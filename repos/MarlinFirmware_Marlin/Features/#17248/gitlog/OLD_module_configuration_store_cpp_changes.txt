commit 18adfe87bcd516436db001b53a0e09e58246c9e2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 7 20:51:40 2020 -0500

    configuration_store => settings

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
deleted file mode 100644
index 28e15cfeb0..0000000000
--- a/Marlin/src/module/configuration_store.cpp
+++ /dev/null
@@ -1,3709 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * configuration_store.cpp
- *
- * Settings and EEPROM storage
- *
- * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
- * in the functions below, also increment the version number. This makes sure that
- * the default values are used whenever there is a change to the data, to prevent
- * wrong data being written to the variables.
- *
- * ALSO: Variables in the Store and Retrieve sections must be in the same order.
- *       If a feature is disabled, some data must still be written that, when read,
- *       either sets a Sane Default, or results in No Change to the existing value.
- *
- */
-
-// Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V81"
-#define EEPROM_OFFSET 100
-
-// Check the integrity of data offsets.
-// Can be disabled for production build.
-//#define DEBUG_EEPROM_READWRITE
-
-#include "configuration_store.h"
-
-#include "endstops.h"
-#include "planner.h"
-#include "stepper.h"
-#include "temperature.h"
-
-#if ENABLED(DWIN_CREALITY_LCD)
-  #include "../lcd/dwin/dwin.h"
-#endif
-
-#include "../lcd/ultralcd.h"
-#include "../libs/vector_3.h"   // for matrix_3x3
-#include "../gcode/gcode.h"
-#include "../MarlinCore.h"
-
-#if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
-  #include "../HAL/shared/eeprom_api.h"
-#endif
-
-#include "probe.h"
-
-#if HAS_LEVELING
-  #include "../feature/bedlevel/bedlevel.h"
-#endif
-
-#if ENABLED(Z_STEPPER_AUTO_ALIGN)
-  #include "../feature/z_stepper_align.h"
-#endif
-
-#if ENABLED(EXTENSIBLE_UI)
-  #include "../lcd/extui/ui_api.h"
-#endif
-
-#if HAS_SERVOS
-  #include "servo.h"
-#endif
-
-#if HAS_SERVOS && HAS_SERVO_ANGLES
-  #define EEPROM_NUM_SERVOS NUM_SERVOS
-#else
-  #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
-#endif
-
-#include "../feature/fwretract.h"
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/powerloss.h"
-#endif
-
-#if HAS_POWER_MONITOR
-  #include "../feature/power_monitor.h"
-#endif
-
-#include "../feature/pause.h"
-
-#if ENABLED(BACKLASH_COMPENSATION)
-  #include "../feature/backlash.h"
-#endif
-
-#if HAS_FILAMENT_SENSOR
-  #include "../feature/runout.h"
-#endif
-
-#if ENABLED(EXTRA_LIN_ADVANCE_K)
-  extern float other_extruder_advance_K[EXTRUDERS];
-#endif
-
-#if EXTRUDERS > 1
-  #include "tool_change.h"
-  void M217_report(const bool eeprom);
-#endif
-
-#if ENABLED(BLTOUCH)
-  #include "../feature/bltouch.h"
-#endif
-
-#if HAS_TRINAMIC_CONFIG
-  #include "stepper/indirection.h"
-  #include "../feature/tmc_util.h"
-#endif
-
-#if ENABLED(PROBE_TEMP_COMPENSATION)
-  #include "../feature/probe_temp_comp.h"
-#endif
-
-#include "../feature/controllerfan.h"
-#if ENABLED(CONTROLLER_FAN_EDITABLE)
-  void M710_report(const bool forReplay);
-#endif
-
-#if ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
-  #include "../feature/caselight.h"
-  #define HAS_CASE_LIGHT_BRIGHTNESS 1
-#endif
-
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  #include "../lcd/tft/touch.h"
-#endif
-
-#pragma pack(push, 1) // No padding between variables
-
-typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
-typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
-typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
-
-// Limit an index to an array size
-#define ALIM(I,ARR) _MIN(I, signed(COUNT(ARR) - 1))
-
-// Defaults for reset / fill in on load
-static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
-static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
-static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
-
-extern const char SP_X_STR[], SP_Y_STR[], SP_Z_STR[], SP_E_STR[];
-
-/**
- * Current EEPROM Layout
- *
- * Keep this data structure up to date so
- * EEPROM size is known at compile time!
- */
-typedef struct SettingsDataStruct {
-  char      version[4];                                 // Vnn\0
-  uint16_t  crc;                                        // Data Checksum
-
-  //
-  // DISTINCT_E_FACTORS
-  //
-  uint8_t   esteppers;                                  // XYZE_N - XYZ
-
-  planner_settings_t planner_settings;
-
-  xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
-  float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
-
-  xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
-
-  #if HAS_HOTEND_OFFSET
-    xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
-  #endif
-
-  //
-  // FILAMENT_RUNOUT_SENSOR
-  //
-  bool runout_sensor_enabled;                           // M412 S
-  float runout_distance_mm;                             // M412 D
-
-  //
-  // ENABLE_LEVELING_FADE_HEIGHT
-  //
-  float planner_z_fade_height;                          // M420 Zn  planner.z_fade_height
-
-  //
-  // MESH_BED_LEVELING
-  //
-  float mbl_z_offset;                                   // mbl.z_offset
-  uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // mbl.z_values
-                    [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
-
-  //
-  // HAS_BED_PROBE
-  //
-
-  xyz_pos_t probe_offset;
-
-  //
-  // ABL_PLANAR
-  //
-  matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
-
-  //
-  // AUTO_BED_LEVELING_BILINEAR
-  //
-  uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
-  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-    bed_mesh_t z_values;                                // G29
-  #else
-    float z_values[3][3];
-  #endif
-
-  //
-  // AUTO_BED_LEVELING_UBL
-  //
-  bool planner_leveling_active;                         // M420 S  planner.leveling_active
-  int8_t ubl_storage_slot;                              // ubl.storage_slot
-
-  //
-  // SERVO_ANGLES
-  //
-  uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
-
-  //
-  // Temperature first layer compensation values
-  //
-  #if ENABLED(PROBE_TEMP_COMPENSATION)
-    int16_t z_offsets_probe[COUNT(temp_comp.z_offsets_probe)], // M871 P I V
-            z_offsets_bed[COUNT(temp_comp.z_offsets_bed)]      // M871 B I V
-            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-              , z_offsets_ext[COUNT(temp_comp.z_offsets_ext)]  // M871 E I V
-            #endif
-            ;
-  #endif
-
-  //
-  // BLTOUCH
-  //
-  bool bltouch_last_written_mode;
-
-  //
-  // DELTA / [XYZ]_DUAL_ENDSTOPS
-  //
-  #if ENABLED(DELTA)
-    float delta_height;                                 // M666 H
-    abc_float_t delta_endstop_adj;                      // M666 X Y Z
-    float delta_radius,                                 // M665 R
-          delta_diagonal_rod,                           // M665 L
-          delta_segments_per_second;                    // M665 S
-    abc_float_t delta_tower_angle_trim,                 // M665 X Y Z
-                delta_diagonal_rod_trim;                // M665 A B C
-  #elif HAS_EXTRA_ENDSTOPS
-    float x2_endstop_adj,                               // M666 X
-          y2_endstop_adj,                               // M666 Y
-          z2_endstop_adj,                               // M666 (S2) Z
-          z3_endstop_adj,                               // M666 (S3) Z
-          z4_endstop_adj;                               // M666 (S4) Z
-  #endif
-
-  //
-  // Z_STEPPER_AUTO_ALIGN, Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
-  //
-  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
-    xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
-    #endif
-  #endif
-
-  //
-  // Material Presets
-  //
-  #if PREHEAT_COUNT
-    preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
-  #endif
-
-  //
-  // PIDTEMP
-  //
-  PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
-  int16_t lpq_len;                                      // M301 L
-
-  //
-  // PIDTEMPBED
-  //
-  PID_t bedPID;                                         // M304 PID / M303 E-1 U
-
-  //
-  // User-defined Thermistors
-  //
-  #if HAS_USER_THERMISTORS
-    user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
-  #endif
-
-  //
-  // Power monitor
-  //
-  uint8_t power_monitor_flags;                          // M430 I V W
-
-  //
-  // HAS_LCD_CONTRAST
-  //
-  int16_t lcd_contrast;                                 // M250 C
-
-  //
-  // Controller fan settings
-  //
-  controllerFan_settings_t controllerFan_settings;      // M710
-
-  //
-  // POWER_LOSS_RECOVERY
-  //
-  bool recovery_enabled;                                // M413 S
-
-  //
-  // FWRETRACT
-  //
-  fwretract_settings_t fwretract_settings;              // M207 S F Z W, M208 S F W R
-  bool autoretract_enabled;                             // M209 S
-
-  //
-  // !NO_VOLUMETRIC
-  //
-  bool parser_volumetric_enabled;                       // M200 S  parser.volumetric_enabled
-  float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
-  float planner_volumetric_extruder_limit[EXTRUDERS];   // M200 T L  planner.volumetric_extruder_limit[]
-
-  //
-  // HAS_TRINAMIC_CONFIG
-  //
-  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2 Y2 Z2 Z3 Z4
-  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-
-  //
-  // LIN_ADVANCE
-  //
-  float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
-
-  //
-  // HAS_MOTOR_CURRENT_PWM
-  //
-  uint32_t motor_current_setting[3];                    // M907 X Z E
-
-  //
-  // CNC_COORDINATE_SYSTEMS
-  //
-  xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
-
-  //
-  // SKEW_CORRECTION
-  //
-  skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
-
-  //
-  // ADVANCED_PAUSE_FEATURE
-  //
-  #if EXTRUDERS
-    fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
-  #endif
-
-  //
-  // Tool-change settings
-  //
-  #if EXTRUDERS > 1
-    toolchange_settings_t toolchange_settings;          // M217 S P R
-  #endif
-
-  //
-  // BACKLASH_COMPENSATION
-  //
-  xyz_float_t backlash_distance_mm;                     // M425 X Y Z
-  uint8_t backlash_correction;                          // M425 F
-  float backlash_smoothing_mm;                          // M425 S
-
-  //
-  // EXTENSIBLE_UI
-  //
-  #if ENABLED(EXTENSIBLE_UI)
-    // This is a significant hardware change; don't reserve space when not present
-    uint8_t extui_data[ExtUI::eeprom_data_size];
-  #endif
-
-  //
-  // HAS_CASE_LIGHT_BRIGHTNESS
-  //
-  #if HAS_CASE_LIGHT_BRIGHTNESS
-    uint8_t caselight_brightness;                        // M355 P
-  #endif
-
-  //
-  // TOUCH_SCREEN_CALIBRATION
-  //
-  #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-    touch_calibration_t touch_calibration;
-  #endif
-
-} SettingsData;
-
-//static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
-
-MarlinSettings settings;
-
-uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
-
-/**
- * Post-process after Retrieve or Reset
- */
-
-#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-  float new_z_fade_height;
-#endif
-
-void MarlinSettings::postprocess() {
-  xyze_pos_t oldpos = current_position;
-
-  // steps per s2 needs to be updated to agree with units per s2
-  planner.reset_acceleration_rates();
-
-  // Make sure delta kinematics are updated before refreshing the
-  // planner position so the stepper counts will be set correctly.
-  TERN_(DELTA, recalc_delta_settings());
-
-  TERN_(PIDTEMP, thermalManager.updatePID());
-
-  #if DISABLED(NO_VOLUMETRICS)
-    planner.calculate_volumetric_multipliers();
-  #elif EXTRUDERS
-    for (uint8_t i = COUNT(planner.e_factor); i--;)
-      planner.refresh_e_factor(i);
-  #endif
-
-  // Software endstops depend on home_offset
-  LOOP_XYZ(i) {
-    update_workspace_offset((AxisEnum)i);
-    update_software_endstops((AxisEnum)i);
-  }
-
-  TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
-
-  TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
-
-  TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
-
-  TERN_(FWRETRACT, fwretract.refresh_autoretract());
-
-  TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
-
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.update_brightness());
-
-  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
-  // and init stepper.count[], planner.position[] with current_position
-  planner.refresh_positioning();
-
-  // Various factors can change the current position
-  if (oldpos != current_position)
-    report_current_position();
-}
-
-#if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
-  #include "printcounter.h"
-  static_assert(
-    !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
-    !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
-    "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
-  );
-#endif
-
-#if ENABLED(SD_FIRMWARE_UPDATE)
-
-  #if ENABLED(EEPROM_SETTINGS)
-    static_assert(
-      !WITHIN(SD_FIRMWARE_UPDATE_EEPROM_ADDR, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
-      "SD_FIRMWARE_UPDATE_EEPROM_ADDR collides with EEPROM settings storage."
-    );
-  #endif
-
-  bool MarlinSettings::sd_update_status() {
-    uint8_t val;
-    persistentStore.read_data(SD_FIRMWARE_UPDATE_EEPROM_ADDR, &val);
-    return (val == SD_FIRMWARE_UPDATE_ACTIVE_VALUE);
-  }
-
-  bool MarlinSettings::set_sd_update_status(const bool enable) {
-    if (enable != sd_update_status())
-      persistentStore.write_data(
-        SD_FIRMWARE_UPDATE_EEPROM_ADDR,
-        enable ? SD_FIRMWARE_UPDATE_ACTIVE_VALUE : SD_FIRMWARE_UPDATE_INACTIVE_VALUE
-      );
-    return true;
-  }
-
-#endif // SD_FIRMWARE_UPDATE
-
-#ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
-  static_assert(
-      EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
-      "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data."
-    );
-#endif
-
-#define DEBUG_OUT ENABLED(EEPROM_CHITCHAT)
-#include "../core/debug_out.h"
-
-#if ENABLED(EEPROM_SETTINGS)
-
-  #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
-                                  int eeprom_index = EEPROM_OFFSET
-  #define EEPROM_FINISH()         persistentStore.access_finish()
-  #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
-  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
-  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)
-  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               }while(0)
-  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
-
-  #if ENABLED(DEBUG_EEPROM_READWRITE)
-    #define _FIELD_TEST(FIELD) \
-      EEPROM_ASSERT( \
-        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
-        "Field " STRINGIFY(FIELD) " mismatch." \
-      )
-  #else
-    #define _FIELD_TEST(FIELD) NOOP
-  #endif
-
-  const char version[4] = EEPROM_VERSION;
-
-  bool MarlinSettings::eeprom_error, MarlinSettings::validating;
-
-  bool MarlinSettings::size_error(const uint16_t size) {
-    if (size != datasize()) {
-      DEBUG_ERROR_MSG("EEPROM datasize error.");
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * M500 - Store Configuration
-   */
-  bool MarlinSettings::save() {
-    float dummyf = 0;
-    char ver[4] = "ERR";
-
-    uint16_t working_crc = 0;
-
-    EEPROM_START();
-
-    eeprom_error = false;
-
-    // Write or Skip version. (Flash doesn't allow rewrite without erase.)
-    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
-
-    EEPROM_SKIP(working_crc); // Skip the checksum slot
-
-    working_crc = 0; // clear before first "real data"
-
-    _FIELD_TEST(esteppers);
-
-    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - XYZ;
-    EEPROM_WRITE(esteppers);
-
-    //
-    // Planner Motion
-    //
-    {
-      EEPROM_WRITE(planner.settings);
-
-      #if HAS_CLASSIC_JERK
-        EEPROM_WRITE(planner.max_jerk);
-        #if HAS_LINEAR_E_JERK
-          dummyf = float(DEFAULT_EJERK);
-          EEPROM_WRITE(dummyf);
-        #endif
-      #else
-        const xyze_pos_t planner_max_jerk = { 10, 10, 0.4, float(DEFAULT_EJERK) };
-        EEPROM_WRITE(planner_max_jerk);
-      #endif
-
-      TERN_(CLASSIC_JERK, dummyf = 0.02f);
-      EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
-    }
-
-    //
-    // Home Offset
-    //
-    {
-      _FIELD_TEST(home_offset);
-
-      #if HAS_SCARA_OFFSET
-        EEPROM_WRITE(scara_home_offset);
-      #else
-        #if !HAS_HOME_OFFSET
-          const xyz_pos_t home_offset{0};
-        #endif
-        EEPROM_WRITE(home_offset);
-      #endif
-
-      #if HAS_HOTEND_OFFSET
-        // Skip hotend 0 which must be 0
-        LOOP_S_L_N(e, 1, HOTENDS)
-          EEPROM_WRITE(hotend_offset[e]);
-      #endif
-    }
-
-    //
-    // Filament Runout Sensor
-    //
-    {
-      #if HAS_FILAMENT_SENSOR
-        const bool &runout_sensor_enabled = runout.enabled;
-      #else
-        constexpr bool runout_sensor_enabled = true;
-      #endif
-      #if HAS_FILAMENT_RUNOUT_DISTANCE
-        const float &runout_distance_mm = runout.runout_distance();
-      #else
-        constexpr float runout_distance_mm = 0;
-      #endif
-      _FIELD_TEST(runout_sensor_enabled);
-      EEPROM_WRITE(runout_sensor_enabled);
-      EEPROM_WRITE(runout_distance_mm);
-    }
-
-    //
-    // Global Leveling
-    //
-    {
-      const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, 10.0f);
-      EEPROM_WRITE(zfh);
-    }
-
-    //
-    // Mesh Bed Leveling
-    //
-    {
-      #if ENABLED(MESH_BED_LEVELING)
-        static_assert(
-          sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
-          "MBL Z array is the wrong size."
-        );
-      #else
-        dummyf = 0;
-      #endif
-
-      const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
-                    mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
-
-      EEPROM_WRITE(TERN(MESH_BED_LEVELING, mbl.z_offset, dummyf));
-      EEPROM_WRITE(mesh_num_x);
-      EEPROM_WRITE(mesh_num_y);
-
-      #if ENABLED(MESH_BED_LEVELING)
-        EEPROM_WRITE(mbl.z_values);
-      #else
-        for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
-      #endif
-    }
-
-    //
-    // Probe XYZ Offsets
-    //
-    {
-      _FIELD_TEST(probe_offset);
-      #if HAS_BED_PROBE
-        const xyz_pos_t &zpo = probe.offset;
-      #else
-        constexpr xyz_pos_t zpo{0};
-      #endif
-      EEPROM_WRITE(zpo);
-    }
-
-    //
-    // Planar Bed Leveling matrix
-    //
-    {
-      #if ABL_PLANAR
-        EEPROM_WRITE(planner.bed_level_matrix);
-      #else
-        dummyf = 0;
-        for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
-      #endif
-    }
-
-    //
-    // Bilinear Auto Bed Leveling
-    //
-    {
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        static_assert(
-          sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
-          "Bilinear Z array is the wrong size."
-        );
-      #else
-        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
-      #endif
-
-      const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
-                    grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
-      EEPROM_WRITE(grid_max_x);
-      EEPROM_WRITE(grid_max_y);
-      EEPROM_WRITE(bilinear_grid_spacing);
-      EEPROM_WRITE(bilinear_start);
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        EEPROM_WRITE(z_values);              // 9-256 floats
-      #else
-        dummyf = 0;
-        for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
-      #endif
-    }
-
-    //
-    // Unified Bed Leveling
-    //
-    {
-      _FIELD_TEST(planner_leveling_active);
-      const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
-      const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
-      EEPROM_WRITE(ubl_active);
-      EEPROM_WRITE(storage_slot);
-    }
-
-    //
-    // Servo Angles
-    //
-    {
-      _FIELD_TEST(servo_angles);
-      #if !HAS_SERVO_ANGLES
-        uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
-      #endif
-      EEPROM_WRITE(servo_angles);
-    }
-
-    //
-    // Thermal first layer compensation values
-    //
-    #if ENABLED(PROBE_TEMP_COMPENSATION)
-      EEPROM_WRITE(temp_comp.z_offsets_probe);
-      EEPROM_WRITE(temp_comp.z_offsets_bed);
-      #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-        EEPROM_WRITE(temp_comp.z_offsets_ext);
-      #endif
-    #else
-      // No placeholder data for this feature
-    #endif
-
-    //
-    // BLTOUCH
-    //
-    {
-      _FIELD_TEST(bltouch_last_written_mode);
-      const bool bltouch_last_written_mode = TERN(BLTOUCH, bltouch.last_written_mode, false);
-      EEPROM_WRITE(bltouch_last_written_mode);
-    }
-
-    //
-    // DELTA Geometry or Dual Endstops offsets
-    //
-    {
-      #if ENABLED(DELTA)
-
-        _FIELD_TEST(delta_height);
-
-        EEPROM_WRITE(delta_height);              // 1 float
-        EEPROM_WRITE(delta_endstop_adj);         // 3 floats
-        EEPROM_WRITE(delta_radius);              // 1 float
-        EEPROM_WRITE(delta_diagonal_rod);        // 1 float
-        EEPROM_WRITE(delta_segments_per_second); // 1 float
-        EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
-        EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
-
-      #elif HAS_EXTRA_ENDSTOPS
-
-        _FIELD_TEST(x2_endstop_adj);
-
-        // Write dual endstops in X, Y, Z order. Unused = 0.0
-        dummyf = 0;
-        EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
-        EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
-        EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
-
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
-          EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
-
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
-          EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
-
-      #endif
-    }
-
-    #if ENABLED(Z_STEPPER_AUTO_ALIGN)
-      EEPROM_WRITE(z_stepper_align.xy);
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-        EEPROM_WRITE(z_stepper_align.stepper_xy);
-      #endif
-    #endif
-
-    //
-    // LCD Preheat settings
-    //
-    #if PREHEAT_COUNT
-      _FIELD_TEST(ui_material_preset);
-      EEPROM_WRITE(ui.material_preset);
-    #endif
-
-    //
-    // PIDTEMP
-    //
-    {
-      _FIELD_TEST(hotendPID);
-      HOTEND_LOOP() {
-        PIDCF_t pidcf = {
-          #if DISABLED(PIDTEMP)
-            NAN, NAN, NAN,
-            NAN, NAN
-          #else
-                         PID_PARAM(Kp, e),
-            unscalePID_i(PID_PARAM(Ki, e)),
-            unscalePID_d(PID_PARAM(Kd, e)),
-                         PID_PARAM(Kc, e),
-                         PID_PARAM(Kf, e)
-          #endif
-        };
-        EEPROM_WRITE(pidcf);
-      }
-
-      _FIELD_TEST(lpq_len);
-      #if DISABLED(PID_EXTRUSION_SCALING)
-        const int16_t lpq_len = 20;
-      #endif
-      EEPROM_WRITE(TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, lpq_len));
-    }
-
-    //
-    // PIDTEMPBED
-    //
-    {
-      _FIELD_TEST(bedPID);
-
-      const PID_t bed_pid = {
-        #if DISABLED(PIDTEMPBED)
-          NAN, NAN, NAN
-        #else
-          // Store the unscaled PID values
-          thermalManager.temp_bed.pid.Kp,
-          unscalePID_i(thermalManager.temp_bed.pid.Ki),
-          unscalePID_d(thermalManager.temp_bed.pid.Kd)
-        #endif
-      };
-      EEPROM_WRITE(bed_pid);
-    }
-
-    //
-    // User-defined Thermistors
-    //
-    #if HAS_USER_THERMISTORS
-    {
-      _FIELD_TEST(user_thermistor);
-      EEPROM_WRITE(thermalManager.user_thermistor);
-    }
-    #endif
-
-    //
-    // Power monitor
-    //
-    {
-      #if HAS_POWER_MONITOR
-        const uint8_t &power_monitor_flags = power_monitor.flags;
-      #else
-        constexpr uint8_t power_monitor_flags = 0x00;
-      #endif
-      _FIELD_TEST(power_monitor_flags);
-      EEPROM_WRITE(power_monitor_flags);
-    }
-
-    //
-    // LCD Contrast
-    //
-    {
-      _FIELD_TEST(lcd_contrast);
-
-      const int16_t lcd_contrast =
-        #if HAS_LCD_CONTRAST
-          ui.contrast
-        #else
-          127
-        #endif
-      ;
-      EEPROM_WRITE(lcd_contrast);
-    }
-
-    //
-    // Controller Fan
-    //
-    {
-      _FIELD_TEST(controllerFan_settings);
-      #if ENABLED(USE_CONTROLLER_FAN)
-        const controllerFan_settings_t &cfs = controllerFan.settings;
-      #else
-        controllerFan_settings_t cfs = controllerFan_defaults;
-      #endif
-      EEPROM_WRITE(cfs);
-    }
-
-    //
-    // Power-Loss Recovery
-    //
-    {
-      _FIELD_TEST(recovery_enabled);
-      const bool recovery_enabled = TERN(POWER_LOSS_RECOVERY, recovery.enabled, ENABLED(PLR_ENABLED_DEFAULT));
-      EEPROM_WRITE(recovery_enabled);
-    }
-
-    //
-    // Firmware Retraction
-    //
-    {
-      _FIELD_TEST(fwretract_settings);
-      #if DISABLED(FWRETRACT)
-        const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
-      #endif
-      EEPROM_WRITE(TERN(FWRETRACT, fwretract.settings, autoretract_defaults));
-
-      #if DISABLED(FWRETRACT_AUTORETRACT)
-        const bool autoretract_enabled = false;
-      #endif
-      EEPROM_WRITE(TERN(FWRETRACT_AUTORETRACT, fwretract.autoretract_enabled, autoretract_enabled));
-    }
-
-    //
-    // Volumetric & Filament Size
-    //
-    {
-      _FIELD_TEST(parser_volumetric_enabled);
-
-      #if DISABLED(NO_VOLUMETRICS)
-
-        EEPROM_WRITE(parser.volumetric_enabled);
-        EEPROM_WRITE(planner.filament_size);
-        #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-          EEPROM_WRITE(planner.volumetric_extruder_limit);
-        #else
-          dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
-          for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
-        #endif
-
-      #else
-
-        const bool volumetric_enabled = false;
-        EEPROM_WRITE(volumetric_enabled);
-        dummyf = DEFAULT_NOMINAL_FILAMENT_DIA;
-        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
-        dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
-        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
-
-      #endif
-    }
-
-    //
-    // TMC Configuration
-    //
-    {
-      _FIELD_TEST(tmc_stepper_current);
-
-      tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-
-      #if HAS_TRINAMIC_CONFIG
-        #if AXIS_IS_TMC(X)
-          tmc_stepper_current.X = stepperX.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Y)
-          tmc_stepper_current.Y = stepperY.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Z)
-          tmc_stepper_current.Z = stepperZ.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(X2)
-          tmc_stepper_current.X2 = stepperX2.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          tmc_stepper_current.Y2 = stepperY2.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Z2)
-          tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Z3)
-          tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Z4)
-          tmc_stepper_current.Z4 = stepperZ4.getMilliamps();
-        #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_IS_TMC(E0)
-            tmc_stepper_current.E0 = stepperE0.getMilliamps();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_IS_TMC(E1)
-              tmc_stepper_current.E1 = stepperE1.getMilliamps();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_IS_TMC(E2)
-                tmc_stepper_current.E2 = stepperE2.getMilliamps();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_IS_TMC(E3)
-                  tmc_stepper_current.E3 = stepperE3.getMilliamps();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_IS_TMC(E4)
-                    tmc_stepper_current.E4 = stepperE4.getMilliamps();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_IS_TMC(E5)
-                      tmc_stepper_current.E5 = stepperE5.getMilliamps();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_IS_TMC(E6)
-                        tmc_stepper_current.E6 = stepperE6.getMilliamps();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_IS_TMC(E7)
-                          tmc_stepper_current.E7 = stepperE7.getMilliamps();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
-      #endif
-      EEPROM_WRITE(tmc_stepper_current);
-    }
-
-    //
-    // TMC Hybrid Threshold, and placeholder values
-    //
-    {
-      _FIELD_TEST(tmc_hybrid_threshold);
-
-      #if ENABLED(HYBRID_THRESHOLD)
-       tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-        #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_hybrid_threshold.X = stepperX.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_hybrid_threshold.Y = stepperY.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_hybrid_threshold.Z = stepperZ.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs();
-        #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
-      #else
-        const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
-          .X  = 100, .Y  = 100, .Z  =   3,
-          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
-          .E0 =  30, .E1 =  30, .E2 =  30,
-          .E3 =  30, .E4 =  30, .E5 =  30
-        };
-      #endif
-      EEPROM_WRITE(tmc_hybrid_threshold);
-    }
-
-    //
-    // TMC StallGuard threshold
-    //
-    {
-      tmc_sgt_t tmc_sgt{0};
-      #if USE_SENSORLESS
-        TERN_(X_SENSORLESS,  tmc_sgt.X  = stepperX.homing_threshold());
-        TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
-        TERN_(Y_SENSORLESS,  tmc_sgt.Y  = stepperY.homing_threshold());
-        TERN_(Y2_SENSORLESS, tmc_sgt.Y2 = stepperY2.homing_threshold());
-        TERN_(Z_SENSORLESS,  tmc_sgt.Z  = stepperZ.homing_threshold());
-        TERN_(Z2_SENSORLESS, tmc_sgt.Z2 = stepperZ2.homing_threshold());
-        TERN_(Z3_SENSORLESS, tmc_sgt.Z3 = stepperZ3.homing_threshold());
-        TERN_(Z4_SENSORLESS, tmc_sgt.Z4 = stepperZ4.homing_threshold());
-      #endif
-      EEPROM_WRITE(tmc_sgt);
-    }
-
-    //
-    // TMC stepping mode
-    //
-    {
-      _FIELD_TEST(tmc_stealth_enabled);
-
-      tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
-
-      #if HAS_STEALTHCHOP
-        #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_stealth_enabled.X = stepperX.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_stealth_enabled.Y = stepperY.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_stealth_enabled.Z = stepperZ.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_stealth_enabled.X2 = stepperX2.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_stealth_enabled.Y2 = stepperY2.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_stealth_enabled.Z2 = stepperZ2.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_stealth_enabled.Z3 = stepperZ3.get_stealthChop_status();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_stealth_enabled.Z4 = stepperZ4.get_stealthChop_status();
-        #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_stealth_enabled.E0 = stepperE0.get_stealthChop_status();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_stealth_enabled.E1 = stepperE1.get_stealthChop_status();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_stealth_enabled.E2 = stepperE2.get_stealthChop_status();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_stealth_enabled.E3 = stepperE3.get_stealthChop_status();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_stealth_enabled.E4 = stepperE4.get_stealthChop_status();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_stealth_enabled.E5 = stepperE5.get_stealthChop_status();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_stealth_enabled.E6 = stepperE6.get_stealthChop_status();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_stealth_enabled.E7 = stepperE7.get_stealthChop_status();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
-      #endif
-      EEPROM_WRITE(tmc_stealth_enabled);
-    }
-
-    //
-    // Linear Advance
-    //
-    {
-      _FIELD_TEST(planner_extruder_advance_K);
-
-      #if ENABLED(LIN_ADVANCE)
-        EEPROM_WRITE(planner.extruder_advance_K);
-      #else
-        dummyf = 0;
-        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummyf);
-      #endif
-    }
-
-    //
-    // Motor Current PWM
-    //
-    {
-      _FIELD_TEST(motor_current_setting);
-
-      #if HAS_MOTOR_CURRENT_PWM
-        EEPROM_WRITE(stepper.motor_current_setting);
-      #else
-        const uint32_t no_current[3] = { 0 };
-        EEPROM_WRITE(no_current);
-      #endif
-    }
-
-    //
-    // CNC Coordinate Systems
-    //
-
-    _FIELD_TEST(coordinate_system);
-
-    #if DISABLED(CNC_COORDINATE_SYSTEMS)
-      const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
-    #endif
-    EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
-
-    //
-    // Skew correction factors
-    //
-    _FIELD_TEST(planner_skew_factor);
-    EEPROM_WRITE(planner.skew_factor);
-
-    //
-    // Advanced Pause filament load & unload lengths
-    //
-    #if EXTRUDERS
-    {
-      #if DISABLED(ADVANCED_PAUSE_FEATURE)
-        const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
-      #endif
-      _FIELD_TEST(fc_settings);
-      EEPROM_WRITE(fc_settings);
-    }
-    #endif
-
-    //
-    // Multiple Extruders
-    //
-
-    #if EXTRUDERS > 1
-      _FIELD_TEST(toolchange_settings);
-      EEPROM_WRITE(toolchange_settings);
-    #endif
-
-    //
-    // Backlash Compensation
-    //
-    {
-      #if ENABLED(BACKLASH_GCODE)
-        const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
-        const uint8_t &backlash_correction = backlash.correction;
-      #else
-        const xyz_float_t backlash_distance_mm{0};
-        const uint8_t backlash_correction = 0;
-      #endif
-      #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
-        const float &backlash_smoothing_mm = backlash.smoothing_mm;
-      #else
-        const float backlash_smoothing_mm = 3;
-      #endif
-      _FIELD_TEST(backlash_distance_mm);
-      EEPROM_WRITE(backlash_distance_mm);
-      EEPROM_WRITE(backlash_correction);
-      EEPROM_WRITE(backlash_smoothing_mm);
-    }
-
-    //
-    // Extensible UI User Data
-    //
-    #if ENABLED(EXTENSIBLE_UI)
-      {
-        char extui_data[ExtUI::eeprom_data_size] = { 0 };
-        ExtUI::onStoreSettings(extui_data);
-        _FIELD_TEST(extui_data);
-        EEPROM_WRITE(extui_data);
-      }
-    #endif
-
-    //
-    // Case Light Brightness
-    //
-    #if HAS_CASE_LIGHT_BRIGHTNESS
-      EEPROM_WRITE(caselight.brightness);
-    #endif
-
-    //
-    // TOUCH_SCREEN_CALIBRATION
-    //
-    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-      EEPROM_WRITE(touch.calibration);
-    #endif
-
-    //
-    // Validate CRC and Data Size
-    //
-    if (!eeprom_error) {
-      const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
-                     final_crc = working_crc;
-
-      // Write the EEPROM header
-      eeprom_index = EEPROM_OFFSET;
-
-      EEPROM_WRITE(version);
-      EEPROM_WRITE(final_crc);
-
-      // Report storage size
-      DEBUG_ECHO_START();
-      DEBUG_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
-
-      eeprom_error |= size_error(eeprom_size);
-    }
-    EEPROM_FINISH();
-
-    //
-    // UBL Mesh
-    //
-    #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
-      if (ubl.storage_slot >= 0)
-        store_mesh(ubl.storage_slot);
-    #endif
-
-    if (!eeprom_error) LCD_MESSAGEPGM(MSG_SETTINGS_STORED);
-
-    TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
-
-    return !eeprom_error;
-  }
-
-  /**
-   * M501 - Retrieve Configuration
-   */
-  bool MarlinSettings::_load() {
-    uint16_t working_crc = 0;
-
-    EEPROM_START();
-
-    char stored_ver[4];
-    EEPROM_READ_ALWAYS(stored_ver);
-
-    uint16_t stored_crc;
-    EEPROM_READ_ALWAYS(stored_crc);
-
-    // Version has to match or defaults are used
-    if (strncmp(version, stored_ver, 3) != 0) {
-      if (stored_ver[3] != '\0') {
-        stored_ver[0] = '?';
-        stored_ver[1] = '\0';
-      }
-      DEBUG_ECHO_START();
-      DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_version());
-      eeprom_error = true;
-    }
-    else {
-      float dummyf = 0;
-      working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
-
-      _FIELD_TEST(esteppers);
-
-      // Number of esteppers may change
-      uint8_t esteppers;
-      EEPROM_READ_ALWAYS(esteppers);
-
-      //
-      // Planner Motion
-      //
-      {
-        // Get only the number of E stepper parameters previously stored
-        // Any steppers added later are set to their defaults
-        uint32_t tmp1[XYZ + esteppers];
-        float tmp2[XYZ + esteppers];
-        feedRate_t tmp3[XYZ + esteppers];
-        EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
-        EEPROM_READ(planner.settings.min_segment_time_us);
-        EEPROM_READ(tmp2);                         // axis_steps_per_mm
-        EEPROM_READ(tmp3);                         // max_feedrate_mm_s
-
-        if (!validating) LOOP_XYZE_N(i) {
-          const bool in = (i < esteppers + XYZ);
-          planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
-          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
-          planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
-        }
-
-        EEPROM_READ(planner.settings.acceleration);
-        EEPROM_READ(planner.settings.retract_acceleration);
-        EEPROM_READ(planner.settings.travel_acceleration);
-        EEPROM_READ(planner.settings.min_feedrate_mm_s);
-        EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
-
-        #if HAS_CLASSIC_JERK
-          EEPROM_READ(planner.max_jerk);
-          #if HAS_LINEAR_E_JERK
-            EEPROM_READ(dummyf);
-          #endif
-        #else
-          for (uint8_t q = 4; q--;) EEPROM_READ(dummyf);
-        #endif
-
-        EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
-      }
-
-      //
-      // Home Offset (M206 / M665)
-      //
-      {
-        _FIELD_TEST(home_offset);
-
-        #if HAS_SCARA_OFFSET
-          EEPROM_READ(scara_home_offset);
-        #else
-          #if !HAS_HOME_OFFSET
-            xyz_pos_t home_offset;
-          #endif
-          EEPROM_READ(home_offset);
-        #endif
-      }
-
-      //
-      // Hotend Offsets, if any
-      //
-      {
-        #if HAS_HOTEND_OFFSET
-          // Skip hotend 0 which must be 0
-          LOOP_S_L_N(e, 1, HOTENDS)
-            EEPROM_READ(hotend_offset[e]);
-        #endif
-      }
-
-      //
-      // Filament Runout Sensor
-      //
-      {
-        #if HAS_FILAMENT_SENSOR
-          const bool &runout_sensor_enabled = runout.enabled;
-        #else
-          bool runout_sensor_enabled;
-        #endif
-        _FIELD_TEST(runout_sensor_enabled);
-        EEPROM_READ(runout_sensor_enabled);
-
-        float runout_distance_mm;
-        EEPROM_READ(runout_distance_mm);
-        #if HAS_FILAMENT_RUNOUT_DISTANCE
-          if (!validating) runout.set_runout_distance(runout_distance_mm);
-        #endif
-      }
-
-      //
-      // Global Leveling
-      //
-      EEPROM_READ(TERN(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height, dummyf));
-
-      //
-      // Mesh (Manual) Bed Leveling
-      //
-      {
-        uint8_t mesh_num_x, mesh_num_y;
-        EEPROM_READ(dummyf);
-        EEPROM_READ_ALWAYS(mesh_num_x);
-        EEPROM_READ_ALWAYS(mesh_num_y);
-
-        #if ENABLED(MESH_BED_LEVELING)
-          if (!validating) mbl.z_offset = dummyf;
-          if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
-            // EEPROM data fits the current mesh
-            EEPROM_READ(mbl.z_values);
-          }
-          else {
-            // EEPROM data is stale
-            if (!validating) mbl.reset();
-            for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
-          }
-        #else
-          // MBL is disabled - skip the stored data
-          for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
-        #endif // MESH_BED_LEVELING
-      }
-
-      //
-      // Probe Z Offset
-      //
-      {
-        _FIELD_TEST(probe_offset);
-        #if HAS_BED_PROBE
-          const xyz_pos_t &zpo = probe.offset;
-        #else
-          xyz_pos_t zpo;
-        #endif
-        EEPROM_READ(zpo);
-      }
-
-      //
-      // Planar Bed Leveling matrix
-      //
-      {
-        #if ABL_PLANAR
-          EEPROM_READ(planner.bed_level_matrix);
-        #else
-          for (uint8_t q = 9; q--;) EEPROM_READ(dummyf);
-        #endif
-      }
-
-      //
-      // Bilinear Auto Bed Leveling
-      //
-      {
-        uint8_t grid_max_x, grid_max_y;
-        EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
-        EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
-        #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
-            if (!validating) set_bed_leveling_enabled(false);
-            EEPROM_READ(bilinear_grid_spacing);        // 2 ints
-            EEPROM_READ(bilinear_start);               // 2 ints
-            EEPROM_READ(z_values);                     // 9 to 256 floats
-          }
-          else // EEPROM data is stale
-        #endif // AUTO_BED_LEVELING_BILINEAR
-          {
-            // Skip past disabled (or stale) Bilinear Grid data
-            xy_pos_t bgs, bs;
-            EEPROM_READ(bgs);
-            EEPROM_READ(bs);
-            for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
-          }
-      }
-
-      //
-      // Unified Bed Leveling active state
-      //
-      {
-        _FIELD_TEST(planner_leveling_active);
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          const bool &planner_leveling_active = planner.leveling_active;
-          const int8_t &ubl_storage_slot = ubl.storage_slot;
-        #else
-          bool planner_leveling_active;
-          int8_t ubl_storage_slot;
-        #endif
-        EEPROM_READ(planner_leveling_active);
-        EEPROM_READ(ubl_storage_slot);
-      }
-
-      //
-      // SERVO_ANGLES
-      //
-      {
-        _FIELD_TEST(servo_angles);
-        #if ENABLED(EDITABLE_SERVO_ANGLES)
-          uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
-        #else
-          uint16_t servo_angles_arr[EEPROM_NUM_SERVOS][2];
-        #endif
-        EEPROM_READ(servo_angles_arr);
-      }
-
-      //
-      // Thermal first layer compensation values
-      //
-      #if ENABLED(PROBE_TEMP_COMPENSATION)
-        EEPROM_READ(temp_comp.z_offsets_probe);
-        EEPROM_READ(temp_comp.z_offsets_bed);
-        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-          EEPROM_READ(temp_comp.z_offsets_ext);
-        #endif
-        temp_comp.reset_index();
-      #else
-        // No placeholder data for this feature
-      #endif
-
-      //
-      // BLTOUCH
-      //
-      {
-        _FIELD_TEST(bltouch_last_written_mode);
-        #if ENABLED(BLTOUCH)
-          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
-        #else
-          bool bltouch_last_written_mode;
-        #endif
-        EEPROM_READ(bltouch_last_written_mode);
-      }
-
-      //
-      // DELTA Geometry or Dual Endstops offsets
-      //
-      {
-        #if ENABLED(DELTA)
-
-          _FIELD_TEST(delta_height);
-
-          EEPROM_READ(delta_height);              // 1 float
-          EEPROM_READ(delta_endstop_adj);         // 3 floats
-          EEPROM_READ(delta_radius);              // 1 float
-          EEPROM_READ(delta_diagonal_rod);        // 1 float
-          EEPROM_READ(delta_segments_per_second); // 1 float
-          EEPROM_READ(delta_tower_angle_trim);    // 3 floats
-          EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
-
-        #elif HAS_EXTRA_ENDSTOPS
-
-          _FIELD_TEST(x2_endstop_adj);
-
-          EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
-          EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
-          EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
-
-          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
-            EEPROM_READ(endstops.z3_endstop_adj); // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
-          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
-            EEPROM_READ(endstops.z4_endstop_adj); // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
-
-        #endif
-      }
-
-      #if ENABLED(Z_STEPPER_AUTO_ALIGN)
-        EEPROM_READ(z_stepper_align.xy);
-        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-          EEPROM_READ(z_stepper_align.stepper_xy);
-        #endif
-      #endif
-
-      //
-      // LCD Preheat settings
-      //
-      #if PREHEAT_COUNT
-        _FIELD_TEST(ui_material_preset);
-        EEPROM_READ(ui.material_preset);
-      #endif
-
-      //
-      // Hotend PID
-      //
-      {
-        HOTEND_LOOP() {
-          PIDCF_t pidcf;
-          EEPROM_READ(pidcf);
-          #if ENABLED(PIDTEMP)
-            if (!validating && !isnan(pidcf.Kp)) {
-              // Scale PID values since EEPROM values are unscaled
-              PID_PARAM(Kp, e) = pidcf.Kp;
-              PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
-              PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
-              TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
-              TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
-            }
-          #endif
-        }
-      }
-
-      //
-      // PID Extrusion Scaling
-      //
-      {
-        _FIELD_TEST(lpq_len);
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          const int16_t &lpq_len = thermalManager.lpq_len;
-        #else
-          int16_t lpq_len;
-        #endif
-        EEPROM_READ(lpq_len);
-      }
-
-      //
-      // Heated Bed PID
-      //
-      {
-        PID_t pid;
-        EEPROM_READ(pid);
-        #if ENABLED(PIDTEMPBED)
-          if (!validating && !isnan(pid.Kp)) {
-            // Scale PID values since EEPROM values are unscaled
-            thermalManager.temp_bed.pid.Kp = pid.Kp;
-            thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
-            thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
-          }
-        #endif
-      }
-
-      //
-      // User-defined Thermistors
-      //
-      #if HAS_USER_THERMISTORS
-      {
-        _FIELD_TEST(user_thermistor);
-        EEPROM_READ(thermalManager.user_thermistor);
-      }
-      #endif
-
-      //
-      // Power monitor
-      //
-      {
-        #if HAS_POWER_MONITOR
-          uint8_t &power_monitor_flags = power_monitor.flags;
-        #else
-          uint8_t power_monitor_flags;
-        #endif
-        _FIELD_TEST(power_monitor_flags);
-        EEPROM_READ(power_monitor_flags);
-      }
-
-      //
-      // LCD Contrast
-      //
-      {
-        _FIELD_TEST(lcd_contrast);
-
-        int16_t lcd_contrast;
-        EEPROM_READ(lcd_contrast);
-        TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
-      }
-
-      //
-      // Controller Fan
-      //
-      {
-        _FIELD_TEST(controllerFan_settings);
-        #if ENABLED(CONTROLLER_FAN_EDITABLE)
-          const controllerFan_settings_t &cfs = controllerFan.settings;
-        #else
-          controllerFan_settings_t cfs = { 0 };
-        #endif
-        EEPROM_READ(cfs);
-      }
-
-      //
-      // Power-Loss Recovery
-      //
-      {
-        _FIELD_TEST(recovery_enabled);
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          const bool &recovery_enabled = recovery.enabled;
-        #else
-          bool recovery_enabled;
-        #endif
-        EEPROM_READ(recovery_enabled);
-      }
-
-      //
-      // Firmware Retraction
-      //
-      {
-        _FIELD_TEST(fwretract_settings);
-
-        #if ENABLED(FWRETRACT)
-          EEPROM_READ(fwretract.settings);
-        #else
-          fwretract_settings_t fwretract_settings;
-          EEPROM_READ(fwretract_settings);
-        #endif
-        #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
-          EEPROM_READ(fwretract.autoretract_enabled);
-        #else
-          bool autoretract_enabled;
-          EEPROM_READ(autoretract_enabled);
-        #endif
-      }
-
-      //
-      // Volumetric & Filament Size
-      //
-      {
-        struct {
-          bool volumetric_enabled;
-          float filament_size[EXTRUDERS];
-          float volumetric_extruder_limit[EXTRUDERS];
-        } storage;
-
-        _FIELD_TEST(parser_volumetric_enabled);
-        EEPROM_READ(storage);
-
-        #if DISABLED(NO_VOLUMETRICS)
-          if (!validating) {
-            parser.volumetric_enabled = storage.volumetric_enabled;
-            COPY(planner.filament_size, storage.filament_size);
-            #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-              COPY(planner.volumetric_extruder_limit, storage.volumetric_extruder_limit);
-            #endif
-          }
-        #endif
-      }
-
-      //
-      // TMC Stepper Settings
-      //
-
-      if (!validating) reset_stepper_drivers();
-
-      // TMC Stepper Current
-      {
-        _FIELD_TEST(tmc_stepper_current);
-
-        tmc_stepper_current_t currents;
-        EEPROM_READ(currents);
-
-        #if HAS_TRINAMIC_CONFIG
-
-          #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
-          if (!validating) {
-            #if AXIS_IS_TMC(X)
-              SET_CURR(X);
-            #endif
-            #if AXIS_IS_TMC(Y)
-              SET_CURR(Y);
-            #endif
-            #if AXIS_IS_TMC(Z)
-              SET_CURR(Z);
-            #endif
-            #if AXIS_IS_TMC(X2)
-              SET_CURR(X2);
-            #endif
-            #if AXIS_IS_TMC(Y2)
-              SET_CURR(Y2);
-            #endif
-            #if AXIS_IS_TMC(Z2)
-              SET_CURR(Z2);
-            #endif
-            #if AXIS_IS_TMC(Z3)
-              SET_CURR(Z3);
-            #endif
-            #if AXIS_IS_TMC(Z4)
-              SET_CURR(Z4);
-            #endif
-            #if AXIS_IS_TMC(E0)
-              SET_CURR(E0);
-            #endif
-            #if AXIS_IS_TMC(E1)
-              SET_CURR(E1);
-            #endif
-            #if AXIS_IS_TMC(E2)
-              SET_CURR(E2);
-            #endif
-            #if AXIS_IS_TMC(E3)
-              SET_CURR(E3);
-            #endif
-            #if AXIS_IS_TMC(E4)
-              SET_CURR(E4);
-            #endif
-            #if AXIS_IS_TMC(E5)
-              SET_CURR(E5);
-            #endif
-            #if AXIS_IS_TMC(E6)
-              SET_CURR(E6);
-            #endif
-            #if AXIS_IS_TMC(E7)
-              SET_CURR(E7);
-            #endif
-          }
-        #endif
-      }
-
-      // TMC Hybrid Threshold
-      {
-        tmc_hybrid_threshold_t tmc_hybrid_threshold;
-        _FIELD_TEST(tmc_hybrid_threshold);
-        EEPROM_READ(tmc_hybrid_threshold);
-
-        #if ENABLED(HYBRID_THRESHOLD)
-          if (!validating) {
-            #if AXIS_HAS_STEALTHCHOP(X)
-              stepperX.set_pwm_thrs(tmc_hybrid_threshold.X);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y)
-              stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z)
-              stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(X2)
-              stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y2)
-              stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z2)
-              stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z3)
-              stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z4)
-              stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E0)
-              stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E2)
-              stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E3)
-              stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E4)
-              stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E5)
-              stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E6)
-              stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E7)
-              stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7);
-            #endif
-          }
-        #endif
-      }
-
-      //
-      // TMC StallGuard threshold.
-      //
-      {
-        tmc_sgt_t tmc_sgt;
-        _FIELD_TEST(tmc_sgt);
-        EEPROM_READ(tmc_sgt);
-        #if USE_SENSORLESS
-          if (!validating) {
-            TERN_(X_SENSORLESS,  stepperX.homing_threshold(tmc_sgt.X));
-            TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
-            TERN_(Y_SENSORLESS,  stepperY.homing_threshold(tmc_sgt.Y));
-            TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(tmc_sgt.Y2));
-            TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(tmc_sgt.Z));
-            TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(tmc_sgt.Z2));
-            TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
-            TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
-          }
-        #endif
-      }
-
-      // TMC stepping mode
-      {
-        _FIELD_TEST(tmc_stealth_enabled);
-
-        tmc_stealth_enabled_t tmc_stealth_enabled;
-        EEPROM_READ(tmc_stealth_enabled);
-
-        #if HAS_TRINAMIC_CONFIG
-
-          #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
-          if (!validating) {
-            #if AXIS_HAS_STEALTHCHOP(X)
-              SET_STEPPING_MODE(X);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y)
-              SET_STEPPING_MODE(Y);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z)
-              SET_STEPPING_MODE(Z);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(X2)
-              SET_STEPPING_MODE(X2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y2)
-              SET_STEPPING_MODE(Y2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z2)
-              SET_STEPPING_MODE(Z2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z3)
-              SET_STEPPING_MODE(Z3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z4)
-              SET_STEPPING_MODE(Z4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E0)
-              SET_STEPPING_MODE(E0);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              SET_STEPPING_MODE(E1);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E2)
-              SET_STEPPING_MODE(E2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E3)
-              SET_STEPPING_MODE(E3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E4)
-              SET_STEPPING_MODE(E4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E5)
-              SET_STEPPING_MODE(E5);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E6)
-              SET_STEPPING_MODE(E6);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E7)
-              SET_STEPPING_MODE(E7);
-            #endif
-          }
-        #endif
-      }
-
-      //
-      // Linear Advance
-      //
-      {
-        float extruder_advance_K[_MAX(EXTRUDERS, 1)];
-        _FIELD_TEST(planner_extruder_advance_K);
-        EEPROM_READ(extruder_advance_K);
-        #if ENABLED(LIN_ADVANCE)
-          if (!validating)
-            COPY(planner.extruder_advance_K, extruder_advance_K);
-        #endif
-      }
-
-      //
-      // Motor Current PWM
-      //
-      {
-        uint32_t motor_current_setting[3];
-        _FIELD_TEST(motor_current_setting);
-        EEPROM_READ(motor_current_setting);
-        #if HAS_MOTOR_CURRENT_PWM
-          if (!validating)
-            COPY(stepper.motor_current_setting, motor_current_setting);
-        #endif
-      }
-
-      //
-      // CNC Coordinate System
-      //
-      {
-        _FIELD_TEST(coordinate_system);
-        #if ENABLED(CNC_COORDINATE_SYSTEMS)
-          if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
-          EEPROM_READ(gcode.coordinate_system);
-        #else
-          xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
-          EEPROM_READ(coordinate_system);
-        #endif
-      }
-
-      //
-      // Skew correction factors
-      //
-      {
-        skew_factor_t skew_factor;
-        _FIELD_TEST(planner_skew_factor);
-        EEPROM_READ(skew_factor);
-        #if ENABLED(SKEW_CORRECTION_GCODE)
-          if (!validating) {
-            planner.skew_factor.xy = skew_factor.xy;
-            #if ENABLED(SKEW_CORRECTION_FOR_Z)
-              planner.skew_factor.xz = skew_factor.xz;
-              planner.skew_factor.yz = skew_factor.yz;
-            #endif
-          }
-        #endif
-      }
-
-      //
-      // Advanced Pause filament load & unload lengths
-      //
-      #if EXTRUDERS
-      {
-        #if DISABLED(ADVANCED_PAUSE_FEATURE)
-          fil_change_settings_t fc_settings[EXTRUDERS];
-        #endif
-        _FIELD_TEST(fc_settings);
-        EEPROM_READ(fc_settings);
-      }
-      #endif
-
-      //
-      // Tool-change settings
-      //
-      #if EXTRUDERS > 1
-        _FIELD_TEST(toolchange_settings);
-        EEPROM_READ(toolchange_settings);
-      #endif
-
-      //
-      // Backlash Compensation
-      //
-      {
-        #if ENABLED(BACKLASH_GCODE)
-          const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
-          const uint8_t &backlash_correction = backlash.correction;
-        #else
-          float backlash_distance_mm[XYZ];
-          uint8_t backlash_correction;
-        #endif
-        #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
-          const float &backlash_smoothing_mm = backlash.smoothing_mm;
-        #else
-          float backlash_smoothing_mm;
-        #endif
-        _FIELD_TEST(backlash_distance_mm);
-        EEPROM_READ(backlash_distance_mm);
-        EEPROM_READ(backlash_correction);
-        EEPROM_READ(backlash_smoothing_mm);
-      }
-
-      //
-      // Extensible UI User Data
-      //
-      #if ENABLED(EXTENSIBLE_UI)
-        // This is a significant hardware change; don't reserve EEPROM space when not present
-        {
-          const char extui_data[ExtUI::eeprom_data_size] = { 0 };
-          _FIELD_TEST(extui_data);
-          EEPROM_READ(extui_data);
-          if (!validating) ExtUI::onLoadSettings(extui_data);
-        }
-      #endif
-
-      //
-      // Case Light Brightness
-      //
-      #if HAS_CASE_LIGHT_BRIGHTNESS
-        _FIELD_TEST(caselight_brightness);
-        EEPROM_READ(caselight.brightness);
-      #endif
-
-      //
-      // TOUCH_SCREEN_CALIBRATION
-      //
-      #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-        _FIELD_TEST(touch.calibration);
-        EEPROM_READ(touch.calibration);
-      #endif
-
-      eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
-      if (eeprom_error) {
-        DEBUG_ECHO_START();
-        DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
-        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
-      }
-      else if (working_crc != stored_crc) {
-        eeprom_error = true;
-        DEBUG_ERROR_START();
-        DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_crc());
-      }
-      else if (!validating) {
-        DEBUG_ECHO_START();
-        DEBUG_ECHO(version);
-        DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
-      }
-
-      if (!validating && !eeprom_error) postprocess();
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        if (!validating) {
-          ubl.report_state();
-
-          if (!ubl.sanity_check()) {
-            SERIAL_EOL();
-            #if ENABLED(EEPROM_CHITCHAT)
-              ubl.echo_name();
-              DEBUG_ECHOLNPGM(" initialized.\n");
-            #endif
-          }
-          else {
-            eeprom_error = true;
-            #if ENABLED(EEPROM_CHITCHAT)
-              DEBUG_ECHOPGM("?Can't enable ");
-              ubl.echo_name();
-              DEBUG_ECHOLNPGM(".");
-            #endif
-            ubl.reset();
-          }
-
-          if (ubl.storage_slot >= 0) {
-            load_mesh(ubl.storage_slot);
-            DEBUG_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
-          }
-          else {
-            ubl.reset();
-            DEBUG_ECHOLNPGM("UBL reset");
-          }
-        }
-      #endif
-    }
-
-    #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      // Report the EEPROM settings
-      if (!validating && (DISABLED(EEPROM_BOOT_SILENT) || IsRunning())) report();
-    #endif
-
-    EEPROM_FINISH();
-
-    return !eeprom_error;
-  }
-
-  #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
-    extern bool restoreEEPROM();
-  #endif
-
-  bool MarlinSettings::validate() {
-    validating = true;
-    #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
-      bool success = _load();
-      if (!success && restoreEEPROM()) {
-        SERIAL_ECHOLNPGM("Recovered backup EEPROM settings from SPI Flash");
-        success = _load();
-      }
-    #else
-      const bool success = _load();
-    #endif
-    validating = false;
-    return success;
-  }
-
-  bool MarlinSettings::load() {
-    if (validate()) {
-      const bool success = _load();
-      TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreRead(success));
-      return success;
-    }
-    reset();
-    #if ENABLED(EEPROM_AUTO_INIT)
-      (void)save();
-      SERIAL_ECHO_MSG("EEPROM Initialized");
-    #endif
-    return false;
-  }
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    inline void ubl_invalid_slot(const int s) {
-      #if ENABLED(EEPROM_CHITCHAT)
-        DEBUG_ECHOLNPGM("?Invalid slot.");
-        DEBUG_ECHO(s);
-        DEBUG_ECHOLNPGM(" mesh slots available.");
-      #else
-        UNUSED(s);
-      #endif
-    }
-
-    const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
-                                                                                  // is a placeholder for the size of the MAT; the MAT will always
-                                                                                  // live at the very end of the eeprom
-
-    uint16_t MarlinSettings::meshes_start_index() {
-      return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
-                                                          // or down a little bit without disrupting the mesh data
-    }
-
-    uint16_t MarlinSettings::calc_num_meshes() {
-      return (meshes_end - meshes_start_index()) / sizeof(ubl.z_values);
-    }
-
-    int MarlinSettings::mesh_slot_offset(const int8_t slot) {
-      return meshes_end - (slot + 1) * sizeof(ubl.z_values);
-    }
-
-    void MarlinSettings::store_mesh(const int8_t slot) {
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        const int16_t a = calc_num_meshes();
-        if (!WITHIN(slot, 0, a - 1)) {
-          ubl_invalid_slot(a);
-          DEBUG_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
-          DEBUG_EOL();
-          return;
-        }
-
-        int pos = mesh_slot_offset(slot);
-        uint16_t crc = 0;
-
-        // Write crc to MAT along with other data, or just tack on to the beginning or end
-        persistentStore.access_start();
-        const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
-        persistentStore.access_finish();
-
-        if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
-        else        DEBUG_ECHOLNPAIR("Mesh saved in slot ", slot);
-
-      #else
-
-        // Other mesh types
-
-      #endif
-    }
-
-    void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=nullptr*/) {
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-        const int16_t a = settings.calc_num_meshes();
-
-        if (!WITHIN(slot, 0, a - 1)) {
-          ubl_invalid_slot(a);
-          return;
-        }
-
-        int pos = mesh_slot_offset(slot);
-        uint16_t crc = 0;
-        uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
-
-        persistentStore.access_start();
-        const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
-        persistentStore.access_finish();
-
-        if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
-        else        DEBUG_ECHOLNPAIR("Mesh loaded from slot ", slot);
-
-        EEPROM_FINISH();
-
-      #else
-
-        // Other mesh types
-
-      #endif
-    }
-
-    //void MarlinSettings::delete_mesh() { return; }
-    //void MarlinSettings::defrag_meshes() { return; }
-
-  #endif // AUTO_BED_LEVELING_UBL
-
-#else // !EEPROM_SETTINGS
-
-  bool MarlinSettings::save() {
-    DEBUG_ERROR_MSG("EEPROM disabled");
-    return false;
-  }
-
-#endif // !EEPROM_SETTINGS
-
-/**
- * M502 - Reset Configuration
- */
-void MarlinSettings::reset() {
-  LOOP_XYZE_N(i) {
-    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
-    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
-    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
-  }
-
-  planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
-  planner.settings.acceleration = DEFAULT_ACCELERATION;
-  planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
-  planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
-  planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
-  planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
-
-  #if HAS_CLASSIC_JERK
-    #ifndef DEFAULT_XJERK
-      #define DEFAULT_XJERK 0
-    #endif
-    #ifndef DEFAULT_YJERK
-      #define DEFAULT_YJERK 0
-    #endif
-    #ifndef DEFAULT_ZJERK
-      #define DEFAULT_ZJERK 0
-    #endif
-    planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
-    TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
-  #endif
-
-  #if HAS_JUNCTION_DEVIATION
-    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
-  #endif
-
-  #if HAS_SCARA_OFFSET
-    scara_home_offset.reset();
-  #elif HAS_HOME_OFFSET
-    home_offset.reset();
-  #endif
-
-  TERN_(HAS_HOTEND_OFFSET, reset_hotend_offsets());
-
-  //
-  // Filament Runout Sensor
-  //
-
-  #if HAS_FILAMENT_SENSOR
-    runout.enabled = true;
-    runout.reset();
-    TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM));
-  #endif
-
-  //
-  // Tool-change Settings
-  //
-
-  #if EXTRUDERS > 1
-    #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-      toolchange_settings.swap_length     = TOOLCHANGE_FS_LENGTH;
-      toolchange_settings.extra_resume    = TOOLCHANGE_FS_EXTRA_RESUME_LENGTH;
-      toolchange_settings.retract_speed   = TOOLCHANGE_FS_RETRACT_SPEED;
-      toolchange_settings.unretract_speed = TOOLCHANGE_FS_UNRETRACT_SPEED;
-      toolchange_settings.extra_prime     = TOOLCHANGE_FS_EXTRA_PRIME;
-      toolchange_settings.prime_speed     = TOOLCHANGE_FS_PRIME_SPEED;
-      toolchange_settings.fan_speed       = TOOLCHANGE_FS_FAN_SPEED;
-      toolchange_settings.fan_time        = TOOLCHANGE_FS_FAN_TIME;
-    #endif
-
-    #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
-      enable_first_prime = false;
-    #endif
-
-    #if ENABLED(TOOLCHANGE_PARK)
-      constexpr xyz_pos_t tpxy = TOOLCHANGE_PARK_XY;
-      toolchange_settings.enable_park = true;
-      toolchange_settings.change_point = tpxy;
-    #endif
-
-    toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
-
-    #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
-      migration = migration_defaults;
-    #endif
-
-  #endif
-
-  #if ENABLED(BACKLASH_GCODE)
-    backlash.correction = (BACKLASH_CORRECTION) * 255;
-    constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
-    backlash.distance_mm = tmp;
-    #ifdef BACKLASH_SMOOTHING_MM
-      backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
-    #endif
-  #endif
-
-  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
-
-  //
-  // Case Light Brightness
-  //
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
-
-  //
-  // TOUCH_SCREEN_CALIBRATION
-  //
-  TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
-
-  //
-  // Magnetic Parking Extruder
-  //
-  TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
-
-  //
-  // Global Leveling
-  //
-  TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
-  TERN_(HAS_LEVELING, reset_bed_level());
-
-  #if HAS_BED_PROBE
-    constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
-    static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
-    #if HAS_PROBE_XY_OFFSET
-      LOOP_XYZ(a) probe.offset[a] = dpo[a];
-    #else
-      probe.offset.x = probe.offset.y = 0;
-      probe.offset.z = dpo[Z_AXIS];
-    #endif
-  #endif
-
-  //
-  // Z Stepper Auto-alignment points
-  //
-  TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
-
-  //
-  // Servo Angles
-  //
-  TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
-
-  //
-  // BLTOUCH
-  //
-  //#if ENABLED(BLTOUCH)
-  //  bltouch.last_written_mode;
-  //#endif
-
-  //
-  // Endstop Adjustments
-  //
-
-  #if ENABLED(DELTA)
-    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
-    delta_height = DELTA_HEIGHT;
-    delta_endstop_adj = adj;
-    delta_radius = DELTA_RADIUS;
-    delta_diagonal_rod = DELTA_DIAGONAL_ROD;
-    delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
-    delta_tower_angle_trim = dta;
-    delta_diagonal_rod_trim = ddr;
-  #endif
-
-  #if ENABLED(X_DUAL_ENDSTOPS)
-    #ifndef X2_ENDSTOP_ADJUSTMENT
-      #define X2_ENDSTOP_ADJUSTMENT 0
-    #endif
-    endstops.x2_endstop_adj = X2_ENDSTOP_ADJUSTMENT;
-  #endif
-
-  #if ENABLED(Y_DUAL_ENDSTOPS)
-    #ifndef Y2_ENDSTOP_ADJUSTMENT
-      #define Y2_ENDSTOP_ADJUSTMENT 0
-    #endif
-    endstops.y2_endstop_adj = Y2_ENDSTOP_ADJUSTMENT;
-  #endif
-
-  #if ENABLED(Z_MULTI_ENDSTOPS)
-    #ifndef Z2_ENDSTOP_ADJUSTMENT
-      #define Z2_ENDSTOP_ADJUSTMENT 0
-    #endif
-    endstops.z2_endstop_adj = Z2_ENDSTOP_ADJUSTMENT;
-    #if NUM_Z_STEPPER_DRIVERS >= 3
-      #ifndef Z3_ENDSTOP_ADJUSTMENT
-        #define Z3_ENDSTOP_ADJUSTMENT 0
-      #endif
-      endstops.z3_endstop_adj = Z3_ENDSTOP_ADJUSTMENT;
-    #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 4
-      #ifndef Z4_ENDSTOP_ADJUSTMENT
-        #define Z4_ENDSTOP_ADJUSTMENT 0
-      #endif
-      endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
-    #endif
-  #endif
-
-  //
-  // Preheat parameters
-  //
-  #if PREHEAT_COUNT
-    #if HAS_HOTEND
-      constexpr uint16_t hpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND, PREHEAT_3_TEMP_HOTEND, PREHEAT_4_TEMP_HOTEND, PREHEAT_5_TEMP_HOTEND);
-    #endif
-    #if HAS_HEATED_BED
-      constexpr uint16_t bpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED, PREHEAT_3_TEMP_BED, PREHEAT_4_TEMP_BED, PREHEAT_5_TEMP_BED);
-    #endif
-    #if HAS_FAN
-      constexpr uint8_t fpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED, PREHEAT_3_FAN_SPEED, PREHEAT_4_FAN_SPEED, PREHEAT_5_FAN_SPEED);
-    #endif
-    LOOP_L_N(i, PREHEAT_COUNT) {
-      #if HAS_HOTEND
-        ui.material_preset[i].hotend_temp = hpre[i];
-      #endif
-      #if HAS_HEATED_BED
-        ui.material_preset[i].bed_temp = bpre[i];
-      #endif
-      #if HAS_FAN
-        ui.material_preset[i].fan_speed = fpre[i];
-      #endif
-    }
-  #endif
-
-  //
-  // Hotend PID
-  //
-
-  #if ENABLED(PIDTEMP)
-    #if ENABLED(PID_PARAMS_PER_HOTEND)
-      constexpr float defKp[] =
-        #ifdef DEFAULT_Kp_LIST
-          DEFAULT_Kp_LIST
-        #else
-          ARRAY_BY_HOTENDS1(DEFAULT_Kp)
-        #endif
-      , defKi[] =
-        #ifdef DEFAULT_Ki_LIST
-          DEFAULT_Ki_LIST
-        #else
-          ARRAY_BY_HOTENDS1(DEFAULT_Ki)
-        #endif
-      , defKd[] =
-        #ifdef DEFAULT_Kd_LIST
-          DEFAULT_Kd_LIST
-        #else
-          ARRAY_BY_HOTENDS1(DEFAULT_Kd)
-        #endif
-      ;
-      static_assert(WITHIN(COUNT(defKp), 1, HOTENDS), "DEFAULT_Kp_LIST must have between 1 and HOTENDS items.");
-      static_assert(WITHIN(COUNT(defKi), 1, HOTENDS), "DEFAULT_Ki_LIST must have between 1 and HOTENDS items.");
-      static_assert(WITHIN(COUNT(defKd), 1, HOTENDS), "DEFAULT_Kd_LIST must have between 1 and HOTENDS items.");
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        constexpr float defKc[] =
-          #ifdef DEFAULT_Kc_LIST
-            DEFAULT_Kc_LIST
-          #else
-            ARRAY_BY_HOTENDS1(DEFAULT_Kc)
-          #endif
-        ;
-        static_assert(WITHIN(COUNT(defKc), 1, HOTENDS), "DEFAULT_Kc_LIST must have between 1 and HOTENDS items.");
-      #endif
-      #if ENABLED(PID_FAN_SCALING)
-        constexpr float defKf[] =
-          #ifdef DEFAULT_Kf_LIST
-            DEFAULT_Kf_LIST
-          #else
-            ARRAY_BY_HOTENDS1(DEFAULT_Kf)
-          #endif
-        ;
-        static_assert(WITHIN(COUNT(defKf), 1, HOTENDS), "DEFAULT_Kf_LIST must have between 1 and HOTENDS items.");
-      #endif
-      #define PID_DEFAULT(N,E) def##N[E]
-    #else
-      #define PID_DEFAULT(N,E) DEFAULT_##N
-    #endif
-    HOTEND_LOOP() {
-      PID_PARAM(Kp, e) = float(PID_DEFAULT(Kp, ALIM(e, defKp)));
-      PID_PARAM(Ki, e) = scalePID_i(PID_DEFAULT(Ki, ALIM(e, defKi)));
-      PID_PARAM(Kd, e) = scalePID_d(PID_DEFAULT(Kd, ALIM(e, defKd)));
-      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = float(PID_DEFAULT(Kc, ALIM(e, defKc))));
-      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = float(PID_DEFAULT(Kf, ALIM(e, defKf))));
-    }
-  #endif
-
-  //
-  // PID Extrusion Scaling
-  //
-  TERN_(PID_EXTRUSION_SCALING, thermalManager.lpq_len = 20); // Default last-position-queue size
-
-  //
-  // Heated Bed PID
-  //
-
-  #if ENABLED(PIDTEMPBED)
-    thermalManager.temp_bed.pid.Kp = DEFAULT_bedKp;
-    thermalManager.temp_bed.pid.Ki = scalePID_i(DEFAULT_bedKi);
-    thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
-  #endif
-
-  //
-  // User-Defined Thermistors
-  //
-  TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
-
-  //
-  // Power Monitor
-  //
-  TERN_(POWER_MONITOR, power_monitor.reset());
-
-  //
-  // LCD Contrast
-  //
-  TERN_(HAS_LCD_CONTRAST, ui.set_contrast(DEFAULT_LCD_CONTRAST));
-
-  //
-  // Controller Fan
-  //
-  TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
-
-  //
-  // Power-Loss Recovery
-  //
-  TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
-
-  //
-  // Firmware Retraction
-  //
-  TERN_(FWRETRACT, fwretract.reset());
-
-  //
-  // Volumetric & Filament Size
-  //
-
-  #if DISABLED(NO_VOLUMETRICS)
-    parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
-    LOOP_L_N(q, COUNT(planner.filament_size))
-      planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
-    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-      LOOP_L_N(q, COUNT(planner.volumetric_extruder_limit))
-        planner.volumetric_extruder_limit[q] = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
-    #endif
-  #endif
-
-  endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
-
-  reset_stepper_drivers();
-
-  //
-  // Linear Advance
-  //
-
-  #if ENABLED(LIN_ADVANCE)
-    LOOP_L_N(i, EXTRUDERS) {
-      planner.extruder_advance_K[i] = LIN_ADVANCE_K;
-      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[i] = LIN_ADVANCE_K);
-    }
-  #endif
-
-  //
-  // Motor Current PWM
-  //
-
-  #if HAS_MOTOR_CURRENT_PWM
-    constexpr uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
-    LOOP_L_N(q, 3)
-      stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
-  #endif
-
-  //
-  // CNC Coordinate System
-  //
-  TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
-
-  //
-  // Skew Correction
-  //
-  #if ENABLED(SKEW_CORRECTION_GCODE)
-    planner.skew_factor.xy = XY_SKEW_FACTOR;
-    #if ENABLED(SKEW_CORRECTION_FOR_Z)
-      planner.skew_factor.xz = XZ_SKEW_FACTOR;
-      planner.skew_factor.yz = YZ_SKEW_FACTOR;
-    #endif
-  #endif
-
-  //
-  // Advanced Pause filament load & unload lengths
-  //
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    LOOP_L_N(e, EXTRUDERS) {
-      fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
-      fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
-    }
-  #endif
-
-  postprocess();
-
-  DEBUG_ECHO_START();
-  DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
-
-  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
-}
-
-#if DISABLED(DISABLE_M503)
-
-  static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
-    if (!repl) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("; ");
-      serialprintPGM(pstr);
-      if (eol) SERIAL_EOL();
-    }
-  }
-
-  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
-  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
-  #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
-
-  #if HAS_TRINAMIC_CONFIG
-    inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
-    #if HAS_STEALTHCHOP
-      void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOPGM("  M569 S1");
-        if (etc) {
-          SERIAL_CHAR(' ');
-          serialprintPGM(etc);
-        }
-        if (newLine) SERIAL_EOL();
-      }
-    #endif
-    #if ENABLED(HYBRID_THRESHOLD)
-      inline void say_M913(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M913"); }
-    #endif
-    #if USE_SENSORLESS
-      inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
-    #endif
-  #endif
-
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    inline void say_M603(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M603 "); }
-  #endif
-
-  inline void say_units(const bool colon) {
-    serialprintPGM(
-      #if ENABLED(INCH_MODE_SUPPORT)
-        parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
-      #endif
-      PSTR(" (mm)")
-    );
-    if (colon) SERIAL_ECHOLNPGM(":");
-  }
-
-  void report_M92(const bool echo=true, const int8_t e=-1);
-
-  /**
-   * M503 - Report current settings in RAM
-   *
-   * Unless specifically disabled, M503 is available even without EEPROM
-   */
-  void MarlinSettings::report(const bool forReplay) {
-    /**
-     * Announce current units, in case inches are being displayed
-     */
-    CONFIG_ECHO_START();
-    #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHOPGM("  G2");
-      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
-      SERIAL_ECHOPGM(" ;");
-      say_units(false);
-    #else
-      SERIAL_ECHOPGM("  G21    ; Units in mm");
-      say_units(false);
-    #endif
-    SERIAL_EOL();
-
-    #if HAS_LCD_MENU
-
-      // Temperature units - for Ultipanel temperature options
-
-      CONFIG_ECHO_START();
-      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        SERIAL_ECHOPGM("  M149 ");
-        SERIAL_CHAR(parser.temp_units_code());
-        SERIAL_ECHOPGM(" ; Units in ");
-        serialprintPGM(parser.temp_units_name());
-      #else
-        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
-      #endif
-
-    #endif
-
-    SERIAL_EOL();
-
-    #if EXTRUDERS && DISABLED(NO_VOLUMETRICS)
-
-      /**
-       * Volumetric extrusion M200
-       */
-      if (!forReplay) {
-        config_heading(forReplay, PSTR("Filament settings:"), false);
-        if (parser.volumetric_enabled)
-          SERIAL_EOL();
-        else
-          SERIAL_ECHOLNPGM(" Disabled");
-      }
-
-      #if EXTRUDERS == 1
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled)
-                              , " D", LINEAR_UNIT(planner.filament_size[0])
-                              #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
-                              #endif
-                         );
-      #else
-        LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR("  M200 T", int(i)
-                                , " D", LINEAR_UNIT(planner.filament_size[i])
-                                #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                                  , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
-                                #endif
-                           );
-        }
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled));
-      #endif
-    #endif // EXTRUDERS && !NO_VOLUMETRICS
-
-    CONFIG_ECHO_HEADING("Steps per unit:");
-    report_M92(!forReplay);
-
-    CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
-      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
-      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
-      #if DISABLED(DISTINCT_E_FACTORS)
-        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
-      #endif
-    );
-    #if ENABLED(DISTINCT_E_FACTORS)
-      LOOP_L_N(i, E_STEPPERS) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-            PSTR("  M203 T"), (int)i
-          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
-        );
-      }
-    #endif
-
-    CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
-      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
-      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
-      #if DISABLED(DISTINCT_E_FACTORS)
-        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
-      #endif
-    );
-    #if ENABLED(DISTINCT_E_FACTORS)
-      LOOP_L_N(i, E_STEPPERS) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-            PSTR("  M201 T"), (int)i
-          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
-        );
-      }
-    #endif
-
-    CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
-      , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
-      , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
-    );
-
-    CONFIG_ECHO_HEADING(
-      "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
-      #if HAS_JUNCTION_DEVIATION
-        " J<junc_dev>"
-      #endif
-      #if HAS_CLASSIC_JERK
-        " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
-        TERN_(HAS_CLASSIC_E_JERK, " E<max_e_jerk>")
-      #endif
-    );
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
-      , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
-      , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
-      #if HAS_JUNCTION_DEVIATION
-        , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
-      #endif
-      #if HAS_CLASSIC_JERK
-        , SP_X_STR, LINEAR_UNIT(planner.max_jerk.x)
-        , SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y)
-        , SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z)
-        #if HAS_CLASSIC_E_JERK
-          , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
-        #endif
-      #endif
-    );
-
-    #if HAS_M206_COMMAND
-      CONFIG_ECHO_HEADING("Home offset:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        #if IS_CARTESIAN
-            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x)
-          , SP_Y_STR, LINEAR_UNIT(home_offset.y)
-          , SP_Z_STR
-        #else
-          PSTR("  M206 Z")
-        #endif
-        , LINEAR_UNIT(home_offset.z)
-      );
-    #endif
-
-    #if HAS_HOTEND_OFFSET
-      CONFIG_ECHO_HEADING("Hotend offsets:");
-      CONFIG_ECHO_START();
-      LOOP_S_L_N(e, 1, HOTENDS) {
-        SERIAL_ECHOPAIR_P(
-          PSTR("  M218 T"), (int)e,
-          SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
-          SP_Y_STR, LINEAR_UNIT(hotend_offset[e].y)
-        );
-        SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(hotend_offset[e].z), 3);
-      }
-    #endif
-
-    /**
-     * Bed Leveling
-     */
-    #if HAS_LEVELING
-
-      #if ENABLED(MESH_BED_LEVELING)
-
-        CONFIG_ECHO_HEADING("Mesh Bed Leveling:");
-
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-        config_heading(forReplay, PSTR(""), false);
-        if (!forReplay) {
-          ubl.echo_name();
-          SERIAL_CHAR(':');
-          SERIAL_EOL();
-        }
-
-      #elif HAS_ABL_OR_UBL
-
-        CONFIG_ECHO_HEADING("Auto Bed Leveling:");
-
-      #endif
-
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        PSTR("  M420 S"), planner.leveling_active ? 1 : 0
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
-        #endif
-      );
-
-      #if ENABLED(MESH_BED_LEVELING)
-
-        if (leveling_is_valid()) {
-          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
-            LOOP_L_N(px, GRID_MAX_POINTS_X) {
-              CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), (int)px, PSTR(" J"), (int)py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
-            }
-          }
-          CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR_F_P(PSTR("  G29 S4 Z"), LINEAR_UNIT(mbl.z_offset), 5);
-        }
-
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-        if (!forReplay) {
-          SERIAL_EOL();
-          ubl.report_state();
-          SERIAL_EOL();
-          config_heading(false, PSTR("Active Mesh Slot: "), false);
-          SERIAL_ECHOLN(ubl.storage_slot);
-          config_heading(false, PSTR("EEPROM can hold "), false);
-          SERIAL_ECHO(calc_num_meshes());
-          SERIAL_ECHOLNPGM(" meshes.\n");
-        }
-
-       //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
-                                                  // solution needs to be found.
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        if (leveling_is_valid()) {
-          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
-            LOOP_L_N(px, GRID_MAX_POINTS_X) {
-              CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
-            }
-          }
-        }
-
-      #endif
-
-    #endif // HAS_LEVELING
-
-    #if ENABLED(EDITABLE_SERVO_ANGLES)
-
-      CONFIG_ECHO_HEADING("Servo Angles:");
-      LOOP_L_N(i, NUM_SERVOS) {
-        switch (i) {
-          #if ENABLED(SWITCHING_EXTRUDER)
-            case SWITCHING_EXTRUDER_SERVO_NR:
-            #if EXTRUDERS > 3
-              case SWITCHING_EXTRUDER_E23_SERVO_NR:
-            #endif
-          #elif ENABLED(SWITCHING_NOZZLE)
-            case SWITCHING_NOZZLE_SERVO_NR:
-          #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
-            case Z_PROBE_SERVO_NR:
-          #endif
-            CONFIG_ECHO_START();
-            SERIAL_ECHOLNPAIR("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
-          default: break;
-        }
-      }
-
-    #endif // EDITABLE_SERVO_ANGLES
-
-    #if HAS_SCARA_OFFSET
-
-      CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M665 S"), delta_segments_per_second
-        , SP_P_STR, scara_home_offset.a
-        , SP_T_STR, scara_home_offset.b
-        , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
-      );
-
-    #elif ENABLED(DELTA)
-
-      CONFIG_ECHO_HEADING("Endstop adjustment:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M666 X"), LINEAR_UNIT(delta_endstop_adj.a)
-        , SP_Y_STR, LINEAR_UNIT(delta_endstop_adj.b)
-        , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
-      );
-
-      CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
-        , PSTR(" R"), LINEAR_UNIT(delta_radius)
-        , PSTR(" H"), LINEAR_UNIT(delta_height)
-        , PSTR(" S"), delta_segments_per_second
-        , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
-        , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
-        , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
-        , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
-        , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
-        , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
-      );
-
-    #elif HAS_EXTRA_ENDSTOPS
-
-      CONFIG_ECHO_HEADING("Endstop adjustment:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOPGM("  M666");
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOLNPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
-      #endif
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOLNPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
-      #endif
-      #if ENABLED(Z_MULTI_ENDSTOPS)
-        #if NUM_Z_STEPPER_DRIVERS >= 3
-          SERIAL_ECHOPAIR(" S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
-          CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR("  M666 S3 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
-          #if NUM_Z_STEPPER_DRIVERS >= 4
-            CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR("  M666 S4 Z", LINEAR_UNIT(endstops.z4_endstop_adj));
-          #endif
-        #else
-          SERIAL_ECHOLNPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
-        #endif
-      #endif
-
-    #endif // [XYZ]_DUAL_ENDSTOPS
-
-    #if PREHEAT_COUNT
-
-      CONFIG_ECHO_HEADING("Material heatup parameters:");
-      LOOP_L_N(i, PREHEAT_COUNT) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-          PSTR("  M145 S"), (int)i
-          #if HAS_HOTEND
-            , PSTR(" H"), TEMP_UNIT(ui.material_preset[i].hotend_temp)
-          #endif
-          #if HAS_HEATED_BED
-            , SP_B_STR, TEMP_UNIT(ui.material_preset[i].bed_temp)
-          #endif
-          #if HAS_FAN
-            , PSTR(" F"), ui.material_preset[i].fan_speed
-          #endif
-        );
-      }
-
-    #endif
-
-    #if HAS_PID_HEATING
-
-      CONFIG_ECHO_HEADING("PID settings:");
-
-      #if ENABLED(PIDTEMP)
-        HOTEND_LOOP() {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR_P(
-            #if ENABLED(PID_PARAMS_PER_HOTEND)
-              PSTR("  M301 E"), e,
-              SP_P_STR
-            #else
-              PSTR("  M301 P")
-            #endif
-                        , PID_PARAM(Kp, e)
-            , PSTR(" I"), unscalePID_i(PID_PARAM(Ki, e))
-            , PSTR(" D"), unscalePID_d(PID_PARAM(Kd, e))
-          );
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR_P(SP_C_STR, PID_PARAM(Kc, e));
-            if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
-          #endif
-          #if ENABLED(PID_FAN_SCALING)
-            SERIAL_ECHOPAIR(" F", PID_PARAM(Kf, e));
-          #endif
-          SERIAL_EOL();
-        }
-      #endif // PIDTEMP
-
-      #if ENABLED(PIDTEMPBED)
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR(
-            "  M304 P", thermalManager.temp_bed.pid.Kp
-          , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
-          , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
-        );
-      #endif
-
-    #endif // PIDTEMP || PIDTEMPBED
-
-    #if HAS_USER_THERMISTORS
-      CONFIG_ECHO_HEADING("User thermistors:");
-      LOOP_L_N(i, USER_THERMISTORS)
-        thermalManager.log_user_thermistor(i, true);
-    #endif
-
-    #if HAS_LCD_CONTRAST
-      CONFIG_ECHO_HEADING("LCD Contrast:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
-    #endif
-
-    TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
-
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      CONFIG_ECHO_HEADING("Power-Loss Recovery:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M413 S", int(recovery.enabled));
-    #endif
-
-    #if ENABLED(FWRETRACT)
-
-      CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
-        , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
-        , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
-        , SP_Z_STR, LINEAR_UNIT(fwretract.settings.retract_zraise)
-      );
-
-      CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
-        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
-        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
-      );
-
-      #if ENABLED(FWRETRACT_AUTORETRACT)
-
-        CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
-
-      #endif // FWRETRACT_AUTORETRACT
-
-    #endif // FWRETRACT
-
-    /**
-     * Probe Offset
-     */
-    #if HAS_BED_PROBE
-      config_heading(forReplay, PSTR("Z-Probe Offset"), false);
-      if (!forReplay) say_units(true);
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        #if HAS_PROBE_XY_OFFSET
-          PSTR("  M851 X"), LINEAR_UNIT(probe.offset_xy.x),
-                  SP_Y_STR, LINEAR_UNIT(probe.offset_xy.y),
-                  SP_Z_STR
-        #else
-          PSTR("  M851 X0 Y0 Z")
-        #endif
-        , LINEAR_UNIT(probe.offset.z)
-      );
-    #endif
-
-    /**
-     * Bed Skew Correction
-     */
-    #if ENABLED(SKEW_CORRECTION_GCODE)
-      CONFIG_ECHO_HEADING("Skew Factor: ");
-      CONFIG_ECHO_START();
-      #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHOPAIR_F("  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
-        SERIAL_ECHOPAIR_F(" J", LINEAR_UNIT(planner.skew_factor.xz), 6);
-        SERIAL_ECHOLNPAIR_F(" K", LINEAR_UNIT(planner.skew_factor.yz), 6);
-      #else
-        SERIAL_ECHOLNPAIR_F("  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
-      #endif
-    #endif
-
-    #if HAS_TRINAMIC_CONFIG
-
-      /**
-       * TMC stepper driver current
-       */
-      CONFIG_ECHO_HEADING("Stepper driver current:");
-
-      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        say_M906(forReplay);
-        #if AXIS_IS_TMC(X)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
-        #endif
-        SERIAL_EOL();
-      #endif
-
-      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        say_M906(forReplay);
-        SERIAL_ECHOPGM(" I1");
-        #if AXIS_IS_TMC(X2)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z2)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
-        #endif
-        SERIAL_EOL();
-      #endif
-
-      #if AXIS_IS_TMC(Z3)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
-      #endif
-
-      #if AXIS_IS_TMC(Z4)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.getMilliamps());
-      #endif
-
-      #if AXIS_IS_TMC(E0)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E1)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E2)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T2 E", stepperE2.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E3)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T3 E", stepperE3.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E4)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T4 E", stepperE4.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E5)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E6)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T6 E", stepperE6.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E7)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T7 E", stepperE7.getMilliamps());
-      #endif
-      SERIAL_EOL();
-
-      /**
-       * TMC Hybrid Threshold
-       */
-      #if ENABLED(HYBRID_THRESHOLD)
-        CONFIG_ECHO_HEADING("Hybrid Threshold:");
-        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
-          say_M913(forReplay);
-          #if AXIS_HAS_STEALTHCHOP(X)
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Y)
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Z)
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
-          say_M913(forReplay);
-          SERIAL_ECHOPGM(" I1");
-          #if AXIS_HAS_STEALTHCHOP(X2)
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Y2)
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Z2)
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.get_pwm_thrs());
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E5)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E6)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T6 E", stepperE6.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E7)
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T7 E", stepperE7.get_pwm_thrs());
-        #endif
-        SERIAL_EOL();
-      #endif // HYBRID_THRESHOLD
-
-      /**
-       * TMC Sensorless homing thresholds
-       */
-      #if USE_SENSORLESS
-        CONFIG_ECHO_HEADING("StallGuard threshold:");
-        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          #if X_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.homing_threshold());
-          #endif
-          #if Y_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.homing_threshold());
-          #endif
-          #if Z_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.homing_threshold());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if X2_SENSORLESS || Y2_SENSORLESS || Z2_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOPGM(" I1");
-          #if X2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.homing_threshold());
-          #endif
-          #if Y2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.homing_threshold());
-          #endif
-          #if Z2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.homing_threshold());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if Z3_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
-        #endif
-
-        #if Z4_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.homing_threshold());
-        #endif
-
-      #endif // USE_SENSORLESS
-
-      /**
-       * TMC stepping mode
-       */
-      #if HAS_STEALTHCHOP
-        CONFIG_ECHO_HEADING("Driver stepping mode:");
-        #if AXIS_HAS_STEALTHCHOP(X)
-          const bool chop_x = stepperX.get_stealthChop_status();
-        #else
-          constexpr bool chop_x = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          const bool chop_y = stepperY.get_stealthChop_status();
-        #else
-          constexpr bool chop_y = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          const bool chop_z = stepperZ.get_stealthChop_status();
-        #else
-          constexpr bool chop_z = false;
-        #endif
-
-        if (chop_x || chop_y || chop_z) {
-          say_M569(forReplay);
-          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
-          SERIAL_EOL();
-        }
-
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          const bool chop_x2 = stepperX2.get_stealthChop_status();
-        #else
-          constexpr bool chop_x2 = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          const bool chop_y2 = stepperY2.get_stealthChop_status();
-        #else
-          constexpr bool chop_y2 = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          const bool chop_z2 = stepperZ2.get_stealthChop_status();
-        #else
-          constexpr bool chop_z2 = false;
-        #endif
-
-        if (chop_x2 || chop_y2 || chop_z2) {
-          say_M569(forReplay, PSTR("I1"));
-          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
-          SERIAL_EOL();
-        }
-
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          if (stepperZ4.get_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
-        #endif
-
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E6)
-          if (stepperE6.get_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E7)
-          if (stepperE7.get_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
-        #endif
-
-      #endif // HAS_STEALTHCHOP
-
-    #endif // HAS_TRINAMIC_CONFIG
-
-    /**
-     * Linear Advance
-     */
-    #if ENABLED(LIN_ADVANCE)
-      CONFIG_ECHO_HEADING("Linear Advance:");
-      #if EXTRUDERS < 2
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
-      #else
-        LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
-        }
-      #endif
-    #endif
-
-    #if HAS_MOTOR_CURRENT_PWM
-      CONFIG_ECHO_HEADING("Stepper motor currents:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M907 X"), stepper.motor_current_setting[0]
-        , SP_Z_STR, stepper.motor_current_setting[1]
-        , SP_E_STR, stepper.motor_current_setting[2]
-      );
-    #endif
-
-    /**
-     * Advanced Pause filament load & unload lengths
-     */
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      CONFIG_ECHO_HEADING("Filament load/unload lengths:");
-      #if EXTRUDERS == 1
-        say_M603(forReplay);
-        SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
-      #else
-        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0);
-        REPEAT(EXTRUDERS, _ECHO_603)
-      #endif
-    #endif
-
-    #if EXTRUDERS > 1
-      CONFIG_ECHO_HEADING("Tool-changing:");
-      CONFIG_ECHO_START();
-      M217_report(true);
-    #endif
-
-    #if ENABLED(BACKLASH_GCODE)
-      CONFIG_ECHO_HEADING("Backlash compensation:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M425 F"), backlash.get_correction()
-        , SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x)
-        , SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y)
-        , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
-        #ifdef BACKLASH_SMOOTHING_MM
-          , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
-        #endif
-      );
-    #endif
-
-    #if HAS_FILAMENT_SENSOR
-      CONFIG_ECHO_HEADING("Filament runout sensor:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-        "  M412 S", int(runout.enabled)
-        #if HAS_FILAMENT_RUNOUT_DISTANCE
-          , " D", LINEAR_UNIT(runout.runout_distance())
-        #endif
-      );
-    #endif
-  }
-
-#endif // !DISABLE_M503
-
-#pragma pack(pop)

commit 99ba866d8d3c9abc16558ca12ba34efb9a7922e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 6 08:14:00 2020 -0500

    Optimize G-code / feature dependencies (#18919)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b9f44eb6f8..28e15cfeb0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -404,7 +404,7 @@ typedef struct SettingsDataStruct {
   // HAS_CASE_LIGHT_BRIGHTNESS
   //
   #if HAS_CASE_LIGHT_BRIGHTNESS
-    uint8_t case_light_brightness;
+    uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
@@ -465,7 +465,7 @@ void MarlinSettings::postprocess() {
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, update_case_light());
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.update_brightness());
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
@@ -1342,7 +1342,7 @@ void MarlinSettings::postprocess() {
     // Case Light Brightness
     //
     #if HAS_CASE_LIGHT_BRIGHTNESS
-      EEPROM_WRITE(case_light_brightness);
+      EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
@@ -2181,8 +2181,8 @@ void MarlinSettings::postprocess() {
       // Case Light Brightness
       //
       #if HAS_CASE_LIGHT_BRIGHTNESS
-        _FIELD_TEST(case_light_brightness);
-        EEPROM_READ(case_light_brightness);
+        _FIELD_TEST(caselight_brightness);
+        EEPROM_READ(caselight.brightness);
       #endif
 
       //
@@ -2493,7 +2493,7 @@ void MarlinSettings::reset() {
   //
   // Case Light Brightness
   //
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 72ff057628..b9f44eb6f8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -140,6 +140,10 @@
   #define HAS_CASE_LIGHT_BRIGHTNESS 1
 #endif
 
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  #include "../lcd/tft/touch.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
@@ -403,6 +407,13 @@ typedef struct SettingsDataStruct {
     uint8_t case_light_brightness;
   #endif
 
+  //
+  // TOUCH_SCREEN_CALIBRATION
+  //
+  #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+    touch_calibration_t touch_calibration;
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
@@ -1334,6 +1345,13 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(case_light_brightness);
     #endif
 
+    //
+    // TOUCH_SCREEN_CALIBRATION
+    //
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      EEPROM_WRITE(touch.calibration);
+    #endif
+
     //
     // Validate CRC and Data Size
     //
@@ -2167,6 +2185,14 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(case_light_brightness);
       #endif
 
+      //
+      // TOUCH_SCREEN_CALIBRATION
+      //
+      #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+        _FIELD_TEST(touch.calibration);
+        EEPROM_READ(touch.calibration);
+      #endif
+
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
@@ -2469,6 +2495,11 @@ void MarlinSettings::reset() {
   //
   TERN_(HAS_CASE_LIGHT_BRIGHTNESS, case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
+  //
+  // TOUCH_SCREEN_CALIBRATION
+  //
+  TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
+
   //
   // Magnetic Parking Extruder
   //

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9a9a805099..72ff057628 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 0e1cb10909b47d939d0766c35cdd3cbbd1d37def
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 13 19:59:32 2020 -0500

    Fix / improve menu items (#18644)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6c4c13f830..9a9a805099 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -148,7 +148,7 @@ typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
-#define ALIM(I,ARR) _MIN(I, COUNT(ARR) - 1)
+#define ALIM(I,ARR) _MIN(I, signed(COUNT(ARR) - 1))
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;

commit 12e7106a8afaceb01f41a1bf61e24049c6e7b49e
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Jul 7 11:53:26 2020 +1200

    Update and fix POWER_MONITOR (#18561)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0915c0451a..6c4c13f830 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -94,7 +94,7 @@
   #include "../feature/powerloss.h"
 #endif
 
-#if ENABLED(POWER_MONITOR)
+#if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 

commit dc6d8357a681cc99e04c5980c0ac66009c173e85
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 27 23:27:28 2020 -0500

    Reduce string duplication

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8ff8731114..0915c0451a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3163,16 +3163,16 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       LOOP_L_N(i, PREHEAT_COUNT) {
         CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR(
-          "  M145 S", (int)i
+        SERIAL_ECHOLNPAIR_P(
+          PSTR("  M145 S"), (int)i
           #if HAS_HOTEND
-            , " H", TEMP_UNIT(ui.material_preset[i].hotend_temp)
+            , PSTR(" H"), TEMP_UNIT(ui.material_preset[i].hotend_temp)
           #endif
           #if HAS_HEATED_BED
-            , " B", TEMP_UNIT(ui.material_preset[i].bed_temp)
+            , SP_B_STR, TEMP_UNIT(ui.material_preset[i].bed_temp)
           #endif
           #if HAS_FAN
-            , " F", ui.material_preset[i].fan_speed
+            , PSTR(" F"), ui.material_preset[i].fan_speed
           #endif
         );
       }
@@ -3198,7 +3198,7 @@ void MarlinSettings::reset() {
             , PSTR(" D"), unscalePID_d(PID_PARAM(Kd, e))
           );
           #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
+            SERIAL_ECHOPAIR_P(SP_C_STR, PID_PARAM(Kc, e));
             if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
           #endif
           #if ENABLED(PID_FAN_SCALING)

commit 70fa4c9323543dfb65d10969838899575406cae6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:18:20 2020 -0500

    Per-Hotend Default PIDs (#18483)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 41ce618a04..8ff8731114 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2587,12 +2587,59 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_PARAMS_PER_HOTEND)
+      constexpr float defKp[] =
+        #ifdef DEFAULT_Kp_LIST
+          DEFAULT_Kp_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Kp)
+        #endif
+      , defKi[] =
+        #ifdef DEFAULT_Ki_LIST
+          DEFAULT_Ki_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Ki)
+        #endif
+      , defKd[] =
+        #ifdef DEFAULT_Kd_LIST
+          DEFAULT_Kd_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Kd)
+        #endif
+      ;
+      static_assert(WITHIN(COUNT(defKp), 1, HOTENDS), "DEFAULT_Kp_LIST must have between 1 and HOTENDS items.");
+      static_assert(WITHIN(COUNT(defKi), 1, HOTENDS), "DEFAULT_Ki_LIST must have between 1 and HOTENDS items.");
+      static_assert(WITHIN(COUNT(defKd), 1, HOTENDS), "DEFAULT_Kd_LIST must have between 1 and HOTENDS items.");
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        constexpr float defKc[] =
+          #ifdef DEFAULT_Kc_LIST
+            DEFAULT_Kc_LIST
+          #else
+            ARRAY_BY_HOTENDS1(DEFAULT_Kc)
+          #endif
+        ;
+        static_assert(WITHIN(COUNT(defKc), 1, HOTENDS), "DEFAULT_Kc_LIST must have between 1 and HOTENDS items.");
+      #endif
+      #if ENABLED(PID_FAN_SCALING)
+        constexpr float defKf[] =
+          #ifdef DEFAULT_Kf_LIST
+            DEFAULT_Kf_LIST
+          #else
+            ARRAY_BY_HOTENDS1(DEFAULT_Kf)
+          #endif
+        ;
+        static_assert(WITHIN(COUNT(defKf), 1, HOTENDS), "DEFAULT_Kf_LIST must have between 1 and HOTENDS items.");
+      #endif
+      #define PID_DEFAULT(N,E) def##N[E]
+    #else
+      #define PID_DEFAULT(N,E) DEFAULT_##N
+    #endif
     HOTEND_LOOP() {
-      PID_PARAM(Kp, e) = float(DEFAULT_Kp);
-      PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);
-      PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);
-      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = DEFAULT_Kc);
-      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = DEFAULT_Kf);
+      PID_PARAM(Kp, e) = float(PID_DEFAULT(Kp, ALIM(e, defKp)));
+      PID_PARAM(Ki, e) = scalePID_i(PID_DEFAULT(Ki, ALIM(e, defKi)));
+      PID_PARAM(Kd, e) = scalePID_d(PID_DEFAULT(Kd, ALIM(e, defKd)));
+      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = float(PID_DEFAULT(Kc, ALIM(e, defKc))));
+      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = float(PID_DEFAULT(Kf, ALIM(e, defKf))));
     }
   #endif
 
@@ -3140,7 +3187,7 @@ void MarlinSettings::reset() {
         HOTEND_LOOP() {
           CONFIG_ECHO_START();
           SERIAL_ECHOPAIR_P(
-            #if BOTH(HAS_MULTI_HOTEND, PID_PARAMS_PER_HOTEND)
+            #if ENABLED(PID_PARAMS_PER_HOTEND)
               PSTR("  M301 E"), e,
               SP_P_STR
             #else

commit 29753baeee75a00d3085c07643629b9e8439f447
Author: Fabio Santos <fabiosan@live.com>
Date:   Sat Jun 27 21:53:44 2020 -0700

    Adjustable delta_diagonal_rod_trim (#18423)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e7de76000e..41ce618a04 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -257,11 +257,12 @@ typedef struct SettingsDataStruct {
   //
   #if ENABLED(DELTA)
     float delta_height;                                 // M666 H
-    abc_float_t delta_endstop_adj;                      // M666 XYZ
+    abc_float_t delta_endstop_adj;                      // M666 X Y Z
     float delta_radius,                                 // M665 R
           delta_diagonal_rod,                           // M665 L
           delta_segments_per_second;                    // M665 S
-    abc_float_t delta_tower_angle_trim;                 // M665 XYZ
+    abc_float_t delta_tower_angle_trim,                 // M665 X Y Z
+                delta_diagonal_rod_trim;                // M665 A B C
   #elif HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
@@ -775,6 +776,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
         EEPROM_WRITE(delta_segments_per_second); // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
+        EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
 
       #elif HAS_EXTRA_ENDSTOPS
 
@@ -1638,6 +1640,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(delta_diagonal_rod);        // 1 float
           EEPROM_READ(delta_segments_per_second); // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
+          EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
 
         #elif HAS_EXTRA_ENDSTOPS
 
@@ -2510,13 +2513,14 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(DELTA)
-    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM;
+    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
     delta_height = DELTA_HEIGHT;
     delta_endstop_adj = adj;
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_tower_angle_trim = dta;
+    delta_diagonal_rod_trim = ddr;
   #endif
 
   #if ENABLED(X_DUAL_ENDSTOPS)
@@ -3065,7 +3069,7 @@ void MarlinSettings::reset() {
         , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
       );
 
-      CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> XYZ<tower angle corrections>");
+      CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
@@ -3075,6 +3079,9 @@ void MarlinSettings::reset() {
         , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
         , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
         , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
+        , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
+        , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
+        , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
       );
 
     #elif HAS_EXTRA_ENDSTOPS

commit 4275466f4930ce554419f5f03f07119b8a9aec04
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 24 19:44:50 2020 -0500

    Fix issues with no hotend / bed / fan (#18395)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 77b807ec4c..e7de76000e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V80"
+#define EEPROM_VERSION "V81"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -281,11 +281,11 @@ typedef struct SettingsDataStruct {
   #endif
 
   //
-  // ULTIPANEL
+  // Material Presets
   //
-  int16_t ui_preheat_hotend_temp[2],                    // M145 S0 H
-          ui_preheat_bed_temp[2];                       // M145 S0 B
-  uint8_t ui_preheat_fan_speed[2];                      // M145 S0 F
+  #if PREHEAT_COUNT
+    preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
+  #endif
 
   //
   // PIDTEMP
@@ -811,27 +811,10 @@ void MarlinSettings::postprocess() {
     //
     // LCD Preheat settings
     //
-    {
-      _FIELD_TEST(ui_preheat_hotend_temp);
-
-      #if HAS_HOTEND && HAS_LCD_MENU
-        const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
-                      (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
-        const uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
-      #elif ENABLED(DWIN_CREALITY_LCD)
-        const int16_t (&ui_preheat_hotend_temp)[2]  = HMI_ValueStruct.preheat_hotend_temp,
-                      (&ui_preheat_bed_temp)[2]     = HMI_ValueStruct.preheat_bed_temp;
-        const uint8_t (&ui_preheat_fan_speed)[2]    = HMI_ValueStruct.preheat_fan_speed;
-      #else
-        constexpr int16_t ui_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
-                          ui_preheat_bed_temp[2]    = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
-        constexpr uint8_t ui_preheat_fan_speed[2]   = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
-      #endif
-
-      EEPROM_WRITE(ui_preheat_hotend_temp);
-      EEPROM_WRITE(ui_preheat_bed_temp);
-      EEPROM_WRITE(ui_preheat_fan_speed);
-    }
+    #if PREHEAT_COUNT
+      _FIELD_TEST(ui_material_preset);
+      EEPROM_WRITE(ui.material_preset);
+    #endif
 
     //
     // PIDTEMP
@@ -1688,25 +1671,10 @@ void MarlinSettings::postprocess() {
       //
       // LCD Preheat settings
       //
-      {
-        _FIELD_TEST(ui_preheat_hotend_temp);
-
-        #if HAS_HOTEND && HAS_LCD_MENU
-          int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
-                  (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
-          uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
-       #elif ENABLED(DWIN_CREALITY_LCD)
-          int16_t (&ui_preheat_hotend_temp)[2]  = HMI_ValueStruct.preheat_hotend_temp,
-                  (&ui_preheat_bed_temp)[2]     = HMI_ValueStruct.preheat_bed_temp;
-          uint8_t (&ui_preheat_fan_speed)[2]    = HMI_ValueStruct.preheat_fan_speed;
-       #else
-          int16_t ui_preheat_hotend_temp[2], ui_preheat_bed_temp[2];
-          uint8_t ui_preheat_fan_speed[2];
-        #endif
-        EEPROM_READ(ui_preheat_hotend_temp); // 2 floats
-        EEPROM_READ(ui_preheat_bed_temp);    // 2 floats
-        EEPROM_READ(ui_preheat_fan_speed);   // 2 floats
-      }
+      #if PREHEAT_COUNT
+        _FIELD_TEST(ui_material_preset);
+        EEPROM_READ(ui.material_preset);
+      #endif
 
       //
       // Hotend PID
@@ -2587,22 +2555,27 @@ void MarlinSettings::reset() {
   //
   // Preheat parameters
   //
-  #if HAS_HOTEND
-    #if ENABLED(DWIN_CREALITY_LCD)
-      HMI_ValueStruct.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
-      HMI_ValueStruct.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
-      HMI_ValueStruct.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
-      HMI_ValueStruct.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
-      HMI_ValueStruct.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
-      HMI_ValueStruct.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
-    #elif HAS_LCD_MENU
-      ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
-      ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
-      ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
-      ui.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
-      ui.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
-      ui.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+  #if PREHEAT_COUNT
+    #if HAS_HOTEND
+      constexpr uint16_t hpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND, PREHEAT_3_TEMP_HOTEND, PREHEAT_4_TEMP_HOTEND, PREHEAT_5_TEMP_HOTEND);
     #endif
+    #if HAS_HEATED_BED
+      constexpr uint16_t bpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED, PREHEAT_3_TEMP_BED, PREHEAT_4_TEMP_BED, PREHEAT_5_TEMP_BED);
+    #endif
+    #if HAS_FAN
+      constexpr uint8_t fpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED, PREHEAT_3_FAN_SPEED, PREHEAT_4_FAN_SPEED, PREHEAT_5_FAN_SPEED);
+    #endif
+    LOOP_L_N(i, PREHEAT_COUNT) {
+      #if HAS_HOTEND
+        ui.material_preset[i].hotend_temp = hpre[i];
+      #endif
+      #if HAS_HEATED_BED
+        ui.material_preset[i].bed_temp = bpre[i];
+      #endif
+      #if HAS_FAN
+        ui.material_preset[i].fan_speed = fpre[i];
+      #endif
+    }
   #endif
 
   //
@@ -3131,16 +3104,22 @@ void MarlinSettings::reset() {
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
-    #if HAS_HOTEND && HAS_LCD_MENU
+    #if PREHEAT_COUNT
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
-      LOOP_L_N(i, COUNT(ui.preheat_hotend_temp)) {
+      LOOP_L_N(i, PREHEAT_COUNT) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR(
-            "  M145 S", (int)i
-          , " H", TEMP_UNIT(ui.preheat_hotend_temp[i])
-          , " B", TEMP_UNIT(ui.preheat_bed_temp[i])
-          , " F", int(ui.preheat_fan_speed[i])
+          "  M145 S", (int)i
+          #if HAS_HOTEND
+            , " H", TEMP_UNIT(ui.material_preset[i].hotend_temp)
+          #endif
+          #if HAS_HEATED_BED
+            , " B", TEMP_UNIT(ui.material_preset[i].bed_temp)
+          #endif
+          #if HAS_FAN
+            , " F", ui.material_preset[i].fan_speed
+          #endif
         );
       }
 

commit 424569b4c4bf112a3939724b30bad528a76a2b08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 18 15:23:03 2020 -0500

    Power monitor and display (#17437)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 96ca20e8a2..77b807ec4c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -94,6 +94,10 @@
   #include "../feature/powerloss.h"
 #endif
 
+#if ENABLED(POWER_MONITOR)
+  #include "../feature/power_monitor.h"
+#endif
+
 #include "../feature/pause.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
@@ -301,6 +305,11 @@ typedef struct SettingsDataStruct {
     user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
   #endif
 
+  //
+  // Power monitor
+  //
+  uint8_t power_monitor_flags;                          // M430 I V W
+
   //
   // HAS_LCD_CONTRAST
   //
@@ -881,6 +890,19 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
+    //
+    // Power monitor
+    //
+    {
+      #if HAS_POWER_MONITOR
+        const uint8_t &power_monitor_flags = power_monitor.flags;
+      #else
+        constexpr uint8_t power_monitor_flags = 0x00;
+      #endif
+      _FIELD_TEST(power_monitor_flags);
+      EEPROM_WRITE(power_monitor_flags);
+    }
+
     //
     // LCD Contrast
     //
@@ -1745,6 +1767,19 @@ void MarlinSettings::postprocess() {
       }
       #endif
 
+      //
+      // Power monitor
+      //
+      {
+        #if HAS_POWER_MONITOR
+          uint8_t &power_monitor_flags = power_monitor.flags;
+        #else
+          uint8_t power_monitor_flags;
+        #endif
+        _FIELD_TEST(power_monitor_flags);
+        EEPROM_READ(power_monitor_flags);
+      }
+
       //
       // LCD Contrast
       //
@@ -2604,6 +2639,11 @@ void MarlinSettings::reset() {
   //
   TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
+  //
+  // Power Monitor
+  //
+  TERN_(POWER_MONITOR, power_monitor.reset());
+
   //
   // LCD Contrast
   //

commit f4c258dc2355fee871bec6e11095c7c4777b160d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 16 01:45:27 2020 -0500

    Creality Ender 3 v2 (#17719)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index aa150671d2..96ca20e8a2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -50,6 +50,11 @@
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
+
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../lcd/dwin/dwin.h"
+#endif
+
 #include "../lcd/ultralcd.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
@@ -804,6 +809,10 @@ void MarlinSettings::postprocess() {
         const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                       (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
         const uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
+      #elif ENABLED(DWIN_CREALITY_LCD)
+        const int16_t (&ui_preheat_hotend_temp)[2]  = HMI_ValueStruct.preheat_hotend_temp,
+                      (&ui_preheat_bed_temp)[2]     = HMI_ValueStruct.preheat_bed_temp;
+        const uint8_t (&ui_preheat_fan_speed)[2]    = HMI_ValueStruct.preheat_fan_speed;
       #else
         constexpr int16_t ui_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
                           ui_preheat_bed_temp[2]    = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
@@ -1664,7 +1673,11 @@ void MarlinSettings::postprocess() {
           int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                   (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
           uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
-        #else
+       #elif ENABLED(DWIN_CREALITY_LCD)
+          int16_t (&ui_preheat_hotend_temp)[2]  = HMI_ValueStruct.preheat_hotend_temp,
+                  (&ui_preheat_bed_temp)[2]     = HMI_ValueStruct.preheat_bed_temp;
+          uint8_t (&ui_preheat_fan_speed)[2]    = HMI_ValueStruct.preheat_fan_speed;
+       #else
           int16_t ui_preheat_hotend_temp[2], ui_preheat_bed_temp[2];
           uint8_t ui_preheat_fan_speed[2];
         #endif
@@ -2539,14 +2552,22 @@ void MarlinSettings::reset() {
   //
   // Preheat parameters
   //
-
-  #if HAS_HOTEND && HAS_LCD_MENU
-    ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
-    ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
-    ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
-    ui.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
-    ui.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
-    ui.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+  #if HAS_HOTEND
+    #if ENABLED(DWIN_CREALITY_LCD)
+      HMI_ValueStruct.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
+      HMI_ValueStruct.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
+      HMI_ValueStruct.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
+      HMI_ValueStruct.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
+      HMI_ValueStruct.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
+      HMI_ValueStruct.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+    #elif HAS_LCD_MENU
+      ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
+      ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
+      ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
+      ui.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
+      ui.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
+      ui.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+    #endif
   #endif
 
   //

commit 2ddd7d2d8def661448b248ae062e76ffd8a96a9a
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Fri Jun 12 03:44:48 2020 +0200

    Fix extra comma typo (#18262)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 691ce92b5d..aa150671d2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2783,7 +2783,7 @@ void MarlinSettings::reset() {
       #if EXTRUDERS == 1
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled)
-                              , " D", LINEAR_UNIT(planner.filament_size[0]),
+                              , " D", LINEAR_UNIT(planner.filament_size[0])
                               #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
                                 , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
                               #endif

commit f2b2b391db124dbfdffe35e82bd9c4540a576e47
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Tue Jun 9 02:54:39 2020 +0200

    Fix EEPROM struct (#18234)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ba242a7f02..691ce92b5d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1796,9 +1796,7 @@ void MarlinSettings::postprocess() {
         struct {
           bool volumetric_enabled;
           float filament_size[EXTRUDERS];
-          #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-            float volumetric_extruder_limit[EXTRUDERS];
-          #endif
+          float volumetric_extruder_limit[EXTRUDERS];
         } storage;
 
         _FIELD_TEST(parser_volumetric_enabled);

commit bac760207c3e85b9ac97a36c37aeb4ad601102a3
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Mon Jun 8 10:24:46 2020 +0200

    Add volumetric extrusion limit (#17017)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ead9ea060e..ba242a7f02 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V79"
+#define EEPROM_VERSION "V80"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -320,8 +320,9 @@ typedef struct SettingsDataStruct {
   //
   // !NO_VOLUMETRIC
   //
-  bool parser_volumetric_enabled;                       // M200 D  parser.volumetric_enabled
+  bool parser_volumetric_enabled;                       // M200 S  parser.volumetric_enabled
   float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
+  float planner_volumetric_extruder_limit[EXTRUDERS];   // M200 T L  planner.volumetric_extruder_limit[]
 
   //
   // HAS_TRINAMIC_CONFIG
@@ -935,12 +936,20 @@ void MarlinSettings::postprocess() {
 
         EEPROM_WRITE(parser.volumetric_enabled);
         EEPROM_WRITE(planner.filament_size);
+        #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+          EEPROM_WRITE(planner.volumetric_extruder_limit);
+        #else
+          dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
+          for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
+        #endif
 
       #else
 
         const bool volumetric_enabled = false;
-        dummyf = DEFAULT_NOMINAL_FILAMENT_DIA;
         EEPROM_WRITE(volumetric_enabled);
+        dummyf = DEFAULT_NOMINAL_FILAMENT_DIA;
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
+        dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
         for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
 
       #endif
@@ -1787,6 +1796,9 @@ void MarlinSettings::postprocess() {
         struct {
           bool volumetric_enabled;
           float filament_size[EXTRUDERS];
+          #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+            float volumetric_extruder_limit[EXTRUDERS];
+          #endif
         } storage;
 
         _FIELD_TEST(parser_volumetric_enabled);
@@ -1796,6 +1808,9 @@ void MarlinSettings::postprocess() {
           if (!validating) {
             parser.volumetric_enabled = storage.volumetric_enabled;
             COPY(planner.filament_size, storage.filament_size);
+            #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+              COPY(planner.volumetric_extruder_limit, storage.volumetric_extruder_limit);
+            #endif
           }
         #endif
       }
@@ -2598,6 +2613,10 @@ void MarlinSettings::reset() {
     parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
     LOOP_L_N(q, COUNT(planner.filament_size))
       planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      LOOP_L_N(q, COUNT(planner.volumetric_extruder_limit))
+        planner.volumetric_extruder_limit[q] = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
+    #endif
   #endif
 
   endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
@@ -2750,7 +2769,7 @@ void MarlinSettings::reset() {
 
     SERIAL_EOL();
 
-    #if DISABLED(NO_VOLUMETRICS)
+    #if EXTRUDERS && DISABLED(NO_VOLUMETRICS)
 
       /**
        * Volumetric extrusion M200
@@ -2765,20 +2784,26 @@ void MarlinSettings::reset() {
 
       #if EXTRUDERS == 1
         CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-      #elif EXTRUDERS
+        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled)
+                              , " D", LINEAR_UNIT(planner.filament_size[0]),
+                              #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
+                              #endif
+                         );
+      #else
         LOOP_L_N(i, EXTRUDERS) {
           CONFIG_ECHO_START();
-          SERIAL_ECHOPGM("  M200");
-          if (i) SERIAL_ECHOPAIR_P(SP_T_STR, int(i));
-          SERIAL_ECHOLNPAIR(" D", LINEAR_UNIT(planner.filament_size[i]));
+          SERIAL_ECHOLNPAIR("  M200 T", int(i)
+                                , " D", LINEAR_UNIT(planner.filament_size[i])
+                                #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+                                  , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
+                                #endif
+                           );
         }
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled));
       #endif
-
-      if (!parser.volumetric_enabled)
-        CONFIG_ECHO_MSG("  M200 D0");
-
-    #endif // !NO_VOLUMETRICS
+    #endif // EXTRUDERS && !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
     report_M92(!forReplay);

commit cfd31ff70ee949eb5eea61bf30eac24aef9fcb9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 23:18:23 2020 -0500

    Add HAS_FILAMENT_RUNOUT_DISTANCE

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d86016db6d..ead9ea060e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -604,7 +604,7 @@ void MarlinSettings::postprocess() {
       #else
         constexpr bool runout_sensor_enabled = true;
       #endif
-      #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
+      #if HAS_FILAMENT_RUNOUT_DISTANCE
         const float &runout_distance_mm = runout.runout_distance();
       #else
         constexpr float runout_distance_mm = 0;
@@ -1460,7 +1460,7 @@ void MarlinSettings::postprocess() {
 
         float runout_distance_mm;
         EEPROM_READ(runout_distance_mm);
-        #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
+        #if HAS_FILAMENT_RUNOUT_DISTANCE
           if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
@@ -2384,9 +2384,7 @@ void MarlinSettings::reset() {
   #if HAS_FILAMENT_SENSOR
     runout.enabled = true;
     runout.reset();
-    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
-      runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM);
-    #endif
+    TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM));
   #endif
 
   //
@@ -3551,7 +3549,7 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
         "  M412 S", int(runout.enabled)
-        #ifdef FILAMENT_RUNOUT_DISTANCE_MM
+        #if HAS_FILAMENT_RUNOUT_DISTANCE
           , " D", LINEAR_UNIT(runout.runout_distance())
         #endif
       );

commit 461647fcee5f9d519e0e54f809dbfb38bf573e59
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 22 02:15:40 2020 -0500

    Use MARLIN_EEPROM_SIZE with E2END as fallback (#18059)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2ebff1f035..d86016db6d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -389,7 +389,7 @@ typedef struct SettingsDataStruct {
 
 } SettingsData;
 
-//static_assert(sizeof(SettingsData) <= E2END + 1, "EEPROM too small to contain SettingsData!");
+//static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 

commit 52aa459a2dc08a8f803ad9ffb7aa173dc449637f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 10 00:12:56 2020 -0500

    Improved EEPROM boot error (#17916)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a42aa2d52d..2ebff1f035 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V78"
+#define EEPROM_VERSION "V79"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -1367,9 +1367,7 @@ void MarlinSettings::postprocess() {
       }
       DEBUG_ECHO_START();
       DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-        LCD_MESSAGEPGM(MSG_ERR_EEPROM_VERSION);
-      #endif
+      TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
@@ -2141,17 +2139,13 @@ void MarlinSettings::postprocess() {
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
-        #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-          LCD_MESSAGEPGM(MSG_ERR_EEPROM_INDEX);
-        #endif
+        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-          LCD_MESSAGEPGM(MSG_ERR_EEPROM_CRC);
-        #endif
+        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();

commit 6947dc139e4e81fed3986510eb32a93c58bd256c
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Wed May 6 14:10:04 2020 +0530

    Fix M503 output formatting (#17893)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 25a00224fd..a42aa2d52d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3211,6 +3211,7 @@ void MarlinSettings::reset() {
         #if AXIS_IS_TMC(Z)
           SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
         #endif
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
@@ -3225,6 +3226,7 @@ void MarlinSettings::reset() {
         #if AXIS_IS_TMC(Z2)
           SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
         #endif
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(Z3)
@@ -3278,34 +3280,30 @@ void MarlinSettings::reset() {
         CONFIG_ECHO_HEADING("Hybrid Threshold:");
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           say_M913(forReplay);
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
+          #if AXIS_HAS_STEALTHCHOP(X)
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Y)
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Z)
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
+          #endif
           SERIAL_EOL();
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
           say_M913(forReplay);
           SERIAL_ECHOPGM(" I1");
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
+          #if AXIS_HAS_STEALTHCHOP(X2)
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Y2)
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Z2)
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
+          #endif
           SERIAL_EOL();
         #endif
 

commit 7c3909bc3f5ea84a59f7dce4e3a378f7e2c4e5ba
Author: Neil van Geffen <neilvangeffen@gmail.com>
Date:   Tue Apr 28 18:22:03 2020 +1200

    Save/Load distinct TMC SG thresholds (#17741)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1582cf7067..25a00224fd 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V77"
+#define EEPROM_VERSION "V78"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -135,7 +135,7 @@
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
 typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z, X2;                                                 } tmc_sgt_t;
+typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
@@ -328,7 +328,7 @@ typedef struct SettingsDataStruct {
   //
   tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
   tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2
+  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2 Y2 Z2 Z3 Z4
   tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
 
   //
@@ -1112,10 +1112,14 @@ void MarlinSettings::postprocess() {
     {
       tmc_sgt_t tmc_sgt{0};
       #if USE_SENSORLESS
-        TERN_(X_SENSORLESS, tmc_sgt.X = stepperX.homing_threshold());
+        TERN_(X_SENSORLESS,  tmc_sgt.X  = stepperX.homing_threshold());
         TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
-        TERN_(Y_SENSORLESS, tmc_sgt.Y = stepperY.homing_threshold());
-        TERN_(Z_SENSORLESS, tmc_sgt.Z = stepperZ.homing_threshold());
+        TERN_(Y_SENSORLESS,  tmc_sgt.Y  = stepperY.homing_threshold());
+        TERN_(Y2_SENSORLESS, tmc_sgt.Y2 = stepperY2.homing_threshold());
+        TERN_(Z_SENSORLESS,  tmc_sgt.Z  = stepperZ.homing_threshold());
+        TERN_(Z2_SENSORLESS, tmc_sgt.Z2 = stepperZ2.homing_threshold());
+        TERN_(Z3_SENSORLESS, tmc_sgt.Z3 = stepperZ3.homing_threshold());
+        TERN_(Z4_SENSORLESS, tmc_sgt.Z4 = stepperZ4.homing_threshold());
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
@@ -1929,9 +1933,6 @@ void MarlinSettings::postprocess() {
 
       //
       // TMC StallGuard threshold.
-      // X and X2 use the same value
-      // Y and Y2 use the same value
-      // Z, Z2, Z3 and Z4 use the same value
       //
       {
         tmc_sgt_t tmc_sgt;
@@ -1939,37 +1940,14 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(tmc_sgt);
         #if USE_SENSORLESS
           if (!validating) {
-            #ifdef X_STALL_SENSITIVITY
-              #if AXIS_HAS_STALLGUARD(X)
-                stepperX.homing_threshold(tmc_sgt.X);
-              #endif
-              #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
-                stepperX2.homing_threshold(tmc_sgt.X);
-              #endif
-            #endif
+            TERN_(X_SENSORLESS,  stepperX.homing_threshold(tmc_sgt.X));
             TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
-            #ifdef Y_STALL_SENSITIVITY
-              #if AXIS_HAS_STALLGUARD(Y)
-                stepperY.homing_threshold(tmc_sgt.Y);
-              #endif
-              #if AXIS_HAS_STALLGUARD(Y2)
-                stepperY2.homing_threshold(tmc_sgt.Y);
-              #endif
-            #endif
-            #ifdef Z_STALL_SENSITIVITY
-              #if AXIS_HAS_STALLGUARD(Z)
-                stepperZ.homing_threshold(tmc_sgt.Z);
-              #endif
-              #if AXIS_HAS_STALLGUARD(Z2)
-                stepperZ2.homing_threshold(tmc_sgt.Z);
-              #endif
-              #if AXIS_HAS_STALLGUARD(Z3)
-                stepperZ3.homing_threshold(tmc_sgt.Z);
-              #endif
-              #if AXIS_HAS_STALLGUARD(Z4)
-                stepperZ4.homing_threshold(tmc_sgt.Z);
-              #endif
-            #endif
+            TERN_(Y_SENSORLESS,  stepperY.homing_threshold(tmc_sgt.Y));
+            TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(tmc_sgt.Y2));
+            TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(tmc_sgt.Z));
+            TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(tmc_sgt.Z2));
+            TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
+            TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
           }
         #endif
       }

commit 01c646a892c9cd36baf577ca9be344e3490a7727
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 22:35:25 2020 -0500

    Apply more HAS_HOTEND

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ea324731c5..1582cf7067 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -799,7 +799,7 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(ui_preheat_hotend_temp);
 
-      #if HOTENDS && HAS_LCD_MENU
+      #if HAS_HOTEND && HAS_LCD_MENU
         const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                       (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
         const uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
@@ -1649,7 +1649,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(ui_preheat_hotend_temp);
 
-        #if HOTENDS && HAS_LCD_MENU
+        #if HAS_HOTEND && HAS_LCD_MENU
           int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                   (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
           uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
@@ -2557,7 +2557,7 @@ void MarlinSettings::reset() {
   // Preheat parameters
   //
 
-  #if HOTENDS && HAS_LCD_MENU
+  #if HAS_HOTEND && HAS_LCD_MENU
     ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
     ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
     ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
@@ -3077,7 +3077,7 @@ void MarlinSettings::reset() {
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
-    #if HOTENDS && HAS_LCD_MENU
+    #if HAS_HOTEND && HAS_LCD_MENU
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       LOOP_L_N(i, COUNT(ui.preheat_hotend_temp)) {

commit e1ad955897f8f2fec1a3797ab45453b2581ed5b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 05:06:55 2020 -0500

    Revert EEPROM tweak

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index df845c593c..ea324731c5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3224,33 +3224,29 @@ void MarlinSettings::reset() {
 
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(forReplay);
-        SERIAL_ECHOLNPAIR_P(
-          #if AXIS_IS_TMC(X)
-            SP_X_STR, stepperX.getMilliamps(),
-          #endif
-          #if AXIS_IS_TMC(Y)
-            SP_Y_STR, stepperY.getMilliamps(),
-          #endif
-          #if AXIS_IS_TMC(Z)
-            SP_Z_STR, stepperZ.getMilliamps()
-          #endif
-        );
+        #if AXIS_IS_TMC(X)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
+        #endif
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(forReplay);
         SERIAL_ECHOPGM(" I1");
-        SERIAL_ECHOLNPAIR_P(
-          #if AXIS_IS_TMC(X2)
-            SP_X_STR, stepperX2.getMilliamps(),
-          #endif
-          #if AXIS_IS_TMC(Y2)
-            SP_Y_STR, stepperY2.getMilliamps(),
-          #endif
-          #if AXIS_IS_TMC(Z2)
-            SP_Z_STR, stepperZ2.getMilliamps()
-          #endif
-        );
+        #if AXIS_IS_TMC(X2)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
+        #endif
       #endif
 
       #if AXIS_IS_TMC(Z3)

commit 4ed912eb23744f750bbb4658f0a1822f5397457f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 25 16:32:08 2020 -0500

    Misc. patches

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 72336f7cc1..df845c593c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3224,31 +3224,33 @@ void MarlinSettings::reset() {
 
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(forReplay);
-        #if AXIS_IS_TMC(X)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
-        #endif
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR_P(
+          #if AXIS_IS_TMC(X)
+            SP_X_STR, stepperX.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Y)
+            SP_Y_STR, stepperY.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Z)
+            SP_Z_STR, stepperZ.getMilliamps()
+          #endif
+        );
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(forReplay);
         SERIAL_ECHOPGM(" I1");
-        #if AXIS_IS_TMC(X2)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z2)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
-        #endif
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR_P(
+          #if AXIS_IS_TMC(X2)
+            SP_X_STR, stepperX2.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Y2)
+            SP_Y_STR, stepperY2.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Z2)
+            SP_Z_STR, stepperZ2.getMilliamps()
+          #endif
+        );
       #endif
 
       #if AXIS_IS_TMC(Z3)
@@ -3451,9 +3453,9 @@ void MarlinSettings::reset() {
 
         if (chop_x || chop_y || chop_z) {
           say_M569(forReplay);
-          if (chop_x) SERIAL_ECHO_P(SP_X_STR);
-          if (chop_y) SERIAL_ECHO_P(SP_Y_STR);
-          if (chop_z) SERIAL_ECHO_P(SP_Z_STR);
+          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
@@ -3475,9 +3477,9 @@ void MarlinSettings::reset() {
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
-          if (chop_x2) SERIAL_ECHO_P(SP_X_STR);
-          if (chop_y2) SERIAL_ECHO_P(SP_Y_STR);
-          if (chop_z2) SERIAL_ECHO_P(SP_Z_STR);
+          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 

commit 75c17c7a67843b0464d8dc005bf93a856639da62
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Apr 26 06:29:30 2020 +1200

    Include echo: with M503 output (#17665)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b38dc6caa3..72336f7cc1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2824,8 +2824,8 @@ void MarlinSettings::reset() {
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START();
       LOOP_L_N(i, E_STEPPERS) {
+        CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M203 T"), (int)i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
@@ -2844,12 +2844,13 @@ void MarlinSettings::reset() {
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START();
-      LOOP_L_N(i, E_STEPPERS)
+      LOOP_L_N(i, E_STEPPERS) {
+        CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M201 T"), (int)i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
         );
+      }
     #endif
 
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
@@ -3522,12 +3523,14 @@ void MarlinSettings::reset() {
      */
     #if ENABLED(LIN_ADVANCE)
       CONFIG_ECHO_HEADING("Linear Advance:");
-      CONFIG_ECHO_START();
       #if EXTRUDERS < 2
+        CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
       #else
-        LOOP_L_N(i, EXTRUDERS)
+        LOOP_L_N(i, EXTRUDERS) {
+          CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
+        }
       #endif
     #endif
 

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a919562d64..b38dc6caa3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3099,7 +3099,7 @@ void MarlinSettings::reset() {
         HOTEND_LOOP() {
           CONFIG_ECHO_START();
           SERIAL_ECHOPAIR_P(
-            #if HAS_MULTI_HOTEND && ENABLED(PID_PARAMS_PER_HOTEND)
+            #if BOTH(HAS_MULTI_HOTEND, PID_PARAMS_PER_HOTEND)
               PSTR("  M301 E"), e,
               SP_P_STR
             #else

commit 55d66fb8971d9e5dbfb15e7ae5c952839b488f59
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 20:49:11 2020 -0500

    Add HAS_JUNCTION_DEVIATION

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 84b8c75370..a919562d64 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2393,7 +2393,7 @@ void MarlinSettings::reset() {
     TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
   #endif
 
-  #if DISABLED(CLASSIC_JERK)
+  #if HAS_JUNCTION_DEVIATION
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #endif
 
@@ -2862,7 +2862,7 @@ void MarlinSettings::reset() {
 
     CONFIG_ECHO_HEADING(
       "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
-      #if DISABLED(CLASSIC_JERK)
+      #if HAS_JUNCTION_DEVIATION
         " J<junc_dev>"
       #endif
       #if HAS_CLASSIC_JERK
@@ -2875,7 +2875,7 @@ void MarlinSettings::reset() {
         PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
       , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
       , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
-      #if DISABLED(CLASSIC_JERK)
+      #if HAS_JUNCTION_DEVIATION
         , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
       #if HAS_CLASSIC_JERK

commit 2f6262c27b11598293839f6d46f3b340ee6a1f4c
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Thu Apr 23 04:03:28 2020 +0200

    Automatic Tool Migration feature (#17248)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 698447a4be..84b8c75370 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2423,16 +2423,32 @@ void MarlinSettings::reset() {
 
   #if EXTRUDERS > 1
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-      toolchange_settings.swap_length = TOOLCHANGE_FIL_SWAP_LENGTH;
-      toolchange_settings.extra_prime = TOOLCHANGE_FIL_EXTRA_PRIME;
-      toolchange_settings.prime_speed = TOOLCHANGE_FIL_SWAP_PRIME_SPEED;
-      toolchange_settings.retract_speed = TOOLCHANGE_FIL_SWAP_RETRACT_SPEED;
+      toolchange_settings.swap_length     = TOOLCHANGE_FS_LENGTH;
+      toolchange_settings.extra_resume    = TOOLCHANGE_FS_EXTRA_RESUME_LENGTH;
+      toolchange_settings.retract_speed   = TOOLCHANGE_FS_RETRACT_SPEED;
+      toolchange_settings.unretract_speed = TOOLCHANGE_FS_UNRETRACT_SPEED;
+      toolchange_settings.extra_prime     = TOOLCHANGE_FS_EXTRA_PRIME;
+      toolchange_settings.prime_speed     = TOOLCHANGE_FS_PRIME_SPEED;
+      toolchange_settings.fan_speed       = TOOLCHANGE_FS_FAN_SPEED;
+      toolchange_settings.fan_time        = TOOLCHANGE_FS_FAN_TIME;
     #endif
+
+    #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
+      enable_first_prime = false;
+    #endif
+
     #if ENABLED(TOOLCHANGE_PARK)
       constexpr xyz_pos_t tpxy = TOOLCHANGE_PARK_XY;
+      toolchange_settings.enable_park = true;
       toolchange_settings.change_point = tpxy;
     #endif
+
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
+
+    #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
+      migration = migration_defaults;
+    #endif
+
   #endif
 
   #if ENABLED(BACKLASH_GCODE)

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d201a45e6d..698447a4be 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -126,9 +126,9 @@
   void M710_report(const bool forReplay);
 #endif
 
-#define HAS_CASE_LIGHT_BRIGHTNESS (ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS))
-#if HAS_CASE_LIGHT_BRIGHTNESS
+#if ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
   #include "../feature/caselight.h"
+  #define HAS_CASE_LIGHT_BRIGHTNESS 1
 #endif
 
 #pragma pack(push, 1) // No padding between variables
@@ -235,7 +235,7 @@ typedef struct SettingsDataStruct {
             #if ENABLED(USE_TEMP_EXT_COMPENSATION)
               , z_offsets_ext[COUNT(temp_comp.z_offsets_ext)]  // M871 E I V
             #endif
-          ;
+            ;
   #endif
 
   //
@@ -411,13 +411,9 @@ void MarlinSettings::postprocess() {
 
   // Make sure delta kinematics are updated before refreshing the
   // planner position so the stepper counts will be set correctly.
-  #if ENABLED(DELTA)
-    recalc_delta_settings();
-  #endif
+  TERN_(DELTA, recalc_delta_settings());
 
-  #if ENABLED(PIDTEMP)
-    thermalManager.updatePID();
-  #endif
+  TERN_(PIDTEMP, thermalManager.updatePID());
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
@@ -432,29 +428,17 @@ void MarlinSettings::postprocess() {
     update_software_endstops((AxisEnum)i);
   }
 
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    set_z_fade_height(new_z_fade_height, false); // false = no report
-  #endif
+  TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
-  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-    refresh_bed_level();
-  #endif
+  TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
-  #if HAS_MOTOR_CURRENT_PWM
-    stepper.refresh_motor_power();
-  #endif
+  TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
-  #if ENABLED(FWRETRACT)
-    fwretract.refresh_autoretract();
-  #endif
+  TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
-  #if HAS_LINEAR_E_JERK
-    planner.recalculate_max_e_jerk();
-  #endif
+  TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
-  #if HAS_CASE_LIGHT_BRIGHTNESS
-    update_case_light();
-  #endif
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, update_case_light());
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
@@ -585,9 +569,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
-      #if ENABLED(CLASSIC_JERK)
-        dummyf = 0.02f;
-      #endif
+      TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
@@ -1130,18 +1112,10 @@ void MarlinSettings::postprocess() {
     {
       tmc_sgt_t tmc_sgt{0};
       #if USE_SENSORLESS
-        #if X_SENSORLESS
-          tmc_sgt.X = stepperX.homing_threshold();
-        #endif
-        #if X2_SENSORLESS
-          tmc_sgt.X2 = stepperX2.homing_threshold();
-        #endif
-        #if Y_SENSORLESS
-          tmc_sgt.Y = stepperY.homing_threshold();
-        #endif
-        #if Z_SENSORLESS
-          tmc_sgt.Z = stepperZ.homing_threshold();
-        #endif
+        TERN_(X_SENSORLESS, tmc_sgt.X = stepperX.homing_threshold());
+        TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
+        TERN_(Y_SENSORLESS, tmc_sgt.Y = stepperY.homing_threshold());
+        TERN_(Z_SENSORLESS, tmc_sgt.Z = stepperZ.homing_threshold());
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
@@ -1362,9 +1336,7 @@ void MarlinSettings::postprocess() {
 
     if (!eeprom_error) LCD_MESSAGEPGM(MSG_SETTINGS_STORED);
 
-    #if ENABLED(EXTENSIBLE_UI)
-      ExtUI::onConfigurationStoreWritten(!eeprom_error);
-    #endif
+    TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
 
     return !eeprom_error;
   }
@@ -1703,12 +1675,8 @@ void MarlinSettings::postprocess() {
               PID_PARAM(Kp, e) = pidcf.Kp;
               PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
               PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
-              #if ENABLED(PID_EXTRUSION_SCALING)
-                PID_PARAM(Kc, e) = pidcf.Kc;
-              #endif
-              #if ENABLED(PID_FAN_SCALING)
-                PID_PARAM(Kf, e) = pidcf.Kf;
-              #endif
+              TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
+              TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
             }
           #endif
         }
@@ -1761,9 +1729,7 @@ void MarlinSettings::postprocess() {
 
         int16_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
-        #if HAS_LCD_CONTRAST
-          ui.set_contrast(lcd_contrast);
-        #endif
+        TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
       }
 
       //
@@ -1981,9 +1947,7 @@ void MarlinSettings::postprocess() {
                 stepperX2.homing_threshold(tmc_sgt.X);
               #endif
             #endif
-            #if X2_SENSORLESS
-              stepperX2.homing_threshold(tmc_sgt.X2);
-            #endif
+            TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
             #ifdef Y_STALL_SENSITIVITY
               #if AXIS_HAS_STALLGUARD(Y)
                 stepperY.homing_threshold(tmc_sgt.Y);
@@ -2284,9 +2248,7 @@ void MarlinSettings::postprocess() {
   bool MarlinSettings::load() {
     if (validate()) {
       const bool success = _load();
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onConfigurationStoreRead(success);
-      #endif
+      TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreRead(success));
       return success;
     }
     reset();
@@ -2428,9 +2390,7 @@ void MarlinSettings::reset() {
       #define DEFAULT_ZJERK 0
     #endif
     planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
-    #if HAS_CLASSIC_E_JERK
-      planner.max_jerk.e = DEFAULT_EJERK;
-    #endif
+    TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
   #endif
 
   #if DISABLED(CLASSIC_JERK)
@@ -2443,9 +2403,7 @@ void MarlinSettings::reset() {
     home_offset.reset();
   #endif
 
-  #if HAS_HOTEND_OFFSET
-    reset_hotend_offsets();
-  #endif
+  TERN_(HAS_HOTEND_OFFSET, reset_hotend_offsets());
 
   //
   // Filament Runout Sensor
@@ -2486,37 +2444,23 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
-  #if ENABLED(EXTENSIBLE_UI)
-    ExtUI::onFactoryReset();
-  #endif
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 
   //
   // Case Light Brightness
   //
-
-  #if HAS_CASE_LIGHT_BRIGHTNESS
-    case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
-  #endif
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // Magnetic Parking Extruder
   //
-
-  #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
-    mpe_settings_init();
-  #endif
+  TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
-
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    new_z_fade_height = 0.0;
-  #endif
-
-  #if HAS_LEVELING
-    reset_bed_level();
-  #endif
+  TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
+  TERN_(HAS_LEVELING, reset_bed_level());
 
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
@@ -2532,18 +2476,12 @@ void MarlinSettings::reset() {
   //
   // Z Stepper Auto-alignment points
   //
-
-  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
-    z_stepper_align.reset_to_default();
-  #endif
+  TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
   //
   // Servo Angles
   //
-
-  #if ENABLED(EDITABLE_SERVO_ANGLES)
-    COPY(servo_angles, base_servo_angles);  // When not editable only one copy of servo angles exists
-  #endif
+  TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
 
   //
   // BLTOUCH
@@ -2564,7 +2502,6 @@ void MarlinSettings::reset() {
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_tower_angle_trim = dta;
-
   #endif
 
   #if ENABLED(X_DUAL_ENDSTOPS)
@@ -2622,23 +2559,15 @@ void MarlinSettings::reset() {
       PID_PARAM(Kp, e) = float(DEFAULT_Kp);
       PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);
       PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        PID_PARAM(Kc, e) = DEFAULT_Kc;
-      #endif
-
-      #if ENABLED(PID_FAN_SCALING)
-        PID_PARAM(Kf, e) = DEFAULT_Kf;
-      #endif
+      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = DEFAULT_Kc);
+      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = DEFAULT_Kf);
     }
   #endif
 
   //
   // PID Extrusion Scaling
   //
-
-  #if ENABLED(PID_EXTRUSION_SCALING)
-    thermalManager.lpq_len = 20;  // Default last-position-queue size
-  #endif
+  TERN_(PID_EXTRUSION_SCALING, thermalManager.lpq_len = 20); // Default last-position-queue size
 
   //
   // Heated Bed PID
@@ -2653,67 +2582,39 @@ void MarlinSettings::reset() {
   //
   // User-Defined Thermistors
   //
-
-  #if HAS_USER_THERMISTORS
-    thermalManager.reset_user_thermistors();
-  #endif
+  TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
   //
   // LCD Contrast
   //
-
-  #if HAS_LCD_CONTRAST
-    ui.set_contrast(DEFAULT_LCD_CONTRAST);
-  #endif
+  TERN_(HAS_LCD_CONTRAST, ui.set_contrast(DEFAULT_LCD_CONTRAST));
 
   //
   // Controller Fan
   //
-  #if ENABLED(USE_CONTROLLER_FAN)
-    controllerFan.reset();
-  #endif
+  TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.enable(ENABLED(PLR_ENABLED_DEFAULT));
-  #endif
+  TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
 
   //
   // Firmware Retraction
   //
-
-  #if ENABLED(FWRETRACT)
-    fwretract.reset();
-  #endif
+  TERN_(FWRETRACT, fwretract.reset());
 
   //
   // Volumetric & Filament Size
   //
 
   #if DISABLED(NO_VOLUMETRICS)
-
-    parser.volumetric_enabled =
-      #if ENABLED(VOLUMETRIC_DEFAULT_ON)
-        true
-      #else
-        false
-      #endif
-    ;
+    parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
     LOOP_L_N(q, COUNT(planner.filament_size))
       planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
-
   #endif
 
-  endstops.enable_globally(
-    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
-      true
-    #else
-      false
-    #endif
-  );
+  endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
   reset_stepper_drivers();
 
@@ -2724,9 +2625,7 @@ void MarlinSettings::reset() {
   #if ENABLED(LIN_ADVANCE)
     LOOP_L_N(i, EXTRUDERS) {
       planner.extruder_advance_K[i] = LIN_ADVANCE_K;
-      #if ENABLED(EXTRA_LIN_ADVANCE_K)
-        other_extruder_advance_K[i] = LIN_ADVANCE_K;
-      #endif
+      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[i] = LIN_ADVANCE_K);
     }
   #endif
 
@@ -2743,15 +2642,11 @@ void MarlinSettings::reset() {
   //
   // CNC Coordinate System
   //
-
-  #if ENABLED(CNC_COORDINATE_SYSTEMS)
-    (void)gcode.select_coordinate_system(-1); // Go back to machine space
-  #endif
+  TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
 
   //
   // Skew Correction
   //
-
   #if ENABLED(SKEW_CORRECTION_GCODE)
     planner.skew_factor.xy = XY_SKEW_FACTOR;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
@@ -2763,7 +2658,6 @@ void MarlinSettings::reset() {
   //
   // Advanced Pause filament load & unload lengths
   //
-
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     LOOP_L_N(e, EXTRUDERS) {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
@@ -2776,9 +2670,7 @@ void MarlinSettings::reset() {
   DEBUG_ECHO_START();
   DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
 
-  #if ENABLED(EXTENSIBLE_UI)
-    ExtUI::onFactoryReset();
-  #endif
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
@@ -2959,9 +2851,7 @@ void MarlinSettings::reset() {
       #endif
       #if HAS_CLASSIC_JERK
         " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
-        #if HAS_CLASSIC_E_JERK
-          " E<max_e_jerk>"
-        #endif
+        TERN_(HAS_CLASSIC_E_JERK, " E<max_e_jerk>")
       #endif
     );
     CONFIG_ECHO_START();
@@ -3237,9 +3127,7 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
     #endif
 
-    #if ENABLED(CONTROLLER_FAN_EDITABLE)
-      M710_report(forReplay);
-    #endif
+    TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");

commit 000ec9fc139413c7702e8e295a29a21f6a6226e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 20 09:43:15 2020 -0500

    Ensure language.h include order
    
    See #17604

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index cdc4432a53..d201a45e6d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -51,7 +51,6 @@
 #include "stepper.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
-#include "../core/language.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0211c303eb..cdc4432a53 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3194,7 +3194,7 @@ void MarlinSettings::reset() {
         HOTEND_LOOP() {
           CONFIG_ECHO_START();
           SERIAL_ECHOPAIR_P(
-            #if HOTENDS > 1 && ENABLED(PID_PARAMS_PER_HOTEND)
+            #if HAS_MULTI_HOTEND && ENABLED(PID_PARAMS_PER_HOTEND)
               PSTR("  M301 E"), e,
               SP_P_STR
             #else

commit 71a4ab3331bf40b985ae9ed214459bc12d0679dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 9 12:28:09 2020 -0500

    Add "Settings Stored" message

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a2beb322f9..0211c303eb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1361,6 +1361,8 @@ void MarlinSettings::postprocess() {
         store_mesh(ubl.storage_slot);
     #endif
 
+    if (!eeprom_error) LCD_MESSAGEPGM(MSG_SETTINGS_STORED);
+
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onConfigurationStoreWritten(!eeprom_error);
     #endif

commit 514afddeb4b3a7ede9ff481504aae69219a95f68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 18:53:58 2020 -0500

    Minor code cleanup

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b2c728fbe0..a2beb322f9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1391,7 +1391,7 @@ void MarlinSettings::postprocess() {
       DEBUG_ECHO_START();
       DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-        ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_VERSION));
+        LCD_MESSAGEPGM(MSG_ERR_EEPROM_VERSION);
       #endif
       eeprom_error = true;
     }
@@ -2199,7 +2199,7 @@ void MarlinSettings::postprocess() {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
         #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-          ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_INDEX));
+          LCD_MESSAGEPGM(MSG_ERR_EEPROM_INDEX);
         #endif
       }
       else if (working_crc != stored_crc) {
@@ -2207,7 +2207,7 @@ void MarlinSettings::postprocess() {
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
-          ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_CRC));
+          LCD_MESSAGEPGM(MSG_ERR_EEPROM_CRC);
         #endif
       }
       else if (!validating) {

commit 7f5dc7b91920ffd4ecd8b70e58bc97cc6be39fa2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 15:00:43 2020 -0500

    More 8 extruders (TMC) support

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2ecc9299c9..b2c728fbe0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V76"
+#define EEPROM_VERSION "V77"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -134,10 +134,10 @@
 
 #pragma pack(push, 1) // No padding between variables
 
-typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
-typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z, X2;                                     } tmc_sgt_t;
-typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
+typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
+typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
+typedef struct {  int16_t X, Y, Z, X2;                                                 } tmc_sgt_t;
+typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, COUNT(ARR) - 1)

commit 8752fbd92c8edcd777b6a2afe54f4d70d3fc4d85
Author: Mathias Rasmussen <mathiasvr@gmail.com>
Date:   Fri Mar 27 23:38:28 2020 +0100

    Store case light brightness in EEPROM (#17307)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d80fe50195..2ecc9299c9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -127,6 +127,11 @@
   void M710_report(const bool forReplay);
 #endif
 
+#define HAS_CASE_LIGHT_BRIGHTNESS (ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS))
+#if HAS_CASE_LIGHT_BRIGHTNESS
+  #include "../feature/caselight.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
@@ -376,6 +381,13 @@ typedef struct SettingsDataStruct {
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
+  //
+  // HAS_CASE_LIGHT_BRIGHTNESS
+  //
+  #if HAS_CASE_LIGHT_BRIGHTNESS
+    uint8_t case_light_brightness;
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= E2END + 1, "EEPROM too small to contain SettingsData!");
@@ -441,6 +453,10 @@ void MarlinSettings::postprocess() {
     planner.recalculate_max_e_jerk();
   #endif
 
+  #if HAS_CASE_LIGHT_BRIGHTNESS
+    update_case_light();
+  #endif
+
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
@@ -1309,6 +1325,13 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
+    //
+    // Case Light Brightness
+    //
+    #if HAS_CASE_LIGHT_BRIGHTNESS
+      EEPROM_WRITE(case_light_brightness);
+    #endif
+
     //
     // Validate CRC and Data Size
     //
@@ -2163,6 +2186,14 @@ void MarlinSettings::postprocess() {
         }
       #endif
 
+      //
+      // Case Light Brightness
+      //
+      #if HAS_CASE_LIGHT_BRIGHTNESS
+        _FIELD_TEST(case_light_brightness);
+        EEPROM_READ(case_light_brightness);
+      #endif
+
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
@@ -2458,6 +2489,14 @@ void MarlinSettings::reset() {
     ExtUI::onFactoryReset();
   #endif
 
+  //
+  // Case Light Brightness
+  //
+
+  #if HAS_CASE_LIGHT_BRIGHTNESS
+    case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
+  #endif
+
   //
   // Magnetic Parking Extruder
   //

commit 129b270628781eae776764e63fd514553e6c2204
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Mar 27 23:29:17 2020 +0100

    QSPI EEPROM for SAMD51 (#17292)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 129e207d29..d80fe50195 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -57,7 +57,7 @@
 #include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
-  #include "../HAL/shared/persistent_store_api.h"
+  #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"

commit 54a12ee1d6557d820fb353a318525aebd7f6c082
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 17:20:23 2020 -0500

    Tweak eeprom storage type

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 803095811e..129e207d29 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1231,7 +1231,7 @@ void MarlinSettings::postprocess() {
       #if HAS_MOTOR_CURRENT_PWM
         EEPROM_WRITE(stepper.motor_current_setting);
       #else
-        const xyz_ulong_t no_current{0};
+        const uint32_t no_current[3] = { 0 };
         EEPROM_WRITE(no_current);
       #endif
     }

commit 0175189c34807733c2230d36e470a713a8186d49
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 19:17:50 2020 -0500

    Allow G2_PWM to be slimmer

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4b7946c6a9..803095811e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2696,7 +2696,7 @@ void MarlinSettings::reset() {
 
   #if HAS_MOTOR_CURRENT_PWM
     constexpr uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
-    for (uint8_t q = 3; q--;)
+    LOOP_L_N(q, 3)
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 

commit 83eec683c969d793b473015476d03f868b470c04
Author: Erkan Colak <erkanc@gmx.de>
Date:   Wed Mar 18 19:41:12 2020 +0100

    New Controller Fan options and M710 gcode (#17149)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3a83dd7c1d..4b7946c6a9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -122,6 +122,11 @@
   #include "../feature/probe_temp_comp.h"
 #endif
 
+#include "../feature/controllerfan.h"
+#if ENABLED(CONTROLLER_FAN_EDITABLE)
+  void M710_report(const bool forReplay);
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
@@ -292,6 +297,11 @@ typedef struct SettingsDataStruct {
   //
   int16_t lcd_contrast;                                 // M250 C
 
+  //
+  // Controller fan settings
+  //
+  controllerFan_settings_t controllerFan_settings;      // M710
+
   //
   // POWER_LOSS_RECOVERY
   //
@@ -880,6 +890,19 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(lcd_contrast);
     }
 
+    //
+    // Controller Fan
+    //
+    {
+      _FIELD_TEST(controllerFan_settings);
+      #if ENABLED(USE_CONTROLLER_FAN)
+        const controllerFan_settings_t &cfs = controllerFan.settings;
+      #else
+        controllerFan_settings_t cfs = controllerFan_defaults;
+      #endif
+      EEPROM_WRITE(cfs);
+    }
+
     //
     // Power-Loss Recovery
     //
@@ -1719,6 +1742,19 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      //
+      // Controller Fan
+      //
+      {
+        _FIELD_TEST(controllerFan_settings);
+        #if ENABLED(CONTROLLER_FAN_EDITABLE)
+          const controllerFan_settings_t &cfs = controllerFan.settings;
+        #else
+          controllerFan_settings_t cfs = { 0 };
+        #endif
+        EEPROM_READ(cfs);
+      }
+
       //
       // Power-Loss Recovery
       //
@@ -2590,6 +2626,13 @@ void MarlinSettings::reset() {
     ui.set_contrast(DEFAULT_LCD_CONTRAST);
   #endif
 
+  //
+  // Controller Fan
+  //
+  #if ENABLED(USE_CONTROLLER_FAN)
+    controllerFan.reset();
+  #endif
+
   //
   // Power-Loss Recovery
   //
@@ -3154,6 +3197,10 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
     #endif
 
+    #if ENABLED(CONTROLLER_FAN_EDITABLE)
+      M710_report(forReplay);
+    #endif
+
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
       CONFIG_ECHO_START();

commit 85187290a78f0947eed8f590942e34da05ee447a
Author: Karl Andersson <karl@iaccess.se>
Date:   Mon Mar 16 00:03:10 2020 +0100

    Fix incorrect type on ubl_storage_slot (#17170)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index fd28c3cc40..3a83dd7c1d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1531,10 +1531,10 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(planner_leveling_active);
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           const bool &planner_leveling_active = planner.leveling_active;
-          const uint8_t &ubl_storage_slot = ubl.storage_slot;
+          const int8_t &ubl_storage_slot = ubl.storage_slot;
         #else
           bool planner_leveling_active;
-          uint8_t ubl_storage_slot;
+          int8_t ubl_storage_slot;
         #endif
         EEPROM_READ(planner_leveling_active);
         EEPROM_READ(ubl_storage_slot);

commit 090a90a0364fec1f13ade0680bbf26aa5aef23d9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 10 17:45:39 2020 -0500

    Add EEPROM_BOOT_SILENT option

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index eb77325094..fd28c3cc40 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2185,8 +2185,10 @@ void MarlinSettings::postprocess() {
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      if (!validating) report();
+      // Report the EEPROM settings
+      if (!validating && (DISABLED(EEPROM_BOOT_SILENT) || IsRunning())) report();
     #endif
+
     EEPROM_FINISH();
 
     return !eeprom_error;

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ae82e59447..eb77325094 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -583,7 +583,7 @@ void MarlinSettings::postprocess() {
 
       #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
-        for (uint8_t e = 1; e < HOTENDS; e++)
+        LOOP_S_L_N(e, 1, HOTENDS)
           EEPROM_WRITE(hotend_offset[e]);
       #endif
     }
@@ -1420,7 +1420,7 @@ void MarlinSettings::postprocess() {
       {
         #if HAS_HOTEND_OFFSET
           // Skip hotend 0 which must be 0
-          for (uint8_t e = 1; e < HOTENDS; e++)
+          LOOP_S_L_N(e, 1, HOTENDS)
             EEPROM_READ(hotend_offset[e]);
         #endif
       }
@@ -2915,7 +2915,7 @@ void MarlinSettings::reset() {
     #if HAS_HOTEND_OFFSET
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
-      for (uint8_t e = 1; e < HOTENDS; e++) {
+      LOOP_S_L_N(e, 1, HOTENDS) {
         SERIAL_ECHOPAIR_P(
           PSTR("  M218 T"), (int)e,
           SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 16e88b7bfd..ae82e59447 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -71,7 +71,7 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
-  #include "../lcd/extensible_ui/ui_api.h"
+  #include "../lcd/extui/ui_api.h"
 #endif
 
 #if HAS_SERVOS
@@ -87,7 +87,7 @@
 #include "../feature/fwretract.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
+  #include "../feature/powerloss.h"
 #endif
 
 #include "../feature/pause.h"
@@ -119,7 +119,7 @@
 #endif
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
-  #include "../feature/probe_temp_compensation.h"
+  #include "../feature/probe_temp_comp.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables

commit 64d092935b27ff89955f0430eef5815b15e5a92d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 7 22:20:41 2020 -0600

    More useful ENABLED / DISABLED macros (#17054)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9d1bbaab21..16e88b7bfd 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -181,11 +181,8 @@ typedef struct SettingsDataStruct {
   //
   float mbl_z_offset;                                   // mbl.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  #if ENABLED(MESH_BED_LEVELING)
-    float mbl_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y]; // mbl.z_values
-  #else
-    float mbl_z_values[3][3];
-  #endif
+  float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // mbl.z_values
+                    [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
@@ -533,11 +530,10 @@ void MarlinSettings::postprocess() {
     EEPROM_START();
 
     eeprom_error = false;
-    #if ENABLED(FLASH_EEPROM_EMULATION)
-      EEPROM_SKIP(ver);   // Flash doesn't allow rewriting without erase
-    #else
-      EEPROM_WRITE(ver);  // invalidate data first
-    #endif
+
+    // Write or Skip version. (Flash doesn't allow rewrite without erase.)
+    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
+
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"
@@ -564,12 +560,10 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
-      #if DISABLED(CLASSIC_JERK)
-        EEPROM_WRITE(planner.junction_deviation_mm);
-      #else
+      #if ENABLED(CLASSIC_JERK)
         dummyf = 0.02f;
-        EEPROM_WRITE(dummyf);
       #endif
+      EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
@@ -617,13 +611,7 @@ void MarlinSettings::postprocess() {
     // Global Leveling
     //
     {
-      const float zfh = (
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          planner.z_fade_height
-        #else
-          10.0
-        #endif
-      );
+      const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, 10.0f);
       EEPROM_WRITE(zfh);
     }
 
@@ -632,22 +620,24 @@ void MarlinSettings::postprocess() {
     //
     {
       #if ENABLED(MESH_BED_LEVELING)
-        // Compile time test that sizeof(mbl.z_values) is as expected
         static_assert(
           sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
           "MBL Z array is the wrong size."
         );
-        const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
-        EEPROM_WRITE(mbl.z_offset);
-        EEPROM_WRITE(mesh_num_x);
-        EEPROM_WRITE(mesh_num_y);
-        EEPROM_WRITE(mbl.z_values);
-      #else // For disabled MBL write a default mesh
+      #else
         dummyf = 0;
-        const uint8_t mesh_num_x = 3, mesh_num_y = 3;
-        EEPROM_WRITE(dummyf); // z_offset
-        EEPROM_WRITE(mesh_num_x);
-        EEPROM_WRITE(mesh_num_y);
+      #endif
+
+      const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
+                    mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
+
+      EEPROM_WRITE(TERN(MESH_BED_LEVELING, mbl.z_offset, dummyf));
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+
+      #if ENABLED(MESH_BED_LEVELING)
+        EEPROM_WRITE(mbl.z_values);
+      #else
         for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
@@ -682,26 +672,25 @@ void MarlinSettings::postprocess() {
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        // Compile time test that sizeof(z_values) is as expected
         static_assert(
           sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
-        const uint8_t grid_max_x = GRID_MAX_POINTS_X, grid_max_y = GRID_MAX_POINTS_Y;
-        EEPROM_WRITE(grid_max_x);            // 1 byte
-        EEPROM_WRITE(grid_max_y);            // 1 byte
-        EEPROM_WRITE(bilinear_grid_spacing); // 2 ints
-        EEPROM_WRITE(bilinear_start);        // 2 ints
-        EEPROM_WRITE(z_values);              // 9-256 floats
       #else
-        // For disabled Bilinear Grid write an empty 3x3 grid
-        const uint8_t grid_max_x = 3, grid_max_y = 3;
         const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
+      #endif
+
+      const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
+                    grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
+      EEPROM_WRITE(grid_max_x);
+      EEPROM_WRITE(grid_max_y);
+      EEPROM_WRITE(bilinear_grid_spacing);
+      EEPROM_WRITE(bilinear_start);
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        EEPROM_WRITE(z_values);              // 9-256 floats
+      #else
         dummyf = 0;
-        EEPROM_WRITE(grid_max_x);
-        EEPROM_WRITE(grid_max_y);
-        EEPROM_WRITE(bilinear_grid_spacing);
-        EEPROM_WRITE(bilinear_start);
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
@@ -711,16 +700,10 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(planner_leveling_active);
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EEPROM_WRITE(planner.leveling_active);
-        EEPROM_WRITE(ubl.storage_slot);
-      #else
-        const bool ubl_active = false;
-        const int8_t storage_slot = -1;
-        EEPROM_WRITE(ubl_active);
-        EEPROM_WRITE(storage_slot);
-      #endif // AUTO_BED_LEVELING_UBL
+      const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
+      const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
+      EEPROM_WRITE(ubl_active);
+      EEPROM_WRITE(storage_slot);
     }
 
     //
@@ -728,7 +711,6 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(servo_angles);
-
       #if !HAS_SERVO_ANGLES
         uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
       #endif
@@ -753,11 +735,7 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(bltouch_last_written_mode);
-      #if ENABLED(BLTOUCH)
-        const bool &bltouch_last_written_mode = bltouch.last_written_mode;
-      #else
-        constexpr bool bltouch_last_written_mode = false;
-      #endif
+      const bool bltouch_last_written_mode = TERN(BLTOUCH, bltouch.last_written_mode, false);
       EEPROM_WRITE(bltouch_last_written_mode);
     }
 
@@ -782,23 +760,9 @@ void MarlinSettings::postprocess() {
 
         // Write dual endstops in X, Y, Z order. Unused = 0.0
         dummyf = 0;
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          EEPROM_WRITE(endstops.x2_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
-
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          EEPROM_WRITE(endstops.y2_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
-
-        #if ENABLED(Z_MULTI_ENDSTOPS)
-          EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
+        EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
+        EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
+        EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
 
         #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
           EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
@@ -865,12 +829,10 @@ void MarlinSettings::postprocess() {
       }
 
       _FIELD_TEST(lpq_len);
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        EEPROM_WRITE(thermalManager.lpq_len);
-      #else
+      #if DISABLED(PID_EXTRUSION_SCALING)
         const int16_t lpq_len = 20;
-        EEPROM_WRITE(lpq_len);
       #endif
+      EEPROM_WRITE(TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, lpq_len));
     }
 
     //
@@ -911,8 +873,6 @@ void MarlinSettings::postprocess() {
       const int16_t lcd_contrast =
         #if HAS_LCD_CONTRAST
           ui.contrast
-        #elif defined(DEFAULT_LCD_CONTRAST)
-          DEFAULT_LCD_CONTRAST
         #else
           127
         #endif
@@ -925,14 +885,7 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(recovery_enabled);
-
-      const bool recovery_enabled =
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          recovery.enabled
-        #else
-          PLR_ENABLED_DEFAULT
-        #endif
-      ;
+      const bool recovery_enabled = TERN(POWER_LOSS_RECOVERY, recovery.enabled, ENABLED(PLR_ENABLED_DEFAULT));
       EEPROM_WRITE(recovery_enabled);
     }
 
@@ -941,19 +894,15 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(fwretract_settings);
-
-      #if ENABLED(FWRETRACT)
-        EEPROM_WRITE(fwretract.settings);
-      #else
+      #if DISABLED(FWRETRACT)
         const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
-        EEPROM_WRITE(autoretract_defaults);
       #endif
-      #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
-        EEPROM_WRITE(fwretract.autoretract_enabled);
-      #else
+      EEPROM_WRITE(TERN(FWRETRACT, fwretract.settings, autoretract_defaults));
+
+      #if DISABLED(FWRETRACT_AUTORETRACT)
         const bool autoretract_enabled = false;
-        EEPROM_WRITE(autoretract_enabled);
       #endif
+      EEPROM_WRITE(TERN(FWRETRACT_AUTORETRACT, fwretract.autoretract_enabled, autoretract_enabled));
     }
 
     //
@@ -1270,12 +1219,10 @@ void MarlinSettings::postprocess() {
 
     _FIELD_TEST(coordinate_system);
 
-    #if ENABLED(CNC_COORDINATE_SYSTEMS)
-      EEPROM_WRITE(gcode.coordinate_system);
-    #else
+    #if DISABLED(CNC_COORDINATE_SYSTEMS)
       const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
-      EEPROM_WRITE(coordinate_system);
     #endif
+    EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
 
     //
     // Skew correction factors
@@ -1448,11 +1395,7 @@ void MarlinSettings::postprocess() {
           for (uint8_t q = 4; q--;) EEPROM_READ(dummyf);
         #endif
 
-        #if DISABLED(CLASSIC_JERK)
-          EEPROM_READ(planner.junction_deviation_mm);
-        #else
-          EEPROM_READ(dummyf);
-        #endif
+        EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
       }
 
       //
@@ -1504,13 +1447,7 @@ void MarlinSettings::postprocess() {
       //
       // Global Leveling
       //
-      {
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          EEPROM_READ(new_z_fade_height);
-        #else
-          EEPROM_READ(dummyf);
-        #endif
-      }
+      EEPROM_READ(TERN(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height, dummyf));
 
       //
       // Mesh (Manual) Bed Leveling
@@ -1662,21 +1599,10 @@ void MarlinSettings::postprocess() {
 
           _FIELD_TEST(x2_endstop_adj);
 
-          #if ENABLED(X_DUAL_ENDSTOPS)
-            EEPROM_READ(endstops.x2_endstop_adj);  // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
-          #if ENABLED(Y_DUAL_ENDSTOPS)
-            EEPROM_READ(endstops.y2_endstop_adj);  // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
-          #if ENABLED(Z_MULTI_ENDSTOPS)
-            EEPROM_READ(endstops.z2_endstop_adj); // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
+          EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
+          EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
+          EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
+
           #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
             EEPROM_READ(endstops.z3_endstop_adj); // 1 float
           #else
@@ -2667,7 +2593,7 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.enable(PLR_ENABLED_DEFAULT);
+    recovery.enable(ENABLED(PLR_ENABLED_DEFAULT));
   #endif
 
   //

commit 913de024a991b41038858cf65b88165fcfb43f2b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 6 13:55:00 2020 -0600

    Change PID dummy value to NAN
    
    Fixes #17078

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3f44963ac3..9d1bbaab21 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -851,8 +851,8 @@ void MarlinSettings::postprocess() {
       HOTEND_LOOP() {
         PIDCF_t pidcf = {
           #if DISABLED(PIDTEMP)
-            DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE,
-            DUMMY_PID_VALUE, DUMMY_PID_VALUE
+            NAN, NAN, NAN,
+            NAN, NAN
           #else
                          PID_PARAM(Kp, e),
             unscalePID_i(PID_PARAM(Ki, e)),
@@ -881,7 +881,7 @@ void MarlinSettings::postprocess() {
 
       const PID_t bed_pid = {
         #if DISABLED(PIDTEMPBED)
-          DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE
+          NAN, NAN, NAN
         #else
           // Store the unscaled PID values
           thermalManager.temp_bed.pid.Kp,
@@ -1725,7 +1725,7 @@ void MarlinSettings::postprocess() {
           PIDCF_t pidcf;
           EEPROM_READ(pidcf);
           #if ENABLED(PIDTEMP)
-            if (!validating && pidcf.Kp != DUMMY_PID_VALUE) {
+            if (!validating && !isnan(pidcf.Kp)) {
               // Scale PID values since EEPROM values are unscaled
               PID_PARAM(Kp, e) = pidcf.Kp;
               PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
@@ -1761,7 +1761,7 @@ void MarlinSettings::postprocess() {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
-          if (!validating && pid.Kp != DUMMY_PID_VALUE) {
+          if (!validating && !isnan(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_bed.pid.Kp = pid.Kp;
             thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);

commit 83a60f15ff1e5fe37e076e4e3e7a62c28de8add8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 3 14:18:31 2020 -0600

    Fix EEPROM compile errors

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d44f63c680..3f44963ac3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1593,8 +1593,8 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(planner_leveling_active);
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          bool &planner_leveling_active = planner.leveling_active;
-          uint8_t &ubl_storage_slot = ubl.storage_slot;
+          const bool &planner_leveling_active = planner.leveling_active;
+          const uint8_t &ubl_storage_slot = ubl.storage_slot;
         #else
           bool planner_leveling_active;
           uint8_t ubl_storage_slot;
@@ -1636,7 +1636,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(bltouch_last_written_mode);
         #if ENABLED(BLTOUCH)
-          bool &bltouch_last_written_mode = bltouch.last_written_mode;
+          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
         #else
           bool bltouch_last_written_mode;
         #endif
@@ -1747,7 +1747,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(lpq_len);
         #if ENABLED(PID_EXTRUSION_SCALING)
-          int16_t &lpq_len = thermalManager.lpq_len;
+          const int16_t &lpq_len = thermalManager.lpq_len;
         #else
           int16_t lpq_len;
         #endif
@@ -1799,7 +1799,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(recovery_enabled);
         #if ENABLED(POWER_LOSS_RECOVERY)
-          bool &recovery_enabled = recovery.enabled;
+          const bool &recovery_enabled = recovery.enabled;
         #else
           bool recovery_enabled;
         #endif

commit 5e28b0f471c4bfa404963c2ce6071c6bb9fbd116
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 21:55:56 2020 -0600

    Minor EEPROM cleanup

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2bac5b2b00..d44f63c680 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -525,7 +525,7 @@ void MarlinSettings::postprocess() {
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
-    float dummy = 0;
+    float dummyf = 0;
     char ver[4] = "ERR";
 
     uint16_t working_crc = 0;
@@ -556,8 +556,8 @@ void MarlinSettings::postprocess() {
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
-          dummy = float(DEFAULT_EJERK);
-          EEPROM_WRITE(dummy);
+          dummyf = float(DEFAULT_EJERK);
+          EEPROM_WRITE(dummyf);
         #endif
       #else
         const xyze_pos_t planner_max_jerk = { 10, 10, 0.4, float(DEFAULT_EJERK) };
@@ -567,8 +567,8 @@ void MarlinSettings::postprocess() {
       #if DISABLED(CLASSIC_JERK)
         EEPROM_WRITE(planner.junction_deviation_mm);
       #else
-        dummy = 0.02f;
-        EEPROM_WRITE(dummy);
+        dummyf = 0.02f;
+        EEPROM_WRITE(dummyf);
       #endif
     }
 
@@ -643,12 +643,12 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(mesh_num_y);
         EEPROM_WRITE(mbl.z_values);
       #else // For disabled MBL write a default mesh
-        dummy = 0;
+        dummyf = 0;
         const uint8_t mesh_num_x = 3, mesh_num_y = 3;
-        EEPROM_WRITE(dummy); // z_offset
+        EEPROM_WRITE(dummyf); // z_offset
         EEPROM_WRITE(mesh_num_x);
         EEPROM_WRITE(mesh_num_y);
-        for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
+        for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
@@ -672,8 +672,8 @@ void MarlinSettings::postprocess() {
       #if ABL_PLANAR
         EEPROM_WRITE(planner.bed_level_matrix);
       #else
-        dummy = 0;
-        for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
+        dummyf = 0;
+        for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
@@ -697,12 +697,12 @@ void MarlinSettings::postprocess() {
         // For disabled Bilinear Grid write an empty 3x3 grid
         const uint8_t grid_max_x = 3, grid_max_y = 3;
         const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
-        dummy = 0;
+        dummyf = 0;
         EEPROM_WRITE(grid_max_x);
         EEPROM_WRITE(grid_max_y);
         EEPROM_WRITE(bilinear_grid_spacing);
         EEPROM_WRITE(bilinear_start);
-        for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummy);
+        for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
@@ -781,35 +781,35 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(x2_endstop_adj);
 
         // Write dual endstops in X, Y, Z order. Unused = 0.0
-        dummy = 0;
+        dummyf = 0;
         #if ENABLED(X_DUAL_ENDSTOPS)
           EEPROM_WRITE(endstops.x2_endstop_adj);   // 1 float
         #else
-          EEPROM_WRITE(dummy);
+          EEPROM_WRITE(dummyf);
         #endif
 
         #if ENABLED(Y_DUAL_ENDSTOPS)
           EEPROM_WRITE(endstops.y2_endstop_adj);   // 1 float
         #else
-          EEPROM_WRITE(dummy);
+          EEPROM_WRITE(dummyf);
         #endif
 
         #if ENABLED(Z_MULTI_ENDSTOPS)
           EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
         #else
-          EEPROM_WRITE(dummy);
+          EEPROM_WRITE(dummyf);
         #endif
 
         #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
           EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
         #else
-          EEPROM_WRITE(dummy);
+          EEPROM_WRITE(dummyf);
         #endif
 
         #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
           EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
         #else
-          EEPROM_WRITE(dummy);
+          EEPROM_WRITE(dummyf);
         #endif
 
       #endif
@@ -970,9 +970,9 @@ void MarlinSettings::postprocess() {
       #else
 
         const bool volumetric_enabled = false;
-        dummy = DEFAULT_NOMINAL_FILAMENT_DIA;
+        dummyf = DEFAULT_NOMINAL_FILAMENT_DIA;
         EEPROM_WRITE(volumetric_enabled);
-        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
 
       #endif
     }
@@ -1245,8 +1245,8 @@ void MarlinSettings::postprocess() {
       #if ENABLED(LIN_ADVANCE)
         EEPROM_WRITE(planner.extruder_advance_K);
       #else
-        dummy = 0;
-        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
+        dummyf = 0;
+        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
@@ -1403,7 +1403,7 @@ void MarlinSettings::postprocess() {
       eeprom_error = true;
     }
     else {
-      float dummy = 0;
+      float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
@@ -1442,16 +1442,16 @@ void MarlinSettings::postprocess() {
         #if HAS_CLASSIC_JERK
           EEPROM_READ(planner.max_jerk);
           #if HAS_LINEAR_E_JERK
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
         #else
-          for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
+          for (uint8_t q = 4; q--;) EEPROM_READ(dummyf);
         #endif
 
         #if DISABLED(CLASSIC_JERK)
           EEPROM_READ(planner.junction_deviation_mm);
         #else
-          EEPROM_READ(dummy);
+          EEPROM_READ(dummyf);
         #endif
       }
 
@@ -1508,7 +1508,7 @@ void MarlinSettings::postprocess() {
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           EEPROM_READ(new_z_fade_height);
         #else
-          EEPROM_READ(dummy);
+          EEPROM_READ(dummyf);
         #endif
       }
 
@@ -1517,12 +1517,12 @@ void MarlinSettings::postprocess() {
       //
       {
         uint8_t mesh_num_x, mesh_num_y;
-        EEPROM_READ(dummy);
+        EEPROM_READ(dummyf);
         EEPROM_READ_ALWAYS(mesh_num_x);
         EEPROM_READ_ALWAYS(mesh_num_y);
 
         #if ENABLED(MESH_BED_LEVELING)
-          if (!validating) mbl.z_offset = dummy;
+          if (!validating) mbl.z_offset = dummyf;
           if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
             // EEPROM data fits the current mesh
             EEPROM_READ(mbl.z_values);
@@ -1530,11 +1530,11 @@ void MarlinSettings::postprocess() {
           else {
             // EEPROM data is stale
             if (!validating) mbl.reset();
-            for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
+            for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
           }
         #else
           // MBL is disabled - skip the stored data
-          for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
+          for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
         #endif // MESH_BED_LEVELING
       }
 
@@ -1558,7 +1558,7 @@ void MarlinSettings::postprocess() {
         #if ABL_PLANAR
           EEPROM_READ(planner.bed_level_matrix);
         #else
-          for (uint8_t q = 9; q--;) EEPROM_READ(dummy);
+          for (uint8_t q = 9; q--;) EEPROM_READ(dummyf);
         #endif
       }
 
@@ -1567,8 +1567,8 @@ void MarlinSettings::postprocess() {
       //
       {
         uint8_t grid_max_x, grid_max_y;
-        EEPROM_READ_ALWAYS(grid_max_x);                       // 1 byte
-        EEPROM_READ_ALWAYS(grid_max_y);                       // 1 byte
+        EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
+        EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
             if (!validating) set_bed_leveling_enabled(false);
@@ -1583,7 +1583,7 @@ void MarlinSettings::postprocess() {
             xy_pos_t bgs, bs;
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
-            for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
+            for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
@@ -1592,16 +1592,15 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(planner_leveling_active);
-
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          EEPROM_READ(planner.leveling_active);
-          EEPROM_READ(ubl.storage_slot);
+          bool &planner_leveling_active = planner.leveling_active;
+          uint8_t &ubl_storage_slot = ubl.storage_slot;
         #else
           bool planner_leveling_active;
           uint8_t ubl_storage_slot;
-          EEPROM_READ(planner_leveling_active);
-          EEPROM_READ(ubl_storage_slot);
         #endif
+        EEPROM_READ(planner_leveling_active);
+        EEPROM_READ(ubl_storage_slot);
       }
 
       //
@@ -1609,7 +1608,6 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(servo_angles);
-
         #if ENABLED(EDITABLE_SERVO_ANGLES)
           uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
         #else
@@ -1638,7 +1636,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(bltouch_last_written_mode);
         #if ENABLED(BLTOUCH)
-          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
+          bool &bltouch_last_written_mode = bltouch.last_written_mode;
         #else
           bool bltouch_last_written_mode;
         #endif
@@ -1667,27 +1665,27 @@ void MarlinSettings::postprocess() {
           #if ENABLED(X_DUAL_ENDSTOPS)
             EEPROM_READ(endstops.x2_endstop_adj);  // 1 float
           #else
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
           #if ENABLED(Y_DUAL_ENDSTOPS)
             EEPROM_READ(endstops.y2_endstop_adj);  // 1 float
           #else
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
           #if ENABLED(Z_MULTI_ENDSTOPS)
             EEPROM_READ(endstops.z2_endstop_adj); // 1 float
           #else
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
           #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
             EEPROM_READ(endstops.z3_endstop_adj); // 1 float
           #else
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
           #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
             EEPROM_READ(endstops.z4_endstop_adj); // 1 float
           #else
-            EEPROM_READ(dummy);
+            EEPROM_READ(dummyf);
           #endif
 
         #endif
@@ -1749,11 +1747,11 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(lpq_len);
         #if ENABLED(PID_EXTRUSION_SCALING)
-          EEPROM_READ(thermalManager.lpq_len);
+          int16_t &lpq_len = thermalManager.lpq_len;
         #else
           int16_t lpq_len;
-          EEPROM_READ(lpq_len);
         #endif
+        EEPROM_READ(lpq_len);
       }
 
       //
@@ -1800,13 +1798,12 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(recovery_enabled);
-
         #if ENABLED(POWER_LOSS_RECOVERY)
-          EEPROM_READ(recovery.enabled);
+          bool &recovery_enabled = recovery.enabled;
         #else
           bool recovery_enabled;
-          EEPROM_READ(recovery_enabled);
         #endif
+        EEPROM_READ(recovery_enabled);
       }
 
       //

commit 552f7a91d09d53b596abd6612f1f716f6aa75f75
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Mar 2 17:07:53 2020 -0500

    Default on/off for Power Loss Recovery (#17051)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 77fc18bb53..2bac5b2b00 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -930,7 +930,7 @@ void MarlinSettings::postprocess() {
         #if ENABLED(POWER_LOSS_RECOVERY)
           recovery.enabled
         #else
-          true
+          PLR_ENABLED_DEFAULT
         #endif
       ;
       EEPROM_WRITE(recovery_enabled);
@@ -2670,7 +2670,7 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.enable(true);
+    recovery.enable(PLR_ENABLED_DEFAULT);
   #endif
 
   //

commit 6b5347ee3949aca63118f25b0e6116d06db3f158
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 29 04:28:07 2020 -0600

    Improved M900

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 346fd64de3..77fc18bb53 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -101,7 +101,7 @@
 #endif
 
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
-  extern float saved_extruder_advance_K[EXTRUDERS];
+  extern float other_extruder_advance_K[EXTRUDERS];
 #endif
 
 #if EXTRUDERS > 1
@@ -2717,7 +2717,7 @@ void MarlinSettings::reset() {
     LOOP_L_N(i, EXTRUDERS) {
       planner.extruder_advance_K[i] = LIN_ADVANCE_K;
       #if ENABLED(EXTRA_LIN_ADVANCE_K)
-        saved_extruder_advance_K[i] = LIN_ADVANCE_K;
+        other_extruder_advance_K[i] = LIN_ADVANCE_K;
       #endif
     }
   #endif

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3fe38d4ade..346fd64de3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -113,7 +113,7 @@
   #include "../feature/bltouch.h"
 #endif
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
   #include "stepper/indirection.h"
   #include "../feature/tmc_util.h"
 #endif
@@ -313,7 +313,7 @@ typedef struct SettingsDataStruct {
   float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
 
   //
-  // HAS_TRINAMIC
+  // HAS_TRINAMIC_CONFIG
   //
   tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
   tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
@@ -985,7 +985,7 @@ void MarlinSettings::postprocess() {
 
       tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
-      #if HAS_TRINAMIC
+      #if HAS_TRINAMIC_CONFIG
         #if AXIS_IS_TMC(X)
           tmc_stepper_current.X = stepperX.getMilliamps();
         #endif
@@ -1862,7 +1862,7 @@ void MarlinSettings::postprocess() {
         tmc_stepper_current_t currents;
         EEPROM_READ(currents);
 
-        #if HAS_TRINAMIC
+        #if HAS_TRINAMIC_CONFIG
 
           #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
           if (!validating) {
@@ -2034,7 +2034,7 @@ void MarlinSettings::postprocess() {
         tmc_stealth_enabled_t tmc_stealth_enabled;
         EEPROM_READ(tmc_stealth_enabled);
 
-        #if HAS_TRINAMIC
+        #if HAS_TRINAMIC_CONFIG
 
           #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
           if (!validating) {
@@ -2788,7 +2788,7 @@ void MarlinSettings::reset() {
   #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
 
-  #if HAS_TRINAMIC
+  #if HAS_TRINAMIC_CONFIG
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
       void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
@@ -3298,7 +3298,7 @@ void MarlinSettings::reset() {
       #endif
     #endif
 
-    #if HAS_TRINAMIC
+    #if HAS_TRINAMIC_CONFIG
 
       /**
        * TMC stepper driver current
@@ -3599,7 +3599,7 @@ void MarlinSettings::reset() {
 
       #endif // HAS_STEALTHCHOP
 
-    #endif // HAS_TRINAMIC
+    #endif // HAS_TRINAMIC_CONFIG
 
     /**
      * Linear Advance

commit 0a7e7a6fa59172f61d3d6ed94d9ccf055c85bf27
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 26 06:26:54 2020 -0600

    Allow servo features in combination (#16960)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 906038638f..3fe38d4ade 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2541,7 +2541,7 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(EDITABLE_SERVO_ANGLES)
-    COPY(servo_angles, base_servo_angles);
+    COPY(servo_angles, base_servo_angles);  // When not editable only one copy of servo angles exists
   #endif
 
   //
@@ -3091,7 +3091,7 @@ void MarlinSettings::reset() {
             #endif
           #elif ENABLED(SWITCHING_NOZZLE)
             case SWITCHING_NOZZLE_SERVO_NR:
-          #elif (ENABLED(BLTOUCH) && defined(BLTOUCH_ANGLES)) || (defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR))
+          #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
             case Z_PROBE_SERVO_NR:
           #endif
             CONFIG_ECHO_START();

commit cdcd45d651adb4b8997ea27d8815fa59b3efea14
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 26 04:04:02 2020 -0500

    Set LCD status for EEPROM errors (#16977)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index efd9dadede..906038638f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1397,6 +1397,9 @@ void MarlinSettings::postprocess() {
       }
       DEBUG_ECHO_START();
       DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
+        ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_VERSION));
+      #endif
       eeprom_error = true;
     }
     else {
@@ -2205,11 +2208,17 @@ void MarlinSettings::postprocess() {
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
+        #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
+          ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_INDEX));
+        #endif
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        #if HAS_LCD_MENU && DISABLED(EEPROM_AUTO_INIT)
+          ui.set_status_P(GET_TEXT(MSG_ERR_EEPROM_CRC));
+        #endif
       }
       else if (!validating) {
         DEBUG_ECHO_START();

commit e1d367e05afad0485f58d4417ff7cd717bf41c80
Author: Jamie <vector76@users.noreply.github.com>
Date:   Fri Feb 21 07:42:13 2020 -0600

    Fix EEPROM errors with EXTRUDERS == 0 (#16898)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index bcdb0e4a81..efd9dadede 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -323,7 +323,7 @@ typedef struct SettingsDataStruct {
   //
   // LIN_ADVANCE
   //
-  float planner_extruder_advance_K[EXTRUDERS];          // M900 K  planner.extruder_advance_K
+  float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM

commit 6320f9795ca91e8c467339afeaa5d3d354500543
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 20 20:56:13 2020 -0600

    More EEPROM cleanup

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0ae3923344..bcdb0e4a81 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2768,7 +2768,7 @@ void MarlinSettings::reset() {
 
   static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
     if (!repl) {
-      CONFIG_ECHO_START();
+      SERIAL_ECHO_START();
       SERIAL_ECHOPGM("; ");
       serialprintPGM(pstr);
       if (eol) SERIAL_EOL();
@@ -2777,7 +2777,7 @@ void MarlinSettings::reset() {
 
   #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
   #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
-  #define CONFIG_ECHO_HEADING(STR, V...) config_heading(forReplay, PSTR(STR), V)
+  #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
 
   #if HAS_TRINAMIC
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
@@ -2861,8 +2861,7 @@ void MarlinSettings::reset() {
        * Volumetric extrusion M200
        */
       if (!forReplay) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOPGM("Filament settings:");
+        config_heading(forReplay, PSTR("Filament settings:"), false);
         if (parser.volumetric_enabled)
           SERIAL_EOL();
         else
@@ -2936,20 +2935,18 @@ void MarlinSettings::reset() {
       , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
     );
 
-    if (!forReplay) {
-      CONFIG_ECHO_START();
-      SERIAL_ECHOPGM("Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
+    CONFIG_ECHO_HEADING(
+      "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
       #if DISABLED(CLASSIC_JERK)
-        SERIAL_ECHOPGM(" J<junc_dev>");
+        " J<junc_dev>"
       #endif
       #if HAS_CLASSIC_JERK
-        SERIAL_ECHOPGM(" X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
+        " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
         #if HAS_CLASSIC_E_JERK
-          SERIAL_ECHOPGM(" E<max_e_jerk>");
+          " E<max_e_jerk>"
         #endif
       #endif
-      SERIAL_EOL();
-    }
+    );
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
@@ -3007,10 +3004,11 @@ void MarlinSettings::reset() {
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
+        config_heading(forReplay, PSTR(""), false);
         if (!forReplay) {
-          CONFIG_ECHO_START();
           ubl.echo_name();
-          SERIAL_ECHOLNPGM(":");
+          SERIAL_CHAR(':');
+          SERIAL_EOL();
         }
 
       #elif HAS_ABL_OR_UBL
@@ -3046,8 +3044,12 @@ void MarlinSettings::reset() {
         if (!forReplay) {
           SERIAL_EOL();
           ubl.report_state();
-          SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
-          SERIAL_ECHOLNPAIR("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
+          SERIAL_EOL();
+          config_heading(false, PSTR("Active Mesh Slot: "), false);
+          SERIAL_ECHOLN(ubl.storage_slot);
+          config_heading(false, PSTR("EEPROM can hold "), false);
+          SERIAL_ECHO(calc_num_meshes());
+          SERIAL_ECHOLNPGM(" meshes.\n");
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
@@ -3257,11 +3259,8 @@ void MarlinSettings::reset() {
      * Probe Offset
      */
     #if HAS_BED_PROBE
-      if (!forReplay) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOPGM("Z-Probe Offset");
-        say_units(true);
-      }
+      config_heading(forReplay, PSTR("Z-Probe Offset"), false);
+      if (!forReplay) say_units(true);
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
         #if HAS_PROBE_XY_OFFSET

commit b8b225c8b5f7792990169563707f8afcb2cc6db9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 20 20:09:59 2020 -0600

    Function for CONFIG_ECHO_HEADING

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a029443328..0ae3923344 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2766,9 +2766,18 @@ void MarlinSettings::reset() {
 
 #if DISABLED(DISABLE_M503)
 
+  static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
+    if (!repl) {
+      CONFIG_ECHO_START();
+      SERIAL_ECHOPGM("; ");
+      serialprintPGM(pstr);
+      if (eol) SERIAL_EOL();
+    }
+  }
+
   #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
   #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
-  #define CONFIG_ECHO_HEADING(STR)  do{ if (!forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); } }while(0)
+  #define CONFIG_ECHO_HEADING(STR, V...) config_heading(forReplay, PSTR(STR), V)
 
   #if HAS_TRINAMIC
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }

commit f312ddfa4fd5772d825908f8e376dedf29442893
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 12:37:20 2020 -0600

    More updates for 8 extruders, REPEAT

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 98bd29e4cc..a029443328 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1905,6 +1905,12 @@ void MarlinSettings::postprocess() {
             #if AXIS_IS_TMC(E5)
               SET_CURR(E5);
             #endif
+            #if AXIS_IS_TMC(E6)
+              SET_CURR(E6);
+            #endif
+            #if AXIS_IS_TMC(E7)
+              SET_CURR(E7);
+            #endif
           }
         #endif
       }
@@ -1959,6 +1965,12 @@ void MarlinSettings::postprocess() {
             #if AXIS_HAS_STEALTHCHOP(E5)
               stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5);
             #endif
+            #if AXIS_HAS_STEALTHCHOP(E6)
+              stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E7)
+              stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7);
+            #endif
           }
         #endif
       }
@@ -2065,6 +2077,12 @@ void MarlinSettings::postprocess() {
             #if AXIS_HAS_STEALTHCHOP(E5)
               SET_STEPPING_MODE(E5);
             #endif
+            #if AXIS_HAS_STEALTHCHOP(E6)
+              SET_STEPPING_MODE(E6);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E7)
+              SET_STEPPING_MODE(E7);
+            #endif
           }
         #endif
       }
@@ -3333,6 +3351,14 @@ void MarlinSettings::reset() {
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
       #endif
+      #if AXIS_IS_TMC(E6)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T6 E", stepperE6.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E7)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T7 E", stepperE7.getMilliamps());
+      #endif
       SERIAL_EOL();
 
       /**
@@ -3407,6 +3433,14 @@ void MarlinSettings::reset() {
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
         #endif
+        #if AXIS_HAS_STEALTHCHOP(E6)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T6 E", stepperE6.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E7)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T7 E", stepperE7.get_pwm_thrs());
+        #endif
         SERIAL_EOL();
       #endif // HYBRID_THRESHOLD
 
@@ -3539,6 +3573,12 @@ void MarlinSettings::reset() {
         #if AXIS_HAS_STEALTHCHOP(E5)
           if (stepperE5.get_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
         #endif
+        #if AXIS_HAS_STEALTHCHOP(E6)
+          if (stepperE6.get_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E7)
+          if (stepperE7.get_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
+        #endif
 
       #endif // HAS_STEALTHCHOP
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3cca051cd8..98bd29e4cc 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 4716dac8742e536dde12773b579407fb1ae1cb66
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 21:00:53 2020 -0600

    Apply REPEAT, RREPEAT, and loop macros (#16757)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f1c7698a48..3cca051cd8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2667,7 +2667,7 @@ void MarlinSettings::reset() {
         false
       #endif
     ;
-    for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
+    LOOP_L_N(q, COUNT(planner.filament_size))
       planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
 
   #endif
@@ -2730,7 +2730,7 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    for (uint8_t e = 0; e < EXTRUDERS; e++) {
+    LOOP_L_N(e, EXTRUDERS) {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
       fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
@@ -2842,36 +2842,17 @@ void MarlinSettings::reset() {
           SERIAL_ECHOLNPGM(" Disabled");
       }
 
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-      #if EXTRUDERS > 1
+      #if EXTRUDERS == 1
         CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
-        #if EXTRUDERS > 2
+        SERIAL_ECHOLNPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
+      #elif EXTRUDERS
+        LOOP_L_N(i, EXTRUDERS) {
           CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
-          #if EXTRUDERS > 3
-            CONFIG_ECHO_START();
-            SERIAL_ECHOLNPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
-            #if EXTRUDERS > 4
-              CONFIG_ECHO_START();
-              SERIAL_ECHOLNPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
-              #if EXTRUDERS > 5
-                CONFIG_ECHO_START();
-                SERIAL_ECHOLNPAIR("  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
-                #if EXTRUDERS > 6
-                  CONFIG_ECHO_START();
-                  SERIAL_ECHOLNPAIR("  M200 T6 D", LINEAR_UNIT(planner.filament_size[6]));
-                  #if EXTRUDERS > 7
-                    CONFIG_ECHO_START();
-                    SERIAL_ECHOLNPAIR("  M200 T7 D", LINEAR_UNIT(planner.filament_size[7]));
-                  #endif // EXTRUDERS > 7
-                #endif // EXTRUDERS > 6
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
+          SERIAL_ECHOPGM("  M200");
+          if (i) SERIAL_ECHOPAIR_P(SP_T_STR, int(i));
+          SERIAL_ECHOLNPAIR(" D", LINEAR_UNIT(planner.filament_size[i]));
+        }
+      #endif
 
       if (!parser.volumetric_enabled)
         CONFIG_ECHO_MSG("  M200 D0");
@@ -2893,7 +2874,7 @@ void MarlinSettings::reset() {
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
-      for (uint8_t i = 0; i < E_STEPPERS; i++) {
+      LOOP_L_N(i, E_STEPPERS) {
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M203 T"), (int)i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
@@ -2913,7 +2894,7 @@ void MarlinSettings::reset() {
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
-      for (uint8_t i = 0; i < E_STEPPERS; i++)
+      LOOP_L_N(i, E_STEPPERS)
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M201 T"), (int)i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
@@ -3022,8 +3003,8 @@ void MarlinSettings::reset() {
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
-          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
-            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
+            LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), (int)px, PSTR(" J"), (int)py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
@@ -3047,8 +3028,8 @@ void MarlinSettings::reset() {
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
-          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
-            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
+            LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
@@ -3063,7 +3044,7 @@ void MarlinSettings::reset() {
     #if ENABLED(EDITABLE_SERVO_ANGLES)
 
       CONFIG_ECHO_HEADING("Servo Angles:");
-      for (uint8_t i = 0; i < NUM_SERVOS; i++) {
+      LOOP_L_N(i, NUM_SERVOS) {
         switch (i) {
           #if ENABLED(SWITCHING_EXTRUDER)
             case SWITCHING_EXTRUDER_SERVO_NR:
@@ -3146,7 +3127,7 @@ void MarlinSettings::reset() {
     #if HOTENDS && HAS_LCD_MENU
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
-      for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {
+      LOOP_L_N(i, COUNT(ui.preheat_hotend_temp)) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR(
             "  M145 S", (int)i
@@ -3200,7 +3181,7 @@ void MarlinSettings::reset() {
 
     #if HAS_USER_THERMISTORS
       CONFIG_ECHO_HEADING("User thermistors:");
-      for (uint8_t i = 0; i < USER_THERMISTORS; i++)
+      LOOP_L_N(i, USER_THERMISTORS)
         thermalManager.log_user_thermistor(i, true);
     #endif
 
@@ -3596,29 +3577,10 @@ void MarlinSettings::reset() {
         say_M603(forReplay);
         SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
-        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0)
-        _ECHO_603(0);
-        _ECHO_603(1);
-        #if EXTRUDERS > 2
-          _ECHO_603(2);
-          #if EXTRUDERS > 3
-            _ECHO_603(3);
-            #if EXTRUDERS > 4
-              _ECHO_603(4);
-              #if EXTRUDERS > 5
-                _ECHO_603(5);
-                #if EXTRUDERS > 6
-                  _ECHO_603(6);
-                  #if EXTRUDERS > 7
-                    _ECHO_603(7);
-                  #endif // EXTRUDERS > 7
-                #endif // EXTRUDERS > 6
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS == 1
-    #endif // ADVANCED_PAUSE_FEATURE
+        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0);
+        REPEAT(EXTRUDERS, _ECHO_603)
+      #endif
+    #endif
 
     #if EXTRUDERS > 1
       CONFIG_ECHO_HEADING("Tool-changing:");

commit 0e72c315a0be49e98758d9744ac0117b0904b7e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 17:05:42 2020 -0600

    Minor string storage optimization

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0e4e6cef30..f1c7698a48 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2922,10 +2922,10 @@ void MarlinSettings::reset() {
 
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR(
-        "  M204 P", LINEAR_UNIT(planner.settings.acceleration)
-      , " R", LINEAR_UNIT(planner.settings.retract_acceleration)
-      , " T", LINEAR_UNIT(planner.settings.travel_acceleration)
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
+      , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
+      , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
     );
 
     if (!forReplay) {
@@ -2946,7 +2946,7 @@ void MarlinSettings::reset() {
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
       , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
-      , PSTR(" T"), LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
+      , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
       #if DISABLED(CLASSIC_JERK)
         , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
@@ -3089,8 +3089,8 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M665 S"), delta_segments_per_second
-        , PSTR(" P"), scara_home_offset.a
-        , PSTR(" T"), scara_home_offset.b
+        , SP_P_STR, scara_home_offset.a
+        , SP_T_STR, scara_home_offset.b
         , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
       );
 
@@ -3168,7 +3168,7 @@ void MarlinSettings::reset() {
           SERIAL_ECHOPAIR_P(
             #if HOTENDS > 1 && ENABLED(PID_PARAMS_PER_HOTEND)
               PSTR("  M301 E"), e,
-              PSTR(" P")
+              SP_P_STR
             #else
               PSTR("  M301 P")
             #endif

commit e58d1bf97405f89d0a720c90a63ad677ca0624b5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Feb 1 05:50:44 2020 -0500

    G34 automatic point assignment (#16473)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 05b67c984c..0e4e6cef30 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V75"
+#define EEPROM_VERSION "V76"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -66,6 +66,10 @@
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(Z_STEPPER_AUTO_ALIGN)
+  #include "../feature/z_stepper_align.h"
+#endif
+
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
@@ -251,6 +255,16 @@ typedef struct SettingsDataStruct {
           z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
+  //
+  // Z_STEPPER_AUTO_ALIGN, Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
+  //
+  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+    xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
+    #endif
+  #endif
+
   //
   // ULTIPANEL
   //
@@ -801,6 +815,13 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
+    #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+      EEPROM_WRITE(z_stepper_align.xy);
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        EEPROM_WRITE(z_stepper_align.stepper_xy);
+      #endif
+    #endif
+
     //
     // LCD Preheat settings
     //
@@ -1669,6 +1690,13 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+        EEPROM_READ(z_stepper_align.xy);
+        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          EEPROM_READ(z_stepper_align.stepper_xy);
+        #endif
+      #endif
+
       //
       // LCD Preheat settings
       //
@@ -2473,6 +2501,14 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
+  //
+  // Z Stepper Auto-alignment points
+  //
+
+  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+    z_stepper_align.reset_to_default();
+  #endif
+
   //
   // Servo Angles
   //

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 85b0b850b0..05b67c984c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -587,12 +587,12 @@ void MarlinSettings::postprocess() {
       #if HAS_FILAMENT_SENSOR
         const bool &runout_sensor_enabled = runout.enabled;
       #else
-        const bool runout_sensor_enabled = true;
+        constexpr bool runout_sensor_enabled = true;
       #endif
       #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
         const float &runout_distance_mm = runout.runout_distance();
       #else
-        const float runout_distance_mm = 0;
+        constexpr float runout_distance_mm = 0;
       #endif
       _FIELD_TEST(runout_sensor_enabled);
       EEPROM_WRITE(runout_sensor_enabled);
@@ -643,7 +643,12 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(probe_offset);
-      EEPROM_WRITE(probe_offset);
+      #if HAS_BED_PROBE
+        const xyz_pos_t &zpo = probe.offset;
+      #else
+        constexpr xyz_pos_t zpo{0};
+      #endif
+      EEPROM_WRITE(zpo);
     }
 
     //
@@ -1458,7 +1463,7 @@ void MarlinSettings::postprocess() {
       //
       {
         #if HAS_FILAMENT_SENSOR
-          bool &runout_sensor_enabled = runout.enabled;
+          const bool &runout_sensor_enabled = runout.enabled;
         #else
           bool runout_sensor_enabled;
         #endif
@@ -1515,7 +1520,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(probe_offset);
         #if HAS_BED_PROBE
-          xyz_pos_t &zpo = probe_offset;
+          const xyz_pos_t &zpo = probe.offset;
         #else
           xyz_pos_t zpo;
         #endif
@@ -1609,7 +1614,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(bltouch_last_written_mode);
         #if ENABLED(BLTOUCH)
-          bool &bltouch_last_written_mode = bltouch.last_written_mode;
+          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
         #else
           bool bltouch_last_written_mode;
         #endif
@@ -2120,14 +2125,14 @@ void MarlinSettings::postprocess() {
       //
       {
         #if ENABLED(BACKLASH_GCODE)
-          xyz_float_t &backlash_distance_mm = backlash.distance_mm;
-          uint8_t &backlash_correction = backlash.correction;
+          const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
+          const uint8_t &backlash_correction = backlash.correction;
         #else
           float backlash_distance_mm[XYZ];
           uint8_t backlash_correction;
         #endif
         #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
-          float &backlash_smoothing_mm = backlash.smoothing_mm;
+          const float &backlash_smoothing_mm = backlash.smoothing_mm;
         #else
           float backlash_smoothing_mm;
         #endif
@@ -2461,10 +2466,10 @@ void MarlinSettings::reset() {
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     #if HAS_PROBE_XY_OFFSET
-      LOOP_XYZ(a) probe_offset[a] = dpo[a];
+      LOOP_XYZ(a) probe.offset[a] = dpo[a];
     #else
-      probe_offset.x = probe_offset.y = 0;
-      probe_offset.z = dpo[Z_AXIS];
+      probe.offset.x = probe.offset.y = 0;
+      probe.offset.z = dpo[Z_AXIS];
     #endif
   #endif
 
@@ -3216,13 +3221,13 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
         #if HAS_PROBE_XY_OFFSET
-          PSTR("  M851 X"), LINEAR_UNIT(probe_offset_xy.x),
-                  SP_Y_STR, LINEAR_UNIT(probe_offset_xy.y),
+          PSTR("  M851 X"), LINEAR_UNIT(probe.offset_xy.x),
+                  SP_Y_STR, LINEAR_UNIT(probe.offset_xy.y),
                   SP_Z_STR
         #else
           PSTR("  M851 X0 Y0 Z")
         #endif
-        , LINEAR_UNIT(probe_offset.z)
+        , LINEAR_UNIT(probe.offset.z)
       );
     #endif
 

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f87ff8a5da..85b0b850b0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1008,6 +1008,16 @@ void MarlinSettings::postprocess() {
                     #if AXIS_IS_TMC(E5)
                       tmc_stepper_current.E5 = stepperE5.getMilliamps();
                     #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_IS_TMC(E6)
+                        tmc_stepper_current.E6 = stepperE6.getMilliamps();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_IS_TMC(E7)
+                          tmc_stepper_current.E7 = stepperE7.getMilliamps();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
               #endif // MAX_EXTRUDERS > 3
@@ -1074,6 +1084,16 @@ void MarlinSettings::postprocess() {
                     #if AXIS_HAS_STEALTHCHOP(E5)
                       tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
                     #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_HAS_STEALTHCHOP(E6)
+                        tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_HAS_STEALTHCHOP(E7)
+                          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
               #endif // MAX_EXTRUDERS > 3
@@ -1170,6 +1190,16 @@ void MarlinSettings::postprocess() {
                     #if AXIS_HAS_STEALTHCHOP(E5)
                       tmc_stealth_enabled.E5 = stepperE5.get_stealthChop_status();
                     #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_HAS_STEALTHCHOP(E6)
+                        tmc_stealth_enabled.E6 = stepperE6.get_stealthChop_status();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_HAS_STEALTHCHOP(E7)
+                          tmc_stealth_enabled.E7 = stepperE7.get_stealthChop_status();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
               #endif // MAX_EXTRUDERS > 3
@@ -2788,6 +2818,14 @@ void MarlinSettings::reset() {
               #if EXTRUDERS > 5
                 CONFIG_ECHO_START();
                 SERIAL_ECHOLNPAIR("  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
+                #if EXTRUDERS > 6
+                  CONFIG_ECHO_START();
+                  SERIAL_ECHOLNPAIR("  M200 T6 D", LINEAR_UNIT(planner.filament_size[6]));
+                  #if EXTRUDERS > 7
+                    CONFIG_ECHO_START();
+                    SERIAL_ECHOLNPAIR("  M200 T7 D", LINEAR_UNIT(planner.filament_size[7]));
+                  #endif // EXTRUDERS > 7
+                #endif // EXTRUDERS > 6
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
@@ -3528,6 +3566,12 @@ void MarlinSettings::reset() {
               _ECHO_603(4);
               #if EXTRUDERS > 5
                 _ECHO_603(5);
+                #if EXTRUDERS > 6
+                  _ECHO_603(6);
+                  #if EXTRUDERS > 7
+                    _ECHO_603(7);
+                  #endif // EXTRUDERS > 7
+                #endif // EXTRUDERS > 6
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b0a8a88aeb..f87ff8a5da 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V74"
+#define EEPROM_VERSION "V75"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -120,10 +120,10 @@
 
 #pragma pack(push, 1) // No padding between variables
 
-typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
-typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
+typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
+typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
 typedef struct {  int16_t X, Y, Z, X2;                                     } tmc_sgt_t;
-typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
+typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, COUNT(ARR) - 1)
@@ -243,11 +243,12 @@ typedef struct SettingsDataStruct {
           delta_diagonal_rod,                           // M665 L
           delta_segments_per_second;                    // M665 S
     abc_float_t delta_tower_angle_trim;                 // M665 XYZ
-  #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #elif HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
-          z2_endstop_adj,                               // M666 Z (S2)
-          z3_endstop_adj;                               // M666 Z (S3)
+          z2_endstop_adj,                               // M666 (S2) Z
+          z3_endstop_adj,                               // M666 (S3) Z
+          z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
   //
@@ -300,10 +301,10 @@ typedef struct SettingsDataStruct {
   //
   // HAS_TRINAMIC
   //
-  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
-  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
+  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
   tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2
-  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
+  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
 
   //
   // LIN_ADVANCE
@@ -756,7 +757,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(delta_segments_per_second); // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
-      #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+      #elif HAS_EXTRA_ENDSTOPS
 
         _FIELD_TEST(x2_endstop_adj);
 
@@ -774,18 +775,24 @@ void MarlinSettings::postprocess() {
           EEPROM_WRITE(dummy);
         #endif
 
-        #if Z_MULTI_ENDSTOPS
+        #if ENABLED(Z_MULTI_ENDSTOPS)
           EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
         #else
           EEPROM_WRITE(dummy);
         #endif
 
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
           EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
         #else
           EEPROM_WRITE(dummy);
         #endif
 
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+          EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummy);
+        #endif
+
       #endif
     }
 
@@ -974,6 +981,9 @@ void MarlinSettings::postprocess() {
         #if AXIS_IS_TMC(Z3)
           tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(Z4)
+          tmc_stepper_current.Z4 = stepperZ4.getMilliamps();
+        #endif
         #if MAX_EXTRUDERS
           #if AXIS_IS_TMC(E0)
             tmc_stepper_current.E0 = stepperE0.getMilliamps();
@@ -1037,6 +1047,9 @@ void MarlinSettings::postprocess() {
         #if AXIS_HAS_STEALTHCHOP(Z3)
           tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
         #endif
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs();
+        #endif
         #if MAX_EXTRUDERS
           #if AXIS_HAS_STEALTHCHOP(E0)
             tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
@@ -1070,7 +1083,7 @@ void MarlinSettings::postprocess() {
       #else
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
           .X  = 100, .Y  = 100, .Z  =   3,
-          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3,
+          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
           .E0 =  30, .E1 =  30, .E2 =  30,
           .E3 =  30, .E4 =  30, .E5 =  30
         };
@@ -1130,6 +1143,9 @@ void MarlinSettings::postprocess() {
         #if AXIS_HAS_STEALTHCHOP(Z3)
           tmc_stealth_enabled.Z3 = stepperZ3.get_stealthChop_status();
         #endif
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          tmc_stealth_enabled.Z4 = stepperZ4.get_stealthChop_status();
+        #endif
         #if MAX_EXTRUDERS
           #if AXIS_HAS_STEALTHCHOP(E0)
             tmc_stealth_enabled.E0 = stepperE0.get_stealthChop_status();
@@ -1585,7 +1601,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(delta_segments_per_second); // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
 
-        #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+        #elif HAS_EXTRA_ENDSTOPS
 
           _FIELD_TEST(x2_endstop_adj);
 
@@ -1599,16 +1615,21 @@ void MarlinSettings::postprocess() {
           #else
             EEPROM_READ(dummy);
           #endif
-          #if Z_MULTI_ENDSTOPS
+          #if ENABLED(Z_MULTI_ENDSTOPS)
             EEPROM_READ(endstops.z2_endstop_adj); // 1 float
           #else
             EEPROM_READ(dummy);
           #endif
-          #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
             EEPROM_READ(endstops.z3_endstop_adj); // 1 float
           #else
             EEPROM_READ(dummy);
           #endif
+          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+            EEPROM_READ(endstops.z4_endstop_adj); // 1 float
+          #else
+            EEPROM_READ(dummy);
+          #endif
 
         #endif
       }
@@ -1800,6 +1821,9 @@ void MarlinSettings::postprocess() {
             #if AXIS_IS_TMC(Z3)
               SET_CURR(Z3);
             #endif
+            #if AXIS_IS_TMC(Z4)
+              SET_CURR(Z4);
+            #endif
             #if AXIS_IS_TMC(E0)
               SET_CURR(E0);
             #endif
@@ -1851,6 +1875,9 @@ void MarlinSettings::postprocess() {
             #if AXIS_HAS_STEALTHCHOP(Z3)
               stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3);
             #endif
+            #if AXIS_HAS_STEALTHCHOP(Z4)
+              stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4);
+            #endif
             #if AXIS_HAS_STEALTHCHOP(E0)
               stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0);
             #endif
@@ -1877,7 +1904,7 @@ void MarlinSettings::postprocess() {
       // TMC StallGuard threshold.
       // X and X2 use the same value
       // Y and Y2 use the same value
-      // Z, Z2 and Z3 use the same value
+      // Z, Z2, Z3 and Z4 use the same value
       //
       {
         tmc_sgt_t tmc_sgt;
@@ -1914,6 +1941,9 @@ void MarlinSettings::postprocess() {
               #if AXIS_HAS_STALLGUARD(Z3)
                 stepperZ3.homing_threshold(tmc_sgt.Z);
               #endif
+              #if AXIS_HAS_STALLGUARD(Z4)
+                stepperZ4.homing_threshold(tmc_sgt.Z);
+              #endif
             #endif
           }
         #endif
@@ -1951,6 +1981,9 @@ void MarlinSettings::postprocess() {
             #if AXIS_HAS_STEALTHCHOP(Z3)
               SET_STEPPING_MODE(Z3);
             #endif
+            #if AXIS_HAS_STEALTHCHOP(Z4)
+              SET_STEPPING_MODE(Z4);
+            #endif
             #if AXIS_HAS_STEALTHCHOP(E0)
               SET_STEPPING_MODE(E0);
             #endif
@@ -2433,51 +2466,39 @@ void MarlinSettings::reset() {
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_tower_angle_trim = dta;
 
-  #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #endif
 
-    #if ENABLED(X_DUAL_ENDSTOPS)
-      endstops.x2_endstop_adj = (
-        #ifdef X_DUAL_ENDSTOPS_ADJUSTMENT
-          X_DUAL_ENDSTOPS_ADJUSTMENT
-        #else
-          0
-        #endif
-      );
-    #endif
-    #if ENABLED(Y_DUAL_ENDSTOPS)
-      endstops.y2_endstop_adj = (
-        #ifdef Y_DUAL_ENDSTOPS_ADJUSTMENT
-          Y_DUAL_ENDSTOPS_ADJUSTMENT
-        #else
-          0
-        #endif
-      );
+  #if ENABLED(X_DUAL_ENDSTOPS)
+    #ifndef X2_ENDSTOP_ADJUSTMENT
+      #define X2_ENDSTOP_ADJUSTMENT 0
     #endif
-    #if ENABLED(Z_DUAL_ENDSTOPS)
-      endstops.z2_endstop_adj = (
-        #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
-          Z_DUAL_ENDSTOPS_ADJUSTMENT
-        #else
-          0
-        #endif
-      );
-    #elif ENABLED(Z_TRIPLE_ENDSTOPS)
-      endstops.z2_endstop_adj = (
-        #ifdef Z_TRIPLE_ENDSTOPS_ADJUSTMENT2
-          Z_TRIPLE_ENDSTOPS_ADJUSTMENT2
-        #else
-          0
-        #endif
-      );
-      endstops.z3_endstop_adj = (
-        #ifdef Z_TRIPLE_ENDSTOPS_ADJUSTMENT3
-          Z_TRIPLE_ENDSTOPS_ADJUSTMENT3
-        #else
-          0
-        #endif
-      );
+    endstops.x2_endstop_adj = X2_ENDSTOP_ADJUSTMENT;
+  #endif
+
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    #ifndef Y2_ENDSTOP_ADJUSTMENT
+      #define Y2_ENDSTOP_ADJUSTMENT 0
     #endif
+    endstops.y2_endstop_adj = Y2_ENDSTOP_ADJUSTMENT;
+  #endif
 
+  #if ENABLED(Z_MULTI_ENDSTOPS)
+    #ifndef Z2_ENDSTOP_ADJUSTMENT
+      #define Z2_ENDSTOP_ADJUSTMENT 0
+    #endif
+    endstops.z2_endstop_adj = Z2_ENDSTOP_ADJUSTMENT;
+    #if NUM_Z_STEPPER_DRIVERS >= 3
+      #ifndef Z3_ENDSTOP_ADJUSTMENT
+        #define Z3_ENDSTOP_ADJUSTMENT 0
+      #endif
+      endstops.z3_endstop_adj = Z3_ENDSTOP_ADJUSTMENT;
+    #endif
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      #ifndef Z4_ENDSTOP_ADJUSTMENT
+        #define Z4_ENDSTOP_ADJUSTMENT 0
+      #endif
+      endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
+    #endif
   #endif
 
   //
@@ -3016,25 +3037,30 @@ void MarlinSettings::reset() {
         , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
       );
 
-    #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+    #elif HAS_EXTRA_ENDSTOPS
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
       SERIAL_ECHOPGM("  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
+        SERIAL_ECHOLNPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
+        SERIAL_ECHOLNPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
       #endif
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
-        SERIAL_ECHOLNPAIR("S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
-        CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR("  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
-      #elif ENABLED(Z_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
+      #if ENABLED(Z_MULTI_ENDSTOPS)
+        #if NUM_Z_STEPPER_DRIVERS >= 3
+          SERIAL_ECHOPAIR(" S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+          CONFIG_ECHO_START();
+          SERIAL_ECHOPAIR("  M666 S3 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+          #if NUM_Z_STEPPER_DRIVERS >= 4
+            CONFIG_ECHO_START();
+            SERIAL_ECHOPAIR("  M666 S4 Z", LINEAR_UNIT(endstops.z4_endstop_adj));
+          #endif
+        #else
+          SERIAL_ECHOLNPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
+        #endif
       #endif
-      SERIAL_EOL();
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
@@ -3218,6 +3244,11 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
       #endif
 
+      #if AXIS_IS_TMC(Z4)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.getMilliamps());
+      #endif
+
       #if AXIS_IS_TMC(E0)
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
@@ -3287,6 +3318,11 @@ void MarlinSettings::reset() {
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
         #endif
 
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.get_pwm_thrs());
+        #endif
+
         #if AXIS_HAS_STEALTHCHOP(E0)
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
@@ -3356,6 +3392,12 @@ void MarlinSettings::reset() {
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
         #endif
 
+        #if Z4_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.homing_threshold());
+        #endif
+
       #endif // USE_SENSORLESS
 
       /**
@@ -3415,6 +3457,10 @@ void MarlinSettings::reset() {
           if (stepperZ3.get_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
         #endif
 
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          if (stepperZ4.get_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
+        #endif
+
         #if AXIS_HAS_STEALTHCHOP(E0)
           if (stepperE0.get_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
         #endif

commit a338dce83f6f3b3348a8422ad8acd7b81cc1cefe
Author: tompe-proj <59094873+tompe-proj@users.noreply.github.com>
Date:   Sat Jan 18 00:16:45 2020 +0100

    PINDA v2 temperature sensor / compensation (#16293)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d38cbbe674..b0a8a88aeb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -114,6 +114,10 @@
   #include "../feature/tmc_util.h"
 #endif
 
+#if ENABLED(PROBE_TEMP_COMPENSATION)
+  #include "../feature/probe_temp_compensation.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
@@ -212,6 +216,18 @@ typedef struct SettingsDataStruct {
   //
   uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
 
+  //
+  // Temperature first layer compensation values
+  //
+  #if ENABLED(PROBE_TEMP_COMPENSATION)
+    int16_t z_offsets_probe[COUNT(temp_comp.z_offsets_probe)], // M871 P I V
+            z_offsets_bed[COUNT(temp_comp.z_offsets_bed)]      // M871 B I V
+            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+              , z_offsets_ext[COUNT(temp_comp.z_offsets_ext)]  // M871 E I V
+            #endif
+          ;
+  #endif
+
   //
   // BLTOUCH
   //
@@ -699,6 +715,19 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(servo_angles);
     }
 
+    //
+    // Thermal first layer compensation values
+    //
+    #if ENABLED(PROBE_TEMP_COMPENSATION)
+      EEPROM_WRITE(temp_comp.z_offsets_probe);
+      EEPROM_WRITE(temp_comp.z_offsets_bed);
+      #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+        EEPROM_WRITE(temp_comp.z_offsets_ext);
+      #endif
+    #else
+      // No placeholder data for this feature
+    #endif
+
     //
     // BLTOUCH
     //
@@ -1514,6 +1543,20 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(servo_angles_arr);
       }
 
+      //
+      // Thermal first layer compensation values
+      //
+      #if ENABLED(PROBE_TEMP_COMPENSATION)
+        EEPROM_READ(temp_comp.z_offsets_probe);
+        EEPROM_READ(temp_comp.z_offsets_bed);
+        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+          EEPROM_READ(temp_comp.z_offsets_ext);
+        #endif
+        temp_comp.reset_index();
+      #else
+        // No placeholder data for this feature
+      #endif
+
       //
       // BLTOUCH
       //

commit 6e658a7c045acc80f92c99551d81c850d8c05723
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 8 20:00:06 2020 -0600

    Code style and comment tweaks

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ddea9388b1..d38cbbe674 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2352,7 +2352,7 @@ void MarlinSettings::reset() {
   #endif
 
   #if HAS_BED_PROBE
-    constexpr float dpo[XYZ] = NOZZLE_TO_PROBE_OFFSET;
+    constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     #if HAS_PROBE_XY_OFFSET
       LOOP_XYZ(a) probe_offset[a] = dpo[a];

commit d26c32375ee7b0748a116677ed7568af53027c03
Author: Vertabreaker <opyrus@hotmail.com>
Date:   Tue Jan 7 22:49:27 2020 -0500

    Fix EEPROM array size bug (#16475)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 57a9742010..ddea9388b1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1145,7 +1145,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner.extruder_advance_K);
       #else
         dummy = 0;
-        for (uint8_t q = _MIN(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
+        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
       #endif
     }
 
@@ -1934,7 +1934,7 @@ void MarlinSettings::postprocess() {
       // Linear Advance
       //
       {
-        float extruder_advance_K[_MIN(EXTRUDERS, 1)];
+        float extruder_advance_K[_MAX(EXTRUDERS, 1)];
         _FIELD_TEST(planner_extruder_advance_K);
         EEPROM_READ(extruder_advance_K);
         #if ENABLED(LIN_ADVANCE)

commit 5e1f0e5e90b678702ad1a455c8f0303811934a86
Author: Vertabreaker <opyrus@hotmail.com>
Date:   Sun Jan 5 03:19:50 2020 -0500

    Followup to EEPROM patch (#16470)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b97d536627..57a9742010 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1145,7 +1145,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner.extruder_advance_K);
       #else
         dummy = 0;
-        for (uint8_t q = MIN(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
+        for (uint8_t q = _MIN(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
       #endif
     }
 
@@ -1934,7 +1934,7 @@ void MarlinSettings::postprocess() {
       // Linear Advance
       //
       {
-        float extruder_advance_K[MIN(EXTRUDERS, 1)];
+        float extruder_advance_K[_MIN(EXTRUDERS, 1)];
         _FIELD_TEST(planner_extruder_advance_K);
         EEPROM_READ(extruder_advance_K);
         #if ENABLED(LIN_ADVANCE)

commit fc07b0ea30b7f75fe6c21210385f8b281f6cf644
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Jan 5 01:34:55 2020 -0600

    Fix EEPROM error with EXTRUDERS == 0 (#16464)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b389741b79..b97d536627 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1145,7 +1145,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner.extruder_advance_K);
       #else
         dummy = 0;
-        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+        for (uint8_t q = MIN(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummy);
       #endif
     }
 
@@ -1934,7 +1934,7 @@ void MarlinSettings::postprocess() {
       // Linear Advance
       //
       {
-        float extruder_advance_K[EXTRUDERS];
+        float extruder_advance_K[MIN(EXTRUDERS, 1)];
         _FIELD_TEST(planner_extruder_advance_K);
         EEPROM_READ(extruder_advance_K);
         #if ENABLED(LIN_ADVANCE)
@@ -2554,9 +2554,9 @@ void MarlinSettings::reset() {
   #if ENABLED(LIN_ADVANCE)
     LOOP_L_N(i, EXTRUDERS) {
       planner.extruder_advance_K[i] = LIN_ADVANCE_K;
-    #if ENABLED(EXTRA_LIN_ADVANCE_K)
-      saved_extruder_advance_K[i] = LIN_ADVANCE_K;
-    #endif
+      #if ENABLED(EXTRA_LIN_ADVANCE_K)
+        saved_extruder_advance_K[i] = LIN_ADVANCE_K;
+      #endif
     }
   #endif
 

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b4de08db78..b389741b79 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2354,7 +2354,12 @@ void MarlinSettings::reset() {
   #if HAS_BED_PROBE
     constexpr float dpo[XYZ] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
-    LOOP_XYZ(a) probe_offset[a] = dpo[a];
+    #if HAS_PROBE_XY_OFFSET
+      LOOP_XYZ(a) probe_offset[a] = dpo[a];
+    #else
+      probe_offset.x = probe_offset.y = 0;
+      probe_offset.z = dpo[Z_AXIS];
+    #endif
   #endif
 
   //
@@ -3102,9 +3107,16 @@ void MarlinSettings::reset() {
         say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(PSTR("  M851 X"), LINEAR_UNIT(probe_offset.x),
-                                  SP_Y_STR, LINEAR_UNIT(probe_offset.y),
-                                  SP_Z_STR, LINEAR_UNIT(probe_offset.z));
+      SERIAL_ECHOLNPAIR_P(
+        #if HAS_PROBE_XY_OFFSET
+          PSTR("  M851 X"), LINEAR_UNIT(probe_offset_xy.x),
+                  SP_Y_STR, LINEAR_UNIT(probe_offset_xy.y),
+                  SP_Z_STR
+        #else
+          PSTR("  M851 X0 Y0 Z")
+        #endif
+        , LINEAR_UNIT(probe_offset.z)
+      );
     #endif
 
     /**

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1a090613f8..b4de08db78 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -54,7 +54,7 @@
 #include "../core/language.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/persistent_store_api.h"

commit 629c039eedcb65adf21e63d55b6ae86aac68c85b
Author: iain MacDonnell <github@dseven.org>
Date:   Thu Dec 12 14:54:54 2019 -0800

    Update M503 MBL G29 report (#16199)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 5b08ce30a3..1a090613f8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2877,10 +2877,12 @@ void MarlinSettings::reset() {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 X"), (int)px + 1, SP_Y_STR, (int)py + 1);
+              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), (int)px, PSTR(" J"), (int)py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
+          CONFIG_ECHO_START();
+          SERIAL_ECHOLNPAIR_F_P(PSTR("  G29 S4 Z"), LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)

commit b65ab2173318df866d47c93ee14f5eea7f3d2729
Author: Antti Andreimann <anttix@users.sourceforge.net>
Date:   Thu Dec 5 20:51:41 2019 -0600

    Fix compile error with disabled PIDTEMP (#16108)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 91adc2ef27..5b08ce30a3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -788,11 +788,16 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
         PIDCF_t pidcf = {
-                       PID_PARAM(Kp, e),
-          unscalePID_i(PID_PARAM(Ki, e)),
-          unscalePID_d(PID_PARAM(Kd, e)),
-                       PID_PARAM(Kc, e),
-                       PID_PARAM(Kf, e)
+          #if DISABLED(PIDTEMP)
+            DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE,
+            DUMMY_PID_VALUE, DUMMY_PID_VALUE
+          #else
+                         PID_PARAM(Kp, e),
+            unscalePID_i(PID_PARAM(Ki, e)),
+            unscalePID_d(PID_PARAM(Kd, e)),
+                         PID_PARAM(Kc, e),
+                         PID_PARAM(Kf, e)
+          #endif
         };
         EEPROM_WRITE(pidcf);
       }

commit cb7817093fbe0ea7a3a2bac06f38d8bd66ba99d2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 1 22:23:19 2019 -0600

    More serial macro cleanup

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b5a5e50024..91adc2ef27 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3124,45 +3124,31 @@ void MarlinSettings::reset() {
 
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(forReplay);
-        SERIAL_ECHOLNPAIR_P(
-          #if AXIS_IS_TMC(X)
-            SP_X_STR, stepperX.getMilliamps()
-          #endif
-          #if AXIS_IS_TMC(Y)
-            #if AXIS_IS_TMC(X)
-              ,
-            #endif
-            SP_Y_STR, stepperY.getMilliamps()
-          #endif
-          #if AXIS_IS_TMC(Z)
-            #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y)
-              ,
-            #endif
-            SP_Z_STR, stepperZ.getMilliamps()
-          #endif
-        );
+        #if AXIS_IS_TMC(X)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
+        #endif
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(forReplay);
         SERIAL_ECHOPGM(" I1");
-        SERIAL_ECHOLNPAIR_P(
-          #if AXIS_IS_TMC(X2)
-            SP_X_STR, stepperX2.getMilliamps()
-          #endif
-          #if AXIS_IS_TMC(Y2)
-            #if AXIS_IS_TMC(X2)
-              ,
-            #endif
-            SP_Y_STR, stepperY2.getMilliamps()
-          #endif
-          #if AXIS_IS_TMC(Z2)
-            #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2)
-              ,
-            #endif
-            SP_Z_STR, stepperZ2.getMilliamps()
-          #endif
-        );
+        #if AXIS_IS_TMC(X2)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
+        #endif
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(Z3)
@@ -3333,9 +3319,9 @@ void MarlinSettings::reset() {
 
         if (chop_x || chop_y || chop_z) {
           say_M569(forReplay);
-          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
+          if (chop_x) SERIAL_ECHO_P(SP_X_STR);
+          if (chop_y) SERIAL_ECHO_P(SP_Y_STR);
+          if (chop_z) SERIAL_ECHO_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
@@ -3357,9 +3343,9 @@ void MarlinSettings::reset() {
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
-          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
+          if (chop_x2) SERIAL_ECHO_P(SP_X_STR);
+          if (chop_y2) SERIAL_ECHO_P(SP_Y_STR);
+          if (chop_z2) SERIAL_ECHO_P(SP_Z_STR);
           SERIAL_EOL();
         }
 

commit 9114a14ecad5a78e343403ed2ea529fffc341578
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 1 21:58:10 2019 -0600

    Fix commas in EEPROM code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index fdd851c170..b5a5e50024 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3126,12 +3126,18 @@ void MarlinSettings::reset() {
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR_P(
           #if AXIS_IS_TMC(X)
-            SP_X_STR, stepperX.getMilliamps(),
+            SP_X_STR, stepperX.getMilliamps()
           #endif
           #if AXIS_IS_TMC(Y)
-            SP_Y_STR, stepperY.getMilliamps(),
+            #if AXIS_IS_TMC(X)
+              ,
+            #endif
+            SP_Y_STR, stepperY.getMilliamps()
           #endif
           #if AXIS_IS_TMC(Z)
+            #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y)
+              ,
+            #endif
             SP_Z_STR, stepperZ.getMilliamps()
           #endif
         );
@@ -3142,12 +3148,18 @@ void MarlinSettings::reset() {
         SERIAL_ECHOPGM(" I1");
         SERIAL_ECHOLNPAIR_P(
           #if AXIS_IS_TMC(X2)
-            SP_X_STR, stepperX2.getMilliamps(),
+            SP_X_STR, stepperX2.getMilliamps()
           #endif
           #if AXIS_IS_TMC(Y2)
-            SP_Y_STR, stepperY2.getMilliamps(),
+            #if AXIS_IS_TMC(X2)
+              ,
+            #endif
+            SP_Y_STR, stepperY2.getMilliamps()
           #endif
           #if AXIS_IS_TMC(Z2)
+            #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2)
+              ,
+            #endif
             SP_Z_STR, stepperZ2.getMilliamps()
           #endif
         );

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 80a7c4ffc6..fdd851c170 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -129,6 +129,8 @@ static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
+extern const char SP_X_STR[], SP_Y_STR[], SP_Z_STR[], SP_E_STR[];
+
 /**
  * Current EEPROM Layout
  *
@@ -2728,40 +2730,40 @@ void MarlinSettings::reset() {
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR(
-        "  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
-      , " Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
-      , " Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
+      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
+      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
       #if DISABLED(DISTINCT_E_FACTORS)
-        , " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
+        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOLNPAIR(
-            "  M203 T", (int)i
-          , " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
+        SERIAL_ECHOLNPAIR_P(
+            PSTR("  M203 T"), (int)i
+          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
         );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR(
-        "  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
-      , " Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
-      , " Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
+      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
+      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
       #if DISABLED(DISTINCT_E_FACTORS)
-        , " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
+        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++)
-        SERIAL_ECHOLNPAIR(
-            "  M201 T", (int)i
-          , " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
+        SERIAL_ECHOLNPAIR_P(
+            PSTR("  M201 T"), (int)i
+          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
         );
     #endif
 
@@ -2788,19 +2790,19 @@ void MarlinSettings::reset() {
       SERIAL_EOL();
     }
     CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR(
-        "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us)
-      , " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
-      , " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
+      , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
+      , PSTR(" T"), LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
       #if DISABLED(CLASSIC_JERK)
-        , " J", LINEAR_UNIT(planner.junction_deviation_mm)
+        , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
       #if HAS_CLASSIC_JERK
-        , " X", LINEAR_UNIT(planner.max_jerk.x)
-        , " Y", LINEAR_UNIT(planner.max_jerk.y)
-        , " Z", LINEAR_UNIT(planner.max_jerk.z)
+        , SP_X_STR, LINEAR_UNIT(planner.max_jerk.x)
+        , SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y)
+        , SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z)
         #if HAS_CLASSIC_E_JERK
-          , " E", LINEAR_UNIT(planner.max_jerk.e)
+          , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
         #endif
       #endif
     );
@@ -2808,12 +2810,15 @@ void MarlinSettings::reset() {
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M206"
+      SERIAL_ECHOLNPAIR_P(
         #if IS_CARTESIAN
-          " X", LINEAR_UNIT(home_offset.x),
-          " Y", LINEAR_UNIT(home_offset.y),
+            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x)
+          , SP_Y_STR, LINEAR_UNIT(home_offset.y)
+          , SP_Z_STR
+        #else
+          PSTR("  M206 Z")
         #endif
-        " Z", LINEAR_UNIT(home_offset.z)
+        , LINEAR_UNIT(home_offset.z)
       );
     #endif
 
@@ -2821,11 +2826,12 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
       for (uint8_t e = 1; e < HOTENDS; e++) {
-        SERIAL_ECHOPAIR(
-          "  M218 T", (int)e,
-          " X", LINEAR_UNIT(hotend_offset[e].x), " Y", LINEAR_UNIT(hotend_offset[e].y)
+        SERIAL_ECHOPAIR_P(
+          PSTR("  M218 T"), (int)e,
+          SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
+          SP_Y_STR, LINEAR_UNIT(hotend_offset[e].y)
         );
-        SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[e].z), 3);
+        SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(hotend_offset[e].z), 3);
       }
     #endif
 
@@ -2853,10 +2859,10 @@ void MarlinSettings::reset() {
       #endif
 
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-        "  M420 S", planner.leveling_active ? 1 : 0
+      SERIAL_ECHOLNPAIR_P(
+        PSTR("  M420 S"), planner.leveling_active ? 1 : 0
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          , " Z", LINEAR_UNIT(planner.z_fade_height)
+          , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
         #endif
       );
 
@@ -2866,8 +2872,8 @@ void MarlinSettings::reset() {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1, " Y", (int)py + 1);
-              SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(mbl.z_values[px][py]), 5);
+              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 X"), (int)px + 1, SP_Y_STR, (int)py + 1);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
         }
@@ -2890,7 +2896,7 @@ void MarlinSettings::reset() {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
-              SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(z_values[px][py]), 5);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
@@ -2926,33 +2932,33 @@ void MarlinSettings::reset() {
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M665 S", delta_segments_per_second
-        , " P", scara_home_offset.a
-        , " T", scara_home_offset.b
-        , " Z", LINEAR_UNIT(scara_home_offset.z)
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M665 S"), delta_segments_per_second
+        , PSTR(" P"), scara_home_offset.a
+        , PSTR(" T"), scara_home_offset.b
+        , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
       );
 
     #elif ENABLED(DELTA)
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M666 X", LINEAR_UNIT(delta_endstop_adj.a)
-        , " Y", LINEAR_UNIT(delta_endstop_adj.b)
-        , " Z", LINEAR_UNIT(delta_endstop_adj.c)
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M666 X"), LINEAR_UNIT(delta_endstop_adj.a)
+        , SP_Y_STR, LINEAR_UNIT(delta_endstop_adj.b)
+        , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
       );
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> XYZ<tower angle corrections>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M665 L", LINEAR_UNIT(delta_diagonal_rod)
-        , " R", LINEAR_UNIT(delta_radius)
-        , " H", LINEAR_UNIT(delta_height)
-        , " S", delta_segments_per_second
-        , " X", LINEAR_UNIT(delta_tower_angle_trim.a)
-        , " Y", LINEAR_UNIT(delta_tower_angle_trim.b)
-        , " Z", LINEAR_UNIT(delta_tower_angle_trim.c)
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
+        , PSTR(" R"), LINEAR_UNIT(delta_radius)
+        , PSTR(" H"), LINEAR_UNIT(delta_height)
+        , PSTR(" S"), delta_segments_per_second
+        , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
+        , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
+        , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
       );
 
     #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -2961,17 +2967,17 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOPGM("  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(endstops.x2_endstop_adj));
+        SERIAL_ECHOPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstops.y2_endstop_adj));
+        SERIAL_ECHOPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         SERIAL_ECHOLNPAIR("S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
         CONFIG_ECHO_START();
         SERIAL_ECHOPAIR("  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
       #elif ENABLED(Z_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(endstops.z2_endstop_adj));
+        SERIAL_ECHOPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
       #endif
       SERIAL_EOL();
 
@@ -2999,13 +3005,16 @@ void MarlinSettings::reset() {
       #if ENABLED(PIDTEMP)
         HOTEND_LOOP() {
           CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR("  M301"
+          SERIAL_ECHOPAIR_P(
             #if HOTENDS > 1 && ENABLED(PID_PARAMS_PER_HOTEND)
-              " E", e,
+              PSTR("  M301 E"), e,
+              PSTR(" P")
+            #else
+              PSTR("  M301 P")
             #endif
-              " P", PID_PARAM(Kp, e)
-            , " I", unscalePID_i(PID_PARAM(Ki, e))
-            , " D", unscalePID_d(PID_PARAM(Kd, e))
+                        , PID_PARAM(Kp, e)
+            , PSTR(" I"), unscalePID_i(PID_PARAM(Ki, e))
+            , PSTR(" D"), unscalePID_d(PID_PARAM(Kd, e))
           );
           #if ENABLED(PID_EXTRUSION_SCALING)
             SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
@@ -3051,11 +3060,11 @@ void MarlinSettings::reset() {
 
       CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length)
-        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_length)
-        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
-        , " Z", LINEAR_UNIT(fwretract.settings.retract_zraise)
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
+        , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
+        , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
+        , SP_Z_STR, LINEAR_UNIT(fwretract.settings.retract_zraise)
       );
 
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
@@ -3086,9 +3095,9 @@ void MarlinSettings::reset() {
         say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(probe_offset.x),
-                              " Y", LINEAR_UNIT(probe_offset.y),
-                              " Z", LINEAR_UNIT(probe_offset.z));
+      SERIAL_ECHOLNPAIR_P(PSTR("  M851 X"), LINEAR_UNIT(probe_offset.x),
+                                  SP_Y_STR, LINEAR_UNIT(probe_offset.y),
+                                  SP_Z_STR, LINEAR_UNIT(probe_offset.z));
     #endif
 
     /**
@@ -3115,15 +3124,15 @@ void MarlinSettings::reset() {
 
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(
+        SERIAL_ECHOLNPAIR_P(
           #if AXIS_IS_TMC(X)
-            " X", stepperX.getMilliamps(),
+            SP_X_STR, stepperX.getMilliamps(),
           #endif
           #if AXIS_IS_TMC(Y)
-            " Y", stepperY.getMilliamps(),
+            SP_Y_STR, stepperY.getMilliamps(),
           #endif
           #if AXIS_IS_TMC(Z)
-            " Z", stepperZ.getMilliamps()
+            SP_Z_STR, stepperZ.getMilliamps()
           #endif
         );
       #endif
@@ -3131,15 +3140,15 @@ void MarlinSettings::reset() {
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(forReplay);
         SERIAL_ECHOPGM(" I1");
-        SERIAL_ECHOLNPAIR(
+        SERIAL_ECHOLNPAIR_P(
           #if AXIS_IS_TMC(X2)
-            " X", stepperX2.getMilliamps(),
+            SP_X_STR, stepperX2.getMilliamps(),
           #endif
           #if AXIS_IS_TMC(Y2)
-            " Y", stepperY2.getMilliamps(),
+            SP_Y_STR, stepperY2.getMilliamps(),
           #endif
           #if AXIS_IS_TMC(Z2)
-            " Z", stepperZ2.getMilliamps()
+            SP_Z_STR, stepperZ2.getMilliamps()
           #endif
         );
       #endif
@@ -3184,13 +3193,13 @@ void MarlinSettings::reset() {
           say_M913(forReplay);
         #endif
         #if AXIS_HAS_STEALTHCHOP(X)
-          SERIAL_ECHOPAIR(" X", stepperX.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          SERIAL_ECHOPAIR(" Y", stepperY.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          SERIAL_ECHOPAIR(" Z", stepperZ.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           SERIAL_EOL();
@@ -3201,13 +3210,13 @@ void MarlinSettings::reset() {
           SERIAL_ECHOPGM(" I1");
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          SERIAL_ECHOPAIR(" X", stepperX2.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          SERIAL_ECHOPAIR(" Y", stepperY2.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          SERIAL_ECHOPAIR(" Z", stepperZ2.get_pwm_thrs());
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
           SERIAL_EOL();
@@ -3254,13 +3263,13 @@ void MarlinSettings::reset() {
           CONFIG_ECHO_START();
           say_M914();
           #if X_SENSORLESS
-            SERIAL_ECHOPAIR(" X", stepperX.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.homing_threshold());
           #endif
           #if Y_SENSORLESS
-            SERIAL_ECHOPAIR(" Y", stepperY.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.homing_threshold());
           #endif
           #if Z_SENSORLESS
-            SERIAL_ECHOPAIR(" Z", stepperZ.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.homing_threshold());
           #endif
           SERIAL_EOL();
         #endif
@@ -3270,13 +3279,13 @@ void MarlinSettings::reset() {
           say_M914();
           SERIAL_ECHOPGM(" I1");
           #if X2_SENSORLESS
-            SERIAL_ECHOPAIR(" X", stepperX2.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.homing_threshold());
           #endif
           #if Y2_SENSORLESS
-            SERIAL_ECHOPAIR(" Y", stepperY2.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.homing_threshold());
           #endif
           #if Z2_SENSORLESS
-            SERIAL_ECHOPAIR(" Z", stepperZ2.homing_threshold());
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.homing_threshold());
           #endif
           SERIAL_EOL();
         #endif
@@ -3312,9 +3321,9 @@ void MarlinSettings::reset() {
 
         if (chop_x || chop_y || chop_z) {
           say_M569(forReplay);
-          if (chop_x) SERIAL_ECHOPGM(" X");
-          if (chop_y) SERIAL_ECHOPGM(" Y");
-          if (chop_z) SERIAL_ECHOPGM(" Z");
+          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
@@ -3336,9 +3345,9 @@ void MarlinSettings::reset() {
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
-          if (chop_x2) SERIAL_ECHOPGM(" X");
-          if (chop_y2) SERIAL_ECHOPGM(" Y");
-          if (chop_z2) SERIAL_ECHOPGM(" Z");
+          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
@@ -3386,10 +3395,10 @@ void MarlinSettings::reset() {
     #if HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M907 X", stepper.motor_current_setting[0]
-        , " Z", stepper.motor_current_setting[1]
-        , " E", stepper.motor_current_setting[2]
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M907 X"), stepper.motor_current_setting[0]
+        , SP_Z_STR, stepper.motor_current_setting[1]
+        , SP_E_STR, stepper.motor_current_setting[2]
       );
     #endif
 
@@ -3429,13 +3438,13 @@ void MarlinSettings::reset() {
     #if ENABLED(BACKLASH_GCODE)
       CONFIG_ECHO_HEADING("Backlash compensation:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-        "  M425 F", backlash.get_correction(),
-        " X", LINEAR_UNIT(backlash.distance_mm.x),
-        " Y", LINEAR_UNIT(backlash.distance_mm.y),
-        " Z", LINEAR_UNIT(backlash.distance_mm.z)
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M425 F"), backlash.get_correction()
+        , SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x)
+        , SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y)
+        , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
         #ifdef BACKLASH_SMOOTHING_MM
-          , " S", LINEAR_UNIT(backlash.smoothing_mm)
+          , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
         #endif
       );
     #endif

commit 752a1e76aba505acc85e2dda0759ae214ed96b32
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 26 23:29:25 2019 -0800

    Float ABL mesh boundaries, no probe position rounding (#16018)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 111d4898b5..80a7c4ffc6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V73"
+#define EEPROM_VERSION "V74"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -192,7 +192,7 @@ typedef struct SettingsDataStruct {
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  xy_int_t bilinear_grid_spacing, bilinear_start;       // G29 L F
+  xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
   #else
@@ -658,7 +658,7 @@ void MarlinSettings::postprocess() {
       #else
         // For disabled Bilinear Grid write an empty 3x3 grid
         const uint8_t grid_max_x = 3, grid_max_y = 3;
-        const xy_int_t bilinear_start{0}, bilinear_grid_spacing{0};
+        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
         dummy = 0;
         EEPROM_WRITE(grid_max_x);
         EEPROM_WRITE(grid_max_y);
@@ -1469,7 +1469,7 @@ void MarlinSettings::postprocess() {
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
-            xy_int_t bgs, bs;
+            xy_pos_t bgs, bs;
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);

commit ff6518c0a891b5de5ef8d1aacff8be6228fe1104
Author: haschtl <haschtl@protonmail.com>
Date:   Tue Nov 26 10:34:43 2019 +0100

    Add PID_FAN_SCALING option (#15585)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index eef20f5f53..111d4898b5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V72"
+#define EEPROM_VERSION "V73"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -242,7 +242,7 @@ typedef struct SettingsDataStruct {
   //
   // PIDTEMP
   //
-  PIDC_t hotendPID[HOTENDS];                            // M301 En PIDC / M303 En U
+  PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
   int16_t lpq_len;                                      // M301 L
 
   //
@@ -785,13 +785,14 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
-        PIDC_t pidc = {
+        PIDCF_t pidcf = {
                        PID_PARAM(Kp, e),
           unscalePID_i(PID_PARAM(Ki, e)),
           unscalePID_d(PID_PARAM(Kd, e)),
-                       PID_PARAM(Kc, e)
+                       PID_PARAM(Kc, e),
+                       PID_PARAM(Kf, e)
         };
-        EEPROM_WRITE(pidc);
+        EEPROM_WRITE(pidcf);
       }
 
       _FIELD_TEST(lpq_len);
@@ -1586,16 +1587,19 @@ void MarlinSettings::postprocess() {
       //
       {
         HOTEND_LOOP() {
-          PIDC_t pidc;
-          EEPROM_READ(pidc);
+          PIDCF_t pidcf;
+          EEPROM_READ(pidcf);
           #if ENABLED(PIDTEMP)
-            if (!validating && pidc.Kp != DUMMY_PID_VALUE) {
+            if (!validating && pidcf.Kp != DUMMY_PID_VALUE) {
               // Scale PID values since EEPROM values are unscaled
-              PID_PARAM(Kp, e) = pidc.Kp;
-              PID_PARAM(Ki, e) = scalePID_i(pidc.Ki);
-              PID_PARAM(Kd, e) = scalePID_d(pidc.Kd);
+              PID_PARAM(Kp, e) = pidcf.Kp;
+              PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
+              PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
               #if ENABLED(PID_EXTRUSION_SCALING)
-                PID_PARAM(Kc, e) = pidc.Kc;
+                PID_PARAM(Kc, e) = pidcf.Kc;
+              #endif
+              #if ENABLED(PID_FAN_SCALING)
+                PID_PARAM(Kf, e) = pidcf.Kf;
               #endif
             }
           #endif
@@ -2446,6 +2450,10 @@ void MarlinSettings::reset() {
       #if ENABLED(PID_EXTRUSION_SCALING)
         PID_PARAM(Kc, e) = DEFAULT_Kc;
       #endif
+
+      #if ENABLED(PID_FAN_SCALING)
+        PID_PARAM(Kf, e) = DEFAULT_Kf;
+      #endif
     }
   #endif
 
@@ -3003,6 +3011,9 @@ void MarlinSettings::reset() {
             SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
             if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
           #endif
+          #if ENABLED(PID_FAN_SCALING)
+            SERIAL_ECHOPAIR(" F", PID_PARAM(Kf, e));
+          #endif
           SERIAL_EOL();
         }
       #endif // PIDTEMP

commit b904ba0f291cdcb9759464f064f85ba066b778ce
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 21 01:26:00 2019 -0800

    Improve Delta probing / calibration (#15887)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 84921d8b34..eef20f5f53 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V71"
+#define EEPROM_VERSION "V72"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -223,8 +223,7 @@ typedef struct SettingsDataStruct {
     abc_float_t delta_endstop_adj;                      // M666 XYZ
     float delta_radius,                                 // M665 R
           delta_diagonal_rod,                           // M665 L
-          delta_segments_per_second,                    // M665 S
-          delta_calibration_radius;                     // M665 B
+          delta_segments_per_second;                    // M665 S
     abc_float_t delta_tower_angle_trim;                 // M665 XYZ
   #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
@@ -724,7 +723,6 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(delta_radius);              // 1 float
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
         EEPROM_WRITE(delta_segments_per_second); // 1 float
-        EEPROM_WRITE(delta_calibration_radius);  // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
       #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -1534,7 +1532,6 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(delta_radius);              // 1 float
           EEPROM_READ(delta_diagonal_rod);        // 1 float
           EEPROM_READ(delta_segments_per_second); // 1 float
-          EEPROM_READ(delta_calibration_radius);  // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
 
         #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -2375,7 +2372,6 @@ void MarlinSettings::reset() {
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
-    delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
     delta_tower_angle_trim = dta;
 
   #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -2939,14 +2935,13 @@ void MarlinSettings::reset() {
         , " Z", LINEAR_UNIT(delta_endstop_adj.c)
       );
 
-      CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
+      CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> XYZ<tower angle corrections>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
           "  M665 L", LINEAR_UNIT(delta_diagonal_rod)
         , " R", LINEAR_UNIT(delta_radius)
         , " H", LINEAR_UNIT(delta_height)
         , " S", delta_segments_per_second
-        , " B", LINEAR_UNIT(delta_calibration_radius)
         , " X", LINEAR_UNIT(delta_tower_angle_trim.a)
         , " Y", LINEAR_UNIT(delta_tower_angle_trim.b)
         , " Z", LINEAR_UNIT(delta_tower_angle_trim.c)

commit 3f4636e916f0c2635f83f457fa662b90fc3a8809
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 13 02:53:11 2019 -0600

    "nozzle_to_probe_offset" is obsolete

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1341a87d64..84921d8b34 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2344,9 +2344,6 @@ void MarlinSettings::reset() {
   #endif
 
   #if HAS_BED_PROBE
-    #ifndef NOZZLE_TO_PROBE_OFFSET
-      #define NOZZLE_TO_PROBE_OFFSET { 0, 0, 0 }
-    #endif
     constexpr float dpo[XYZ] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     LOOP_XYZ(a) probe_offset[a] = dpo[a];

commit a4709ba7658b654d43018953bf6f74fcabe86969
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 13 01:47:46 2019 -0600

    Store unscaled PID values in EEPROM (#15884)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f3de8f0531..1341a87d64 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V70"
+#define EEPROM_VERSION "V71"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -788,7 +788,10 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
         PIDC_t pidc = {
-          PID_PARAM(Kp, e), PID_PARAM(Ki, e), PID_PARAM(Kd, e), PID_PARAM(Kc, e)
+                       PID_PARAM(Kp, e),
+          unscalePID_i(PID_PARAM(Ki, e)),
+          unscalePID_d(PID_PARAM(Kd, e)),
+                       PID_PARAM(Kc, e)
         };
         EEPROM_WRITE(pidc);
       }
@@ -808,12 +811,17 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(bedPID);
 
-      #if DISABLED(PIDTEMPBED)
-        const PID_t bed_pid = { DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE };
-        EEPROM_WRITE(bed_pid);
-      #else
-        EEPROM_WRITE(thermalManager.temp_bed.pid);
-      #endif
+      const PID_t bed_pid = {
+        #if DISABLED(PIDTEMPBED)
+          DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE
+        #else
+          // Store the unscaled PID values
+          thermalManager.temp_bed.pid.Kp,
+          unscalePID_i(thermalManager.temp_bed.pid.Ki),
+          unscalePID_d(thermalManager.temp_bed.pid.Kd)
+        #endif
+      };
+      EEPROM_WRITE(bed_pid);
     }
 
     //
@@ -1585,10 +1593,10 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(pidc);
           #if ENABLED(PIDTEMP)
             if (!validating && pidc.Kp != DUMMY_PID_VALUE) {
-              // No need to scale PID values since EEPROM values are scaled
+              // Scale PID values since EEPROM values are unscaled
               PID_PARAM(Kp, e) = pidc.Kp;
-              PID_PARAM(Ki, e) = pidc.Ki;
-              PID_PARAM(Kd, e) = pidc.Kd;
+              PID_PARAM(Ki, e) = scalePID_i(pidc.Ki);
+              PID_PARAM(Kd, e) = scalePID_d(pidc.Kd);
               #if ENABLED(PID_EXTRUSION_SCALING)
                 PID_PARAM(Kc, e) = pidc.Kc;
               #endif
@@ -1617,8 +1625,12 @@ void MarlinSettings::postprocess() {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
-          if (!validating && pid.Kp != DUMMY_PID_VALUE)
-            memcpy(&thermalManager.temp_bed.pid, &pid, sizeof(pid));
+          if (!validating && pid.Kp != DUMMY_PID_VALUE) {
+            // Scale PID values since EEPROM values are unscaled
+            thermalManager.temp_bed.pid.Kp = pid.Kp;
+            thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
+            thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
+          }
         #endif
       }
 

commit 5e5045c4eefb020ddaa8aebe06297b4a3e9e8d06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 9 21:17:18 2019 -0600

    Touch UI finishing touches

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 993dfbf5e7..f3de8f0531 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2091,12 +2091,12 @@ void MarlinSettings::postprocess() {
     validating = true;
     #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
       bool success = _load();
-      if(!success && restoreEEPROM()) {
+      if (!success && restoreEEPROM()) {
         SERIAL_ECHOLNPGM("Recovered backup EEPROM settings from SPI Flash");
         success = _load();
       }
     #else
-    const bool success = _load();
+      const bool success = _load();
     #endif
     validating = false;
     return success;

commit 5639b8ca20bd67a4f6c9a8d5cf5ce1db3ec74aa8
Author: Marcio Teixeira <57453521+marcio-cp@users.noreply.github.com>
Date:   Sun Nov 10 17:49:41 2019 -0700

    Touch UI fixes for Cocoa Press (#15847)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3d2d78875b..993dfbf5e7 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -446,6 +446,13 @@ void MarlinSettings::postprocess() {
 
 #endif // SD_FIRMWARE_UPDATE
 
+#ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+  static_assert(
+      EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
+      "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data."
+    );
+#endif
+
 #define DEBUG_OUT ENABLED(EEPROM_CHITCHAT)
 #include "../core/debug_out.h"
 
@@ -2076,9 +2083,21 @@ void MarlinSettings::postprocess() {
     return !eeprom_error;
   }
 
+  #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+    extern bool restoreEEPROM();
+  #endif
+
   bool MarlinSettings::validate() {
     validating = true;
+    #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+      bool success = _load();
+      if(!success && restoreEEPROM()) {
+        SERIAL_ECHOLNPGM("Recovered backup EEPROM settings from SPI Flash");
+        success = _load();
+      }
+    #else
     const bool success = _load();
+    #endif
     validating = false;
     return success;
   }

commit ac466ecf74892079840b18f6e8aeb2c324c88aec
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Fri Oct 11 07:31:59 2019 +0700

    Change Junction Deviation to Classic Jerk (#15505)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a726586e13..3d2d78875b 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -525,7 +525,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if DISABLED(CLASSIC_JERK)
         EEPROM_WRITE(planner.junction_deviation_mm);
       #else
         dummy = 0.02f;
@@ -1323,7 +1323,7 @@ void MarlinSettings::postprocess() {
           for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
         #endif
 
-        #if ENABLED(JUNCTION_DEVIATION)
+        #if DISABLED(CLASSIC_JERK)
           EEPROM_READ(planner.junction_deviation_mm);
         #else
           EEPROM_READ(dummy);
@@ -2235,7 +2235,7 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
-  #if ENABLED(JUNCTION_DEVIATION)
+  #if DISABLED(CLASSIC_JERK)
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #endif
 
@@ -2744,7 +2744,7 @@ void MarlinSettings::reset() {
     if (!forReplay) {
       CONFIG_ECHO_START();
       SERIAL_ECHOPGM("Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if DISABLED(CLASSIC_JERK)
         SERIAL_ECHOPGM(" J<junc_dev>");
       #endif
       #if HAS_CLASSIC_JERK
@@ -2760,7 +2760,7 @@ void MarlinSettings::reset() {
         "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us)
       , " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
       , " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if DISABLED(CLASSIC_JERK)
         , " J", LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
       #if HAS_CLASSIC_JERK

commit af80653f3f65017c3c5a9e73e2b1360ac2e02fd2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 7 21:13:15 2019 -0500

    Always report all PIDs in M503
    
    Fix #14474

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9c29f16c7a..a726586e13 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2964,38 +2964,23 @@ void MarlinSettings::reset() {
     #if HAS_PID_HEATING
 
       CONFIG_ECHO_HEADING("PID settings:");
+
       #if ENABLED(PIDTEMP)
-        #if HOTENDS > 1
-          if (forReplay) {
-            HOTEND_LOOP() {
-              CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR(
-                  "  M301 E", e
-                , " P", PID_PARAM(Kp, e)
-                , " I", unscalePID_i(PID_PARAM(Ki, e))
-                , " D", unscalePID_d(PID_PARAM(Kd, e))
-              );
-              #if ENABLED(PID_EXTRUSION_SCALING)
-                SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
-                if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
-              #endif
-              SERIAL_EOL();
-            }
-          }
-          else
-        #endif // HOTENDS > 1
-        // !forReplay || HOTENDS == 1
-        {
+        HOTEND_LOOP() {
           CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR(
-              "  M301 P", PID_PARAM(Kp, 0) // for compatibility with hosts, only echo values for E0
-            , " I", unscalePID_i(PID_PARAM(Ki, 0))
-            , " D", unscalePID_d(PID_PARAM(Kd, 0))
-            #if ENABLED(PID_EXTRUSION_SCALING)
-              , " C", PID_PARAM(Kc, 0)
-              , " L", thermalManager.lpq_len
+          SERIAL_ECHOPAIR("  M301"
+            #if HOTENDS > 1 && ENABLED(PID_PARAMS_PER_HOTEND)
+              " E", e,
             #endif
+              " P", PID_PARAM(Kp, e)
+            , " I", unscalePID_i(PID_PARAM(Ki, e))
+            , " D", unscalePID_d(PID_PARAM(Kd, e))
           );
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
+            if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
+          #endif
+          SERIAL_EOL();
         }
       #endif // PIDTEMP
 

commit c0005e939cf9c1d9db16f20e605c3228bc41a758
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 8 19:42:18 2019 -0500

    Enable junction deviation by default (#15481)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f00eb98e4a..9c29f16c7a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -398,7 +398,7 @@ void MarlinSettings::postprocess() {
     fwretract.refresh_autoretract();
   #endif
 
-  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+  #if HAS_LINEAR_E_JERK
     planner.recalculate_max_e_jerk();
   #endif
 
@@ -516,7 +516,7 @@ void MarlinSettings::postprocess() {
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
-        #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+        #if HAS_LINEAR_E_JERK
           dummy = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummy);
         #endif
@@ -1316,7 +1316,7 @@ void MarlinSettings::postprocess() {
 
         #if HAS_CLASSIC_JERK
           EEPROM_READ(planner.max_jerk);
-          #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+          #if HAS_LINEAR_E_JERK
             EEPROM_READ(dummy);
           #endif
         #else
@@ -2230,7 +2230,7 @@ void MarlinSettings::reset() {
       #define DEFAULT_ZJERK 0
     #endif
     planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
-    #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+    #if HAS_CLASSIC_E_JERK
       planner.max_jerk.e = DEFAULT_EJERK;
     #endif
   #endif
@@ -2749,7 +2749,7 @@ void MarlinSettings::reset() {
       #endif
       #if HAS_CLASSIC_JERK
         SERIAL_ECHOPGM(" X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
-        #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+        #if HAS_CLASSIC_E_JERK
           SERIAL_ECHOPGM(" E<max_e_jerk>");
         #endif
       #endif
@@ -2767,7 +2767,7 @@ void MarlinSettings::reset() {
         , " X", LINEAR_UNIT(planner.max_jerk.x)
         , " Y", LINEAR_UNIT(planner.max_jerk.y)
         , " Z", LINEAR_UNIT(planner.max_jerk.z)
-        #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+        #if HAS_CLASSIC_E_JERK
           , " E", LINEAR_UNIT(planner.max_jerk.e)
         #endif
       #endif

commit 806d64e1bf5a838a88e8a473bcb2b0f353b90c30
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:45:00 2019 -0500

    X_SENSORLESS includes AXIS_HAS_STALLGUARD

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 88e219db9c..f00eb98e4a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3246,27 +3246,23 @@ void MarlinSettings::reset() {
           SERIAL_EOL();
         #endif
 
-        #define HAS_X2_SENSORLESS (defined(X_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
-        #define HAS_Y2_SENSORLESS (defined(Y_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Y2))
-        #define HAS_Z2_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
-        #define HAS_Z3_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
-        #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
+        #if X2_SENSORLESS || Y2_SENSORLESS || Z2_SENSORLESS
           CONFIG_ECHO_START();
           say_M914();
           SERIAL_ECHOPGM(" I1");
-          #if HAS_X2_SENSORLESS
+          #if X2_SENSORLESS
             SERIAL_ECHOPAIR(" X", stepperX2.homing_threshold());
           #endif
-          #if HAS_Y2_SENSORLESS
+          #if Y2_SENSORLESS
             SERIAL_ECHOPAIR(" Y", stepperY2.homing_threshold());
           #endif
-          #if HAS_Z2_SENSORLESS
+          #if Z2_SENSORLESS
             SERIAL_ECHOPAIR(" Z", stepperZ2.homing_threshold());
           #endif
           SERIAL_EOL();
         #endif
 
-        #if HAS_Z3_SENSORLESS
+        #if Z3_SENSORLESS
           CONFIG_ECHO_START();
           say_M914();
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());

commit 74746c6573593596301acbb5bb947977eae524d4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 29 16:55:34 2019 -0500

    Fix probe_offset EEPROM field test

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 699b44cdb2..88e219db9c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -614,10 +614,10 @@ void MarlinSettings::postprocess() {
     }
 
     //
-    // Probe Z Offset
+    // Probe XYZ Offsets
     //
     {
-      _FIELD_TEST(probe_offset.z);
+      _FIELD_TEST(probe_offset);
       EEPROM_WRITE(probe_offset);
     }
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3d723909b0..699b44cdb2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -52,7 +52,7 @@
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
-#include "../libs/vector_3.h"
+#include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../Marlin.h"
 
@@ -146,13 +146,13 @@ typedef struct SettingsDataStruct {
 
   planner_settings_t planner_settings;
 
-  float planner_max_jerk[XYZE],                         // M205 XYZE  planner.max_jerk[XYZE]
-        planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
+  xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
+  float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
-  float home_offset[XYZ];                               // M206 XYZ / M665 TPZ
+  xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
 
   #if HAS_HOTEND_OFFSET
-    float hotend_offset[XYZ][HOTENDS - 1];              // M218 XYZ
+    xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
   #endif
 
   //
@@ -181,7 +181,7 @@ typedef struct SettingsDataStruct {
   // HAS_BED_PROBE
   //
 
-  float probe_offset[XYZ];
+  xyz_pos_t probe_offset;
 
   //
   // ABL_PLANAR
@@ -192,10 +192,9 @@ typedef struct SettingsDataStruct {
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  int bilinear_grid_spacing[2],
-      bilinear_start[2];                                // G29 L F
+  xy_int_t bilinear_grid_spacing, bilinear_start;       // G29 L F
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-    float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y]; // G29
+    bed_mesh_t z_values;                                // G29
   #else
     float z_values[3][3];
   #endif
@@ -220,13 +219,13 @@ typedef struct SettingsDataStruct {
   // DELTA / [XYZ]_DUAL_ENDSTOPS
   //
   #if ENABLED(DELTA)
-    float delta_height,                                 // M666 H
-          delta_endstop_adj[ABC],                       // M666 XYZ
-          delta_radius,                                 // M665 R
+    float delta_height;                                 // M666 H
+    abc_float_t delta_endstop_adj;                      // M666 XYZ
+    float delta_radius,                                 // M665 R
           delta_diagonal_rod,                           // M665 L
           delta_segments_per_second,                    // M665 S
-          delta_calibration_radius,                     // M665 B
-          delta_tower_angle_trim[ABC];                  // M665 XYZ
+          delta_calibration_radius;                     // M665 B
+    abc_float_t delta_tower_angle_trim;                 // M665 XYZ
   #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
@@ -302,7 +301,7 @@ typedef struct SettingsDataStruct {
   //
   // CNC_COORDINATE_SYSTEMS
   //
-  float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ]; // G54-G59.3
+  xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
@@ -326,7 +325,7 @@ typedef struct SettingsDataStruct {
   //
   // BACKLASH_COMPENSATION
   //
-  float backlash_distance_mm[XYZ];                      // M425 X Y Z
+  xyz_float_t backlash_distance_mm;                     // M425 X Y Z
   uint8_t backlash_correction;                          // M425 F
   float backlash_smoothing_mm;                          // M425 S
 
@@ -355,7 +354,7 @@ uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 #endif
 
 void MarlinSettings::postprocess() {
-  const float oldpos[XYZE] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS] };
+  xyze_pos_t oldpos = current_position;
 
   // steps per s2 needs to be updated to agree with units per s2
   planner.reset_acceleration_rates();
@@ -408,7 +407,7 @@ void MarlinSettings::postprocess() {
   planner.refresh_positioning();
 
   // Various factors can change the current position
-  if (memcmp(oldpos, current_position, sizeof(oldpos)))
+  if (oldpos != current_position)
     report_current_position();
 }
 
@@ -522,7 +521,7 @@ void MarlinSettings::postprocess() {
           EEPROM_WRITE(dummy);
         #endif
       #else
-        const float planner_max_jerk[XYZE] = { float(DEFAULT_EJERK) };
+        const xyze_pos_t planner_max_jerk = { 10, 10, 0.4, float(DEFAULT_EJERK) };
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
@@ -544,7 +543,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(scara_home_offset);
       #else
         #if !HAS_HOME_OFFSET
-          const float home_offset[XYZ] = { 0 };
+          const xyz_pos_t home_offset{0};
         #endif
         EEPROM_WRITE(home_offset);
       #endif
@@ -552,7 +551,7 @@ void MarlinSettings::postprocess() {
       #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
         for (uint8_t e = 1; e < HOTENDS; e++)
-          LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
+          EEPROM_WRITE(hotend_offset[e]);
       #endif
     }
 
@@ -618,7 +617,7 @@ void MarlinSettings::postprocess() {
     // Probe Z Offset
     //
     {
-      _FIELD_TEST(probe_offset[Z_AXIS]);
+      _FIELD_TEST(probe_offset.z);
       EEPROM_WRITE(probe_offset);
     }
 
@@ -653,7 +652,7 @@ void MarlinSettings::postprocess() {
       #else
         // For disabled Bilinear Grid write an empty 3x3 grid
         const uint8_t grid_max_x = 3, grid_max_y = 3;
-        const int bilinear_start[2] = { 0 }, bilinear_grid_spacing[2] = { 0 };
+        const xy_int_t bilinear_start{0}, bilinear_grid_spacing{0};
         dummy = 0;
         EEPROM_WRITE(grid_max_x);
         EEPROM_WRITE(grid_max_y);
@@ -1033,7 +1032,7 @@ void MarlinSettings::postprocess() {
     // TMC StallGuard threshold
     //
     {
-      tmc_sgt_t tmc_sgt = { 0 };
+      tmc_sgt_t tmc_sgt{0};
       #if USE_SENSORLESS
         #if X_SENSORLESS
           tmc_sgt.X = stepperX.homing_threshold();
@@ -1138,8 +1137,8 @@ void MarlinSettings::postprocess() {
       #if HAS_MOTOR_CURRENT_PWM
         EEPROM_WRITE(stepper.motor_current_setting);
       #else
-        const uint32_t dummyui32[XYZ] = { 0 };
-        EEPROM_WRITE(dummyui32);
+        const xyz_ulong_t no_current{0};
+        EEPROM_WRITE(no_current);
       #endif
     }
 
@@ -1152,7 +1151,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
       EEPROM_WRITE(gcode.coordinate_system);
     #else
-      const float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ] = { { 0 } };
+      const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
       EEPROM_WRITE(coordinate_system);
     #endif
 
@@ -1189,10 +1188,10 @@ void MarlinSettings::postprocess() {
     //
     {
       #if ENABLED(BACKLASH_GCODE)
-        const float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+        const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
         const uint8_t &backlash_correction = backlash.correction;
       #else
-        const float backlash_distance_mm[XYZ] = { 0 };
+        const xyz_float_t backlash_distance_mm{0};
         const uint8_t backlash_correction = 0;
       #endif
       #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
@@ -1341,7 +1340,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(scara_home_offset);
         #else
           #if !HAS_HOME_OFFSET
-            float home_offset[XYZ];
+            xyz_pos_t home_offset;
           #endif
           EEPROM_READ(home_offset);
         #endif
@@ -1354,7 +1353,7 @@ void MarlinSettings::postprocess() {
         #if HAS_HOTEND_OFFSET
           // Skip hotend 0 which must be 0
           for (uint8_t e = 1; e < HOTENDS; e++)
-            LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
+            EEPROM_READ(hotend_offset[e]);
         #endif
       }
 
@@ -1418,12 +1417,11 @@ void MarlinSettings::postprocess() {
       // Probe Z Offset
       //
       {
-        _FIELD_TEST(probe_offset[Z_AXIS]);
-
+        _FIELD_TEST(probe_offset);
         #if HAS_BED_PROBE
-          float (&zpo)[XYZ] = probe_offset;
+          xyz_pos_t &zpo = probe_offset;
         #else
-          float zpo[XYZ];
+          xyz_pos_t zpo;
         #endif
         EEPROM_READ(zpo);
       }
@@ -1457,7 +1455,7 @@ void MarlinSettings::postprocess() {
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
-            int bgs[2], bs[2];
+            xy_int_t bgs, bs;
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
@@ -1940,7 +1938,7 @@ void MarlinSettings::postprocess() {
           if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
           EEPROM_READ(gcode.coordinate_system);
         #else
-          float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
+          xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
           EEPROM_READ(coordinate_system);
         #endif
       }
@@ -1989,7 +1987,7 @@ void MarlinSettings::postprocess() {
       //
       {
         #if ENABLED(BACKLASH_GCODE)
-          float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+          xyz_float_t &backlash_distance_mm = backlash.distance_mm;
           uint8_t &backlash_correction = backlash.correction;
         #else
           float backlash_distance_mm[XYZ];
@@ -2231,11 +2229,9 @@ void MarlinSettings::reset() {
     #ifndef DEFAULT_ZJERK
       #define DEFAULT_ZJERK 0
     #endif
-    planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
-    planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
-    planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
+    planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
     #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
-      planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
+      planner.max_jerk.e = DEFAULT_EJERK;
     #endif
   #endif
 
@@ -2244,9 +2240,9 @@ void MarlinSettings::reset() {
   #endif
 
   #if HAS_SCARA_OFFSET
-    ZERO(scara_home_offset);
+    scara_home_offset.reset();
   #elif HAS_HOME_OFFSET
-    ZERO(home_offset);
+    home_offset.reset();
   #endif
 
   #if HAS_HOTEND_OFFSET
@@ -2277,17 +2273,16 @@ void MarlinSettings::reset() {
       toolchange_settings.retract_speed = TOOLCHANGE_FIL_SWAP_RETRACT_SPEED;
     #endif
     #if ENABLED(TOOLCHANGE_PARK)
-      toolchange_settings.change_point = TOOLCHANGE_PARK_XY;
+      constexpr xyz_pos_t tpxy = TOOLCHANGE_PARK_XY;
+      toolchange_settings.change_point = tpxy;
     #endif
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.correction = (BACKLASH_CORRECTION) * 255;
-    constexpr float tmp[XYZ] = BACKLASH_DISTANCE_MM;
-    backlash.distance_mm[X_AXIS] = tmp[X_AXIS];
-    backlash.distance_mm[Y_AXIS] = tmp[Y_AXIS];
-    backlash.distance_mm[Z_AXIS] = tmp[Z_AXIS];
+    constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
+    backlash.distance_mm = tmp;
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
@@ -2346,14 +2341,14 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(DELTA)
-    const float adj[ABC] = DELTA_ENDSTOP_ADJ, dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
+    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM;
     delta_height = DELTA_HEIGHT;
-    COPY(delta_endstop_adj, adj);
+    delta_endstop_adj = adj;
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
-    COPY(delta_tower_angle_trim, dta);
+    delta_tower_angle_trim = dta;
 
   #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
@@ -2769,11 +2764,11 @@ void MarlinSettings::reset() {
         , " J", LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
       #if HAS_CLASSIC_JERK
-        , " X", LINEAR_UNIT(planner.max_jerk[X_AXIS])
-        , " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS])
-        , " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS])
+        , " X", LINEAR_UNIT(planner.max_jerk.x)
+        , " Y", LINEAR_UNIT(planner.max_jerk.y)
+        , " Z", LINEAR_UNIT(planner.max_jerk.z)
         #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
-          , " E", LINEAR_UNIT(planner.max_jerk[E_AXIS])
+          , " E", LINEAR_UNIT(planner.max_jerk.e)
         #endif
       #endif
     );
@@ -2783,10 +2778,10 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR("  M206"
         #if IS_CARTESIAN
-          " X", LINEAR_UNIT(home_offset[X_AXIS]),
-          " Y", LINEAR_UNIT(home_offset[Y_AXIS]),
+          " X", LINEAR_UNIT(home_offset.x),
+          " Y", LINEAR_UNIT(home_offset.y),
         #endif
-        " Z", LINEAR_UNIT(home_offset[Z_AXIS])
+        " Z", LINEAR_UNIT(home_offset.z)
       );
     #endif
 
@@ -2796,9 +2791,9 @@ void MarlinSettings::reset() {
       for (uint8_t e = 1; e < HOTENDS; e++) {
         SERIAL_ECHOPAIR(
           "  M218 T", (int)e,
-          " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]), " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e])
+          " X", LINEAR_UNIT(hotend_offset[e].x), " Y", LINEAR_UNIT(hotend_offset[e].y)
         );
-        SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
+        SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[e].z), 3);
       }
     #endif
 
@@ -2901,9 +2896,9 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
           "  M665 S", delta_segments_per_second
-        , " P", scara_home_offset[A_AXIS]
-        , " T", scara_home_offset[B_AXIS]
-        , " Z", LINEAR_UNIT(scara_home_offset[Z_AXIS])
+        , " P", scara_home_offset.a
+        , " T", scara_home_offset.b
+        , " Z", LINEAR_UNIT(scara_home_offset.z)
       );
 
     #elif ENABLED(DELTA)
@@ -2911,9 +2906,9 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
-          "  M666 X", LINEAR_UNIT(delta_endstop_adj[A_AXIS])
-        , " Y", LINEAR_UNIT(delta_endstop_adj[B_AXIS])
-        , " Z", LINEAR_UNIT(delta_endstop_adj[C_AXIS])
+          "  M666 X", LINEAR_UNIT(delta_endstop_adj.a)
+        , " Y", LINEAR_UNIT(delta_endstop_adj.b)
+        , " Z", LINEAR_UNIT(delta_endstop_adj.c)
       );
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
@@ -2924,9 +2919,9 @@ void MarlinSettings::reset() {
         , " H", LINEAR_UNIT(delta_height)
         , " S", delta_segments_per_second
         , " B", LINEAR_UNIT(delta_calibration_radius)
-        , " X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS])
-        , " Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS])
-        , " Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS])
+        , " X", LINEAR_UNIT(delta_tower_angle_trim.a)
+        , " Y", LINEAR_UNIT(delta_tower_angle_trim.b)
+        , " Z", LINEAR_UNIT(delta_tower_angle_trim.c)
       );
 
     #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -3072,9 +3067,9 @@ void MarlinSettings::reset() {
         say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(probe_offset[X_AXIS]),
-                              " Y", LINEAR_UNIT(probe_offset[Y_AXIS]),
-                              " Z", LINEAR_UNIT(probe_offset[Z_AXIS]));
+      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(probe_offset.x),
+                              " Y", LINEAR_UNIT(probe_offset.y),
+                              " Z", LINEAR_UNIT(probe_offset.z));
     #endif
 
     /**
@@ -3421,9 +3416,9 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
         "  M425 F", backlash.get_correction(),
-        " X", LINEAR_UNIT(backlash.distance_mm[X_AXIS]),
-        " Y", LINEAR_UNIT(backlash.distance_mm[Y_AXIS]),
-        " Z", LINEAR_UNIT(backlash.distance_mm[Z_AXIS])
+        " X", LINEAR_UNIT(backlash.distance_mm.x),
+        " Y", LINEAR_UNIT(backlash.distance_mm.y),
+        " Z", LINEAR_UNIT(backlash.distance_mm.z)
         #ifdef BACKLASH_SMOOTHING_MM
           , " S", LINEAR_UNIT(backlash.smoothing_mm)
         #endif

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ad3f6f4dcb..3d723909b0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -124,6 +124,11 @@ typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, COUNT(ARR) - 1)
 
+// Defaults for reset / fill in on load
+static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
+static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
+static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
+
 /**
  * Current EEPROM Layout
  *
@@ -1289,21 +1294,19 @@ void MarlinSettings::postprocess() {
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
-        const uint32_t def1[] = DEFAULT_MAX_ACCELERATION;
-        const float def2[] = DEFAULT_AXIS_STEPS_PER_UNIT, def3[] = DEFAULT_MAX_FEEDRATE;
-
         uint32_t tmp1[XYZ + esteppers];
+        float tmp2[XYZ + esteppers];
+        feedRate_t tmp3[XYZ + esteppers];
         EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
         EEPROM_READ(planner.settings.min_segment_time_us);
-
-        float tmp2[XYZ + esteppers], tmp3[XYZ + esteppers];
         EEPROM_READ(tmp2);                         // axis_steps_per_mm
         EEPROM_READ(tmp3);                         // max_feedrate_mm_s
+
         if (!validating) LOOP_XYZE_N(i) {
           const bool in = (i < esteppers + XYZ);
-          planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : def1[ALIM(i, def1)];
-          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : def2[ALIM(i, def2)];
-          planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : def3[ALIM(i, def3)];
+          planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
+          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+          planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
@@ -2205,20 +2208,18 @@ void MarlinSettings::postprocess() {
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
-  static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
-  static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE_N(i) {
-    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&tmp1[ALIM(i, tmp1)]);
-    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&tmp2[ALIM(i, tmp2)]);
-    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&tmp3[ALIM(i, tmp3)]);
+    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
+    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
-  planner.settings.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
-  planner.settings.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
+  planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
+  planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
   #if HAS_CLASSIC_JERK
     #ifndef DEFAULT_XJERK
@@ -3039,7 +3040,7 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR(
           "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length)
         , " W", LINEAR_UNIT(fwretract.settings.swap_retract_length)
-        , " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s))
+        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
         , " Z", LINEAR_UNIT(fwretract.settings.retract_zraise)
       );
 
@@ -3048,7 +3049,7 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR(
           "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
         , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
-        , " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s))
+        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
       );
 
       #if ENABLED(FWRETRACT_AUTORETRACT)

commit ee7558a6228747a7502ab50e2817234fb8a6feb4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 26 01:15:35 2019 -0500

    Tweaks to Z fade behavior

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f12e377af3..ad3f6f4dcb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2061,7 +2061,7 @@ void MarlinSettings::postprocess() {
           }
           else {
             ubl.reset();
-            DEBUG_ECHOLNPGM("UBL System reset()");
+            DEBUG_ECHOLNPGM("UBL reset");
           }
         }
       #endif

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6b7f7ab958..f12e377af3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -176,7 +176,7 @@ typedef struct SettingsDataStruct {
   // HAS_BED_PROBE
   //
 
-  float zprobe_offset[XYZ];
+  float probe_offset[XYZ];
 
   //
   // ABL_PLANAR
@@ -613,8 +613,8 @@ void MarlinSettings::postprocess() {
     // Probe Z Offset
     //
     {
-      _FIELD_TEST(zprobe_offset[Z_AXIS]);
-      EEPROM_WRITE(zprobe_offset);
+      _FIELD_TEST(probe_offset[Z_AXIS]);
+      EEPROM_WRITE(probe_offset);
     }
 
     //
@@ -1415,10 +1415,10 @@ void MarlinSettings::postprocess() {
       // Probe Z Offset
       //
       {
-        _FIELD_TEST(zprobe_offset[Z_AXIS]);
+        _FIELD_TEST(probe_offset[Z_AXIS]);
 
         #if HAS_BED_PROBE
-          float (&zpo)[XYZ] = zprobe_offset;
+          float (&zpo)[XYZ] = probe_offset;
         #else
           float zpo[XYZ];
         #endif
@@ -2322,7 +2322,7 @@ void MarlinSettings::reset() {
     #endif
     constexpr float dpo[XYZ] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
-    LOOP_XYZ(a) zprobe_offset[a] = dpo[a];
+    LOOP_XYZ(a) probe_offset[a] = dpo[a];
   #endif
 
   //
@@ -3071,9 +3071,9 @@ void MarlinSettings::reset() {
         say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(zprobe_offset[X_AXIS]),
-                              " Y", LINEAR_UNIT(zprobe_offset[Y_AXIS]),
-                              " Z", LINEAR_UNIT(zprobe_offset[Z_AXIS]));
+      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(probe_offset[X_AXIS]),
+                              " Y", LINEAR_UNIT(probe_offset[Y_AXIS]),
+                              " Z", LINEAR_UNIT(probe_offset[Z_AXIS]));
     #endif
 
     /**

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b00f62f2c9..6b7f7ab958 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V69"
+#define EEPROM_VERSION "V70"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -60,6 +60,8 @@
   #include "../HAL/shared/persistent_store_api.h"
 #endif
 
+#include "probe.h"
+
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
@@ -78,10 +80,6 @@
   #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
 #endif
 
-#if HAS_BED_PROBE
-  #include "probe.h"
-#endif
-
 #include "../feature/fwretract.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -178,7 +176,7 @@ typedef struct SettingsDataStruct {
   // HAS_BED_PROBE
   //
 
-  float zprobe_zoffset;
+  float zprobe_offset[XYZ];
 
   //
   // ABL_PLANAR
@@ -615,12 +613,8 @@ void MarlinSettings::postprocess() {
     // Probe Z Offset
     //
     {
-      _FIELD_TEST(zprobe_zoffset);
-
-      #if !HAS_BED_PROBE
-        const float zprobe_zoffset = 0;
-      #endif
-      EEPROM_WRITE(zprobe_zoffset);
+      _FIELD_TEST(zprobe_offset[Z_AXIS]);
+      EEPROM_WRITE(zprobe_offset);
     }
 
     //
@@ -1421,12 +1415,14 @@ void MarlinSettings::postprocess() {
       // Probe Z Offset
       //
       {
-        _FIELD_TEST(zprobe_zoffset);
+        _FIELD_TEST(zprobe_offset[Z_AXIS]);
 
-        #if !HAS_BED_PROBE
-          float zprobe_zoffset;
+        #if HAS_BED_PROBE
+          float (&zpo)[XYZ] = zprobe_offset;
+        #else
+          float zpo[XYZ];
         #endif
-        EEPROM_READ(zprobe_zoffset);
+        EEPROM_READ(zpo);
       }
 
       //
@@ -2321,7 +2317,12 @@ void MarlinSettings::reset() {
   #endif
 
   #if HAS_BED_PROBE
-    zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
+    #ifndef NOZZLE_TO_PROBE_OFFSET
+      #define NOZZLE_TO_PROBE_OFFSET { 0, 0, 0 }
+    #endif
+    constexpr float dpo[XYZ] = NOZZLE_TO_PROBE_OFFSET;
+    static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
+    LOOP_XYZ(a) zprobe_offset[a] = dpo[a];
   #endif
 
   //
@@ -3070,7 +3071,9 @@ void MarlinSettings::reset() {
         say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M851 Z", LINEAR_UNIT(zprobe_zoffset));
+      SERIAL_ECHOLNPAIR("  M851 X", LINEAR_UNIT(zprobe_offset[X_AXIS]),
+                              " Y", LINEAR_UNIT(zprobe_offset[Y_AXIS]),
+                              " Z", LINEAR_UNIT(zprobe_offset[Z_AXIS]));
     #endif
 
     /**

commit 514223f960e01cd4dccf95daf8cb27c4a2806868
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Sep 19 22:48:41 2019 -0700

    Fix BACKLASH_COMPENSATION compiler issues (#15307)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 905fde8407..b00f62f2c9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1189,17 +1189,14 @@ void MarlinSettings::postprocess() {
     // Backlash Compensation
     //
     {
-      #ifdef BACKLASH_DISTANCE_MM
+      #if ENABLED(BACKLASH_GCODE)
         const float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
-      #else
-        const float backlash_distance_mm[XYZ] = { 0 };
-      #endif
-      #if ENABLED(BACKLASH_COMPENSATION)
         const uint8_t &backlash_correction = backlash.correction;
       #else
+        const float backlash_distance_mm[XYZ] = { 0 };
         const uint8_t backlash_correction = 0;
       #endif
-      #ifdef BACKLASH_SMOOTHING_MM
+      #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
         const float &backlash_smoothing_mm = backlash.smoothing_mm;
       #else
         const float backlash_smoothing_mm = 3;
@@ -1992,17 +1989,14 @@ void MarlinSettings::postprocess() {
       // Backlash Compensation
       //
       {
-        #ifdef BACKLASH_DISTANCE_MM
+        #if ENABLED(BACKLASH_GCODE)
           float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
-        #else
-          float backlash_distance_mm[XYZ];
-        #endif
-        #if ENABLED(BACKLASH_COMPENSATION)
           uint8_t &backlash_correction = backlash.correction;
         #else
+          float backlash_distance_mm[XYZ];
           uint8_t backlash_correction;
         #endif
-        #ifdef BACKLASH_SMOOTHING_MM
+        #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
           float &backlash_smoothing_mm = backlash.smoothing_mm;
         #else
           float backlash_smoothing_mm;
@@ -2293,12 +2287,10 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.correction = (BACKLASH_CORRECTION) * 255;
-    #ifdef BACKLASH_DISTANCE_MM
-      constexpr float tmp[XYZ] = BACKLASH_DISTANCE_MM;
-      backlash.distance_mm[X_AXIS] = tmp[X_AXIS];
-      backlash.distance_mm[Y_AXIS] = tmp[Y_AXIS];
-      backlash.distance_mm[Z_AXIS] = tmp[Z_AXIS];
-    #endif
+    constexpr float tmp[XYZ] = BACKLASH_DISTANCE_MM;
+    backlash.distance_mm[X_AXIS] = tmp[X_AXIS];
+    backlash.distance_mm[Y_AXIS] = tmp[Y_AXIS];
+    backlash.distance_mm[Z_AXIS] = tmp[Z_AXIS];
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 5d0a0300ba..905fde8407 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1205,9 +1205,7 @@ void MarlinSettings::postprocess() {
         const float backlash_smoothing_mm = 3;
       #endif
       _FIELD_TEST(backlash_distance_mm);
-      EEPROM_WRITE(backlash_distance_mm[X_AXIS]);
-      EEPROM_WRITE(backlash_distance_mm[Y_AXIS]);
-      EEPROM_WRITE(backlash_distance_mm[Z_AXIS]);
+      EEPROM_WRITE(backlash_distance_mm);
       EEPROM_WRITE(backlash_correction);
       EEPROM_WRITE(backlash_smoothing_mm);
     }
@@ -2010,9 +2008,7 @@ void MarlinSettings::postprocess() {
           float backlash_smoothing_mm;
         #endif
         _FIELD_TEST(backlash_distance_mm);
-        EEPROM_READ(backlash_distance_mm[X_AXIS]);
-        EEPROM_READ(backlash_distance_mm[Y_AXIS]);
-        EEPROM_READ(backlash_distance_mm[Z_AXIS]);
+        EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
       }
@@ -2805,9 +2801,8 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       for (uint8_t e = 1; e < HOTENDS; e++) {
         SERIAL_ECHOPAIR(
-            "  M218 T", (int)e
-          , " X", LINEAR_UNIT(hotend_offset[X_AXIS][e])
-          , " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e])
+          "  M218 T", (int)e,
+          " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]), " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e])
         );
         SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
       }
@@ -2922,9 +2917,9 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
-          "  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS])
-        , " Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS])
-        , " Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS])
+          "  M666 X", LINEAR_UNIT(delta_endstop_adj[A_AXIS])
+        , " Y", LINEAR_UNIT(delta_endstop_adj[B_AXIS])
+        , " Z", LINEAR_UNIT(delta_endstop_adj[C_AXIS])
       );
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d122c6e129..5d0a0300ba 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -309,7 +309,9 @@ typedef struct SettingsDataStruct {
   //
   // ADVANCED_PAUSE_FEATURE
   //
-  fil_change_settings_t fc_settings[EXTRUDERS];         // M603 T U L
+  #if EXTRUDERS
+    fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
+  #endif
 
   //
   // Tool-change settings
@@ -367,7 +369,7 @@ void MarlinSettings::postprocess() {
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
-  #else
+  #elif EXTRUDERS
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
@@ -759,7 +761,7 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(ui_preheat_hotend_temp);
 
-      #if HAS_LCD_MENU
+      #if HOTENDS && HAS_LCD_MENU
         const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                       (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
         const uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
@@ -1164,6 +1166,7 @@ void MarlinSettings::postprocess() {
     //
     // Advanced Pause filament load & unload lengths
     //
+    #if EXTRUDERS
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
         const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
@@ -1171,6 +1174,7 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
     }
+    #endif
 
     //
     // Multiple Extruders
@@ -1560,7 +1564,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(ui_preheat_hotend_temp);
 
-        #if HAS_LCD_MENU
+        #if HOTENDS && HAS_LCD_MENU
           int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
                   (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
           uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
@@ -1968,6 +1972,7 @@ void MarlinSettings::postprocess() {
       //
       // Advanced Pause filament load & unload lengths
       //
+      #if EXTRUDERS
       {
         #if DISABLED(ADVANCED_PAUSE_FEATURE)
           fil_change_settings_t fc_settings[EXTRUDERS];
@@ -1975,6 +1980,7 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(fc_settings);
         EEPROM_READ(fc_settings);
       }
+      #endif
 
       //
       // Tool-change settings
@@ -2410,7 +2416,7 @@ void MarlinSettings::reset() {
   // Preheat parameters
   //
 
-  #if HAS_LCD_MENU
+  #if HOTENDS && HAS_LCD_MENU
     ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
     ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
     ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
@@ -2956,7 +2962,7 @@ void MarlinSettings::reset() {
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
-    #if HAS_LCD_MENU
+    #if HOTENDS && HAS_LCD_MENU
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {

commit eed7c2fe2fe13dc6249b9a3e1a0d3d2644366069
Author: ManuelMcLure <manuel@mclure.org>
Date:   Sat Sep 7 18:29:38 2019 -0700

    Fix 'echo:' in TMC parameters M503 report (#15193)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 190bde400d..d122c6e129 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2585,17 +2585,18 @@ void MarlinSettings::reset() {
   #if HAS_TRINAMIC
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
-      void say_M569(const char * const etc=nullptr) {
+      void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
+        CONFIG_ECHO_START();
         SERIAL_ECHOPGM("  M569 S1");
         if (etc) {
           SERIAL_CHAR(' ');
           serialprintPGM(etc);
-          SERIAL_EOL();
         }
+        if (newLine) SERIAL_EOL();
       }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
-      inline void say_M913() { SERIAL_ECHOPGM("  M913"); }
+      inline void say_M913(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M913"); }
     #endif
     #if USE_SENSORLESS
       inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
@@ -3168,9 +3169,8 @@ void MarlinSettings::reset() {
        */
       #if ENABLED(HYBRID_THRESHOLD)
         CONFIG_ECHO_HEADING("Hybrid Threshold:");
-        CONFIG_ECHO_START();
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
-          say_M913();
+          say_M913(forReplay);
         #endif
         #if AXIS_HAS_STEALTHCHOP(X)
           SERIAL_ECHOPAIR(" X", stepperX.get_pwm_thrs());
@@ -3186,7 +3186,7 @@ void MarlinSettings::reset() {
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOPGM(" I1");
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
@@ -3203,32 +3203,32 @@ void MarlinSettings::reset() {
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          say_M913();
+          say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
         #endif
         SERIAL_EOL();
@@ -3239,8 +3239,8 @@ void MarlinSettings::reset() {
        */
       #if USE_SENSORLESS
         CONFIG_ECHO_HEADING("StallGuard threshold:");
-        CONFIG_ECHO_START();
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
+          CONFIG_ECHO_START();
           say_M914();
           #if X_SENSORLESS
             SERIAL_ECHOPAIR(" X", stepperX.homing_threshold());
@@ -3259,6 +3259,7 @@ void MarlinSettings::reset() {
         #define HAS_Z2_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
         #define HAS_Z3_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
         #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
+          CONFIG_ECHO_START();
           say_M914();
           SERIAL_ECHOPGM(" I1");
           #if HAS_X2_SENSORLESS
@@ -3274,6 +3275,7 @@ void MarlinSettings::reset() {
         #endif
 
         #if HAS_Z3_SENSORLESS
+          CONFIG_ECHO_START();
           say_M914();
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
         #endif
@@ -3285,7 +3287,6 @@ void MarlinSettings::reset() {
        */
       #if HAS_STEALTHCHOP
         CONFIG_ECHO_HEADING("Driver stepping mode:");
-        CONFIG_ECHO_START();
         #if AXIS_HAS_STEALTHCHOP(X)
           const bool chop_x = stepperX.get_stealthChop_status();
         #else
@@ -3302,11 +3303,13 @@ void MarlinSettings::reset() {
           constexpr bool chop_z = false;
         #endif
 
-        if (chop_x || chop_y || chop_z) say_M569();
-        if (chop_x) SERIAL_ECHOPGM(" X");
-        if (chop_y) SERIAL_ECHOPGM(" Y");
-        if (chop_z) SERIAL_ECHOPGM(" Z");
-        if (chop_x || chop_y || chop_z) SERIAL_EOL();
+        if (chop_x || chop_y || chop_z) {
+          say_M569(forReplay);
+          if (chop_x) SERIAL_ECHOPGM(" X");
+          if (chop_y) SERIAL_ECHOPGM(" Y");
+          if (chop_z) SERIAL_ECHOPGM(" Z");
+          SERIAL_EOL();
+        }
 
         #if AXIS_HAS_STEALTHCHOP(X2)
           const bool chop_x2 = stepperX2.get_stealthChop_status();
@@ -3324,33 +3327,35 @@ void MarlinSettings::reset() {
           constexpr bool chop_z2 = false;
         #endif
 
-        if (chop_x2 || chop_y2 || chop_z2) say_M569(PSTR("I1"));
-        if (chop_x2) SERIAL_ECHOPGM(" X");
-        if (chop_y2) SERIAL_ECHOPGM(" Y");
-        if (chop_z2) SERIAL_ECHOPGM(" Z");
-        if (chop_x2 || chop_y2 || chop_z2) SERIAL_EOL();
+        if (chop_x2 || chop_y2 || chop_z2) {
+          say_M569(forReplay, PSTR("I1"));
+          if (chop_x2) SERIAL_ECHOPGM(" X");
+          if (chop_y2) SERIAL_ECHOPGM(" Y");
+          if (chop_z2) SERIAL_ECHOPGM(" Z");
+          SERIAL_EOL();
+        }
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stealthChop_status()) { say_M569(PSTR("I2 Z")); }
+          if (stepperZ3.get_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stealthChop_status()) { say_M569(PSTR("T0 E")); }
+          if (stepperE0.get_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stealthChop_status()) { say_M569(PSTR("T1 E")); }
+          if (stepperE1.get_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stealthChop_status()) { say_M569(PSTR("T2 E")); }
+          if (stepperE2.get_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stealthChop_status()) { say_M569(PSTR("T3 E")); }
+          if (stepperE3.get_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stealthChop_status()) { say_M569(PSTR("T4 E")); }
+          if (stepperE4.get_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stealthChop_status()) { say_M569(PSTR("T5 E")); }
+          if (stepperE5.get_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
         #endif
 
       #endif // HAS_STEALTHCHOP

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2bcfdb6047..190bde400d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -112,7 +112,7 @@
 #endif
 
 #if HAS_TRINAMIC
-  #include "stepper_indirection.h"
+  #include "stepper/indirection.h"
   #include "../feature/tmc_util.h"
 #endif
 

commit 0ebaea94be98b7ae27f9e2daf34e59f65436bd26
Author: AlexandrZloy <49792082+AlexandrZloy@users.noreply.github.com>
Date:   Thu Aug 29 12:15:31 2019 +0700

    Add stallGuard threshold for X2 (#15042)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 15c0922692..2bcfdb6047 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V68"
+#define EEPROM_VERSION "V69"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -120,7 +120,7 @@
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
 typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z;                                         } tmc_sgt_t;
+typedef struct {  int16_t X, Y, Z, X2;                                     } tmc_sgt_t;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
@@ -283,7 +283,7 @@ typedef struct SettingsDataStruct {
   //
   tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
-  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z
+  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2
   tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
 
   //
@@ -1032,11 +1032,14 @@ void MarlinSettings::postprocess() {
     // TMC StallGuard threshold
     //
     {
-      tmc_sgt_t tmc_sgt = { 0, 0, 0 };
+      tmc_sgt_t tmc_sgt = { 0 };
       #if USE_SENSORLESS
         #if X_SENSORLESS
           tmc_sgt.X = stepperX.homing_threshold();
         #endif
+        #if X2_SENSORLESS
+          tmc_sgt.X2 = stepperX2.homing_threshold();
+        #endif
         #if Y_SENSORLESS
           tmc_sgt.Y = stepperY.homing_threshold();
         #endif
@@ -1820,10 +1823,13 @@ void MarlinSettings::postprocess() {
               #if AXIS_HAS_STALLGUARD(X)
                 stepperX.homing_threshold(tmc_sgt.X);
               #endif
-              #if AXIS_HAS_STALLGUARD(X2)
+              #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
                 stepperX2.homing_threshold(tmc_sgt.X);
               #endif
             #endif
+            #if X2_SENSORLESS
+              stepperX2.homing_threshold(tmc_sgt.X2);
+            #endif
             #ifdef Y_STALL_SENSITIVITY
               #if AXIS_HAS_STALLGUARD(Y)
                 stepperY.homing_threshold(tmc_sgt.Y);

commit e604f76703165027a22dc33c7875f4858e9f1c80
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu Aug 22 01:56:39 2019 +0200

    Enable contrast via LCD_CONTRAST_INIT (#15006)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index cc5b15b57c..15c0922692 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -828,8 +828,10 @@ void MarlinSettings::postprocess() {
       const int16_t lcd_contrast =
         #if HAS_LCD_CONTRAST
           ui.contrast
+        #elif defined(DEFAULT_LCD_CONTRAST)
+          DEFAULT_LCD_CONTRAST
         #else
-          32
+          127
         #endif
       ;
       EEPROM_WRITE(lcd_contrast);

commit cd09e35f9067bdc5caf43e10545fee18205ea88e
Author: Tim Moore <tim@youngmoores.com>
Date:   Sun Aug 18 19:17:00 2019 -0700

    Remove extra M503 "M412" report (#14985)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 161e360c21..cc5b15b57c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2798,12 +2798,6 @@ void MarlinSettings::reset() {
       }
     #endif
 
-    #if HAS_FILAMENT_SENSOR
-      CONFIG_ECHO_HEADING("Filament Runout Sensor:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M412 S", int(runout.enabled));
-    #endif
-
     /**
      * Bed Leveling
      */

commit 9c5086e6af1e31095fc691090969e97e4828f72b
Author: Eric Ptak <trouch@trouch.com>
Date:   Sun Aug 11 02:14:31 2019 +0200

    [STM32F1] Simpler Flash EEPROM (#14829)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index da3a52035d..161e360c21 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -447,36 +447,19 @@ void MarlinSettings::postprocess() {
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #define WORD_PADDED_EEPROM ENABLED(__STM32F1__, FLASH_EEPROM_EMULATION)
-
-  #if WORD_PADDED_EEPROM && ENABLED(DEBUG_EEPROM_READWRITE)
-    #define UPDATE_TEST_INDEX(VAR) (test_index += sizeof(VAR))
-  #else
-    #define UPDATE_TEST_INDEX(VAR) NOOP
-  #endif
-  #if WORD_PADDED_EEPROM
-    #define EEPROM_SKIP(VAR) do{ eeprom_index += sizeof(VAR) + (sizeof(VAR) & 1); UPDATE_TEST_INDEX(sizeof(VAR)); }while(0)
-  #else
-    #define EEPROM_SKIP(VAR) (eeprom_index += sizeof(VAR))
-  #endif
-
   #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
                                   int eeprom_index = EEPROM_OFFSET
   #define EEPROM_FINISH()         persistentStore.access_finish()
-  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              UPDATE_TEST_INDEX(VAR); }while(0)
-  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  UPDATE_TEST_INDEX(VAR); }while(0)
-  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               UPDATE_TEST_INDEX(VAR); }while(0)
+  #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
+  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
+  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)
+  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               }while(0)
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
-    #if WORD_PADDED_EEPROM
-      int test_index;
-    #else
-      #define test_index eeprom_index
-    #endif
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \
-        eeprom_error || test_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
+        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else

commit 92c35d14a47a7b333690989f7b749d6385185bd7
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Wed Aug 7 07:43:00 2019 +0200

    Non-fatal error from ps::access_start (#14845)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 70ae30bec4..da3a52035d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -450,7 +450,7 @@ void MarlinSettings::postprocess() {
   #define WORD_PADDED_EEPROM ENABLED(__STM32F1__, FLASH_EEPROM_EMULATION)
 
   #if WORD_PADDED_EEPROM && ENABLED(DEBUG_EEPROM_READWRITE)
-    #define UPDATE_TEST_INDEX(VAR) (text_index += sizeof(VAR))
+    #define UPDATE_TEST_INDEX(VAR) (test_index += sizeof(VAR))
   #else
     #define UPDATE_TEST_INDEX(VAR) NOOP
   #endif

commit fdbc7333761e1e49d5c7ce0be6b22d3d93bc5d4d
Author: Eric Ptak <trouch@trouch.com>
Date:   Wed Jul 31 00:43:45 2019 +0200

    Return 'false' on EEPROM connection fail (#14776)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 96f868b9e3..70ae30bec4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -460,7 +460,8 @@ void MarlinSettings::postprocess() {
     #define EEPROM_SKIP(VAR) (eeprom_index += sizeof(VAR))
   #endif
 
-  #define EEPROM_START()          int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
+  #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
+                                  int eeprom_index = EEPROM_OFFSET
   #define EEPROM_FINISH()         persistentStore.access_finish()
   #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              UPDATE_TEST_INDEX(VAR); }while(0)
   #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  UPDATE_TEST_INDEX(VAR); }while(0)
@@ -2111,7 +2112,7 @@ void MarlinSettings::postprocess() {
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
-    return true;
+    return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)

commit 0b154c2d71fc46c1f4347c4ba18999c747c9a029
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Jul 30 06:01:56 2019 -0400

    Enable runout sensor in EEPROM by default (#14771)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 06897605dc..96f868b9e3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -574,7 +574,7 @@ void MarlinSettings::postprocess() {
       #if HAS_FILAMENT_SENSOR
         const bool &runout_sensor_enabled = runout.enabled;
       #else
-        const bool runout_sensor_enabled = false;
+        const bool runout_sensor_enabled = true;
       #endif
       #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
         const float &runout_distance_mm = runout.runout_distance();

commit eefe3f595ae98ed2b32a9a60a5b27ed307993a7d
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Jul 28 21:47:20 2019 -0600

    New options: Bootscreen as Info, game Easter-egg (#13829)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8143b27994..06897605dc 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2028,8 +2028,7 @@ void MarlinSettings::postprocess() {
           const char extui_data[ExtUI::eeprom_data_size] = { 0 };
           _FIELD_TEST(extui_data);
           EEPROM_READ(extui_data);
-          if(!validating)
-            ExtUI::onLoadSettings(extui_data);
+          if (!validating) ExtUI::onLoadSettings(extui_data);
         }
       #endif
 

commit 97e9c95f4722de6e15899aeb4efa7359f0b34f82
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jul 28 05:44:05 2019 +0200

    Fix & clean up ExtUI (#14748)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8af5146eb3..8143b27994 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -98,10 +98,8 @@
   #include "../feature/runout.h"
 #endif
 
-#include "../lcd/extensible_ui/ui_api.h"
-
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
-extern float saved_extruder_advance_K[EXTRUDERS];
+  extern float saved_extruder_advance_K[EXTRUDERS];
 #endif
 
 #if EXTRUDERS > 1

commit 839255eed43a8c28fa27de44138dc85ec5d0de26
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 18:11:45 2019 -0600

    Fix for M504 changing filament runout value (#14661)
    
    Fixes #14476

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 33e00cf79b..8af5146eb3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1390,7 +1390,7 @@ void MarlinSettings::postprocess() {
         float runout_distance_mm;
         EEPROM_READ(runout_distance_mm);
         #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
-          runout.set_runout_distance(runout_distance_mm);
+          if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
 

commit eaf1c0954eff9a8a6473a8853a47478a4a6cb73b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 14 08:56:29 2019 -0500

    Update some precompiler tests

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dd3565de14..33e00cf79b 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2252,7 +2252,7 @@ void MarlinSettings::reset() {
     planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
     planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
     planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
-    #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+    #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
       planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
     #endif
   #endif
@@ -2768,7 +2768,7 @@ void MarlinSettings::reset() {
       #endif
       #if HAS_CLASSIC_JERK
         SERIAL_ECHOPGM(" X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
-        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+        #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
           SERIAL_ECHOPGM(" E<max_e_jerk>");
         #endif
       #endif
@@ -2786,7 +2786,7 @@ void MarlinSettings::reset() {
         , " X", LINEAR_UNIT(planner.max_jerk[X_AXIS])
         , " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS])
         , " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS])
-        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+        #if !BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
           , " E", LINEAR_UNIT(planner.max_jerk[E_AXIS])
         #endif
       #endif

commit ce02c6cee2bf17590d929d078d71cc37f67e00d1
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jul 14 12:40:58 2019 -0400

    Variable tool change purge (#14618)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 7ec76ae3d1..dd3565de14 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V67"
+#define EEPROM_VERSION "V68"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -2290,6 +2290,7 @@ void MarlinSettings::reset() {
   #if EXTRUDERS > 1
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       toolchange_settings.swap_length = TOOLCHANGE_FIL_SWAP_LENGTH;
+      toolchange_settings.extra_prime = TOOLCHANGE_FIL_EXTRA_PRIME;
       toolchange_settings.prime_speed = TOOLCHANGE_FIL_SWAP_PRIME_SPEED;
       toolchange_settings.retract_speed = TOOLCHANGE_FIL_SWAP_RETRACT_SPEED;
     #endif

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d396ea3986..7ec76ae3d1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -126,7 +126,7 @@ typedef struct {  int16_t X, Y, Z;                                         } tmc
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
-#define ALIM(I,ARR) MIN(I, COUNT(ARR) - 1)
+#define ALIM(I,ARR) _MIN(I, COUNT(ARR) - 1)
 
 /**
  * Current EEPROM Layout

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f8d2e565ad..d396ea3986 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 8c55bd5451e7afa57e936ae1e2483086253f8a3e
Author: oechslein <oechslein@gmx.de>
Date:   Wed Jun 26 10:33:07 2019 +0200

    Update "StallGuard threshold" heading (#14395)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index fd0ea2f5f0..f8d2e565ad 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -3254,7 +3254,7 @@ void MarlinSettings::reset() {
        * TMC Sensorless homing thresholds
        */
       #if USE_SENSORLESS
-        CONFIG_ECHO_HEADING("TMC2130 StallGuard threshold:");
+        CONFIG_ECHO_HEADING("StallGuard threshold:");
         CONFIG_ECHO_START();
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           say_M914();

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index df9f62fce8..fd0ea2f5f0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1051,13 +1051,13 @@ void MarlinSettings::postprocess() {
       tmc_sgt_t tmc_sgt = { 0, 0, 0 };
       #if USE_SENSORLESS
         #if X_SENSORLESS
-          tmc_sgt.X = stepperX.sgt();
+          tmc_sgt.X = stepperX.homing_threshold();
         #endif
         #if Y_SENSORLESS
-          tmc_sgt.Y = stepperY.sgt();
+          tmc_sgt.Y = stepperY.homing_threshold();
         #endif
         #if Z_SENSORLESS
-          tmc_sgt.Z = stepperZ.sgt();
+          tmc_sgt.Z = stepperZ.homing_threshold();
         #endif
       #endif
       EEPROM_WRITE(tmc_sgt);
@@ -1834,29 +1834,29 @@ void MarlinSettings::postprocess() {
           if (!validating) {
             #ifdef X_STALL_SENSITIVITY
               #if AXIS_HAS_STALLGUARD(X)
-                stepperX.sgt(tmc_sgt.X);
+                stepperX.homing_threshold(tmc_sgt.X);
               #endif
               #if AXIS_HAS_STALLGUARD(X2)
-                stepperX2.sgt(tmc_sgt.X);
+                stepperX2.homing_threshold(tmc_sgt.X);
               #endif
             #endif
             #ifdef Y_STALL_SENSITIVITY
               #if AXIS_HAS_STALLGUARD(Y)
-                stepperY.sgt(tmc_sgt.Y);
+                stepperY.homing_threshold(tmc_sgt.Y);
               #endif
               #if AXIS_HAS_STALLGUARD(Y2)
-                stepperY2.sgt(tmc_sgt.Y);
+                stepperY2.homing_threshold(tmc_sgt.Y);
               #endif
             #endif
             #ifdef Z_STALL_SENSITIVITY
               #if AXIS_HAS_STALLGUARD(Z)
-                stepperZ.sgt(tmc_sgt.Z);
+                stepperZ.homing_threshold(tmc_sgt.Z);
               #endif
               #if AXIS_HAS_STALLGUARD(Z2)
-                stepperZ2.sgt(tmc_sgt.Z);
+                stepperZ2.homing_threshold(tmc_sgt.Z);
               #endif
               #if AXIS_HAS_STALLGUARD(Z3)
-                stepperZ3.sgt(tmc_sgt.Z);
+                stepperZ3.homing_threshold(tmc_sgt.Z);
               #endif
             #endif
           }
@@ -3259,13 +3259,13 @@ void MarlinSettings::reset() {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           say_M914();
           #if X_SENSORLESS
-            SERIAL_ECHOPAIR(" X", stepperX.sgt());
+            SERIAL_ECHOPAIR(" X", stepperX.homing_threshold());
           #endif
           #if Y_SENSORLESS
-            SERIAL_ECHOPAIR(" Y", stepperY.sgt());
+            SERIAL_ECHOPAIR(" Y", stepperY.homing_threshold());
           #endif
           #if Z_SENSORLESS
-            SERIAL_ECHOPAIR(" Z", stepperZ.sgt());
+            SERIAL_ECHOPAIR(" Z", stepperZ.homing_threshold());
           #endif
           SERIAL_EOL();
         #endif
@@ -3278,20 +3278,20 @@ void MarlinSettings::reset() {
           say_M914();
           SERIAL_ECHOPGM(" I1");
           #if HAS_X2_SENSORLESS
-            SERIAL_ECHOPAIR(" X", stepperX2.sgt());
+            SERIAL_ECHOPAIR(" X", stepperX2.homing_threshold());
           #endif
           #if HAS_Y2_SENSORLESS
-            SERIAL_ECHOPAIR(" Y", stepperY2.sgt());
+            SERIAL_ECHOPAIR(" Y", stepperY2.homing_threshold());
           #endif
           #if HAS_Z2_SENSORLESS
-            SERIAL_ECHOPAIR(" Z", stepperZ2.sgt());
+            SERIAL_ECHOPAIR(" Z", stepperZ2.homing_threshold());
           #endif
           SERIAL_EOL();
         #endif
 
         #if HAS_Z3_SENSORLESS
           say_M914();
-          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.sgt());
+          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
         #endif
 
       #endif // USE_SENSORLESS

commit 49e83dd7c81cffef7462a0a53a70a125562de83a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 25 22:56:47 2019 -0400

    BLTouch V3.1 changes (#14104)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d2e8418fe2..df9f62fce8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V66"
+#define EEPROM_VERSION "V67"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -109,6 +109,10 @@ extern float saved_extruder_advance_K[EXTRUDERS];
   void M217_report(const bool eeprom);
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
 #if HAS_TRINAMIC
   #include "stepper_indirection.h"
   #include "../feature/tmc_util.h"
@@ -206,6 +210,11 @@ typedef struct SettingsDataStruct {
   //
   uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
 
+  //
+  // BLTOUCH
+  //
+  bool bltouch_last_written_mode;
+
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
   //
@@ -700,6 +709,19 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(servo_angles);
     }
 
+    //
+    // BLTOUCH
+    //
+    {
+      _FIELD_TEST(bltouch_last_written_mode);
+      #if ENABLED(BLTOUCH)
+        const bool &bltouch_last_written_mode = bltouch.last_written_mode;
+      #else
+        constexpr bool bltouch_last_written_mode = false;
+      #endif
+      EEPROM_WRITE(bltouch_last_written_mode);
+    }
+
     //
     // DELTA Geometry or Dual Endstops offsets
     //
@@ -1488,6 +1510,19 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(servo_angles_arr);
       }
 
+      //
+      // BLTOUCH
+      //
+      {
+        _FIELD_TEST(bltouch_last_written_mode);
+        #if ENABLED(BLTOUCH)
+          bool &bltouch_last_written_mode = bltouch.last_written_mode;
+        #else
+          bool bltouch_last_written_mode;
+        #endif
+        EEPROM_READ(bltouch_last_written_mode);
+      }
+
       //
       // DELTA Geometry or Dual Endstops offsets
       //
@@ -2313,6 +2348,13 @@ void MarlinSettings::reset() {
     COPY(servo_angles, base_servo_angles);
   #endif
 
+  //
+  // BLTOUCH
+  //
+  //#if ENABLED(BLTOUCH)
+  //  bltouch.last_written_mode;
+  //#endif
+
   //
   // Endstop Adjustments
   //

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1da47e6682..d2e8418fe2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -112,7 +112,6 @@ extern float saved_extruder_advance_K[EXTRUDERS];
 #if HAS_TRINAMIC
   #include "stepper_indirection.h"
   #include "../feature/tmc_util.h"
-  #define TMC_GET_PWMTHRS(A,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.settings.axis_steps_per_mm[_AXIS(A)])
 #endif
 
 #pragma pack(push, 1) // No padding between variables
@@ -962,49 +961,49 @@ void MarlinSettings::postprocess() {
       #if ENABLED(HYBRID_THRESHOLD)
        tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
         #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_hybrid_threshold.X = TMC_GET_PWMTHRS(X, X);
+          tmc_hybrid_threshold.X = stepperX.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_hybrid_threshold.Y = TMC_GET_PWMTHRS(Y, Y);
+          tmc_hybrid_threshold.Y = stepperY.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_hybrid_threshold.Z = TMC_GET_PWMTHRS(Z, Z);
+          tmc_hybrid_threshold.Z = stepperZ.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_hybrid_threshold.X2 = TMC_GET_PWMTHRS(X, X2);
+          tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_hybrid_threshold.Y2 = TMC_GET_PWMTHRS(Y, Y2);
+          tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_hybrid_threshold.Z2 = TMC_GET_PWMTHRS(Z, Z2);
+          tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_hybrid_threshold.Z3 = TMC_GET_PWMTHRS(Z, Z3);
+          tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
         #endif
         #if MAX_EXTRUDERS
           #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_hybrid_threshold.E0 = TMC_GET_PWMTHRS(E, E0);
+            tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
           #endif
           #if MAX_EXTRUDERS > 1
             #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_hybrid_threshold.E1 = TMC_GET_PWMTHRS(E, E1);
+              tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
             #endif
             #if MAX_EXTRUDERS > 2
               #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_hybrid_threshold.E2 = TMC_GET_PWMTHRS(E, E2);
+                tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
               #endif
               #if MAX_EXTRUDERS > 3
                 #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_hybrid_threshold.E3 = TMC_GET_PWMTHRS(E, E3);
+                  tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
                 #endif
                 #if MAX_EXTRUDERS > 4
                   #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_hybrid_threshold.E4 = TMC_GET_PWMTHRS(E, E4);
+                    tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
                   #endif
                   #if MAX_EXTRUDERS > 5
                     #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_hybrid_threshold.E5 = TMC_GET_PWMTHRS(E, E5);
+                      tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
                     #endif
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
@@ -1742,46 +1741,45 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(tmc_hybrid_threshold);
 
         #if ENABLED(HYBRID_THRESHOLD)
-          #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold.Q, planner.settings.axis_steps_per_mm[_AXIS(A)])
           if (!validating) {
             #if AXIS_HAS_STEALTHCHOP(X)
-              TMC_SET_PWMTHRS(X, X);
+              stepperX.set_pwm_thrs(tmc_hybrid_threshold.X);
             #endif
             #if AXIS_HAS_STEALTHCHOP(Y)
-              TMC_SET_PWMTHRS(Y, Y);
+              stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y);
             #endif
             #if AXIS_HAS_STEALTHCHOP(Z)
-              TMC_SET_PWMTHRS(Z, Z);
+              stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z);
             #endif
             #if AXIS_HAS_STEALTHCHOP(X2)
-              TMC_SET_PWMTHRS(X, X2);
+              stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2);
             #endif
             #if AXIS_HAS_STEALTHCHOP(Y2)
-              TMC_SET_PWMTHRS(Y, Y2);
+              stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2);
             #endif
             #if AXIS_HAS_STEALTHCHOP(Z2)
-              TMC_SET_PWMTHRS(Z, Z2);
+              stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2);
             #endif
             #if AXIS_HAS_STEALTHCHOP(Z3)
-              TMC_SET_PWMTHRS(Z, Z3);
+              stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E0)
-              TMC_SET_PWMTHRS(E, E0);
+              stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E1)
-              TMC_SET_PWMTHRS(E, E1);
+              stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E2)
-              TMC_SET_PWMTHRS(E, E2);
+              stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E3)
-              TMC_SET_PWMTHRS(E, E3);
+              stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E4)
-              TMC_SET_PWMTHRS(E, E4);
+              stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4);
             #endif
             #if AXIS_HAS_STEALTHCHOP(E5)
-              TMC_SET_PWMTHRS(E, E5);
+              stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5);
             #endif
           }
         #endif
@@ -3149,13 +3147,13 @@ void MarlinSettings::reset() {
           say_M913();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X)
-          SERIAL_ECHOPAIR(" X", TMC_GET_PWMTHRS(X, X));
+          SERIAL_ECHOPAIR(" X", stepperX.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          SERIAL_ECHOPAIR(" Y", TMC_GET_PWMTHRS(Y, Y));
+          SERIAL_ECHOPAIR(" Y", stepperY.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          SERIAL_ECHOPAIR(" Z", TMC_GET_PWMTHRS(Z, Z));
+          SERIAL_ECHOPAIR(" Z", stepperZ.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           SERIAL_EOL();
@@ -3166,13 +3164,13 @@ void MarlinSettings::reset() {
           SERIAL_ECHOPGM(" I1");
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          SERIAL_ECHOPAIR(" X", TMC_GET_PWMTHRS(X, X2));
+          SERIAL_ECHOPAIR(" X", stepperX2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          SERIAL_ECHOPAIR(" Y", TMC_GET_PWMTHRS(Y, Y2));
+          SERIAL_ECHOPAIR(" Y", stepperY2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          SERIAL_ECHOPAIR(" Z", TMC_GET_PWMTHRS(Z, Z2));
+          SERIAL_ECHOPAIR(" Z", stepperZ2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
           SERIAL_EOL();
@@ -3180,32 +3178,32 @@ void MarlinSettings::reset() {
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
           say_M913();
-          SERIAL_ECHOLNPAIR(" I2 Z", TMC_GET_PWMTHRS(Z, Z3));
+          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T0 E", TMC_GET_PWMTHRS(E, E0));
+          SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T1 E", TMC_GET_PWMTHRS(E, E1));
+          SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T2 E", TMC_GET_PWMTHRS(E, E2));
+          SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T3 E", TMC_GET_PWMTHRS(E, E3));
+          SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T4 E", TMC_GET_PWMTHRS(E, E4));
+          SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
           say_M913();
-          SERIAL_ECHOLNPAIR(" T5 E", TMC_GET_PWMTHRS(E, E5));
+          SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
         #endif
         SERIAL_EOL();
       #endif // HYBRID_THRESHOLD

commit aeec9ef76be19640dc0ca70c26fffadc445eba11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 20 21:34:08 2019 -0500

    Update backlash code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 50d5214ff2..1da47e6682 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1177,17 +1177,20 @@ void MarlinSettings::postprocess() {
     // Backlash Compensation
     //
     {
+      #ifdef BACKLASH_DISTANCE_MM
+        const float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+      #else
+        const float backlash_distance_mm[XYZ] = { 0 };
+      #endif
       #if ENABLED(BACKLASH_COMPENSATION)
-        const float   (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
-        const uint8_t &backlash_correction         = backlash.correction;
+        const uint8_t &backlash_correction = backlash.correction;
       #else
-        const float    backlash_distance_mm[XYZ]   = { 0 };
-        const uint8_t  backlash_correction         = 0;
+        const uint8_t backlash_correction = 0;
       #endif
       #ifdef BACKLASH_SMOOTHING_MM
-        const float   &backlash_smoothing_mm       = backlash.smoothing_mm;
+        const float &backlash_smoothing_mm = backlash.smoothing_mm;
       #else
-        const float    backlash_smoothing_mm       = 3;
+        const float backlash_smoothing_mm = 3;
       #endif
       _FIELD_TEST(backlash_distance_mm);
       EEPROM_WRITE(backlash_distance_mm[X_AXIS]);
@@ -1962,17 +1965,20 @@ void MarlinSettings::postprocess() {
       // Backlash Compensation
       //
       {
+        #ifdef BACKLASH_DISTANCE_MM
+          float (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+        #else
+          float backlash_distance_mm[XYZ];
+        #endif
         #if ENABLED(BACKLASH_COMPENSATION)
-          float   (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
-          uint8_t &backlash_correction         = backlash.correction;
+          uint8_t &backlash_correction = backlash.correction;
         #else
-          float   backlash_distance_mm[XYZ];
           uint8_t backlash_correction;
         #endif
         #ifdef BACKLASH_SMOOTHING_MM
           float &backlash_smoothing_mm = backlash.smoothing_mm;
         #else
-          float  backlash_smoothing_mm;
+          float backlash_smoothing_mm;
         #endif
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm[X_AXIS]);

commit 5108e4b6aaeb0b5143b7b6bf09103e6cdd3be491
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 11 17:54:03 2019 -0400

    Cleaner EEPROM auto init (#13975)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 7742710bd6..50d5214ff2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2071,6 +2071,10 @@ void MarlinSettings::postprocess() {
       return success;
     }
     reset();
+    #if ENABLED(EEPROM_AUTO_INIT)
+      (void)save();
+      SERIAL_ECHO_MSG("EEPROM Initialized");
+    #endif
     return true;
   }
 

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 128c847097..7742710bd6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2132,7 +2132,7 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
-    void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=NULL*/) {
+    void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=nullptr*/) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
 
@@ -2545,7 +2545,7 @@ void MarlinSettings::reset() {
   #if HAS_TRINAMIC
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
-      void say_M569(const char * const etc=NULL) {
+      void say_M569(const char * const etc=nullptr) {
         SERIAL_ECHOPGM("  M569 S1");
         if (etc) {
           SERIAL_CHAR(' ');

commit 5dcb25664f829be801e20ab6032e782c1c65b4ba
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 17:30:31 2019 -0400

    Option to Auto-Initialize EEPROM (#13935)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 11fbbd289b..128c847097 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -401,9 +401,8 @@ void MarlinSettings::postprocess() {
     report_current_position();
 }
 
-#if ENABLED(PRINTCOUNTER) && ENABLED(EEPROM_SETTINGS)
+#if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
-
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),

commit 23a8707ef1969be3db28251ccee2287e1ea7b9e4
Author: doggyfan <49303635+doggyfan@users.noreply.github.com>
Date:   Tue May 7 00:51:06 2019 +0100

    Configurable Thermistor (#13888)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 63d95e6b59..11fbbd289b 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -243,6 +243,13 @@ typedef struct SettingsDataStruct {
   //
   PID_t bedPID;                                         // M304 PID / M303 E-1 U
 
+  //
+  // User-defined Thermistors
+  //
+  #if HAS_USER_THERMISTORS
+    user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
+  #endif
+
   //
   // HAS_LCD_CONTRAST
   //
@@ -800,6 +807,16 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
+    //
+    // User-defined Thermistors
+    //
+    #if HAS_USER_THERMISTORS
+    {
+      _FIELD_TEST(user_thermistor);
+      EEPROM_WRITE(thermalManager.user_thermistor);
+    }
+    #endif
+
     //
     // LCD Contrast
     //
@@ -1579,6 +1596,16 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      //
+      // User-defined Thermistors
+      //
+      #if HAS_USER_THERMISTORS
+      {
+        _FIELD_TEST(user_thermistor);
+        EEPROM_READ(thermalManager.user_thermistor);
+      }
+      #endif
+
       //
       // LCD Contrast
       //
@@ -2386,6 +2413,14 @@ void MarlinSettings::reset() {
     thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
   #endif
 
+  //
+  // User-Defined Thermistors
+  //
+
+  #if HAS_USER_THERMISTORS
+    thermalManager.reset_user_thermistors();
+  #endif
+
   //
   // LCD Contrast
   //
@@ -2951,6 +2986,12 @@ void MarlinSettings::reset() {
 
     #endif // PIDTEMP || PIDTEMPBED
 
+    #if HAS_USER_THERMISTORS
+      CONFIG_ECHO_HEADING("User thermistors:");
+      for (uint8_t i = 0; i < USER_THERMISTORS; i++)
+        thermalManager.log_user_thermistor(i, true);
+    #endif
+
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
       CONFIG_ECHO_START();

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    …And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ceab713813..63d95e6b59 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V65"
+#define EEPROM_VERSION "V66"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -90,10 +90,16 @@
 
 #include "../feature/pause.h"
 
+#if ENABLED(BACKLASH_COMPENSATION)
+  #include "../feature/backlash.h"
+#endif
+
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
 #endif
 
+#include "../lcd/extensible_ui/ui_api.h"
+
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
 extern float saved_extruder_advance_K[EXTRUDERS];
 #endif
@@ -149,6 +155,7 @@ typedef struct SettingsDataStruct {
   // FILAMENT_RUNOUT_SENSOR
   //
   bool runout_sensor_enabled;                           // M412 S
+  float runout_distance_mm;                             // M412 D
 
   //
   // ENABLE_LEVELING_FADE_HEIGHT
@@ -298,6 +305,21 @@ typedef struct SettingsDataStruct {
     toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
+  //
+  // BACKLASH_COMPENSATION
+  //
+  float backlash_distance_mm[XYZ];                      // M425 X Y Z
+  uint8_t backlash_correction;                          // M425 F
+  float backlash_smoothing_mm;                          // M425 S
+
+  //
+  // EXTENSIBLE_UI
+  //
+  #if ENABLED(EXTENSIBLE_UI)
+    // This is a significant hardware change; don't reserve space when not present
+    uint8_t extui_data[ExtUI::eeprom_data_size];
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= E2END + 1, "EEPROM too small to contain SettingsData!");
@@ -372,6 +394,16 @@ void MarlinSettings::postprocess() {
     report_current_position();
 }
 
+#if ENABLED(PRINTCOUNTER) && ENABLED(EEPROM_SETTINGS)
+  #include "printcounter.h"
+
+  static_assert(
+    !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
+    !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
+    "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
+  );
+#endif
+
 #if ENABLED(SD_FIRMWARE_UPDATE)
 
   #if ENABLED(EEPROM_SETTINGS)
@@ -528,11 +560,18 @@ void MarlinSettings::postprocess() {
     //
     {
       #if HAS_FILAMENT_SENSOR
-        EEPROM_WRITE(runout.enabled);
+        const bool &runout_sensor_enabled = runout.enabled;
       #else
-        const bool runout_sensor_enabled = true;
-        EEPROM_WRITE(runout_sensor_enabled);
+        const bool runout_sensor_enabled = false;
       #endif
+      #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
+        const float &runout_distance_mm = runout.runout_distance();
+      #else
+        const float runout_distance_mm = 0;
+      #endif
+      _FIELD_TEST(runout_sensor_enabled);
+      EEPROM_WRITE(runout_sensor_enabled);
+      EEPROM_WRITE(runout_distance_mm);
     }
 
     //
@@ -1118,6 +1157,42 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(toolchange_settings);
     #endif
 
+    //
+    // Backlash Compensation
+    //
+    {
+      #if ENABLED(BACKLASH_COMPENSATION)
+        const float   (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+        const uint8_t &backlash_correction         = backlash.correction;
+      #else
+        const float    backlash_distance_mm[XYZ]   = { 0 };
+        const uint8_t  backlash_correction         = 0;
+      #endif
+      #ifdef BACKLASH_SMOOTHING_MM
+        const float   &backlash_smoothing_mm       = backlash.smoothing_mm;
+      #else
+        const float    backlash_smoothing_mm       = 3;
+      #endif
+      _FIELD_TEST(backlash_distance_mm);
+      EEPROM_WRITE(backlash_distance_mm[X_AXIS]);
+      EEPROM_WRITE(backlash_distance_mm[Y_AXIS]);
+      EEPROM_WRITE(backlash_distance_mm[Z_AXIS]);
+      EEPROM_WRITE(backlash_correction);
+      EEPROM_WRITE(backlash_smoothing_mm);
+    }
+
+    //
+    // Extensible UI User Data
+    //
+    #if ENABLED(EXTENSIBLE_UI)
+      {
+        char extui_data[ExtUI::eeprom_data_size] = { 0 };
+        ExtUI::onStoreSettings(extui_data);
+        _FIELD_TEST(extui_data);
+        EEPROM_WRITE(extui_data);
+      }
+    #endif
+
     //
     // Validate CRC and Data Size
     //
@@ -1148,7 +1223,7 @@ void MarlinSettings::postprocess() {
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
-      if (!eeprom_error) ExtUI::onStoreSettings();
+      ExtUI::onConfigurationStoreWritten(!eeprom_error);
     #endif
 
     return !eeprom_error;
@@ -1264,12 +1339,18 @@ void MarlinSettings::postprocess() {
       // Filament Runout Sensor
       //
       {
-        _FIELD_TEST(runout_sensor_enabled);
         #if HAS_FILAMENT_SENSOR
-          EEPROM_READ(runout.enabled);
+          bool &runout_sensor_enabled = runout.enabled;
         #else
           bool runout_sensor_enabled;
-          EEPROM_READ(runout_sensor_enabled);
+        #endif
+        _FIELD_TEST(runout_sensor_enabled);
+        EEPROM_READ(runout_sensor_enabled);
+
+        float runout_distance_mm;
+        EEPROM_READ(runout_distance_mm);
+        #if HAS_FILAMENT_SENSOR && defined(FILAMENT_RUNOUT_DISTANCE_MM)
+          runout.set_runout_distance(runout_distance_mm);
         #endif
       }
 
@@ -1851,6 +1932,44 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(toolchange_settings);
       #endif
 
+      //
+      // Backlash Compensation
+      //
+      {
+        #if ENABLED(BACKLASH_COMPENSATION)
+          float   (&backlash_distance_mm)[XYZ] = backlash.distance_mm;
+          uint8_t &backlash_correction         = backlash.correction;
+        #else
+          float   backlash_distance_mm[XYZ];
+          uint8_t backlash_correction;
+        #endif
+        #ifdef BACKLASH_SMOOTHING_MM
+          float &backlash_smoothing_mm = backlash.smoothing_mm;
+        #else
+          float  backlash_smoothing_mm;
+        #endif
+        _FIELD_TEST(backlash_distance_mm);
+        EEPROM_READ(backlash_distance_mm[X_AXIS]);
+        EEPROM_READ(backlash_distance_mm[Y_AXIS]);
+        EEPROM_READ(backlash_distance_mm[Z_AXIS]);
+        EEPROM_READ(backlash_correction);
+        EEPROM_READ(backlash_smoothing_mm);
+      }
+
+      //
+      // Extensible UI User Data
+      //
+      #if ENABLED(EXTENSIBLE_UI)
+        // This is a significant hardware change; don't reserve EEPROM space when not present
+        {
+          const char extui_data[ExtUI::eeprom_data_size] = { 0 };
+          _FIELD_TEST(extui_data);
+          EEPROM_READ(extui_data);
+          if(!validating)
+            ExtUI::onLoadSettings(extui_data);
+        }
+      #endif
+
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
@@ -1921,7 +2040,7 @@ void MarlinSettings::postprocess() {
     if (validate()) {
       const bool success = _load();
       #if ENABLED(EXTENSIBLE_UI)
-        if (success) ExtUI::onLoadSettings();
+        ExtUI::onConfigurationStoreRead(success);
       #endif
       return success;
     }
@@ -2090,6 +2209,9 @@ void MarlinSettings::reset() {
   #if HAS_FILAMENT_SENSOR
     runout.enabled = true;
     runout.reset();
+    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
+      runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM);
+    #endif
   #endif
 
   //
@@ -2108,6 +2230,23 @@ void MarlinSettings::reset() {
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
 
+  #if ENABLED(BACKLASH_GCODE)
+    backlash.correction = (BACKLASH_CORRECTION) * 255;
+    #ifdef BACKLASH_DISTANCE_MM
+      constexpr float tmp[XYZ] = BACKLASH_DISTANCE_MM;
+      backlash.distance_mm[X_AXIS] = tmp[X_AXIS];
+      backlash.distance_mm[Y_AXIS] = tmp[Y_AXIS];
+      backlash.distance_mm[Z_AXIS] = tmp[Z_AXIS];
+    #endif
+    #ifdef BACKLASH_SMOOTHING_MM
+      backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
+    #endif
+  #endif
+
+  #if ENABLED(EXTENSIBLE_UI)
+    ExtUI::onFactoryReset();
+  #endif
+
   //
   // Magnetic Parking Extruder
   //
@@ -3200,6 +3339,31 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       M217_report(true);
     #endif
+
+    #if ENABLED(BACKLASH_GCODE)
+      CONFIG_ECHO_HEADING("Backlash compensation:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR(
+        "  M425 F", backlash.get_correction(),
+        " X", LINEAR_UNIT(backlash.distance_mm[X_AXIS]),
+        " Y", LINEAR_UNIT(backlash.distance_mm[Y_AXIS]),
+        " Z", LINEAR_UNIT(backlash.distance_mm[Z_AXIS])
+        #ifdef BACKLASH_SMOOTHING_MM
+          , " S", LINEAR_UNIT(backlash.smoothing_mm)
+        #endif
+      );
+    #endif
+
+    #if HAS_FILAMENT_SENSOR
+      CONFIG_ECHO_HEADING("Filament runout sensor:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR(
+        "  M412 S", int(runout.enabled)
+        #ifdef FILAMENT_RUNOUT_DISTANCE_MM
+          , " D", LINEAR_UNIT(runout.runout_distance())
+        #endif
+      );
+    #endif
   }
 
 #endif // !DISABLE_M503

commit e5438a9a034f2a9ae12c0e2f4b04c1d4aee1fe33
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu May 2 07:47:26 2019 +0200

    settings: store runout sensor on/off (#13876)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a766d91b6e..ceab713813 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V64"
+#define EEPROM_VERSION "V65"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -90,6 +90,10 @@
 
 #include "../feature/pause.h"
 
+#if HAS_FILAMENT_SENSOR
+  #include "../feature/runout.h"
+#endif
+
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
 extern float saved_extruder_advance_K[EXTRUDERS];
 #endif
@@ -141,6 +145,11 @@ typedef struct SettingsDataStruct {
     float hotend_offset[XYZ][HOTENDS - 1];              // M218 XYZ
   #endif
 
+  //
+  // FILAMENT_RUNOUT_SENSOR
+  //
+  bool runout_sensor_enabled;                           // M412 S
+
   //
   // ENABLE_LEVELING_FADE_HEIGHT
   //
@@ -291,6 +300,8 @@ typedef struct SettingsDataStruct {
 
 } SettingsData;
 
+//static_assert(sizeof(SettingsData) <= E2END + 1, "EEPROM too small to contain SettingsData!");
+
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
@@ -512,6 +523,18 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
+    //
+    // Filament Runout Sensor
+    //
+    {
+      #if HAS_FILAMENT_SENSOR
+        EEPROM_WRITE(runout.enabled);
+      #else
+        const bool runout_sensor_enabled = true;
+        EEPROM_WRITE(runout_sensor_enabled);
+      #endif
+    }
+
     //
     // Global Leveling
     //
@@ -1237,6 +1260,19 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      //
+      // Filament Runout Sensor
+      //
+      {
+        _FIELD_TEST(runout_sensor_enabled);
+        #if HAS_FILAMENT_SENSOR
+          EEPROM_READ(runout.enabled);
+        #else
+          bool runout_sensor_enabled;
+          EEPROM_READ(runout_sensor_enabled);
+        #endif
+      }
+
       //
       // Global Leveling
       //
@@ -2047,6 +2083,19 @@ void MarlinSettings::reset() {
     reset_hotend_offsets();
   #endif
 
+  //
+  // Filament Runout Sensor
+  //
+
+  #if HAS_FILAMENT_SENSOR
+    runout.enabled = true;
+    runout.reset();
+  #endif
+
+  //
+  // Tool-change Settings
+  //
+
   #if EXTRUDERS > 1
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       toolchange_settings.swap_length = TOOLCHANGE_FIL_SWAP_LENGTH;
@@ -2059,6 +2108,10 @@ void MarlinSettings::reset() {
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
 
+  //
+  // Magnetic Parking Extruder
+  //
+
   #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
     mpe_settings_init();
   #endif
@@ -2540,6 +2593,12 @@ void MarlinSettings::reset() {
       }
     #endif
 
+    #if HAS_FILAMENT_SENSOR
+      CONFIG_ECHO_HEADING("Filament Runout Sensor:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR("  M412 S", int(runout.enabled));
+    #endif
+
     /**
      * Bed Leveling
      */

commit 5051909c3c43ae42c14765d0adce4405b8e9a423
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 10:13:44 2019 -0500

    Update do_select_screen for general use (#13800)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0552f555a5..a766d91b6e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -64,6 +64,10 @@
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extensible_ui/ui_api.h"
+#endif
+
 #if HAS_SERVOS
   #include "servo.h"
 #endif
@@ -1120,6 +1124,10 @@ void MarlinSettings::postprocess() {
         store_mesh(ubl.storage_slot);
     #endif
 
+    #if ENABLED(EXTENSIBLE_UI)
+      if (!eeprom_error) ExtUI::onStoreSettings();
+    #endif
+
     return !eeprom_error;
   }
 
@@ -1874,7 +1882,13 @@ void MarlinSettings::postprocess() {
   }
 
   bool MarlinSettings::load() {
-    if (validate()) return _load();
+    if (validate()) {
+      const bool success = _load();
+      #if ENABLED(EXTENSIBLE_UI)
+        if (success) ExtUI::onLoadSettings();
+      #endif
+      return success;
+    }
     reset();
     return true;
   }
@@ -2290,6 +2304,10 @@ void MarlinSettings::reset() {
 
   DEBUG_ECHO_START();
   DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
+
+  #if ENABLED(EXTENSIBLE_UI)
+    ExtUI::onFactoryReset();
+  #endif
 }
 
 #if DISABLED(DISABLE_M503)

commit fe346cd4d112392281d1cad6f4f2ef32f7b49b8a
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Mar 26 10:12:22 2019 +0100

    Fix DEBUG_EEPROM_READWRITE compile error (#13492)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 63af8a1092..0552f555a5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -412,7 +412,7 @@ void MarlinSettings::postprocess() {
     #if WORD_PADDED_EEPROM
       int test_index;
     #else
-      int &test_index = eeprom_index;
+      #define test_index eeprom_index
     #endif
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \

commit e3ab54753b236fff303b65f07e2369eb28c9fae7
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Tue Mar 26 09:02:27 2019 +0000

    Add extra Linear Advance factors (#13490)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 833d944447..63af8a1092 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -86,6 +86,10 @@
 
 #include "../feature/pause.h"
 
+#if ENABLED(EXTRA_LIN_ADVANCE_K)
+extern float saved_extruder_advance_K[EXTRUDERS];
+#endif
+
 #if EXTRUDERS > 1
   #include "tool_change.h"
   void M217_report(const bool eeprom);
@@ -2233,7 +2237,12 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(LIN_ADVANCE)
-    LOOP_L_N(i, EXTRUDERS) planner.extruder_advance_K[i] = LIN_ADVANCE_K;
+    LOOP_L_N(i, EXTRUDERS) {
+      planner.extruder_advance_K[i] = LIN_ADVANCE_K;
+    #if ENABLED(EXTRA_LIN_ADVANCE_K)
+      saved_extruder_advance_K[i] = LIN_ADVANCE_K;
+    #endif
+    }
   #endif
 
   //

commit 380c771988ff415d48cc06df74b6c86967087016
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 24 19:10:33 2019 -0500

    Handle word-padded flash-based eeprom (STM32F1)
    
    Fix #13445

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d71c97ae23..833d944447 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -384,18 +384,35 @@ void MarlinSettings::postprocess() {
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
-  #define EEPROM_FINISH() persistentStore.access_finish()
-  #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
-  #define EEPROM_WRITE(VAR) persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_READ(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
-  #define EEPROM_READ_ALWAYS(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
+  #define WORD_PADDED_EEPROM ENABLED(__STM32F1__, FLASH_EEPROM_EMULATION)
+
+  #if WORD_PADDED_EEPROM && ENABLED(DEBUG_EEPROM_READWRITE)
+    #define UPDATE_TEST_INDEX(VAR) (text_index += sizeof(VAR))
+  #else
+    #define UPDATE_TEST_INDEX(VAR) NOOP
+  #endif
+  #if WORD_PADDED_EEPROM
+    #define EEPROM_SKIP(VAR) do{ eeprom_index += sizeof(VAR) + (sizeof(VAR) & 1); UPDATE_TEST_INDEX(sizeof(VAR)); }while(0)
+  #else
+    #define EEPROM_SKIP(VAR) (eeprom_index += sizeof(VAR))
+  #endif
+
+  #define EEPROM_START()          int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
+  #define EEPROM_FINISH()         persistentStore.access_finish()
+  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              UPDATE_TEST_INDEX(VAR); }while(0)
+  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  UPDATE_TEST_INDEX(VAR); }while(0)
+  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               UPDATE_TEST_INDEX(VAR); }while(0)
+  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
+    #if WORD_PADDED_EEPROM
+      int test_index;
+    #else
+      int &test_index = eeprom_index;
+    #endif
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \
-        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
+        eeprom_error || test_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0239d28255..d71c97ae23 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2578,7 +2578,7 @@ void MarlinSettings::reset() {
             #endif
           #elif ENABLED(SWITCHING_NOZZLE)
             case SWITCHING_NOZZLE_SERVO_NR:
-          #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+          #elif (ENABLED(BLTOUCH) && defined(BLTOUCH_ANGLES)) || (defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR))
             case Z_PROBE_SERVO_NR:
           #endif
             CONFIG_ECHO_START();

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 46cb4c831c..0239d28255 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -56,7 +56,7 @@
 #include "../gcode/gcode.h"
 #include "../Marlin.h"
 
-#if ENABLED(EEPROM_SETTINGS) || ENABLED(SD_FIRMWARE_UPDATE)
+#if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/persistent_store_api.h"
 #endif
 
@@ -194,7 +194,7 @@ typedef struct SettingsDataStruct {
           delta_segments_per_second,                    // M665 S
           delta_calibration_radius,                     // M665 B
           delta_tower_angle_trim[ABC];                  // M665 XYZ
-  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 Z (S2)
@@ -340,7 +340,7 @@ void MarlinSettings::postprocess() {
     fwretract.refresh_autoretract();
   #endif
 
-  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
     planner.recalculate_max_e_jerk();
   #endif
 
@@ -448,7 +448,7 @@ void MarlinSettings::postprocess() {
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
-        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+        #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
           dummy = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummy);
         #endif
@@ -624,7 +624,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(delta_calibration_radius);  // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
-      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+      #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
         _FIELD_TEST(x2_endstop_adj);
 
@@ -757,7 +757,7 @@ void MarlinSettings::postprocess() {
         const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
         EEPROM_WRITE(autoretract_defaults);
       #endif
-      #if ENABLED(FWRETRACT) && ENABLED(FWRETRACT_AUTORETRACT)
+      #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
         EEPROM_WRITE(fwretract.autoretract_enabled);
       #else
         const bool autoretract_enabled = false;
@@ -1167,7 +1167,7 @@ void MarlinSettings::postprocess() {
 
         #if HAS_CLASSIC_JERK
           EEPROM_READ(planner.max_jerk);
-          #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+          #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
             EEPROM_READ(dummy);
           #endif
         #else
@@ -1340,7 +1340,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(delta_calibration_radius);  // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
 
-        #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+        #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
           _FIELD_TEST(x2_endstop_adj);
 
@@ -1472,7 +1472,7 @@ void MarlinSettings::postprocess() {
           fwretract_settings_t fwretract_settings;
           EEPROM_READ(fwretract_settings);
         #endif
-        #if ENABLED(FWRETRACT) && ENABLED(FWRETRACT_AUTORETRACT)
+        #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
           EEPROM_READ(fwretract.autoretract_enabled);
         #else
           bool autoretract_enabled;
@@ -2066,7 +2066,7 @@ void MarlinSettings::reset() {
     delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
     COPY(delta_tower_angle_trim, dta);
 
-  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       endstops.x2_endstop_adj = (
@@ -2623,7 +2623,7 @@ void MarlinSettings::reset() {
         , " Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS])
       );
 
-    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+    #elif EITHER(X_DUAL_ENDSTOPS, Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();

commit 5c1aa5162d9b7dad67899aa2514995ee99efcdf9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 15 19:18:34 2019 -0500

    Adjust M206 output in M503 for DELTA

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b60935184e..46cb4c831c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2474,10 +2474,12 @@ void MarlinSettings::reset() {
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
-          "  M206 X", LINEAR_UNIT(home_offset[X_AXIS])
-        , " Y", LINEAR_UNIT(home_offset[Y_AXIS])
-        , " Z", LINEAR_UNIT(home_offset[Z_AXIS])
+      SERIAL_ECHOLNPAIR("  M206"
+        #if IS_CARTESIAN
+          " X", LINEAR_UNIT(home_offset[X_AXIS]),
+          " Y", LINEAR_UNIT(home_offset[Y_AXIS]),
+        #endif
+        " Z", LINEAR_UNIT(home_offset[Z_AXIS])
       );
     #endif
 

commit 9a515cbd3268b30eb7a4dc9ea0f96f3a253d9063
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:26:07 2019 -0500

    Fix Pause Print message and behavior (#13394)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3ff51f9862..b60935184e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2733,8 +2733,8 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
-          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length)
-        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length)
+          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
+        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
         , " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s))
       );
 

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 13eacae04c..3ff51f9862 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -379,27 +379,8 @@ void MarlinSettings::postprocess() {
 
 #endif // SD_FIRMWARE_UPDATE
 
-#if ENABLED(EEPROM_CHITCHAT)
-  #define CHITCHAT_ECHO(V)              SERIAL_ECHO(V)
-  #define CHITCHAT_ECHOLNPGM(STR)       SERIAL_ECHOLNPGM(STR)
-  #define CHITCHAT_ECHOPAIR(...)        SERIAL_ECHOPAIR(__VA_ARGS__)
-  #define CHITCHAT_ECHOLNPAIR(...)      SERIAL_ECHOLNPAIR(__VA_ARGS__)
-  #define CHITCHAT_ECHO_START()         SERIAL_ECHO_START()
-  #define CHITCHAT_ERROR_START()        SERIAL_ERROR_START()
-  #define CHITCHAT_ERROR_MSG(STR)       SERIAL_ERROR_MSG(STR)
-  #define CHITCHAT_ECHOPGM(STR)         SERIAL_ECHOPGM(STR)
-  #define CHITCHAT_EOL()                SERIAL_EOL()
-#else
-  #define CHITCHAT_ECHO(V)              NOOP
-  #define CHITCHAT_ECHOLNPGM(STR)       NOOP
-  #define CHITCHAT_ECHOPAIR(...)        NOOP
-  #define CHITCHAT_ECHOLNPAIR(...)      NOOP
-  #define CHITCHAT_ECHO_START()         NOOP
-  #define CHITCHAT_ERROR_START()        NOOP
-  #define CHITCHAT_ERROR_MSG(STR)       NOOP
-  #define CHITCHAT_ECHOPGM(STR)         NOOP
-  #define CHITCHAT_EOL()                NOOP
-#endif
+#define DEBUG_OUT ENABLED(EEPROM_CHITCHAT)
+#include "../core/debug_out.h"
 
 #if ENABLED(EEPROM_SETTINGS)
 
@@ -427,7 +408,7 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
-      CHITCHAT_ERROR_MSG("EEPROM datasize error.");
+      DEBUG_ERROR_MSG("EEPROM datasize error.");
       return true;
     }
     return false;
@@ -1103,8 +1084,8 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(final_crc);
 
       // Report storage size
-      CHITCHAT_ECHO_START();
-      CHITCHAT_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
+      DEBUG_ECHO_START();
+      DEBUG_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
@@ -1141,8 +1122,8 @@ void MarlinSettings::postprocess() {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
-      CHITCHAT_ECHO_START();
-      CHITCHAT_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      DEBUG_ECHO_START();
+      DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       eeprom_error = true;
     }
     else {
@@ -1807,18 +1788,18 @@ void MarlinSettings::postprocess() {
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        CHITCHAT_ECHO_START();
-        CHITCHAT_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
+        DEBUG_ECHO_START();
+        DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
-        CHITCHAT_ERROR_START();
-        CHITCHAT_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        DEBUG_ERROR_START();
+        DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
       }
       else if (!validating) {
-        CHITCHAT_ECHO_START();
-        CHITCHAT_ECHO(version);
-        CHITCHAT_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
+        DEBUG_ECHO_START();
+        DEBUG_ECHO(version);
+        DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
@@ -1831,26 +1812,26 @@ void MarlinSettings::postprocess() {
             SERIAL_EOL();
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();
-              CHITCHAT_ECHOLNPGM(" initialized.\n");
+              DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if ENABLED(EEPROM_CHITCHAT)
-              CHITCHAT_ECHOPGM("?Can't enable ");
+              DEBUG_ECHOPGM("?Can't enable ");
               ubl.echo_name();
-              CHITCHAT_ECHOLNPGM(".");
+              DEBUG_ECHOLNPGM(".");
             #endif
             ubl.reset();
           }
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
-            CHITCHAT_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
+            DEBUG_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
           }
           else {
             ubl.reset();
-            CHITCHAT_ECHOLNPGM("UBL System reset()");
+            DEBUG_ECHOLNPGM("UBL System reset()");
           }
         }
       #endif
@@ -1881,9 +1862,9 @@ void MarlinSettings::postprocess() {
 
     inline void ubl_invalid_slot(const int s) {
       #if ENABLED(EEPROM_CHITCHAT)
-        CHITCHAT_ECHOLNPGM("?Invalid slot.");
-        CHITCHAT_ECHO(s);
-        CHITCHAT_ECHOLNPGM(" mesh slots available.");
+        DEBUG_ECHOLNPGM("?Invalid slot.");
+        DEBUG_ECHO(s);
+        DEBUG_ECHOLNPGM(" mesh slots available.");
       #else
         UNUSED(s);
       #endif
@@ -1912,8 +1893,8 @@ void MarlinSettings::postprocess() {
         const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
           ubl_invalid_slot(a);
-          CHITCHAT_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
-          CHITCHAT_EOL();
+          DEBUG_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
+          DEBUG_EOL();
           return;
         }
 
@@ -1926,7 +1907,7 @@ void MarlinSettings::postprocess() {
         persistentStore.access_finish();
 
         if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
-        else        CHITCHAT_ECHOLNPAIR("Mesh saved in slot ", slot);
+        else        DEBUG_ECHOLNPAIR("Mesh saved in slot ", slot);
 
       #else
 
@@ -1955,7 +1936,7 @@ void MarlinSettings::postprocess() {
         persistentStore.access_finish();
 
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
-        else        CHITCHAT_ECHOLNPAIR("Mesh loaded from slot ", slot);
+        else        DEBUG_ECHOLNPAIR("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();
 
@@ -1974,7 +1955,7 @@ void MarlinSettings::postprocess() {
 #else // !EEPROM_SETTINGS
 
   bool MarlinSettings::save() {
-    CHITCHAT_ERROR_MSG("EEPROM disabled");
+    DEBUG_ERROR_MSG("EEPROM disabled");
     return false;
   }
 
@@ -2281,8 +2262,8 @@ void MarlinSettings::reset() {
 
   postprocess();
 
-  CHITCHAT_ECHO_START();
-  CHITCHAT_ECHOLNPGM("Hardcoded Default Settings Loaded");
+  DEBUG_ECHO_START();
+  DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
 }
 
 #if DISABLED(DISABLE_M503)

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e69df2f0df..13eacae04c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2028,15 +2028,7 @@ void MarlinSettings::reset() {
   #endif
 
   #if HAS_HOTEND_OFFSET
-    constexpr float tmp4[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
-    static_assert(
-      tmp4[X_AXIS][0] == 0 && tmp4[Y_AXIS][0] == 0 && tmp4[Z_AXIS][0] == 0,
-      "Offsets for the first hotend must be 0.0."
-    );
-    LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp4[i][e];
-    #if ENABLED(DUAL_X_CARRIAGE)
-      hotend_offset[X_AXIS][1] = MAX(X2_HOME_POS, X2_MAX_POS);
-    #endif
+    reset_hotend_offsets();
   #endif
 
   #if EXTRUDERS > 1

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1074dd914c..e69df2f0df 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -728,7 +728,7 @@ void MarlinSettings::postprocess() {
         const PID_t bed_pid = { DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE };
         EEPROM_WRITE(bed_pid);
       #else
-        EEPROM_WRITE(thermalManager.bed_pid);
+        EEPROM_WRITE(thermalManager.temp_bed.pid);
       #endif
     }
 
@@ -1448,7 +1448,7 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
           if (!validating && pid.Kp != DUMMY_PID_VALUE)
-            memcpy(&thermalManager.bed_pid, &pid, sizeof(pid));
+            memcpy(&thermalManager.temp_bed.pid, &pid, sizeof(pid));
         #endif
       }
 
@@ -2181,9 +2181,9 @@ void MarlinSettings::reset() {
   //
 
   #if ENABLED(PIDTEMPBED)
-    thermalManager.bed_pid.Kp = DEFAULT_bedKp;
-    thermalManager.bed_pid.Ki = scalePID_i(DEFAULT_bedKi);
-    thermalManager.bed_pid.Kd = scalePID_d(DEFAULT_bedKd);
+    thermalManager.temp_bed.pid.Kp = DEFAULT_bedKp;
+    thermalManager.temp_bed.pid.Ki = scalePID_i(DEFAULT_bedKi);
+    thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
   #endif
 
   //
@@ -2726,9 +2726,9 @@ void MarlinSettings::reset() {
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR(
-            "  M304 P", thermalManager.bed_pid.Kp
-          , " I", unscalePID_i(thermalManager.bed_pid.Ki)
-          , " D", unscalePID_d(thermalManager.bed_pid.Kd)
+            "  M304 P", thermalManager.temp_bed.pid.Kp
+          , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
+          , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
         );
       #endif
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 47f87281ee..1074dd914c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -382,8 +382,8 @@ void MarlinSettings::postprocess() {
 #if ENABLED(EEPROM_CHITCHAT)
   #define CHITCHAT_ECHO(V)              SERIAL_ECHO(V)
   #define CHITCHAT_ECHOLNPGM(STR)       SERIAL_ECHOLNPGM(STR)
-  #define CHITCHAT_ECHOPAIR(STR,V)      SERIAL_ECHOPAIR(STR,V)
-  #define CHITCHAT_ECHOLNPAIR(STR,V)    SERIAL_ECHOLNPAIR(STR,V)
+  #define CHITCHAT_ECHOPAIR(...)        SERIAL_ECHOPAIR(__VA_ARGS__)
+  #define CHITCHAT_ECHOLNPAIR(...)      SERIAL_ECHOLNPAIR(__VA_ARGS__)
   #define CHITCHAT_ECHO_START()         SERIAL_ECHO_START()
   #define CHITCHAT_ERROR_START()        SERIAL_ERROR_START()
   #define CHITCHAT_ERROR_MSG(STR)       SERIAL_ERROR_MSG(STR)
@@ -392,8 +392,8 @@ void MarlinSettings::postprocess() {
 #else
   #define CHITCHAT_ECHO(V)              NOOP
   #define CHITCHAT_ECHOLNPGM(STR)       NOOP
-  #define CHITCHAT_ECHOPAIR(STR,V)      NOOP
-  #define CHITCHAT_ECHOLNPAIR(STR,V)    NOOP
+  #define CHITCHAT_ECHOPAIR(...)        NOOP
+  #define CHITCHAT_ECHOLNPAIR(...)      NOOP
   #define CHITCHAT_ECHO_START()         NOOP
   #define CHITCHAT_ERROR_START()        NOOP
   #define CHITCHAT_ERROR_MSG(STR)       NOOP
@@ -1104,9 +1104,7 @@ void MarlinSettings::postprocess() {
 
       // Report storage size
       CHITCHAT_ECHO_START();
-      CHITCHAT_ECHOPAIR("Settings Stored (", eeprom_size);
-      CHITCHAT_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
-      CHITCHAT_ECHOLNPGM(")");
+      CHITCHAT_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
@@ -1144,9 +1142,7 @@ void MarlinSettings::postprocess() {
         stored_ver[1] = '\0';
       }
       CHITCHAT_ECHO_START();
-      CHITCHAT_ECHOPGM("EEPROM version mismatch ");
-      CHITCHAT_ECHOPAIR("(EEPROM=", stored_ver);
-      CHITCHAT_ECHOLNPGM(" Marlin=" EEPROM_VERSION ")");
+      CHITCHAT_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       eeprom_error = true;
     }
     else {
@@ -1812,24 +1808,17 @@ void MarlinSettings::postprocess() {
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         CHITCHAT_ECHO_START();
-        CHITCHAT_ECHOPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)));
-        CHITCHAT_ECHOLNPAIR(" Size: ", datasize());
+        CHITCHAT_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         CHITCHAT_ERROR_START();
-        CHITCHAT_ECHOPGM("EEPROM CRC mismatch - (stored) ");
-        CHITCHAT_ECHO(stored_crc);
-        CHITCHAT_ECHOPGM(" != ");
-        CHITCHAT_ECHO(working_crc);
-        CHITCHAT_ECHOLNPGM(" (calculated)!");
+        CHITCHAT_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
       }
       else if (!validating) {
         CHITCHAT_ECHO_START();
         CHITCHAT_ECHO(version);
-        CHITCHAT_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-        CHITCHAT_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
-        CHITCHAT_ECHOLNPGM(")");
+        CHITCHAT_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
@@ -1857,8 +1846,7 @@ void MarlinSettings::postprocess() {
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
-            CHITCHAT_ECHOPAIR("Mesh ", ubl.storage_slot);
-            CHITCHAT_ECHOLNPGM(" loaded from storage.");
+            CHITCHAT_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
           }
           else {
             ubl.reset();
@@ -1924,9 +1912,7 @@ void MarlinSettings::postprocess() {
         const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
           ubl_invalid_slot(a);
-          CHITCHAT_ECHOPAIR("E2END=", persistentStore.capacity() - 1);
-          CHITCHAT_ECHOPAIR(" meshes_end=", meshes_end);
-          CHITCHAT_ECHOLNPAIR(" slot=", slot);
+          CHITCHAT_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
           CHITCHAT_EOL();
           return;
         }
@@ -2314,7 +2300,7 @@ void MarlinSettings::reset() {
   #define CONFIG_ECHO_HEADING(STR)  do{ if (!forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); } }while(0)
 
   #if HAS_TRINAMIC
-    void say_M906() { SERIAL_ECHOPGM("  M906"); }
+    inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
       void say_M569(const char * const etc=NULL) {
         SERIAL_ECHOPGM("  M569 S1");
@@ -2326,15 +2312,15 @@ void MarlinSettings::reset() {
       }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
-      void say_M913() { SERIAL_ECHOPGM("  M913"); }
+      inline void say_M913() { SERIAL_ECHOPGM("  M913"); }
     #endif
     #if USE_SENSORLESS
-      void say_M914() { SERIAL_ECHOPGM("  M914"); }
+      inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
     #endif
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    void say_M603() { SERIAL_ECHOPGM("  M603 "); }
+    inline void say_M603(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M603 "); }
   #endif
 
   inline void say_units(const bool colon) {
@@ -2403,28 +2389,22 @@ void MarlinSettings::reset() {
       }
 
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
       #if EXTRUDERS > 1
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
-          SERIAL_EOL();
+          SERIAL_ECHOLNPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
-            SERIAL_EOL();
+            SERIAL_ECHOLNPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
-              SERIAL_EOL();
+              SERIAL_ECHOLNPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
               #if EXTRUDERS > 5
                 CONFIG_ECHO_START();
-                SERIAL_ECHOPAIR("  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
-                SERIAL_EOL();
+                SERIAL_ECHOLNPAIR("  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
@@ -2441,43 +2421,50 @@ void MarlinSettings::reset() {
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR("  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]));
-    #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS]));
-    #endif
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR(
+        "  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
+      , " Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
+      , " Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
+      #if DISABLED(DISTINCT_E_FACTORS)
+        , " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
+      #endif
+    );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR("  M203 T", (int)i);
-        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)]));
+        SERIAL_ECHOLNPAIR(
+            "  M203 T", (int)i
+          , " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
+        );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR("  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]));
-    #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS]));
-    #endif
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR(
+        "  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
+      , " Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
+      , " Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+      #if DISABLED(DISTINCT_E_FACTORS)
+        , " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
+      #endif
+    );
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
-      for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR("  M201 T", (int)i);
-        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]));
-      }
+      for (uint8_t i = 0; i < E_STEPPERS; i++)
+        SERIAL_ECHOLNPAIR(
+            "  M201 T", (int)i
+          , " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
+        );
     #endif
 
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR("  M204 P", LINEAR_UNIT(planner.settings.acceleration));
-    SERIAL_ECHOPAIR(" R", LINEAR_UNIT(planner.settings.retract_acceleration));
-    SERIAL_ECHOLNPAIR(" T", LINEAR_UNIT(planner.settings.travel_acceleration));
+    SERIAL_ECHOLNPAIR(
+        "  M204 P", LINEAR_UNIT(planner.settings.acceleration)
+      , " R", LINEAR_UNIT(planner.settings.retract_acceleration)
+      , " T", LINEAR_UNIT(planner.settings.travel_acceleration)
+    );
 
     if (!forReplay) {
       CONFIG_ECHO_START();
@@ -2494,39 +2481,42 @@ void MarlinSettings::reset() {
       SERIAL_EOL();
     }
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR("  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us));
-    SERIAL_ECHOPAIR(" S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s));
-    SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s));
-
-    #if ENABLED(JUNCTION_DEVIATION)
-      SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.junction_deviation_mm));
-    #endif
-    #if HAS_CLASSIC_JERK
-      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
-      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
-      #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
-        SERIAL_ECHOPAIR(" E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+    SERIAL_ECHOLNPAIR(
+        "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us)
+      , " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
+      , " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
+      #if ENABLED(JUNCTION_DEVIATION)
+        , " J", LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
-    #endif
-
-    SERIAL_EOL();
+      #if HAS_CLASSIC_JERK
+        , " X", LINEAR_UNIT(planner.max_jerk[X_AXIS])
+        , " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS])
+        , " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS])
+        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+          , " E", LINEAR_UNIT(planner.max_jerk[E_AXIS])
+        #endif
+      #endif
+    );
 
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(home_offset[Y_AXIS]));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(home_offset[Z_AXIS]));
+      SERIAL_ECHOLNPAIR(
+          "  M206 X", LINEAR_UNIT(home_offset[X_AXIS])
+        , " Y", LINEAR_UNIT(home_offset[Y_AXIS])
+        , " Z", LINEAR_UNIT(home_offset[Z_AXIS])
+      );
     #endif
 
     #if HAS_HOTEND_OFFSET
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
       for (uint8_t e = 1; e < HOTENDS; e++) {
-        SERIAL_ECHOPAIR("  M218 T", (int)e);
-        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
-        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
+        SERIAL_ECHOPAIR(
+            "  M218 T", (int)e
+          , " X", LINEAR_UNIT(hotend_offset[X_AXIS][e])
+          , " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e])
+        );
         SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
       }
     #endif
@@ -2555,11 +2545,12 @@ void MarlinSettings::reset() {
       #endif
 
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
-      #endif
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR(
+        "  M420 S", planner.leveling_active ? 1 : 0
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          , " Z", LINEAR_UNIT(planner.z_fade_height)
+        #endif
+      );
 
       #if ENABLED(MESH_BED_LEVELING)
 
@@ -2567,8 +2558,7 @@ void MarlinSettings::reset() {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
-              SERIAL_ECHOPAIR(" Y", (int)py + 1);
+              SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1, " Y", (int)py + 1);
               SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
@@ -2580,8 +2570,7 @@ void MarlinSettings::reset() {
           SERIAL_EOL();
           ubl.report_state();
           SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
-          SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
-          SERIAL_ECHOLNPGM(" meshes.\n");
+          SERIAL_ECHOLNPAIR("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
@@ -2592,8 +2581,7 @@ void MarlinSettings::reset() {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 W I", (int)px);
-              SERIAL_ECHOPAIR(" J", (int)py);
+              SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
               SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
@@ -2619,10 +2607,7 @@ void MarlinSettings::reset() {
             case Z_PROBE_SERVO_NR:
           #endif
             CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR("  M281 P", int(i));
-            SERIAL_ECHOPAIR(" L", servo_angles[i][0]);
-            SERIAL_ECHOPAIR(" U", servo_angles[i][1]);
-            SERIAL_EOL();
+            SERIAL_ECHOLNPAIR("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
           default: break;
         }
       }
@@ -2633,33 +2618,37 @@ void MarlinSettings::reset() {
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M665 S", delta_segments_per_second);
-      SERIAL_ECHOPAIR(" P", scara_home_offset[A_AXIS]);
-      SERIAL_ECHOPAIR(" T", scara_home_offset[B_AXIS]);
-      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(scara_home_offset[Z_AXIS]));
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR(
+          "  M665 S", delta_segments_per_second
+        , " P", scara_home_offset[A_AXIS]
+        , " T", scara_home_offset[B_AXIS]
+        , " Z", LINEAR_UNIT(scara_home_offset[Z_AXIS])
+      );
 
     #elif ENABLED(DELTA)
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
+      SERIAL_ECHOLNPAIR(
+          "  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS])
+        , " Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS])
+        , " Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS])
+      );
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
-      SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
-      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(delta_height));
-      SERIAL_ECHOPAIR(" S", delta_segments_per_second);
-      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
-      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
-      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR(
+          "  M665 L", LINEAR_UNIT(delta_diagonal_rod)
+        , " R", LINEAR_UNIT(delta_radius)
+        , " H", LINEAR_UNIT(delta_height)
+        , " S", delta_segments_per_second
+        , " B", LINEAR_UNIT(delta_calibration_radius)
+        , " X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS])
+        , " Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS])
+        , " Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS])
+      );
 
-    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
@@ -2686,10 +2675,12 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR("  M145 S", (int)i);
-        SERIAL_ECHOPAIR(" H", TEMP_UNIT(ui.preheat_hotend_temp[i]));
-        SERIAL_ECHOPAIR(" B", TEMP_UNIT(ui.preheat_bed_temp[i]));
-        SERIAL_ECHOLNPAIR(" F", int(ui.preheat_fan_speed[i]));
+        SERIAL_ECHOLNPAIR(
+            "  M145 S", (int)i
+          , " H", TEMP_UNIT(ui.preheat_hotend_temp[i])
+          , " B", TEMP_UNIT(ui.preheat_bed_temp[i])
+          , " F", int(ui.preheat_fan_speed[i])
+        );
       }
 
     #endif
@@ -2702,10 +2693,12 @@ void MarlinSettings::reset() {
           if (forReplay) {
             HOTEND_LOOP() {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  M301 E", e);
-              SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
-              SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
-              SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
+              SERIAL_ECHOPAIR(
+                  "  M301 E", e
+                , " P", PID_PARAM(Kp, e)
+                , " I", unscalePID_i(PID_PARAM(Ki, e))
+                , " D", unscalePID_d(PID_PARAM(Kd, e))
+              );
               #if ENABLED(PID_EXTRUSION_SCALING)
                 SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
                 if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
@@ -2718,23 +2711,25 @@ void MarlinSettings::reset() {
         // !forReplay || HOTENDS == 1
         {
           CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
-          SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
-          SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
-            SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
-          #endif
-          SERIAL_EOL();
+          SERIAL_ECHOLNPAIR(
+              "  M301 P", PID_PARAM(Kp, 0) // for compatibility with hosts, only echo values for E0
+            , " I", unscalePID_i(PID_PARAM(Ki, 0))
+            , " D", unscalePID_d(PID_PARAM(Kd, 0))
+            #if ENABLED(PID_EXTRUSION_SCALING)
+              , " C", PID_PARAM(Kc, 0)
+              , " L", thermalManager.lpq_len
+            #endif
+          );
         }
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR("  M304 P", thermalManager.bed_pid.Kp);
-        SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bed_pid.Ki));
-        SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bed_pid.Kd));
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR(
+            "  M304 P", thermalManager.bed_pid.Kp
+          , " I", unscalePID_i(thermalManager.bed_pid.Ki)
+          , " D", unscalePID_d(thermalManager.bed_pid.Kd)
+        );
       #endif
 
     #endif // PIDTEMP || PIDTEMPBED
@@ -2755,16 +2750,20 @@ void MarlinSettings::reset() {
 
       CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
-      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(fwretract.settings.retract_zraise));
+      SERIAL_ECHOLNPAIR(
+          "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length)
+        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_length)
+        , " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s))
+        , " Z", LINEAR_UNIT(fwretract.settings.retract_zraise)
+      );
 
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length));
-      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR(
+          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length)
+        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length)
+        , " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s))
+      );
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
 
@@ -2810,67 +2809,65 @@ void MarlinSettings::reset() {
        * TMC stepper driver current
        */
       CONFIG_ECHO_HEADING("Stepper driver current:");
-      CONFIG_ECHO_START();
-      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        say_M906();
-      #endif
-      #if AXIS_IS_TMC(X)
-        SERIAL_ECHOPAIR(" X", stepperX.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(Y)
-        SERIAL_ECHOPAIR(" Y", stepperY.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(Z)
-        SERIAL_ECHOPAIR(" Z", stepperZ.getMilliamps());
-      #endif
+
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        SERIAL_EOL();
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(
+          #if AXIS_IS_TMC(X)
+            " X", stepperX.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Y)
+            " Y", stepperY.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Z)
+            " Z", stepperZ.getMilliamps()
+          #endif
+        );
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOPGM(" I1");
-      #endif
-      #if AXIS_IS_TMC(X2)
-        SERIAL_ECHOPAIR(" X", stepperX2.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        SERIAL_ECHOPAIR(" Y", stepperY2.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(Z2)
-        SERIAL_ECHOPAIR(" Z", stepperZ2.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR(
+          #if AXIS_IS_TMC(X2)
+            " X", stepperX2.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Y2)
+            " Y", stepperY2.getMilliamps(),
+          #endif
+          #if AXIS_IS_TMC(Z2)
+            " Z", stepperZ2.getMilliamps()
+          #endif
+        );
       #endif
 
       #if AXIS_IS_TMC(Z3)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
       #endif
 
       #if AXIS_IS_TMC(E0)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E1)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E2)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T2 E", stepperE2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E3)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T3 E", stepperE3.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E4)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T4 E", stepperE4.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E5)
-        say_M906();
+        say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
       #endif
       SERIAL_EOL();
@@ -2916,8 +2913,7 @@ void MarlinSettings::reset() {
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
           say_M913();
-          SERIAL_ECHOPGM(" I2");
-          SERIAL_ECHOLNPAIR(" Z", TMC_GET_PWMTHRS(Z, Z3));
+          SERIAL_ECHOLNPAIR(" I2 Z", TMC_GET_PWMTHRS(Z, Z3));
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
@@ -2988,8 +2984,7 @@ void MarlinSettings::reset() {
 
         #if HAS_Z3_SENSORLESS
           say_M914();
-          SERIAL_ECHOPGM(" I2");
-          SERIAL_ECHOLNPAIR(" Z", stepperZ3.sgt());
+          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.sgt());
         #endif
 
       #endif // USE_SENSORLESS
@@ -3080,20 +3075,19 @@ void MarlinSettings::reset() {
       #if EXTRUDERS < 2
         SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
       #else
-        LOOP_L_N(i, EXTRUDERS) {
-          SERIAL_ECHOPAIR("  M900 T", int(i));
-          SERIAL_ECHOLNPAIR(" K", planner.extruder_advance_K[i]);
-        }
+        LOOP_L_N(i, EXTRUDERS)
+          SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
       #endif
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR("  M907 X", stepper.motor_current_setting[0]);
-      SERIAL_ECHOPAIR(" Z", stepper.motor_current_setting[1]);
-      SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR(
+          "  M907 X", stepper.motor_current_setting[0]
+        , " Z", stepper.motor_current_setting[1]
+        , " E", stepper.motor_current_setting[2]
+      );
     #endif
 
     /**
@@ -3101,39 +3095,21 @@ void MarlinSettings::reset() {
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
-      CONFIG_ECHO_START();
       #if EXTRUDERS == 1
-        say_M603();
-        SERIAL_ECHOPAIR("L", LINEAR_UNIT(fc_settings[0].load_length));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[0].unload_length));
+        say_M603(forReplay);
+        SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
-        say_M603();
-        SERIAL_ECHOPAIR("T0 L", LINEAR_UNIT(fc_settings[0].load_length));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[0].unload_length));
-        CONFIG_ECHO_START();
-        say_M603();
-        SERIAL_ECHOPAIR("T1 L", LINEAR_UNIT(fc_settings[1].load_length));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[1].unload_length));
+        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0)
+        _ECHO_603(0);
+        _ECHO_603(1);
         #if EXTRUDERS > 2
-          CONFIG_ECHO_START();
-          say_M603();
-          SERIAL_ECHOPAIR("T2 L", LINEAR_UNIT(fc_settings[2].load_length));
-          SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[2].unload_length));
+          _ECHO_603(2);
           #if EXTRUDERS > 3
-            CONFIG_ECHO_START();
-            say_M603();
-            SERIAL_ECHOPAIR("T3 L", LINEAR_UNIT(fc_settings[3].load_length));
-            SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[3].unload_length));
+            _ECHO_603(3);
             #if EXTRUDERS > 4
-              CONFIG_ECHO_START();
-              say_M603();
-              SERIAL_ECHOPAIR("T4 L", LINEAR_UNIT(fc_settings[4].load_length));
-              SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[4].unload_length));
+              _ECHO_603(4);
               #if EXTRUDERS > 5
-                CONFIG_ECHO_START();
-                say_M603();
-                SERIAL_ECHOPAIR("T5 L", LINEAR_UNIT(fc_settings[5].load_length));
-                SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[5].unload_length));
+                _ECHO_603(5);
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3

commit 71773b128db764afeccb3c782c5a8bdaef175042
Author: Vasily Evseenko <svpcom@gmail.com>
Date:   Sun Mar 3 02:29:02 2019 +0300

    Fix stepper use before init. Add Ultimaker2+ Extended clone config (#13284)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1271f9bb16..47f87281ee 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2265,7 +2265,7 @@ void MarlinSettings::reset() {
   //
 
   #if HAS_MOTOR_CURRENT_PWM
-    uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
+    constexpr uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
     for (uint8_t q = 3; q--;)
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif

commit 2616e4d4d99b6441d07ba066778cac8f4228c3bb
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Feb 25 23:13:01 2019 +0100

    Remove duplicated 'chitchat' defines (#13258)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 91991585d4..1271f9bb16 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -387,11 +387,7 @@ void MarlinSettings::postprocess() {
   #define CHITCHAT_ECHO_START()         SERIAL_ECHO_START()
   #define CHITCHAT_ERROR_START()        SERIAL_ERROR_START()
   #define CHITCHAT_ERROR_MSG(STR)       SERIAL_ERROR_MSG(STR)
-  #define CHITCHAT_ECHO(VAL)            SERIAL_ECHO(VAL)
   #define CHITCHAT_ECHOPGM(STR)         SERIAL_ECHOPGM(STR)
-  #define CHITCHAT_ECHOLNPGM(STR)       SERIAL_ECHOLNPGM(STR)
-  #define CHITCHAT_ECHOPAIR(STR, VAL)   SERIAL_ECHOPAIR(STR, VAL)
-  #define CHITCHAT_ECHOLNPAIR(STR, VAL) SERIAL_ECHOLNPAIR(STR, VAL)
   #define CHITCHAT_EOL()                SERIAL_EOL()
 #else
   #define CHITCHAT_ECHO(V)              NOOP
@@ -401,11 +397,7 @@ void MarlinSettings::postprocess() {
   #define CHITCHAT_ECHO_START()         NOOP
   #define CHITCHAT_ERROR_START()        NOOP
   #define CHITCHAT_ERROR_MSG(STR)       NOOP
-  #define CHITCHAT_ECHO(VAL)            NOOP
   #define CHITCHAT_ECHOPGM(STR)         NOOP
-  #define CHITCHAT_ECHOLNPGM(STR)       NOOP
-  #define CHITCHAT_ECHOPAIR(STR, VAL)   NOOP
-  #define CHITCHAT_ECHOLNPAIR(STR, VAL) NOOP
   #define CHITCHAT_EOL()                NOOP
 #endif
 

commit 808b076000e89fd7dae071bd2e4899833c872af6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 24 20:29:03 2019 -0600

    Update some ABL/UBL conditionals

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3430db901a..91991585d4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2556,7 +2556,7 @@ void MarlinSettings::reset() {
           SERIAL_ECHOLNPGM(":");
         }
 
-      #elif HAS_ABL
+      #elif HAS_ABL_OR_UBL
 
         CONFIG_ECHO_HEADING("Auto Bed Leveling:");
 

commit e15354e387cc825390fc4eaaf3ae4b784a8fd588
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 23 22:53:01 2019 -0600

    Simplify serial port redirect (#13234)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9270b3a747..3430db901a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -46,20 +46,6 @@
 
 #include "configuration_store.h"
 
-#if ADD_PORT_ARG
-  #define PORTARG_SOLO     const int8_t port
-  #define PORTARG_BEFORE   const int8_t port,
-  #define PORTARG_AFTER   ,const int8_t port
-  #define PORTVAR_SOLO     port
-  #define PORTVAR_BEFORE   port,
-#else
-  #define PORTARG_SOLO
-  #define PORTARG_BEFORE
-  #define PORTARG_AFTER
-  #define PORTVAR_SOLO
-  #define PORTVAR_BEFORE
-#endif
-
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
@@ -394,33 +380,33 @@ void MarlinSettings::postprocess() {
 #endif // SD_FIRMWARE_UPDATE
 
 #if ENABLED(EEPROM_CHITCHAT)
-  #define CHITCHAT_ECHO(V)                      SERIAL_ECHO(V)
-  #define CHITCHAT_ECHOLNPGM(STR)               SERIAL_ECHOLNPGM(STR)
-  #define CHITCHAT_ECHOPAIR(STR,V)              SERIAL_ECHOPAIR(STR,V)
-  #define CHITCHAT_ECHOLNPAIR(STR,V)            SERIAL_ECHOLNPAIR(STR,V)
-  #define CHITCHAT_ECHO_START_P(port)           SERIAL_ECHO_START_P(port)
-  #define CHITCHAT_ERROR_START_P(port)          SERIAL_ERROR_START_P(port)
-  #define CHITCHAT_ERROR_MSG_P(port, STR)       SERIAL_ERROR_MSG_P(port, STR)
-  #define CHITCHAT_ECHO_P(port, VAL)            SERIAL_ECHO_P(port, VAL)
-  #define CHITCHAT_ECHOPGM_P(port, STR)         SERIAL_ECHOPGM_P(port, STR)
-  #define CHITCHAT_ECHOLNPGM_P(port, STR)       SERIAL_ECHOLNPGM_P(port, STR)
-  #define CHITCHAT_ECHOPAIR_P(port, STR, VAL)   SERIAL_ECHOPAIR_P(port, STR, VAL)
-  #define CHITCHAT_ECHOLNPAIR_P(port, STR, VAL) SERIAL_ECHOLNPAIR_P(port, STR, VAL)
-  #define CHITCHAT_EOL()                        SERIAL_EOL()
+  #define CHITCHAT_ECHO(V)              SERIAL_ECHO(V)
+  #define CHITCHAT_ECHOLNPGM(STR)       SERIAL_ECHOLNPGM(STR)
+  #define CHITCHAT_ECHOPAIR(STR,V)      SERIAL_ECHOPAIR(STR,V)
+  #define CHITCHAT_ECHOLNPAIR(STR,V)    SERIAL_ECHOLNPAIR(STR,V)
+  #define CHITCHAT_ECHO_START()         SERIAL_ECHO_START()
+  #define CHITCHAT_ERROR_START()        SERIAL_ERROR_START()
+  #define CHITCHAT_ERROR_MSG(STR)       SERIAL_ERROR_MSG(STR)
+  #define CHITCHAT_ECHO(VAL)            SERIAL_ECHO(VAL)
+  #define CHITCHAT_ECHOPGM(STR)         SERIAL_ECHOPGM(STR)
+  #define CHITCHAT_ECHOLNPGM(STR)       SERIAL_ECHOLNPGM(STR)
+  #define CHITCHAT_ECHOPAIR(STR, VAL)   SERIAL_ECHOPAIR(STR, VAL)
+  #define CHITCHAT_ECHOLNPAIR(STR, VAL) SERIAL_ECHOLNPAIR(STR, VAL)
+  #define CHITCHAT_EOL()                SERIAL_EOL()
 #else
-  #define CHITCHAT_ECHO(V)                      NOOP
-  #define CHITCHAT_ECHOLNPGM(STR)               NOOP
-  #define CHITCHAT_ECHOPAIR(STR,V)              NOOP
-  #define CHITCHAT_ECHOLNPAIR(STR,V)            NOOP
-  #define CHITCHAT_ECHO_START_P(port)           NOOP
-  #define CHITCHAT_ERROR_START_P(port)          NOOP
-  #define CHITCHAT_ERROR_MSG_P(port, STR)       NOOP
-  #define CHITCHAT_ECHO_P(port, VAL)            NOOP
-  #define CHITCHAT_ECHOPGM_P(port, STR)         NOOP
-  #define CHITCHAT_ECHOLNPGM_P(port, STR)       NOOP
-  #define CHITCHAT_ECHOPAIR_P(port, STR, VAL)   NOOP
-  #define CHITCHAT_ECHOLNPAIR_P(port, STR, VAL) NOOP
-  #define CHITCHAT_EOL()                        NOOP
+  #define CHITCHAT_ECHO(V)              NOOP
+  #define CHITCHAT_ECHOLNPGM(STR)       NOOP
+  #define CHITCHAT_ECHOPAIR(STR,V)      NOOP
+  #define CHITCHAT_ECHOLNPAIR(STR,V)    NOOP
+  #define CHITCHAT_ECHO_START()         NOOP
+  #define CHITCHAT_ERROR_START()        NOOP
+  #define CHITCHAT_ERROR_MSG(STR)       NOOP
+  #define CHITCHAT_ECHO(VAL)            NOOP
+  #define CHITCHAT_ECHOPGM(STR)         NOOP
+  #define CHITCHAT_ECHOLNPGM(STR)       NOOP
+  #define CHITCHAT_ECHOPAIR(STR, VAL)   NOOP
+  #define CHITCHAT_ECHOLNPAIR(STR, VAL) NOOP
+  #define CHITCHAT_EOL()                NOOP
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
@@ -431,7 +417,7 @@ void MarlinSettings::postprocess() {
   #define EEPROM_WRITE(VAR) persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_READ(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
   #define EEPROM_READ_ALWAYS(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_MSG_P(port, ERR); eeprom_error = true; } }while(0)
+  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
@@ -447,9 +433,9 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
 
-  bool MarlinSettings::size_error(const uint16_t size PORTARG_AFTER) {
+  bool MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
-      CHITCHAT_ERROR_MSG_P(port, "EEPROM datasize error.");
+      CHITCHAT_ERROR_MSG("EEPROM datasize error.");
       return true;
     }
     return false;
@@ -458,7 +444,7 @@ void MarlinSettings::postprocess() {
   /**
    * M500 - Store Configuration
    */
-  bool MarlinSettings::save(PORTARG_SOLO) {
+  bool MarlinSettings::save() {
     float dummy = 0;
     char ver[4] = "ERR";
 
@@ -1125,10 +1111,10 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(final_crc);
 
       // Report storage size
-      CHITCHAT_ECHO_START_P(port);
-      CHITCHAT_ECHOPAIR_P(port, "Settings Stored (", eeprom_size);
-      CHITCHAT_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)final_crc);
-      CHITCHAT_ECHOLNPGM_P(port, ")");
+      CHITCHAT_ECHO_START();
+      CHITCHAT_ECHOPAIR("Settings Stored (", eeprom_size);
+      CHITCHAT_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
+      CHITCHAT_ECHOLNPGM(")");
 
       eeprom_error |= size_error(eeprom_size);
     }
@@ -1148,7 +1134,7 @@ void MarlinSettings::postprocess() {
   /**
    * M501 - Retrieve Configuration
    */
-  bool MarlinSettings::_load(PORTARG_SOLO) {
+  bool MarlinSettings::_load() {
     uint16_t working_crc = 0;
 
     EEPROM_START();
@@ -1165,10 +1151,10 @@ void MarlinSettings::postprocess() {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
-      CHITCHAT_ECHO_START_P(port);
-      CHITCHAT_ECHOPGM_P(port, "EEPROM version mismatch ");
-      CHITCHAT_ECHOPAIR_P(port, "(EEPROM=", stored_ver);
-      CHITCHAT_ECHOLNPGM_P(port, " Marlin=" EEPROM_VERSION ")");
+      CHITCHAT_ECHO_START();
+      CHITCHAT_ECHOPGM("EEPROM version mismatch ");
+      CHITCHAT_ECHOPAIR("(EEPROM=", stored_ver);
+      CHITCHAT_ECHOLNPGM(" Marlin=" EEPROM_VERSION ")");
       eeprom_error = true;
     }
     else {
@@ -1833,25 +1819,25 @@ void MarlinSettings::postprocess() {
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        CHITCHAT_ECHO_START_P(port);
-        CHITCHAT_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
-        CHITCHAT_ECHOLNPAIR_P(port, " Size: ", datasize());
+        CHITCHAT_ECHO_START();
+        CHITCHAT_ECHOPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)));
+        CHITCHAT_ECHOLNPAIR(" Size: ", datasize());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
-        CHITCHAT_ERROR_START_P(port);
-        CHITCHAT_ECHOPGM_P(port, "EEPROM CRC mismatch - (stored) ");
-        CHITCHAT_ECHO_P(port, stored_crc);
-        CHITCHAT_ECHOPGM_P(port, " != ");
-        CHITCHAT_ECHO_P(port, working_crc);
-        CHITCHAT_ECHOLNPGM_P(port, " (calculated)!");
+        CHITCHAT_ERROR_START();
+        CHITCHAT_ECHOPGM("EEPROM CRC mismatch - (stored) ");
+        CHITCHAT_ECHO(stored_crc);
+        CHITCHAT_ECHOPGM(" != ");
+        CHITCHAT_ECHO(working_crc);
+        CHITCHAT_ECHOLNPGM(" (calculated)!");
       }
       else if (!validating) {
-        CHITCHAT_ECHO_START_P(port);
-        CHITCHAT_ECHO_P(port, version);
-        CHITCHAT_ECHOPAIR_P(port, " stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-        CHITCHAT_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)working_crc);
-        CHITCHAT_ECHOLNPGM_P(port, ")");
+        CHITCHAT_ECHO_START();
+        CHITCHAT_ECHO(version);
+        CHITCHAT_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+        CHITCHAT_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
+        CHITCHAT_ECHOLNPGM(")");
       }
 
       if (!validating && !eeprom_error) postprocess();
@@ -1861,52 +1847,52 @@ void MarlinSettings::postprocess() {
           ubl.report_state();
 
           if (!ubl.sanity_check()) {
-            SERIAL_EOL_P(port);
+            SERIAL_EOL();
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();
-              CHITCHAT_ECHOLNPGM_P(port, " initialized.\n");
+              CHITCHAT_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if ENABLED(EEPROM_CHITCHAT)
-              CHITCHAT_ECHOPGM_P(port, "?Can't enable ");
+              CHITCHAT_ECHOPGM("?Can't enable ");
               ubl.echo_name();
-              CHITCHAT_ECHOLNPGM_P(port, ".");
+              CHITCHAT_ECHOLNPGM(".");
             #endif
             ubl.reset();
           }
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
-            CHITCHAT_ECHOPAIR_P(port, "Mesh ", ubl.storage_slot);
-            CHITCHAT_ECHOLNPGM_P(port, " loaded from storage.");
+            CHITCHAT_ECHOPAIR("Mesh ", ubl.storage_slot);
+            CHITCHAT_ECHOLNPGM(" loaded from storage.");
           }
           else {
             ubl.reset();
-            CHITCHAT_ECHOLNPGM_P(port, "UBL System reset()");
+            CHITCHAT_ECHOLNPGM("UBL System reset()");
           }
         }
       #endif
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      if (!validating) report(PORTVAR_SOLO);
+      if (!validating) report();
     #endif
     EEPROM_FINISH();
 
     return !eeprom_error;
   }
 
-  bool MarlinSettings::validate(PORTARG_SOLO) {
+  bool MarlinSettings::validate() {
     validating = true;
-    const bool success = _load(PORTVAR_SOLO);
+    const bool success = _load();
     validating = false;
     return success;
   }
 
-  bool MarlinSettings::load(PORTARG_SOLO) {
-    if (validate(PORTVAR_SOLO)) return _load(PORTVAR_SOLO);
+  bool MarlinSettings::load() {
+    if (validate()) return _load();
     reset();
     return true;
   }
@@ -2009,8 +1995,8 @@ void MarlinSettings::postprocess() {
 
 #else // !EEPROM_SETTINGS
 
-  bool MarlinSettings::save(PORTARG_SOLO) {
-    CHITCHAT_ERROR_MSG_P(port, "EEPROM disabled");
+  bool MarlinSettings::save() {
+    CHITCHAT_ERROR_MSG("EEPROM disabled");
     return false;
   }
 
@@ -2019,7 +2005,7 @@ void MarlinSettings::postprocess() {
 /**
  * M502 - Reset Configuration
  */
-void MarlinSettings::reset(PORTARG_SOLO) {
+void MarlinSettings::reset() {
   static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
   static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE_N(i) {
@@ -2325,91 +2311,72 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   postprocess();
 
-  CHITCHAT_ECHO_START_P(port);
-  CHITCHAT_ECHOLNPGM_P(port, "Hardcoded Default Settings Loaded");
+  CHITCHAT_ECHO_START();
+  CHITCHAT_ECHOLNPGM("Hardcoded Default Settings Loaded");
 }
 
 #if DISABLED(DISABLE_M503)
 
-  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
-  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(port, STR); }while(0)
-  #define CONFIG_ECHO_HEADING(STR)  do{ if (!forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(port, STR); } }while(0)
+  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
+  #define CONFIG_ECHO_HEADING(STR)  do{ if (!forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); } }while(0)
 
   #if HAS_TRINAMIC
-    void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906"); }
+    void say_M906() { SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
-      void say_M569(PORTARG_BEFORE const char * const etc=NULL) {
-        SERIAL_ECHOPGM_P(port, "  M569 S1");
+      void say_M569(const char * const etc=NULL) {
+        SERIAL_ECHOPGM("  M569 S1");
         if (etc) {
-          SERIAL_CHAR_P(port, ' ');
-          serialprintPGM_P(port, etc);
-          SERIAL_EOL_P(port);
+          SERIAL_CHAR(' ');
+          serialprintPGM(etc);
+          SERIAL_EOL();
         }
       }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
-      void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913"); }
+      void say_M913() { SERIAL_ECHOPGM("  M913"); }
     #endif
     #if USE_SENSORLESS
-      void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914"); }
+      void say_M914() { SERIAL_ECHOPGM("  M914"); }
     #endif
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    void say_M603(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M603 "); }
+    void say_M603() { SERIAL_ECHOPGM("  M603 "); }
   #endif
 
-  inline void say_units(
-    #if NUM_SERIAL > 1
-      const int8_t port,
-    #endif
-    const bool colon
-  ) {
-    serialprintPGM_P(port,
+  inline void say_units(const bool colon) {
+    serialprintPGM(
       #if ENABLED(INCH_MODE_SUPPORT)
         parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
       #endif
       PSTR(" (mm)")
     );
-    if (colon) SERIAL_ECHOLNPGM_P(port, ":");
+    if (colon) SERIAL_ECHOLNPGM(":");
   }
-  #if NUM_SERIAL > 1
-    #define SAY_UNITS_P(PORT, COLON) say_units(PORT, COLON)
-  #else
-    #define SAY_UNITS_P(PORT, COLON) say_units(COLON)
-  #endif
 
-  void report_M92(
-    #if NUM_SERIAL > 1
-      const int8_t port,
-    #endif
-    const bool echo=true, const int8_t e=-1
-  );
+  void report_M92(const bool echo=true, const int8_t e=-1);
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
-  void MarlinSettings::report(const bool forReplay
-    #if NUM_SERIAL > 1
-      , const int8_t port/*=-1*/
-    #endif
-  ) {
+  void MarlinSettings::report(const bool forReplay) {
     /**
      * Announce current units, in case inches are being displayed
      */
     CONFIG_ECHO_START();
     #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHOPGM_P(port, "  G2");
-      SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
-      SERIAL_ECHOPGM_P(port, " ;");
-      SAY_UNITS_P(port, false);
+      SERIAL_ECHOPGM("  G2");
+      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
+      SERIAL_ECHOPGM(" ;");
+      say_units(false);
     #else
-      SERIAL_ECHOPGM_P(port, "  G21    ; Units in mm");
-      SAY_UNITS_P(port, false);
+      SERIAL_ECHOPGM("  G21    ; Units in mm");
+      say_units(false);
     #endif
-    SERIAL_EOL_P(port);
+    SERIAL_EOL();
 
     #if HAS_LCD_MENU
 
@@ -2417,17 +2384,17 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       CONFIG_ECHO_START();
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        SERIAL_ECHOPGM_P(port, "  M149 ");
-        SERIAL_CHAR_P(port, parser.temp_units_code());
-        SERIAL_ECHOPGM_P(port, " ; Units in ");
-        serialprintPGM_P(port, parser.temp_units_name());
+        SERIAL_ECHOPGM("  M149 ");
+        SERIAL_CHAR(parser.temp_units_code());
+        SERIAL_ECHOPGM(" ; Units in ");
+        serialprintPGM(parser.temp_units_name());
       #else
-        SERIAL_ECHOLNPGM_P(port, "  M149 C ; Units in Celsius");
+        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
       #endif
 
     #endif
 
-    SERIAL_EOL_P(port);
+    SERIAL_EOL();
 
     #if DISABLED(NO_VOLUMETRICS)
 
@@ -2436,36 +2403,36 @@ void MarlinSettings::reset(PORTARG_SOLO) {
        */
       if (!forReplay) {
         CONFIG_ECHO_START();
-        SERIAL_ECHOPGM_P(port, "Filament settings:");
+        SERIAL_ECHOPGM("Filament settings:");
         if (parser.volumetric_enabled)
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         else
-          SERIAL_ECHOLNPGM_P(port, " Disabled");
+          SERIAL_ECHOLNPGM(" Disabled");
       }
 
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-      SERIAL_EOL_P(port);
+      SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
+      SERIAL_EOL();
       #if EXTRUDERS > 1
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR_P(port, "  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
-        SERIAL_EOL_P(port);
+        SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
+        SERIAL_EOL();
         #if EXTRUDERS > 2
           CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR_P(port, "  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
-          SERIAL_EOL_P(port);
+          SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
+          SERIAL_EOL();
           #if EXTRUDERS > 3
             CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR_P(port, "  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
-            SERIAL_EOL_P(port);
+            SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
+            SERIAL_EOL();
             #if EXTRUDERS > 4
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(port, "  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
-              SERIAL_EOL_P(port);
+              SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
+              SERIAL_EOL();
               #if EXTRUDERS > 5
                 CONFIG_ECHO_START();
-                SERIAL_ECHOPAIR_P(port, "  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
-                SERIAL_EOL_P(port);
+                SERIAL_ECHOPAIR("  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
+                SERIAL_EOL();
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
@@ -2478,102 +2445,97 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif // !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
-    report_M92(
-      #if NUM_SERIAL > 1
-        port,
-      #endif
-      !forReplay
-    );
+    report_M92(!forReplay);
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR_P(port, "  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]));
+    SERIAL_ECHOPAIR("  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS]));
+      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS]));
     #endif
-    SERIAL_EOL_P(port);
+    SERIAL_EOL();
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR_P(port, "  M203 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)]));
+        SERIAL_ECHOPAIR("  M203 T", (int)i);
+        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)]));
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR_P(port, "  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]));
+    SERIAL_ECHOPAIR("  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS]));
+      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS]));
     #endif
-    SERIAL_EOL_P(port);
+    SERIAL_EOL();
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR_P(port, "  M201 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]));
+        SERIAL_ECHOPAIR("  M201 T", (int)i);
+        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]));
       }
     #endif
 
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR_P(port, "  M204 P", LINEAR_UNIT(planner.settings.acceleration));
-    SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(planner.settings.retract_acceleration));
-    SERIAL_ECHOLNPAIR_P(port, " T", LINEAR_UNIT(planner.settings.travel_acceleration));
+    SERIAL_ECHOPAIR("  M204 P", LINEAR_UNIT(planner.settings.acceleration));
+    SERIAL_ECHOPAIR(" R", LINEAR_UNIT(planner.settings.retract_acceleration));
+    SERIAL_ECHOLNPAIR(" T", LINEAR_UNIT(planner.settings.travel_acceleration));
 
     if (!forReplay) {
       CONFIG_ECHO_START();
-      SERIAL_ECHOPGM_P(port, "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
+      SERIAL_ECHOPGM("Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
       #if ENABLED(JUNCTION_DEVIATION)
-        SERIAL_ECHOPGM_P(port, " J<junc_dev>");
+        SERIAL_ECHOPGM(" J<junc_dev>");
       #endif
       #if HAS_CLASSIC_JERK
-        SERIAL_ECHOPGM_P(port, " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
+        SERIAL_ECHOPGM(" X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
         #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
-          SERIAL_ECHOPGM_P(port, " E<max_e_jerk>");
+          SERIAL_ECHOPGM(" E<max_e_jerk>");
         #endif
       #endif
-      SERIAL_EOL_P(port);
+      SERIAL_EOL();
     }
     CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR_P(port, "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us));
-    SERIAL_ECHOPAIR_P(port, " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s));
-    SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s));
+    SERIAL_ECHOPAIR("  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us));
+    SERIAL_ECHOPAIR(" S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s));
+    SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s));
 
     #if ENABLED(JUNCTION_DEVIATION)
-      SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.junction_deviation_mm));
+      SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.junction_deviation_mm));
     #endif
     #if HAS_CLASSIC_JERK
-      SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
+      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
+      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
       #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
-        SERIAL_ECHOPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+        SERIAL_ECHOPAIR(" E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
       #endif
     #endif
 
-    SERIAL_EOL_P(port);
+    SERIAL_EOL();
 
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(home_offset[Y_AXIS]));
-      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(home_offset[Z_AXIS]));
+      SERIAL_ECHOPAIR("  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(home_offset[Y_AXIS]));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(home_offset[Z_AXIS]));
     #endif
 
     #if HAS_HOTEND_OFFSET
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
       for (uint8_t e = 1; e < HOTENDS; e++) {
-        SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
-        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
-        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
+        SERIAL_ECHOPAIR("  M218 T", (int)e);
+        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
+        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
+        SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
       }
     #endif
 
@@ -2591,7 +2553,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         if (!forReplay) {
           CONFIG_ECHO_START();
           ubl.echo_name();
-          SERIAL_ECHOLNPGM_P(port, ":");
+          SERIAL_ECHOLNPGM(":");
         }
 
       #elif HAS_ABL
@@ -2601,11 +2563,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif
 
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M420 S", planner.leveling_active ? 1 : 0);
+      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.z_fade_height));
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
       #endif
-      SERIAL_EOL_P(port);
+      SERIAL_EOL();
 
       #if ENABLED(MESH_BED_LEVELING)
 
@@ -2613,9 +2575,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
-              SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
-              SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(mbl.z_values[px][py]), 5);
+              SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
+              SERIAL_ECHOPAIR(" Y", (int)py + 1);
+              SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
         }
@@ -2623,14 +2585,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
           ubl.report_state();
-          SERIAL_ECHOLNPAIR_P(port, "\nActive Mesh Slot: ", ubl.storage_slot);
-          SERIAL_ECHOPAIR_P(port, "EEPROM can hold ", calc_num_meshes());
-          SERIAL_ECHOLNPGM_P(port, " meshes.\n");
+          SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
+          SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
+          SERIAL_ECHOLNPGM(" meshes.\n");
         }
 
-       //ubl.report_current_mesh(PORTVAR_SOLO);   // This is too verbose for large meshes. A better (more terse)
+       //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
@@ -2638,9 +2600,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px);
-              SERIAL_ECHOPAIR_P(port, " J", (int)py);
-              SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(z_values[px][py]), 5);
+              SERIAL_ECHOPAIR("  G29 W I", (int)px);
+              SERIAL_ECHOPAIR(" J", (int)py);
+              SERIAL_ECHOLNPAIR_F(" Z", LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
@@ -2665,10 +2627,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
             case Z_PROBE_SERVO_NR:
           #endif
             CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR_P(port, "  M281 P", int(i));
-            SERIAL_ECHOPAIR_P(port, " L", servo_angles[i][0]);
-            SERIAL_ECHOPAIR_P(port, " U", servo_angles[i][1]);
-            SERIAL_EOL_P(port);
+            SERIAL_ECHOPAIR("  M281 P", int(i));
+            SERIAL_ECHOPAIR(" L", servo_angles[i][0]);
+            SERIAL_ECHOPAIR(" U", servo_angles[i][1]);
+            SERIAL_EOL();
           default: break;
         }
       }
@@ -2679,51 +2641,51 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M665 S", delta_segments_per_second);
-      SERIAL_ECHOPAIR_P(port, " P", scara_home_offset[A_AXIS]);
-      SERIAL_ECHOPAIR_P(port, " T", scara_home_offset[B_AXIS]);
-      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(scara_home_offset[Z_AXIS]));
-      SERIAL_EOL_P(port);
+      SERIAL_ECHOPAIR("  M665 S", delta_segments_per_second);
+      SERIAL_ECHOPAIR(" P", scara_home_offset[A_AXIS]);
+      SERIAL_ECHOPAIR(" T", scara_home_offset[B_AXIS]);
+      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(scara_home_offset[Z_AXIS]));
+      SERIAL_EOL();
 
     #elif ENABLED(DELTA)
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
-      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
+      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M665 L", LINEAR_UNIT(delta_diagonal_rod));
-      SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(delta_radius));
-      SERIAL_ECHOPAIR_P(port, " H", LINEAR_UNIT(delta_height));
-      SERIAL_ECHOPAIR_P(port, " S", delta_segments_per_second);
-      SERIAL_ECHOPAIR_P(port, " B", LINEAR_UNIT(delta_calibration_radius));
-      SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
-      SERIAL_EOL_P(port);
+      SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
+      SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
+      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(delta_height));
+      SERIAL_ECHOPAIR(" S", delta_segments_per_second);
+      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
+      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
+      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
+      SERIAL_EOL();
 
     #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPGM_P(port, "  M666");
+      SERIAL_ECHOPGM("  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(endstops.x2_endstop_adj));
+        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(endstops.x2_endstop_adj));
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(endstops.y2_endstop_adj));
+        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstops.y2_endstop_adj));
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
-        SERIAL_ECHOLNPAIR_P(port, "S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
+        SERIAL_ECHOLNPAIR("S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR_P(port, "  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+        SERIAL_ECHOPAIR("  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
       #elif ENABLED(Z_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(endstops.z2_endstop_adj));
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(endstops.z2_endstop_adj));
       #endif
-      SERIAL_EOL_P(port);
+      SERIAL_EOL();
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
@@ -2732,10 +2694,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR_P(port, "  M145 S", (int)i);
-        SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(ui.preheat_hotend_temp[i]));
-        SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(ui.preheat_bed_temp[i]));
-        SERIAL_ECHOLNPAIR_P(port, " F", int(ui.preheat_fan_speed[i]));
+        SERIAL_ECHOPAIR("  M145 S", (int)i);
+        SERIAL_ECHOPAIR(" H", TEMP_UNIT(ui.preheat_hotend_temp[i]));
+        SERIAL_ECHOPAIR(" B", TEMP_UNIT(ui.preheat_bed_temp[i]));
+        SERIAL_ECHOLNPAIR(" F", int(ui.preheat_fan_speed[i]));
       }
 
     #endif
@@ -2748,15 +2710,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           if (forReplay) {
             HOTEND_LOOP() {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(port, "  M301 E", e);
-              SERIAL_ECHOPAIR_P(port, " P", PID_PARAM(Kp, e));
-              SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, e)));
-              SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, e)));
+              SERIAL_ECHOPAIR("  M301 E", e);
+              SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
+              SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
+              SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
               #if ENABLED(PID_EXTRUSION_SCALING)
-                SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, e));
-                if (e == 0) SERIAL_ECHOPAIR_P(port, " L", thermalManager.lpq_len);
+                SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
+                if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
               #endif
-              SERIAL_EOL_P(port);
+              SERIAL_EOL();
             }
           }
           else
@@ -2764,23 +2726,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         // !forReplay || HOTENDS == 1
         {
           CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR_P(port, "  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
-          SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, 0)));
-          SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, 0)));
+          SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
+          SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
+          SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
           #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, 0));
-            SERIAL_ECHOPAIR_P(port, " L", thermalManager.lpq_len);
+            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
+            SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
           #endif
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         }
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_START();
-        SERIAL_ECHOPAIR_P(port, "  M304 P", thermalManager.bed_pid.Kp);
-        SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(thermalManager.bed_pid.Ki));
-        SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(thermalManager.bed_pid.Kd));
-        SERIAL_EOL_P(port);
+        SERIAL_ECHOPAIR("  M304 P", thermalManager.bed_pid.Kp);
+        SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bed_pid.Ki));
+        SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bed_pid.Kd));
+        SERIAL_EOL();
       #endif
 
     #endif // PIDTEMP || PIDTEMPBED
@@ -2788,35 +2750,35 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(port, "  M250 C", ui.contrast);
+      SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
     #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(port, "  M413 S", int(recovery.enabled));
+      SERIAL_ECHOLNPAIR("  M413 S", int(recovery.enabled));
     #endif
 
     #if ENABLED(FWRETRACT)
 
       CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
-      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
-      SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.settings.retract_zraise));
+      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
+      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(fwretract.settings.retract_zraise));
 
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length));
-      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length));
-      SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s)));
+      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length));
+      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s)));
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
 
         CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
         CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(port, "  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+        SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
 
       #endif // FWRETRACT_AUTORETRACT
 
@@ -2828,11 +2790,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_BED_PROBE
       if (!forReplay) {
         CONFIG_ECHO_START();
-        SERIAL_ECHOPGM_P(port, "Z-Probe Offset");
-        SAY_UNITS_P(port, true);
+        SERIAL_ECHOPGM("Z-Probe Offset");
+        say_units(true);
       }
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(port, "  M851 Z", LINEAR_UNIT(zprobe_zoffset));
+      SERIAL_ECHOLNPAIR("  M851 Z", LINEAR_UNIT(zprobe_zoffset));
     #endif
 
     /**
@@ -2842,11 +2804,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_HEADING("Skew Factor: ");
       CONFIG_ECHO_START();
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHOPAIR_F_P(port, "  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
-        SERIAL_ECHOPAIR_F_P(port, " J", LINEAR_UNIT(planner.skew_factor.xz), 6);
-        SERIAL_ECHOLNPAIR_F_P(port, " K", LINEAR_UNIT(planner.skew_factor.yz), 6);
+        SERIAL_ECHOPAIR_F("  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
+        SERIAL_ECHOPAIR_F(" J", LINEAR_UNIT(planner.skew_factor.xz), 6);
+        SERIAL_ECHOLNPAIR_F(" K", LINEAR_UNIT(planner.skew_factor.yz), 6);
       #else
-        SERIAL_ECHOLNPAIR_F_P(port, "  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
+        SERIAL_ECHOLNPAIR_F("  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
       #endif
     #endif
 
@@ -2858,68 +2820,68 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_HEADING("Stepper driver current:");
       CONFIG_ECHO_START();
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        say_M906(PORTVAR_SOLO);
+        say_M906();
       #endif
       #if AXIS_IS_TMC(X)
-        SERIAL_ECHOPAIR_P(port, " X", stepperX.getMilliamps());
+        SERIAL_ECHOPAIR(" X", stepperX.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Y)
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getMilliamps());
+        SERIAL_ECHOPAIR(" Y", stepperY.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Z)
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getMilliamps());
+        SERIAL_ECHOPAIR(" Z", stepperZ.getMilliamps());
       #endif
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        SERIAL_EOL_P(port);
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOPGM_P(port, " I1");
+        say_M906();
+        SERIAL_ECHOPGM(" I1");
       #endif
       #if AXIS_IS_TMC(X2)
-        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getMilliamps());
+        SERIAL_ECHOPAIR(" X", stepperX2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Y2)
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getMilliamps());
+        SERIAL_ECHOPAIR(" Y", stepperY2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Z2)
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getMilliamps());
+        SERIAL_ECHOPAIR(" Z", stepperZ2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        SERIAL_EOL_P(port);
+        SERIAL_EOL();
       #endif
 
       #if AXIS_IS_TMC(Z3)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " I2 Z", stepperZ3.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
       #endif
 
       #if AXIS_IS_TMC(E0)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E1)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E2)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T2 E", stepperE2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E3)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T3 E", stepperE3.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E4)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T4 E", stepperE4.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E5)
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T5 E", stepperE5.getMilliamps());
+        say_M906();
+        SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
       #endif
-      SERIAL_EOL_P(port);
+      SERIAL_EOL();
 
       /**
        * TMC Hybrid Threshold
@@ -2928,69 +2890,69 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         CONFIG_ECHO_HEADING("Hybrid Threshold:");
         CONFIG_ECHO_START();
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
-          say_M913(PORTVAR_SOLO);
+          say_M913();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X)
-          SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
+          SERIAL_ECHOPAIR(" X", TMC_GET_PWMTHRS(X, X));
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
+          SERIAL_ECHOPAIR(" Y", TMC_GET_PWMTHRS(Y, Y));
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
+          SERIAL_ECHOPAIR(" Z", TMC_GET_PWMTHRS(Z, Z));
         #endif
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOPGM_P(port, " I1");
+          say_M913();
+          SERIAL_ECHOPGM(" I1");
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
+          SERIAL_ECHOPAIR(" X", TMC_GET_PWMTHRS(X, X2));
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
+          SERIAL_ECHOPAIR(" Y", TMC_GET_PWMTHRS(Y, Y2));
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
+          SERIAL_ECHOPAIR(" Z", TMC_GET_PWMTHRS(Z, Z2));
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOPGM_P(port, " I2");
-          SERIAL_ECHOLNPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z3));
+          say_M913();
+          SERIAL_ECHOPGM(" I2");
+          SERIAL_ECHOLNPAIR(" Z", TMC_GET_PWMTHRS(Z, Z3));
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T0 E", TMC_GET_PWMTHRS(E, E0));
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T1 E", TMC_GET_PWMTHRS(E, E1));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T1 E", TMC_GET_PWMTHRS(E, E1));
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T2 E", TMC_GET_PWMTHRS(E, E2));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T2 E", TMC_GET_PWMTHRS(E, E2));
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T3 E", TMC_GET_PWMTHRS(E, E3));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T3 E", TMC_GET_PWMTHRS(E, E3));
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, " T5 E", TMC_GET_PWMTHRS(E, E5));
+          say_M913();
+          SERIAL_ECHOLNPAIR(" T5 E", TMC_GET_PWMTHRS(E, E5));
         #endif
-        SERIAL_EOL_P(port);
+        SERIAL_EOL();
       #endif // HYBRID_THRESHOLD
 
       /**
@@ -3000,17 +2962,17 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         CONFIG_ECHO_HEADING("TMC2130 StallGuard threshold:");
         CONFIG_ECHO_START();
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
-          say_M914(PORTVAR_SOLO);
+          say_M914();
           #if X_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
+            SERIAL_ECHOPAIR(" X", stepperX.sgt());
           #endif
           #if Y_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
+            SERIAL_ECHOPAIR(" Y", stepperY.sgt());
           #endif
           #if Z_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " Z", stepperZ.sgt());
+            SERIAL_ECHOPAIR(" Z", stepperZ.sgt());
           #endif
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         #endif
 
         #define HAS_X2_SENSORLESS (defined(X_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
@@ -3018,24 +2980,24 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #define HAS_Z2_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
         #define HAS_Z3_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
         #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
-          say_M914(PORTVAR_SOLO);
-          SERIAL_ECHOPGM_P(port, " I1");
+          say_M914();
+          SERIAL_ECHOPGM(" I1");
           #if HAS_X2_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " X", stepperX2.sgt());
+            SERIAL_ECHOPAIR(" X", stepperX2.sgt());
           #endif
           #if HAS_Y2_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " Y", stepperY2.sgt());
+            SERIAL_ECHOPAIR(" Y", stepperY2.sgt());
           #endif
           #if HAS_Z2_SENSORLESS
-            SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.sgt());
+            SERIAL_ECHOPAIR(" Z", stepperZ2.sgt());
           #endif
-          SERIAL_EOL_P(port);
+          SERIAL_EOL();
         #endif
 
         #if HAS_Z3_SENSORLESS
-          say_M914(PORTVAR_SOLO);
-          SERIAL_ECHOPGM_P(port, " I2");
-          SERIAL_ECHOLNPAIR_P(port, " Z", stepperZ3.sgt());
+          say_M914();
+          SERIAL_ECHOPGM(" I2");
+          SERIAL_ECHOLNPAIR(" Z", stepperZ3.sgt());
         #endif
 
       #endif // USE_SENSORLESS
@@ -3062,11 +3024,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           constexpr bool chop_z = false;
         #endif
 
-        if (chop_x || chop_y || chop_z) say_M569(PORTVAR_SOLO);
-        if (chop_x) SERIAL_ECHOPGM_P(port, " X");
-        if (chop_y) SERIAL_ECHOPGM_P(port, " Y");
-        if (chop_z) SERIAL_ECHOPGM_P(port, " Z");
-        if (chop_x || chop_y || chop_z) SERIAL_EOL_P(port);
+        if (chop_x || chop_y || chop_z) say_M569();
+        if (chop_x) SERIAL_ECHOPGM(" X");
+        if (chop_y) SERIAL_ECHOPGM(" Y");
+        if (chop_z) SERIAL_ECHOPGM(" Z");
+        if (chop_x || chop_y || chop_z) SERIAL_EOL();
 
         #if AXIS_HAS_STEALTHCHOP(X2)
           const bool chop_x2 = stepperX2.get_stealthChop_status();
@@ -3084,33 +3046,33 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           constexpr bool chop_z2 = false;
         #endif
 
-        if (chop_x2 || chop_y2 || chop_z2) say_M569(PORTVAR_BEFORE PSTR("I1"));
-        if (chop_x2) SERIAL_ECHOPGM_P(port, " X");
-        if (chop_y2) SERIAL_ECHOPGM_P(port, " Y");
-        if (chop_z2) SERIAL_ECHOPGM_P(port, " Z");
-        if (chop_x2 || chop_y2 || chop_z2) SERIAL_EOL_P(port);
+        if (chop_x2 || chop_y2 || chop_z2) say_M569(PSTR("I1"));
+        if (chop_x2) SERIAL_ECHOPGM(" X");
+        if (chop_y2) SERIAL_ECHOPGM(" Y");
+        if (chop_z2) SERIAL_ECHOPGM(" Z");
+        if (chop_x2 || chop_y2 || chop_z2) SERIAL_EOL();
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("I2 Z")); }
+          if (stepperZ3.get_stealthChop_status()) { say_M569(PSTR("I2 Z")); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T0 E")); }
+          if (stepperE0.get_stealthChop_status()) { say_M569(PSTR("T0 E")); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T1 E")); }
+          if (stepperE1.get_stealthChop_status()) { say_M569(PSTR("T1 E")); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T2 E")); }
+          if (stepperE2.get_stealthChop_status()) { say_M569(PSTR("T2 E")); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T3 E")); }
+          if (stepperE3.get_stealthChop_status()) { say_M569(PSTR("T3 E")); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T4 E")); }
+          if (stepperE4.get_stealthChop_status()) { say_M569(PSTR("T4 E")); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T5 E")); }
+          if (stepperE5.get_stealthChop_status()) { say_M569(PSTR("T5 E")); }
         #endif
 
       #endif // HAS_STEALTHCHOP
@@ -3124,11 +3086,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_HEADING("Linear Advance:");
       CONFIG_ECHO_START();
       #if EXTRUDERS < 2
-        SERIAL_ECHOLNPAIR_P(port, "  M900 K", planner.extruder_advance_K[0]);
+        SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
       #else
         LOOP_L_N(i, EXTRUDERS) {
-          SERIAL_ECHOPAIR_P(port, "  M900 T", int(i));
-          SERIAL_ECHOLNPAIR_P(port, " K", planner.extruder_advance_K[i]);
+          SERIAL_ECHOPAIR("  M900 T", int(i));
+          SERIAL_ECHOLNPAIR(" K", planner.extruder_advance_K[i]);
         }
       #endif
     #endif
@@ -3136,10 +3098,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOPAIR_P(port, "  M907 X", stepper.motor_current_setting[0]);
-      SERIAL_ECHOPAIR_P(port, " Z", stepper.motor_current_setting[1]);
-      SERIAL_ECHOPAIR_P(port, " E", stepper.motor_current_setting[2]);
-      SERIAL_EOL_P(port);
+      SERIAL_ECHOPAIR("  M907 X", stepper.motor_current_setting[0]);
+      SERIAL_ECHOPAIR(" Z", stepper.motor_current_setting[1]);
+      SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
+      SERIAL_EOL();
     #endif
 
     /**
@@ -3149,37 +3111,37 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       CONFIG_ECHO_START();
       #if EXTRUDERS == 1
-        say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(fc_settings[0].load_length));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[0].unload_length));
+        say_M603();
+        SERIAL_ECHOPAIR("L", LINEAR_UNIT(fc_settings[0].load_length));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
-        say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(fc_settings[0].load_length));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[0].unload_length));
+        say_M603();
+        SERIAL_ECHOPAIR("T0 L", LINEAR_UNIT(fc_settings[0].load_length));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[0].unload_length));
         CONFIG_ECHO_START();
-        say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(fc_settings[1].load_length));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[1].unload_length));
+        say_M603();
+        SERIAL_ECHOPAIR("T1 L", LINEAR_UNIT(fc_settings[1].load_length));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[1].unload_length));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START();
-          say_M603(PORTVAR_SOLO);
-          SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(fc_settings[2].load_length));
-          SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[2].unload_length));
+          say_M603();
+          SERIAL_ECHOPAIR("T2 L", LINEAR_UNIT(fc_settings[2].load_length));
+          SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[2].unload_length));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START();
-            say_M603(PORTVAR_SOLO);
-            SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(fc_settings[3].load_length));
-            SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[3].unload_length));
+            say_M603();
+            SERIAL_ECHOPAIR("T3 L", LINEAR_UNIT(fc_settings[3].load_length));
+            SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[3].unload_length));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START();
-              say_M603(PORTVAR_SOLO);
-              SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(fc_settings[4].load_length));
-              SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[4].unload_length));
+              say_M603();
+              SERIAL_ECHOPAIR("T4 L", LINEAR_UNIT(fc_settings[4].load_length));
+              SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[4].unload_length));
               #if EXTRUDERS > 5
                 CONFIG_ECHO_START();
-                say_M603(PORTVAR_SOLO);
-                SERIAL_ECHOPAIR_P(port, "T5 L", LINEAR_UNIT(fc_settings[5].load_length));
-                SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[5].unload_length));
+                say_M603();
+                SERIAL_ECHOPAIR("T5 L", LINEAR_UNIT(fc_settings[5].load_length));
+                SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(fc_settings[5].unload_length));
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3

commit 3c9a7926c22141fbae6e5c6c8538a4894bd15163
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 20 04:54:17 2019 -0600

    Fix compile error with JUNCTION_DEVIATION
    
    See #13000

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e3aafc4968..9270b3a747 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2036,6 +2036,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   planner.settings.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
 
   #if HAS_CLASSIC_JERK
+    #ifndef DEFAULT_XJERK
+      #define DEFAULT_XJERK 0
+    #endif
+    #ifndef DEFAULT_YJERK
+      #define DEFAULT_YJERK 0
+    #endif
+    #ifndef DEFAULT_ZJERK
+      #define DEFAULT_ZJERK 0
+    #endif
     planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
     planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
     planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e53c0dd532..e3aafc4968 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 524c6c10bf52b9956ca2f68eb3d3074e5cba0706
Author: Rolf Werum <39219447+Weruminger@users.noreply.github.com>
Date:   Wed Feb 6 13:30:53 2019 +0100

    MAGNETIC_PARKING_EXTRUDER (#12351)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3e66751a86..e53c0dd532 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2078,6 +2078,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
 
+  #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
+    mpe_settings_init();
+  #endif
+
   //
   // Global Leveling
   //

commit 4200bd2fc12627843027b9961ef7a96f05e01340
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 4 05:24:15 2019 -0600

    Report on M92 with no arguments (#12833)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f2730924b2..3e66751a86 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2366,6 +2366,13 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #define SAY_UNITS_P(PORT, COLON) say_units(COLON)
   #endif
 
+  void report_M92(
+    #if NUM_SERIAL > 1
+      const int8_t port,
+    #endif
+    const bool echo=true, const int8_t e=-1
+  );
+
   /**
    * M503 - Report current settings in RAM
    *
@@ -2458,21 +2465,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif // !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOPAIR_P(port, "  M92 X", LINEAR_UNIT(planner.settings.axis_steps_per_mm[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Z_AXIS]));
-    #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.axis_steps_per_mm[E_AXIS]));
-    #endif
-    SERIAL_EOL_P(port);
-    #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START();
-      for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR_P(port, "  M92 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.axis_steps_per_mm[E_AXIS + i]));
-      }
-    #endif
+    report_M92(
+      #if NUM_SERIAL > 1
+        port,
+      #endif
+      !forReplay
+    );
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f42cfa215d..f2730924b2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -89,7 +89,7 @@
 #endif
 
 #if HAS_BED_PROBE
-  #include "../module/probe.h"
+  #include "probe.h"
 #endif
 
 #include "../feature/fwretract.h"

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index cadec09c43..f42cfa215d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1961,7 +1961,7 @@ void MarlinSettings::postprocess() {
         const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
         persistentStore.access_finish();
 
-        if (status) SERIAL_ECHOPGM("?Unable to save mesh data.\n");
+        if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
         else        CHITCHAT_ECHOLNPAIR("Mesh saved in slot ", slot);
 
       #else
@@ -1990,7 +1990,7 @@ void MarlinSettings::postprocess() {
         const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
         persistentStore.access_finish();
 
-        if (status) SERIAL_ECHOPGM("?Unable to load mesh data.\n");
+        if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        CHITCHAT_ECHOLNPAIR("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8f986006ed..cadec09c43 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V63"
+#define EEPROM_VERSION "V64"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -48,12 +48,16 @@
 
 #if ADD_PORT_ARG
   #define PORTARG_SOLO     const int8_t port
+  #define PORTARG_BEFORE   const int8_t port,
   #define PORTARG_AFTER   ,const int8_t port
   #define PORTVAR_SOLO     port
+  #define PORTVAR_BEFORE   port,
 #else
   #define PORTARG_SOLO
+  #define PORTARG_BEFORE
   #define PORTARG_AFTER
   #define PORTVAR_SOLO
+  #define PORTVAR_BEFORE
 #endif
 
 #include "endstops.h"
@@ -112,6 +116,7 @@
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
 typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
 typedef struct {  int16_t X, Y, Z;                                         } tmc_sgt_t;
+typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) MIN(I, COUNT(ARR) - 1)
@@ -256,6 +261,7 @@ typedef struct SettingsDataStruct {
   tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   tmc_sgt_t tmc_sgt;                                    // M914 X Y Z
+  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
 
   //
   // LIN_ADVANCE
@@ -974,6 +980,70 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(tmc_sgt);
     }
 
+    //
+    // TMC stepping mode
+    //
+    {
+      _FIELD_TEST(tmc_stealth_enabled);
+
+      tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
+
+      #if HAS_STEALTHCHOP
+        #if AXIS_HAS_STEALTHCHOP(X)
+          tmc_stealth_enabled.X = stepperX.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          tmc_stealth_enabled.Y = stepperY.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          tmc_stealth_enabled.Z = stepperZ.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          tmc_stealth_enabled.X2 = stepperX2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          tmc_stealth_enabled.Y2 = stepperY2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          tmc_stealth_enabled.Z2 = stepperZ2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          tmc_stealth_enabled.Z3 = stepperZ3.get_stealthChop_status();
+        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_HAS_STEALTHCHOP(E0)
+            tmc_stealth_enabled.E0 = stepperE0.get_stealthChop_status();
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              tmc_stealth_enabled.E1 = stepperE1.get_stealthChop_status();
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_HAS_STEALTHCHOP(E2)
+                tmc_stealth_enabled.E2 = stepperE2.get_stealthChop_status();
+              #endif
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_HAS_STEALTHCHOP(E3)
+                  tmc_stealth_enabled.E3 = stepperE3.get_stealthChop_status();
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_HAS_STEALTHCHOP(E4)
+                    tmc_stealth_enabled.E4 = stepperE4.get_stealthChop_status();
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_HAS_STEALTHCHOP(E5)
+                      tmc_stealth_enabled.E5 = stepperE5.get_stealthChop_status();
+                    #endif
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #endif
+      EEPROM_WRITE(tmc_stealth_enabled);
+    }
+
     //
     // Linear Advance
     //
@@ -1630,6 +1700,60 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      // TMC stepping mode
+      {
+        _FIELD_TEST(tmc_stealth_enabled);
+
+        tmc_stealth_enabled_t tmc_stealth_enabled;
+        EEPROM_READ(tmc_stealth_enabled);
+
+        #if HAS_TRINAMIC
+
+          #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
+          if (!validating) {
+            #if AXIS_HAS_STEALTHCHOP(X)
+              SET_STEPPING_MODE(X);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y)
+              SET_STEPPING_MODE(Y);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z)
+              SET_STEPPING_MODE(Z);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(X2)
+              SET_STEPPING_MODE(X2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y2)
+              SET_STEPPING_MODE(Y2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z2)
+              SET_STEPPING_MODE(Z2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z3)
+              SET_STEPPING_MODE(Z3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E0)
+              SET_STEPPING_MODE(E0);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              SET_STEPPING_MODE(E1);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E2)
+              SET_STEPPING_MODE(E2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E3)
+              SET_STEPPING_MODE(E3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E4)
+              SET_STEPPING_MODE(E4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E5)
+              SET_STEPPING_MODE(E5);
+            #endif
+          }
+        #endif
+      }
+
       //
       // Linear Advance
       //
@@ -2200,6 +2324,16 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #if HAS_TRINAMIC
     void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906"); }
+    #if HAS_STEALTHCHOP
+      void say_M569(PORTARG_BEFORE const char * const etc=NULL) {
+        SERIAL_ECHOPGM_P(port, "  M569 S1");
+        if (etc) {
+          SERIAL_CHAR_P(port, ' ');
+          serialprintPGM_P(port, etc);
+          SERIAL_EOL_P(port);
+        }
+      }
+    #endif
     #if ENABLED(HYBRID_THRESHOLD)
       void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913"); }
     #endif
@@ -2895,6 +3029,81 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       #endif // USE_SENSORLESS
 
+      /**
+       * TMC stepping mode
+       */
+      #if HAS_STEALTHCHOP
+        CONFIG_ECHO_HEADING("Driver stepping mode:");
+        CONFIG_ECHO_START();
+        #if AXIS_HAS_STEALTHCHOP(X)
+          const bool chop_x = stepperX.get_stealthChop_status();
+        #else
+          constexpr bool chop_x = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          const bool chop_y = stepperY.get_stealthChop_status();
+        #else
+          constexpr bool chop_y = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          const bool chop_z = stepperZ.get_stealthChop_status();
+        #else
+          constexpr bool chop_z = false;
+        #endif
+
+        if (chop_x || chop_y || chop_z) say_M569(PORTVAR_SOLO);
+        if (chop_x) SERIAL_ECHOPGM_P(port, " X");
+        if (chop_y) SERIAL_ECHOPGM_P(port, " Y");
+        if (chop_z) SERIAL_ECHOPGM_P(port, " Z");
+        if (chop_x || chop_y || chop_z) SERIAL_EOL_P(port);
+
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          const bool chop_x2 = stepperX2.get_stealthChop_status();
+        #else
+          constexpr bool chop_x2 = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          const bool chop_y2 = stepperY2.get_stealthChop_status();
+        #else
+          constexpr bool chop_y2 = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          const bool chop_z2 = stepperZ2.get_stealthChop_status();
+        #else
+          constexpr bool chop_z2 = false;
+        #endif
+
+        if (chop_x2 || chop_y2 || chop_z2) say_M569(PORTVAR_BEFORE PSTR("I1"));
+        if (chop_x2) SERIAL_ECHOPGM_P(port, " X");
+        if (chop_y2) SERIAL_ECHOPGM_P(port, " Y");
+        if (chop_z2) SERIAL_ECHOPGM_P(port, " Z");
+        if (chop_x2 || chop_y2 || chop_z2) SERIAL_EOL_P(port);
+
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          if (stepperZ3.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("I2 Z")); }
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(E0)
+          if (stepperE0.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T0 E")); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E1)
+          if (stepperE1.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T1 E")); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E2)
+          if (stepperE2.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T2 E")); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E3)
+          if (stepperE3.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T3 E")); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E4)
+          if (stepperE4.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T4 E")); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E5)
+          if (stepperE5.get_stealthChop_status()) { say_M569(PORTVAR_BEFORE PSTR("T5 E")); }
+        #endif
+
+      #endif // HAS_STEALTHCHOP
+
     #endif // HAS_TRINAMIC
 
     /**

commit 19fea772e5eba0b850512123f10c9c72868d75a4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 11 19:37:20 2019 -0600

    Use E_AXIS_N where it makes sense

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 29058e3233..8f986006ed 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2353,7 +2353,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M203 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS + i]));
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)]));
       }
     #endif
 
@@ -2370,7 +2370,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M201 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS + i]));
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]));
       }
     #endif
 

commit 371d9a1acf6a87f42b76c602b1a542e1bdd37b26
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 30 12:20:30 2018 -0600

    Fix line-endings, formatting, whitespace
    
    Followup to #12770

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 03bf2650c4..29058e3233 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -488,7 +488,7 @@ void MarlinSettings::postprocess() {
           EEPROM_WRITE(dummy);
         #endif
       #else
-        const float planner_max_jerk[XYZE] = { float(DEFAULT_EJERK) };	
+        const float planner_max_jerk[XYZE] = { float(DEFAULT_EJERK) };
         EEPROM_WRITE(planner_max_jerk);
       #endif
 

commit 135c74017c55d51f31bc11e9449121b67e6f79a2
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Dec 30 18:37:20 2018 +0100

    Fix compile DEBUG_EEPROM_READWRITE error (#12746)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 5849c683c9..03bf2650c4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -487,6 +487,9 @@ void MarlinSettings::postprocess() {
           dummy = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummy);
         #endif
+      #else
+        const float planner_max_jerk[XYZE] = { float(DEFAULT_EJERK) };	
+        EEPROM_WRITE(planner_max_jerk);
       #endif
 
       #if ENABLED(JUNCTION_DEVIATION)
@@ -693,7 +696,7 @@ void MarlinSettings::postprocess() {
     // LCD Preheat settings
     //
     {
-      _FIELD_TEST(lcd_preheat_hotend_temp);
+      _FIELD_TEST(ui_preheat_hotend_temp);
 
       #if HAS_LCD_MENU
         const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,

commit cfc5e96b4b316683391c7acae5b298a59fc7cba2
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Thu Dec 27 22:29:39 2018 +0100

    Move JD to Config.h (and fix jerk->eeprom bug) (#12720)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9d7451588e..5849c683c9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -487,9 +487,6 @@ void MarlinSettings::postprocess() {
           dummy = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummy);
         #endif
-      #else
-        const float planner_max_jerk[XYZE] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
-        EEPROM_WRITE(planner_max_jerk);
       #endif
 
       #if ENABLED(JUNCTION_DEVIATION)

commit e8bda62d2af42e68035f1a3de007b14a28f5d08a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 8 15:31:32 2018 -0600

    Followup to servo angles patch
    
    Fix #12594

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 796f5477cb..9d7451588e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -76,6 +76,9 @@
 
 #if HAS_SERVOS
   #include "servo.h"
+#endif
+
+#if HAS_SERVOS && HAS_SERVO_ANGLES
   #define EEPROM_NUM_SERVOS NUM_SERVOS
 #else
   #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
@@ -634,8 +637,8 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(servo_angles);
 
-      #if !HAS_SERVOS
-        uint16_t servo_angles[NUM_SERVO_PLUGS][2] = { { 0, 0 } };
+      #if !HAS_SERVO_ANGLES
+        uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
       #endif
       EEPROM_WRITE(servo_angles);
     }

commit aaf862aef22caa136f4aa63d9fcc4e71c164ae33
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 30 12:31:42 2018 -0600

    Fix angles for disabled EDITABLE_SERVO_ANGLES (#12559)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 03fa5a3da9..796f5477cb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -76,9 +76,9 @@
 
 #if HAS_SERVOS
   #include "servo.h"
+  #define EEPROM_NUM_SERVOS NUM_SERVOS
 #else
-  #undef NUM_SERVOS
-  #define NUM_SERVOS NUM_SERVO_PLUGS
+  #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
 #endif
 
 #if HAS_BED_PROBE
@@ -187,7 +187,7 @@ typedef struct SettingsDataStruct {
   //
   // SERVO_ANGLES
   //
-  uint16_t servo_angles[NUM_SERVOS][2];                 // M281 P L U
+  uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
 
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
@@ -632,36 +632,11 @@ void MarlinSettings::postprocess() {
     // Servo Angles
     //
     {
-      #if !(HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES))
-
-        uint16_t servo_angles[NUM_SERVOS][2] = { { 0, 0 } };
-
-        #if ENABLED(SWITCHING_EXTRUDER)
-
-          constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-          servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = sesa[0][0];
-          servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = sesa[0][1];
-          #if EXTRUDERS > 3
-            servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = sesa[1][0];
-            servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = sesa[1][1];
-          #endif
-
-        #elif ENABLED(SWITCHING_NOZZLE)
-
-          constexpr uint16_t snsa[] = SWITCHING_NOZZLE_SERVO_ANGLES;
-          servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = snsa[0];
-          servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = snsa[1];
-
-        #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
-
-          constexpr uint16_t zsa[] = Z_SERVO_ANGLES;
-          servo_angles[Z_PROBE_SERVO_NR][0] = zsa[0];
-          servo_angles[Z_PROBE_SERVO_NR][1] = zsa[1];
-
-        #endif
-
-      #endif // !HAS_SERVOS || !EDITABLE_SERVO_ANGLES
+      _FIELD_TEST(servo_angles);
 
+      #if !HAS_SERVOS
+        uint16_t servo_angles[NUM_SERVO_PLUGS][2] = { { 0, 0 } };
+      #endif
       EEPROM_WRITE(servo_angles);
     }
 
@@ -1311,10 +1286,14 @@ void MarlinSettings::postprocess() {
       // SERVO_ANGLES
       //
       {
-        #if !(HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES))
-          uint16_t servo_angles[NUM_SERVOS][2];
+        _FIELD_TEST(servo_angles);
+
+        #if ENABLED(EDITABLE_SERVO_ANGLES)
+          uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
+        #else
+          uint16_t servo_angles_arr[EEPROM_NUM_SERVOS][2];
         #endif
-        EEPROM_READ(servo_angles);
+        EEPROM_READ(servo_angles_arr);
       }
 
       //
@@ -1992,39 +1971,13 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   // Servo Angles
   //
 
-  #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
-
-    #if ENABLED(SWITCHING_EXTRUDER)
-
-      #if EXTRUDERS > 3
-        #define REQ_ANGLES 4
-      #else
-        #define REQ_ANGLES 2
-      #endif
-      constexpr uint16_t sesa[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-      static_assert(COUNT(sesa) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
-      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = sesa[0];
-      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = sesa[1];
-      #if EXTRUDERS > 3
-        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = sesa[2];
-        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = sesa[3];
-      #endif
-
-    #elif ENABLED(SWITCHING_NOZZLE)
-
-      constexpr uint16_t snsa[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = snsa[0];
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = snsa[1];
-
-    #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
-
-      constexpr uint16_t zsa[2] = Z_SERVO_ANGLES;
-      servo_angles[Z_PROBE_SERVO_NR][0] = zsa[0];
-      servo_angles[Z_PROBE_SERVO_NR][1] = zsa[1];
-
-    #endif
+  #if ENABLED(EDITABLE_SERVO_ANGLES)
+    COPY(servo_angles, base_servo_angles);
+  #endif
 
-  #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
+  //
+  // Endstop Adjustments
+  //
 
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ, dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
@@ -2083,6 +2036,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #endif
 
+  //
+  // Preheat parameters
+  //
+
   #if HAS_LCD_MENU
     ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
     ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
@@ -2092,6 +2049,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     ui.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
   #endif
 
+  //
+  // Hotend PID
+  //
+
   #if ENABLED(PIDTEMP)
     HOTEND_LOOP() {
       PID_PARAM(Kp, e) = float(DEFAULT_Kp);
@@ -2101,10 +2062,19 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         PID_PARAM(Kc, e) = DEFAULT_Kc;
       #endif
     }
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      thermalManager.lpq_len = 20; // default last-position-queue size
-    #endif
-  #endif // PIDTEMP
+  #endif
+
+  //
+  // PID Extrusion Scaling
+  //
+
+  #if ENABLED(PID_EXTRUSION_SCALING)
+    thermalManager.lpq_len = 20;  // Default last-position-queue size
+  #endif
+
+  //
+  // Heated Bed PID
+  //
 
   #if ENABLED(PIDTEMPBED)
     thermalManager.bed_pid.Kp = DEFAULT_bedKp;
@@ -2112,18 +2082,34 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     thermalManager.bed_pid.Kd = scalePID_d(DEFAULT_bedKd);
   #endif
 
+  //
+  // LCD Contrast
+  //
+
   #if HAS_LCD_CONTRAST
     ui.set_contrast(DEFAULT_LCD_CONTRAST);
   #endif
 
+  //
+  // Power-Loss Recovery
+  //
+
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.enable(true);
   #endif
 
+  //
+  // Firmware Retraction
+  //
+
   #if ENABLED(FWRETRACT)
     fwretract.reset();
   #endif
 
+  //
+  // Volumetric & Filament Size
+  //
+
   #if DISABLED(NO_VOLUMETRICS)
 
     parser.volumetric_enabled =
@@ -2148,16 +2134,36 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   reset_stepper_drivers();
 
+  //
+  // Linear Advance
+  //
+
   #if ENABLED(LIN_ADVANCE)
     LOOP_L_N(i, EXTRUDERS) planner.extruder_advance_K[i] = LIN_ADVANCE_K;
   #endif
 
+  //
+  // Motor Current PWM
+  //
+
   #if HAS_MOTOR_CURRENT_PWM
     uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
     for (uint8_t q = 3; q--;)
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 
+  //
+  // CNC Coordinate System
+  //
+
+  #if ENABLED(CNC_COORDINATE_SYSTEMS)
+    (void)gcode.select_coordinate_system(-1); // Go back to machine space
+  #endif
+
+  //
+  // Skew Correction
+  //
+
   #if ENABLED(SKEW_CORRECTION_GCODE)
     planner.skew_factor.xy = XY_SKEW_FACTOR;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
@@ -2166,6 +2172,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
   #endif
 
+  //
+  // Advanced Pause filament load & unload lengths
+  //
+
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     for (uint8_t e = 0; e < EXTRUDERS; e++) {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
@@ -2491,7 +2501,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #endif // HAS_LEVELING
 
-    #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
+    #if ENABLED(EDITABLE_SERVO_ANGLES)
 
       CONFIG_ECHO_HEADING("Servo Angles:");
       for (uint8_t i = 0; i < NUM_SERVOS; i++) {
@@ -2515,7 +2525,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         }
       }
 
-    #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
+    #endif // EDITABLE_SERVO_ANGLES
 
     #if HAS_SCARA_OFFSET
 

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2da6ea3eb2..03fa5a3da9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -384,6 +384,36 @@ void MarlinSettings::postprocess() {
 
 #endif // SD_FIRMWARE_UPDATE
 
+#if ENABLED(EEPROM_CHITCHAT)
+  #define CHITCHAT_ECHO(V)                      SERIAL_ECHO(V)
+  #define CHITCHAT_ECHOLNPGM(STR)               SERIAL_ECHOLNPGM(STR)
+  #define CHITCHAT_ECHOPAIR(STR,V)              SERIAL_ECHOPAIR(STR,V)
+  #define CHITCHAT_ECHOLNPAIR(STR,V)            SERIAL_ECHOLNPAIR(STR,V)
+  #define CHITCHAT_ECHO_START_P(port)           SERIAL_ECHO_START_P(port)
+  #define CHITCHAT_ERROR_START_P(port)          SERIAL_ERROR_START_P(port)
+  #define CHITCHAT_ERROR_MSG_P(port, STR)       SERIAL_ERROR_MSG_P(port, STR)
+  #define CHITCHAT_ECHO_P(port, VAL)            SERIAL_ECHO_P(port, VAL)
+  #define CHITCHAT_ECHOPGM_P(port, STR)         SERIAL_ECHOPGM_P(port, STR)
+  #define CHITCHAT_ECHOLNPGM_P(port, STR)       SERIAL_ECHOLNPGM_P(port, STR)
+  #define CHITCHAT_ECHOPAIR_P(port, STR, VAL)   SERIAL_ECHOPAIR_P(port, STR, VAL)
+  #define CHITCHAT_ECHOLNPAIR_P(port, STR, VAL) SERIAL_ECHOLNPAIR_P(port, STR, VAL)
+  #define CHITCHAT_EOL()                        SERIAL_EOL()
+#else
+  #define CHITCHAT_ECHO(V)                      NOOP
+  #define CHITCHAT_ECHOLNPGM(STR)               NOOP
+  #define CHITCHAT_ECHOPAIR(STR,V)              NOOP
+  #define CHITCHAT_ECHOLNPAIR(STR,V)            NOOP
+  #define CHITCHAT_ECHO_START_P(port)           NOOP
+  #define CHITCHAT_ERROR_START_P(port)          NOOP
+  #define CHITCHAT_ERROR_MSG_P(port, STR)       NOOP
+  #define CHITCHAT_ECHO_P(port, VAL)            NOOP
+  #define CHITCHAT_ECHOPGM_P(port, STR)         NOOP
+  #define CHITCHAT_ECHOLNPGM_P(port, STR)       NOOP
+  #define CHITCHAT_ECHOPAIR_P(port, STR, VAL)   NOOP
+  #define CHITCHAT_ECHOLNPAIR_P(port, STR, VAL) NOOP
+  #define CHITCHAT_EOL()                        NOOP
+#endif
+
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
@@ -392,7 +422,7 @@ void MarlinSettings::postprocess() {
   #define EEPROM_WRITE(VAR) persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_READ(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
   #define EEPROM_READ_ALWAYS(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_START_P(port); SERIAL_ERRORLNPGM_P(port, ERR); eeprom_error = true; } }while(0)
+  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_MSG_P(port, ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
@@ -410,10 +440,7 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::size_error(const uint16_t size PORTARG_AFTER) {
     if (size != datasize()) {
-      #if ENABLED(EEPROM_CHITCHAT)
-        SERIAL_ERROR_START_P(port);
-        SERIAL_ERRORLNPGM_P(port, "EEPROM datasize error.");
-      #endif
+      CHITCHAT_ERROR_MSG_P(port, "EEPROM datasize error.");
       return true;
     }
     return false;
@@ -1050,12 +1077,10 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(final_crc);
 
       // Report storage size
-      #if ENABLED(EEPROM_CHITCHAT)
-        SERIAL_ECHO_START_P(port);
-        SERIAL_ECHOPAIR_P(port, "Settings Stored (", eeprom_size);
-        SERIAL_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)final_crc);
-        SERIAL_ECHOLNPGM_P(port, ")");
-      #endif
+      CHITCHAT_ECHO_START_P(port);
+      CHITCHAT_ECHOPAIR_P(port, "Settings Stored (", eeprom_size);
+      CHITCHAT_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)final_crc);
+      CHITCHAT_ECHOLNPGM_P(port, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
@@ -1092,12 +1117,10 @@ void MarlinSettings::postprocess() {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
-      #if ENABLED(EEPROM_CHITCHAT)
-        SERIAL_ECHO_START_P(port);
-        SERIAL_ECHOPGM_P(port, "EEPROM version mismatch ");
-        SERIAL_ECHOPAIR_P(port, "(EEPROM=", stored_ver);
-        SERIAL_ECHOLNPGM_P(port, " Marlin=" EEPROM_VERSION ")");
-      #endif
+      CHITCHAT_ECHO_START_P(port);
+      CHITCHAT_ECHOPGM_P(port, "EEPROM version mismatch ");
+      CHITCHAT_ECHOPAIR_P(port, "(EEPROM=", stored_ver);
+      CHITCHAT_ECHOLNPGM_P(port, " Marlin=" EEPROM_VERSION ")");
       eeprom_error = true;
     }
     else {
@@ -1704,31 +1727,25 @@ void MarlinSettings::postprocess() {
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ECHO_START_P(port);
-          SERIAL_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
-          SERIAL_ECHOLNPAIR_P(port, " Size: ", datasize());
-        #endif
+        CHITCHAT_ECHO_START_P(port);
+        CHITCHAT_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
+        CHITCHAT_ECHOLNPAIR_P(port, " Size: ", datasize());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
-        #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ERROR_START_P(port);
-          SERIAL_ERRORPGM_P(port, "EEPROM CRC mismatch - (stored) ");
-          SERIAL_ERROR_P(port, stored_crc);
-          SERIAL_ERRORPGM_P(port, " != ");
-          SERIAL_ERROR_P(port, working_crc);
-          SERIAL_ERRORLNPGM_P(port, " (calculated)!");
-        #endif
+        CHITCHAT_ERROR_START_P(port);
+        CHITCHAT_ECHOPGM_P(port, "EEPROM CRC mismatch - (stored) ");
+        CHITCHAT_ECHO_P(port, stored_crc);
+        CHITCHAT_ECHOPGM_P(port, " != ");
+        CHITCHAT_ECHO_P(port, working_crc);
+        CHITCHAT_ECHOLNPGM_P(port, " (calculated)!");
       }
       else if (!validating) {
-        #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ECHO_START_P(port);
-          SERIAL_ECHO_P(port, version);
-          SERIAL_ECHOPAIR_P(port, " stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-          SERIAL_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)working_crc);
-          SERIAL_ECHOLNPGM_P(port, ")");
-        #endif
+        CHITCHAT_ECHO_START_P(port);
+        CHITCHAT_ECHO_P(port, version);
+        CHITCHAT_ECHOPAIR_P(port, " stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+        CHITCHAT_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)working_crc);
+        CHITCHAT_ECHOLNPGM_P(port, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
@@ -1741,31 +1758,27 @@ void MarlinSettings::postprocess() {
             SERIAL_EOL_P(port);
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();
-              SERIAL_ECHOLNPGM_P(port, " initialized.\n");
+              CHITCHAT_ECHOLNPGM_P(port, " initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_PROTOCOLPGM_P(port, "?Can't enable ");
+              CHITCHAT_ECHOPGM_P(port, "?Can't enable ");
               ubl.echo_name();
-              SERIAL_PROTOCOLLNPGM_P(port, ".");
+              CHITCHAT_ECHOLNPGM_P(port, ".");
             #endif
             ubl.reset();
           }
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
-            #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_ECHOPAIR_P(port, "Mesh ", ubl.storage_slot);
-              SERIAL_ECHOLNPGM_P(port, " loaded from storage.");
-            #endif
+            CHITCHAT_ECHOPAIR_P(port, "Mesh ", ubl.storage_slot);
+            CHITCHAT_ECHOLNPGM_P(port, " loaded from storage.");
           }
           else {
             ubl.reset();
-            #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_ECHOLNPGM_P(port, "UBL System reset()");
-            #endif
+            CHITCHAT_ECHOLNPGM_P(port, "UBL System reset()");
           }
         }
       #endif
@@ -1794,13 +1807,15 @@ void MarlinSettings::postprocess() {
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-    #if ENABLED(EEPROM_CHITCHAT)
-      void ubl_invalid_slot(const int s) {
-        SERIAL_PROTOCOLLNPGM("?Invalid slot.");
-        SERIAL_PROTOCOL(s);
-        SERIAL_PROTOCOLLNPGM(" mesh slots available.");
-      }
-    #endif
+    inline void ubl_invalid_slot(const int s) {
+      #if ENABLED(EEPROM_CHITCHAT)
+        CHITCHAT_ECHOLNPGM("?Invalid slot.");
+        CHITCHAT_ECHO(s);
+        CHITCHAT_ECHOLNPGM(" mesh slots available.");
+      #else
+        UNUSED(s);
+      #endif
+    }
 
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
                                                                                   // is a placeholder for the size of the MAT; the MAT will always
@@ -1824,32 +1839,24 @@ void MarlinSettings::postprocess() {
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
-          #if ENABLED(EEPROM_CHITCHAT)
-            ubl_invalid_slot(a);
-            SERIAL_PROTOCOLPAIR("E2END=", persistentStore.capacity() - 1);
-            SERIAL_PROTOCOLPAIR(" meshes_end=", meshes_end);
-            SERIAL_PROTOCOLLNPAIR(" slot=", slot);
-            SERIAL_EOL();
-          #endif
+          ubl_invalid_slot(a);
+          CHITCHAT_ECHOPAIR("E2END=", persistentStore.capacity() - 1);
+          CHITCHAT_ECHOPAIR(" meshes_end=", meshes_end);
+          CHITCHAT_ECHOLNPAIR(" slot=", slot);
+          CHITCHAT_EOL();
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
 
+        // Write crc to MAT along with other data, or just tack on to the beginning or end
         persistentStore.access_start();
         const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
         persistentStore.access_finish();
 
-        if (status)
-          SERIAL_PROTOCOLPGM("?Unable to save mesh data.\n");
-
-        // Write crc to MAT along with other data, or just tack on to the beginning or end
-
-        #if ENABLED(EEPROM_CHITCHAT)
-          if (!status)
-            SERIAL_PROTOCOLLNPAIR("Mesh saved in slot ", slot);
-        #endif
+        if (status) SERIAL_ECHOPGM("?Unable to save mesh data.\n");
+        else        CHITCHAT_ECHOLNPAIR("Mesh saved in slot ", slot);
 
       #else
 
@@ -1865,9 +1872,7 @@ void MarlinSettings::postprocess() {
         const int16_t a = settings.calc_num_meshes();
 
         if (!WITHIN(slot, 0, a - 1)) {
-          #if ENABLED(EEPROM_CHITCHAT)
-            ubl_invalid_slot(a);
-          #endif
+          ubl_invalid_slot(a);
           return;
         }
 
@@ -1879,13 +1884,9 @@ void MarlinSettings::postprocess() {
         const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
         persistentStore.access_finish();
 
-        if (status)
-          SERIAL_PROTOCOLPGM("?Unable to load mesh data.\n");
+        if (status) SERIAL_ECHOPGM("?Unable to load mesh data.\n");
+        else        CHITCHAT_ECHOLNPAIR("Mesh loaded from slot ", slot);
 
-        #if ENABLED(EEPROM_CHITCHAT)
-          else
-            SERIAL_PROTOCOLLNPAIR("Mesh loaded from slot ", slot);
-        #endif
         EEPROM_FINISH();
 
       #else
@@ -1903,10 +1904,7 @@ void MarlinSettings::postprocess() {
 #else // !EEPROM_SETTINGS
 
   bool MarlinSettings::save(PORTARG_SOLO) {
-    #if ENABLED(EEPROM_CHITCHAT)
-      SERIAL_ERROR_START_P(port);
-      SERIAL_ERRORLNPGM_P(port, "EEPROM disabled");
-    #endif
+    CHITCHAT_ERROR_MSG_P(port, "EEPROM disabled");
     return false;
   }
 
@@ -2177,15 +2175,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   postprocess();
 
-  #if ENABLED(EEPROM_CHITCHAT)
-    SERIAL_ECHO_START_P(port);
-    SERIAL_ECHOLNPGM_P(port, "Hardcoded Default Settings Loaded");
-  #endif
+  CHITCHAT_ECHO_START_P(port);
+  CHITCHAT_ECHOLNPGM_P(port, "Hardcoded Default Settings Loaded");
 }
 
 #if DISABLED(DISABLE_M503)
 
-  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
+  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
+  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(port, STR); }while(0)
+  #define CONFIG_ECHO_HEADING(STR)  do{ if (!forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(port, STR); } }while(0)
 
   #if HAS_TRINAMIC
     void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906"); }
@@ -2234,7 +2232,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     /**
      * Announce current units, in case inches are being displayed
      */
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_START();
     #if ENABLED(INCH_MODE_SUPPORT)
       SERIAL_ECHOPGM_P(port, "  G2");
       SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
@@ -2250,7 +2248,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       // Temperature units - for Ultipanel temperature options
 
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
         SERIAL_ECHOPGM_P(port, "  M149 ");
         SERIAL_CHAR_P(port, parser.temp_units_code());
@@ -2270,7 +2268,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
        * Volumetric extrusion M200
        */
       if (!forReplay) {
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPGM_P(port, "Filament settings:");
         if (parser.volumetric_enabled)
           SERIAL_EOL_P(port);
@@ -2278,27 +2276,27 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, " Disabled");
       }
 
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M200 D", LINEAR_UNIT(planner.filament_size[0]));
       SERIAL_EOL_P(port);
       #if EXTRUDERS > 1
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPAIR_P(port, "  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
         SERIAL_EOL_P(port);
         #if EXTRUDERS > 2
-          CONFIG_ECHO_START;
+          CONFIG_ECHO_START();
           SERIAL_ECHOPAIR_P(port, "  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
           SERIAL_EOL_P(port);
           #if EXTRUDERS > 3
-            CONFIG_ECHO_START;
+            CONFIG_ECHO_START();
             SERIAL_ECHOPAIR_P(port, "  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
             SERIAL_EOL_P(port);
             #if EXTRUDERS > 4
-              CONFIG_ECHO_START;
+              CONFIG_ECHO_START();
               SERIAL_ECHOPAIR_P(port, "  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
               SERIAL_EOL_P(port);
               #if EXTRUDERS > 5
-                CONFIG_ECHO_START;
+                CONFIG_ECHO_START();
                 SERIAL_ECHOPAIR_P(port, "  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
                 SERIAL_EOL_P(port);
               #endif // EXTRUDERS > 5
@@ -2307,18 +2305,13 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #endif // EXTRUDERS > 2
       #endif // EXTRUDERS > 1
 
-      if (!parser.volumetric_enabled) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "  M200 D0");
-      }
+      if (!parser.volumetric_enabled)
+        CONFIG_ECHO_MSG("  M200 D0");
 
     #endif // !NO_VOLUMETRICS
 
-    if (!forReplay) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM_P(port, "Steps per unit:");
-    }
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_HEADING("Steps per unit:");
+    CONFIG_ECHO_START();
     SERIAL_ECHOPAIR_P(port, "  M92 X", LINEAR_UNIT(planner.settings.axis_steps_per_mm[X_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Y_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Z_AXIS]));
@@ -2327,18 +2320,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M92 T", (int)i);
         SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.axis_steps_per_mm[E_AXIS + i]));
       }
     #endif
 
-    if (!forReplay) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM_P(port, "Maximum feedrates (units/s):");
-    }
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
+    CONFIG_ECHO_START();
     SERIAL_ECHOPAIR_P(port, "  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]));
@@ -2347,18 +2337,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M203 T", (int)i);
         SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS + i]));
       }
     #endif
 
-    if (!forReplay) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM_P(port, "Maximum Acceleration (units/s2):");
-    }
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
+    CONFIG_ECHO_START();
     SERIAL_ECHOPAIR_P(port, "  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]));
     SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]));
@@ -2367,24 +2354,21 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M201 T", (int)i);
         SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS + i]));
       }
     #endif
 
-    if (!forReplay) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM_P(port, "Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
-    }
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
+    CONFIG_ECHO_START();
     SERIAL_ECHOPAIR_P(port, "  M204 P", LINEAR_UNIT(planner.settings.acceleration));
     SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(planner.settings.retract_acceleration));
     SERIAL_ECHOLNPAIR_P(port, " T", LINEAR_UNIT(planner.settings.travel_acceleration));
 
     if (!forReplay) {
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       SERIAL_ECHOPGM_P(port, "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
       #if ENABLED(JUNCTION_DEVIATION)
         SERIAL_ECHOPGM_P(port, " J<junc_dev>");
@@ -2397,7 +2381,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif
       SERIAL_EOL_P(port);
     }
-    CONFIG_ECHO_START;
+    CONFIG_ECHO_START();
     SERIAL_ECHOPAIR_P(port, "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us));
     SERIAL_ECHOPAIR_P(port, " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s));
     SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s));
@@ -2417,29 +2401,21 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     SERIAL_EOL_P(port);
 
     #if HAS_M206_COMMAND
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Home offset:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Home offset:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(home_offset[Y_AXIS]));
       SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(home_offset[Z_AXIS]));
     #endif
 
     #if HAS_HOTEND_OFFSET
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Hotend offsets:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Hotend offsets:");
+      CONFIG_ECHO_START();
       for (uint8_t e = 1; e < HOTENDS; e++) {
         SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
         SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        SERIAL_ECHO_P(port, " Z");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
-        SERIAL_EOL_P(port);
+        SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
       }
     #endif
 
@@ -2450,29 +2426,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       #if ENABLED(MESH_BED_LEVELING)
 
-        if (!forReplay) {
-          CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "Mesh Bed Leveling:");
-        }
+        CONFIG_ECHO_HEADING("Mesh Bed Leveling:");
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
-          CONFIG_ECHO_START;
+          CONFIG_ECHO_START();
           ubl.echo_name();
           SERIAL_ECHOLNPGM_P(port, ":");
         }
 
       #elif HAS_ABL
 
-        if (!forReplay) {
-          CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "Auto Bed Leveling:");
-        }
+        CONFIG_ECHO_HEADING("Auto Bed Leveling:");
 
       #endif
 
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.z_fade_height));
@@ -2484,12 +2454,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         if (leveling_is_valid()) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
-              CONFIG_ECHO_START;
+              CONFIG_ECHO_START();
               SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
               SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
-              SERIAL_ECHOPGM_P(port, " Z");
-              SERIAL_ECHO_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
-              SERIAL_EOL_P(port);
+              SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
         }
@@ -2504,19 +2472,17 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, " meshes.\n");
         }
 
-//      ubl.report_current_mesh(PORTVAR_SOLO);   // This is too verbose for large mesh's.   A better (more terse)
-                                                 // solution needs to be found.
+       //ubl.report_current_mesh(PORTVAR_SOLO);   // This is too verbose for large meshes. A better (more terse)
+                                                  // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
-              CONFIG_ECHO_START;
+              CONFIG_ECHO_START();
               SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px);
               SERIAL_ECHOPAIR_P(port, " J", (int)py);
-              SERIAL_ECHOPGM_P(port, " Z");
-              SERIAL_ECHO_F_P(port, LINEAR_UNIT(z_values[px][py]), 5);
-              SERIAL_EOL_P(port);
+              SERIAL_ECHOLNPAIR_F_P(port, " Z", LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
@@ -2527,10 +2493,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Servo Angles:");
-      }
+      CONFIG_ECHO_HEADING("Servo Angles:");
       for (uint8_t i = 0; i < NUM_SERVOS; i++) {
         switch (i) {
           #if ENABLED(SWITCHING_EXTRUDER)
@@ -2543,7 +2506,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
             case Z_PROBE_SERVO_NR:
           #endif
-            CONFIG_ECHO_START;
+            CONFIG_ECHO_START();
             SERIAL_ECHOPAIR_P(port, "  M281 P", int(i));
             SERIAL_ECHOPAIR_P(port, " L", servo_angles[i][0]);
             SERIAL_ECHOPAIR_P(port, " U", servo_angles[i][1]);
@@ -2556,11 +2519,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #if HAS_SCARA_OFFSET
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M665 S", delta_segments_per_second);
       SERIAL_ECHOPAIR_P(port, " P", scara_home_offset[A_AXIS]);
       SERIAL_ECHOPAIR_P(port, " T", scara_home_offset[B_AXIS]);
@@ -2569,19 +2529,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #elif ENABLED(DELTA)
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Endstop adjustment:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Endstop adjustment:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
       SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
-      }
-      CONFIG_ECHO_START;
+
+      CONFIG_ECHO_HEADING("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M665 L", LINEAR_UNIT(delta_diagonal_rod));
       SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(delta_radius));
       SERIAL_ECHOPAIR_P(port, " H", LINEAR_UNIT(delta_height));
@@ -2594,11 +2549,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Endstop adjustment:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Endstop adjustment:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPGM_P(port, "  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(endstops.x2_endstop_adj));
@@ -2608,7 +2560,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         SERIAL_ECHOLNPAIR_P(port, "S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPAIR_P(port, "  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
       #elif ENABLED(Z_DUAL_ENDSTOPS)
         SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(endstops.z2_endstop_adj));
@@ -2619,12 +2571,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #if HAS_LCD_MENU
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Material heatup parameters:");
-      }
+      CONFIG_ECHO_HEADING("Material heatup parameters:");
       for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPAIR_P(port, "  M145 S", (int)i);
         SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(ui.preheat_hotend_temp[i]));
         SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(ui.preheat_bed_temp[i]));
@@ -2635,15 +2584,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #if HAS_PID_HEATING
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "PID settings:");
-      }
+      CONFIG_ECHO_HEADING("PID settings:");
       #if ENABLED(PIDTEMP)
         #if HOTENDS > 1
           if (forReplay) {
             HOTEND_LOOP() {
-              CONFIG_ECHO_START;
+              CONFIG_ECHO_START();
               SERIAL_ECHOPAIR_P(port, "  M301 E", e);
               SERIAL_ECHOPAIR_P(port, " P", PID_PARAM(Kp, e));
               SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, e)));
@@ -2659,7 +2605,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #endif // HOTENDS > 1
         // !forReplay || HOTENDS == 1
         {
-          CONFIG_ECHO_START;
+          CONFIG_ECHO_START();
           SERIAL_ECHOPAIR_P(port, "  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
           SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, 0)));
           SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, 0)));
@@ -2672,7 +2618,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPAIR_P(port, "  M304 P", thermalManager.bed_pid.Kp);
         SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(thermalManager.bed_pid.Ki));
         SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(thermalManager.bed_pid.Kd));
@@ -2682,51 +2628,36 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif // PIDTEMP || PIDTEMPBED
 
     #if HAS_LCD_CONTRAST
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "LCD Contrast:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("LCD Contrast:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(port, "  M250 C", ui.contrast);
     #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Power-Loss Recovery:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Power-Loss Recovery:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(port, "  M413 S", int(recovery.enabled));
     #endif
 
     #if ENABLED(FWRETRACT)
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Retract: S<length> F<units/m> Z<lift>");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
       SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
       SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
       SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.settings.retract_zraise));
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Recover: S<length> F<units/m>");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length));
       SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length));
       SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s)));
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
 
-        if (!forReplay) {
-          CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-        }
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
+        CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(port, "  M209 S", fwretract.autoretract_enabled ? 1 : 0);
 
       #endif // FWRETRACT_AUTORETRACT
@@ -2738,11 +2669,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
      */
     #if HAS_BED_PROBE
       if (!forReplay) {
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         SERIAL_ECHOPGM_P(port, "Z-Probe Offset");
         SAY_UNITS_P(port, true);
       }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(port, "  M851 Z", LINEAR_UNIT(zprobe_zoffset));
     #endif
 
@@ -2750,23 +2681,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
      * Bed Skew Correction
      */
     #if ENABLED(SKEW_CORRECTION_GCODE)
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Skew Factor: ");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Skew Factor: ");
+      CONFIG_ECHO_START();
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHOPGM_P(port, "  M852 I");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xy), 6);
-        SERIAL_ECHOPGM_P(port, " J");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xz), 6);
-        SERIAL_ECHOPGM_P(port, " K");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.yz), 6);
-        SERIAL_EOL_P(port);
+        SERIAL_ECHOPAIR_F_P(port, "  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
+        SERIAL_ECHOPAIR_F_P(port, " J", LINEAR_UNIT(planner.skew_factor.xz), 6);
+        SERIAL_ECHOLNPAIR_F_P(port, " K", LINEAR_UNIT(planner.skew_factor.yz), 6);
       #else
-        SERIAL_ECHOPGM_P(port, "  M852 S");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xy), 6);
-        SERIAL_EOL_P(port);
+        SERIAL_ECHOLNPAIR_F_P(port, "  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
       #endif
     #endif
 
@@ -2775,11 +2697,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       /**
        * TMC stepper driver current
        */
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Stepper driver current:");
+      CONFIG_ECHO_START();
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(PORTVAR_SOLO);
       #endif
@@ -2848,11 +2767,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
        * TMC Hybrid Threshold
        */
       #if ENABLED(HYBRID_THRESHOLD)
-        if (!forReplay) {
-          CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
-        }
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_HEADING("Hybrid Threshold:");
+        CONFIG_ECHO_START();
         #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           say_M913(PORTVAR_SOLO);
         #endif
@@ -2923,11 +2839,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
        * TMC Sensorless homing thresholds
        */
       #if USE_SENSORLESS
-        if (!forReplay) {
-          CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "TMC2130 StallGuard threshold:");
-        }
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_HEADING("TMC2130 StallGuard threshold:");
+        CONFIG_ECHO_START();
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           say_M914(PORTVAR_SOLO);
           #if X_SENSORLESS
@@ -2975,12 +2888,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Linear Advance:");
-      }
-
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Linear Advance:");
+      CONFIG_ECHO_START();
       #if EXTRUDERS < 2
         SERIAL_ECHOLNPAIR_P(port, "  M900 K", planner.extruder_advance_K[0]);
       #else
@@ -2992,11 +2901,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
-      CONFIG_ECHO_START;
-      if (!forReplay) {
-        SERIAL_ECHOLNPGM_P(port, "Stepper motor currents:");
-        CONFIG_ECHO_START;
-      }
+      CONFIG_ECHO_HEADING("Stepper motor currents:");
+      CONFIG_ECHO_START();
       SERIAL_ECHOPAIR_P(port, "  M907 X", stepper.motor_current_setting[0]);
       SERIAL_ECHOPAIR_P(port, " Z", stepper.motor_current_setting[1]);
       SERIAL_ECHOPAIR_P(port, " E", stepper.motor_current_setting[2]);
@@ -3007,11 +2913,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Filament load/unload lengths:");
-      }
-      CONFIG_ECHO_START;
+      CONFIG_ECHO_HEADING("Filament load/unload lengths:");
+      CONFIG_ECHO_START();
       #if EXTRUDERS == 1
         say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(fc_settings[0].load_length));
@@ -3020,27 +2923,27 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(fc_settings[0].load_length));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[0].unload_length));
-        CONFIG_ECHO_START;
+        CONFIG_ECHO_START();
         say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(fc_settings[1].load_length));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[1].unload_length));
         #if EXTRUDERS > 2
-          CONFIG_ECHO_START;
+          CONFIG_ECHO_START();
           say_M603(PORTVAR_SOLO);
           SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(fc_settings[2].load_length));
           SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[2].unload_length));
           #if EXTRUDERS > 3
-            CONFIG_ECHO_START;
+            CONFIG_ECHO_START();
             say_M603(PORTVAR_SOLO);
             SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(fc_settings[3].load_length));
             SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[3].unload_length));
             #if EXTRUDERS > 4
-              CONFIG_ECHO_START;
+              CONFIG_ECHO_START();
               say_M603(PORTVAR_SOLO);
               SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(fc_settings[4].load_length));
               SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[4].unload_length));
               #if EXTRUDERS > 5
-                CONFIG_ECHO_START;
+                CONFIG_ECHO_START();
                 say_M603(PORTVAR_SOLO);
                 SERIAL_ECHOPAIR_P(port, "T5 L", LINEAR_UNIT(fc_settings[5].load_length));
                 SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[5].unload_length));
@@ -3052,11 +2955,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif // ADVANCED_PAUSE_FEATURE
 
     #if EXTRUDERS > 1
-      CONFIG_ECHO_START;
-      if (!forReplay) {
-        SERIAL_ECHOLNPGM_P(port, "Tool-changing:");
-        CONFIG_ECHO_START;
-      }
+      CONFIG_ECHO_HEADING("Tool-changing:");
+      CONFIG_ECHO_START();
       M217_report(true);
     #endif
   }

commit 22d7fed60aa72937786e88196854c5983c98501d
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Nov 18 04:13:36 2018 +0100

    Fix compile error with SD_FIRMWARE_UPDATE (#12462)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0844b8af66..2da6ea3eb2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -66,6 +66,10 @@
 #include "../gcode/gcode.h"
 #include "../Marlin.h"
 
+#if ENABLED(EEPROM_SETTINGS) || ENABLED(SD_FIRMWARE_UPDATE)
+  #include "../HAL/shared/persistent_store_api.h"
+#endif
+
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
@@ -381,7 +385,6 @@ void MarlinSettings::postprocess() {
 #endif // SD_FIRMWARE_UPDATE
 
 #if ENABLED(EEPROM_SETTINGS)
-  #include "../HAL/shared/persistent_store_api.h"
 
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
   #define EEPROM_FINISH() persistentStore.access_finish()

commit d97e31db4c2b8b27ab1c6fbbe05f11aa9d5e94e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 20:47:07 2018 -0600

    Optimize Power-Loss Recovery (#12440)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3919f99ea7..0844b8af66 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V62"
+#define EEPROM_VERSION "V63"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -82,6 +82,11 @@
 #endif
 
 #include "../feature/fwretract.h"
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
+
 #include "../feature/pause.h"
 
 #if EXTRUDERS > 1
@@ -221,6 +226,11 @@ typedef struct SettingsDataStruct {
   //
   int16_t lcd_contrast;                                 // M250 C
 
+  //
+  // POWER_LOSS_RECOVERY
+  //
+  bool recovery_enabled;                                // M413 S
+
   //
   // FWRETRACT
   //
@@ -269,7 +279,7 @@ typedef struct SettingsDataStruct {
   // Tool-change settings
   //
   #if EXTRUDERS > 1
-    toolchange_settings_t toolchange_settings;                // M217 S P R
+    toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
 } SettingsData;
@@ -746,6 +756,22 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(lcd_contrast);
     }
 
+    //
+    // Power-Loss Recovery
+    //
+    {
+      _FIELD_TEST(recovery_enabled);
+
+      const bool recovery_enabled =
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          recovery.enabled
+        #else
+          true
+        #endif
+      ;
+      EEPROM_WRITE(recovery_enabled);
+    }
+
     //
     // Firmware Retraction
     //
@@ -1387,6 +1413,20 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
+      //
+      // Power-Loss Recovery
+      //
+      {
+        _FIELD_TEST(recovery_enabled);
+
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          EEPROM_READ(recovery.enabled);
+        #else
+          bool recovery_enabled;
+          EEPROM_READ(recovery_enabled);
+        #endif
+      }
+
       //
       // Firmware Retraction
       //
@@ -2075,6 +2115,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     ui.set_contrast(DEFAULT_LCD_CONTRAST);
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    recovery.enable(true);
+  #endif
+
   #if ENABLED(FWRETRACT)
     fwretract.reset();
   #endif
@@ -2643,6 +2687,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPAIR_P(port, "  M250 C", ui.contrast);
     #endif
 
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM_P(port, "Power-Loss Recovery:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPAIR_P(port, "  M413 S", int(recovery.enabled));
+    #endif
+
     #if ENABLED(FWRETRACT)
 
       if (!forReplay) {
@@ -2683,7 +2736,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_BED_PROBE
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOPGM_P(port, "Z-Probe Offset (mm):");
+        SERIAL_ECHOPGM_P(port, "Z-Probe Offset");
         SAY_UNITS_P(port, true);
       }
       CONFIG_ECHO_START;

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9e8e9e3fc5..3919f99ea7 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -201,9 +201,9 @@ typedef struct SettingsDataStruct {
   //
   // ULTIPANEL
   //
-  int16_t lcd_preheat_hotend_temp[2],                   // M145 S0 H
-          lcd_preheat_bed_temp[2];                      // M145 S0 B
-  uint8_t lcd_preheat_fan_speed[2];                     // M145 S0 F
+  int16_t ui_preheat_hotend_temp[2],                    // M145 S0 H
+          ui_preheat_bed_temp[2];                       // M145 S0 B
+  uint8_t ui_preheat_fan_speed[2];                      // M145 S0 F
 
   //
   // PIDTEMP
@@ -680,15 +680,19 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(lcd_preheat_hotend_temp);
 
-      #if !HAS_LCD_MENU
-        constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
-                          lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
-        constexpr uint8_t lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+      #if HAS_LCD_MENU
+        const int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
+                      (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
+        const uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
+      #else
+        constexpr int16_t ui_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
+                          ui_preheat_bed_temp[2]    = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
+        constexpr uint8_t ui_preheat_fan_speed[2]   = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
       #endif
 
-      EEPROM_WRITE(lcd_preheat_hotend_temp);
-      EEPROM_WRITE(lcd_preheat_bed_temp);
-      EEPROM_WRITE(lcd_preheat_fan_speed);
+      EEPROM_WRITE(ui_preheat_hotend_temp);
+      EEPROM_WRITE(ui_preheat_bed_temp);
+      EEPROM_WRITE(ui_preheat_fan_speed);
     }
 
     //
@@ -717,6 +721,7 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(bedPID);
+
       #if DISABLED(PIDTEMPBED)
         const PID_t bed_pid = { DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE };
         EEPROM_WRITE(bed_pid);
@@ -731,9 +736,13 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(lcd_contrast);
 
-      #if !HAS_LCD_CONTRAST
-        const int16_t lcd_contrast = 32;
-      #endif
+      const int16_t lcd_contrast =
+        #if HAS_LCD_CONTRAST
+          ui.contrast
+        #else
+          32
+        #endif
+      ;
       EEPROM_WRITE(lcd_contrast);
     }
 
@@ -1304,15 +1313,19 @@ void MarlinSettings::postprocess() {
       // LCD Preheat settings
       //
       {
-        _FIELD_TEST(lcd_preheat_hotend_temp);
+        _FIELD_TEST(ui_preheat_hotend_temp);
 
-        #if !HAS_LCD_MENU
-          int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
-          uint8_t lcd_preheat_fan_speed[2];
+        #if HAS_LCD_MENU
+          int16_t (&ui_preheat_hotend_temp)[2]  = ui.preheat_hotend_temp,
+                  (&ui_preheat_bed_temp)[2]     = ui.preheat_bed_temp;
+          uint8_t (&ui_preheat_fan_speed)[2]    = ui.preheat_fan_speed;
+        #else
+          int16_t ui_preheat_hotend_temp[2], ui_preheat_bed_temp[2];
+          uint8_t ui_preheat_fan_speed[2];
         #endif
-        EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
-        EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
-        EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
+        EEPROM_READ(ui_preheat_hotend_temp); // 2 floats
+        EEPROM_READ(ui_preheat_bed_temp);    // 2 floats
+        EEPROM_READ(ui_preheat_fan_speed);   // 2 floats
       }
 
       //
@@ -1366,10 +1379,12 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(lcd_contrast);
-        #if !HAS_LCD_CONTRAST
-          int16_t lcd_contrast;
-        #endif
+
+        int16_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
+        #if HAS_LCD_CONTRAST
+          ui.set_contrast(lcd_contrast);
+        #endif
       }
 
       //
@@ -2028,12 +2043,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if HAS_LCD_MENU
-    lcd_preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
-    lcd_preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
-    lcd_preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
-    lcd_preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
-    lcd_preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
-    lcd_preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+    ui.preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
+    ui.preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
+    ui.preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
+    ui.preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
+    ui.preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
+    ui.preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
   #endif
 
   #if ENABLED(PIDTEMP)
@@ -2057,7 +2072,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if HAS_LCD_CONTRAST
-    lcd_contrast = DEFAULT_LCD_CONTRAST;
+    ui.set_contrast(DEFAULT_LCD_CONTRAST);
   #endif
 
   #if ENABLED(FWRETRACT)
@@ -2561,12 +2576,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Material heatup parameters:");
       }
-      for (uint8_t i = 0; i < COUNT(lcd_preheat_hotend_temp); i++) {
+      for (uint8_t i = 0; i < COUNT(ui.preheat_hotend_temp); i++) {
         CONFIG_ECHO_START;
         SERIAL_ECHOPAIR_P(port, "  M145 S", (int)i);
-        SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
-        SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
-        SERIAL_ECHOLNPAIR_P(port, " F", int(lcd_preheat_fan_speed[i]));
+        SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(ui.preheat_hotend_temp[i]));
+        SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(ui.preheat_bed_temp[i]));
+        SERIAL_ECHOLNPAIR_P(port, " F", int(ui.preheat_fan_speed[i]));
       }
 
     #endif
@@ -2625,7 +2640,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOLNPGM_P(port, "LCD Contrast:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR_P(port, "  M250 C", lcd_contrast);
+      SERIAL_ECHOLNPAIR_P(port, "  M250 C", ui.contrast);
     #endif
 
     #if ENABLED(FWRETRACT)

commit ef724edd80840739e5a99bcbb39e775fa7a8c289
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 8 09:48:09 2018 -0600

    Apply HAS_LCD_MENU in EEPROM code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dbac3377ac..9e8e9e3fc5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -680,7 +680,7 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(lcd_preheat_hotend_temp);
 
-      #if DISABLED(ULTIPANEL)
+      #if !HAS_LCD_MENU
         constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
                           lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
         constexpr uint8_t lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
@@ -1306,7 +1306,7 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(lcd_preheat_hotend_temp);
 
-        #if DISABLED(ULTIPANEL)
+        #if !HAS_LCD_MENU
           int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
           uint8_t lcd_preheat_fan_speed[2];
         #endif
@@ -2027,7 +2027,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #endif
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     lcd_preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
     lcd_preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
     lcd_preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
@@ -2184,7 +2184,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
     SERIAL_EOL_P(port);
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
 
       // Temperature units - for Ultipanel temperature options
 
@@ -2555,7 +2555,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
+
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Material heatup parameters:");
@@ -2567,7 +2568,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
         SERIAL_ECHOLNPAIR_P(port, " F", int(lcd_preheat_fan_speed[i]));
       }
-    #endif // ULTIPANEL
+
+    #endif
 
     #if HAS_PID_HEATING
 

commit 6471a75a228d8d60416f7b405e888064e7e8c8da
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Nov 6 22:52:20 2018 -0500

    Combine more tool-change variables (#12137)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1a02a13373..dbac3377ac 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -266,7 +266,7 @@ typedef struct SettingsDataStruct {
   fil_change_settings_t fc_settings[EXTRUDERS];         // M603 T U L
 
   //
-  // SINGLENOZZLE toolchange values
+  // Tool-change settings
   //
   #if EXTRUDERS > 1
     toolchange_settings_t toolchange_settings;                // M217 S P R
@@ -990,7 +990,7 @@ void MarlinSettings::postprocess() {
     }
 
     //
-    // SINGLENOZZLE
+    // Multiple Extruders
     //
 
     #if EXTRUDERS > 1
@@ -1637,7 +1637,7 @@ void MarlinSettings::postprocess() {
       }
 
       //
-      // SINGLENOZZLE toolchange values
+      // Tool-change settings
       //
       #if EXTRUDERS > 1
         _FIELD_TEST(toolchange_settings);
@@ -1905,13 +1905,13 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if EXTRUDERS > 1
-    #if ENABLED(SINGLENOZZLE)
-      toolchange_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
-      toolchange_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
-      toolchange_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
-      #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-        toolchange_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
-      #endif
+    #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+      toolchange_settings.swap_length = TOOLCHANGE_FIL_SWAP_LENGTH;
+      toolchange_settings.prime_speed = TOOLCHANGE_FIL_SWAP_PRIME_SPEED;
+      toolchange_settings.retract_speed = TOOLCHANGE_FIL_SWAP_RETRACT_SPEED;
+    #endif
+    #if ENABLED(TOOLCHANGE_PARK)
+      toolchange_settings.change_point = TOOLCHANGE_PARK_XY;
     #endif
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
@@ -2978,10 +2978,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif // EXTRUDERS == 1
     #endif // ADVANCED_PAUSE_FEATURE
 
-    #if ENABLED(SINGLENOZZLE)
+    #if EXTRUDERS > 1
       CONFIG_ECHO_START;
       if (!forReplay) {
-        SERIAL_ECHOLNPGM_P(port, "SINGLENOZZLE:");
+        SERIAL_ECHOLNPGM_P(port, "Tool-changing:");
         CONFIG_ECHO_START;
       }
       M217_report(true);

commit c04cf127f779bf69b2bf9f44cc425ac9c2038184
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 16:14:54 2018 -0600

    Fix EEPROM servo angles init, section grouping

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0a0d35fca9..1a02a13373 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -432,214 +432,264 @@ void MarlinSettings::postprocess() {
     const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
 
-    EEPROM_WRITE(planner.settings);
+    //
+    // Planner Motion
+    //
+    {
+      EEPROM_WRITE(planner.settings);
 
-    #if HAS_CLASSIC_JERK
-      EEPROM_WRITE(planner.max_jerk);
-      #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
-        dummy = float(DEFAULT_EJERK);
-        EEPROM_WRITE(dummy);
+      #if HAS_CLASSIC_JERK
+        EEPROM_WRITE(planner.max_jerk);
+        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+          dummy = float(DEFAULT_EJERK);
+          EEPROM_WRITE(dummy);
+        #endif
+      #else
+        const float planner_max_jerk[XYZE] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
+        EEPROM_WRITE(planner_max_jerk);
       #endif
-    #else
-      const float planner_max_jerk[XYZE] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
-      EEPROM_WRITE(planner_max_jerk);
-    #endif
 
-    #if ENABLED(JUNCTION_DEVIATION)
-      EEPROM_WRITE(planner.junction_deviation_mm);
-    #else
-      dummy = 0.02f;
-      EEPROM_WRITE(dummy);
-    #endif
+      #if ENABLED(JUNCTION_DEVIATION)
+        EEPROM_WRITE(planner.junction_deviation_mm);
+      #else
+        dummy = 0.02f;
+        EEPROM_WRITE(dummy);
+      #endif
+    }
 
-    _FIELD_TEST(home_offset);
+    //
+    // Home Offset
+    //
+    {
+      _FIELD_TEST(home_offset);
 
-    #if HAS_SCARA_OFFSET
-      EEPROM_WRITE(scara_home_offset);
-    #else
-      #if !HAS_HOME_OFFSET
-        const float home_offset[XYZ] = { 0 };
+      #if HAS_SCARA_OFFSET
+        EEPROM_WRITE(scara_home_offset);
+      #else
+        #if !HAS_HOME_OFFSET
+          const float home_offset[XYZ] = { 0 };
+        #endif
+        EEPROM_WRITE(home_offset);
       #endif
-      EEPROM_WRITE(home_offset);
-    #endif
 
-    #if HAS_HOTEND_OFFSET
-      // Skip hotend 0 which must be 0
-      for (uint8_t e = 1; e < HOTENDS; e++)
-        LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
-    #endif
+      #if HAS_HOTEND_OFFSET
+        // Skip hotend 0 which must be 0
+        for (uint8_t e = 1; e < HOTENDS; e++)
+          LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
+      #endif
+    }
 
     //
     // Global Leveling
     //
+    {
+      const float zfh = (
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          planner.z_fade_height
+        #else
+          10.0
+        #endif
+      );
+      EEPROM_WRITE(zfh);
+    }
 
-    const float zfh = (
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        planner.z_fade_height
-      #else
-        10.0
+    //
+    // Mesh Bed Leveling
+    //
+    {
+      #if ENABLED(MESH_BED_LEVELING)
+        // Compile time test that sizeof(mbl.z_values) is as expected
+        static_assert(
+          sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
+          "MBL Z array is the wrong size."
+        );
+        const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
+        EEPROM_WRITE(mbl.z_offset);
+        EEPROM_WRITE(mesh_num_x);
+        EEPROM_WRITE(mesh_num_y);
+        EEPROM_WRITE(mbl.z_values);
+      #else // For disabled MBL write a default mesh
+        dummy = 0;
+        const uint8_t mesh_num_x = 3, mesh_num_y = 3;
+        EEPROM_WRITE(dummy); // z_offset
+        EEPROM_WRITE(mesh_num_x);
+        EEPROM_WRITE(mesh_num_y);
+        for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
       #endif
-    );
-    EEPROM_WRITE(zfh);
+    }
 
     //
-    // Mesh Bed Leveling
+    // Probe Z Offset
     //
+    {
+      _FIELD_TEST(zprobe_zoffset);
 
-    #if ENABLED(MESH_BED_LEVELING)
-      // Compile time test that sizeof(mbl.z_values) is as expected
-      static_assert(
-        sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
-        "MBL Z array is the wrong size."
-      );
-      const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
-      EEPROM_WRITE(mbl.z_offset);
-      EEPROM_WRITE(mesh_num_x);
-      EEPROM_WRITE(mesh_num_y);
-      EEPROM_WRITE(mbl.z_values);
-    #else // For disabled MBL write a default mesh
-      dummy = 0;
-      const uint8_t mesh_num_x = 3, mesh_num_y = 3;
-      EEPROM_WRITE(dummy); // z_offset
-      EEPROM_WRITE(mesh_num_x);
-      EEPROM_WRITE(mesh_num_y);
-      for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
-    #endif // MESH_BED_LEVELING
-
-    _FIELD_TEST(zprobe_zoffset);
-
-    #if !HAS_BED_PROBE
-      const float zprobe_zoffset = 0;
-    #endif
-    EEPROM_WRITE(zprobe_zoffset);
+      #if !HAS_BED_PROBE
+        const float zprobe_zoffset = 0;
+      #endif
+      EEPROM_WRITE(zprobe_zoffset);
+    }
 
     //
     // Planar Bed Leveling matrix
     //
-
-    #if ABL_PLANAR
-      EEPROM_WRITE(planner.bed_level_matrix);
-    #else
-      dummy = 0;
-      for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
-    #endif
+    {
+      #if ABL_PLANAR
+        EEPROM_WRITE(planner.bed_level_matrix);
+      #else
+        dummy = 0;
+        for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
+      #endif
+    }
 
     //
     // Bilinear Auto Bed Leveling
     //
+    {
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        // Compile time test that sizeof(z_values) is as expected
+        static_assert(
+          sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
+          "Bilinear Z array is the wrong size."
+        );
+        const uint8_t grid_max_x = GRID_MAX_POINTS_X, grid_max_y = GRID_MAX_POINTS_Y;
+        EEPROM_WRITE(grid_max_x);            // 1 byte
+        EEPROM_WRITE(grid_max_y);            // 1 byte
+        EEPROM_WRITE(bilinear_grid_spacing); // 2 ints
+        EEPROM_WRITE(bilinear_start);        // 2 ints
+        EEPROM_WRITE(z_values);              // 9-256 floats
+      #else
+        // For disabled Bilinear Grid write an empty 3x3 grid
+        const uint8_t grid_max_x = 3, grid_max_y = 3;
+        const int bilinear_start[2] = { 0 }, bilinear_grid_spacing[2] = { 0 };
+        dummy = 0;
+        EEPROM_WRITE(grid_max_x);
+        EEPROM_WRITE(grid_max_y);
+        EEPROM_WRITE(bilinear_grid_spacing);
+        EEPROM_WRITE(bilinear_start);
+        for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummy);
+      #endif
+    }
 
-    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      // Compile time test that sizeof(z_values) is as expected
-      static_assert(
-        sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
-        "Bilinear Z array is the wrong size."
-      );
-      const uint8_t grid_max_x = GRID_MAX_POINTS_X, grid_max_y = GRID_MAX_POINTS_Y;
-      EEPROM_WRITE(grid_max_x);            // 1 byte
-      EEPROM_WRITE(grid_max_y);            // 1 byte
-      EEPROM_WRITE(bilinear_grid_spacing); // 2 ints
-      EEPROM_WRITE(bilinear_start);        // 2 ints
-      EEPROM_WRITE(z_values);              // 9-256 floats
-    #else
-      // For disabled Bilinear Grid write an empty 3x3 grid
-      const uint8_t grid_max_x = 3, grid_max_y = 3;
-      const int bilinear_start[2] = { 0 }, bilinear_grid_spacing[2] = { 0 };
-      dummy = 0;
-      EEPROM_WRITE(grid_max_x);
-      EEPROM_WRITE(grid_max_y);
-      EEPROM_WRITE(bilinear_grid_spacing);
-      EEPROM_WRITE(bilinear_start);
-      for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummy);
-    #endif // AUTO_BED_LEVELING_BILINEAR
-
-    _FIELD_TEST(planner_leveling_active);
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      EEPROM_WRITE(planner.leveling_active);
-      EEPROM_WRITE(ubl.storage_slot);
-    #else
-      const bool ubl_active = false;
-      const int8_t storage_slot = -1;
-      EEPROM_WRITE(ubl_active);
-      EEPROM_WRITE(storage_slot);
-    #endif // AUTO_BED_LEVELING_UBL
+    //
+    // Unified Bed Leveling
+    //
+    {
+      _FIELD_TEST(planner_leveling_active);
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        EEPROM_WRITE(planner.leveling_active);
+        EEPROM_WRITE(ubl.storage_slot);
+      #else
+        const bool ubl_active = false;
+        const int8_t storage_slot = -1;
+        EEPROM_WRITE(ubl_active);
+        EEPROM_WRITE(storage_slot);
+      #endif // AUTO_BED_LEVELING_UBL
+    }
+
+    //
+    // Servo Angles
+    //
+    {
+      #if !(HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES))
+
+        uint16_t servo_angles[NUM_SERVOS][2] = { { 0, 0 } };
 
-    #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
-      #if ENABLED(SWITCHING_EXTRUDER)
-        constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-      #endif
-      constexpr uint16_t servo_angles[NUM_SERVOS][2] = {
         #if ENABLED(SWITCHING_EXTRUDER)
-          [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0][0], sesa[0][1] }
+
+          constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+          servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = sesa[0][0];
+          servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = sesa[0][1];
           #if EXTRUDERS > 3
-            , [SWITCHING_EXTRUDER_E23_SERVO_NR] = { sesa[1][0], sesa[1][1] }
+            servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = sesa[1][0];
+            servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = sesa[1][1];
           #endif
+
         #elif ENABLED(SWITCHING_NOZZLE)
-          [SWITCHING_NOZZLE_SERVO_NR] = SWITCHING_NOZZLE_SERVO_ANGLES
+
+          constexpr uint16_t snsa[] = SWITCHING_NOZZLE_SERVO_ANGLES;
+          servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = snsa[0];
+          servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = snsa[1];
+
         #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
-          [Z_PROBE_SERVO_NR] = Z_SERVO_ANGLES
+
+          constexpr uint16_t zsa[] = Z_SERVO_ANGLES;
+          servo_angles[Z_PROBE_SERVO_NR][0] = zsa[0];
+          servo_angles[Z_PROBE_SERVO_NR][1] = zsa[1];
+
         #endif
-      };
-    #endif
 
-    EEPROM_WRITE(servo_angles);
+      #endif // !HAS_SERVOS || !EDITABLE_SERVO_ANGLES
 
-    // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
-    #if ENABLED(DELTA)
+      EEPROM_WRITE(servo_angles);
+    }
 
-      _FIELD_TEST(delta_height);
+    //
+    // DELTA Geometry or Dual Endstops offsets
+    //
+    {
+      #if ENABLED(DELTA)
 
-      EEPROM_WRITE(delta_height);              // 1 float
-      EEPROM_WRITE(delta_endstop_adj);         // 3 floats
-      EEPROM_WRITE(delta_radius);              // 1 float
-      EEPROM_WRITE(delta_diagonal_rod);        // 1 float
-      EEPROM_WRITE(delta_segments_per_second); // 1 float
-      EEPROM_WRITE(delta_calibration_radius);  // 1 float
-      EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
+        _FIELD_TEST(delta_height);
 
-    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+        EEPROM_WRITE(delta_height);              // 1 float
+        EEPROM_WRITE(delta_endstop_adj);         // 3 floats
+        EEPROM_WRITE(delta_radius);              // 1 float
+        EEPROM_WRITE(delta_diagonal_rod);        // 1 float
+        EEPROM_WRITE(delta_segments_per_second); // 1 float
+        EEPROM_WRITE(delta_calibration_radius);  // 1 float
+        EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
-      _FIELD_TEST(x2_endstop_adj);
+      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
-      // Write dual endstops in X, Y, Z order. Unused = 0.0
-      dummy = 0;
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        EEPROM_WRITE(endstops.x2_endstop_adj);   // 1 float
-      #else
-        EEPROM_WRITE(dummy);
-      #endif
+        _FIELD_TEST(x2_endstop_adj);
 
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        EEPROM_WRITE(endstops.y2_endstop_adj);   // 1 float
-      #else
-        EEPROM_WRITE(dummy);
-      #endif
+        // Write dual endstops in X, Y, Z order. Unused = 0.0
+        dummy = 0;
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          EEPROM_WRITE(endstops.x2_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummy);
+        #endif
 
-      #if Z_MULTI_ENDSTOPS
-        EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
-      #else
-        EEPROM_WRITE(dummy);
-      #endif
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          EEPROM_WRITE(endstops.y2_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummy);
+        #endif
 
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
-        EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
-      #else
-        EEPROM_WRITE(dummy);
-      #endif
+        #if Z_MULTI_ENDSTOPS
+          EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummy);
+        #endif
 
-    #endif
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummy);
+        #endif
 
-    _FIELD_TEST(lcd_preheat_hotend_temp);
+      #endif
+    }
 
-    #if DISABLED(ULTIPANEL)
-      constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
-                        lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
-      constexpr uint8_t lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
-    #endif
+    //
+    // LCD Preheat settings
+    //
+    {
+      _FIELD_TEST(lcd_preheat_hotend_temp);
 
-    EEPROM_WRITE(lcd_preheat_hotend_temp);
-    EEPROM_WRITE(lcd_preheat_bed_temp);
-    EEPROM_WRITE(lcd_preheat_fan_speed);
+      #if DISABLED(ULTIPANEL)
+        constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
+                          lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
+        constexpr uint8_t lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+      #endif
+
+      EEPROM_WRITE(lcd_preheat_hotend_temp);
+      EEPROM_WRITE(lcd_preheat_bed_temp);
+      EEPROM_WRITE(lcd_preheat_fan_speed);
+    }
 
     //
     // PIDTEMP
@@ -678,13 +728,14 @@ void MarlinSettings::postprocess() {
     //
     // LCD Contrast
     //
+    {
+      _FIELD_TEST(lcd_contrast);
 
-    _FIELD_TEST(lcd_contrast);
-
-    #if !HAS_LCD_CONTRAST
-      const int16_t lcd_contrast = 32;
-    #endif
-    EEPROM_WRITE(lcd_contrast);
+      #if !HAS_LCD_CONTRAST
+        const int16_t lcd_contrast = 32;
+      #endif
+      EEPROM_WRITE(lcd_contrast);
+    }
 
     //
     // Firmware Retraction
@@ -1199,7 +1250,7 @@ void MarlinSettings::postprocess() {
       // SERVO_ANGLES
       //
       {
-        #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+        #if !(HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES))
           uint16_t servo_angles[NUM_SERVOS][2];
         #endif
         EEPROM_READ(servo_angles);
@@ -1894,26 +1945,26 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #else
         #define REQ_ANGLES 2
       #endif
-      constexpr uint16_t extruder_angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-      static_assert(COUNT(extruder_angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
-      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = extruder_angles[0];
-      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = extruder_angles[1];
+      constexpr uint16_t sesa[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+      static_assert(COUNT(sesa) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
+      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = sesa[0];
+      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = sesa[1];
       #if EXTRUDERS > 3
-        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = extruder_angles[2];
-        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = extruder_angles[3];
+        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = sesa[2];
+        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = sesa[3];
       #endif
 
     #elif ENABLED(SWITCHING_NOZZLE)
 
-      constexpr uint16_t nozzle_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = nozzle_angles[0];
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = nozzle_angles[1];
+      constexpr uint16_t snsa[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = snsa[0];
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = snsa[1];
 
     #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
 
-      constexpr uint16_t z_probe_angles[2] = Z_SERVO_ANGLES;
-      servo_angles[Z_PROBE_SERVO_NR][0] = z_probe_angles[0];
-      servo_angles[Z_PROBE_SERVO_NR][1] = z_probe_angles[1];
+      constexpr uint16_t zsa[2] = Z_SERVO_ANGLES;
+      servo_angles[Z_PROBE_SERVO_NR][0] = zsa[0];
+      servo_angles[Z_PROBE_SERVO_NR][1] = zsa[1];
 
     #endif
 

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9b96de163f..0a0d35fca9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -124,7 +124,7 @@ typedef struct SettingsDataStruct {
   float planner_max_jerk[XYZE],                         // M205 XYZE  planner.max_jerk[XYZE]
         planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
-  float home_offset[XYZ];                               // M206 XYZ
+  float home_offset[XYZ];                               // M206 XYZ / M665 TPZ
 
   #if HAS_HOTEND_OFFSET
     float hotend_offset[XYZ][HOTENDS - 1];              // M218 XYZ
@@ -309,10 +309,11 @@ void MarlinSettings::postprocess() {
       planner.refresh_e_factor(i);
   #endif
 
-  #if HAS_HOME_OFFSET || ENABLED(DUAL_X_CARRIAGE)
-    // Software endstops depend on home_offset
-    LOOP_XYZ(i) update_software_endstops((AxisEnum)i);
-  #endif
+  // Software endstops depend on home_offset
+  LOOP_XYZ(i) {
+    update_workspace_offset((AxisEnum)i);
+    update_software_endstops((AxisEnum)i);
+  }
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     set_z_fade_height(new_z_fade_height, false); // false = no report
@@ -453,10 +454,14 @@ void MarlinSettings::postprocess() {
 
     _FIELD_TEST(home_offset);
 
-    #if !HAS_HOME_OFFSET
-      const float home_offset[XYZ] = { 0 };
+    #if HAS_SCARA_OFFSET
+      EEPROM_WRITE(scara_home_offset);
+    #else
+      #if !HAS_HOME_OFFSET
+        const float home_offset[XYZ] = { 0 };
+      #endif
+      EEPROM_WRITE(home_offset);
     #endif
-    EEPROM_WRITE(home_offset);
 
     #if HAS_HOTEND_OFFSET
       // Skip hotend 0 which must be 0
@@ -1062,15 +1067,19 @@ void MarlinSettings::postprocess() {
       }
 
       //
-      // Home Offset (M206)
+      // Home Offset (M206 / M665)
       //
       {
         _FIELD_TEST(home_offset);
 
-        #if !HAS_HOME_OFFSET
-          float home_offset[XYZ];
+        #if HAS_SCARA_OFFSET
+          EEPROM_READ(scara_home_offset);
+        #else
+          #if !HAS_HOME_OFFSET
+            float home_offset[XYZ];
+          #endif
+          EEPROM_READ(home_offset);
         #endif
-        EEPROM_READ(home_offset);
       }
 
       //
@@ -1826,7 +1835,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #endif
 
-  #if HAS_HOME_OFFSET
+  #if HAS_SCARA_OFFSET
+    ZERO(scara_home_offset);
+  #elif HAS_HOME_OFFSET
     ZERO(home_offset);
   #endif
 
@@ -2430,7 +2441,20 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
 
-    #if ENABLED(DELTA)
+    #if HAS_SCARA_OFFSET
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM_P(port, "SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR_P(port, "  M665 S", delta_segments_per_second);
+      SERIAL_ECHOPAIR_P(port, " P", scara_home_offset[A_AXIS]);
+      SERIAL_ECHOPAIR_P(port, " T", scara_home_offset[B_AXIS]);
+      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(scara_home_offset[Z_AXIS]));
+      SERIAL_EOL_P(port);
+
+    #elif ENABLED(DELTA)
 
       if (!forReplay) {
         CONFIG_ECHO_START;

commit 31c28d0dd243331adba3debb4801fbd03f7f6ec2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 2 00:42:16 2018 -0500

    Drop pgm_read_*_near and let headers choose (#12301)
    
    - Drop `pgm_read_*_near` and let headers choose.
    - Define `USE_EXECUTE_COMMANDS_IMMEDIATE` as a conditional.
    - Add `process_subcommands_now` for SRAM-based commands.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f66649c958..9b96de163f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1803,7 +1803,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   LOOP_XYZE_N(i) {
     planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&tmp1[ALIM(i, tmp1)]);
     planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&tmp2[ALIM(i, tmp2)]);
-    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword_near(&tmp3[ALIM(i, tmp3)]);
+    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&tmp3[ALIM(i, tmp3)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;

commit 946cf8b4533ee6176b3a0834e09f387977e2a37d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 16:39:49 2018 -0500

    EEPROM read code grouping

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2e34fb3028..f66649c958 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1008,10 +1008,6 @@ void MarlinSettings::postprocess() {
     }
     else {
       float dummy = 0;
-      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || DISABLED(FWRETRACT_AUTORETRACT) || ENABLED(NO_VOLUMETRICS)
-        bool dummyb;
-      #endif
-
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
@@ -1023,223 +1019,241 @@ void MarlinSettings::postprocess() {
       //
       // Planner Motion
       //
+      {
+        // Get only the number of E stepper parameters previously stored
+        // Any steppers added later are set to their defaults
+        const uint32_t def1[] = DEFAULT_MAX_ACCELERATION;
+        const float def2[] = DEFAULT_AXIS_STEPS_PER_UNIT, def3[] = DEFAULT_MAX_FEEDRATE;
+
+        uint32_t tmp1[XYZ + esteppers];
+        EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
+        EEPROM_READ(planner.settings.min_segment_time_us);
+
+        float tmp2[XYZ + esteppers], tmp3[XYZ + esteppers];
+        EEPROM_READ(tmp2);                         // axis_steps_per_mm
+        EEPROM_READ(tmp3);                         // max_feedrate_mm_s
+        if (!validating) LOOP_XYZE_N(i) {
+          const bool in = (i < esteppers + XYZ);
+          planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : def1[ALIM(i, def1)];
+          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : def2[ALIM(i, def2)];
+          planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : def3[ALIM(i, def3)];
+        }
 
-      // Get only the number of E stepper parameters previously stored
-      // Any steppers added later are set to their defaults
-      const uint32_t def1[] = DEFAULT_MAX_ACCELERATION;
-      const float def2[] = DEFAULT_AXIS_STEPS_PER_UNIT, def3[] = DEFAULT_MAX_FEEDRATE;
-
-      uint32_t tmp1[XYZ + esteppers];
-      EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
-      EEPROM_READ(planner.settings.min_segment_time_us);
-
-      float tmp2[XYZ + esteppers], tmp3[XYZ + esteppers];
-      EEPROM_READ(tmp2);                         // axis_steps_per_mm
-      EEPROM_READ(tmp3);                         // max_feedrate_mm_s
-      if (!validating) LOOP_XYZE_N(i) {
-        const bool in = (i < esteppers + XYZ);
-        planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : def1[ALIM(i, def1)];
-        planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : def2[ALIM(i, def2)];
-        planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : def3[ALIM(i, def3)];
-      }
+        EEPROM_READ(planner.settings.acceleration);
+        EEPROM_READ(planner.settings.retract_acceleration);
+        EEPROM_READ(planner.settings.travel_acceleration);
+        EEPROM_READ(planner.settings.min_feedrate_mm_s);
+        EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
-      EEPROM_READ(planner.settings.acceleration);
-      EEPROM_READ(planner.settings.retract_acceleration);
-      EEPROM_READ(planner.settings.travel_acceleration);
-      EEPROM_READ(planner.settings.min_feedrate_mm_s);
-      EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
+        #if HAS_CLASSIC_JERK
+          EEPROM_READ(planner.max_jerk);
+          #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+            EEPROM_READ(dummy);
+          #endif
+        #else
+          for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
+        #endif
 
-      #if HAS_CLASSIC_JERK
-        EEPROM_READ(planner.max_jerk);
-        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+        #if ENABLED(JUNCTION_DEVIATION)
+          EEPROM_READ(planner.junction_deviation_mm);
+        #else
           EEPROM_READ(dummy);
         #endif
-      #else
-        for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
-      #endif
-
-      #if ENABLED(JUNCTION_DEVIATION)
-        EEPROM_READ(planner.junction_deviation_mm);
-      #else
-        EEPROM_READ(dummy);
-      #endif
+      }
 
       //
       // Home Offset (M206)
       //
+      {
+        _FIELD_TEST(home_offset);
 
-      _FIELD_TEST(home_offset);
-
-      #if !HAS_HOME_OFFSET
-        float home_offset[XYZ];
-      #endif
-      EEPROM_READ(home_offset);
+        #if !HAS_HOME_OFFSET
+          float home_offset[XYZ];
+        #endif
+        EEPROM_READ(home_offset);
+      }
 
       //
       // Hotend Offsets, if any
       //
-
-      #if HAS_HOTEND_OFFSET
-        // Skip hotend 0 which must be 0
-        for (uint8_t e = 1; e < HOTENDS; e++)
-          LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
-      #endif
+      {
+        #if HAS_HOTEND_OFFSET
+          // Skip hotend 0 which must be 0
+          for (uint8_t e = 1; e < HOTENDS; e++)
+            LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
+        #endif
+      }
 
       //
       // Global Leveling
       //
-
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        EEPROM_READ(new_z_fade_height);
-      #else
-        EEPROM_READ(dummy);
-      #endif
+      {
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          EEPROM_READ(new_z_fade_height);
+        #else
+          EEPROM_READ(dummy);
+        #endif
+      }
 
       //
       // Mesh (Manual) Bed Leveling
       //
-
-      uint8_t mesh_num_x, mesh_num_y;
-      EEPROM_READ(dummy);
-      EEPROM_READ_ALWAYS(mesh_num_x);
-      EEPROM_READ_ALWAYS(mesh_num_y);
-
-      #if ENABLED(MESH_BED_LEVELING)
-        if (!validating) mbl.z_offset = dummy;
-        if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
-          // EEPROM data fits the current mesh
-          EEPROM_READ(mbl.z_values);
-        }
-        else {
-          // EEPROM data is stale
-          if (!validating) mbl.reset();
+      {
+        uint8_t mesh_num_x, mesh_num_y;
+        EEPROM_READ(dummy);
+        EEPROM_READ_ALWAYS(mesh_num_x);
+        EEPROM_READ_ALWAYS(mesh_num_y);
+
+        #if ENABLED(MESH_BED_LEVELING)
+          if (!validating) mbl.z_offset = dummy;
+          if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
+            // EEPROM data fits the current mesh
+            EEPROM_READ(mbl.z_values);
+          }
+          else {
+            // EEPROM data is stale
+            if (!validating) mbl.reset();
+            for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
+          }
+        #else
+          // MBL is disabled - skip the stored data
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
-        }
-      #else
-        // MBL is disabled - skip the stored data
-        for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
-      #endif // MESH_BED_LEVELING
+        #endif // MESH_BED_LEVELING
+      }
 
-      _FIELD_TEST(zprobe_zoffset);
+      //
+      // Probe Z Offset
+      //
+      {
+        _FIELD_TEST(zprobe_zoffset);
 
-      #if !HAS_BED_PROBE
-        float zprobe_zoffset;
-      #endif
-      EEPROM_READ(zprobe_zoffset);
+        #if !HAS_BED_PROBE
+          float zprobe_zoffset;
+        #endif
+        EEPROM_READ(zprobe_zoffset);
+      }
 
       //
       // Planar Bed Leveling matrix
       //
-
-      #if ABL_PLANAR
-        EEPROM_READ(planner.bed_level_matrix);
-      #else
-        for (uint8_t q = 9; q--;) EEPROM_READ(dummy);
-      #endif
+      {
+        #if ABL_PLANAR
+          EEPROM_READ(planner.bed_level_matrix);
+        #else
+          for (uint8_t q = 9; q--;) EEPROM_READ(dummy);
+        #endif
+      }
 
       //
       // Bilinear Auto Bed Leveling
       //
-
-      uint8_t grid_max_x, grid_max_y;
-      EEPROM_READ_ALWAYS(grid_max_x);                       // 1 byte
-      EEPROM_READ_ALWAYS(grid_max_y);                       // 1 byte
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
-          if (!validating) set_bed_leveling_enabled(false);
-          EEPROM_READ(bilinear_grid_spacing);        // 2 ints
-          EEPROM_READ(bilinear_start);               // 2 ints
-          EEPROM_READ(z_values);                     // 9 to 256 floats
-        }
-        else // EEPROM data is stale
-      #endif // AUTO_BED_LEVELING_BILINEAR
-        {
-          // Skip past disabled (or stale) Bilinear Grid data
-          int bgs[2], bs[2];
-          EEPROM_READ(bgs);
-          EEPROM_READ(bs);
-          for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
-        }
+      {
+        uint8_t grid_max_x, grid_max_y;
+        EEPROM_READ_ALWAYS(grid_max_x);                       // 1 byte
+        EEPROM_READ_ALWAYS(grid_max_y);                       // 1 byte
+        #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
+            if (!validating) set_bed_leveling_enabled(false);
+            EEPROM_READ(bilinear_grid_spacing);        // 2 ints
+            EEPROM_READ(bilinear_start);               // 2 ints
+            EEPROM_READ(z_values);                     // 9 to 256 floats
+          }
+          else // EEPROM data is stale
+        #endif // AUTO_BED_LEVELING_BILINEAR
+          {
+            // Skip past disabled (or stale) Bilinear Grid data
+            int bgs[2], bs[2];
+            EEPROM_READ(bgs);
+            EEPROM_READ(bs);
+            for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
+          }
+      }
 
       //
       // Unified Bed Leveling active state
       //
+      {
+        _FIELD_TEST(planner_leveling_active);
 
-      _FIELD_TEST(planner_leveling_active);
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EEPROM_READ(planner.leveling_active);
-        EEPROM_READ(ubl.storage_slot);
-      #else
-        uint8_t dummyui8;
-        EEPROM_READ(dummyb);
-        EEPROM_READ(dummyui8);
-      #endif // AUTO_BED_LEVELING_UBL
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          EEPROM_READ(planner.leveling_active);
+          EEPROM_READ(ubl.storage_slot);
+        #else
+          bool planner_leveling_active;
+          uint8_t ubl_storage_slot;
+          EEPROM_READ(planner_leveling_active);
+          EEPROM_READ(ubl_storage_slot);
+        #endif
+      }
 
       //
       // SERVO_ANGLES
       //
-      #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
-        uint16_t servo_angles[NUM_SERVOS][2];
-      #endif
-      EEPROM_READ(servo_angles);
+      {
+        #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+          uint16_t servo_angles[NUM_SERVOS][2];
+        #endif
+        EEPROM_READ(servo_angles);
+      }
 
       //
       // DELTA Geometry or Dual Endstops offsets
       //
+      {
+        #if ENABLED(DELTA)
 
-      #if ENABLED(DELTA)
+          _FIELD_TEST(delta_height);
 
-        _FIELD_TEST(delta_height);
+          EEPROM_READ(delta_height);              // 1 float
+          EEPROM_READ(delta_endstop_adj);         // 3 floats
+          EEPROM_READ(delta_radius);              // 1 float
+          EEPROM_READ(delta_diagonal_rod);        // 1 float
+          EEPROM_READ(delta_segments_per_second); // 1 float
+          EEPROM_READ(delta_calibration_radius);  // 1 float
+          EEPROM_READ(delta_tower_angle_trim);    // 3 floats
 
-        EEPROM_READ(delta_height);              // 1 float
-        EEPROM_READ(delta_endstop_adj);         // 3 floats
-        EEPROM_READ(delta_radius);              // 1 float
-        EEPROM_READ(delta_diagonal_rod);        // 1 float
-        EEPROM_READ(delta_segments_per_second); // 1 float
-        EEPROM_READ(delta_calibration_radius);  // 1 float
-        EEPROM_READ(delta_tower_angle_trim);    // 3 floats
+        #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
-      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+          _FIELD_TEST(x2_endstop_adj);
 
-        _FIELD_TEST(x2_endstop_adj);
+          #if ENABLED(X_DUAL_ENDSTOPS)
+            EEPROM_READ(endstops.x2_endstop_adj);  // 1 float
+          #else
+            EEPROM_READ(dummy);
+          #endif
+          #if ENABLED(Y_DUAL_ENDSTOPS)
+            EEPROM_READ(endstops.y2_endstop_adj);  // 1 float
+          #else
+            EEPROM_READ(dummy);
+          #endif
+          #if Z_MULTI_ENDSTOPS
+            EEPROM_READ(endstops.z2_endstop_adj); // 1 float
+          #else
+            EEPROM_READ(dummy);
+          #endif
+          #if ENABLED(Z_TRIPLE_ENDSTOPS)
+            EEPROM_READ(endstops.z3_endstop_adj); // 1 float
+          #else
+            EEPROM_READ(dummy);
+          #endif
 
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          EEPROM_READ(endstops.x2_endstop_adj);  // 1 float
-        #else
-          EEPROM_READ(dummy);
-        #endif
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          EEPROM_READ(endstops.y2_endstop_adj);  // 1 float
-        #else
-          EEPROM_READ(dummy);
-        #endif
-        #if Z_MULTI_ENDSTOPS
-          EEPROM_READ(endstops.z2_endstop_adj); // 1 float
-        #else
-          EEPROM_READ(dummy);
         #endif
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
-          EEPROM_READ(endstops.z3_endstop_adj); // 1 float
-        #else
-          EEPROM_READ(dummy);
-        #endif
-
-      #endif
+      }
 
       //
       // LCD Preheat settings
       //
+      {
+        _FIELD_TEST(lcd_preheat_hotend_temp);
 
-      _FIELD_TEST(lcd_preheat_hotend_temp);
-
-      #if DISABLED(ULTIPANEL)
-        int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
-        uint8_t lcd_preheat_fan_speed[2];
-      #endif
-      EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
-      EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
-      EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
+        #if DISABLED(ULTIPANEL)
+          int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
+          uint8_t lcd_preheat_fan_speed[2];
+        #endif
+        EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
+        EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
+        EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
+      }
 
       //
       // Hotend PID

commit d015f746cc8f8e2dd930d7c87165825993743351
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 26 03:53:06 2018 -0500

    Fix some compile warnings (#12220)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 66e65478c1..2e34fb3028 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -927,7 +927,7 @@ void MarlinSettings::postprocess() {
     //
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
-        const fil_change_settings_t fc_settings[EXTRUDERS] = { { 0 } };
+        const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
       #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);

commit d801f8596386d06db6a8696f18c966e27e1de14d
Author: Roman Moravčík <roman.moravcik@gmail.com>
Date:   Sun Oct 21 09:56:31 2018 +0200

    Correct EEPROM read/write disparities. (#12169)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 16e30e41fe..66e65478c1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V61"
+#define EEPROM_VERSION "V62"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -194,10 +194,8 @@ typedef struct SettingsDataStruct {
   #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
-          z2_endstop_adj;                               // M666 Z
-    #if ENABLED(Z_TRIPLE_ENDSTOPS)
-      float z3_endstop_adj;                             // M666 Z
-    #endif
+          z2_endstop_adj,                               // M666 Z (S2)
+          z3_endstop_adj;                               // M666 Z (S3)
   #endif
 
   //
@@ -939,7 +937,7 @@ void MarlinSettings::postprocess() {
     // SINGLENOZZLE
     //
 
-    #if ENABLED(SINGLENOZZLE)
+    #if EXTRUDERS > 1
       _FIELD_TEST(toolchange_settings);
       EEPROM_WRITE(toolchange_settings);
     #endif
@@ -1567,7 +1565,7 @@ void MarlinSettings::postprocess() {
       //
       // SINGLENOZZLE toolchange values
       //
-      #if ENABLED(SINGLENOZZLE)
+      #if EXTRUDERS > 1
         _FIELD_TEST(toolchange_settings);
         EEPROM_READ(toolchange_settings);
       #endif
@@ -1831,16 +1829,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if EXTRUDERS > 1
-    toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
-  #endif
-  
-  #if ENABLED(SINGLENOZZLE)
-    toolchange_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
-    toolchange_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
-    toolchange_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
-    #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-      toolchange_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
+    #if ENABLED(SINGLENOZZLE)
+      toolchange_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
+      toolchange_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
+      toolchange_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+      #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+        toolchange_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
+      #endif
     #endif
+    toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
   #endif
 
   //

commit b64157109872c696c328cc2b19bdfa314007a5e7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 20 16:10:50 2018 -0500

    Replace types.h with millis_t.h

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index bb3e341cb1..16e30e41fe 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -81,13 +81,8 @@
   #include "../module/probe.h"
 #endif
 
-#if ENABLED(FWRETRACT)
-  #include "../feature/fwretract.h"
-#endif
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "../feature/pause.h"
-#endif
+#include "../feature/fwretract.h"
+#include "../feature/pause.h"
 
 #if EXTRUDERS > 1
   #include "tool_change.h"

commit 3ec38727305862c881f268e2fc27f8188b5bc767
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 17 12:11:41 2018 -0400

    Single Z raise value for all tool-changing / parking (#12090)
    
    * Universal tool-change Z lift
    * Add TOOLCHANGE_ZRAISE to example configs
    * Park/unpark changes to example configs
    * Implement DEBUG_DXC_MODE

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index c359710ab3..bb3e341cb1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -89,7 +89,7 @@
   #include "../feature/pause.h"
 #endif
 
-#if ENABLED(SINGLENOZZLE)
+#if EXTRUDERS > 1
   #include "tool_change.h"
   void M217_report(const bool eeprom);
 #endif
@@ -275,8 +275,8 @@ typedef struct SettingsDataStruct {
   //
   // SINGLENOZZLE toolchange values
   //
-  #if ENABLED(SINGLENOZZLE)
-    singlenozzle_settings_t sn_settings;                // M217 S P R
+  #if EXTRUDERS > 1
+    toolchange_settings_t toolchange_settings;                // M217 S P R
   #endif
 
 } SettingsData;
@@ -945,8 +945,8 @@ void MarlinSettings::postprocess() {
     //
 
     #if ENABLED(SINGLENOZZLE)
-      _FIELD_TEST(sn_settings);
-      EEPROM_WRITE(sn_settings);
+      _FIELD_TEST(toolchange_settings);
+      EEPROM_WRITE(toolchange_settings);
     #endif
 
     //
@@ -1573,8 +1573,8 @@ void MarlinSettings::postprocess() {
       // SINGLENOZZLE toolchange values
       //
       #if ENABLED(SINGLENOZZLE)
-        _FIELD_TEST(sn_settings);
-        EEPROM_READ(sn_settings);
+        _FIELD_TEST(toolchange_settings);
+        EEPROM_READ(toolchange_settings);
       #endif
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
@@ -1835,13 +1835,16 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
   #endif
 
+  #if EXTRUDERS > 1
+    toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
+  #endif
+  
   #if ENABLED(SINGLENOZZLE)
-    sn_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
-    sn_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
-    sn_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
-    sn_settings.z_raise = SINGLENOZZLE_TOOLCHANGE_ZRAISE;
+    toolchange_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
+    toolchange_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
+    toolchange_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
     #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-      sn_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
+      toolchange_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
     #endif
   #endif
 

commit 8bf596bd4cb6879eb50994d497b30acf84082395
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 16 16:46:24 2018 -0500

    RETRACT_ZLIFT => RETRACT_ZRAISE

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 54eb69825d..c359710ab3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2552,7 +2552,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
       SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
       SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.settings.retract_zlift));
+      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.settings.retract_zraise));
 
       if (!forReplay) {
         CONFIG_ECHO_START;

commit a40458405ad4fb8ebe8d90a4271d69f9b8282bc4
Author: Karl Andersson <karl@iaccess.se>
Date:   Sun Oct 14 09:14:34 2018 +0200

    Fix datasize error when FWRETRACT is disabled (#12086)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index bb45cc0f1d..54eb69825d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1313,6 +1313,9 @@ void MarlinSettings::postprocess() {
 
         #if ENABLED(FWRETRACT)
           EEPROM_READ(fwretract.settings);
+        #else
+          fwretract_settings_t fwretract_settings;
+          EEPROM_READ(fwretract_settings);
         #endif
         #if ENABLED(FWRETRACT) && ENABLED(FWRETRACT_AUTORETRACT)
           EEPROM_READ(fwretract.autoretract_enabled);

commit 951b25163e8b9e09212594b47c26434f23dc1a1e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 13 23:08:20 2018 -0500

    Extend M217 with configurable park/raise (#12076)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 150f562802..bb45cc0f1d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1836,6 +1836,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     sn_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
     sn_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
     sn_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+    sn_settings.z_raise = SINGLENOZZLE_TOOLCHANGE_ZRAISE;
+    #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+      sn_settings.change_point = SINGLENOZZLE_TOOLCHANGE_XY;
+    #endif
   #endif
 
   //
@@ -2096,15 +2100,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
      */
     CONFIG_ECHO_START;
     #if ENABLED(INCH_MODE_SUPPORT)
-      #define LINEAR_UNIT(N) (float(N) / parser.linear_unit_factor)
-      #define VOLUMETRIC_UNIT(N) (float(N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
       SERIAL_ECHOPGM_P(port, "  G2");
       SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
       SERIAL_ECHOPGM_P(port, " ;");
       SAY_UNITS_P(port, false);
     #else
-      #define LINEAR_UNIT(N) (N)
-      #define VOLUMETRIC_UNIT(N) (N)
       SERIAL_ECHOPGM_P(port, "  G21    ; Units in mm");
       SAY_UNITS_P(port, false);
     #endif
@@ -2116,13 +2116,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       CONFIG_ECHO_START;
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        #define TEMP_UNIT(N) parser.to_temp_units(N)
         SERIAL_ECHOPGM_P(port, "  M149 ");
         SERIAL_CHAR_P(port, parser.temp_units_code());
         SERIAL_ECHOPGM_P(port, " ; Units in ");
         serialprintPGM_P(port, parser.temp_units_name());
       #else
-        #define TEMP_UNIT(N) (N)
         SERIAL_ECHOLNPGM_P(port, "  M149 C ; Units in Celsius");
       #endif
 

commit e8d2cf4fb55324a421f9c3f517712cc9a717200c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 10 17:20:48 2018 -0500

    EEPROM followup (tmc_stepper_current_t)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3d4a1e42e4..150f562802 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -197,9 +197,9 @@ typedef struct SettingsDataStruct {
           delta_calibration_radius,                     // M665 B
           delta_tower_angle_trim[ABC];                  // M665 XYZ
   #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
-    float x2_endstop_adj,                                // M666 X
-          y2_endstop_adj,                                // M666 Y
-          z2_endstop_adj;                                // M666 Z
+    float x2_endstop_adj,                               // M666 X
+          y2_endstop_adj,                               // M666 Y
+          z2_endstop_adj;                               // M666 Z
     #if ENABLED(Z_TRIPLE_ENDSTOPS)
       float z3_endstop_adj;                             // M666 Z
     #endif
@@ -243,7 +243,6 @@ typedef struct SettingsDataStruct {
   //
   // HAS_TRINAMIC
   //
-  #define TMC_AXES (MAX_EXTRUDERS + 7)
   tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   tmc_sgt_t tmc_sgt;                                    // M914 X Y Z
@@ -1353,13 +1352,12 @@ void MarlinSettings::postprocess() {
       {
         _FIELD_TEST(tmc_stepper_current);
 
-        tmc_stepper_current_t tmc_stepper_current;
+        tmc_stepper_current_t currents;
+        EEPROM_READ(currents);
 
         #if HAS_TRINAMIC
 
           #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
-          tmc_stepper_current_t currents;
-          EEPROM_READ(currents);
           if (!validating) {
             #if AXIS_IS_TMC(X)
               SET_CURR(X);
@@ -1401,9 +1399,6 @@ void MarlinSettings::postprocess() {
               SET_CURR(E5);
             #endif
           }
-        #else
-          uint16_t val;
-          for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
         #endif
       }
 

commit d332fcb8fa34d7012b08f4f06f8354cca64d0fb4
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 10 17:46:08 2018 -0400

    Fix firmware-retract compile errors (#12061)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f5c63a321e..3d4a1e42e4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -697,11 +697,14 @@ void MarlinSettings::postprocess() {
 
       #if ENABLED(FWRETRACT)
         EEPROM_WRITE(fwretract.settings);
-        EEPROM_WRITE(fwretract.autoretract_enabled);
       #else
         const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
-        const bool autoretract_enabled = false;
         EEPROM_WRITE(autoretract_defaults);
+      #endif
+      #if ENABLED(FWRETRACT) && ENABLED(FWRETRACT_AUTORETRACT)
+        EEPROM_WRITE(fwretract.autoretract_enabled);
+      #else
+        const bool autoretract_enabled = false;
         EEPROM_WRITE(autoretract_enabled);
       #endif
     }
@@ -1311,11 +1314,11 @@ void MarlinSettings::postprocess() {
 
         #if ENABLED(FWRETRACT)
           EEPROM_READ(fwretract.settings);
+        #endif
+        #if ENABLED(FWRETRACT) && ENABLED(FWRETRACT_AUTORETRACT)
           EEPROM_READ(fwretract.autoretract_enabled);
         #else
-          fwretract_settings_t fwretract_settings;
           bool autoretract_enabled;
-          EEPROM_READ(fwretract_settings);
           EEPROM_READ(autoretract_enabled);
         #endif
       }
@@ -1575,7 +1578,7 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(sn_settings);
         EEPROM_READ(sn_settings);
       #endif
-  
+
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         #if ENABLED(EEPROM_CHITCHAT)

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1897a53bb4..f5c63a321e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -81,15 +81,6 @@
   #include "../module/probe.h"
 #endif
 
-#if HAS_TRINAMIC
-  #include "stepper_indirection.h"
-  #include "../feature/tmc_util.h"
-  #define TMC_GET_PWMTHRS(A,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.axis_steps_per_mm[_AXIS(A)])
-#endif
-typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
-typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z;                                         } tmc_sgt_t;
-
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
@@ -103,14 +94,20 @@ typedef struct {  int16_t X, Y, Z;                                         } tmc
   void M217_report(const bool eeprom);
 #endif
 
-#if ENABLED(PID_EXTRUSION_SCALING)
-  #define LPQ_LEN thermalManager.lpq_len
+#if HAS_TRINAMIC
+  #include "stepper_indirection.h"
+  #include "../feature/tmc_util.h"
+  #define TMC_GET_PWMTHRS(A,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.settings.axis_steps_per_mm[_AXIS(A)])
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
-typedef struct PID  { float Kp, Ki, Kd;     } PID;
-typedef struct PIDC { float Kp, Ki, Kd, Kc; } PIDC;
+typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
+typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
+typedef struct {  int16_t X, Y, Z;                                         } tmc_sgt_t;
+
+// Limit an index to an array size
+#define ALIM(I,ARR) MIN(I, COUNT(ARR) - 1)
 
 /**
  * Current EEPROM Layout
@@ -127,17 +124,10 @@ typedef struct SettingsDataStruct {
   //
   uint8_t   esteppers;                                  // XYZE_N - XYZ
 
-  uint32_t  planner_max_acceleration_mm_per_s2[XYZE_N], // M201 XYZE  planner.max_acceleration_mm_per_s2[XYZE_N]
-            planner_min_segment_time_us;                // M205 B     planner.min_segment_time_us
-  float     planner_axis_steps_per_mm[XYZE_N],          // M92 XYZE   planner.axis_steps_per_mm[XYZE_N]
-            planner_max_feedrate_mm_s[XYZE_N],          // M203 XYZE  planner.max_feedrate_mm_s[XYZE_N]
-            planner_acceleration,                       // M204 P     planner.acceleration
-            planner_retract_acceleration,               // M204 R     planner.retract_acceleration
-            planner_travel_acceleration,                // M204 T     planner.travel_acceleration
-            planner_min_feedrate_mm_s,                  // M205 S     planner.min_feedrate_mm_s
-            planner_min_travel_feedrate_mm_s,           // M205 T     planner.min_travel_feedrate_mm_s
-            planner_max_jerk[XYZE],                     // M205 XYZE  planner.max_jerk[XYZE]
-            planner_junction_deviation_mm;              // M205 J     planner.junction_deviation_mm
+  planner_settings_t planner_settings;
+
+  float planner_max_jerk[XYZE],                         // M205 XYZE  planner.max_jerk[XYZE]
+        planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
   float home_offset[XYZ];                               // M206 XYZ
 
@@ -225,32 +215,24 @@ typedef struct SettingsDataStruct {
   //
   // PIDTEMP
   //
-  PIDC hotendPID[HOTENDS];                              // M301 En PIDC / M303 En U
-
+  PIDC_t hotendPID[HOTENDS];                            // M301 En PIDC / M303 En U
   int16_t lpq_len;                                      // M301 L
 
   //
   // PIDTEMPBED
   //
-  PID bedPID;                                           // M304 PID / M303 E-1 U
+  PID_t bedPID;                                         // M304 PID / M303 E-1 U
 
   //
   // HAS_LCD_CONTRAST
   //
-  int16_t lcd_contrast;                                // M250 C
+  int16_t lcd_contrast;                                 // M250 C
 
   //
   // FWRETRACT
   //
+  fwretract_settings_t fwretract_settings;              // M207 S F Z W, M208 S F W R
   bool autoretract_enabled;                             // M209 S
-  float retract_length,                                 // M207 S
-        retract_feedrate_mm_s,                          // M207 F
-        retract_zlift,                                  // M207 Z
-        retract_recover_length,                         // M208 S
-        retract_recover_feedrate_mm_s,                  // M208 F
-        swap_retract_length,                            // M207 W
-        swap_retract_recover_length,                    // M208 W
-        swap_retract_recover_feedrate_mm_s;             // M208 R
 
   //
   // !NO_VOLUMETRIC
@@ -274,7 +256,7 @@ typedef struct SettingsDataStruct {
   //
   // HAS_MOTOR_CURRENT_PWM
   //
-  uint32_t motor_current_setting[XYZ];                  // M907 X Z E
+  uint32_t motor_current_setting[3];                    // M907 X Z E
 
   //
   // CNC_COORDINATE_SYSTEMS
@@ -284,29 +266,22 @@ typedef struct SettingsDataStruct {
   //
   // SKEW_CORRECTION
   //
-  float planner_xy_skew_factor,                         // M852 I  planner.xy_skew_factor
-        planner_xz_skew_factor,                         // M852 J  planner.xz_skew_factor
-        planner_yz_skew_factor;                         // M852 K  planner.yz_skew_factor
+  skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
 
   //
   // ADVANCED_PAUSE_FEATURE
   //
-  float filament_change_unload_length[EXTRUDERS],       // M603 T U
-        filament_change_load_length[EXTRUDERS];         // M603 T L
+  fil_change_settings_t fc_settings[EXTRUDERS];         // M603 T U L
 
   //
   // SINGLENOZZLE toolchange values
   //
   #if ENABLED(SINGLENOZZLE)
-    float singlenozzle_swap_length;                     // M217 S
-    int16_t singlenozzle_prime_speed,                   // M217 P
-            singlenozzle_retract_speed;                 // M217 R
+    singlenozzle_settings_t sn_settings;                // M217 S P R
   #endif
 
 } SettingsData;
 
-#pragma pack(pop)
-
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
@@ -405,14 +380,13 @@ void MarlinSettings::postprocess() {
 #if ENABLED(EEPROM_SETTINGS)
   #include "../HAL/shared/persistent_store_api.h"
 
-  #define DUMMY_PID_VALUE 3000.0f
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
   #define EEPROM_FINISH() persistentStore.access_finish()
   #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
   #define EEPROM_WRITE(VAR) persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_READ(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
   #define EEPROM_READ_ALWAYS(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START_P(port); SERIAL_ERRORLNPGM_P(port, ERR); eeprom_error = true; }while(0)
+  #define EEPROM_ASSERT(TST,ERR) do{ if (!(TST)) { SERIAL_ERROR_START_P(port); SERIAL_ERRORLNPGM_P(port, ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
@@ -462,18 +436,10 @@ void MarlinSettings::postprocess() {
 
     _FIELD_TEST(esteppers);
 
-    const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
+    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
 
-    EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
-    EEPROM_WRITE(planner.min_segment_time_us);
-    EEPROM_WRITE(planner.axis_steps_per_mm);
-    EEPROM_WRITE(planner.max_feedrate_mm_s);
-    EEPROM_WRITE(planner.acceleration);
-    EEPROM_WRITE(planner.retract_acceleration);
-    EEPROM_WRITE(planner.travel_acceleration);
-    EEPROM_WRITE(planner.min_feedrate_mm_s);
-    EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
+    EEPROM_WRITE(planner.settings);
 
     #if HAS_CLASSIC_JERK
       EEPROM_WRITE(planner.max_jerk);
@@ -678,40 +644,43 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(lcd_preheat_bed_temp);
     EEPROM_WRITE(lcd_preheat_fan_speed);
 
-    for (uint8_t e = 0; e < HOTENDS; e++) {
-      #if ENABLED(PIDTEMP)
-        EEPROM_WRITE(PID_PARAM(Kp, e));
-        EEPROM_WRITE(PID_PARAM(Ki, e));
-        EEPROM_WRITE(PID_PARAM(Kd, e));
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          EEPROM_WRITE(PID_PARAM(Kc, e));
-        #else
-          dummy = 1.0f; // 1.0 = default kc
-          EEPROM_WRITE(dummy);
-        #endif
+    //
+    // PIDTEMP
+    //
+    {
+      _FIELD_TEST(hotendPID);
+      HOTEND_LOOP() {
+        PIDC_t pidc = {
+          PID_PARAM(Kp, e), PID_PARAM(Ki, e), PID_PARAM(Kd, e), PID_PARAM(Kc, e)
+        };
+        EEPROM_WRITE(pidc);
+      }
+
+      _FIELD_TEST(lpq_len);
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        EEPROM_WRITE(thermalManager.lpq_len);
       #else
-        dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
-        EEPROM_WRITE(dummy); // Kp
-        dummy = 0;
-        for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
+        const int16_t lpq_len = 20;
+        EEPROM_WRITE(lpq_len);
       #endif
-    } // Hotends Loop
-
-    _FIELD_TEST(lpq_len);
+    }
 
-    #if DISABLED(PID_EXTRUSION_SCALING)
-      const int16_t LPQ_LEN = 20;
-    #endif
-    EEPROM_WRITE(LPQ_LEN);
+    //
+    // PIDTEMPBED
+    //
+    {
+      _FIELD_TEST(bedPID);
+      #if DISABLED(PIDTEMPBED)
+        const PID_t bed_pid = { DUMMY_PID_VALUE, DUMMY_PID_VALUE, DUMMY_PID_VALUE };
+        EEPROM_WRITE(bed_pid);
+      #else
+        EEPROM_WRITE(thermalManager.bed_pid);
+      #endif
+    }
 
-    #if DISABLED(PIDTEMPBED)
-      dummy = DUMMY_PID_VALUE;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
-    #else
-      EEPROM_WRITE(thermalManager.bedKp);
-      EEPROM_WRITE(thermalManager.bedKi);
-      EEPROM_WRITE(thermalManager.bedKd);
-    #endif
+    //
+    // LCD Contrast
+    //
 
     _FIELD_TEST(lcd_contrast);
 
@@ -720,228 +689,224 @@ void MarlinSettings::postprocess() {
     #endif
     EEPROM_WRITE(lcd_contrast);
 
-    const bool autoretract_enabled =
-      #if DISABLED(FWRETRACT_AUTORETRACT)
-        false
+    //
+    // Firmware Retraction
+    //
+    {
+      _FIELD_TEST(fwretract_settings);
+
+      #if ENABLED(FWRETRACT)
+        EEPROM_WRITE(fwretract.settings);
+        EEPROM_WRITE(fwretract.autoretract_enabled);
       #else
-        fwretract.autoretract_enabled
+        const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
+        const bool autoretract_enabled = false;
+        EEPROM_WRITE(autoretract_defaults);
+        EEPROM_WRITE(autoretract_enabled);
       #endif
-    ;
-    EEPROM_WRITE(autoretract_enabled);
-
-    #if DISABLED(FWRETRACT)
-      const float autoretract_defaults[] = { 3, 45, 0, 0, 0, 13, 0, 8 };
-      EEPROM_WRITE(autoretract_defaults);
-    #else
-      EEPROM_WRITE(fwretract.retract_length);
-      EEPROM_WRITE(fwretract.retract_feedrate_mm_s);
-      EEPROM_WRITE(fwretract.retract_zlift);
-      EEPROM_WRITE(fwretract.retract_recover_length);
-      EEPROM_WRITE(fwretract.retract_recover_feedrate_mm_s);
-      EEPROM_WRITE(fwretract.swap_retract_length);
-      EEPROM_WRITE(fwretract.swap_retract_recover_length);
-      EEPROM_WRITE(fwretract.swap_retract_recover_feedrate_mm_s);
-    #endif
+    }
 
     //
     // Volumetric & Filament Size
     //
+    {
+      _FIELD_TEST(parser_volumetric_enabled);
 
-    _FIELD_TEST(parser_volumetric_enabled);
-
-    #if DISABLED(NO_VOLUMETRICS)
-
-      EEPROM_WRITE(parser.volumetric_enabled);
+      #if DISABLED(NO_VOLUMETRICS)
 
-      // Save filament sizes
-      for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
-        EEPROM_WRITE(planner.filament_size[q]);
+        EEPROM_WRITE(parser.volumetric_enabled);
+        EEPROM_WRITE(planner.filament_size);
 
-    #else
+      #else
 
-      const bool volumetric_enabled = false;
-      dummy = DEFAULT_NOMINAL_FILAMENT_DIA;
-      EEPROM_WRITE(volumetric_enabled);
-      for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+        const bool volumetric_enabled = false;
+        dummy = DEFAULT_NOMINAL_FILAMENT_DIA;
+        EEPROM_WRITE(volumetric_enabled);
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
 
-    #endif
+      #endif
+    }
 
     //
-    // Save TMC Configuration, and placeholder values
+    // TMC Configuration
     //
+    {
+      _FIELD_TEST(tmc_stepper_current);
 
-    _FIELD_TEST(tmc_stepper_current);
-
-    tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+      tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
-    #if HAS_TRINAMIC
-      #if AXIS_IS_TMC(X)
-        tmc_stepper_current.X = stepperX.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(Y)
-        tmc_stepper_current.Y = stepperY.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(Z)
-        tmc_stepper_current.Z = stepperZ.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(X2)
-        tmc_stepper_current.X2 = stepperX2.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        tmc_stepper_current.Y2 = stepperY2.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(Z2)
-        tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
-      #endif
-      #if AXIS_IS_TMC(Z3)
-        tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
-      #endif
-      #if MAX_EXTRUDERS
-        #if AXIS_IS_TMC(E0)
-          tmc_stepper_current.E0 = stepperE0.getMilliamps();
+      #if HAS_TRINAMIC
+        #if AXIS_IS_TMC(X)
+          tmc_stepper_current.X = stepperX.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y)
+          tmc_stepper_current.Y = stepperY.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z)
+          tmc_stepper_current.Z = stepperZ.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(X2)
+          tmc_stepper_current.X2 = stepperX2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          tmc_stepper_current.Y2 = stepperY2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
         #endif
-        #if MAX_EXTRUDERS > 1
-          #if AXIS_IS_TMC(E1)
-            tmc_stepper_current.E1 = stepperE1.getMilliamps();
+        #if AXIS_IS_TMC(Z3)
+          tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
+        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_IS_TMC(E0)
+            tmc_stepper_current.E0 = stepperE0.getMilliamps();
           #endif
-          #if MAX_EXTRUDERS > 2
-            #if AXIS_IS_TMC(E2)
-              tmc_stepper_current.E2 = stepperE2.getMilliamps();
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_IS_TMC(E1)
+              tmc_stepper_current.E1 = stepperE1.getMilliamps();
             #endif
-            #if MAX_EXTRUDERS > 3
-              #if AXIS_IS_TMC(E3)
-                tmc_stepper_current.E3 = stepperE3.getMilliamps();
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_IS_TMC(E2)
+                tmc_stepper_current.E2 = stepperE2.getMilliamps();
               #endif
-              #if MAX_EXTRUDERS > 4
-                #if AXIS_IS_TMC(E4)
-                  tmc_stepper_current.E4 = stepperE4.getMilliamps();
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_IS_TMC(E3)
+                  tmc_stepper_current.E3 = stepperE3.getMilliamps();
                 #endif
-                #if MAX_EXTRUDERS > 5
-                  #if AXIS_IS_TMC(E5)
-                    tmc_stepper_current.E5 = stepperE5.getMilliamps();
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_IS_TMC(E4)
+                    tmc_stepper_current.E4 = stepperE4.getMilliamps();
                   #endif
-                #endif // MAX_EXTRUDERS > 5
-              #endif // MAX_EXTRUDERS > 4
-            #endif // MAX_EXTRUDERS > 3
-          #endif // MAX_EXTRUDERS > 2
-        #endif // MAX_EXTRUDERS > 1
-      #endif // MAX_EXTRUDERS
-    #endif
-    EEPROM_WRITE(tmc_stepper_current);
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_IS_TMC(E5)
+                      tmc_stepper_current.E5 = stepperE5.getMilliamps();
+                    #endif
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #endif
+      EEPROM_WRITE(tmc_stepper_current);
+    }
 
     //
-    // Save TMC Hybrid Threshold, and placeholder values
+    // TMC Hybrid Threshold, and placeholder values
     //
+    {
+      _FIELD_TEST(tmc_hybrid_threshold);
 
-    _FIELD_TEST(tmc_hybrid_threshold);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-     tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-     #if AXIS_HAS_STEALTHCHOP(X)
-        tmc_hybrid_threshold.X = TMC_GET_PWMTHRS(X, X);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Y)
-        tmc_hybrid_threshold.Y = TMC_GET_PWMTHRS(Y, Y);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z)
-        tmc_hybrid_threshold.Z = TMC_GET_PWMTHRS(Z, Z);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(X2)
-        tmc_hybrid_threshold.X2 = TMC_GET_PWMTHRS(X, X2);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Y2)
-        tmc_hybrid_threshold.Y2 = TMC_GET_PWMTHRS(Y, Y2);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z2)
-        tmc_hybrid_threshold.Z2 = TMC_GET_PWMTHRS(Z, Z2);
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z3)
-        tmc_hybrid_threshold.Z3 = TMC_GET_PWMTHRS(Z, Z3);
-      #endif
-      #if MAX_EXTRUDERS
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          tmc_hybrid_threshold.E0 = TMC_GET_PWMTHRS(E, E0);
+      #if ENABLED(HYBRID_THRESHOLD)
+       tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+        #if AXIS_HAS_STEALTHCHOP(X)
+          tmc_hybrid_threshold.X = TMC_GET_PWMTHRS(X, X);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          tmc_hybrid_threshold.Y = TMC_GET_PWMTHRS(Y, Y);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          tmc_hybrid_threshold.Z = TMC_GET_PWMTHRS(Z, Z);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          tmc_hybrid_threshold.X2 = TMC_GET_PWMTHRS(X, X2);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          tmc_hybrid_threshold.Y2 = TMC_GET_PWMTHRS(Y, Y2);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          tmc_hybrid_threshold.Z2 = TMC_GET_PWMTHRS(Z, Z2);
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          tmc_hybrid_threshold.Z3 = TMC_GET_PWMTHRS(Z, Z3);
         #endif
-        #if MAX_EXTRUDERS > 1
-          #if AXIS_HAS_STEALTHCHOP(E1)
-            tmc_hybrid_threshold.E1 = TMC_GET_PWMTHRS(E, E1);
+        #if MAX_EXTRUDERS
+          #if AXIS_HAS_STEALTHCHOP(E0)
+            tmc_hybrid_threshold.E0 = TMC_GET_PWMTHRS(E, E0);
           #endif
-          #if MAX_EXTRUDERS > 2
-            #if AXIS_HAS_STEALTHCHOP(E2)
-              tmc_hybrid_threshold.E2 = TMC_GET_PWMTHRS(E, E2);
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              tmc_hybrid_threshold.E1 = TMC_GET_PWMTHRS(E, E1);
             #endif
-            #if MAX_EXTRUDERS > 3
-              #if AXIS_HAS_STEALTHCHOP(E3)
-                tmc_hybrid_threshold.E3 = TMC_GET_PWMTHRS(E, E3);
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_HAS_STEALTHCHOP(E2)
+                tmc_hybrid_threshold.E2 = TMC_GET_PWMTHRS(E, E2);
               #endif
-              #if MAX_EXTRUDERS > 4
-                #if AXIS_HAS_STEALTHCHOP(E4)
-                  tmc_hybrid_threshold.E4 = TMC_GET_PWMTHRS(E, E4);
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_HAS_STEALTHCHOP(E3)
+                  tmc_hybrid_threshold.E3 = TMC_GET_PWMTHRS(E, E3);
                 #endif
-                #if MAX_EXTRUDERS > 5
-                  #if AXIS_HAS_STEALTHCHOP(E5)
-                    tmc_hybrid_threshold.E5 = TMC_GET_PWMTHRS(E, E5);
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_HAS_STEALTHCHOP(E4)
+                    tmc_hybrid_threshold.E4 = TMC_GET_PWMTHRS(E, E4);
                   #endif
-                #endif // MAX_EXTRUDERS > 5
-              #endif // MAX_EXTRUDERS > 4
-            #endif // MAX_EXTRUDERS > 3
-          #endif // MAX_EXTRUDERS > 2
-        #endif // MAX_EXTRUDERS > 1
-      #endif // MAX_EXTRUDERS
-    #else
-      const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
-        .X  = 100, .Y  = 100, .Z  =   3,
-        .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3,
-        .E0 =  30, .E1 =  30, .E2 =  30,
-        .E3 =  30, .E4 =  30, .E5 =  30
-      };
-    #endif
-    EEPROM_WRITE(tmc_hybrid_threshold);
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_HAS_STEALTHCHOP(E5)
+                      tmc_hybrid_threshold.E5 = TMC_GET_PWMTHRS(E, E5);
+                    #endif
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #else
+        const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
+          .X  = 100, .Y  = 100, .Z  =   3,
+          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3,
+          .E0 =  30, .E1 =  30, .E2 =  30,
+          .E3 =  30, .E4 =  30, .E5 =  30
+        };
+      #endif
+      EEPROM_WRITE(tmc_hybrid_threshold);
+    }
 
     //
     // TMC StallGuard threshold
     //
-
-    tmc_sgt_t tmc_sgt = { 0, 0, 0 };
-
-    #if USE_SENSORLESS
-      #if X_SENSORLESS
-        tmc_sgt.X = stepperX.sgt();
-      #endif
-      #if Y_SENSORLESS
-        tmc_sgt.Y = stepperY.sgt();
-      #endif
-      #if Z_SENSORLESS
-        tmc_sgt.Z = stepperZ.sgt();
+    {
+      tmc_sgt_t tmc_sgt = { 0, 0, 0 };
+      #if USE_SENSORLESS
+        #if X_SENSORLESS
+          tmc_sgt.X = stepperX.sgt();
+        #endif
+        #if Y_SENSORLESS
+          tmc_sgt.Y = stepperY.sgt();
+        #endif
+        #if Z_SENSORLESS
+          tmc_sgt.Z = stepperZ.sgt();
+        #endif
       #endif
-    #endif
-    EEPROM_WRITE(tmc_sgt);
+      EEPROM_WRITE(tmc_sgt);
+    }
 
     //
     // Linear Advance
     //
+    {
+      _FIELD_TEST(planner_extruder_advance_K);
 
-    _FIELD_TEST(planner_extruder_advance_K);
-
-    #if ENABLED(LIN_ADVANCE)
-      LOOP_L_N(i, EXTRUDERS) EEPROM_WRITE(planner.extruder_advance_K[i]);
-    #else
-      dummy = 0;
-      LOOP_L_N(i, EXTRUDERS) EEPROM_WRITE(dummy);
-    #endif
-
-    _FIELD_TEST(motor_current_setting);
+      #if ENABLED(LIN_ADVANCE)
+        EEPROM_WRITE(planner.extruder_advance_K);
+      #else
+        dummy = 0;
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+      #endif
+    }
 
     //
     // Motor Current PWM
     //
+    {
+      _FIELD_TEST(motor_current_setting);
 
-    #if HAS_MOTOR_CURRENT_PWM
-      for (uint8_t q = XYZ; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
-    #else
-      const uint32_t dummyui32[XYZ] = { 0 };
-      EEPROM_WRITE(dummyui32);
-    #endif
+      #if HAS_MOTOR_CURRENT_PWM
+        EEPROM_WRITE(stepper.motor_current_setting);
+      #else
+        const uint32_t dummyui32[XYZ] = { 0 };
+        EEPROM_WRITE(dummyui32);
+      #endif
+    }
 
     //
     // CNC Coordinate Systems
@@ -950,52 +915,36 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(coordinate_system);
 
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
-      EEPROM_WRITE(gcode.coordinate_system); // 27 floats
+      EEPROM_WRITE(gcode.coordinate_system);
     #else
-      dummy = 0;
-      for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_WRITE(dummy);
+      const float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ] = { { 0 } };
+      EEPROM_WRITE(coordinate_system);
     #endif
 
     //
     // Skew correction factors
     //
-
-    _FIELD_TEST(planner_xy_skew_factor);
-
-    #if ENABLED(SKEW_CORRECTION)
-      EEPROM_WRITE(planner.xy_skew_factor);
-      EEPROM_WRITE(planner.xz_skew_factor);
-      EEPROM_WRITE(planner.yz_skew_factor);
-    #else
-      dummy = 0;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
-    #endif
+    _FIELD_TEST(planner_skew_factor);
+    EEPROM_WRITE(planner.skew_factor);
 
     //
     // Advanced Pause filament load & unload lengths
     //
-
-    _FIELD_TEST(filament_change_unload_length);
-
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      for (uint8_t q = 0; q < COUNT(filament_change_unload_length); q++) {
-        EEPROM_WRITE(filament_change_unload_length[q]);
-        EEPROM_WRITE(filament_change_load_length[q]);
-      }
-    #else
-      dummy = 0;
-      for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
-    #endif
+    {
+      #if DISABLED(ADVANCED_PAUSE_FEATURE)
+        const fil_change_settings_t fc_settings[EXTRUDERS] = { { 0 } };
+      #endif
+      _FIELD_TEST(fc_settings);
+      EEPROM_WRITE(fc_settings);
+    }
 
     //
     // SINGLENOZZLE
     //
 
     #if ENABLED(SINGLENOZZLE)
-      _FIELD_TEST(singlenozzle_swap_length);
-      EEPROM_WRITE(singlenozzle_swap_length);
-      EEPROM_WRITE(singlenozzle_prime_speed);
-      EEPROM_WRITE(singlenozzle_retract_speed);
+      _FIELD_TEST(sn_settings);
+      EEPROM_WRITE(sn_settings);
     #endif
 
     //
@@ -1087,22 +1036,23 @@ void MarlinSettings::postprocess() {
 
       uint32_t tmp1[XYZ + esteppers];
       EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
-      EEPROM_READ(planner.min_segment_time_us);
+      EEPROM_READ(planner.settings.min_segment_time_us);
 
       float tmp2[XYZ + esteppers], tmp3[XYZ + esteppers];
       EEPROM_READ(tmp2);                         // axis_steps_per_mm
       EEPROM_READ(tmp3);                         // max_feedrate_mm_s
       if (!validating) LOOP_XYZE_N(i) {
-        planner.max_acceleration_mm_per_s2[i] = i < XYZ + esteppers ? tmp1[i] : def1[i < COUNT(def1) ? i : COUNT(def1) - 1];
-        planner.axis_steps_per_mm[i]          = i < XYZ + esteppers ? tmp2[i] : def2[i < COUNT(def2) ? i : COUNT(def2) - 1];
-        planner.max_feedrate_mm_s[i]          = i < XYZ + esteppers ? tmp3[i] : def3[i < COUNT(def3) ? i : COUNT(def3) - 1];
+        const bool in = (i < esteppers + XYZ);
+        planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : def1[ALIM(i, def1)];
+        planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : def2[ALIM(i, def2)];
+        planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : def3[ALIM(i, def3)];
       }
 
-      EEPROM_READ(planner.acceleration);
-      EEPROM_READ(planner.retract_acceleration);
-      EEPROM_READ(planner.travel_acceleration);
-      EEPROM_READ(planner.min_feedrate_mm_s);
-      EEPROM_READ(planner.min_travel_feedrate_mm_s);
+      EEPROM_READ(planner.settings.acceleration);
+      EEPROM_READ(planner.settings.retract_acceleration);
+      EEPROM_READ(planner.settings.travel_acceleration);
+      EEPROM_READ(planner.settings.min_feedrate_mm_s);
+      EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
       #if HAS_CLASSIC_JERK
         EEPROM_READ(planner.max_jerk);
@@ -1299,351 +1249,333 @@ void MarlinSettings::postprocess() {
       //
       // Hotend PID
       //
-
-      #if ENABLED(PIDTEMP)
-        for (uint8_t e = 0; e < HOTENDS; e++) {
-          EEPROM_READ(dummy); // Kp
-          if (dummy != DUMMY_PID_VALUE) {
-            // do not need to scale PID values as the values in EEPROM are already scaled
-            if (!validating) PID_PARAM(Kp, e) = dummy;
-            EEPROM_READ(PID_PARAM(Ki, e));
-            EEPROM_READ(PID_PARAM(Kd, e));
-            #if ENABLED(PID_EXTRUSION_SCALING)
-              EEPROM_READ(PID_PARAM(Kc, e));
-            #else
-              EEPROM_READ(dummy);
-            #endif
-          }
-          else
-            for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
+      {
+        HOTEND_LOOP() {
+          PIDC_t pidc;
+          EEPROM_READ(pidc);
+          #if ENABLED(PIDTEMP)
+            if (!validating && pidc.Kp != DUMMY_PID_VALUE) {
+              // No need to scale PID values since EEPROM values are scaled
+              PID_PARAM(Kp, e) = pidc.Kp;
+              PID_PARAM(Ki, e) = pidc.Ki;
+              PID_PARAM(Kd, e) = pidc.Kd;
+              #if ENABLED(PID_EXTRUSION_SCALING)
+                PID_PARAM(Kc, e) = pidc.Kc;
+              #endif
+            }
+          #endif
         }
-      #else // !PIDTEMP
-        // 4 x 4 = 16 slots for PID parameters
-        for (uint8_t q = HOTENDS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
-      #endif // !PIDTEMP
+      }
 
       //
       // PID Extrusion Scaling
       //
-
-      _FIELD_TEST(lpq_len);
-
-      #if DISABLED(PID_EXTRUSION_SCALING)
-        int16_t LPQ_LEN;
-      #endif
-      EEPROM_READ(LPQ_LEN);
+      {
+        _FIELD_TEST(lpq_len);
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          EEPROM_READ(thermalManager.lpq_len);
+        #else
+          int16_t lpq_len;
+          EEPROM_READ(lpq_len);
+        #endif
+      }
 
       //
       // Heated Bed PID
       //
-
-      #if ENABLED(PIDTEMPBED)
-        EEPROM_READ(dummy); // bedKp
-        if (dummy != DUMMY_PID_VALUE) {
-          if (!validating) thermalManager.bedKp = dummy;
-          EEPROM_READ(thermalManager.bedKi);
-          EEPROM_READ(thermalManager.bedKd);
-        }
-      #else
-        for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
-      #endif
+      {
+        PID_t pid;
+        EEPROM_READ(pid);
+        #if ENABLED(PIDTEMPBED)
+          if (!validating && pid.Kp != DUMMY_PID_VALUE)
+            memcpy(&thermalManager.bed_pid, &pid, sizeof(pid));
+        #endif
+      }
 
       //
       // LCD Contrast
       //
-
-      _FIELD_TEST(lcd_contrast);
-
-      #if !HAS_LCD_CONTRAST
-        int16_t lcd_contrast;
-      #endif
-      EEPROM_READ(lcd_contrast);
+      {
+        _FIELD_TEST(lcd_contrast);
+        #if !HAS_LCD_CONTRAST
+          int16_t lcd_contrast;
+        #endif
+        EEPROM_READ(lcd_contrast);
+      }
 
       //
       // Firmware Retraction
       //
+      {
+        _FIELD_TEST(fwretract_settings);
 
-      #if ENABLED(FWRETRACT)
-        #if DISABLED(FWRETRACT_AUTORETRACT)
-          EEPROM_READ(dummyb);
-        #else
+        #if ENABLED(FWRETRACT)
+          EEPROM_READ(fwretract.settings);
           EEPROM_READ(fwretract.autoretract_enabled);
+        #else
+          fwretract_settings_t fwretract_settings;
+          bool autoretract_enabled;
+          EEPROM_READ(fwretract_settings);
+          EEPROM_READ(autoretract_enabled);
         #endif
-        EEPROM_READ(fwretract.retract_length);
-        EEPROM_READ(fwretract.retract_feedrate_mm_s);
-        EEPROM_READ(fwretract.retract_zlift);
-        EEPROM_READ(fwretract.retract_recover_length);
-        EEPROM_READ(fwretract.retract_recover_feedrate_mm_s);
-        EEPROM_READ(fwretract.swap_retract_length);
-        EEPROM_READ(fwretract.swap_retract_recover_length);
-        EEPROM_READ(fwretract.swap_retract_recover_feedrate_mm_s);
-      #else
-        EEPROM_READ(dummyb);
-        for (uint8_t q=8; q--;) EEPROM_READ(dummy);
-      #endif
+      }
 
       //
       // Volumetric & Filament Size
       //
-
-      _FIELD_TEST(parser_volumetric_enabled);
-
-      #if DISABLED(NO_VOLUMETRICS)
-
-        EEPROM_READ(parser.volumetric_enabled);
-
-        for (uint8_t q = 0; q < COUNT(planner.filament_size); q++) {
-          EEPROM_READ(dummy);
-          if (!validating) planner.filament_size[q] = dummy;
-        }
-
-      #else
-
-        EEPROM_READ(dummyb);
-        for (uint8_t q=EXTRUDERS; q--;) EEPROM_READ(dummy);
-
-      #endif
-
-      if (!validating) reset_stepper_drivers();
+      {
+        struct {
+          bool volumetric_enabled;
+          float filament_size[EXTRUDERS];
+        } storage;
+
+        _FIELD_TEST(parser_volumetric_enabled);
+        EEPROM_READ(storage);
+
+        #if DISABLED(NO_VOLUMETRICS)
+          if (!validating) {
+            parser.volumetric_enabled = storage.volumetric_enabled;
+            COPY(planner.filament_size, storage.filament_size);
+          }
+        #endif
+      }
 
       //
       // TMC Stepper Settings
       //
 
-      _FIELD_TEST(tmc_stepper_current);
+      if (!validating) reset_stepper_drivers();
 
-      #if HAS_TRINAMIC
+      // TMC Stepper Current
+      {
+        _FIELD_TEST(tmc_stepper_current);
 
-        #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
-        tmc_stepper_current_t currents;
-        EEPROM_READ(currents);
-        if (!validating) {
-          #if AXIS_IS_TMC(X)
-            SET_CURR(X);
-          #endif
-          #if AXIS_IS_TMC(Y)
-            SET_CURR(Y);
-          #endif
-          #if AXIS_IS_TMC(Z)
-            SET_CURR(Z);
-          #endif
-          #if AXIS_IS_TMC(X2)
-            SET_CURR(X2);
-          #endif
-          #if AXIS_IS_TMC(Y2)
-            SET_CURR(Y2);
-          #endif
-          #if AXIS_IS_TMC(Z2)
-            SET_CURR(Z2);
-          #endif
-          #if AXIS_IS_TMC(Z3)
-            SET_CURR(Z3);
-          #endif
-          #if AXIS_IS_TMC(E0)
-            SET_CURR(E0);
-          #endif
-          #if AXIS_IS_TMC(E1)
-            SET_CURR(E1);
-          #endif
-          #if AXIS_IS_TMC(E2)
-            SET_CURR(E2);
-          #endif
-          #if AXIS_IS_TMC(E3)
-            SET_CURR(E3);
-          #endif
-          #if AXIS_IS_TMC(E4)
-            SET_CURR(E4);
-          #endif
-          #if AXIS_IS_TMC(E5)
-            SET_CURR(E5);
-          #endif
-        }
-      #else
-        uint16_t val;
-        for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
-      #endif
+        tmc_stepper_current_t tmc_stepper_current;
 
-      _FIELD_TEST(tmc_hybrid_threshold);
+        #if HAS_TRINAMIC
 
-      #if ENABLED(HYBRID_THRESHOLD)
-        #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold.Q, planner.axis_steps_per_mm[_AXIS(A)])
+          #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
+          tmc_stepper_current_t currents;
+          EEPROM_READ(currents);
+          if (!validating) {
+            #if AXIS_IS_TMC(X)
+              SET_CURR(X);
+            #endif
+            #if AXIS_IS_TMC(Y)
+              SET_CURR(Y);
+            #endif
+            #if AXIS_IS_TMC(Z)
+              SET_CURR(Z);
+            #endif
+            #if AXIS_IS_TMC(X2)
+              SET_CURR(X2);
+            #endif
+            #if AXIS_IS_TMC(Y2)
+              SET_CURR(Y2);
+            #endif
+            #if AXIS_IS_TMC(Z2)
+              SET_CURR(Z2);
+            #endif
+            #if AXIS_IS_TMC(Z3)
+              SET_CURR(Z3);
+            #endif
+            #if AXIS_IS_TMC(E0)
+              SET_CURR(E0);
+            #endif
+            #if AXIS_IS_TMC(E1)
+              SET_CURR(E1);
+            #endif
+            #if AXIS_IS_TMC(E2)
+              SET_CURR(E2);
+            #endif
+            #if AXIS_IS_TMC(E3)
+              SET_CURR(E3);
+            #endif
+            #if AXIS_IS_TMC(E4)
+              SET_CURR(E4);
+            #endif
+            #if AXIS_IS_TMC(E5)
+              SET_CURR(E5);
+            #endif
+          }
+        #else
+          uint16_t val;
+          for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
+        #endif
+      }
+
+      // TMC Hybrid Threshold
+      {
         tmc_hybrid_threshold_t tmc_hybrid_threshold;
+        _FIELD_TEST(tmc_hybrid_threshold);
         EEPROM_READ(tmc_hybrid_threshold);
-        if (!validating) {
-          #if AXIS_HAS_STEALTHCHOP(X)
-            TMC_SET_PWMTHRS(X, X);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Y)
-            TMC_SET_PWMTHRS(Y, Y);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Z)
-            TMC_SET_PWMTHRS(Z, Z);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(X2)
-            TMC_SET_PWMTHRS(X, X2);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Y2)
-            TMC_SET_PWMTHRS(Y, Y2);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Z2)
-            TMC_SET_PWMTHRS(Z, Z2);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(Z3)
-            TMC_SET_PWMTHRS(Z, Z3);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            TMC_SET_PWMTHRS(E, E0);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E1)
-            TMC_SET_PWMTHRS(E, E1);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E2)
-            TMC_SET_PWMTHRS(E, E2);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E3)
-            TMC_SET_PWMTHRS(E, E3);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E4)
-            TMC_SET_PWMTHRS(E, E4);
-          #endif
-          #if AXIS_HAS_STEALTHCHOP(E5)
-            TMC_SET_PWMTHRS(E, E5);
-          #endif
-        }
-      #else
-        uint32_t thrs_val;
-        for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(thrs_val);
-      #endif
 
-      /**
-       * TMC StallGuard threshold.
-       * X and X2 use the same value
-       * Y and Y2 use the same value
-       * Z, Z2 and Z3 use the same value
-       */
-
-      _FIELD_TEST(tmc_sgt);
-
-      tmc_sgt_t tmc_sgt;
-      EEPROM_READ(tmc_sgt);
-      #if USE_SENSORLESS
-        if (!validating) {
-          #ifdef X_STALL_SENSITIVITY
-            #if AXIS_HAS_STALLGUARD(X)
-              stepperX.sgt(tmc_sgt.X);
+        #if ENABLED(HYBRID_THRESHOLD)
+          #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold.Q, planner.settings.axis_steps_per_mm[_AXIS(A)])
+          if (!validating) {
+            #if AXIS_HAS_STEALTHCHOP(X)
+              TMC_SET_PWMTHRS(X, X);
             #endif
-            #if AXIS_HAS_STALLGUARD(X2)
-              stepperX2.sgt(tmc_sgt.X);
+            #if AXIS_HAS_STEALTHCHOP(Y)
+              TMC_SET_PWMTHRS(Y, Y);
             #endif
-          #endif
-          #ifdef Y_STALL_SENSITIVITY
-            #if AXIS_HAS_STALLGUARD(Y)
-              stepperY.sgt(tmc_sgt.Y);
+            #if AXIS_HAS_STEALTHCHOP(Z)
+              TMC_SET_PWMTHRS(Z, Z);
             #endif
-            #if AXIS_HAS_STALLGUARD(Y2)
-              stepperY2.sgt(tmc_sgt.Y);
+            #if AXIS_HAS_STEALTHCHOP(X2)
+              TMC_SET_PWMTHRS(X, X2);
             #endif
-          #endif
-          #ifdef Z_STALL_SENSITIVITY
-            #if AXIS_HAS_STALLGUARD(Z)
-              stepperZ.sgt(tmc_sgt.Z);
+            #if AXIS_HAS_STEALTHCHOP(Y2)
+              TMC_SET_PWMTHRS(Y, Y2);
             #endif
-            #if AXIS_HAS_STALLGUARD(Z2)
-              stepperZ2.sgt(tmc_sgt.Z);
+            #if AXIS_HAS_STEALTHCHOP(Z2)
+              TMC_SET_PWMTHRS(Z, Z2);
             #endif
-            #if AXIS_HAS_STALLGUARD(Z3)
-              stepperZ3.sgt(tmc_sgt.Z);
+            #if AXIS_HAS_STEALTHCHOP(Z3)
+              TMC_SET_PWMTHRS(Z, Z3);
             #endif
-          #endif
-        }
-      #endif
+            #if AXIS_HAS_STEALTHCHOP(E0)
+              TMC_SET_PWMTHRS(E, E0);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              TMC_SET_PWMTHRS(E, E1);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E2)
+              TMC_SET_PWMTHRS(E, E2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E3)
+              TMC_SET_PWMTHRS(E, E3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E4)
+              TMC_SET_PWMTHRS(E, E4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E5)
+              TMC_SET_PWMTHRS(E, E5);
+            #endif
+          }
+        #endif
+      }
 
       //
-      // Linear Advance
+      // TMC StallGuard threshold.
+      // X and X2 use the same value
+      // Y and Y2 use the same value
+      // Z, Z2 and Z3 use the same value
       //
-      _FIELD_TEST(planner_extruder_advance_K);
+      {
+        tmc_sgt_t tmc_sgt;
+        _FIELD_TEST(tmc_sgt);
+        EEPROM_READ(tmc_sgt);
+        #if USE_SENSORLESS
+          if (!validating) {
+            #ifdef X_STALL_SENSITIVITY
+              #if AXIS_HAS_STALLGUARD(X)
+                stepperX.sgt(tmc_sgt.X);
+              #endif
+              #if AXIS_HAS_STALLGUARD(X2)
+                stepperX2.sgt(tmc_sgt.X);
+              #endif
+            #endif
+            #ifdef Y_STALL_SENSITIVITY
+              #if AXIS_HAS_STALLGUARD(Y)
+                stepperY.sgt(tmc_sgt.Y);
+              #endif
+              #if AXIS_HAS_STALLGUARD(Y2)
+                stepperY2.sgt(tmc_sgt.Y);
+              #endif
+            #endif
+            #ifdef Z_STALL_SENSITIVITY
+              #if AXIS_HAS_STALLGUARD(Z)
+                stepperZ.sgt(tmc_sgt.Z);
+              #endif
+              #if AXIS_HAS_STALLGUARD(Z2)
+                stepperZ2.sgt(tmc_sgt.Z);
+              #endif
+              #if AXIS_HAS_STALLGUARD(Z3)
+                stepperZ3.sgt(tmc_sgt.Z);
+              #endif
+            #endif
+          }
+        #endif
+      }
 
-      LOOP_L_N(i, EXTRUDERS) {
+      //
+      // Linear Advance
+      //
+      {
+        float extruder_advance_K[EXTRUDERS];
+        _FIELD_TEST(planner_extruder_advance_K);
+        EEPROM_READ(extruder_advance_K);
         #if ENABLED(LIN_ADVANCE)
-          EEPROM_READ(planner.extruder_advance_K[i]);
-        #else
-          EEPROM_READ(dummy);
+          if (!validating)
+            COPY(planner.extruder_advance_K, extruder_advance_K);
         #endif
       }
 
       //
       // Motor Current PWM
       //
-
-      _FIELD_TEST(motor_current_setting);
-
-      #if HAS_MOTOR_CURRENT_PWM
-        for (uint8_t q = XYZ; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
-      #else
-        uint32_t dummyui32[XYZ];
-        EEPROM_READ(dummyui32);
-      #endif
+      {
+        uint32_t motor_current_setting[3];
+        _FIELD_TEST(motor_current_setting);
+        EEPROM_READ(motor_current_setting);
+        #if HAS_MOTOR_CURRENT_PWM
+          if (!validating)
+            COPY(stepper.motor_current_setting, motor_current_setting);
+        #endif
+      }
 
       //
       // CNC Coordinate System
       //
-
-      _FIELD_TEST(coordinate_system);
-
-      #if ENABLED(CNC_COORDINATE_SYSTEMS)
-        if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
-        EEPROM_READ(gcode.coordinate_system);                  // 27 floats
-      #else
-        for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_READ(dummy);
-      #endif
+      {
+        _FIELD_TEST(coordinate_system);
+        #if ENABLED(CNC_COORDINATE_SYSTEMS)
+          if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
+          EEPROM_READ(gcode.coordinate_system);
+        #else
+          float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
+          EEPROM_READ(coordinate_system);
+        #endif
+      }
 
       //
       // Skew correction factors
       //
-
-      _FIELD_TEST(planner_xy_skew_factor);
-
-      #if ENABLED(SKEW_CORRECTION_GCODE)
-        EEPROM_READ(planner.xy_skew_factor);
-        #if ENABLED(SKEW_CORRECTION_FOR_Z)
-          EEPROM_READ(planner.xz_skew_factor);
-          EEPROM_READ(planner.yz_skew_factor);
-        #else
-          EEPROM_READ(dummy);
-          EEPROM_READ(dummy);
+      {
+        skew_factor_t skew_factor;
+        _FIELD_TEST(planner_skew_factor);
+        EEPROM_READ(skew_factor);
+        #if ENABLED(SKEW_CORRECTION_GCODE)
+          if (!validating) {
+            planner.skew_factor.xy = skew_factor.xy;
+            #if ENABLED(SKEW_CORRECTION_FOR_Z)
+              planner.skew_factor.xz = skew_factor.xz;
+              planner.skew_factor.yz = skew_factor.yz;
+            #endif
+          }
         #endif
-      #else
-        for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
-      #endif
+      }
 
       //
       // Advanced Pause filament load & unload lengths
       //
-
-      _FIELD_TEST(filament_change_unload_length);
-
-      #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        for (uint8_t q = 0; q < COUNT(filament_change_unload_length); q++) {
-          EEPROM_READ(dummy);
-          if (!validating && q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
-          EEPROM_READ(dummy);
-          if (!validating && q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
-        }
-      #else
-        for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
-      #endif
+      {
+        #if DISABLED(ADVANCED_PAUSE_FEATURE)
+          fil_change_settings_t fc_settings[EXTRUDERS];
+        #endif
+        _FIELD_TEST(fc_settings);
+        EEPROM_READ(fc_settings);
+      }
 
       //
       // SINGLENOZZLE toolchange values
       //
-
       #if ENABLED(SINGLENOZZLE)
-        _FIELD_TEST(singlenozzle_swap_length);
-        EEPROM_READ(singlenozzle_swap_length);
-        EEPROM_READ(singlenozzle_prime_speed);
-        EEPROM_READ(singlenozzle_retract_speed);
+        _FIELD_TEST(sn_settings);
+        EEPROM_READ(sn_settings);
       #endif
-
+  
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         #if ENABLED(EEPROM_CHITCHAT)
@@ -1861,21 +1793,17 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
   static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE_N(i) {
-    planner.axis_steps_per_mm[i]          = pgm_read_float(&tmp1[i < COUNT(tmp1) ? i : COUNT(tmp1) - 1]);
-    planner.max_feedrate_mm_s[i]          = pgm_read_float(&tmp2[i < COUNT(tmp2) ? i : COUNT(tmp2) - 1]);
-    planner.max_acceleration_mm_per_s2[i] = pgm_read_dword_near(&tmp3[i < COUNT(tmp3) ? i : COUNT(tmp3) - 1]);
+    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&tmp1[ALIM(i, tmp1)]);
+    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&tmp2[ALIM(i, tmp2)]);
+    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword_near(&tmp3[ALIM(i, tmp3)]);
   }
 
-  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
-  planner.acceleration = DEFAULT_ACCELERATION;
-  planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
-  planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
-  planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
-  planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
-
-  #if ENABLED(JUNCTION_DEVIATION)
-    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
-  #endif
+  planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
+  planner.settings.acceleration = DEFAULT_ACCELERATION;
+  planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
+  planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
+  planner.settings.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
+  planner.settings.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
 
   #if HAS_CLASSIC_JERK
     planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
@@ -1886,6 +1814,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
   #endif
 
+  #if ENABLED(JUNCTION_DEVIATION)
+    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
+  #endif
+
   #if HAS_HOME_OFFSET
     ZERO(home_offset);
   #endif
@@ -1903,9 +1835,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if ENABLED(SINGLENOZZLE)
-    singlenozzle_swap_length = SINGLENOZZLE_SWAP_LENGTH;
-    singlenozzle_prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
-    singlenozzle_retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+    sn_settings.swap_length = SINGLENOZZLE_SWAP_LENGTH;
+    sn_settings.prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
+    sn_settings.retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
   #endif
 
   //
@@ -2029,10 +1961,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if ENABLED(PIDTEMP)
-    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-      HOTEND_LOOP()
-    #endif
-    {
+    HOTEND_LOOP() {
       PID_PARAM(Kp, e) = float(DEFAULT_Kp);
       PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);
       PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);
@@ -2046,9 +1975,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif // PIDTEMP
 
   #if ENABLED(PIDTEMPBED)
-    thermalManager.bedKp = DEFAULT_bedKp;
-    thermalManager.bedKi = scalePID_i(DEFAULT_bedKi);
-    thermalManager.bedKd = scalePID_d(DEFAULT_bedKd);
+    thermalManager.bed_pid.Kp = DEFAULT_bedKp;
+    thermalManager.bed_pid.Ki = scalePID_i(DEFAULT_bedKi);
+    thermalManager.bed_pid.Kd = scalePID_d(DEFAULT_bedKd);
   #endif
 
   #if HAS_LCD_CONTRAST
@@ -2088,23 +2017,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if HAS_MOTOR_CURRENT_PWM
-    uint32_t tmp_motor_current_setting[XYZ] = PWM_MOTOR_CURRENT;
-    for (uint8_t q = XYZ; q--;)
+    uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
+    for (uint8_t q = 3; q--;)
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 
   #if ENABLED(SKEW_CORRECTION_GCODE)
-    planner.xy_skew_factor = XY_SKEW_FACTOR;
+    planner.skew_factor.xy = XY_SKEW_FACTOR;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
-      planner.xz_skew_factor = XZ_SKEW_FACTOR;
-      planner.yz_skew_factor = YZ_SKEW_FACTOR;
+      planner.skew_factor.xz = XZ_SKEW_FACTOR;
+      planner.skew_factor.yz = YZ_SKEW_FACTOR;
     #endif
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     for (uint8_t e = 0; e < EXTRUDERS; e++) {
-      filament_change_unload_length[e] = FILAMENT_CHANGE_UNLOAD_LENGTH;
-      filament_change_load_length[e] = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
+      fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
+      fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
   #endif
 
@@ -2258,18 +2187,18 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPGM_P(port, "Steps per unit:");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M92 X", LINEAR_UNIT(planner.axis_steps_per_mm[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.axis_steps_per_mm[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.axis_steps_per_mm[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M92 X", LINEAR_UNIT(planner.settings.axis_steps_per_mm[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.axis_steps_per_mm[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.axis_steps_per_mm[E_AXIS]));
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M92 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS + i]));
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.axis_steps_per_mm[E_AXIS + i]));
       }
     #endif
 
@@ -2278,18 +2207,18 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPGM_P(port, "Maximum feedrates (units/s):");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M203 X", LINEAR_UNIT(planner.max_feedrate_mm_s[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_feedrate_mm_s[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_feedrate_mm_s[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M203 X", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS]));
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M203 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS + i]));
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS + i]));
       }
     #endif
 
@@ -2298,18 +2227,18 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPGM_P(port, "Maximum Acceleration (units/s2):");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M201 X", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M201 X", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS]));
     #endif
     SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
         SERIAL_ECHOPAIR_P(port, "  M201 T", (int)i);
-        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS + i]));
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS + i]));
       }
     #endif
 
@@ -2318,9 +2247,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPGM_P(port, "Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M204 P", LINEAR_UNIT(planner.acceleration));
-    SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(planner.retract_acceleration));
-    SERIAL_ECHOLNPAIR_P(port, " T", LINEAR_UNIT(planner.travel_acceleration));
+    SERIAL_ECHOPAIR_P(port, "  M204 P", LINEAR_UNIT(planner.settings.acceleration));
+    SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(planner.settings.retract_acceleration));
+    SERIAL_ECHOLNPAIR_P(port, " T", LINEAR_UNIT(planner.settings.travel_acceleration));
 
     if (!forReplay) {
       CONFIG_ECHO_START;
@@ -2337,9 +2266,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_EOL_P(port);
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M205 B", LINEAR_UNIT(planner.min_segment_time_us));
-    SERIAL_ECHOPAIR_P(port, " S", LINEAR_UNIT(planner.min_feedrate_mm_s));
-    SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
+    SERIAL_ECHOPAIR_P(port, "  M205 B", LINEAR_UNIT(planner.settings.min_segment_time_us));
+    SERIAL_ECHOPAIR_P(port, " S", LINEAR_UNIT(planner.settings.min_feedrate_mm_s));
+    SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s));
 
     #if ENABLED(JUNCTION_DEVIATION)
       SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.junction_deviation_mm));
@@ -2597,9 +2526,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR_P(port, "  M304 P", thermalManager.bedKp);
-        SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(thermalManager.bedKi));
-        SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(thermalManager.bedKd));
+        SERIAL_ECHOPAIR_P(port, "  M304 P", thermalManager.bed_pid.Kp);
+        SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(thermalManager.bed_pid.Ki));
+        SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(thermalManager.bed_pid.Kd));
         SERIAL_EOL_P(port);
       #endif
 
@@ -2621,19 +2550,19 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOLNPGM_P(port, "Retract: S<length> F<units/m> Z<lift>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.retract_length));
-      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.swap_retract_length));
-      SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.retract_zlift));
+      SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.settings.retract_length));
+      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_length));
+      SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.settings.retract_zlift));
 
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Recover: S<length> F<units/m>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR_P(port, "  M208 S", LINEAR_UNIT(fwretract.retract_recover_length));
-      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.swap_retract_recover_length));
-      SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_recover_feedrate_mm_s)));
+      SERIAL_ECHOPAIR_P(port, "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_length));
+      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_length));
+      SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.settings.retract_recover_feedrate_mm_s)));
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
 
@@ -2672,15 +2601,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_START;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         SERIAL_ECHOPGM_P(port, "  M852 I");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xy), 6);
         SERIAL_ECHOPGM_P(port, " J");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xz_skew_factor), 6);
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xz), 6);
         SERIAL_ECHOPGM_P(port, " K");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.yz_skew_factor), 6);
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.yz), 6);
         SERIAL_EOL_P(port);
       #else
         SERIAL_ECHOPGM_P(port, "  M852 S");
-        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.skew_factor.xy), 6);
         SERIAL_EOL_P(port);
       #endif
     #endif
@@ -2929,36 +2858,36 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_START;
       #if EXTRUDERS == 1
         say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(filament_change_load_length[0]));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
+        SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(fc_settings[0].load_length));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
         say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(filament_change_load_length[0]));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
+        SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(fc_settings[0].load_length));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[0].unload_length));
         CONFIG_ECHO_START;
         say_M603(PORTVAR_SOLO);
-        SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(filament_change_load_length[1]));
-        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[1]));
+        SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(fc_settings[1].load_length));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[1].unload_length));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START;
           say_M603(PORTVAR_SOLO);
-          SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(filament_change_load_length[2]));
-          SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[2]));
+          SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(fc_settings[2].load_length));
+          SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[2].unload_length));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START;
             say_M603(PORTVAR_SOLO);
-            SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(filament_change_load_length[3]));
-            SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[3]));
+            SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(fc_settings[3].load_length));
+            SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[3].unload_length));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START;
               say_M603(PORTVAR_SOLO);
-              SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(filament_change_load_length[4]));
-              SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[4]));
+              SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(fc_settings[4].load_length));
+              SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[4].unload_length));
               #if EXTRUDERS > 5
                 CONFIG_ECHO_START;
                 say_M603(PORTVAR_SOLO);
-                SERIAL_ECHOPAIR_P(port, "T5 L", LINEAR_UNIT(filament_change_load_length[5]));
-                SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[5]));
+                SERIAL_ECHOPAIR_P(port, "T5 L", LINEAR_UNIT(fc_settings[5].load_length));
+                SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(fc_settings[5].unload_length));
               #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
@@ -2977,3 +2906,5 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   }
 
 #endif // !DISABLE_M503
+
+#pragma pack(pop)

commit 9b5c1a5e77b5783baadcd1262efd5c1f002f5c32
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 10 02:21:47 2018 -0500

    Fix EEPROM checksum bug
    
    Addressing #12048

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 043ebcf94a..1897a53bb4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,8 +37,8 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V60"
-#define EEPROM_OFFSET 0
+#define EEPROM_VERSION "V61"
+#define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.

commit cf5284cdf25f759ce1b64c87480b2cd47dfb1916
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 9 20:00:47 2018 -0500

    Add SD Firmware Update capability (#12043)
    
    Co-Authored-By: timoxd7 <timoxd7@users.noreply.github.com>

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 993ea39644..043ebcf94a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -376,6 +376,32 @@ void MarlinSettings::postprocess() {
     report_current_position();
 }
 
+#if ENABLED(SD_FIRMWARE_UPDATE)
+
+  #if ENABLED(EEPROM_SETTINGS)
+    static_assert(
+      !WITHIN(SD_FIRMWARE_UPDATE_EEPROM_ADDR, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
+      "SD_FIRMWARE_UPDATE_EEPROM_ADDR collides with EEPROM settings storage."
+    );
+  #endif
+
+  bool MarlinSettings::sd_update_status() {
+    uint8_t val;
+    persistentStore.read_data(SD_FIRMWARE_UPDATE_EEPROM_ADDR, &val);
+    return (val == SD_FIRMWARE_UPDATE_ACTIVE_VALUE);
+  }
+
+  bool MarlinSettings::set_sd_update_status(const bool enable) {
+    if (enable != sd_update_status())
+      persistentStore.write_data(
+        SD_FIRMWARE_UPDATE_EEPROM_ADDR,
+        enable ? SD_FIRMWARE_UPDATE_ACTIVE_VALUE : SD_FIRMWARE_UPDATE_INACTIVE_VALUE
+      );
+    return true;
+  }
+
+#endif // SD_FIRMWARE_UPDATE
+
 #if ENABLED(EEPROM_SETTINGS)
   #include "../HAL/shared/persistent_store_api.h"
 

commit 74cd6cb4fc90e4c483e7a97a313c0257790f1375
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 7 18:06:14 2018 -0400

    Single nozzle filament change (#11994)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index fae14db100..993ea39644 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -98,6 +98,11 @@ typedef struct {  int16_t X, Y, Z;                                         } tmc
   #include "../feature/pause.h"
 #endif
 
+#if ENABLED(SINGLENOZZLE)
+  #include "tool_change.h"
+  void M217_report(const bool eeprom);
+#endif
+
 #if ENABLED(PID_EXTRUSION_SCALING)
   #define LPQ_LEN thermalManager.lpq_len
 #endif
@@ -289,6 +294,15 @@ typedef struct SettingsDataStruct {
   float filament_change_unload_length[EXTRUDERS],       // M603 T U
         filament_change_load_length[EXTRUDERS];         // M603 T L
 
+  //
+  // SINGLENOZZLE toolchange values
+  //
+  #if ENABLED(SINGLENOZZLE)
+    float singlenozzle_swap_length;                     // M217 S
+    int16_t singlenozzle_prime_speed,                   // M217 P
+            singlenozzle_retract_speed;                 // M217 R
+  #endif
+
 } SettingsData;
 
 #pragma pack(pop)
@@ -947,6 +961,17 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
     #endif
 
+    //
+    // SINGLENOZZLE
+    //
+
+    #if ENABLED(SINGLENOZZLE)
+      _FIELD_TEST(singlenozzle_swap_length);
+      EEPROM_WRITE(singlenozzle_swap_length);
+      EEPROM_WRITE(singlenozzle_prime_speed);
+      EEPROM_WRITE(singlenozzle_retract_speed);
+    #endif
+
     //
     // Validate CRC and Data Size
     //
@@ -1582,6 +1607,17 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
       #endif
 
+      //
+      // SINGLENOZZLE toolchange values
+      //
+
+      #if ENABLED(SINGLENOZZLE)
+        _FIELD_TEST(singlenozzle_swap_length);
+        EEPROM_READ(singlenozzle_swap_length);
+        EEPROM_READ(singlenozzle_prime_speed);
+        EEPROM_READ(singlenozzle_retract_speed);
+      #endif
+
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         #if ENABLED(EEPROM_CHITCHAT)
@@ -1840,6 +1876,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
   #endif
 
+  #if ENABLED(SINGLENOZZLE)
+    singlenozzle_swap_length = SINGLENOZZLE_SWAP_LENGTH;
+    singlenozzle_prime_speed = SINGLENOZZLE_SWAP_PRIME_SPEED;
+    singlenozzle_retract_speed = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+  #endif
+
   //
   // Global Leveling
   //
@@ -2897,6 +2939,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #endif // EXTRUDERS > 2
       #endif // EXTRUDERS == 1
     #endif // ADVANCED_PAUSE_FEATURE
+
+    #if ENABLED(SINGLENOZZLE)
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM_P(port, "SINGLENOZZLE:");
+        CONFIG_ECHO_START;
+      }
+      M217_report(true);
+    #endif
   }
 
 #endif // !DISABLE_M503

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dd97441dc6..fae14db100 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V59"
+#define EEPROM_VERSION "V60"
 #define EEPROM_OFFSET 0
 
 // Check the integrity of data offsets.
@@ -214,8 +214,8 @@ typedef struct SettingsDataStruct {
   // ULTIPANEL
   //
   int16_t lcd_preheat_hotend_temp[2],                   // M145 S0 H
-          lcd_preheat_bed_temp[2],                      // M145 S0 B
-          lcd_preheat_fan_speed[2];                     // M145 S0 F
+          lcd_preheat_bed_temp[2];                      // M145 S0 B
+  uint8_t lcd_preheat_fan_speed[2];                     // M145 S0 F
 
   //
   // PIDTEMP
@@ -630,8 +630,8 @@ void MarlinSettings::postprocess() {
 
     #if DISABLED(ULTIPANEL)
       constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
-                        lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
-                        lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+                        lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED };
+      constexpr uint8_t lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
     #endif
 
     EEPROM_WRITE(lcd_preheat_hotend_temp);
@@ -1238,17 +1238,13 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(lcd_preheat_hotend_temp);
 
       #if DISABLED(ULTIPANEL)
-        int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+        int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
+        uint8_t lcd_preheat_fan_speed[2];
       #endif
       EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
       EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
       EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
 
-      //EEPROM_ASSERT(
-      //  WITHIN(lcd_preheat_fan_speed, 0, 255),
-      //  "lcd_preheat_fan_speed out of range"
-      //);
-
       //
       // Hotend PID
       //
@@ -2489,7 +2485,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, "  M145 S", (int)i);
         SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
         SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
-        SERIAL_ECHOLNPAIR_P(port, " F", lcd_preheat_fan_speed[i]);
+        SERIAL_ECHOLNPAIR_P(port, " F", int(lcd_preheat_fan_speed[i]));
       }
     #endif // ULTIPANEL
 

commit e8d677620ca4489add6900e8342cfce393819290
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 6 13:31:01 2018 -0500

    Use NUM_SERVOS in EEPROM code
    
    Fix #12015

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 25574bdf3b..dd97441dc6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -72,6 +72,9 @@
 
 #if HAS_SERVOS
   #include "servo.h"
+#else
+  #undef NUM_SERVOS
+  #define NUM_SERVOS NUM_SERVO_PLUGS
 #endif
 
 #if HAS_BED_PROBE
@@ -185,7 +188,7 @@ typedef struct SettingsDataStruct {
   //
   // SERVO_ANGLES
   //
-  uint16_t servo_angles[NUM_SERVO_PLUGS][2];                 // M281 P L U
+  uint16_t servo_angles[NUM_SERVOS][2];                 // M281 P L U
 
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
@@ -562,7 +565,7 @@ void MarlinSettings::postprocess() {
       #if ENABLED(SWITCHING_EXTRUDER)
         constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
       #endif
-      constexpr uint16_t servo_angles[NUM_SERVO_PLUGS][2] = {
+      constexpr uint16_t servo_angles[NUM_SERVOS][2] = {
         #if ENABLED(SWITCHING_EXTRUDER)
           [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0][0], sesa[0][1] }
           #if EXTRUDERS > 3
@@ -1181,7 +1184,7 @@ void MarlinSettings::postprocess() {
       // SERVO_ANGLES
       //
       #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
-        uint16_t servo_angles[NUM_SERVO_PLUGS][2];
+        uint16_t servo_angles[NUM_SERVOS][2];
       #endif
       EEPROM_READ(servo_angles);
 

commit c40ea1f0fd28f421bad4f25b660e2316e4c5f2e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 3 11:34:34 2018 -0500

    Update EEPROM_VERSION
    
    And set EEPROM_OFFSET to 0, since the historical 100 skipped bytes are never used.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1ae61a5ad9..25574bdf3b 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,8 +37,8 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V58"
-#define EEPROM_OFFSET 100
+#define EEPROM_VERSION "V59"
+#define EEPROM_OFFSET 0
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.

commit 1358bd9319167278d24813fa346da2fc578d5fa1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 3 11:32:09 2018 -0500

    Make MAX_EXTRUDERS always 6

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9a92e47d53..1ae61a5ad9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -877,6 +877,7 @@ void MarlinSettings::postprocess() {
     //
     // Linear Advance
     //
+
     _FIELD_TEST(planner_extruder_advance_K);
 
     #if ENABLED(LIN_ADVANCE)
@@ -888,6 +889,10 @@ void MarlinSettings::postprocess() {
 
     _FIELD_TEST(motor_current_setting);
 
+    //
+    // Motor Current PWM
+    //
+
     #if HAS_MOTOR_CURRENT_PWM
       for (uint8_t q = XYZ; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
     #else
@@ -1408,6 +1413,8 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
       #endif
 
+      _FIELD_TEST(tmc_hybrid_threshold);
+
       #if ENABLED(HYBRID_THRESHOLD)
         #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold.Q, planner.axis_steps_per_mm[_AXIS(A)])
         tmc_hybrid_threshold_t tmc_hybrid_threshold;
@@ -1458,12 +1465,15 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(thrs_val);
       #endif
 
-      /*
+      /**
        * TMC StallGuard threshold.
        * X and X2 use the same value
        * Y and Y2 use the same value
        * Z, Z2 and Z3 use the same value
        */
+
+      _FIELD_TEST(tmc_sgt);
+
       tmc_sgt_t tmc_sgt;
       EEPROM_READ(tmc_sgt);
       #if USE_SENSORLESS

commit c3229e1b3461b6da8373e7a24a7eeb131912a15b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Oct 3 10:48:49 2018 +0300

    Migrate to a new TMC library (#11943)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index eee30aba84..9a92e47d53 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -83,6 +83,9 @@
   #include "../feature/tmc_util.h"
   #define TMC_GET_PWMTHRS(A,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.axis_steps_per_mm[_AXIS(A)])
 #endif
+typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_stepper_current_t;
+typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5; } tmc_hybrid_threshold_t;
+typedef struct {  int16_t X, Y, Z;                                         } tmc_sgt_t;
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
@@ -98,7 +101,7 @@
 
 #pragma pack(push, 1) // No padding between variables
 
-typedef struct PID { float Kp, Ki, Kd; } PID;
+typedef struct PID  { float Kp, Ki, Kd;     } PID;
 typedef struct PIDC { float Kp, Ki, Kd, Kc; } PIDC;
 
 /**
@@ -251,9 +254,9 @@ typedef struct SettingsDataStruct {
   // HAS_TRINAMIC
   //
   #define TMC_AXES (MAX_EXTRUDERS + 7)
-  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
-  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
-  int16_t tmc_sgt[XYZ];                                 // M914 X Y Z
+  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
+  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
+  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z
 
   //
   // LIN_ADVANCE
@@ -300,7 +303,7 @@ uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 #endif
 
 void MarlinSettings::postprocess() {
-  const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
+  const float oldpos[XYZE] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS] };
 
   // steps per s2 needs to be updated to agree with units per s2
   planner.reset_acceleration_rates();
@@ -436,7 +439,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(dummy);
       #endif
     #else
-      const float planner_max_jerk[] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
+      const float planner_max_jerk[XYZE] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
       EEPROM_WRITE(planner_max_jerk);
     #endif
 
@@ -464,11 +467,13 @@ void MarlinSettings::postprocess() {
     // Global Leveling
     //
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float zfh = planner.z_fade_height;
-    #else
-      const float zfh = 10.0;
-    #endif
+    const float zfh = (
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        planner.z_fade_height
+      #else
+        10.0
+      #endif
+    );
     EEPROM_WRITE(zfh);
 
     //
@@ -478,7 +483,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(MESH_BED_LEVELING)
       // Compile time test that sizeof(mbl.z_values) is as expected
       static_assert(
-        sizeof(mbl.z_values) == GRID_MAX_POINTS * sizeof(mbl.z_values[0][0]),
+        sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
         "MBL Z array is the wrong size."
       );
       const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
@@ -520,7 +525,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
       // Compile time test that sizeof(z_values) is as expected
       static_assert(
-        sizeof(z_values) == GRID_MAX_POINTS * sizeof(z_values[0][0]),
+        sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
         "Bilinear Z array is the wrong size."
       );
       const uint8_t grid_max_x = GRID_MAX_POINTS_X, grid_max_y = GRID_MAX_POINTS_Y;
@@ -719,230 +724,154 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
-    // Save TMC2130 or TMC2208 Configuration, and placeholder values
+    // Save TMC Configuration, and placeholder values
     //
 
     _FIELD_TEST(tmc_stepper_current);
 
-    uint16_t tmc_stepper_current[TMC_AXES] = {
-      #if HAS_TRINAMIC
-        #if AXIS_IS_TMC(X)
-          stepperX.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(Y)
-          stepperY.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(Z)
-          stepperZ.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(X2)
-          stepperX2.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          stepperY2.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(Z2)
-          stepperZ2.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(Z3)
-          stepperZ3.getCurrent(),
-        #else
-          0,
+    tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    #if HAS_TRINAMIC
+      #if AXIS_IS_TMC(X)
+        tmc_stepper_current.X = stepperX.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(Y)
+        tmc_stepper_current.Y = stepperY.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(Z)
+        tmc_stepper_current.Z = stepperZ.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(X2)
+        tmc_stepper_current.X2 = stepperX2.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_stepper_current.Y2 = stepperY2.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(Z2)
+        tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
+      #endif
+      #if AXIS_IS_TMC(Z3)
+        tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
+      #endif
+      #if MAX_EXTRUDERS
+        #if AXIS_IS_TMC(E0)
+          tmc_stepper_current.E0 = stepperE0.getMilliamps();
         #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_IS_TMC(E0)
-            stepperE0.getCurrent(),
-          #else
-            0,
+        #if MAX_EXTRUDERS > 1
+          #if AXIS_IS_TMC(E1)
+            tmc_stepper_current.E1 = stepperE1.getMilliamps();
           #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_IS_TMC(E1)
-              stepperE1.getCurrent(),
-            #else
-              0,
+          #if MAX_EXTRUDERS > 2
+            #if AXIS_IS_TMC(E2)
+              tmc_stepper_current.E2 = stepperE2.getMilliamps();
             #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_IS_TMC(E2)
-                stepperE2.getCurrent(),
-              #else
-                0,
+            #if MAX_EXTRUDERS > 3
+              #if AXIS_IS_TMC(E3)
+                tmc_stepper_current.E3 = stepperE3.getMilliamps();
               #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_IS_TMC(E3)
-                  stepperE3.getCurrent(),
-                #else
-                  0,
+              #if MAX_EXTRUDERS > 4
+                #if AXIS_IS_TMC(E4)
+                  tmc_stepper_current.E4 = stepperE4.getMilliamps();
                 #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_IS_TMC(E4)
-                    stepperE4.getCurrent()
-                  #else
-                    0
+                #if MAX_EXTRUDERS > 5
+                  #if AXIS_IS_TMC(E5)
+                    tmc_stepper_current.E5 = stepperE5.getMilliamps();
                   #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_IS_TMC(E5)
-                      stepperE5.getCurrent()
-                    #else
-                      0
-                    #endif
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
-      #else
-        0
-      #endif
-    };
+                #endif // MAX_EXTRUDERS > 5
+              #endif // MAX_EXTRUDERS > 4
+            #endif // MAX_EXTRUDERS > 3
+          #endif // MAX_EXTRUDERS > 2
+        #endif // MAX_EXTRUDERS > 1
+      #endif // MAX_EXTRUDERS
+    #endif
     EEPROM_WRITE(tmc_stepper_current);
 
     //
-    // Save TMC2130 or TMC2208 Hybrid Threshold, and placeholder values
+    // Save TMC Hybrid Threshold, and placeholder values
     //
 
     _FIELD_TEST(tmc_hybrid_threshold);
 
-    uint32_t tmc_hybrid_threshold[TMC_AXES] = {
-      #if ENABLED(HYBRID_THRESHOLD)
-        #if AXIS_HAS_STEALTHCHOP(X)
-          TMC_GET_PWMTHRS(X, X),
-        #else
-          X_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          TMC_GET_PWMTHRS(Y, Y),
-        #else
-          Y_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          TMC_GET_PWMTHRS(Z, Z),
-        #else
-          Z_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          TMC_GET_PWMTHRS(X, X2),
-        #else
-          X2_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          TMC_GET_PWMTHRS(Y, Y2),
-        #else
-          Y2_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          TMC_GET_PWMTHRS(Z, Z2),
-        #else
-          Z2_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          TMC_GET_PWMTHRS(Z, Z3),
-        #else
-          Z3_HYBRID_THRESHOLD,
+    #if ENABLED(HYBRID_THRESHOLD)
+     tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+     #if AXIS_HAS_STEALTHCHOP(X)
+        tmc_hybrid_threshold.X = TMC_GET_PWMTHRS(X, X);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Y)
+        tmc_hybrid_threshold.Y = TMC_GET_PWMTHRS(Y, Y);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z)
+        tmc_hybrid_threshold.Z = TMC_GET_PWMTHRS(Z, Z);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(X2)
+        tmc_hybrid_threshold.X2 = TMC_GET_PWMTHRS(X, X2);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Y2)
+        tmc_hybrid_threshold.Y2 = TMC_GET_PWMTHRS(Y, Y2);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z2)
+        tmc_hybrid_threshold.Z2 = TMC_GET_PWMTHRS(Z, Z2);
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z3)
+        tmc_hybrid_threshold.Z3 = TMC_GET_PWMTHRS(Z, Z3);
+      #endif
+      #if MAX_EXTRUDERS
+        #if AXIS_HAS_STEALTHCHOP(E0)
+          tmc_hybrid_threshold.E0 = TMC_GET_PWMTHRS(E, E0);
         #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            TMC_GET_PWMTHRS(E, E0),
-          #else
-            E0_HYBRID_THRESHOLD,
+        #if MAX_EXTRUDERS > 1
+          #if AXIS_HAS_STEALTHCHOP(E1)
+            tmc_hybrid_threshold.E1 = TMC_GET_PWMTHRS(E, E1);
           #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              TMC_GET_PWMTHRS(E, E1),
-            #else
-              E1_HYBRID_THRESHOLD,
+          #if MAX_EXTRUDERS > 2
+            #if AXIS_HAS_STEALTHCHOP(E2)
+              tmc_hybrid_threshold.E2 = TMC_GET_PWMTHRS(E, E2);
             #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_HAS_STEALTHCHOP(E2)
-                TMC_GET_PWMTHRS(E, E2),
-              #else
-                E2_HYBRID_THRESHOLD,
+            #if MAX_EXTRUDERS > 3
+              #if AXIS_HAS_STEALTHCHOP(E3)
+                tmc_hybrid_threshold.E3 = TMC_GET_PWMTHRS(E, E3);
               #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_HAS_STEALTHCHOP(E3)
-                  TMC_GET_PWMTHRS(E, E3),
-                #else
-                  E3_HYBRID_THRESHOLD,
+              #if MAX_EXTRUDERS > 4
+                #if AXIS_HAS_STEALTHCHOP(E4)
+                  tmc_hybrid_threshold.E4 = TMC_GET_PWMTHRS(E, E4);
                 #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_HAS_STEALTHCHOP(E4)
-                    TMC_GET_PWMTHRS(E, E4)
-                  #else
-                    E4_HYBRID_THRESHOLD
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_HAS_STEALTHCHOP(E5)
-                      TMC_GET_PWMTHRS(E, E5)
-                    #else
-                      E5_HYBRID_THRESHOLD
-                    #endif
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
-      #else
-        100, 100, 3,            // X, Y, Z
-        100, 100, 3, 3          // X2, Y2, Z2, Z3
-        #if MAX_EXTRUDERS
-          , 30                  // E0
-          #if MAX_EXTRUDERS > 1
-            , 30                // E1
-            #if MAX_EXTRUDERS > 2
-              , 30              // E2
-              #if MAX_EXTRUDERS > 3
-                , 30            // E3
-                #if MAX_EXTRUDERS > 4
-                  , 30          // E4
-                  #if MAX_EXTRUDERS > 5
-                    , 30        // E5
+                #if MAX_EXTRUDERS > 5
+                  #if AXIS_HAS_STEALTHCHOP(E5)
+                    tmc_hybrid_threshold.E5 = TMC_GET_PWMTHRS(E, E5);
                   #endif
-                #endif
-              #endif
-            #endif
-          #endif
-        #endif
-      #endif
-    };
+                #endif // MAX_EXTRUDERS > 5
+              #endif // MAX_EXTRUDERS > 4
+            #endif // MAX_EXTRUDERS > 3
+          #endif // MAX_EXTRUDERS > 2
+        #endif // MAX_EXTRUDERS > 1
+      #endif // MAX_EXTRUDERS
+    #else
+      const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
+        .X  = 100, .Y  = 100, .Z  =   3,
+        .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3,
+        .E0 =  30, .E1 =  30, .E2 =  30,
+        .E3 =  30, .E4 =  30, .E5 =  30
+      };
+    #endif
     EEPROM_WRITE(tmc_hybrid_threshold);
 
     //
-    // TMC2130 StallGuard threshold
+    // TMC StallGuard threshold
     //
-    int16_t tmc_sgt[XYZ] = {
-      #if USE_SENSORLESS
-        #if X_SENSORLESS
-          stepperX.sgt(),
-        #else
-          0,
-        #endif
-        #if Y_SENSORLESS
-          stepperY.sgt(),
-        #else
-          0,
-        #endif
-        #if Z_SENSORLESS
-          stepperZ.sgt()
-        #else
-          0
-        #endif
-      #else
-        0
+
+    tmc_sgt_t tmc_sgt = { 0, 0, 0 };
+
+    #if USE_SENSORLESS
+      #if X_SENSORLESS
+        tmc_sgt.X = stepperX.sgt();
       #endif
-    };
+      #if Y_SENSORLESS
+        tmc_sgt.Y = stepperY.sgt();
+      #endif
+      #if Z_SENSORLESS
+        tmc_sgt.Z = stepperZ.sgt();
+      #endif
+    #endif
     EEPROM_WRITE(tmc_sgt);
 
     //
@@ -1423,15 +1352,15 @@ void MarlinSettings::postprocess() {
       if (!validating) reset_stepper_drivers();
 
       //
-      // TMC2130 Stepper Settings
+      // TMC Stepper Settings
       //
 
       _FIELD_TEST(tmc_stepper_current);
 
       #if HAS_TRINAMIC
 
-        #define SET_CURR(Q) stepper##Q.setCurrent(currents[TMC_##Q] ? currents[TMC_##Q] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
-        uint16_t currents[TMC_AXES];
+        #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
+        tmc_stepper_current_t currents;
         EEPROM_READ(currents);
         if (!validating) {
           #if AXIS_IS_TMC(X)
@@ -1480,8 +1409,8 @@ void MarlinSettings::postprocess() {
       #endif
 
       #if ENABLED(HYBRID_THRESHOLD)
-        #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[_AXIS(A)])
-        uint32_t tmc_hybrid_threshold[TMC_AXES];
+        #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold.Q, planner.axis_steps_per_mm[_AXIS(A)])
+        tmc_hybrid_threshold_t tmc_hybrid_threshold;
         EEPROM_READ(tmc_hybrid_threshold);
         if (!validating) {
           #if AXIS_HAS_STEALTHCHOP(X)
@@ -1530,40 +1459,40 @@ void MarlinSettings::postprocess() {
       #endif
 
       /*
-       * TMC2130 StallGuard threshold.
+       * TMC StallGuard threshold.
        * X and X2 use the same value
        * Y and Y2 use the same value
        * Z, Z2 and Z3 use the same value
        */
-      int16_t tmc_sgt[XYZ];
+      tmc_sgt_t tmc_sgt;
       EEPROM_READ(tmc_sgt);
       #if USE_SENSORLESS
         if (!validating) {
           #ifdef X_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(X)
-              stepperX.sgt(tmc_sgt[0]);
+              stepperX.sgt(tmc_sgt.X);
             #endif
             #if AXIS_HAS_STALLGUARD(X2)
-              stepperX2.sgt(tmc_sgt[0]);
+              stepperX2.sgt(tmc_sgt.X);
             #endif
           #endif
           #ifdef Y_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(Y)
-              stepperY.sgt(tmc_sgt[1]);
+              stepperY.sgt(tmc_sgt.Y);
             #endif
             #if AXIS_HAS_STALLGUARD(Y2)
-              stepperY2.sgt(tmc_sgt[1]);
+              stepperY2.sgt(tmc_sgt.Y);
             #endif
           #endif
           #ifdef Z_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(Z)
-              stepperZ.sgt(tmc_sgt[2]);
+              stepperZ.sgt(tmc_sgt.Z);
             #endif
             #if AXIS_HAS_STALLGUARD(Z2)
-              stepperZ2.sgt(tmc_sgt[2]);
+              stepperZ2.sgt(tmc_sgt.Z);
             #endif
             #if AXIS_HAS_STALLGUARD(Z3)
-              stepperZ3.sgt(tmc_sgt[2]);
+              stepperZ3.sgt(tmc_sgt.Z);
             #endif
           #endif
         }
@@ -1957,8 +1886,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
 
   #if ENABLED(DELTA)
-    const float adj[ABC] = DELTA_ENDSTOP_ADJ,
-                dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
+    const float adj[ABC] = DELTA_ENDSTOP_ADJ, dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
     delta_height = DELTA_HEIGHT;
     COPY(delta_endstop_adj, adj);
     delta_radius = DELTA_RADIUS;
@@ -2683,7 +2611,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_TRINAMIC
 
       /**
-       * TMC2130 / TMC2208 stepper driver current
+       * TMC stepper driver current
        */
       if (!forReplay) {
         CONFIG_ECHO_START;
@@ -2694,65 +2622,68 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         say_M906(PORTVAR_SOLO);
       #endif
       #if AXIS_IS_TMC(X)
-        SERIAL_ECHOPAIR_P(port, " X", stepperX.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " X", stepperX.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Y)
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Z)
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getMilliamps());
       #endif
       #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         SERIAL_EOL_P(port);
       #endif
+
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOPGM_P(port, " I1");
       #endif
       #if AXIS_IS_TMC(X2)
-        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Y2)
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(Z2)
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         SERIAL_EOL_P(port);
       #endif
+
       #if AXIS_IS_TMC(Z3)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " I2 Z", stepperZ3.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " I2 Z", stepperZ3.getMilliamps());
       #endif
+
       #if AXIS_IS_TMC(E0)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E1)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E2)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E3)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E4)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E5)
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, " T5 E", stepperE5.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T5 E", stepperE5.getMilliamps());
       #endif
       SERIAL_EOL_P(port);
 
       /**
-       * TMC2130 / TMC2208 / TRAMS Hybrid Threshold
+       * TMC Hybrid Threshold
        */
       #if ENABLED(HYBRID_THRESHOLD)
         if (!forReplay) {
@@ -2760,63 +2691,66 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
         }
         CONFIG_ECHO_START;
-        #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
+        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           say_M913(PORTVAR_SOLO);
         #endif
-        #if AXIS_IS_TMC(X)
+        #if AXIS_HAS_STEALTHCHOP(X)
           SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
         #endif
-        #if AXIS_IS_TMC(Y)
+        #if AXIS_HAS_STEALTHCHOP(Y)
           SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
         #endif
-        #if AXIS_IS_TMC(Z)
+        #if AXIS_HAS_STEALTHCHOP(Z)
           SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
         #endif
-        #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
+        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
           SERIAL_EOL_P(port);
         #endif
-        #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
+
+        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I1");
         #endif
-        #if AXIS_IS_TMC(X2)
+        #if AXIS_HAS_STEALTHCHOP(X2)
           SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
         #endif
-        #if AXIS_IS_TMC(Y2)
+        #if AXIS_HAS_STEALTHCHOP(Y2)
           SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
         #endif
-        #if AXIS_IS_TMC(Z2)
+        #if AXIS_HAS_STEALTHCHOP(Z2)
           SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
         #endif
-        #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
+        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
           SERIAL_EOL_P(port);
         #endif
-        #if AXIS_IS_TMC(Z3)
+
+        #if AXIS_HAS_STEALTHCHOP(Z3)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I2");
           SERIAL_ECHOLNPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z3));
         #endif
-        #if AXIS_IS_TMC(E0)
+
+        #if AXIS_HAS_STEALTHCHOP(E0)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
         #endif
-        #if AXIS_IS_TMC(E1)
+        #if AXIS_HAS_STEALTHCHOP(E1)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T1 E", TMC_GET_PWMTHRS(E, E1));
         #endif
-        #if AXIS_IS_TMC(E2)
+        #if AXIS_HAS_STEALTHCHOP(E2)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T2 E", TMC_GET_PWMTHRS(E, E2));
         #endif
-        #if AXIS_IS_TMC(E3)
+        #if AXIS_HAS_STEALTHCHOP(E3)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T3 E", TMC_GET_PWMTHRS(E, E3));
         #endif
-        #if AXIS_IS_TMC(E4)
+        #if AXIS_HAS_STEALTHCHOP(E4)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
-        #if AXIS_IS_TMC(E5)
+        #if AXIS_HAS_STEALTHCHOP(E5)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T5 E", TMC_GET_PWMTHRS(E, E5));
         #endif
@@ -2824,7 +2758,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif // HYBRID_THRESHOLD
 
       /**
-     * TMC2130 Sensorless homing thresholds
+       * TMC Sensorless homing thresholds
        */
       #if USE_SENSORLESS
         if (!forReplay) {

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 81dd1db206..eee30aba84 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -920,10 +920,10 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(tmc_hybrid_threshold);
 
     //
-    // TMC2130 Sensorless homing threshold
+    // TMC2130 StallGuard threshold
     //
     int16_t tmc_sgt[XYZ] = {
-      #if ENABLED(SENSORLESS_HOMING)
+      #if USE_SENSORLESS
         #if X_SENSORLESS
           stepperX.sgt(),
         #else
@@ -1530,16 +1530,16 @@ void MarlinSettings::postprocess() {
       #endif
 
       /*
-       * TMC2130 Sensorless homing threshold.
+       * TMC2130 StallGuard threshold.
        * X and X2 use the same value
        * Y and Y2 use the same value
        * Z, Z2 and Z3 use the same value
        */
       int16_t tmc_sgt[XYZ];
       EEPROM_READ(tmc_sgt);
-      #if ENABLED(SENSORLESS_HOMING)
+      #if USE_SENSORLESS
         if (!validating) {
-          #ifdef X_HOMING_SENSITIVITY
+          #ifdef X_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(X)
               stepperX.sgt(tmc_sgt[0]);
             #endif
@@ -1547,7 +1547,7 @@ void MarlinSettings::postprocess() {
               stepperX2.sgt(tmc_sgt[0]);
             #endif
           #endif
-          #ifdef Y_HOMING_SENSITIVITY
+          #ifdef Y_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(Y)
               stepperY.sgt(tmc_sgt[1]);
             #endif
@@ -1555,7 +1555,7 @@ void MarlinSettings::postprocess() {
               stepperY2.sgt(tmc_sgt[1]);
             #endif
           #endif
-          #ifdef Z_HOMING_SENSITIVITY
+          #ifdef Z_STALL_SENSITIVITY
             #if AXIS_HAS_STALLGUARD(Z)
               stepperZ.sgt(tmc_sgt[2]);
             #endif
@@ -2120,7 +2120,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if ENABLED(HYBRID_THRESHOLD)
       void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913"); }
     #endif
-    #if ENABLED(SENSORLESS_HOMING)
+    #if USE_SENSORLESS
       void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914"); }
     #endif
   #endif
@@ -2824,12 +2824,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif // HYBRID_THRESHOLD
 
       /**
-       * TMC2130 Sensorless homing thresholds
+     * TMC2130 Sensorless homing thresholds
        */
-      #if ENABLED(SENSORLESS_HOMING)
+      #if USE_SENSORLESS
         if (!forReplay) {
           CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
+          SERIAL_ECHOLNPGM_P(port, "TMC2130 StallGuard threshold:");
         }
         CONFIG_ECHO_START;
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
@@ -2846,10 +2846,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_EOL_P(port);
         #endif
 
-        #define HAS_X2_SENSORLESS (defined(X_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
-        #define HAS_Y2_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Y2))
-        #define HAS_Z2_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
-        #define HAS_Z3_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
+        #define HAS_X2_SENSORLESS (defined(X_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
+        #define HAS_Y2_SENSORLESS (defined(Y_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Y2))
+        #define HAS_Z2_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
+        #define HAS_Z3_SENSORLESS (defined(Z_STALL_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
         #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
           say_M914(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I1");
@@ -2871,7 +2871,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPAIR_P(port, " Z", stepperZ3.sgt());
         #endif
 
-      #endif // SENSORLESS_HOMING
+      #endif // USE_SENSORLESS
 
     #endif // HAS_TRINAMIC
 

commit 93839e2f73c78fd2448c15c5ffefef62fd53fe6b
Author: Victor Tseng <palatis@gmail.com>
Date:   Sat Sep 29 05:52:56 2018 +0800

    Add option to enable/disable autoretract altogether (#11904)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 18743edef1..81dd1db206 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -672,13 +672,19 @@ void MarlinSettings::postprocess() {
     #endif
     EEPROM_WRITE(lcd_contrast);
 
+    const bool autoretract_enabled =
+      #if DISABLED(FWRETRACT_AUTORETRACT)
+        false
+      #else
+        fwretract.autoretract_enabled
+      #endif
+    ;
+    EEPROM_WRITE(autoretract_enabled);
+
     #if DISABLED(FWRETRACT)
-      const bool autoretract_enabled = false;
       const float autoretract_defaults[] = { 3, 45, 0, 0, 0, 13, 0, 8 };
-      EEPROM_WRITE(autoretract_enabled);
       EEPROM_WRITE(autoretract_defaults);
     #else
-      EEPROM_WRITE(fwretract.autoretract_enabled);
       EEPROM_WRITE(fwretract.retract_length);
       EEPROM_WRITE(fwretract.retract_feedrate_mm_s);
       EEPROM_WRITE(fwretract.retract_zlift);
@@ -1070,7 +1076,7 @@ void MarlinSettings::postprocess() {
     }
     else {
       float dummy = 0;
-      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || ENABLED(NO_VOLUMETRICS)
+      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || DISABLED(FWRETRACT_AUTORETRACT) || ENABLED(NO_VOLUMETRICS)
         bool dummyb;
       #endif
 
@@ -1374,7 +1380,11 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(FWRETRACT)
-        EEPROM_READ(fwretract.autoretract_enabled);
+        #if DISABLED(FWRETRACT_AUTORETRACT)
+          EEPROM_READ(dummyb);
+        #else
+          EEPROM_READ(fwretract.autoretract_enabled);
+        #endif
         EEPROM_READ(fwretract.retract_length);
         EEPROM_READ(fwretract.retract_feedrate_mm_s);
         EEPROM_READ(fwretract.retract_zlift);
@@ -2620,12 +2630,16 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.swap_retract_recover_length));
       SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_recover_feedrate_mm_s)));
 
-      if (!forReplay) {
+      #if ENABLED(FWRETRACT_AUTORETRACT)
+
+        if (!forReplay) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOLNPGM_P(port, "Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
+        }
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-      }
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR_P(port, "  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+        SERIAL_ECHOLNPAIR_P(port, "  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+
+      #endif // FWRETRACT_AUTORETRACT
 
     #endif // FWRETRACT
 

commit cee34f72901788fabc358a31580c9894c6424a20
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 24 21:46:56 2018 -0400

    Followup for BABYSTEP_HOTEND_Z_OFFSET (#11916)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ba007afd28..18743edef1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -495,12 +495,12 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
     #endif // MESH_BED_LEVELING
 
+    _FIELD_TEST(zprobe_zoffset);
+
     #if !HAS_BED_PROBE
       const float zprobe_zoffset = 0;
     #endif
-
-      _FIELD_TEST(zprobe_zoffset);
-      EEPROM_WRITE(zprobe_zoffset);
+    EEPROM_WRITE(zprobe_zoffset);
 
     //
     // Planar Bed Leveling matrix
@@ -1181,12 +1181,12 @@ void MarlinSettings::postprocess() {
         for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
       #endif // MESH_BED_LEVELING
 
+      _FIELD_TEST(zprobe_zoffset);
+
       #if !HAS_BED_PROBE
         float zprobe_zoffset;
       #endif
-
-        _FIELD_TEST(zprobe_zoffset);
-        EEPROM_READ(zprobe_zoffset);
+      EEPROM_READ(zprobe_zoffset);
 
       //
       // Planar Bed Leveling matrix

commit 1104054d7347668a61e90fb6216e22afae2ef9f3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Sep 24 10:40:48 2018 -0400

    2.0 IDEX Independent z offset and other fixes (#11862)
    
    * Add Formbot Raptor board
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Add a second Z probe Z offset
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Modify method to utilize live adjustment of hotend z offset
    
    Should probably move config option to babystepping and rename as it may now apply to all multiextruder systems
    
    * Move config item and catchup other code to current method

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 10c0b66962..ba007afd28 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -153,7 +153,8 @@ typedef struct SettingsDataStruct {
   //
   // HAS_BED_PROBE
   //
-  float zprobe_zoffset;                                 // M851 Z
+
+  float zprobe_zoffset;
 
   //
   // ABL_PLANAR
@@ -494,12 +495,12 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
     #endif // MESH_BED_LEVELING
 
-    _FIELD_TEST(zprobe_zoffset);
-
     #if !HAS_BED_PROBE
       const float zprobe_zoffset = 0;
     #endif
-    EEPROM_WRITE(zprobe_zoffset);
+
+      _FIELD_TEST(zprobe_zoffset);
+      EEPROM_WRITE(zprobe_zoffset);
 
     //
     // Planar Bed Leveling matrix
@@ -1180,12 +1181,12 @@ void MarlinSettings::postprocess() {
         for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
       #endif // MESH_BED_LEVELING
 
-      _FIELD_TEST(zprobe_zoffset);
-
       #if !HAS_BED_PROBE
         float zprobe_zoffset;
       #endif
-      EEPROM_READ(zprobe_zoffset);
+
+        _FIELD_TEST(zprobe_zoffset);
+        EEPROM_READ(zprobe_zoffset);
 
       //
       // Planar Bed Leveling matrix

commit ea9eb2fc8fa8a5b5e3349ef9e11543765f6b3bfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 21 15:20:14 2018 -0400

    Fix servo angles in config-store

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d07479ebf3..10c0b66962 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -558,9 +558,9 @@ void MarlinSettings::postprocess() {
       #endif
       constexpr uint16_t servo_angles[NUM_SERVO_PLUGS][2] = {
         #if ENABLED(SWITCHING_EXTRUDER)
-          [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0], sesa[1] }
+          [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0][0], sesa[0][1] }
           #if EXTRUDERS > 3
-            , [SWITCHING_EXTRUDER_E23_SERVO_NR] = { sesa[2], sesa[3] }
+            , [SWITCHING_EXTRUDER_E23_SERVO_NR] = { sesa[1][0], sesa[1][1] }
           #endif
         #elif ENABLED(SWITCHING_NOZZLE)
           [SWITCHING_NOZZLE_SERVO_NR] = SWITCHING_NOZZLE_SERVO_ANGLES

commit beab9733f8cb0afc72c657ba39557bcdf71b69af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 19 17:06:51 2018 -0500

    Remove extra clauses in config-store

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 101175b229..d07479ebf3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -773,7 +773,7 @@ void MarlinSettings::postprocess() {
                 0,
               #endif
               #if MAX_EXTRUDERS > 3
-                  #if AXIS_IS_TMC(E3)
+                #if AXIS_IS_TMC(E3)
                   stepperE3.getCurrent(),
                 #else
                   0,
@@ -2714,23 +2714,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getCurrent());
       #endif
-      #if E_STEPPERS > 1 && AXIS_IS_TMC(E1)
+      #if AXIS_IS_TMC(E1)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getCurrent());
       #endif
-      #if E_STEPPERS > 2 && AXIS_IS_TMC(E2)
+      #if AXIS_IS_TMC(E2)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getCurrent());
       #endif
-      #if E_STEPPERS > 3 && AXIS_IS_TMC(E3)
+      #if AXIS_IS_TMC(E3)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getCurrent());
       #endif
-      #if E_STEPPERS > 4 && AXIS_IS_TMC(E4)
+      #if AXIS_IS_TMC(E4)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getCurrent());
       #endif
-      #if E_STEPPERS > 5 && AXIS_IS_TMC(E5)
+      #if AXIS_IS_TMC(E5)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T5 E", stepperE5.getCurrent());
       #endif
@@ -2785,23 +2785,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
         #endif
-        #if E_STEPPERS > 1 && AXIS_IS_TMC(E1)
+        #if AXIS_IS_TMC(E1)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T1 E", TMC_GET_PWMTHRS(E, E1));
         #endif
-        #if E_STEPPERS > 2 && AXIS_IS_TMC(E2)
+        #if AXIS_IS_TMC(E2)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T2 E", TMC_GET_PWMTHRS(E, E2));
         #endif
-        #if E_STEPPERS > 3 && AXIS_IS_TMC(E3)
+        #if AXIS_IS_TMC(E3)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T3 E", TMC_GET_PWMTHRS(E, E3));
         #endif
-        #if E_STEPPERS > 4 && AXIS_IS_TMC(E4)
+        #if AXIS_IS_TMC(E4)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
-        #if E_STEPPERS > 5 && AXIS_IS_TMC(E5)
+        #if AXIS_IS_TMC(E5)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T5 E", TMC_GET_PWMTHRS(E, E5));
         #endif

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 031bb2830a..101175b229 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1886,6 +1886,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       "Offsets for the first hotend must be 0.0."
     );
     LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp4[i][e];
+    #if ENABLED(DUAL_X_CARRIAGE)
+      hotend_offset[X_AXIS][1] = MAX(X2_HOME_POS, X2_MAX_POS);
+    #endif
   #endif
 
   //

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3703d27b37..031bb2830a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V57"
+#define EEPROM_VERSION "V58"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -213,7 +213,7 @@ typedef struct SettingsDataStruct {
   //
   // PIDTEMP
   //
-  PIDC hotendPID[MAX_EXTRUDERS];                        // M301 En PIDC / M303 En U
+  PIDC hotendPID[HOTENDS];                              // M301 En PIDC / M303 En U
 
   int16_t lpq_len;                                      // M301 L
 
@@ -244,14 +244,14 @@ typedef struct SettingsDataStruct {
   // !NO_VOLUMETRIC
   //
   bool parser_volumetric_enabled;                       // M200 D  parser.volumetric_enabled
-  float planner_filament_size[MAX_EXTRUDERS];           // M200 T D  planner.filament_size[]
+  float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
 
   //
   // HAS_TRINAMIC
   //
   #define TMC_AXES (MAX_EXTRUDERS + 7)
-  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4
-  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4
+  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
+  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4 E5
   int16_t tmc_sgt[XYZ];                                 // M914 X Y Z
 
   //
@@ -279,8 +279,8 @@ typedef struct SettingsDataStruct {
   //
   // ADVANCED_PAUSE_FEATURE
   //
-  float filament_change_unload_length[MAX_EXTRUDERS],   // M603 T U
-        filament_change_load_length[MAX_EXTRUDERS];     // M603 T L
+  float filament_change_unload_length[EXTRUDERS],       // M603 T U
+        filament_change_load_length[EXTRUDERS];         // M603 T L
 
 } SettingsData;
 
@@ -629,29 +629,23 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(lcd_preheat_bed_temp);
     EEPROM_WRITE(lcd_preheat_fan_speed);
 
-    for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
-
+    for (uint8_t e = 0; e < HOTENDS; e++) {
       #if ENABLED(PIDTEMP)
-        if (e < HOTENDS) {
-          EEPROM_WRITE(PID_PARAM(Kp, e));
-          EEPROM_WRITE(PID_PARAM(Ki, e));
-          EEPROM_WRITE(PID_PARAM(Kd, e));
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            EEPROM_WRITE(PID_PARAM(Kc, e));
-          #else
-            dummy = 1.0f; // 1.0 = default kc
-            EEPROM_WRITE(dummy);
-          #endif
-        }
-        else
-      #endif // !PIDTEMP
-        {
-          dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
-          EEPROM_WRITE(dummy); // Kp
-          dummy = 0;
-          for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
-        }
-
+        EEPROM_WRITE(PID_PARAM(Kp, e));
+        EEPROM_WRITE(PID_PARAM(Ki, e));
+        EEPROM_WRITE(PID_PARAM(Kd, e));
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          EEPROM_WRITE(PID_PARAM(Kc, e));
+        #else
+          dummy = 1.0f; // 1.0 = default kc
+          EEPROM_WRITE(dummy);
+        #endif
+      #else
+        dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
+        EEPROM_WRITE(dummy); // Kp
+        dummy = 0;
+        for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
+      #endif
     } // Hotends Loop
 
     _FIELD_TEST(lpq_len);
@@ -705,17 +699,15 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(parser.volumetric_enabled);
 
       // Save filament sizes
-      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-        if (q < COUNT(planner.filament_size)) dummy = planner.filament_size[q];
-        EEPROM_WRITE(dummy);
-      }
+      for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
+        EEPROM_WRITE(planner.filament_size[q]);
 
     #else
 
       const bool volumetric_enabled = false;
       dummy = DEFAULT_NOMINAL_FILAMENT_DIA;
       EEPROM_WRITE(volumetric_enabled);
-      for (uint8_t q = MAX_EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummy);
 
     #endif
 
@@ -762,31 +754,48 @@ void MarlinSettings::postprocess() {
         #else
           0,
         #endif
-        #if AXIS_IS_TMC(E0)
-          stepperE0.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(E1)
-          stepperE1.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(E2)
-          stepperE2.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(E3)
-          stepperE3.getCurrent(),
-        #else
-          0,
-        #endif
-        #if AXIS_IS_TMC(E4)
-          stepperE4.getCurrent()
-        #else
-          0
-        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_IS_TMC(E0)
+            stepperE0.getCurrent(),
+          #else
+            0,
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_IS_TMC(E1)
+              stepperE1.getCurrent(),
+            #else
+              0,
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_IS_TMC(E2)
+                stepperE2.getCurrent(),
+              #else
+                0,
+              #endif
+              #if MAX_EXTRUDERS > 3
+                  #if AXIS_IS_TMC(E3)
+                  stepperE3.getCurrent(),
+                #else
+                  0,
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_IS_TMC(E4)
+                    stepperE4.getCurrent()
+                  #else
+                    0
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_IS_TMC(E5)
+                      stepperE5.getCurrent()
+                    #else
+                      0
+                    #endif
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
       #else
         0
       #endif
@@ -836,35 +845,69 @@ void MarlinSettings::postprocess() {
         #else
           Z3_HYBRID_THRESHOLD,
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          TMC_GET_PWMTHRS(E, E0),
-        #else
-          E0_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
-          TMC_GET_PWMTHRS(E, E1),
-        #else
-          E1_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
-          TMC_GET_PWMTHRS(E, E2),
-        #else
-          E2_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
-          TMC_GET_PWMTHRS(E, E3),
-        #else
-          E3_HYBRID_THRESHOLD,
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
-          TMC_GET_PWMTHRS(E, E4)
-        #else
-          E4_HYBRID_THRESHOLD
-        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_HAS_STEALTHCHOP(E0)
+            TMC_GET_PWMTHRS(E, E0),
+          #else
+            E0_HYBRID_THRESHOLD,
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              TMC_GET_PWMTHRS(E, E1),
+            #else
+              E1_HYBRID_THRESHOLD,
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_HAS_STEALTHCHOP(E2)
+                TMC_GET_PWMTHRS(E, E2),
+              #else
+                E2_HYBRID_THRESHOLD,
+              #endif
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_HAS_STEALTHCHOP(E3)
+                  TMC_GET_PWMTHRS(E, E3),
+                #else
+                  E3_HYBRID_THRESHOLD,
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_HAS_STEALTHCHOP(E4)
+                    TMC_GET_PWMTHRS(E, E4)
+                  #else
+                    E4_HYBRID_THRESHOLD
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_HAS_STEALTHCHOP(E5)
+                      TMC_GET_PWMTHRS(E, E5)
+                    #else
+                      E5_HYBRID_THRESHOLD
+                    #endif
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
       #else
-        100, 100, 3,          // X, Y, Z
-        100, 100, 3, 3,       // X2, Y2, Z2, Z3
-        30, 30, 30, 30, 30    // E0, E1, E2, E3, E4
+        100, 100, 3,            // X, Y, Z
+        100, 100, 3, 3          // X2, Y2, Z2, Z3
+        #if MAX_EXTRUDERS
+          , 30                  // E0
+          #if MAX_EXTRUDERS > 1
+            , 30                // E1
+            #if MAX_EXTRUDERS > 2
+              , 30              // E2
+              #if MAX_EXTRUDERS > 3
+                , 30            // E3
+                #if MAX_EXTRUDERS > 4
+                  , 30          // E4
+                  #if MAX_EXTRUDERS > 5
+                    , 30        // E5
+                  #endif
+                #endif
+              #endif
+            #endif
+          #endif
+        #endif
       #endif
     };
     EEPROM_WRITE(tmc_hybrid_threshold);
@@ -951,17 +994,13 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(filament_change_unload_length);
 
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-        if (q < COUNT(filament_change_unload_length)) dummy = filament_change_unload_length[q];
-        EEPROM_WRITE(dummy);
-      }
-      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-        if (q < COUNT(filament_change_load_length)) dummy = filament_change_load_length[q];
-        EEPROM_WRITE(dummy);
+      for (uint8_t q = 0; q < COUNT(filament_change_unload_length); q++) {
+        EEPROM_WRITE(filament_change_unload_length[q]);
+        EEPROM_WRITE(filament_change_load_length[q]);
       }
     #else
       dummy = 0;
-      for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
     #endif
 
     //
@@ -1271,9 +1310,9 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(PIDTEMP)
-        for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
+        for (uint8_t e = 0; e < HOTENDS; e++) {
           EEPROM_READ(dummy); // Kp
-          if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
+          if (dummy != DUMMY_PID_VALUE) {
             // do not need to scale PID values as the values in EEPROM are already scaled
             if (!validating) PID_PARAM(Kp, e) = dummy;
             EEPROM_READ(PID_PARAM(Ki, e));
@@ -1284,13 +1323,12 @@ void MarlinSettings::postprocess() {
               EEPROM_READ(dummy);
             #endif
           }
-          else {
+          else
             for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
-          }
         }
       #else // !PIDTEMP
         // 4 x 4 = 16 slots for PID parameters
-        for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
+        for (uint8_t q = HOTENDS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
       #endif // !PIDTEMP
 
       //
@@ -1359,16 +1397,15 @@ void MarlinSettings::postprocess() {
 
         EEPROM_READ(parser.volumetric_enabled);
 
-        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        for (uint8_t q = 0; q < COUNT(planner.filament_size); q++) {
           EEPROM_READ(dummy);
-          if (!validating && q < COUNT(planner.filament_size))
-            planner.filament_size[q] = dummy;
+          if (!validating) planner.filament_size[q] = dummy;
         }
 
       #else
 
         EEPROM_READ(dummyb);
-        for (uint8_t q=MAX_EXTRUDERS; q--;) EEPROM_READ(dummy);
+        for (uint8_t q=EXTRUDERS; q--;) EEPROM_READ(dummy);
 
       #endif
 
@@ -1422,6 +1459,9 @@ void MarlinSettings::postprocess() {
           #if AXIS_IS_TMC(E4)
             SET_CURR(E4);
           #endif
+          #if AXIS_IS_TMC(E5)
+            SET_CURR(E5);
+          #endif
         }
       #else
         uint16_t val;
@@ -1469,6 +1509,9 @@ void MarlinSettings::postprocess() {
           #if AXIS_HAS_STEALTHCHOP(E4)
             TMC_SET_PWMTHRS(E, E4);
           #endif
+          #if AXIS_HAS_STEALTHCHOP(E5)
+            TMC_SET_PWMTHRS(E, E5);
+          #endif
         }
       #else
         uint32_t thrs_val;
@@ -1580,16 +1623,14 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(filament_change_unload_length);
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        for (uint8_t q = 0; q < COUNT(filament_change_unload_length); q++) {
           EEPROM_READ(dummy);
           if (!validating && q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
-        }
-        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
           EEPROM_READ(dummy);
           if (!validating && q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
         }
       #else
-        for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
+        for (uint8_t q = EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
       #endif
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
@@ -2176,6 +2217,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
               CONFIG_ECHO_START;
               SERIAL_ECHOPAIR_P(port, "  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
               SERIAL_EOL_P(port);
+              #if EXTRUDERS > 5
+                CONFIG_ECHO_START;
+                SERIAL_ECHOPAIR_P(port, "  M200 T5 D", LINEAR_UNIT(planner.filament_size[5]));
+                SERIAL_EOL_P(port);
+              #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2
@@ -2681,6 +2727,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getCurrent());
       #endif
+      #if E_STEPPERS > 5 && AXIS_IS_TMC(E5)
+        say_M906(PORTVAR_SOLO);
+        SERIAL_ECHOLNPAIR_P(port, " T5 E", stepperE5.getCurrent());
+      #endif
       SERIAL_EOL_P(port);
 
       /**
@@ -2748,6 +2798,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
+        #if E_STEPPERS > 5 && AXIS_IS_TMC(E5)
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, " T5 E", TMC_GET_PWMTHRS(E, E5));
+        #endif
         SERIAL_EOL_P(port);
       #endif // HYBRID_THRESHOLD
 
@@ -2871,6 +2925,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
               say_M603(PORTVAR_SOLO);
               SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(filament_change_load_length[4]));
               SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[4]));
+              #if EXTRUDERS > 5
+                CONFIG_ECHO_START;
+                say_M603(PORTVAR_SOLO);
+                SERIAL_ECHOPAIR_P(port, "T5 L", LINEAR_UNIT(filament_change_load_length[5]));
+                SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[5]));
+              #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1ddd9bbbd4..3703d27b37 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -428,12 +428,20 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(planner.min_feedrate_mm_s);
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if HAS_CLASSIC_JERK
+      EEPROM_WRITE(planner.max_jerk);
+      #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+        dummy = float(DEFAULT_EJERK);
+        EEPROM_WRITE(dummy);
+      #endif
+    #else
       const float planner_max_jerk[] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
       EEPROM_WRITE(planner_max_jerk);
+    #endif
+
+    #if ENABLED(JUNCTION_DEVIATION)
       EEPROM_WRITE(planner.junction_deviation_mm);
     #else
-      EEPROM_WRITE(planner.max_jerk);
       dummy = 0.02f;
       EEPROM_WRITE(dummy);
     #endif
@@ -1062,11 +1070,18 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(planner.min_feedrate_mm_s);
       EEPROM_READ(planner.min_travel_feedrate_mm_s);
 
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if HAS_CLASSIC_JERK
+        EEPROM_READ(planner.max_jerk);
+        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+          EEPROM_READ(dummy);
+        #endif
+      #else
         for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
+      #endif
+
+      #if ENABLED(JUNCTION_DEVIATION)
         EEPROM_READ(planner.junction_deviation_mm);
       #else
-        EEPROM_READ(planner.max_jerk);
         EEPROM_READ(dummy);
       #endif
 
@@ -1808,11 +1823,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #if ENABLED(JUNCTION_DEVIATION)
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
-  #else
+  #endif
+
+  #if HAS_CLASSIC_JERK
     planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
     planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
     planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
-    planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
+    #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+      planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
+    #endif
   #endif
 
   #if HAS_HOME_OFFSET
@@ -2243,11 +2262,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPGM_P(port, "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
       #if ENABLED(JUNCTION_DEVIATION)
         SERIAL_ECHOPGM_P(port, " J<junc_dev>");
-      #else
-        SERIAL_ECHOPGM_P(port, " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
       #endif
-      #if DISABLED(JUNCTION_DEVIATION) || ENABLED(LIN_ADVANCE)
-        SERIAL_ECHOPGM_P(port, " E<max_e_jerk>");
+      #if HAS_CLASSIC_JERK
+        SERIAL_ECHOPGM_P(port, " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
+        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+          SERIAL_ECHOPGM_P(port, " E<max_e_jerk>");
+        #endif
       #endif
       SERIAL_EOL_P(port);
     }
@@ -2258,11 +2278,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #if ENABLED(JUNCTION_DEVIATION)
       SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.junction_deviation_mm));
-    #else
+    #endif
+    #if HAS_CLASSIC_JERK
       SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
-      SERIAL_ECHOPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+      #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+        SERIAL_ECHOPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+      #endif
     #endif
 
     SERIAL_EOL_P(port);

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger Müller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6a5d630473..1ddd9bbbd4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -194,10 +194,13 @@ typedef struct SettingsDataStruct {
           delta_segments_per_second,                    // M665 S
           delta_calibration_radius,                     // M665 B
           delta_tower_angle_trim[ABC];                  // M665 XYZ
-  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-    float x_endstop_adj,                                // M666 X
-          y_endstop_adj,                                // M666 Y
-          z_endstop_adj;                                // M666 Z
+  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+    float x2_endstop_adj,                                // M666 X
+          y2_endstop_adj,                                // M666 Y
+          z2_endstop_adj;                                // M666 Z
+    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      float z3_endstop_adj;                             // M666 Z
+    #endif
   #endif
 
   //
@@ -246,9 +249,9 @@ typedef struct SettingsDataStruct {
   //
   // HAS_TRINAMIC
   //
-  #define TMC_AXES (MAX_EXTRUDERS + 6)
-  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
-  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
+  #define TMC_AXES (MAX_EXTRUDERS + 7)
+  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4
+  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 Z3 E0 E1 E2 E3 E4
   int16_t tmc_sgt[XYZ];                                 // M914 X Y Z
 
   //
@@ -574,26 +577,32 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(delta_calibration_radius);  // 1 float
       EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
-    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
-      _FIELD_TEST(x_endstop_adj);
+      _FIELD_TEST(x2_endstop_adj);
 
       // Write dual endstops in X, Y, Z order. Unused = 0.0
       dummy = 0;
       #if ENABLED(X_DUAL_ENDSTOPS)
-        EEPROM_WRITE(endstops.x_endstop_adj);   // 1 float
+        EEPROM_WRITE(endstops.x2_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummy);
       #endif
 
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        EEPROM_WRITE(endstops.y_endstop_adj);   // 1 float
+        EEPROM_WRITE(endstops.y2_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummy);
       #endif
 
-      #if ENABLED(Z_DUAL_ENDSTOPS)
-        EEPROM_WRITE(endstops.z_endstop_adj);   // 1 float
+      #if Z_MULTI_ENDSTOPS
+        EEPROM_WRITE(endstops.z2_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummy);
+      #endif
+
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummy);
       #endif
@@ -740,6 +749,11 @@ void MarlinSettings::postprocess() {
         #else
           0,
         #endif
+        #if AXIS_IS_TMC(Z3)
+          stepperZ3.getCurrent(),
+        #else
+          0,
+        #endif
         #if AXIS_IS_TMC(E0)
           stepperE0.getCurrent(),
         #else
@@ -809,6 +823,11 @@ void MarlinSettings::postprocess() {
         #else
           Z2_HYBRID_THRESHOLD,
         #endif
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          TMC_GET_PWMTHRS(Z, Z3),
+        #else
+          Z3_HYBRID_THRESHOLD,
+        #endif
         #if AXIS_HAS_STEALTHCHOP(E0)
           TMC_GET_PWMTHRS(E, E0),
         #else
@@ -836,7 +855,7 @@ void MarlinSettings::postprocess() {
         #endif
       #else
         100, 100, 3,          // X, Y, Z
-        100, 100, 3,          // X2, Y2, Z2
+        100, 100, 3, 3,       // X2, Y2, Z2, Z3
         30, 30, 30, 30, 30    // E0, E1, E2, E3, E4
       #endif
     };
@@ -1187,22 +1206,27 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(delta_calibration_radius);  // 1 float
         EEPROM_READ(delta_tower_angle_trim);    // 3 floats
 
-      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
-        _FIELD_TEST(x_endstop_adj);
+        _FIELD_TEST(x2_endstop_adj);
 
         #if ENABLED(X_DUAL_ENDSTOPS)
-          EEPROM_READ(endstops.x_endstop_adj);  // 1 float
+          EEPROM_READ(endstops.x2_endstop_adj);  // 1 float
         #else
           EEPROM_READ(dummy);
         #endif
         #if ENABLED(Y_DUAL_ENDSTOPS)
-          EEPROM_READ(endstops.y_endstop_adj);  // 1 float
+          EEPROM_READ(endstops.y2_endstop_adj);  // 1 float
+        #else
+          EEPROM_READ(dummy);
+        #endif
+        #if Z_MULTI_ENDSTOPS
+          EEPROM_READ(endstops.z2_endstop_adj); // 1 float
         #else
           EEPROM_READ(dummy);
         #endif
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          EEPROM_READ(endstops.z_endstop_adj); // 1 float
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          EEPROM_READ(endstops.z3_endstop_adj); // 1 float
         #else
           EEPROM_READ(dummy);
         #endif
@@ -1365,6 +1389,9 @@ void MarlinSettings::postprocess() {
           #if AXIS_IS_TMC(Z2)
             SET_CURR(Z2);
           #endif
+          #if AXIS_IS_TMC(Z3)
+            SET_CURR(Z3);
+          #endif
           #if AXIS_IS_TMC(E0)
             SET_CURR(E0);
           #endif
@@ -1409,6 +1436,9 @@ void MarlinSettings::postprocess() {
           #if AXIS_HAS_STEALTHCHOP(Z2)
             TMC_SET_PWMTHRS(Z, Z2);
           #endif
+          #if AXIS_HAS_STEALTHCHOP(Z3)
+            TMC_SET_PWMTHRS(Z, Z3);
+          #endif
           #if AXIS_HAS_STEALTHCHOP(E0)
             TMC_SET_PWMTHRS(E, E0);
           #endif
@@ -1434,7 +1464,7 @@ void MarlinSettings::postprocess() {
        * TMC2130 Sensorless homing threshold.
        * X and X2 use the same value
        * Y and Y2 use the same value
-       * Z and Z2 use the same value
+       * Z, Z2 and Z3 use the same value
        */
       int16_t tmc_sgt[XYZ];
       EEPROM_READ(tmc_sgt);
@@ -1463,6 +1493,9 @@ void MarlinSettings::postprocess() {
             #if AXIS_HAS_STALLGUARD(Z2)
               stepperZ2.sgt(tmc_sgt[2]);
             #endif
+            #if AXIS_HAS_STALLGUARD(Z3)
+              stepperZ3.sgt(tmc_sgt[2]);
+            #endif
           #endif
         }
       #endif
@@ -1860,10 +1893,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
     COPY(delta_tower_angle_trim, dta);
 
-  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
 
     #if ENABLED(X_DUAL_ENDSTOPS)
-      endstops.x_endstop_adj = (
+      endstops.x2_endstop_adj = (
         #ifdef X_DUAL_ENDSTOPS_ADJUSTMENT
           X_DUAL_ENDSTOPS_ADJUSTMENT
         #else
@@ -1872,7 +1905,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       );
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      endstops.y_endstop_adj = (
+      endstops.y2_endstop_adj = (
         #ifdef Y_DUAL_ENDSTOPS_ADJUSTMENT
           Y_DUAL_ENDSTOPS_ADJUSTMENT
         #else
@@ -1881,13 +1914,28 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       );
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      endstops.z_endstop_adj = (
+      endstops.z2_endstop_adj = (
         #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
           Z_DUAL_ENDSTOPS_ADJUSTMENT
         #else
           0
         #endif
       );
+    #elif ENABLED(Z_TRIPLE_ENDSTOPS)
+      endstops.z2_endstop_adj = (
+        #ifdef Z_TRIPLE_ENDSTOPS_ADJUSTMENT2
+          Z_TRIPLE_ENDSTOPS_ADJUSTMENT2
+        #else
+          0
+        #endif
+      );
+      endstops.z3_endstop_adj = (
+        #ifdef Z_TRIPLE_ENDSTOPS_ADJUSTMENT3
+          Z_TRIPLE_ENDSTOPS_ADJUSTMENT3
+        #else
+          0
+        #endif
+      );
     #endif
 
   #endif
@@ -2391,13 +2439,17 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       CONFIG_ECHO_START;
       SERIAL_ECHOPGM_P(port, "  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(endstops.x_endstop_adj));
+        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(endstops.x2_endstop_adj));
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(endstops.y_endstop_adj));
+        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(endstops.y2_endstop_adj));
       #endif
-      #if ENABLED(Z_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(endstops.z_endstop_adj));
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        SERIAL_ECHOLNPAIR_P(port, "S1 Z", LINEAR_UNIT(endstops.z2_endstop_adj));
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR_P(port, "  M666 S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+      #elif ENABLED(Z_DUAL_ENDSTOPS)
+        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(endstops.z2_endstop_adj));
       #endif
       SERIAL_EOL_P(port);
 
@@ -2582,6 +2634,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         SERIAL_EOL_P(port);
       #endif
+      #if AXIS_IS_TMC(Z3)
+        say_M906(PORTVAR_SOLO);
+        SERIAL_ECHOLNPAIR_P(port, " I2 Z", stepperZ3.getCurrent());
+      #endif
       #if AXIS_IS_TMC(E0)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getCurrent());
@@ -2644,6 +2700,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
           SERIAL_EOL_P(port);
         #endif
+        #if AXIS_IS_TMC(Z3)
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOPGM_P(port, " I2");
+          SERIAL_ECHOLNPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z3));
+        #endif
         #if AXIS_IS_TMC(E0)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
@@ -2693,6 +2754,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         #define HAS_X2_SENSORLESS (defined(X_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
         #define HAS_Y2_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Y2))
         #define HAS_Z2_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
+        #define HAS_Z3_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z3))
         #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
           say_M914(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I1");
@@ -2708,6 +2770,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_EOL_P(port);
         #endif
 
+        #if HAS_Z3_SENSORLESS
+          say_M914(PORTVAR_SOLO);
+          SERIAL_ECHOPGM_P(port, " I2");
+          SERIAL_ECHOLNPAIR_P(port, " Z", stepperZ3.sgt());
+        #endif
+
       #endif // SENSORLESS_HOMING
 
     #endif // HAS_TRINAMIC

commit 8584d3697d1e0bebe67e8d30184ef7dc04d873e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 11 16:20:12 2018 -0500

    Fix servo count define conflict
    
    `MAX_SERVOS` => `NUM_SERVO_PLUGS`

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ae48b7e7a4..6a5d630473 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -181,7 +181,7 @@ typedef struct SettingsDataStruct {
   //
   // SERVO_ANGLES
   //
-  uint16_t servo_angles[MAX_SERVOS][2];                 // M281 P L U
+  uint16_t servo_angles[NUM_SERVO_PLUGS][2];                 // M281 P L U
 
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
@@ -545,7 +545,7 @@ void MarlinSettings::postprocess() {
       #if ENABLED(SWITCHING_EXTRUDER)
         constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
       #endif
-      constexpr uint16_t servo_angles[MAX_SERVOS][2] = {
+      constexpr uint16_t servo_angles[NUM_SERVO_PLUGS][2] = {
         #if ENABLED(SWITCHING_EXTRUDER)
           [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0], sesa[1] }
           #if EXTRUDERS > 3
@@ -1167,7 +1167,7 @@ void MarlinSettings::postprocess() {
       // SERVO_ANGLES
       //
       #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
-        uint16_t servo_angles[MAX_SERVOS][2];
+        uint16_t servo_angles[NUM_SERVO_PLUGS][2];
       #endif
       EEPROM_READ(servo_angles);
 

commit 4f883d59712608d82d33d387d13571c8a0b7dfd4
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Tue Sep 11 04:37:32 2018 +0100

    [2.0.x] Extruder-Distinct Linear Advance K Factors (#11789)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9028df8a26..ae48b7e7a4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V56"
+#define EEPROM_VERSION "V57"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -254,7 +254,7 @@ typedef struct SettingsDataStruct {
   //
   // LIN_ADVANCE
   //
-  float planner_extruder_advance_K;                     // M900 K    planner.extruder_advance_K
+  float planner_extruder_advance_K[EXTRUDERS];          // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
@@ -871,14 +871,13 @@ void MarlinSettings::postprocess() {
     //
     // Linear Advance
     //
-
     _FIELD_TEST(planner_extruder_advance_K);
 
     #if ENABLED(LIN_ADVANCE)
-      EEPROM_WRITE(planner.extruder_advance_K);
+      LOOP_L_N(i, EXTRUDERS) EEPROM_WRITE(planner.extruder_advance_K[i]);
     #else
       dummy = 0;
-      EEPROM_WRITE(dummy);
+      LOOP_L_N(i, EXTRUDERS) EEPROM_WRITE(dummy);
     #endif
 
     _FIELD_TEST(motor_current_setting);
@@ -1471,14 +1470,15 @@ void MarlinSettings::postprocess() {
       //
       // Linear Advance
       //
-
       _FIELD_TEST(planner_extruder_advance_K);
 
-      #if ENABLED(LIN_ADVANCE)
-        EEPROM_READ(planner.extruder_advance_K);
-      #else
-        EEPROM_READ(dummy);
-      #endif
+      LOOP_L_N(i, EXTRUDERS) {
+        #if ENABLED(LIN_ADVANCE)
+          EEPROM_READ(planner.extruder_advance_K[i]);
+        #else
+          EEPROM_READ(dummy);
+        #endif
+      }
 
       //
       // Motor Current PWM
@@ -1957,7 +1957,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   reset_stepper_drivers();
 
   #if ENABLED(LIN_ADVANCE)
-    planner.extruder_advance_K = LIN_ADVANCE_K;
+    LOOP_L_N(i, EXTRUDERS) planner.extruder_advance_K[i] = LIN_ADVANCE_K;
   #endif
 
   #if HAS_MOTOR_CURRENT_PWM
@@ -2720,8 +2720,16 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Linear Advance:");
       }
+
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR_P(port, "  M900 K", planner.extruder_advance_K);
+      #if EXTRUDERS < 2
+        SERIAL_ECHOLNPAIR_P(port, "  M900 K", planner.extruder_advance_K[0]);
+      #else
+        LOOP_L_N(i, EXTRUDERS) {
+          SERIAL_ECHOPAIR_P(port, "  M900 T", int(i));
+          SERIAL_ECHOLNPAIR_P(port, " K", planner.extruder_advance_K[i]);
+        }
+      #endif
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM

commit 8e18e48d49a3fe61348a2b996a7b5f4c32069002
Merge: 4668c71a75 3e81745e81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 03:55:38 2018 -0500

    Merge pull request #11610 from Freeviv/bugfix-2.0.x
    
    [2.0.x] Editable servo angles

diff --combined Marlin/src/module/configuration_store.cpp
index a97dbb73c5,20bcb1ce74..9028df8a26
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@@ -37,7 -37,7 +37,7 @@@
   */
  
  // Change EEPROM version if the structure changes
- #define EEPROM_VERSION "V55"
+ #define EEPROM_VERSION "V56"
  #define EEPROM_OFFSET 100
  
  // Check the integrity of data offsets.
@@@ -70,6 -70,10 +70,10 @@@
    #include "../feature/bedlevel/bedlevel.h"
  #endif
  
+ #if HAS_SERVOS
+   #include "servo.h"
+ #endif
+ 
  #if HAS_BED_PROBE
    #include "../module/probe.h"
  #endif
@@@ -174,6 -178,11 +178,11 @@@ typedef struct SettingsDataStruct 
    bool planner_leveling_active;                         // M420 S  planner.leveling_active
    int8_t ubl_storage_slot;                              // ubl.storage_slot
  
+   //
+   // SERVO_ANGLES
+   //
+   uint16_t servo_angles[MAX_SERVOS][2];                 // M281 P L U
+ 
    //
    // DELTA / [XYZ]_DUAL_ENDSTOPS
    //
@@@ -532,6 -541,26 +541,26 @@@ void MarlinSettings::postprocess() 
        EEPROM_WRITE(storage_slot);
      #endif // AUTO_BED_LEVELING_UBL
  
+     #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+       #if ENABLED(SWITCHING_EXTRUDER)
+         constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+       #endif
+       constexpr uint16_t servo_angles[MAX_SERVOS][2] = {
+         #if ENABLED(SWITCHING_EXTRUDER)
+           [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0], sesa[1] }
+           #if EXTRUDERS > 3
+             , [SWITCHING_EXTRUDER_E23_SERVO_NR] = { sesa[2], sesa[3] }
+           #endif
+         #elif ENABLED(SWITCHING_NOZZLE)
+           [SWITCHING_NOZZLE_SERVO_NR] = SWITCHING_NOZZLE_SERVO_ANGLES
+         #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+           [Z_PROBE_SERVO_NR] = Z_SERVO_ANGLES
+         #endif
+       };
+     #endif
+ 
+     EEPROM_WRITE(servo_angles);
+ 
      // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
      #if ENABLED(DELTA)
  
@@@ -1135,6 -1164,14 +1164,14 @@@
          EEPROM_READ(dummyui8);
        #endif // AUTO_BED_LEVELING_UBL
  
+       //
+       // SERVO_ANGLES
+       //
+       #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+         uint16_t servo_angles[MAX_SERVOS][2];
+       #endif
+       EEPROM_READ(servo_angles);
+ 
        //
        // DELTA Geometry or Dual Endstops offsets
        //
@@@ -1774,6 -1811,44 +1811,44 @@@ void MarlinSettings::reset(PORTARG_SOLO
      zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
    #endif
  
+   //
+   // Servo Angles
+   //
+ 
+   #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
+ 
+     #if ENABLED(SWITCHING_EXTRUDER)
+ 
+       #if EXTRUDERS > 3
+         #define REQ_ANGLES 4
+       #else
+         #define REQ_ANGLES 2
+       #endif
+       constexpr uint16_t extruder_angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+       static_assert(COUNT(extruder_angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
+       servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = extruder_angles[0];
+       servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = extruder_angles[1];
+       #if EXTRUDERS > 3
+         servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = extruder_angles[2];
+         servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = extruder_angles[3];
+       #endif
+ 
+     #elif ENABLED(SWITCHING_NOZZLE)
+ 
+       constexpr uint16_t nozzle_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+       servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = nozzle_angles[0];
+       servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = nozzle_angles[1];
+ 
+     #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+ 
+       constexpr uint16_t z_probe_angles[2] = Z_SERVO_ANGLES;
+       servo_angles[Z_PROBE_SERVO_NR][0] = z_probe_angles[0];
+       servo_angles[Z_PROBE_SERVO_NR][1] = z_probe_angles[1];
+ 
+     #endif
+ 
+   #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
+ 
    #if ENABLED(DELTA)
      const float adj[ABC] = DELTA_ENDSTOP_ADJ,
                  dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
@@@ -2165,8 -2240,7 +2240,8 @@@
          SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
          SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
          SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
 -        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
 +        SERIAL_ECHO_P(port, " Z");
 +        SERIAL_ECHO_F_P(port, LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
          SERIAL_EOL_P(port);
        }
      #endif
@@@ -2253,6 -2327,35 +2328,35 @@@
  
      #endif // HAS_LEVELING
  
+     #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
+ 
+       if (!forReplay) {
+         CONFIG_ECHO_START;
+         SERIAL_ECHOLNPGM_P(port, "Servo Angles:");
+       }
+       for (uint8_t i = 0; i < NUM_SERVOS; i++) {
+         switch (i) {
+           #if ENABLED(SWITCHING_EXTRUDER)
+             case SWITCHING_EXTRUDER_SERVO_NR:
+             #if EXTRUDERS > 3
+               case SWITCHING_EXTRUDER_E23_SERVO_NR:
+             #endif
+           #elif ENABLED(SWITCHING_NOZZLE)
+             case SWITCHING_NOZZLE_SERVO_NR:
+           #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+             case Z_PROBE_SERVO_NR:
+           #endif
+             CONFIG_ECHO_START;
+             SERIAL_ECHOPAIR_P(port, "  M281 P", int(i));
+             SERIAL_ECHOPAIR_P(port, " L", servo_angles[i][0]);
+             SERIAL_ECHOPAIR_P(port, " U", servo_angles[i][1]);
+             SERIAL_EOL_P(port);
+           default: break;
+         }
+       }
+ 
+     #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
+ 
      #if ENABLED(DELTA)
  
        if (!forReplay) {

commit ada85d5585472a9fcf32b4367678808597b3f705
Author: scott0122 <39105828+scott0122@users.noreply.github.com>
Date:   Sat Sep 1 04:15:40 2018 +0800

    Improve HOTEND OFFSET Z display precision to 3 (#11686)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 83cb3b4c46..a97dbb73c5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2165,7 +2165,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
         SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
+        SERIAL_ECHO_P(port, " Z");
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(hotend_offset[Z_AXIS][e]), 3);
         SERIAL_EOL_P(port);
       }
     #endif

commit 3e81745e81fea173599b06ac9db7ed776e986808
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:53:42 2018 -0500

    Fix issues, make optional

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 097842e47f..20bcb1ce74 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -72,7 +72,7 @@
 
 #if HAS_SERVOS
   #include "servo.h"
-#endif 
+#endif
 
 #if HAS_BED_PROBE
   #include "../module/probe.h"
@@ -181,9 +181,7 @@ typedef struct SettingsDataStruct {
   //
   // SERVO_ANGLES
   //
-  #if HAS_SERVOS
-    uint8_t servo_angles[NUM_SERVOS][2];
-  #endif
+  uint16_t servo_angles[MAX_SERVOS][2];                 // M281 P L U
 
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
@@ -543,10 +541,26 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
-    #if HAS_SERVOS
-      EEPROM_WRITE(servo_angles);
+    #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+      #if ENABLED(SWITCHING_EXTRUDER)
+        constexpr uint16_t sesa[][2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+      #endif
+      constexpr uint16_t servo_angles[MAX_SERVOS][2] = {
+        #if ENABLED(SWITCHING_EXTRUDER)
+          [SWITCHING_EXTRUDER_SERVO_NR] = { sesa[0], sesa[1] }
+          #if EXTRUDERS > 3
+            , [SWITCHING_EXTRUDER_E23_SERVO_NR] = { sesa[2], sesa[3] }
+          #endif
+        #elif ENABLED(SWITCHING_NOZZLE)
+          [SWITCHING_NOZZLE_SERVO_NR] = SWITCHING_NOZZLE_SERVO_ANGLES
+        #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+          [Z_PROBE_SERVO_NR] = Z_SERVO_ANGLES
+        #endif
+      };
     #endif
 
+    EEPROM_WRITE(servo_angles);
+
     // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
 
@@ -1153,10 +1167,10 @@ void MarlinSettings::postprocess() {
       //
       // SERVO_ANGLES
       //
-      #if HAS_SERVOS
-        EEPROM_READ(servo_angles);
+      #if !HAS_SERVOS || DISABLED(EDITABLE_SERVO_ANGLES)
+        uint16_t servo_angles[MAX_SERVOS][2];
       #endif
-
+      EEPROM_READ(servo_angles);
 
       //
       // DELTA Geometry or Dual Endstops offsets
@@ -1801,32 +1815,39 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   // Servo Angles
   //
 
-  #if HAS_SERVOS
+  #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
+
     #if ENABLED(SWITCHING_EXTRUDER)
+
       #if EXTRUDERS > 3
         #define REQ_ANGLES 4
       #else
         #define REQ_ANGLES 2
       #endif
-      const uint8_t extruder_angles[2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+      constexpr uint16_t extruder_angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
       static_assert(COUNT(extruder_angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
       servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = extruder_angles[0];
       servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = extruder_angles[1];
-    #endif
+      #if EXTRUDERS > 3
+        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][0] = extruder_angles[2];
+        servo_angles[SWITCHING_EXTRUDER_E23_SERVO_NR][1] = extruder_angles[3];
+      #endif
 
-    #if ENABLED(SWITCHING_NOZZLE)
-      const uint8_t nozzel_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = nozzel_angles[0];
-      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = nozzel_angles[1];
-    #endif
+    #elif ENABLED(SWITCHING_NOZZLE)
 
-    #if defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
-      const uint8_t z_probe_angles[2] = Z_SERVO_ANGLES;
+      constexpr uint16_t nozzle_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = nozzle_angles[0];
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = nozzle_angles[1];
+
+    #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+
+      constexpr uint16_t z_probe_angles[2] = Z_SERVO_ANGLES;
       servo_angles[Z_PROBE_SERVO_NR][0] = z_probe_angles[0];
       servo_angles[Z_PROBE_SERVO_NR][1] = z_probe_angles[1];
+
     #endif
 
-  #endif
+  #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
 
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ,
@@ -2306,19 +2327,34 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #endif // HAS_LEVELING
 
-    #if HAS_SERVOS
+    #if HAS_SERVOS && ENABLED(EDITABLE_SERVO_ANGLES)
+
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Servo Angles:");
       }
       for (uint8_t i = 0; i < NUM_SERVOS; i++) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR_P(port, "  M281 P", i);
-        SERIAL_ECHOPAIR_P(port, " L",servo_angles[i][0]);
-        SERIAL_ECHOPAIR_P(port, " U",servo_angles[i][1]);
-        SERIAL_EOL_P(port);
+        switch (i) {
+          #if ENABLED(SWITCHING_EXTRUDER)
+            case SWITCHING_EXTRUDER_SERVO_NR:
+            #if EXTRUDERS > 3
+              case SWITCHING_EXTRUDER_E23_SERVO_NR:
+            #endif
+          #elif ENABLED(SWITCHING_NOZZLE)
+            case SWITCHING_NOZZLE_SERVO_NR:
+          #elif defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+            case Z_PROBE_SERVO_NR:
+          #endif
+            CONFIG_ECHO_START;
+            SERIAL_ECHOPAIR_P(port, "  M281 P", int(i));
+            SERIAL_ECHOPAIR_P(port, " L", servo_angles[i][0]);
+            SERIAL_ECHOPAIR_P(port, " U", servo_angles[i][1]);
+            SERIAL_EOL_P(port);
+          default: break;
+        }
       }
-    #endif
+
+    #endif // HAS_SERVOS && EDITABLE_SERVO_ANGLES
 
     #if ENABLED(DELTA)
 

commit aa80e448e24a27ac0006de4e3d3e93b18c73e3e0
Author: Jan <janschon@uni-bremen.de>
Date:   Tue Aug 7 17:04:46 2018 +0200

    Store servo angles in EEPROM

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 83cb3b4c46..097842e47f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V55"
+#define EEPROM_VERSION "V56"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -70,6 +70,10 @@
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if HAS_SERVOS
+  #include "servo.h"
+#endif 
+
 #if HAS_BED_PROBE
   #include "../module/probe.h"
 #endif
@@ -174,6 +178,13 @@ typedef struct SettingsDataStruct {
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
+  //
+  // SERVO_ANGLES
+  //
+  #if HAS_SERVOS
+    uint8_t servo_angles[NUM_SERVOS][2];
+  #endif
+
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
   //
@@ -532,6 +543,10 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
+    #if HAS_SERVOS
+      EEPROM_WRITE(servo_angles);
+    #endif
+
     // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
 
@@ -1135,6 +1150,14 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(dummyui8);
       #endif // AUTO_BED_LEVELING_UBL
 
+      //
+      // SERVO_ANGLES
+      //
+      #if HAS_SERVOS
+        EEPROM_READ(servo_angles);
+      #endif
+
+
       //
       // DELTA Geometry or Dual Endstops offsets
       //
@@ -1774,6 +1797,37 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
   #endif
 
+  //
+  // Servo Angles
+  //
+
+  #if HAS_SERVOS
+    #if ENABLED(SWITCHING_EXTRUDER)
+      #if EXTRUDERS > 3
+        #define REQ_ANGLES 4
+      #else
+        #define REQ_ANGLES 2
+      #endif
+      const uint8_t extruder_angles[2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+      static_assert(COUNT(extruder_angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
+      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][0] = extruder_angles[0];
+      servo_angles[SWITCHING_EXTRUDER_SERVO_NR][1] = extruder_angles[1];
+    #endif
+
+    #if ENABLED(SWITCHING_NOZZLE)
+      const uint8_t nozzel_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][0] = nozzel_angles[0];
+      servo_angles[SWITCHING_NOZZLE_SERVO_NR][1] = nozzel_angles[1];
+    #endif
+
+    #if defined(Z_SERVO_ANGLES) && defined(Z_PROBE_SERVO_NR)
+      const uint8_t z_probe_angles[2] = Z_SERVO_ANGLES;
+      servo_angles[Z_PROBE_SERVO_NR][0] = z_probe_angles[0];
+      servo_angles[Z_PROBE_SERVO_NR][1] = z_probe_angles[1];
+    #endif
+
+  #endif
+
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ,
                 dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
@@ -2252,6 +2306,20 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     #endif // HAS_LEVELING
 
+    #if HAS_SERVOS
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM_P(port, "Servo Angles:");
+      }
+      for (uint8_t i = 0; i < NUM_SERVOS; i++) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR_P(port, "  M281 P", i);
+        SERIAL_ECHOPAIR_P(port, " L",servo_angles[i][0]);
+        SERIAL_ECHOPAIR_P(port, " U",servo_angles[i][1]);
+        SERIAL_EOL_P(port);
+      }
+    #endif
+
     #if ENABLED(DELTA)
 
       if (!forReplay) {

commit d1c9517903da3e7ab84e34ffb2c23d0772f2ce8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:26:29 2018 -0500

    Followup to hotend_offset[Z] patch

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 092934a66e..83cb3b4c46 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -126,7 +126,7 @@ typedef struct SettingsDataStruct {
 
   float home_offset[XYZ];                               // M206 XYZ
 
-  #if HOTENDS > 1
+  #if HAS_HOTEND_OFFSET
     float hotend_offset[XYZ][HOTENDS - 1];              // M218 XYZ
   #endif
 
@@ -433,7 +433,7 @@ void MarlinSettings::postprocess() {
     #endif
     EEPROM_WRITE(home_offset);
 
-    #if HOTENDS > 1
+    #if HAS_HOTEND_OFFSET
       // Skip hotend 0 which must be 0
       for (uint8_t e = 1; e < HOTENDS; e++)
         LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
@@ -1038,7 +1038,7 @@ void MarlinSettings::postprocess() {
       // Hotend Offsets, if any
       //
 
-      #if HOTENDS > 1
+      #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
         for (uint8_t e = 1; e < HOTENDS; e++)
           LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
@@ -1749,16 +1749,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     ZERO(home_offset);
   #endif
 
-  #if HOTENDS > 1
-    constexpr float tmp4[XYZ][HOTENDS] = {
-      HOTEND_OFFSET_X,
-      HOTEND_OFFSET_Y
-      #ifdef HOTEND_OFFSET_Z
-        , HOTEND_OFFSET_Z
-      #else
-        , { 0 }
-      #endif
-    };
+  #if HAS_HOTEND_OFFSET
+    constexpr float tmp4[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       tmp4[X_AXIS][0] == 0 && tmp4[Y_AXIS][0] == 0 && tmp4[Z_AXIS][0] == 0,
       "Offsets for the first hotend must be 0.0."
@@ -2163,7 +2155,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(home_offset[Z_AXIS]));
     #endif
 
-    #if HOTENDS > 1
+    #if HAS_HOTEND_OFFSET
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Hotend offsets:");
@@ -2173,9 +2165,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
         SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        #if HAS_HOTEND_OFFSET_Z
-          SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
-        #endif
+        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
         SERIAL_EOL_P(port);
       }
     #endif

commit c64199941e058abb18a06be90002f5f03009347b
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Tue Aug 14 01:28:52 2018 -0700

    Compile only selected PIO environment (#11519)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 05f7d3766a..092934a66e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -344,7 +344,7 @@ void MarlinSettings::postprocess() {
 }
 
 #if ENABLED(EEPROM_SETTINGS)
-  #include "../HAL/persistent_store_api.h"
+  #include "../HAL/shared/persistent_store_api.h"
 
   #define DUMMY_PID_VALUE 3000.0f
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()

commit 6a8b906318dc182f5566a9777108360514bfbd35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 17:43:24 2018 -0500

    Followup for persistent_store_api.h

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dacee2eb8f..05f7d3766a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -345,7 +345,6 @@ void MarlinSettings::postprocess() {
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../HAL/persistent_store_api.h"
-  PersistentStore persistentStore;
 
   #define DUMMY_PID_VALUE 3000.0f
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()

commit 66d2b48b5995a4225029f7fed84a2dfe0ee9300a
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Mon Aug 13 23:30:26 2018 +0100

    Update PersistentStore api (#11538)
    
    - Clean up the API to use a `static` class instance to adhere to Marlin convention
    - Add `const` position data access for read/write
    - Add Storage capacity to the interface

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8af22648b6..dacee2eb8f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -345,14 +345,15 @@ void MarlinSettings::postprocess() {
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../HAL/persistent_store_api.h"
+  PersistentStore persistentStore;
 
   #define DUMMY_PID_VALUE 3000.0f
-  #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; HAL::PersistentStore::access_start()
-  #define EEPROM_FINISH() HAL::PersistentStore::access_finish()
+  #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; persistentStore.access_start()
+  #define EEPROM_FINISH() persistentStore.access_finish()
   #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
-  #define EEPROM_WRITE(VAR) HAL::PersistentStore::write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
-  #define EEPROM_READ_ALWAYS(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
+  #define EEPROM_WRITE(VAR) persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
+  #define EEPROM_READ(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
+  #define EEPROM_READ_ALWAYS(VAR) persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START_P(port); SERIAL_ERRORLNPGM_P(port, ERR); eeprom_error = true; }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
@@ -1607,6 +1608,10 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
+    const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
+                                                                                  // is a placeholder for the size of the MAT; the MAT will always
+                                                                                  // live at the very end of the eeprom
+
     uint16_t MarlinSettings::meshes_start_index() {
       return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
                                                           // or down a little bit without disrupting the mesh data
@@ -1627,7 +1632,7 @@ void MarlinSettings::postprocess() {
         if (!WITHIN(slot, 0, a - 1)) {
           #if ENABLED(EEPROM_CHITCHAT)
             ubl_invalid_slot(a);
-            SERIAL_PROTOCOLPAIR("E2END=", E2END);
+            SERIAL_PROTOCOLPAIR("E2END=", persistentStore.capacity() - 1);
             SERIAL_PROTOCOLPAIR(" meshes_end=", meshes_end);
             SERIAL_PROTOCOLLNPAIR(" slot=", slot);
             SERIAL_EOL();
@@ -1638,9 +1643,9 @@ void MarlinSettings::postprocess() {
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
 
-        HAL::PersistentStore::access_start();
-        const bool status = HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
-        HAL::PersistentStore::access_finish();
+        persistentStore.access_start();
+        const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        persistentStore.access_finish();
 
         if (status)
           SERIAL_PROTOCOLPGM("?Unable to save mesh data.\n");
@@ -1676,9 +1681,9 @@ void MarlinSettings::postprocess() {
         uint16_t crc = 0;
         uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
 
-        HAL::PersistentStore::access_start();
-        const uint16_t status = HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
-        HAL::PersistentStore::access_finish();
+        persistentStore.access_start();
+        const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        persistentStore.access_finish();
 
         if (status)
           SERIAL_PROTOCOLPGM("?Unable to load mesh data.\n");

commit fbcdf5eaeb4f2265fd43097ab6c652a89842d8e7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jul 14 14:13:06 2018 +0300

    Simplify stepper driver per-axis selection

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f9fdbd3800..8af22648b6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -681,57 +681,57 @@ void MarlinSettings::postprocess() {
 
     uint16_t tmc_stepper_current[TMC_AXES] = {
       #if HAS_TRINAMIC
-        #if X_IS_TRINAMIC
+        #if AXIS_IS_TMC(X)
           stepperX.getCurrent(),
         #else
           0,
         #endif
-        #if Y_IS_TRINAMIC
+        #if AXIS_IS_TMC(Y)
           stepperY.getCurrent(),
         #else
           0,
         #endif
-        #if Z_IS_TRINAMIC
+        #if AXIS_IS_TMC(Z)
           stepperZ.getCurrent(),
         #else
           0,
         #endif
-        #if X2_IS_TRINAMIC
+        #if AXIS_IS_TMC(X2)
           stepperX2.getCurrent(),
         #else
           0,
         #endif
-        #if Y2_IS_TRINAMIC
+        #if AXIS_IS_TMC(Y2)
           stepperY2.getCurrent(),
         #else
           0,
         #endif
-        #if Z2_IS_TRINAMIC
+        #if AXIS_IS_TMC(Z2)
           stepperZ2.getCurrent(),
         #else
           0,
         #endif
-        #if E0_IS_TRINAMIC
+        #if AXIS_IS_TMC(E0)
           stepperE0.getCurrent(),
         #else
           0,
         #endif
-        #if E1_IS_TRINAMIC
+        #if AXIS_IS_TMC(E1)
           stepperE1.getCurrent(),
         #else
           0,
         #endif
-        #if E2_IS_TRINAMIC
+        #if AXIS_IS_TMC(E2)
           stepperE2.getCurrent(),
         #else
           0,
         #endif
-        #if E3_IS_TRINAMIC
+        #if AXIS_IS_TMC(E3)
           stepperE3.getCurrent(),
         #else
           0,
         #endif
-        #if E4_IS_TRINAMIC
+        #if AXIS_IS_TMC(E4)
           stepperE4.getCurrent()
         #else
           0
@@ -750,57 +750,57 @@ void MarlinSettings::postprocess() {
 
     uint32_t tmc_hybrid_threshold[TMC_AXES] = {
       #if ENABLED(HYBRID_THRESHOLD)
-        #if X_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(X)
           TMC_GET_PWMTHRS(X, X),
         #else
           X_HYBRID_THRESHOLD,
         #endif
-        #if Y_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(Y)
           TMC_GET_PWMTHRS(Y, Y),
         #else
           Y_HYBRID_THRESHOLD,
         #endif
-        #if Z_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(Z)
           TMC_GET_PWMTHRS(Z, Z),
         #else
           Z_HYBRID_THRESHOLD,
         #endif
-        #if X2_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(X2)
           TMC_GET_PWMTHRS(X, X2),
         #else
           X2_HYBRID_THRESHOLD,
         #endif
-        #if Y2_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(Y2)
           TMC_GET_PWMTHRS(Y, Y2),
         #else
           Y2_HYBRID_THRESHOLD,
         #endif
-        #if Z2_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(Z2)
           TMC_GET_PWMTHRS(Z, Z2),
         #else
           Z2_HYBRID_THRESHOLD,
         #endif
-        #if E0_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(E0)
           TMC_GET_PWMTHRS(E, E0),
         #else
           E0_HYBRID_THRESHOLD,
         #endif
-        #if E1_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(E1)
           TMC_GET_PWMTHRS(E, E1),
         #else
           E1_HYBRID_THRESHOLD,
         #endif
-        #if E2_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(E2)
           TMC_GET_PWMTHRS(E, E2),
         #else
           E2_HYBRID_THRESHOLD,
         #endif
-        #if E3_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(E3)
           TMC_GET_PWMTHRS(E, E3),
         #else
           E3_HYBRID_THRESHOLD,
         #endif
-        #if E4_IS_TRINAMIC
+        #if AXIS_HAS_STEALTHCHOP(E4)
           TMC_GET_PWMTHRS(E, E4)
         #else
           E4_HYBRID_THRESHOLD
@@ -818,17 +818,17 @@ void MarlinSettings::postprocess() {
     //
     int16_t tmc_sgt[XYZ] = {
       #if ENABLED(SENSORLESS_HOMING)
-        #if defined(X_HOMING_SENSITIVITY) && (ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS))
+        #if X_SENSORLESS
           stepperX.sgt(),
         #else
           0,
         #endif
-        #if defined(Y_HOMING_SENSITIVITY) && (ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS))
+        #if Y_SENSORLESS
           stepperY.sgt(),
         #else
           0,
         #endif
-        #if defined(Z_HOMING_SENSITIVITY) && (ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS))
+        #if Z_SENSORLESS
           stepperZ.sgt()
         #else
           0
@@ -1311,37 +1311,37 @@ void MarlinSettings::postprocess() {
         uint16_t currents[TMC_AXES];
         EEPROM_READ(currents);
         if (!validating) {
-          #if X_IS_TRINAMIC
+          #if AXIS_IS_TMC(X)
             SET_CURR(X);
           #endif
-          #if Y_IS_TRINAMIC
+          #if AXIS_IS_TMC(Y)
             SET_CURR(Y);
           #endif
-          #if Z_IS_TRINAMIC
+          #if AXIS_IS_TMC(Z)
             SET_CURR(Z);
           #endif
-          #if X2_IS_TRINAMIC
+          #if AXIS_IS_TMC(X2)
             SET_CURR(X2);
           #endif
-          #if Y2_IS_TRINAMIC
+          #if AXIS_IS_TMC(Y2)
             SET_CURR(Y2);
           #endif
-          #if Z2_IS_TRINAMIC
+          #if AXIS_IS_TMC(Z2)
             SET_CURR(Z2);
           #endif
-          #if E0_IS_TRINAMIC
+          #if AXIS_IS_TMC(E0)
             SET_CURR(E0);
           #endif
-          #if E1_IS_TRINAMIC
+          #if AXIS_IS_TMC(E1)
             SET_CURR(E1);
           #endif
-          #if E2_IS_TRINAMIC
+          #if AXIS_IS_TMC(E2)
             SET_CURR(E2);
           #endif
-          #if E3_IS_TRINAMIC
+          #if AXIS_IS_TMC(E3)
             SET_CURR(E3);
           #endif
-          #if E4_IS_TRINAMIC
+          #if AXIS_IS_TMC(E4)
             SET_CURR(E4);
           #endif
         }
@@ -1355,37 +1355,37 @@ void MarlinSettings::postprocess() {
         uint32_t tmc_hybrid_threshold[TMC_AXES];
         EEPROM_READ(tmc_hybrid_threshold);
         if (!validating) {
-          #if X_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(X)
             TMC_SET_PWMTHRS(X, X);
           #endif
-          #if Y_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(Y)
             TMC_SET_PWMTHRS(Y, Y);
           #endif
-          #if Z_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(Z)
             TMC_SET_PWMTHRS(Z, Z);
           #endif
-          #if X2_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(X2)
             TMC_SET_PWMTHRS(X, X2);
           #endif
-          #if Y2_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(Y2)
             TMC_SET_PWMTHRS(Y, Y2);
           #endif
-          #if Z2_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(Z2)
             TMC_SET_PWMTHRS(Z, Z2);
           #endif
-          #if E0_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(E0)
             TMC_SET_PWMTHRS(E, E0);
           #endif
-          #if E1_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(E1)
             TMC_SET_PWMTHRS(E, E1);
           #endif
-          #if E2_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(E2)
             TMC_SET_PWMTHRS(E, E2);
           #endif
-          #if E3_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(E3)
             TMC_SET_PWMTHRS(E, E3);
           #endif
-          #if E4_IS_TRINAMIC
+          #if AXIS_HAS_STEALTHCHOP(E4)
             TMC_SET_PWMTHRS(E, E4);
           #endif
         }
@@ -1405,26 +1405,26 @@ void MarlinSettings::postprocess() {
       #if ENABLED(SENSORLESS_HOMING)
         if (!validating) {
           #ifdef X_HOMING_SENSITIVITY
-            #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
+            #if AXIS_HAS_STALLGUARD(X)
               stepperX.sgt(tmc_sgt[0]);
             #endif
-            #if ENABLED(X2_IS_TMC2130)
+            #if AXIS_HAS_STALLGUARD(X2)
               stepperX2.sgt(tmc_sgt[0]);
             #endif
           #endif
           #ifdef Y_HOMING_SENSITIVITY
-            #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
+            #if AXIS_HAS_STALLGUARD(Y)
               stepperY.sgt(tmc_sgt[1]);
             #endif
-            #if ENABLED(Y2_IS_TMC2130)
+            #if AXIS_HAS_STALLGUARD(Y2)
               stepperY2.sgt(tmc_sgt[1]);
             #endif
           #endif
           #ifdef Z_HOMING_SENSITIVITY
-            #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
+            #if AXIS_HAS_STALLGUARD(Z)
               stepperZ.sgt(tmc_sgt[2]);
             #endif
-            #if ENABLED(Z2_IS_TMC2130)
+            #if AXIS_HAS_STALLGUARD(Z2)
               stepperZ2.sgt(tmc_sgt[2]);
             #endif
           #endif
@@ -2445,61 +2445,61 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_TRINAMIC
 
       /**
-       * TMC2130 / TMC2208 / TRAMS stepper driver current
+       * TMC2130 / TMC2208 stepper driver current
        */
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
-      #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         say_M906(PORTVAR_SOLO);
       #endif
-      #if X_IS_TRINAMIC
+      #if AXIS_IS_TMC(X)
         SERIAL_ECHOPAIR_P(port, " X", stepperX.getCurrent());
       #endif
-      #if Y_IS_TRINAMIC
+      #if AXIS_IS_TMC(Y)
         SERIAL_ECHOPAIR_P(port, " Y", stepperY.getCurrent());
       #endif
-      #if Z_IS_TRINAMIC
+      #if AXIS_IS_TMC(Z)
         SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getCurrent());
       #endif
-      #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
         SERIAL_EOL_P(port);
       #endif
-      #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOPGM_P(port, " I1");
       #endif
-      #if X2_IS_TRINAMIC
+      #if AXIS_IS_TMC(X2)
         SERIAL_ECHOPAIR_P(port, " X", stepperX2.getCurrent());
       #endif
-      #if Y2_IS_TRINAMIC
+      #if AXIS_IS_TMC(Y2)
         SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getCurrent());
       #endif
-      #if Z2_IS_TRINAMIC
+      #if AXIS_IS_TMC(Z2)
         SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getCurrent());
       #endif
-      #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
         SERIAL_EOL_P(port);
       #endif
-      #if E0_IS_TRINAMIC
+      #if AXIS_IS_TMC(E0)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getCurrent());
       #endif
-      #if E_STEPPERS > 1 && E1_IS_TRINAMIC
+      #if E_STEPPERS > 1 && AXIS_IS_TMC(E1)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getCurrent());
       #endif
-      #if E_STEPPERS > 2 && E2_IS_TRINAMIC
+      #if E_STEPPERS > 2 && AXIS_IS_TMC(E2)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getCurrent());
       #endif
-      #if E_STEPPERS > 3 && E3_IS_TRINAMIC
+      #if E_STEPPERS > 3 && AXIS_IS_TMC(E3)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getCurrent());
       #endif
-      #if E_STEPPERS > 4 && E4_IS_TRINAMIC
+      #if E_STEPPERS > 4 && AXIS_IS_TMC(E4)
         say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getCurrent());
       #endif
@@ -2514,54 +2514,54 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
         }
         CONFIG_ECHO_START;
-        #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+        #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
           say_M913(PORTVAR_SOLO);
         #endif
-        #if X_IS_TRINAMIC
+        #if AXIS_IS_TMC(X)
           SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
         #endif
-        #if Y_IS_TRINAMIC
+        #if AXIS_IS_TMC(Y)
           SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
         #endif
-        #if Z_IS_TRINAMIC
+        #if AXIS_IS_TMC(Z)
           SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
         #endif
-        #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+        #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
           SERIAL_EOL_P(port);
         #endif
-        #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+        #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I1");
         #endif
-        #if X2_IS_TRINAMIC
+        #if AXIS_IS_TMC(X2)
           SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
         #endif
-        #if Y2_IS_TRINAMIC
+        #if AXIS_IS_TMC(Y2)
           SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
         #endif
-        #if Z2_IS_TRINAMIC
+        #if AXIS_IS_TMC(Z2)
           SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
         #endif
-        #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+        #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
           SERIAL_EOL_P(port);
         #endif
-        #if E0_IS_TRINAMIC
+        #if AXIS_IS_TMC(E0)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
         #endif
-        #if E_STEPPERS > 1 && E1_IS_TRINAMIC
+        #if E_STEPPERS > 1 && AXIS_IS_TMC(E1)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T1 E", TMC_GET_PWMTHRS(E, E1));
         #endif
-        #if E_STEPPERS > 2 && E2_IS_TRINAMIC
+        #if E_STEPPERS > 2 && AXIS_IS_TMC(E2)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T2 E", TMC_GET_PWMTHRS(E, E2));
         #endif
-        #if E_STEPPERS > 3 && E3_IS_TRINAMIC
+        #if E_STEPPERS > 3 && AXIS_IS_TMC(E3)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T3 E", TMC_GET_PWMTHRS(E, E3));
         #endif
-        #if E_STEPPERS > 4 && E4_IS_TRINAMIC
+        #if E_STEPPERS > 4 && AXIS_IS_TMC(E4)
           say_M913(PORTVAR_SOLO);
           SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
@@ -2577,26 +2577,23 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
         }
         CONFIG_ECHO_START;
-        #define HAS_X_SENSORLESS (defined(X_HOMING_SENSITIVITY) && (ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)))
-        #define HAS_Y_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && (ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)))
-        #define HAS_Z_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && (ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)))
-        #if HAS_X_SENSORLESS || HAS_Y_SENSORLESS || HAS_Z_SENSORLESS
+        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           say_M914(PORTVAR_SOLO);
-          #if HAS_X_SENSORLESS
+          #if X_SENSORLESS
             SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
           #endif
-          #if HAS_Y_SENSORLESS
+          #if Y_SENSORLESS
             SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
           #endif
-          #if HAS_Z_SENSORLESS
+          #if Z_SENSORLESS
             SERIAL_ECHOPAIR_P(port, " Z", stepperZ.sgt());
           #endif
           SERIAL_EOL_P(port);
         #endif
 
-        #define HAS_X2_SENSORLESS (defined(X_HOMING_SENSITIVITY) && ENABLED(X2_IS_TMC2130))
-        #define HAS_Y2_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && ENABLED(Y2_IS_TMC2130))
-        #define HAS_Z2_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && ENABLED(Z2_IS_TMC2130))
+        #define HAS_X2_SENSORLESS (defined(X_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(X2))
+        #define HAS_Y2_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Y2))
+        #define HAS_Z2_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && AXIS_HAS_STALLGUARD(Z2))
         #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
           say_M914(PORTVAR_SOLO);
           SERIAL_ECHOPGM_P(port, " I1");

commit 71df1f7f5724d2f18865969fc7c2dc1625b391f2
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jul 17 17:19:52 2018 -0500

    Don't display M421 information for UBL at startup
    
    It takes too long to display the mesh data for large mesh's at startup.   We should consider ways to speed this up.
    Perhaps it makes sense to display an entire row of the mesh instead of just one mesh point?

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 52c64330c6..f9fdbd3800 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2237,8 +2237,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, " meshes.\n");
         }
 
-        ubl.report_current_mesh(PORTVAR_SOLO);
-
+//      ubl.report_current_mesh(PORTVAR_SOLO);   // This is too verbose for large mesh's.   A better (more terse)
+                                                 // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {

commit 63f4c9bdb923d8ec4d11f9b261ebed88d192274a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 6 20:41:08 2018 -0500

    Followup to float maths patch

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 14bfafa802..52c64330c6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -384,7 +384,7 @@ void MarlinSettings::postprocess() {
    * M500 - Store Configuration
    */
   bool MarlinSettings::save(PORTARG_SOLO) {
-    float dummy = 0.0f;
+    float dummy = 0;
     char ver[4] = "ERR";
 
     uint16_t working_crc = 0;
@@ -466,7 +466,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(mesh_num_y);
       EEPROM_WRITE(mbl.z_values);
     #else // For disabled MBL write a default mesh
-      dummy = 0.0f;
+      dummy = 0;
       const uint8_t mesh_num_x = 3, mesh_num_y = 3;
       EEPROM_WRITE(dummy); // z_offset
       EEPROM_WRITE(mesh_num_x);
@@ -488,7 +488,7 @@ void MarlinSettings::postprocess() {
     #if ABL_PLANAR
       EEPROM_WRITE(planner.bed_level_matrix);
     #else
-      dummy = 0.0f;
+      dummy = 0;
       for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
     #endif
 
@@ -512,7 +512,7 @@ void MarlinSettings::postprocess() {
       // For disabled Bilinear Grid write an empty 3x3 grid
       const uint8_t grid_max_x = 3, grid_max_y = 3;
       const int bilinear_start[2] = { 0 }, bilinear_grid_spacing[2] = { 0 };
-      dummy = 0.0f;
+      dummy = 0;
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       EEPROM_WRITE(bilinear_grid_spacing);
@@ -550,7 +550,7 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(x_endstop_adj);
 
       // Write dual endstops in X, Y, Z order. Unused = 0.0
-      dummy = 0.0f;
+      dummy = 0;
       #if ENABLED(X_DUAL_ENDSTOPS)
         EEPROM_WRITE(endstops.x_endstop_adj);   // 1 float
       #else
@@ -602,7 +602,7 @@ void MarlinSettings::postprocess() {
         {
           dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
           EEPROM_WRITE(dummy); // Kp
-          dummy = 0.0f;
+          dummy = 0;
           for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
         }
 
@@ -848,7 +848,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(LIN_ADVANCE)
       EEPROM_WRITE(planner.extruder_advance_K);
     #else
-      dummy = 0.0f;
+      dummy = 0;
       EEPROM_WRITE(dummy);
     #endif
 
@@ -870,7 +870,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
       EEPROM_WRITE(gcode.coordinate_system); // 27 floats
     #else
-      dummy = 0.0f;
+      dummy = 0;
       for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_WRITE(dummy);
     #endif
 
@@ -885,7 +885,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(planner.xz_skew_factor);
       EEPROM_WRITE(planner.yz_skew_factor);
     #else
-      dummy = 0.0f;
+      dummy = 0;
       for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
     #endif
 
@@ -905,7 +905,7 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(dummy);
       }
     #else
-      dummy = 0.0f;
+      dummy = 0;
       for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
     #endif
 
@@ -974,7 +974,7 @@ void MarlinSettings::postprocess() {
       eeprom_error = true;
     }
     else {
-      float dummy = 0.0f;
+      float dummy = 0;
       #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || ENABLED(NO_VOLUMETRICS)
         bool dummyb;
       #endif

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d58382de83..14bfafa802 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -417,12 +417,12 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
 
     #if ENABLED(JUNCTION_DEVIATION)
-      const float planner_max_jerk[] = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+      const float planner_max_jerk[] = { float(DEFAULT_XJERK), float(DEFAULT_YJERK), float(DEFAULT_ZJERK), float(DEFAULT_EJERK) };
       EEPROM_WRITE(planner_max_jerk);
       EEPROM_WRITE(planner.junction_deviation_mm);
     #else
       EEPROM_WRITE(planner.max_jerk);
-      dummy = 0.02;
+      dummy = 0.02f;
       EEPROM_WRITE(dummy);
     #endif
 
@@ -488,7 +488,7 @@ void MarlinSettings::postprocess() {
     #if ABL_PLANAR
       EEPROM_WRITE(planner.bed_level_matrix);
     #else
-      dummy = 0.0;
+      dummy = 0.0f;
       for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
     #endif
 
@@ -974,7 +974,7 @@ void MarlinSettings::postprocess() {
       eeprom_error = true;
     }
     else {
-      float dummy = 0;
+      float dummy = 0.0f;
       #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || ENABLED(NO_VOLUMETRICS)
         bool dummyb;
       #endif
@@ -1733,7 +1733,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
 
   #if ENABLED(JUNCTION_DEVIATION)
-    planner.junction_deviation_mm = JUNCTION_DEVIATION_MM;
+    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #else
     planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
     planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
@@ -1835,7 +1835,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       HOTEND_LOOP()
     #endif
     {
-      PID_PARAM(Kp, e) = DEFAULT_Kp;
+      PID_PARAM(Kp, e) = float(DEFAULT_Kp);
       PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);
       PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);
       #if ENABLED(PID_EXTRUSION_SCALING)

commit 3b3029c4bfd785c19f791493fbea68fe312abf9a
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 27 03:38:31 2018 +0100

    Make max_e_jerk an array to reduce CPU usage (#11118)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 544f3b3c8f..d58382de83 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -331,7 +331,7 @@ void MarlinSettings::postprocess() {
   #endif
 
   #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
-    planner.recalculate_max_e_jerk_factor();
+    planner.recalculate_max_e_jerk();
   #endif
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm

commit 8d8f257384354fa6bfc0e4815fe2ad865acc566a
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Tue Jun 26 20:37:52 2018 +0200

    [2.0.x] Fix advanced pause init values (#11095)
    
    Fixed for cycle used to initialize default values

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 34af1f42f3..544f3b3c8f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1904,7 +1904,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    for (uint8_t e = 0; e < E_STEPPERS; e++) {
+    for (uint8_t e = 0; e < EXTRUDERS; e++) {
       filament_change_unload_length[e] = FILAMENT_CHANGE_UNLOAD_LENGTH;
       filament_change_load_length[e] = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }

commit da94e0bd27f4c434ccd861ac3ab12aa9ef46bfbd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 15 15:51:45 2018 -0500

    Unsigned eeprom mesh addresses

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0a6e60b5d3..34af1f42f3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1607,7 +1607,7 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
-    int16_t MarlinSettings::meshes_start_index() {
+    uint16_t MarlinSettings::meshes_start_index() {
       return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
                                                           // or down a little bit without disrupting the mesh data
     }

commit 9d04f47d9809a22f2ed41cb8cc093ce68e5f5753
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 18:49:08 2018 -0500

    Improvements for junction_deviation_mm
    
    - Drop `max_jerk` with `JUNCTION_DEVIATION`
    - Add `max_e_jerk_factor` for use by `LIN_ADVANCE`
    - Recalculate `max_e_jerk_factor` when `junction_deviation_mm` changes
    - Fix LCD editing of `junction_deviation_mm`

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3dbf3fa757..0a6e60b5d3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -330,6 +330,10 @@ void MarlinSettings::postprocess() {
     fwretract.refresh_autoretract();
   #endif
 
+  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+    planner.recalculate_max_e_jerk_factor();
+  #endif
+
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
@@ -411,11 +415,13 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(planner.travel_acceleration);
     EEPROM_WRITE(planner.min_feedrate_mm_s);
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
-    EEPROM_WRITE(planner.max_jerk);
 
     #if ENABLED(JUNCTION_DEVIATION)
+      const float planner_max_jerk[] = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+      EEPROM_WRITE(planner_max_jerk);
       EEPROM_WRITE(planner.junction_deviation_mm);
     #else
+      EEPROM_WRITE(planner.max_jerk);
       dummy = 0.02;
       EEPROM_WRITE(dummy);
     #endif
@@ -1008,11 +1014,12 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(planner.travel_acceleration);
       EEPROM_READ(planner.min_feedrate_mm_s);
       EEPROM_READ(planner.min_travel_feedrate_mm_s);
-      EEPROM_READ(planner.max_jerk);
 
       #if ENABLED(JUNCTION_DEVIATION)
+        for (uint8_t q = 4; q--;) EEPROM_READ(dummy);
         EEPROM_READ(planner.junction_deviation_mm);
       #else
+        EEPROM_READ(planner.max_jerk);
         EEPROM_READ(dummy);
       #endif
 
@@ -1724,13 +1731,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
-  planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
-  planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
-  planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
-  planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
 
   #if ENABLED(JUNCTION_DEVIATION)
     planner.junction_deviation_mm = JUNCTION_DEVIATION_MM;
+  #else
+    planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
+    planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
+    planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
+    planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
   #endif
 
   #if HAS_HOME_OFFSET
@@ -2135,8 +2143,6 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
       SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
-    #endif
-    #if DISABLED(JUNCTION_DEVIATION) || ENABLED(LIN_ADVANCE)
       SERIAL_ECHOPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
     #endif
 

commit a2f521d34b7a500bcaea996e1f386b57ff40d2f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 10 18:02:54 2018 -0500

    Add Junction Deviation mm runtime setting (#10990)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 8b06f76acb..3dbf3fa757 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V54"
+#define EEPROM_VERSION "V55"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -112,16 +112,17 @@ typedef struct SettingsDataStruct {
   //
   uint8_t   esteppers;                                  // XYZE_N - XYZ
 
+  uint32_t  planner_max_acceleration_mm_per_s2[XYZE_N], // M201 XYZE  planner.max_acceleration_mm_per_s2[XYZE_N]
+            planner_min_segment_time_us;                // M205 B     planner.min_segment_time_us
   float     planner_axis_steps_per_mm[XYZE_N],          // M92 XYZE   planner.axis_steps_per_mm[XYZE_N]
-            planner_max_feedrate_mm_s[XYZE_N];          // M203 XYZE  planner.max_feedrate_mm_s[XYZE_N]
-  uint32_t  planner_max_acceleration_mm_per_s2[XYZE_N]; // M201 XYZE  planner.max_acceleration_mm_per_s2[XYZE_N]
-  float     planner_acceleration,                       // M204 P     planner.acceleration
+            planner_max_feedrate_mm_s[XYZE_N],          // M203 XYZE  planner.max_feedrate_mm_s[XYZE_N]
+            planner_acceleration,                       // M204 P     planner.acceleration
             planner_retract_acceleration,               // M204 R     planner.retract_acceleration
             planner_travel_acceleration,                // M204 T     planner.travel_acceleration
             planner_min_feedrate_mm_s,                  // M205 S     planner.min_feedrate_mm_s
-            planner_min_travel_feedrate_mm_s;           // M205 T     planner.min_travel_feedrate_mm_s
-  uint32_t  planner_min_segment_time_us;                // M205 B     planner.min_segment_time_us
-  float     planner_max_jerk[XYZE];                     // M205 XYZE  planner.max_jerk[XYZE]
+            planner_min_travel_feedrate_mm_s,           // M205 T     planner.min_travel_feedrate_mm_s
+            planner_max_jerk[XYZE],                     // M205 XYZE  planner.max_jerk[XYZE]
+            planner_junction_deviation_mm;              // M205 J     planner.junction_deviation_mm
 
   float home_offset[XYZ];                               // M206 XYZ
 
@@ -401,18 +402,24 @@ void MarlinSettings::postprocess() {
     const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
 
+    EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
+    EEPROM_WRITE(planner.min_segment_time_us);
     EEPROM_WRITE(planner.axis_steps_per_mm);
     EEPROM_WRITE(planner.max_feedrate_mm_s);
-    EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
-
     EEPROM_WRITE(planner.acceleration);
     EEPROM_WRITE(planner.retract_acceleration);
     EEPROM_WRITE(planner.travel_acceleration);
     EEPROM_WRITE(planner.min_feedrate_mm_s);
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
-    EEPROM_WRITE(planner.min_segment_time_us);
     EEPROM_WRITE(planner.max_jerk);
 
+    #if ENABLED(JUNCTION_DEVIATION)
+      EEPROM_WRITE(planner.junction_deviation_mm);
+    #else
+      dummy = 0.02;
+      EEPROM_WRITE(dummy);
+    #endif
+
     _FIELD_TEST(home_offset);
 
     #if !HAS_HOME_OFFSET
@@ -980,17 +987,20 @@ void MarlinSettings::postprocess() {
 
       // Get only the number of E stepper parameters previously stored
       // Any steppers added later are set to their defaults
-      const float def1[] = DEFAULT_AXIS_STEPS_PER_UNIT, def2[] = DEFAULT_MAX_FEEDRATE;
-      const uint32_t def3[] = DEFAULT_MAX_ACCELERATION;
-      float tmp1[XYZ + esteppers], tmp2[XYZ + esteppers];
-      uint32_t tmp3[XYZ + esteppers];
-      EEPROM_READ(tmp1);
-      EEPROM_READ(tmp2);
-      EEPROM_READ(tmp3);
+      const uint32_t def1[] = DEFAULT_MAX_ACCELERATION;
+      const float def2[] = DEFAULT_AXIS_STEPS_PER_UNIT, def3[] = DEFAULT_MAX_FEEDRATE;
+
+      uint32_t tmp1[XYZ + esteppers];
+      EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
+      EEPROM_READ(planner.min_segment_time_us);
+
+      float tmp2[XYZ + esteppers], tmp3[XYZ + esteppers];
+      EEPROM_READ(tmp2);                         // axis_steps_per_mm
+      EEPROM_READ(tmp3);                         // max_feedrate_mm_s
       if (!validating) LOOP_XYZE_N(i) {
-        planner.axis_steps_per_mm[i]          = i < XYZ + esteppers ? tmp1[i] : def1[i < COUNT(def1) ? i : COUNT(def1) - 1];
-        planner.max_feedrate_mm_s[i]          = i < XYZ + esteppers ? tmp2[i] : def2[i < COUNT(def2) ? i : COUNT(def2) - 1];
-        planner.max_acceleration_mm_per_s2[i] = i < XYZ + esteppers ? tmp3[i] : def3[i < COUNT(def3) ? i : COUNT(def3) - 1];
+        planner.max_acceleration_mm_per_s2[i] = i < XYZ + esteppers ? tmp1[i] : def1[i < COUNT(def1) ? i : COUNT(def1) - 1];
+        planner.axis_steps_per_mm[i]          = i < XYZ + esteppers ? tmp2[i] : def2[i < COUNT(def2) ? i : COUNT(def2) - 1];
+        planner.max_feedrate_mm_s[i]          = i < XYZ + esteppers ? tmp3[i] : def3[i < COUNT(def3) ? i : COUNT(def3) - 1];
       }
 
       EEPROM_READ(planner.acceleration);
@@ -998,9 +1008,14 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(planner.travel_acceleration);
       EEPROM_READ(planner.min_feedrate_mm_s);
       EEPROM_READ(planner.min_travel_feedrate_mm_s);
-      EEPROM_READ(planner.min_segment_time_us);
       EEPROM_READ(planner.max_jerk);
 
+      #if ENABLED(JUNCTION_DEVIATION)
+        EEPROM_READ(planner.junction_deviation_mm);
+      #else
+        EEPROM_READ(dummy);
+      #endif
+
       //
       // Home Offset (M206)
       //
@@ -1518,9 +1533,9 @@ void MarlinSettings::postprocess() {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
-            ubl.report_state();
+          ubl.report_state();
 
-            if (!ubl.sanity_check()) {
+          if (!ubl.sanity_check()) {
             SERIAL_EOL_P(port);
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();
@@ -1703,17 +1718,21 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     planner.max_acceleration_mm_per_s2[i] = pgm_read_dword_near(&tmp3[i < COUNT(tmp3) ? i : COUNT(tmp3) - 1]);
   }
 
+  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.acceleration = DEFAULT_ACCELERATION;
   planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
-  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
   planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
   planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
   planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
 
+  #if ENABLED(JUNCTION_DEVIATION)
+    planner.junction_deviation_mm = JUNCTION_DEVIATION_MM;
+  #endif
+
   #if HAS_HOME_OFFSET
     ZERO(home_offset);
   #endif
@@ -2094,16 +2113,34 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM_P(port, "Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_us> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
+      SERIAL_ECHOPGM_P(port, "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>");
+      #if ENABLED(JUNCTION_DEVIATION)
+        SERIAL_ECHOPGM_P(port, " J<junc_dev>");
+      #else
+        SERIAL_ECHOPGM_P(port, " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>");
+      #endif
+      #if DISABLED(JUNCTION_DEVIATION) || ENABLED(LIN_ADVANCE)
+        SERIAL_ECHOPGM_P(port, " E<max_e_jerk>");
+      #endif
+      SERIAL_EOL_P(port);
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR_P(port, "  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
+    SERIAL_ECHOPAIR_P(port, "  M205 B", LINEAR_UNIT(planner.min_segment_time_us));
+    SERIAL_ECHOPAIR_P(port, " S", LINEAR_UNIT(planner.min_feedrate_mm_s));
     SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
-    SERIAL_ECHOPAIR_P(port, " B", planner.min_segment_time_us);
-    SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
-    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
-    SERIAL_ECHOLNPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+
+    #if ENABLED(JUNCTION_DEVIATION)
+      SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.junction_deviation_mm));
+    #else
+      SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
+    #endif
+    #if DISABLED(JUNCTION_DEVIATION) || ENABLED(LIN_ADVANCE)
+      SERIAL_ECHOPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+    #endif
+
+    SERIAL_EOL_P(port);
 
     #if HAS_M206_COMMAND
       if (!forReplay) {

commit 55aedf036ba376821d369e75c98bfbbb10b3a7ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 7 16:36:50 2018 -0500

    Fix M503 ABL mesh report. (Zero-based IJ indices)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 65f9834c38..8b06f76acb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2202,8 +2202,8 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
               CONFIG_ECHO_START;
-              SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px + 1);
-              SERIAL_ECHOPAIR_P(port, " J", (int)py + 1);
+              SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px);
+              SERIAL_ECHOPAIR_P(port, " J", (int)py);
               SERIAL_ECHOPGM_P(port, " Z");
               SERIAL_ECHO_F_P(port, LINEAR_UNIT(z_values[px][py]), 5);
               SERIAL_EOL_P(port);

commit d8b983f6246cf0be0fa8341800f0e1df31f7175e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 6 20:58:28 2018 -0500

    More concise M503 output for M906, M913, M914 (#10947)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a5f791bbb4..65f9834c38 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1896,12 +1896,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
   #if HAS_TRINAMIC
-    void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906 "); }
+    void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906"); }
     #if ENABLED(HYBRID_THRESHOLD)
-      void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913 "); }
+      void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913"); }
     #endif
     #if ENABLED(SENSORLESS_HOMING)
-      void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914 "); }
+      void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914"); }
     #endif
   #endif
 
@@ -2409,49 +2409,56 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
-      #if X_IS_TRINAMIC
+      #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "X", stepperX.getCurrent());
       #endif
-      #if X2_IS_TRINAMIC
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.getCurrent());
+      #if X_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", stepperX.getCurrent());
       #endif
       #if Y_IS_TRINAMIC
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.getCurrent());
-      #endif
-      #if Y2_IS_TRINAMIC
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getCurrent());
       #endif
       #if Z_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getCurrent());
+      #endif
+      #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+        SERIAL_EOL_P(port);
+      #endif
+      #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.getCurrent());
+        SERIAL_ECHOPGM_P(port, " I1");
+      #endif
+      #if X2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getCurrent());
+      #endif
+      #if Y2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getCurrent());
       #endif
       #if Z2_IS_TRINAMIC
-        say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getCurrent());
+      #endif
+      #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+        SERIAL_EOL_P(port);
       #endif
       #if E0_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T0 E", stepperE0.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T0 E", stepperE0.getCurrent());
       #endif
       #if E_STEPPERS > 1 && E1_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T1 E", stepperE1.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T1 E", stepperE1.getCurrent());
       #endif
       #if E_STEPPERS > 2 && E2_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T2 E", stepperE2.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T2 E", stepperE2.getCurrent());
       #endif
       #if E_STEPPERS > 3 && E3_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T3 E", stepperE3.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T3 E", stepperE3.getCurrent());
       #endif
       #if E_STEPPERS > 4 && E4_IS_TRINAMIC
         say_M906(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T4 E", stepperE4.getCurrent());
+        SERIAL_ECHOLNPAIR_P(port, " T4 E", stepperE4.getCurrent());
       #endif
       SERIAL_EOL_P(port);
 
@@ -2464,49 +2471,56 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
         }
         CONFIG_ECHO_START;
-        #if X_IS_TRINAMIC
+        #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "X", TMC_GET_PWMTHRS(X, X));
         #endif
-        #if X2_IS_TRINAMIC
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "I1 X", TMC_GET_PWMTHRS(X, X2));
+        #if X_IS_TRINAMIC
+          SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
         #endif
         #if Y_IS_TRINAMIC
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "Y", TMC_GET_PWMTHRS(Y, Y));
-        #endif
-        #if Y2_IS_TRINAMIC
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "I1 Y", TMC_GET_PWMTHRS(Y, Y2));
+          SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
         #endif
         #if Z_IS_TRINAMIC
+          SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
+        #endif
+        #if X_IS_TRINAMIC || Y_IS_TRINAMIC || Z_IS_TRINAMIC
+          SERIAL_EOL_P(port);
+        #endif
+        #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "Z", TMC_GET_PWMTHRS(Z, Z));
+          SERIAL_ECHOPGM_P(port, " I1");
+        #endif
+        #if X2_IS_TRINAMIC
+          SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
+        #endif
+        #if Y2_IS_TRINAMIC
+          SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
         #endif
         #if Z2_IS_TRINAMIC
-          say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "I1 Z", TMC_GET_PWMTHRS(Z, Z2));
+          SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
+        #endif
+        #if X2_IS_TRINAMIC || Y2_IS_TRINAMIC || Z2_IS_TRINAMIC
+          SERIAL_EOL_P(port);
         #endif
         #if E0_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "T0 E", TMC_GET_PWMTHRS(E, E0));
+          SERIAL_ECHOLNPAIR_P(port, " T0 E", TMC_GET_PWMTHRS(E, E0));
         #endif
         #if E_STEPPERS > 1 && E1_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "T1 E", TMC_GET_PWMTHRS(E, E1));
+          SERIAL_ECHOLNPAIR_P(port, " T1 E", TMC_GET_PWMTHRS(E, E1));
         #endif
         #if E_STEPPERS > 2 && E2_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "T2 E", TMC_GET_PWMTHRS(E, E2));
+          SERIAL_ECHOLNPAIR_P(port, " T2 E", TMC_GET_PWMTHRS(E, E2));
         #endif
         #if E_STEPPERS > 3 && E3_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "T3 E", TMC_GET_PWMTHRS(E, E3));
+          SERIAL_ECHOLNPAIR_P(port, " T3 E", TMC_GET_PWMTHRS(E, E3));
         #endif
         #if E_STEPPERS > 4 && E4_IS_TRINAMIC
           say_M913(PORTVAR_SOLO);
-          SERIAL_ECHOLNPAIR_P(port, "T4 E", TMC_GET_PWMTHRS(E, E4));
+          SERIAL_ECHOLNPAIR_P(port, " T4 E", TMC_GET_PWMTHRS(E, E4));
         #endif
         SERIAL_EOL_P(port);
       #endif // HYBRID_THRESHOLD
@@ -2520,38 +2534,42 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
         }
         CONFIG_ECHO_START;
-        #ifdef X_HOMING_SENSITIVITY
-          #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "X", stepperX.sgt());
-          #endif
-          #if ENABLED(X2_IS_TMC2130)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.sgt());
+        #define HAS_X_SENSORLESS (defined(X_HOMING_SENSITIVITY) && (ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)))
+        #define HAS_Y_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && (ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)))
+        #define HAS_Z_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && (ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)))
+        #if HAS_X_SENSORLESS || HAS_Y_SENSORLESS || HAS_Z_SENSORLESS
+          say_M914(PORTVAR_SOLO);
+          #if HAS_X_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
           #endif
-        #endif
-        #ifdef Y_HOMING_SENSITIVITY
-          #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.sgt());
+          #if HAS_Y_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
           #endif
-          #if ENABLED(Y2_IS_TMC2130)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.sgt());
+          #if HAS_Z_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " Z", stepperZ.sgt());
           #endif
+          SERIAL_EOL_P(port);
         #endif
-        #ifdef Z_HOMING_SENSITIVITY
-          #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.sgt());
+
+        #define HAS_X2_SENSORLESS (defined(X_HOMING_SENSITIVITY) && ENABLED(X2_IS_TMC2130))
+        #define HAS_Y2_SENSORLESS (defined(Y_HOMING_SENSITIVITY) && ENABLED(Y2_IS_TMC2130))
+        #define HAS_Z2_SENSORLESS (defined(Z_HOMING_SENSITIVITY) && ENABLED(Z2_IS_TMC2130))
+        #if HAS_X2_SENSORLESS || HAS_Y2_SENSORLESS || HAS_Z2_SENSORLESS
+          say_M914(PORTVAR_SOLO);
+          SERIAL_ECHOPGM_P(port, " I1");
+          #if HAS_X2_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " X", stepperX2.sgt());
           #endif
-          #if ENABLED(Z2_IS_TMC2130)
-            say_M914(PORTVAR_SOLO);
-            SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.sgt());
+          #if HAS_Y2_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " Y", stepperY2.sgt());
           #endif
+          #if HAS_Z2_SENSORLESS
+            SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.sgt());
+          #endif
+          SERIAL_EOL_P(port);
         #endif
-        SERIAL_EOL_P(port);
-      #endif
+
+      #endif // SENSORLESS_HOMING
 
     #endif // HAS_TRINAMIC
 

commit 83d42f33e140680a3328990cc3bf899b7dd84370
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 19 16:37:27 2018 -0500

    Add HAS_HOTEND_OFFSET_Z conditional

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 483775baaf..a5f791bbb4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2126,7 +2126,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
         SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+        #if HAS_HOTEND_OFFSET_Z
           SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
         #endif
         SERIAL_EOL_P(port);

commit 3c76bda2d8d1f198a9e6dcb94aca6e383c9d5392
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Fri May 18 20:16:59 2018 +0200

    Fix switching extruder
    
    `DONT_SWITCH` got lost along the way. Replace it with `DO_SWITCH_EXTRUDER` and adjust the code.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4c7aa664f9..483775baaf 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2126,7 +2126,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
         SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
         SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
-        #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) ||ENABLED(PARKING_EXTRUDER)
+        #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
           SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
         #endif
         SERIAL_EOL_P(port);

commit 08e36e264e72f56bada1f25c1a784d6e3f9d2135
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:44:24 2018 -0500

    Apply _AXIS macro

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a250e2806b..4c7aa664f9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -77,7 +77,7 @@
 #if HAS_TRINAMIC
   #include "stepper_indirection.h"
   #include "../feature/tmc_util.h"
-  #define TMC_GET_PWMTHRS(P,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.axis_steps_per_mm[P##_AXIS])
+  #define TMC_GET_PWMTHRS(A,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.axis_steps_per_mm[_AXIS(A)])
 #endif
 
 #if ENABLED(FWRETRACT)
@@ -1329,7 +1329,7 @@ void MarlinSettings::postprocess() {
       #endif
 
       #if ENABLED(HYBRID_THRESHOLD)
-        #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
+        #define TMC_SET_PWMTHRS(A,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[_AXIS(A)])
         uint32_t tmc_hybrid_threshold[TMC_AXES];
         EEPROM_READ(tmc_hybrid_threshold);
         if (!validating) {

commit 625035a9cefde67da3f9f5933a2ba9e636cef5bb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 02:13:40 2018 -0500

    Fix M301 access to lpq_len (#10714)
    
    Co-Authored-By: Zwaubel

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index b0ac1fc2a0..a250e2806b 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -88,6 +88,10 @@
   #include "../feature/pause.h"
 #endif
 
+#if ENABLED(PID_EXTRUSION_SCALING)
+  #define LPQ_LEN thermalManager.lpq_len
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct PID { float Kp, Ki, Kd; } PID;
@@ -198,7 +202,7 @@ typedef struct SettingsDataStruct {
   //
   PIDC hotendPID[MAX_EXTRUDERS];                        // M301 En PIDC / M303 En U
 
-  int lpq_len;                                          // M301 L
+  int16_t lpq_len;                                      // M301 L
 
   //
   // PIDTEMPBED
@@ -594,9 +598,9 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(lpq_len);
 
     #if DISABLED(PID_EXTRUSION_SCALING)
-      int lpq_len = 20;
+      const int16_t LPQ_LEN = 20;
     #endif
-    EEPROM_WRITE(lpq_len);
+    EEPROM_WRITE(LPQ_LEN);
 
     #if DISABLED(PIDTEMPBED)
       dummy = DUMMY_PID_VALUE;
@@ -1199,9 +1203,9 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(lpq_len);
 
       #if DISABLED(PID_EXTRUSION_SCALING)
-        int lpq_len;
+        int16_t LPQ_LEN;
       #endif
-      EEPROM_READ(lpq_len);
+      EEPROM_READ(LPQ_LEN);
 
       //
       // Heated Bed PID
@@ -1812,7 +1816,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #endif
     }
     #if ENABLED(PID_EXTRUSION_SCALING)
-      lpq_len = 20; // default last-position-queue size
+      thermalManager.lpq_len = 20; // default last-position-queue size
     #endif
   #endif // PIDTEMP
 
@@ -2288,7 +2292,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
               SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, e)));
               #if ENABLED(PID_EXTRUSION_SCALING)
                 SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, e));
-                if (e == 0) SERIAL_ECHOPAIR_P(port, " L", lpq_len);
+                if (e == 0) SERIAL_ECHOPAIR_P(port, " L", thermalManager.lpq_len);
               #endif
               SERIAL_EOL_P(port);
             }
@@ -2303,7 +2307,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, 0)));
           #if ENABLED(PID_EXTRUSION_SCALING)
             SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, 0));
-            SERIAL_ECHOPAIR_P(port, " L", lpq_len);
+            SERIAL_ECHOPAIR_P(port, " L", thermalManager.lpq_len);
           #endif
           SERIAL_EOL_P(port);
         }

commit d99f1b22455e21cd21744baff27f30d7964783a8
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sat May 12 01:06:04 2018 +0200

    [2.0.x] EEPROM code cleanup (#10710)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2cb4c5fdc3..b0ac1fc2a0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -954,7 +954,6 @@ void MarlinSettings::postprocess() {
         SERIAL_ECHOPAIR_P(port, "(EEPROM=", stored_ver);
         SERIAL_ECHOLNPGM_P(port, " Marlin=" EEPROM_VERSION ")");
       #endif
-      if (!validating) reset();
       eeprom_error = true;
     }
     else {
@@ -1511,15 +1510,13 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
-      if (!validating) {
-        if (eeprom_error) reset(); else postprocess();
-      }
+      if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        ubl.report_state();
-
         if (!validating) {
-          if (!ubl.sanity_check()) {
+            ubl.report_state();
+
+            if (!ubl.sanity_check()) {
             SERIAL_EOL_P(port);
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();

commit b76344c080ce0b7f651290dcfeecc6b815fea916
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 10 00:05:15 2018 -0500

    More Trinamic cleanup

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 873ac49d0c..2cb4c5fdc3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1326,7 +1326,7 @@ void MarlinSettings::postprocess() {
       #endif
 
       #if ENABLED(HYBRID_THRESHOLD)
-        #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, TMC_##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
+        #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
         uint32_t tmc_hybrid_threshold[TMC_AXES];
         EEPROM_READ(tmc_hybrid_threshold);
         if (!validating) {

commit 6d9ec1852a05bcc2474a8baddb81594bf345b0de
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 9 00:30:08 2018 -0500

    Fix compilation of say_units
    
    Fixes #10663

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2f200e6c46..873ac49d0c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1909,10 +1909,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   inline void say_units(
-    #if ADD_PORT_ARG
-      PORTARG_SOLO,
+    #if NUM_SERIAL > 1
+      const int8_t port,
     #endif
-    const bool colon=false
+    const bool colon
   ) {
     serialprintPGM_P(port,
       #if ENABLED(INCH_MODE_SUPPORT)
@@ -1922,6 +1922,11 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     );
     if (colon) SERIAL_ECHOLNPGM_P(port, ":");
   }
+  #if NUM_SERIAL > 1
+    #define SAY_UNITS_P(PORT, COLON) say_units(PORT, COLON)
+  #else
+    #define SAY_UNITS_P(PORT, COLON) say_units(COLON)
+  #endif
 
   /**
    * M503 - Report current settings in RAM
@@ -1943,12 +1948,12 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPGM_P(port, "  G2");
       SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
       SERIAL_ECHOPGM_P(port, " ;");
-      say_units(PORTVAR_SOLO);
+      SAY_UNITS_P(port, false);
     #else
       #define LINEAR_UNIT(N) (N)
       #define VOLUMETRIC_UNIT(N) (N)
       SERIAL_ECHOPGM_P(port, "  G21    ; Units in mm");
-      say_units(PORTVAR_SOLO);
+      SAY_UNITS_P(port, false);
     #endif
     SERIAL_EOL_P(port);
 
@@ -2363,12 +2368,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOPGM_P(port, "Z-Probe Offset (mm):");
-        say_units(
-          #if ADD_PORT_ARG
-            port,
-          #endif
-          true
-        );
+        SAY_UNITS_P(port, true);
       }
       CONFIG_ECHO_START;
       SERIAL_ECHOLNPAIR_P(port, "  M851 Z", LINEAR_UNIT(zprobe_zoffset));

commit 55f1f8446bc175bbf9dc425d12776e5dfefce35d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 06:29:53 2018 -0500

    Show correct current units in M503

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index eb774d1539..2f200e6c46 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1908,6 +1908,21 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     void say_M603(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M603 "); }
   #endif
 
+  inline void say_units(
+    #if ADD_PORT_ARG
+      PORTARG_SOLO,
+    #endif
+    const bool colon=false
+  ) {
+    serialprintPGM_P(port,
+      #if ENABLED(INCH_MODE_SUPPORT)
+        parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
+      #endif
+      PSTR(" (mm)")
+    );
+    if (colon) SERIAL_ECHOLNPGM_P(port, ":");
+  }
+
   /**
    * M503 - Report current settings in RAM
    *
@@ -1927,13 +1942,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       #define VOLUMETRIC_UNIT(N) (float(N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
       SERIAL_ECHOPGM_P(port, "  G2");
       SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
-      SERIAL_ECHOPGM_P(port, " ; Units in ");
-      serialprintPGM_P(port, parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
+      SERIAL_ECHOPGM_P(port, " ;");
+      say_units(PORTVAR_SOLO);
     #else
       #define LINEAR_UNIT(N) (N)
       #define VOLUMETRIC_UNIT(N) (N)
-      SERIAL_ECHOLNPGM_P(port, "  G21    ; Units in mm");
+      SERIAL_ECHOPGM_P(port, "  G21    ; Units in mm");
+      say_units(PORTVAR_SOLO);
     #endif
+    SERIAL_EOL_P(port);
 
     #if ENABLED(ULTIPANEL)
 
@@ -2345,7 +2362,13 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #if HAS_BED_PROBE
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Z-Probe Offset (mm):");
+        SERIAL_ECHOPGM_P(port, "Z-Probe Offset (mm):");
+        say_units(
+          #if ADD_PORT_ARG
+            port,
+          #endif
+          true
+        );
       }
       CONFIG_ECHO_START;
       SERIAL_ECHOLNPAIR_P(port, "  M851 Z", LINEAR_UNIT(zprobe_zoffset));

commit 2d9b0a66fe8bbd417f6b1dfef9651667aef383c1
Author: Sean <noingwhat@gmail.com>
Date:   Tue Mar 20 11:19:10 2018 -0700

    Add Filament Change accelerations

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ac64ccf37e..eb774d1539 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1878,7 +1878,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     for (uint8_t e = 0; e < E_STEPPERS; e++) {
       filament_change_unload_length[e] = FILAMENT_CHANGE_UNLOAD_LENGTH;
-      filament_change_load_length[e] = FILAMENT_CHANGE_LOAD_LENGTH;
+      filament_change_load_length[e] = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
   #endif
 

commit 4c79dc109327dff06a34ec569e82dcacc4df1072
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 2 03:11:11 2018 -0500

    Fix a Serial+EEPROM compile error
    
    Fixes #10278

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1934f94dda..ac64ccf37e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1484,9 +1484,11 @@ void MarlinSettings::postprocess() {
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        SERIAL_ECHO_START_P(port);
-        SERIAL_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
-        SERIAL_ECHOLNPAIR_P(port, " Size: ", datasize());
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_ECHO_START_P(port);
+          SERIAL_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
+          SERIAL_ECHOLNPAIR_P(port, " Size: ", datasize());
+        #endif
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;

commit 02f0f95d4014f03f547a87d021d264fa4057d06a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 1 16:58:37 2018 -0500

    Handle disabled HYBRID_THRESHOLD in EEPROM (#10275)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6ba4a9e398..1934f94dda 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -732,7 +732,7 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(tmc_hybrid_threshold);
 
     uint32_t tmc_hybrid_threshold[TMC_AXES] = {
-      #if HAS_TRINAMIC
+      #if ENABLED(HYBRID_THRESHOLD)
         #if X_IS_TRINAMIC
           TMC_GET_PWMTHRS(X, X),
         #else
@@ -1325,7 +1325,7 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
       #endif
 
-      #if HAS_TRINAMIC
+      #if ENABLED(HYBRID_THRESHOLD)
         #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, TMC_##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
         uint32_t tmc_hybrid_threshold[TMC_AXES];
         EEPROM_READ(tmc_hybrid_threshold);
@@ -1894,7 +1894,9 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #if HAS_TRINAMIC
     void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906 "); }
-    void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913 "); }
+    #if ENABLED(HYBRID_THRESHOLD)
+      void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913 "); }
+    #endif
     #if ENABLED(SENSORLESS_HOMING)
       void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914 "); }
     #endif
@@ -2430,56 +2432,58 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       /**
        * TMC2130 / TMC2208 / TRAMS Hybrid Threshold
        */
-      if (!forReplay) {
+      #if ENABLED(HYBRID_THRESHOLD)
+        if (!forReplay) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
+        }
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
-      }
-      CONFIG_ECHO_START;
-      #if X_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "X", TMC_GET_PWMTHRS(X, X));
-      #endif
-      #if X2_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 X", TMC_GET_PWMTHRS(X, X2));
-      #endif
-      #if Y_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "Y", TMC_GET_PWMTHRS(Y, Y));
-      #endif
-      #if Y2_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 Y", TMC_GET_PWMTHRS(Y, Y2));
-      #endif
-      #if Z_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "Z", TMC_GET_PWMTHRS(Z, Z));
-      #endif
-      #if Z2_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "I1 Z", TMC_GET_PWMTHRS(Z, Z2));
-      #endif
-      #if E0_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T0 E", TMC_GET_PWMTHRS(E, E0));
-      #endif
-      #if E_STEPPERS > 1 && E1_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T1 E", TMC_GET_PWMTHRS(E, E1));
-      #endif
-      #if E_STEPPERS > 2 && E2_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T2 E", TMC_GET_PWMTHRS(E, E2));
-      #endif
-      #if E_STEPPERS > 3 && E3_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T3 E", TMC_GET_PWMTHRS(E, E3));
-      #endif
-      #if E_STEPPERS > 4 && E4_IS_TRINAMIC
-        say_M913(PORTVAR_SOLO);
-        SERIAL_ECHOLNPAIR_P(port, "T4 E", TMC_GET_PWMTHRS(E, E4));
-      #endif
-      SERIAL_EOL_P(port);
+        #if X_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "X", TMC_GET_PWMTHRS(X, X));
+        #endif
+        #if X2_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "I1 X", TMC_GET_PWMTHRS(X, X2));
+        #endif
+        #if Y_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "Y", TMC_GET_PWMTHRS(Y, Y));
+        #endif
+        #if Y2_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "I1 Y", TMC_GET_PWMTHRS(Y, Y2));
+        #endif
+        #if Z_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "Z", TMC_GET_PWMTHRS(Z, Z));
+        #endif
+        #if Z2_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "I1 Z", TMC_GET_PWMTHRS(Z, Z2));
+        #endif
+        #if E0_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "T0 E", TMC_GET_PWMTHRS(E, E0));
+        #endif
+        #if E_STEPPERS > 1 && E1_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "T1 E", TMC_GET_PWMTHRS(E, E1));
+        #endif
+        #if E_STEPPERS > 2 && E2_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "T2 E", TMC_GET_PWMTHRS(E, E2));
+        #endif
+        #if E_STEPPERS > 3 && E3_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "T3 E", TMC_GET_PWMTHRS(E, E3));
+        #endif
+        #if E_STEPPERS > 4 && E4_IS_TRINAMIC
+          say_M913(PORTVAR_SOLO);
+          SERIAL_ECHOLNPAIR_P(port, "T4 E", TMC_GET_PWMTHRS(E, E4));
+        #endif
+        SERIAL_EOL_P(port);
+      #endif // HYBRID_THRESHOLD
 
       /**
        * TMC2130 Sensorless homing thresholds

commit 2bc7f416eef66835054265a9ead38ef20fa59ef0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 14:43:46 2018 -0500

    Fix missing comma in tmc_sgt
    
    Fixes #10209

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e99d0768e1..6ba4a9e398 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -809,7 +809,7 @@ void MarlinSettings::postprocess() {
         #if defined(Y_HOMING_SENSITIVITY) && (ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS))
           stepperY.sgt(),
         #else
-          0
+          0,
         #endif
         #if defined(Z_HOMING_SENSITIVITY) && (ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS))
           stepperZ.sgt()

commit 9656a82609c83f9dc2e0f21973a26c13b336f953
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Mar 28 13:14:39 2018 -0500

    Fix G53/CNC_COORDINATE_SYSTEMS compilation, Travis testing (#10227)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 413ce35a23..e99d0768e1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -851,7 +851,7 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(coordinate_system);
 
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
-      EEPROM_WRITE(coordinate_system); // 27 floats
+      EEPROM_WRITE(gcode.coordinate_system); // 27 floats
     #else
       dummy = 0.0f;
       for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_WRITE(dummy);

commit b28756025816bf50a4b096ec572f65b60c967906
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 12:54:58 2018 -0500

    Fix say_M603

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 661783313f..413ce35a23 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1901,7 +1901,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    #define say_M603(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M603 "); }
+    void say_M603(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M603 "); }
   #endif
 
   /**

commit 8870f9b1da947920fad0a8a8b735137cb14769ba
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Mar 23 16:43:43 2018 -0500

    Fix M503 helper functions following TMC updates (#10197)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e654bc56ae..661783313f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1893,15 +1893,15 @@ void MarlinSettings::reset(PORTARG_SOLO) {
   #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
   #if HAS_TRINAMIC
-    void say_M906() { SERIAL_ECHOPGM_P(port, "  M906 "); }
-    void say_M913() { SERIAL_ECHOPGM_P(port, "  M913 "); }
+    void say_M906(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M906 "); }
+    void say_M913(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M913 "); }
     #if ENABLED(SENSORLESS_HOMING)
-      void say_M914() { SERIAL_ECHOPGM_P(port, "  M914 "); }
+      void say_M914(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M914 "); }
     #endif
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    void say_M603() { SERIAL_ECHOPGM_P(port, "  M603 "); }
+    #define say_M603(PORTARG_SOLO) { SERIAL_ECHOPGM_P(port, "  M603 "); }
   #endif
 
   /**
@@ -2382,47 +2382,47 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       }
       CONFIG_ECHO_START;
       #if X_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "X", stepperX.getCurrent());
       #endif
       #if X2_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.getCurrent());
       #endif
       #if Y_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.getCurrent());
       #endif
       #if Y2_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.getCurrent());
       #endif
       #if Z_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.getCurrent());
       #endif
       #if Z2_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.getCurrent());
       #endif
       #if E0_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T0 E", stepperE0.getCurrent());
       #endif
       #if E_STEPPERS > 1 && E1_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T1 E", stepperE1.getCurrent());
       #endif
       #if E_STEPPERS > 2 && E2_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T2 E", stepperE2.getCurrent());
       #endif
       #if E_STEPPERS > 3 && E3_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T3 E", stepperE3.getCurrent());
       #endif
       #if E_STEPPERS > 4 && E4_IS_TRINAMIC
-        say_M906();
+        say_M906(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T4 E", stepperE4.getCurrent());
       #endif
       SERIAL_EOL_P(port);
@@ -2436,47 +2436,47 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       }
       CONFIG_ECHO_START;
       #if X_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "X", TMC_GET_PWMTHRS(X, X));
       #endif
       #if X2_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 X", TMC_GET_PWMTHRS(X, X2));
       #endif
       #if Y_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "Y", TMC_GET_PWMTHRS(Y, Y));
       #endif
       #if Y2_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 Y", TMC_GET_PWMTHRS(Y, Y2));
       #endif
       #if Z_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "Z", TMC_GET_PWMTHRS(Z, Z));
       #endif
       #if Z2_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "I1 Z", TMC_GET_PWMTHRS(Z, Z2));
       #endif
       #if E0_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T0 E", TMC_GET_PWMTHRS(E, E0));
       #endif
       #if E_STEPPERS > 1 && E1_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T1 E", TMC_GET_PWMTHRS(E, E1));
       #endif
       #if E_STEPPERS > 2 && E2_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T2 E", TMC_GET_PWMTHRS(E, E2));
       #endif
       #if E_STEPPERS > 3 && E3_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T3 E", TMC_GET_PWMTHRS(E, E3));
       #endif
       #if E_STEPPERS > 4 && E4_IS_TRINAMIC
-        say_M913();
+        say_M913(PORTVAR_SOLO);
         SERIAL_ECHOLNPAIR_P(port, "T4 E", TMC_GET_PWMTHRS(E, E4));
       #endif
       SERIAL_EOL_P(port);
@@ -2492,31 +2492,31 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         CONFIG_ECHO_START;
         #ifdef X_HOMING_SENSITIVITY
           #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "X", stepperX.sgt());
           #endif
           #if ENABLED(X2_IS_TMC2130)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.sgt());
           #endif
         #endif
         #ifdef Y_HOMING_SENSITIVITY
           #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.sgt());
           #endif
           #if ENABLED(Y2_IS_TMC2130)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.sgt());
           #endif
         #endif
         #ifdef Z_HOMING_SENSITIVITY
           #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.sgt());
           #endif
           #if ENABLED(Z2_IS_TMC2130)
-            say_M914();
+            say_M914(PORTVAR_SOLO);
             SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.sgt());
           #endif
         #endif
@@ -2559,30 +2559,30 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       }
       CONFIG_ECHO_START;
       #if EXTRUDERS == 1
-        say_M603();
+        say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(filament_change_load_length[0]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
       #else
-        say_M603();
+        say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(filament_change_load_length[0]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
         CONFIG_ECHO_START;
-        say_M603();
+        say_M603(PORTVAR_SOLO);
         SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(filament_change_load_length[1]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[1]));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START;
-          say_M603();
+          say_M603(PORTVAR_SOLO);
           SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(filament_change_load_length[2]));
           SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[2]));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START;
-            say_M603();
+            say_M603(PORTVAR_SOLO);
             SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(filament_change_load_length[3]));
             SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[3]));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START;
-              say_M603();
+              say_M603(PORTVAR_SOLO);
               SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(filament_change_load_length[4]));
               SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[4]));
             #endif // EXTRUDERS > 4

commit 9da0797e293252938511a3404346f5e343037980
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 23 02:08:11 2018 -0400

    Fix EEPROM size of tmc_hybrid_threshold
    
    Followup to #10102

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 052ee96e5a..e654bc56ae 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1365,7 +1365,7 @@ void MarlinSettings::postprocess() {
           #endif
         }
       #else
-        uint16_t thrs_val;
+        uint32_t thrs_val;
         for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(thrs_val);
       #endif
 

commit 1628a9e864683e2abcae186b1a272a2de40fdfe6
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Mar 22 19:25:28 2018 -0500

    make data declarations consistent

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f45307106e..052ee96e5a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V53"
+#define EEPROM_VERSION "V54"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -1327,7 +1327,7 @@ void MarlinSettings::postprocess() {
 
       #if HAS_TRINAMIC
         #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, TMC_##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
-        uint16_t tmc_hybrid_threshold[TMC_AXES];
+        uint32_t tmc_hybrid_threshold[TMC_AXES];
         EEPROM_READ(tmc_hybrid_threshold);
         if (!validating) {
           #if X_IS_TRINAMIC

commit a46bac3100124cd3d1782ee98d731baa838733bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 07:25:27 2018 -0500

    Add 'I' parameter to M906/M913/M914; 'T' to M906/M913

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index eb1d9db1d8..f45307106e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1892,6 +1892,14 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
+  #if HAS_TRINAMIC
+    void say_M906() { SERIAL_ECHOPGM_P(port, "  M906 "); }
+    void say_M913() { SERIAL_ECHOPGM_P(port, "  M913 "); }
+    #if ENABLED(SENSORLESS_HOMING)
+      void say_M914() { SERIAL_ECHOPGM_P(port, "  M914 "); }
+    #endif
+  #endif
+
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     void say_M603() { SERIAL_ECHOPGM_P(port, "  M603 "); }
   #endif
@@ -2373,34 +2381,51 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPGM_P(port, "  M906");
       #if X_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " X", stepperX.getCurrent());
-      #elif X2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getCurrent());
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "X", stepperX.getCurrent());
+      #endif
+      #if X2_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.getCurrent());
       #endif
       #if Y_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getCurrent());
-      #elif Y2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getCurrent());
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.getCurrent());
+      #endif
+      #if Y2_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.getCurrent());
       #endif
       #if Z_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getCurrent());
-      #elif Z2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getCurrent());
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.getCurrent());
+      #endif
+      #if Z2_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.getCurrent());
       #endif
       #if E0_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", stepperE0.getCurrent());
-      #elif E1_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", stepperE1.getCurrent());
-      #elif E2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", stepperE2.getCurrent());
-      #elif E3_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", stepperE3.getCurrent());
-      #elif E4_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", stepperE4.getCurrent());
-      #endif
-      SERIAL_EOL();
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "T0 E", stepperE0.getCurrent());
+      #endif
+      #if E_STEPPERS > 1 && E1_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "T1 E", stepperE1.getCurrent());
+      #endif
+      #if E_STEPPERS > 2 && E2_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "T2 E", stepperE2.getCurrent());
+      #endif
+      #if E_STEPPERS > 3 && E3_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "T3 E", stepperE3.getCurrent());
+      #endif
+      #if E_STEPPERS > 4 && E4_IS_TRINAMIC
+        say_M906();
+        SERIAL_ECHOLNPAIR_P(port, "T4 E", stepperE4.getCurrent());
+      #endif
+      SERIAL_EOL_P(port);
 
       /**
        * TMC2130 / TMC2208 / TRAMS Hybrid Threshold
@@ -2410,34 +2435,51 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPGM_P(port, "  M913");
       #if X_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
-      #elif X2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "X", TMC_GET_PWMTHRS(X, X));
+      #endif
+      #if X2_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "I1 X", TMC_GET_PWMTHRS(X, X2));
       #endif
       #if Y_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
-      #elif Y2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "Y", TMC_GET_PWMTHRS(Y, Y));
+      #endif
+      #if Y2_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "I1 Y", TMC_GET_PWMTHRS(Y, Y2));
       #endif
       #if Z_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
-      #elif Z2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "Z", TMC_GET_PWMTHRS(Z, Z));
+      #endif
+      #if Z2_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "I1 Z", TMC_GET_PWMTHRS(Z, Z2));
       #endif
       #if E0_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E0));
-      #elif E1_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E1));
-      #elif E2_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E2));
-      #elif E3_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E3));
-      #elif E4_IS_TRINAMIC
-        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E4));
-      #endif
-      SERIAL_EOL();
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "T0 E", TMC_GET_PWMTHRS(E, E0));
+      #endif
+      #if E_STEPPERS > 1 && E1_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "T1 E", TMC_GET_PWMTHRS(E, E1));
+      #endif
+      #if E_STEPPERS > 2 && E2_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "T2 E", TMC_GET_PWMTHRS(E, E2));
+      #endif
+      #if E_STEPPERS > 3 && E3_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "T3 E", TMC_GET_PWMTHRS(E, E3));
+      #endif
+      #if E_STEPPERS > 4 && E4_IS_TRINAMIC
+        say_M913();
+        SERIAL_ECHOLNPAIR_P(port, "T4 E", TMC_GET_PWMTHRS(E, E4));
+      #endif
+      SERIAL_EOL_P(port);
 
       /**
        * TMC2130 Sensorless homing thresholds
@@ -2448,29 +2490,37 @@ void MarlinSettings::reset(PORTARG_SOLO) {
           SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
         }
         CONFIG_ECHO_START;
-        SERIAL_ECHOPGM_P(port, "  M914");
         #ifdef X_HOMING_SENSITIVITY
           #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
-            SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
-          #elif ENABLED(X2_IS_TMC2130)
-            SERIAL_ECHOPAIR_P(port, " X", stepperX2.sgt());
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "X", stepperX.sgt());
+          #endif
+          #if ENABLED(X2_IS_TMC2130)
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "I1 X", stepperX2.sgt());
           #endif
         #endif
         #ifdef Y_HOMING_SENSITIVITY
           #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
-            SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
-          #elif ENABLED(Y2_IS_TMC2130)
-            SERIAL_ECHOPAIR_P(port, " Y", stepperY2.sgt());
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "Y", stepperY.sgt());
+          #endif
+          #if ENABLED(Y2_IS_TMC2130)
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "I1 Y", stepperY2.sgt());
           #endif
         #endif
         #ifdef Z_HOMING_SENSITIVITY
           #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
-            SERIAL_ECHOPAIR_P(port, " Z", stepperZ.sgt());
-          #elif ENABLED(Z2_IS_TMC2130)
-            SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.sgt());
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "Z", stepperZ.sgt());
+          #endif
+          #if ENABLED(Z2_IS_TMC2130)
+            say_M914();
+            SERIAL_ECHOLNPAIR_P(port, "I1 Z", stepperZ2.sgt());
           #endif
         #endif
-        SERIAL_EOL();
+        SERIAL_EOL_P(port);
       #endif
 
     #endif // HAS_TRINAMIC

commit c95450016b1f42c09ae54a3b293b41de9ff15102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 22:03:53 2018 -0500

    Improve Trinamic support in the EEPROM

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 96435a45e1..eb1d9db1d8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V52"
+#define EEPROM_VERSION "V53"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -74,8 +74,10 @@
   #include "../module/probe.h"
 #endif
 
-#if ENABLED(HAVE_TMC2130)
+#if HAS_TRINAMIC
   #include "stepper_indirection.h"
+  #include "../feature/tmc_util.h"
+  #define TMC_GET_PWMTHRS(P,Q) _tmc_thrs(stepper##Q.microsteps(), stepper##Q.TPWMTHRS(), planner.axis_steps_per_mm[P##_AXIS])
 #endif
 
 #if ENABLED(FWRETRACT)
@@ -230,7 +232,9 @@ typedef struct SettingsDataStruct {
   //
   // HAS_TRINAMIC
   //
-  uint16_t tmc_stepper_current[11];                     // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
+  #define TMC_AXES (MAX_EXTRUDERS + 6)
+  uint16_t tmc_stepper_current[TMC_AXES];               // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
+  uint32_t tmc_hybrid_threshold[TMC_AXES];              // M913 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
   int16_t tmc_sgt[XYZ];                                 // M914 X Y Z
 
   //
@@ -658,7 +662,7 @@ void MarlinSettings::postprocess() {
 
     _FIELD_TEST(tmc_stepper_current);
 
-    uint16_t currents[11] = {
+    uint16_t tmc_stepper_current[TMC_AXES] = {
       #if HAS_TRINAMIC
         #if X_IS_TRINAMIC
           stepperX.getCurrent(),
@@ -719,24 +723,95 @@ void MarlinSettings::postprocess() {
         0
       #endif
     };
-    EEPROM_WRITE(currents);
+    EEPROM_WRITE(tmc_stepper_current);
+
+    //
+    // Save TMC2130 or TMC2208 Hybrid Threshold, and placeholder values
+    //
+
+    _FIELD_TEST(tmc_hybrid_threshold);
+
+    uint32_t tmc_hybrid_threshold[TMC_AXES] = {
+      #if HAS_TRINAMIC
+        #if X_IS_TRINAMIC
+          TMC_GET_PWMTHRS(X, X),
+        #else
+          X_HYBRID_THRESHOLD,
+        #endif
+        #if Y_IS_TRINAMIC
+          TMC_GET_PWMTHRS(Y, Y),
+        #else
+          Y_HYBRID_THRESHOLD,
+        #endif
+        #if Z_IS_TRINAMIC
+          TMC_GET_PWMTHRS(Z, Z),
+        #else
+          Z_HYBRID_THRESHOLD,
+        #endif
+        #if X2_IS_TRINAMIC
+          TMC_GET_PWMTHRS(X, X2),
+        #else
+          X2_HYBRID_THRESHOLD,
+        #endif
+        #if Y2_IS_TRINAMIC
+          TMC_GET_PWMTHRS(Y, Y2),
+        #else
+          Y2_HYBRID_THRESHOLD,
+        #endif
+        #if Z2_IS_TRINAMIC
+          TMC_GET_PWMTHRS(Z, Z2),
+        #else
+          Z2_HYBRID_THRESHOLD,
+        #endif
+        #if E0_IS_TRINAMIC
+          TMC_GET_PWMTHRS(E, E0),
+        #else
+          E0_HYBRID_THRESHOLD,
+        #endif
+        #if E1_IS_TRINAMIC
+          TMC_GET_PWMTHRS(E, E1),
+        #else
+          E1_HYBRID_THRESHOLD,
+        #endif
+        #if E2_IS_TRINAMIC
+          TMC_GET_PWMTHRS(E, E2),
+        #else
+          E2_HYBRID_THRESHOLD,
+        #endif
+        #if E3_IS_TRINAMIC
+          TMC_GET_PWMTHRS(E, E3),
+        #else
+          E3_HYBRID_THRESHOLD,
+        #endif
+        #if E4_IS_TRINAMIC
+          TMC_GET_PWMTHRS(E, E4)
+        #else
+          E4_HYBRID_THRESHOLD
+        #endif
+      #else
+        100, 100, 3,          // X, Y, Z
+        100, 100, 3,          // X2, Y2, Z2
+        30, 30, 30, 30, 30    // E0, E1, E2, E3, E4
+      #endif
+    };
+    EEPROM_WRITE(tmc_hybrid_threshold);
 
     //
     // TMC2130 Sensorless homing threshold
     //
-    int16_t thrs[XYZ] = {
+    int16_t tmc_sgt[XYZ] = {
       #if ENABLED(SENSORLESS_HOMING)
-        #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+        #if defined(X_HOMING_SENSITIVITY) && (ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS))
           stepperX.sgt(),
         #else
           0,
         #endif
-        #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+        #if defined(Y_HOMING_SENSITIVITY) && (ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS))
           stepperY.sgt(),
         #else
           0
         #endif
-        #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
+        #if defined(Z_HOMING_SENSITIVITY) && (ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS))
           stepperZ.sgt()
         #else
           0
@@ -745,7 +820,7 @@ void MarlinSettings::postprocess() {
         0
       #endif
     };
-    EEPROM_WRITE(thrs);
+    EEPROM_WRITE(tmc_sgt);
 
     //
     // Linear Advance
@@ -794,7 +869,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(planner.yz_skew_factor);
     #else
       dummy = 0.0f;
-      for (uint8_t q = XYZ; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
     #endif
 
     //
@@ -1197,54 +1272,101 @@ void MarlinSettings::postprocess() {
 
       #endif
 
+      if (!validating) reset_stepper_drivers();
+
       //
-      // TMC2130 Stepper Current
+      // TMC2130 Stepper Settings
       //
 
       _FIELD_TEST(tmc_stepper_current);
 
       #if HAS_TRINAMIC
-        #define SET_CURR(N,Q) stepper##Q.setCurrent(currents[N] ? currents[N] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
-        uint16_t currents[11];
+
+        #define SET_CURR(Q) stepper##Q.setCurrent(currents[TMC_##Q] ? currents[TMC_##Q] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
+        uint16_t currents[TMC_AXES];
         EEPROM_READ(currents);
         if (!validating) {
           #if X_IS_TRINAMIC
-            SET_CURR(0, X);
+            SET_CURR(X);
           #endif
           #if Y_IS_TRINAMIC
-            SET_CURR(1, Y);
+            SET_CURR(Y);
           #endif
           #if Z_IS_TRINAMIC
-            SET_CURR(2, Z);
+            SET_CURR(Z);
           #endif
           #if X2_IS_TRINAMIC
-            SET_CURR(3, X2);
+            SET_CURR(X2);
           #endif
           #if Y2_IS_TRINAMIC
-            SET_CURR(4, Y2);
+            SET_CURR(Y2);
           #endif
           #if Z2_IS_TRINAMIC
-            SET_CURR(5, Z2);
+            SET_CURR(Z2);
           #endif
           #if E0_IS_TRINAMIC
-            SET_CURR(6, E0);
+            SET_CURR(E0);
           #endif
           #if E1_IS_TRINAMIC
-            SET_CURR(7, E1);
+            SET_CURR(E1);
           #endif
           #if E2_IS_TRINAMIC
-            SET_CURR(8, E2);
+            SET_CURR(E2);
           #endif
           #if E3_IS_TRINAMIC
-            SET_CURR(9, E3);
+            SET_CURR(E3);
           #endif
           #if E4_IS_TRINAMIC
-            SET_CURR(10, E4);
+            SET_CURR(E4);
           #endif
         }
       #else
         uint16_t val;
-        for (uint8_t q=11; q--;) EEPROM_READ(val);
+        for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(val);
+      #endif
+
+      #if HAS_TRINAMIC
+        #define TMC_SET_PWMTHRS(P,Q) tmc_set_pwmthrs(stepper##Q, TMC_##Q, tmc_hybrid_threshold[TMC_##Q], planner.axis_steps_per_mm[P##_AXIS])
+        uint16_t tmc_hybrid_threshold[TMC_AXES];
+        EEPROM_READ(tmc_hybrid_threshold);
+        if (!validating) {
+          #if X_IS_TRINAMIC
+            TMC_SET_PWMTHRS(X, X);
+          #endif
+          #if Y_IS_TRINAMIC
+            TMC_SET_PWMTHRS(Y, Y);
+          #endif
+          #if Z_IS_TRINAMIC
+            TMC_SET_PWMTHRS(Z, Z);
+          #endif
+          #if X2_IS_TRINAMIC
+            TMC_SET_PWMTHRS(X, X2);
+          #endif
+          #if Y2_IS_TRINAMIC
+            TMC_SET_PWMTHRS(Y, Y2);
+          #endif
+          #if Z2_IS_TRINAMIC
+            TMC_SET_PWMTHRS(Z, Z2);
+          #endif
+          #if E0_IS_TRINAMIC
+            TMC_SET_PWMTHRS(E, E0);
+          #endif
+          #if E1_IS_TRINAMIC
+            TMC_SET_PWMTHRS(E, E1);
+          #endif
+          #if E2_IS_TRINAMIC
+            TMC_SET_PWMTHRS(E, E2);
+          #endif
+          #if E3_IS_TRINAMIC
+            TMC_SET_PWMTHRS(E, E3);
+          #endif
+          #if E4_IS_TRINAMIC
+            TMC_SET_PWMTHRS(E, E4);
+          #endif
+        }
+      #else
+        uint16_t thrs_val;
+        for (uint8_t q=TMC_AXES; q--;) EEPROM_READ(thrs_val);
       #endif
 
       /*
@@ -1253,32 +1375,32 @@ void MarlinSettings::postprocess() {
        * Y and Y2 use the same value
        * Z and Z2 use the same value
        */
-      int16_t thrs[XYZ];
-      EEPROM_READ(thrs);
+      int16_t tmc_sgt[XYZ];
+      EEPROM_READ(tmc_sgt);
       #if ENABLED(SENSORLESS_HOMING)
         if (!validating) {
           #ifdef X_HOMING_SENSITIVITY
-            #if ENABLED(X_IS_TMC2130)
-              stepperX.sgt(thrs[0]);
+            #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
+              stepperX.sgt(tmc_sgt[0]);
             #endif
             #if ENABLED(X2_IS_TMC2130)
-              stepperX2.sgt(thrs[0]);
+              stepperX2.sgt(tmc_sgt[0]);
             #endif
           #endif
           #ifdef Y_HOMING_SENSITIVITY
-            #if ENABLED(Y_IS_TMC2130)
-              stepperY.sgt(thrs[1]);
+            #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
+              stepperY.sgt(tmc_sgt[1]);
             #endif
             #if ENABLED(Y2_IS_TMC2130)
-              stepperY2.sgt(thrs[1]);
+              stepperY2.sgt(tmc_sgt[1]);
             #endif
           #endif
           #ifdef Z_HOMING_SENSITIVITY
-            #if ENABLED(Z_IS_TMC2130)
-              stepperZ.sgt(thrs[2]);
+            #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
+              stepperZ.sgt(tmc_sgt[2]);
             #endif
             #if ENABLED(Z2_IS_TMC2130)
-              stepperZ2.sgt(thrs[2]);
+              stepperZ2.sgt(tmc_sgt[2]);
             #endif
           #endif
         }
@@ -1338,7 +1460,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(dummy);
         #endif
       #else
-        for (uint8_t q = XYZ; q--;) EEPROM_READ(dummy);
+        for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
       #endif
 
       //
@@ -1731,66 +1853,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
     #endif
   );
 
-  #if X_IS_TRINAMIC
-    stepperX.setCurrent(X_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if Y_IS_TRINAMIC
-    stepperY.setCurrent(Y_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if Z_IS_TRINAMIC
-    stepperZ.setCurrent(Z_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if X2_IS_TRINAMIC
-    stepperX2.setCurrent(X2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if Y2_IS_TRINAMIC
-    stepperY2.setCurrent(Y2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if Z2_IS_TRINAMIC
-    stepperZ2.setCurrent(Z2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if E0_IS_TRINAMIC
-    stepperE0.setCurrent(E0_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if E1_IS_TRINAMIC
-    stepperE1.setCurrent(E1_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if E2_IS_TRINAMIC
-    stepperE2.setCurrent(E2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if E3_IS_TRINAMIC
-    stepperE3.setCurrent(E3_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-  #if E4_IS_TRINAMIC
-    stepperE4.setCurrent(E4_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-  #endif
-
-  #if ENABLED(SENSORLESS_HOMING)
-    #ifdef X_HOMING_SENSITIVITY
-      #if ENABLED(X_IS_TMC2130)
-        stepperX.sgt(X_HOMING_SENSITIVITY);
-      #endif
-      #if ENABLED(X2_IS_TMC2130)
-        stepperX2.sgt(X_HOMING_SENSITIVITY);
-      #endif
-    #endif
-    #ifdef Y_HOMING_SENSITIVITY
-      #if ENABLED(Y_IS_TMC2130)
-        stepperY.sgt(Y_HOMING_SENSITIVITY);
-      #endif
-      #if ENABLED(Y2_IS_TMC2130)
-        stepperY2.sgt(Y_HOMING_SENSITIVITY);
-      #endif
-    #endif
-    #ifdef Z_HOMING_SENSITIVITY
-      #if ENABLED(Z_IS_TMC2130)
-        stepperZ.sgt(Z_HOMING_SENSITIVITY);
-      #endif
-      #if ENABLED(Z2_IS_TMC2130)
-        stepperZ2.sgt(Z_HOMING_SENSITIVITY);
-      #endif
-    #endif
-  #endif
+  reset_stepper_drivers();
 
   #if ENABLED(LIN_ADVANCE)
     planner.extruder_advance_K = LIN_ADVANCE_K;
@@ -1829,6 +1892,10 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
   #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    void say_M603() { SERIAL_ECHOPGM_P(port, "  M603 "); }
+  #endif
+
   /**
    * M503 - Report current settings in RAM
    *
@@ -1849,7 +1916,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       SERIAL_ECHOPGM_P(port, "  G2");
       SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
       SERIAL_ECHOPGM_P(port, " ; Units in ");
-      serialprintPGM(parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
+      serialprintPGM_P(port, parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
     #else
       #define LINEAR_UNIT(N) (N)
       #define VOLUMETRIC_UNIT(N) (N)
@@ -2076,7 +2143,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
               SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
               SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
               SERIAL_ECHOPGM_P(port, " Z");
-              SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
+              SERIAL_ECHO_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
               SERIAL_EOL_P(port);
             }
           }
@@ -2103,7 +2170,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
               SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px + 1);
               SERIAL_ECHOPAIR_P(port, " J", (int)py + 1);
               SERIAL_ECHOPGM_P(port, " Z");
-              SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(z_values[px][py]), 5);
+              SERIAL_ECHO_F_P(port, LINEAR_UNIT(z_values[px][py]), 5);
               SERIAL_EOL_P(port);
             }
           }
@@ -2289,95 +2356,124 @@ void MarlinSettings::reset(PORTARG_SOLO) {
         SERIAL_ECHOPGM_P(port, " K");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.yz_skew_factor), 6);
         SERIAL_EOL_P(port);
-       #else
+      #else
         SERIAL_ECHOPGM_P(port, "  M852 S");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_EOL_P(port);
       #endif
     #endif
 
-    /**
-     * TMC2130 stepper driver current
-     */
     #if HAS_TRINAMIC
+
+      /**
+       * TMC2130 / TMC2208 / TRAMS stepper driver current
+       */
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
       SERIAL_ECHOPGM_P(port, "  M906");
-      #if ENABLED(X_IS_TMC2130) || ENABLED(X_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " X ", stepperX.getCurrent());
+      #if X_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", stepperX.getCurrent());
+      #elif X2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", stepperX2.getCurrent());
       #endif
-      #if ENABLED(Y_IS_TMC2130) || ENABLED(Y_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " Y ", stepperY.getCurrent());
+      #if Y_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY.getCurrent());
+      #elif Y2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY2.getCurrent());
       #endif
-      #if ENABLED(Z_IS_TMC2130) || ENABLED(Z_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " Z ", stepperZ.getCurrent());
+      #if Z_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ.getCurrent());
+      #elif Z2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.getCurrent());
       #endif
-      #if ENABLED(X2_IS_TMC2130) || ENABLED(X2_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.getCurrent());
+      #if E0_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", stepperE0.getCurrent());
+      #elif E1_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", stepperE1.getCurrent());
+      #elif E2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", stepperE2.getCurrent());
+      #elif E3_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", stepperE3.getCurrent());
+      #elif E4_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", stepperE4.getCurrent());
       #endif
-      #if ENABLED(Y2_IS_TMC2130) || ENABLED(Y2_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.getCurrent());
-      #endif
-      #if ENABLED(Z2_IS_TMC2130) || ENABLED(Z2_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " Z2 ", stepperZ2.getCurrent());
-      #endif
-      #if ENABLED(E0_IS_TMC2130) || ENABLED(E0_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " E0 ", stepperE0.getCurrent());
-      #endif
-      #if ENABLED(E1_IS_TMC2130) || ENABLED(E1_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " E1 ", stepperE1.getCurrent());
-      #endif
-      #if ENABLED(E2_IS_TMC2130) || ENABLED(E2_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " E2 ", stepperE2.getCurrent());
-      #endif
-      #if ENABLED(E3_IS_TMC2130) || ENABLED(E3_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " E3 ", stepperE3.getCurrent());
-      #endif
-      #if ENABLED(E4_IS_TMC2130) || ENABLED(E4_IS_TMC2208)
-        SERIAL_ECHOPAIR_P(port, " E4 ", stepperE4.getCurrent());
-      #endif
-      SERIAL_EOL_P(port);
-    #endif
+      SERIAL_EOL();
 
-    /**
-     * TMC2130 Sensorless homing thresholds
-     */
-    #if ENABLED(SENSORLESS_HOMING)
+      /**
+       * TMC2130 / TMC2208 / TRAMS Hybrid Threshold
+       */
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
+        SERIAL_ECHOLNPGM_P(port, "Hybrid Threshold:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPGM_P(port, "  M914");
-      #ifdef X_HOMING_SENSITIVITY
-        #if ENABLED(X_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
-        #endif
-        #if ENABLED(X2_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.sgt());
-        #endif
+      SERIAL_ECHOPGM_P(port, "  M913");
+      #if X_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X));
+      #elif X2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " X", TMC_GET_PWMTHRS(X, X2));
       #endif
-      #ifdef Y_HOMING_SENSITIVITY
-        #if ENABLED(Y_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
-        #endif
-        #if ENABLED(Y2_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.sgt());
-        #endif
+      #if Y_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y));
+      #elif Y2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Y", TMC_GET_PWMTHRS(Y, Y2));
       #endif
-      #ifdef Z_HOMING_SENSITIVITY
-        #if ENABLED(Z_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " Z ", stepperZ.sgt());
+      #if Z_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z));
+      #elif Z2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " Z", TMC_GET_PWMTHRS(Z, Z2));
+      #endif
+      #if E0_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E0));
+      #elif E1_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E1));
+      #elif E2_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E2));
+      #elif E3_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E3));
+      #elif E4_IS_TRINAMIC
+        SERIAL_ECHOPAIR_P(port, " E", TMC_GET_PWMTHRS(E, E4));
+      #endif
+      SERIAL_EOL();
+
+      /**
+       * TMC2130 Sensorless homing thresholds
+       */
+      #if ENABLED(SENSORLESS_HOMING)
+        if (!forReplay) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
+        }
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPGM_P(port, "  M914");
+        #ifdef X_HOMING_SENSITIVITY
+          #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
+            SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
+          #elif ENABLED(X2_IS_TMC2130)
+            SERIAL_ECHOPAIR_P(port, " X", stepperX2.sgt());
+          #endif
+        #endif
+        #ifdef Y_HOMING_SENSITIVITY
+          #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
+            SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
+          #elif ENABLED(Y2_IS_TMC2130)
+            SERIAL_ECHOPAIR_P(port, " Y", stepperY2.sgt());
+          #endif
         #endif
-        #if ENABLED(Z2_IS_TMC2130)
-          SERIAL_ECHOPAIR_P(port, " Z2 ", stepperZ2.sgt());
+        #ifdef Z_HOMING_SENSITIVITY
+          #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
+            SERIAL_ECHOPAIR_P(port, " Z", stepperZ.sgt());
+          #elif ENABLED(Z2_IS_TMC2130)
+            SERIAL_ECHOPAIR_P(port, " Z", stepperZ2.sgt());
+          #endif
         #endif
+        SERIAL_EOL();
       #endif
-      SERIAL_EOL_P(port);
-    #endif
+
+    #endif // HAS_TRINAMIC
 
     /**
      * Linear Advance
@@ -2413,25 +2509,31 @@ void MarlinSettings::reset(PORTARG_SOLO) {
       }
       CONFIG_ECHO_START;
       #if EXTRUDERS == 1
-        SERIAL_ECHOPAIR_P(port, "  M603 L", LINEAR_UNIT(filament_change_load_length[0]));
+        say_M603();
+        SERIAL_ECHOPAIR_P(port, "L", LINEAR_UNIT(filament_change_load_length[0]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
       #else
-        SERIAL_ECHOPAIR_P(port, "  M603 T0 L", LINEAR_UNIT(filament_change_load_length[0]));
+        say_M603();
+        SERIAL_ECHOPAIR_P(port, "T0 L", LINEAR_UNIT(filament_change_load_length[0]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR_P(port, "  M603 T1 L", LINEAR_UNIT(filament_change_load_length[1]));
+        say_M603();
+        SERIAL_ECHOPAIR_P(port, "T1 L", LINEAR_UNIT(filament_change_load_length[1]));
         SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[1]));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR_P(port, "  M603 T2 L", LINEAR_UNIT(filament_change_load_length[2]));
+          say_M603();
+          SERIAL_ECHOPAIR_P(port, "T2 L", LINEAR_UNIT(filament_change_load_length[2]));
           SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[2]));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR_P(port, "  M603 T3 L", LINEAR_UNIT(filament_change_load_length[3]));
+            say_M603();
+            SERIAL_ECHOPAIR_P(port, "T3 L", LINEAR_UNIT(filament_change_load_length[3]));
             SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[3]));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START;
-              SERIAL_ECHOPAIR_P(port, "  M603 T4 L", LINEAR_UNIT(filament_change_load_length[4]));
+              say_M603();
+              SERIAL_ECHOPAIR_P(port, "T4 L", LINEAR_UNIT(filament_change_load_length[4]));
               SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[4]));
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3

commit 772810fb240edba18fe64793fbe30d20a0cfc679
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 19:21:10 2018 -0500

    Followup to PORTVAR patch

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2791510150..96435a45e1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1827,7 +1827,7 @@ void MarlinSettings::reset(PORTARG_SOLO) {
 
 #if DISABLED(DISABLE_M503)
 
-  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(PORTVAR_SOLO); }while(0)
+  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
   /**
    * M503 - Report current settings in RAM

commit 4aebe3d82e1baf7da6b71b3ecdb3225af8429ffd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 22:44:07 2018 -0500

    Pretty up EEPROM port args

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 50c9d18b55..2791510150 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -45,6 +45,17 @@
 //#define DEBUG_EEPROM_READWRITE
 
 #include "configuration_store.h"
+
+#if ADD_PORT_ARG
+  #define PORTARG_SOLO     const int8_t port
+  #define PORTARG_AFTER   ,const int8_t port
+  #define PORTVAR_SOLO     port
+#else
+  #define PORTARG_SOLO
+  #define PORTARG_AFTER
+  #define PORTVAR_SOLO
+#endif
+
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
@@ -345,11 +356,7 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
 
-  bool MarlinSettings::size_error(const uint16_t size
-    #if ADD_PORT_ARG
-      , const int8_t port/*=-1*/
-    #endif
-  ) {
+  bool MarlinSettings::size_error(const uint16_t size PORTARG_AFTER) {
     if (size != datasize()) {
       #if ENABLED(EEPROM_CHITCHAT)
         SERIAL_ERROR_START_P(port);
@@ -363,11 +370,7 @@ void MarlinSettings::postprocess() {
   /**
    * M500 - Store Configuration
    */
-  bool MarlinSettings::save(
-    #if ADD_PORT_ARG
-      const int8_t port/*=-1*/
-    #endif
-  ) {
+  bool MarlinSettings::save(PORTARG_SOLO) {
     float dummy = 0.0f;
     char ver[4] = "ERR";
 
@@ -853,11 +856,7 @@ void MarlinSettings::postprocess() {
   /**
    * M501 - Retrieve Configuration
    */
-  bool MarlinSettings::_load(
-    #if ADD_PORT_ARG
-      const int8_t port/*=-1*/
-    #endif
-  ) {
+  bool MarlinSettings::_load(PORTARG_SOLO) {
     uint16_t working_crc = 0;
 
     EEPROM_START();
@@ -1431,46 +1430,22 @@ void MarlinSettings::postprocess() {
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      if (!validating) report(
-        #if ADD_PORT_ARG
-          port
-        #endif
-      );
+      if (!validating) report(PORTVAR_SOLO);
     #endif
     EEPROM_FINISH();
 
     return !eeprom_error;
   }
 
-  bool MarlinSettings::validate(
-    #if ADD_PORT_ARG
-      const int8_t port/*=-1*/
-    #endif
-  ) {
+  bool MarlinSettings::validate(PORTARG_SOLO) {
     validating = true;
-    const bool success = _load(
-      #if ADD_PORT_ARG
-        port
-      #endif
-    );
+    const bool success = _load(PORTVAR_SOLO);
     validating = false;
     return success;
   }
 
-  bool MarlinSettings::load(
-    #if ADD_PORT_ARG
-      const int8_t port/*=-1*/
-    #endif
-  ) {
-    if (validate(
-      #if ADD_PORT_ARG
-        port
-      #endif
-    )) return _load(
-      #if ADD_PORT_ARG
-        port
-      #endif
-    );
+  bool MarlinSettings::load(PORTARG_SOLO) {
+    if (validate(PORTVAR_SOLO)) return _load(PORTVAR_SOLO);
     reset();
     return true;
   }
@@ -1581,11 +1556,7 @@ void MarlinSettings::postprocess() {
 
 #else // !EEPROM_SETTINGS
 
-  bool MarlinSettings::save(
-    #if ADD_PORT_ARG
-      const int8_t port/*=-1*/
-    #endif
-  ) {
+  bool MarlinSettings::save(PORTARG_SOLO) {
     #if ENABLED(EEPROM_CHITCHAT)
       SERIAL_ERROR_START_P(port);
       SERIAL_ERRORLNPGM_P(port, "EEPROM disabled");
@@ -1598,11 +1569,7 @@ void MarlinSettings::postprocess() {
 /**
  * M502 - Reset Configuration
  */
-void MarlinSettings::reset(
-  #if ADD_PORT_ARG
-    const int8_t port/*=-1*/
-  #endif
-) {
+void MarlinSettings::reset(PORTARG_SOLO) {
   static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
   static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE_N(i) {
@@ -1860,11 +1827,7 @@ void MarlinSettings::reset(
 
 #if DISABLED(DISABLE_M503)
 
-  #if ADD_PORT_ARG
-    #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
-  #else
-    #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
-  #endif
+  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(PORTVAR_SOLO); }while(0)
 
   /**
    * M503 - Report current settings in RAM
@@ -2129,11 +2092,7 @@ void MarlinSettings::reset(
           SERIAL_ECHOLNPGM_P(port, " meshes.\n");
         }
 
-        ubl.report_current_mesh(
-          #if ADD_PORT_ARG
-            port
-          #endif
-        );
+        ubl.report_current_mesh(PORTVAR_SOLO);
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 

commit 239902f8615d37a95a8296195fe37c1b35c2e383
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 10 03:02:53 2018 -0600

    Fix E2END and add EEPROM to Smart RAMPS
    
    Reference #9983

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 197d9ad141..50c9d18b55 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1494,6 +1494,10 @@ void MarlinSettings::postprocess() {
       return (meshes_end - meshes_start_index()) / sizeof(ubl.z_values);
     }
 
+    int MarlinSettings::mesh_slot_offset(const int8_t slot) {
+      return meshes_end - (slot + 1) * sizeof(ubl.z_values);
+    }
+
     void MarlinSettings::store_mesh(const int8_t slot) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -1509,8 +1513,8 @@ void MarlinSettings::postprocess() {
           return;
         }
 
+        int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
-        int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
 
         HAL::PersistentStore::access_start();
         const bool status = HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
@@ -1546,8 +1550,8 @@ void MarlinSettings::postprocess() {
           return;
         }
 
+        int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
-        int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
         uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
 
         HAL::PersistentStore::access_start();

commit 49ca67202f87dc90e296f0e4dc5fb4caecc61214
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 07:42:27 2018 -0600

    Patch configuration_store for extra serial port
    
    Fix #9948

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6f395c262f..197d9ad141 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1462,7 +1462,11 @@ void MarlinSettings::postprocess() {
       const int8_t port/*=-1*/
     #endif
   ) {
-    if (validate()) return _load(
+    if (validate(
+      #if ADD_PORT_ARG
+        port
+      #endif
+    )) return _load(
       #if ADD_PORT_ARG
         port
       #endif
@@ -1864,7 +1868,7 @@ void MarlinSettings::reset(
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay
-    #if ADD_PORT_ARG
+    #if NUM_SERIAL > 1
       , const int8_t port/*=-1*/
     #endif
   ) {

commit 966d9af98acdb43cca9f15de7f258565270b9704
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 08:07:48 2018 -0600

    Mesh export in Bilinear + UBL M503

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dcd9f65d94..6f395c262f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2098,14 +2098,16 @@ void MarlinSettings::reset(
 
       #if ENABLED(MESH_BED_LEVELING)
 
-        for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
-          for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
-            CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
-            SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
-            SERIAL_ECHOPGM_P(port, " Z");
-            SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
-            SERIAL_EOL_P(port);
+        if (leveling_is_valid()) {
+          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
+            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
+              SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
+              SERIAL_ECHOPGM_P(port, " Z");
+              SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
+              SERIAL_EOL_P(port);
+            }
           }
         }
 
@@ -2119,6 +2121,27 @@ void MarlinSettings::reset(
           SERIAL_ECHOLNPGM_P(port, " meshes.\n");
         }
 
+        ubl.report_current_mesh(
+          #if ADD_PORT_ARG
+            port
+          #endif
+        );
+
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        if (leveling_is_valid()) {
+          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
+            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR_P(port, "  G29 W I", (int)px + 1);
+              SERIAL_ECHOPAIR_P(port, " J", (int)py + 1);
+              SERIAL_ECHOPGM_P(port, " Z");
+              SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(z_values[px][py]), 5);
+              SERIAL_EOL_P(port);
+            }
+          }
+        }
+
       #endif
 
     #endif // HAS_LEVELING

commit 8d5a77001ead226323aefd4c84d766b217e41868
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 21:02:22 2018 -0600

    EEPROM parity with 1.1.x

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9b547406d7..dcd9f65d94 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -220,7 +220,7 @@ typedef struct SettingsDataStruct {
   // HAS_TRINAMIC
   //
   uint16_t tmc_stepper_current[11];                     // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
-  int16_t tmc_sgt[3];                                   // M914 X Y Z
+  int16_t tmc_sgt[XYZ];                                 // M914 X Y Z
 
   //
   // LIN_ADVANCE
@@ -721,30 +721,28 @@ void MarlinSettings::postprocess() {
     //
     // TMC2130 Sensorless homing threshold
     //
-    int16_t thrs;
-    #if ENABLED(SENSORLESS_HOMING)
-      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
-        thrs = stepperX.sgt();
-      #else
-        thrs = 0;
-      #endif
-      EEPROM_WRITE(thrs);
-      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
-        thrs = stepperY.sgt();
-      #else
-        thrs = 0;
-      #endif
-      EEPROM_WRITE(thrs);
-      #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
-        thrs = stepperZ.sgt();
+    int16_t thrs[XYZ] = {
+      #if ENABLED(SENSORLESS_HOMING)
+        #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+          stepperX.sgt(),
+        #else
+          0,
+        #endif
+        #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+          stepperY.sgt(),
+        #else
+          0
+        #endif
+        #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
+          stepperZ.sgt()
+        #else
+          0
+        #endif
       #else
-        thrs = 0;
+        0
       #endif
-      EEPROM_WRITE(thrs);
-    #else
-      thrs = 0;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(thrs);
-    #endif
+    };
+    EEPROM_WRITE(thrs);
 
     //
     // Linear Advance
@@ -762,10 +760,10 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(motor_current_setting);
 
     #if HAS_MOTOR_CURRENT_PWM
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
+      for (uint8_t q = XYZ; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
     #else
-      const uint32_t dummyui32 = 0;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummyui32);
+      const uint32_t dummyui32[XYZ] = { 0 };
+      EEPROM_WRITE(dummyui32);
     #endif
 
     //
@@ -793,7 +791,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(planner.yz_skew_factor);
     #else
       dummy = 0.0f;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = XYZ; q--;) EEPROM_WRITE(dummy);
     #endif
 
     //
@@ -1254,44 +1252,37 @@ void MarlinSettings::postprocess() {
        * TMC2130 Sensorless homing threshold.
        * X and X2 use the same value
        * Y and Y2 use the same value
+       * Z and Z2 use the same value
        */
-      int16_t thrs;
+      int16_t thrs[XYZ];
+      EEPROM_READ(thrs);
       #if ENABLED(SENSORLESS_HOMING)
-        EEPROM_READ(thrs);
-        #ifdef X_HOMING_SENSITIVITY
-          if (!validating) {
+        if (!validating) {
+          #ifdef X_HOMING_SENSITIVITY
             #if ENABLED(X_IS_TMC2130)
-              stepperX.sgt(thrs);
+              stepperX.sgt(thrs[0]);
             #endif
             #if ENABLED(X2_IS_TMC2130)
-              stepperX2.sgt(thrs);
+              stepperX2.sgt(thrs[0]);
             #endif
-          }
-        #endif
-        EEPROM_READ(thrs);
-        #ifdef Y_HOMING_SENSITIVITY
-          if (!validating) {
+          #endif
+          #ifdef Y_HOMING_SENSITIVITY
             #if ENABLED(Y_IS_TMC2130)
-              stepperY.sgt(thrs);
+              stepperY.sgt(thrs[1]);
             #endif
             #if ENABLED(Y2_IS_TMC2130)
-              stepperY2.sgt(thrs);
+              stepperY2.sgt(thrs[1]);
             #endif
-          }
-        #endif
-        EEPROM_READ(thrs);
-        #ifdef Z_HOMING_SENSITIVITY
-          if (!validating) {
+          #endif
+          #ifdef Z_HOMING_SENSITIVITY
             #if ENABLED(Z_IS_TMC2130)
-              stepperZ.sgt(thrs);
+              stepperZ.sgt(thrs[2]);
             #endif
             #if ENABLED(Z2_IS_TMC2130)
-              stepperZ2.sgt(thrs);
+              stepperZ2.sgt(thrs[2]);
             #endif
-          }
-        #endif
-      #else
-        for (uint8_t q = 0; q < 3; q++) EEPROM_READ(thrs);
+          #endif
+        }
       #endif
 
       //
@@ -1313,10 +1304,10 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(motor_current_setting);
 
       #if HAS_MOTOR_CURRENT_PWM
-        for (uint8_t q = 3; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
+        for (uint8_t q = XYZ; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
       #else
-        uint32_t dummyui32;
-        for (uint8_t q = 3; q--;) EEPROM_READ(dummyui32);
+        uint32_t dummyui32[XYZ];
+        EEPROM_READ(dummyui32);
       #endif
 
       //
@@ -1348,7 +1339,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(dummy);
         #endif
       #else
-        for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
+        for (uint8_t q = XYZ; q--;) EEPROM_READ(dummy);
       #endif
 
       //
@@ -1831,8 +1822,8 @@ void MarlinSettings::reset(
   #endif
 
   #if HAS_MOTOR_CURRENT_PWM
-    uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
-    for (uint8_t q = 3; q--;)
+    uint32_t tmp_motor_current_setting[XYZ] = PWM_MOTOR_CURRENT;
+    for (uint8_t q = XYZ; q--;)
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 

commit 0557ab57803a7c4d84ba18e0d1da8f873f1093f8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 05:34:26 2018 -0600

    Fix CONFIG_ECHO_START bug
    
    In reference to #9633

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e4337e423e..9b547406d7 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1861,7 +1861,11 @@ void MarlinSettings::reset(
 
 #if DISABLED(DISABLE_M503)
 
-  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
+  #if ADD_PORT_ARG
+    #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
+  #else
+    #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+  #endif
 
   /**
    * M503 - Report current settings in RAM

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ace7f73c1f..e4337e423e 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V51"
+#define EEPROM_VERSION "V52"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -225,8 +225,7 @@ typedef struct SettingsDataStruct {
   //
   // LIN_ADVANCE
   //
-  float planner_extruder_advance_k,                     // M900 K    planner.extruder_advance_k
-        planner_advance_ed_ratio;                       // M900 WHD  planner.advance_ed_ratio
+  float planner_extruder_advance_K;                     // M900 K    planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
@@ -751,15 +750,13 @@ void MarlinSettings::postprocess() {
     // Linear Advance
     //
 
-    _FIELD_TEST(planner_extruder_advance_k);
+    _FIELD_TEST(planner_extruder_advance_K);
 
     #if ENABLED(LIN_ADVANCE)
-      EEPROM_WRITE(planner.extruder_advance_k);
-      EEPROM_WRITE(planner.advance_ed_ratio);
+      EEPROM_WRITE(planner.extruder_advance_K);
     #else
       dummy = 0.0f;
       EEPROM_WRITE(dummy);
-      EEPROM_WRITE(dummy);
     #endif
 
     _FIELD_TEST(motor_current_setting);
@@ -1301,14 +1298,12 @@ void MarlinSettings::postprocess() {
       // Linear Advance
       //
 
-      _FIELD_TEST(planner_extruder_advance_k);
+      _FIELD_TEST(planner_extruder_advance_K);
 
       #if ENABLED(LIN_ADVANCE)
-        EEPROM_READ(planner.extruder_advance_k);
-        EEPROM_READ(planner.advance_ed_ratio);
+        EEPROM_READ(planner.extruder_advance_K);
       #else
         EEPROM_READ(dummy);
-        EEPROM_READ(dummy);
       #endif
 
       //
@@ -1832,8 +1827,7 @@ void MarlinSettings::reset(
   #endif
 
   #if ENABLED(LIN_ADVANCE)
-    planner.extruder_advance_k = LIN_ADVANCE_K;
-    planner.advance_ed_ratio = LIN_ADVANCE_E_D_RATIO;
+    planner.extruder_advance_K = LIN_ADVANCE_K;
   #endif
 
   #if HAS_MOTOR_CURRENT_PWM
@@ -2409,8 +2403,7 @@ void MarlinSettings::reset(
         SERIAL_ECHOLNPGM_P(port, "Linear Advance:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR_P(port, "  M900 K", planner.extruder_advance_k);
-      SERIAL_ECHOLNPAIR_P(port, " R", planner.advance_ed_ratio);
+      SERIAL_ECHOLNPAIR_P(port, "  M900 K", planner.extruder_advance_K);
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM

commit 5968a3e60eac512ade0c9482ab723ee0f33fb5a7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Feb 22 20:28:46 2018 +0200

    Add ADVANCED_PAUSE_FEATURE include

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6799b1f938..ace7f73c1f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -71,6 +71,10 @@
   #include "../feature/fwretract.h"
 #endif
 
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../feature/pause.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct PID { float Kp, Ki, Kd; } PID;

commit 472229b974087e330d5be27c0058ad808e5ac55c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 17 08:27:54 2018 -0600

    Fix #9681

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index cd2019324a..6799b1f938 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -886,7 +886,7 @@ void MarlinSettings::postprocess() {
     }
     else {
       float dummy = 0;
-      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT)
+      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT) || ENABLED(NO_VOLUMETRICS)
         bool dummyb;
       #endif
 

commit 1541224a81a80b91a1ac2009c917f1f33e816cfb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Feb 8 04:20:44 2018 -0600

    Enable Z axis and delta sensorless homing (#9516)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6208275f51..cd2019324a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V50"
+#define EEPROM_VERSION "V51"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -216,7 +216,7 @@ typedef struct SettingsDataStruct {
   // HAS_TRINAMIC
   //
   uint16_t tmc_stepper_current[11];                     // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
-  int16_t tmc_sgt[2];                                   // M914 X Y
+  int16_t tmc_sgt[3];                                   // M914 X Y Z
 
   //
   // LIN_ADVANCE
@@ -720,21 +720,27 @@ void MarlinSettings::postprocess() {
     //
     int16_t thrs;
     #if ENABLED(SENSORLESS_HOMING)
-      #if ENABLED(X_IS_TMC2130)
+      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
         thrs = stepperX.sgt();
       #else
         thrs = 0;
       #endif
       EEPROM_WRITE(thrs);
-      #if ENABLED(Y_IS_TMC2130)
+      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
         thrs = stepperY.sgt();
       #else
         thrs = 0;
       #endif
       EEPROM_WRITE(thrs);
+      #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
+        thrs = stepperZ.sgt();
+      #else
+        thrs = 0;
+      #endif
+      EEPROM_WRITE(thrs);
     #else
       thrs = 0;
-      for (uint8_t q = 2; q--;) EEPROM_WRITE(thrs);
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(thrs);
     #endif
 
     //
@@ -1251,25 +1257,40 @@ void MarlinSettings::postprocess() {
       int16_t thrs;
       #if ENABLED(SENSORLESS_HOMING)
         EEPROM_READ(thrs);
-        if (!validating) {
-          #if ENABLED(X_IS_TMC2130)
-            stepperX.sgt(thrs);
-          #endif
-          #if ENABLED(X2_IS_TMC2130)
-            stepperX2.sgt(thrs);
-          #endif
-        }
+        #ifdef X_HOMING_SENSITIVITY
+          if (!validating) {
+            #if ENABLED(X_IS_TMC2130)
+              stepperX.sgt(thrs);
+            #endif
+            #if ENABLED(X2_IS_TMC2130)
+              stepperX2.sgt(thrs);
+            #endif
+          }
+        #endif
         EEPROM_READ(thrs);
-        if (!validating) {
-          #if ENABLED(Y_IS_TMC2130)
-            stepperY.sgt(thrs);
-          #endif
-          #if ENABLED(Y2_IS_TMC2130)
-            stepperY2.sgt(thrs);
-          #endif
-        }
+        #ifdef Y_HOMING_SENSITIVITY
+          if (!validating) {
+            #if ENABLED(Y_IS_TMC2130)
+              stepperY.sgt(thrs);
+            #endif
+            #if ENABLED(Y2_IS_TMC2130)
+              stepperY2.sgt(thrs);
+            #endif
+          }
+        #endif
+        EEPROM_READ(thrs);
+        #ifdef Z_HOMING_SENSITIVITY
+          if (!validating) {
+            #if ENABLED(Z_IS_TMC2130)
+              stepperZ.sgt(thrs);
+            #endif
+            #if ENABLED(Z2_IS_TMC2130)
+              stepperZ2.sgt(thrs);
+            #endif
+          }
+        #endif
       #else
-        for (uint8_t q = 0; q < 2; q++) EEPROM_READ(thrs);
+        for (uint8_t q = 0; q < 3; q++) EEPROM_READ(thrs);
       #endif
 
       //
@@ -1780,17 +1801,29 @@ void MarlinSettings::reset(
   #endif
 
   #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130)
-      stepperX.sgt(X_HOMING_SENSITIVITY);
-    #endif
-    #if ENABLED(X2_IS_TMC2130)
-      stepperX2.sgt(X_HOMING_SENSITIVITY);
+    #ifdef X_HOMING_SENSITIVITY
+      #if ENABLED(X_IS_TMC2130)
+        stepperX.sgt(X_HOMING_SENSITIVITY);
+      #endif
+      #if ENABLED(X2_IS_TMC2130)
+        stepperX2.sgt(X_HOMING_SENSITIVITY);
+      #endif
     #endif
-    #if ENABLED(Y_IS_TMC2130)
-      stepperY.sgt(Y_HOMING_SENSITIVITY);
+    #ifdef Y_HOMING_SENSITIVITY
+      #if ENABLED(Y_IS_TMC2130)
+        stepperY.sgt(Y_HOMING_SENSITIVITY);
+      #endif
+      #if ENABLED(Y2_IS_TMC2130)
+        stepperY2.sgt(Y_HOMING_SENSITIVITY);
+      #endif
     #endif
-    #if ENABLED(Y2_IS_TMC2130)
-      stepperY2.sgt(Y_HOMING_SENSITIVITY);
+    #ifdef Z_HOMING_SENSITIVITY
+      #if ENABLED(Z_IS_TMC2130)
+        stepperZ.sgt(Z_HOMING_SENSITIVITY);
+      #endif
+      #if ENABLED(Z2_IS_TMC2130)
+        stepperZ2.sgt(Z_HOMING_SENSITIVITY);
+      #endif
     #endif
   #endif
 
@@ -2336,17 +2369,29 @@ void MarlinSettings::reset(
       }
       CONFIG_ECHO_START;
       SERIAL_ECHOPGM_P(port, "  M914");
-      #if ENABLED(X_IS_TMC2130)
-        SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
-      #endif
-      #if ENABLED(X2_IS_TMC2130)
-        SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.sgt());
+      #ifdef X_HOMING_SENSITIVITY
+        #if ENABLED(X_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
+        #endif
+        #if ENABLED(X2_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.sgt());
+        #endif
       #endif
-      #if ENABLED(Y_IS_TMC2130)
-        SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
+      #ifdef Y_HOMING_SENSITIVITY
+        #if ENABLED(Y_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
+        #endif
+        #if ENABLED(Y2_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.sgt());
+        #endif
       #endif
-      #if ENABLED(X2_IS_TMC2130)
-        SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.sgt());
+      #ifdef Z_HOMING_SENSITIVITY
+        #if ENABLED(Z_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " Z ", stepperZ.sgt());
+        #endif
+        #if ENABLED(Z2_IS_TMC2130)
+          SERIAL_ECHOPAIR_P(port, " Z2 ", stepperZ2.sgt());
+        #endif
       #endif
       SERIAL_EOL_P(port);
     #endif

commit 2bea1bda569ac7aecc87c0f79a7ceaa7a073a0b4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 21:17:33 2018 -0600

    Move more strings to PROGMEM

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index a27cf80563..6208275f51 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1502,7 +1502,7 @@ void MarlinSettings::postprocess() {
         HAL::PersistentStore::access_finish();
 
         if (status)
-          SERIAL_PROTOCOL("?Unable to save mesh data.\n");
+          SERIAL_PROTOCOLPGM("?Unable to save mesh data.\n");
 
         // Write crc to MAT along with other data, or just tack on to the beginning or end
 
@@ -1540,7 +1540,7 @@ void MarlinSettings::postprocess() {
         HAL::PersistentStore::access_finish();
 
         if (status)
-          SERIAL_PROTOCOL("?Unable to load mesh data.\n");
+          SERIAL_PROTOCOLPGM("?Unable to load mesh data.\n");
 
         #if ENABLED(EEPROM_CHITCHAT)
           else

commit 1dcfe193acaac8a26d789dcd4e949bb9613f3b58
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 19:09:40 2018 -0600

    Optimize some serial strings

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1f8921f206..a27cf80563 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2266,7 +2266,7 @@ void MarlinSettings::reset(
       }
       CONFIG_ECHO_START;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHO_P(port, "  M852 I");
+        SERIAL_ECHOPGM_P(port, "  M852 I");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_ECHOPGM_P(port, " J");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xz_skew_factor), 6);
@@ -2274,7 +2274,7 @@ void MarlinSettings::reset(
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.yz_skew_factor), 6);
         SERIAL_EOL_P(port);
        #else
-        SERIAL_ECHO_P(port, "  M852 S");
+        SERIAL_ECHOPGM_P(port, "  M852 S");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_EOL_P(port);
       #endif
@@ -2289,7 +2289,7 @@ void MarlinSettings::reset(
         SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHO_P(port, "  M906");
+      SERIAL_ECHOPGM_P(port, "  M906");
       #if ENABLED(X_IS_TMC2130) || ENABLED(X_IS_TMC2208)
         SERIAL_ECHOPAIR_P(port, " X ", stepperX.getCurrent());
       #endif
@@ -2335,7 +2335,7 @@ void MarlinSettings::reset(
         SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHO_P(port, "  M914");
+      SERIAL_ECHOPGM_P(port, "  M914");
       #if ENABLED(X_IS_TMC2130)
         SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
       #endif

commit f7f8569bbfbd4210e6106e5abb036bb3b531353e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 08:09:36 2018 -0600

    Fix skew settings report precision
    
    Followup to changes from #8843

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 74224abf0a..1f8921f206 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2268,9 +2268,12 @@ void MarlinSettings::reset(
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         SERIAL_ECHO_P(port, "  M852 I");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
-        SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.xz_skew_factor));
-        SERIAL_ECHOLNPAIR_P(port, " K", LINEAR_UNIT(planner.yz_skew_factor));
-      #else
+        SERIAL_ECHOPGM_P(port, " J");
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xz_skew_factor), 6);
+        SERIAL_ECHOPGM_P(port, " K");
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.yz_skew_factor), 6);
+        SERIAL_EOL_P(port);
+       #else
         SERIAL_ECHO_P(port, "  M852 S");
         SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_EOL_P(port);

commit 90d011cc485b6af53c8691c6bae738213338fdb7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 06:27:22 2018 -0600

    Use ADD_PORT_ARG for all cases

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f76d1c80fb..74224abf0a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1421,7 +1421,7 @@ void MarlinSettings::postprocess() {
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
       if (!validating) report(
-        #if NUM_SERIAL > 1
+        #if ADD_PORT_ARG
           port
         #endif
       );
@@ -1432,13 +1432,13 @@ void MarlinSettings::postprocess() {
   }
 
   bool MarlinSettings::validate(
-    #if NUM_SERIAL > 1
+    #if ADD_PORT_ARG
       const int8_t port/*=-1*/
     #endif
   ) {
     validating = true;
     const bool success = _load(
-      #if NUM_SERIAL > 1
+      #if ADD_PORT_ARG
         port
       #endif
     );
@@ -1838,7 +1838,7 @@ void MarlinSettings::reset(
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay
-    #if NUM_SERIAL > 1
+    #if ADD_PORT_ARG
       , const int8_t port/*=-1*/
     #endif
   ) {

commit 429e6ba8a6a074c846a4b63e0f95d19fd1610880
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Fri Jan 19 15:24:13 2018 -0600

    Fix lcd_preheat dummy variable types

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d0a9539e2f..f76d1c80fb 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -547,9 +547,9 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(lcd_preheat_hotend_temp);
 
     #if DISABLED(ULTIPANEL)
-      constexpr int lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
-                    lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
-                    lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+      constexpr int16_t lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
+                        lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
+                        lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
     #endif
 
     EEPROM_WRITE(lcd_preheat_hotend_temp);
@@ -1076,7 +1076,7 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(lcd_preheat_hotend_temp);
 
       #if DISABLED(ULTIPANEL)
-        int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+        int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
       #endif
       EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
       EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats

commit cfd989d7c5e78be13784094d1f3dac9ba1583186
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Fri Jan 12 19:38:23 2018 -0600

    Fix EEPROM SettingsData for 32-bit architectures

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6ae28bc81c..d0a9539e2f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -71,6 +71,8 @@
   #include "../feature/fwretract.h"
 #endif
 
+#pragma pack(push, 1) // No padding between variables
+
 typedef struct PID { float Kp, Ki, Kd; } PID;
 typedef struct PIDC { float Kp, Ki, Kd, Kc; } PIDC;
 
@@ -170,9 +172,9 @@ typedef struct SettingsDataStruct {
   //
   // ULTIPANEL
   //
-  int lcd_preheat_hotend_temp[2],                       // M145 S0 H
-      lcd_preheat_bed_temp[2],                          // M145 S0 B
-      lcd_preheat_fan_speed[2];                         // M145 S0 F
+  int16_t lcd_preheat_hotend_temp[2],                   // M145 S0 H
+          lcd_preheat_bed_temp[2],                      // M145 S0 B
+          lcd_preheat_fan_speed[2];                     // M145 S0 F
 
   //
   // PIDTEMP
@@ -247,6 +249,8 @@ typedef struct SettingsDataStruct {
 
 } SettingsData;
 
+#pragma pack(pop)
+
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }

commit e633ce06c723d262dc570c74dc21efcadb9ea7a8
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Tue Jan 9 23:41:14 2018 -0600

    LCD contrast type mismatch  is back
    
    WORKS!

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d2680229a9..6ae28bc81c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -189,7 +189,7 @@ typedef struct SettingsDataStruct {
   //
   // HAS_LCD_CONTRAST
   //
-  uint16_t lcd_contrast;                                // M250 C
+  int16_t lcd_contrast;                                // M250 C
 
   //
   // FWRETRACT
@@ -596,7 +596,7 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(lcd_contrast);
 
     #if !HAS_LCD_CONTRAST
-      const uint16_t lcd_contrast = 32;
+      const int16_t lcd_contrast = 32;
     #endif
     EEPROM_WRITE(lcd_contrast);
 
@@ -1143,7 +1143,7 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(lcd_contrast);
 
       #if !HAS_LCD_CONTRAST
-        uint16_t lcd_contrast;
+        int16_t lcd_contrast;
       #endif
       EEPROM_READ(lcd_contrast);
 

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1ab2a26cf2..d2680229a9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -322,7 +322,7 @@ void MarlinSettings::postprocess() {
   #define EEPROM_WRITE(VAR) HAL::PersistentStore::write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
   #define EEPROM_READ_ALWAYS(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_error = true; }while(0)
+  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START_P(port); SERIAL_ERRORLNPGM_P(port, ERR); eeprom_error = true; }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
@@ -338,10 +338,16 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
 
-  bool MarlinSettings::size_error(const uint16_t size) {
+  bool MarlinSettings::size_error(const uint16_t size
+    #if ADD_PORT_ARG
+      , const int8_t port/*=-1*/
+    #endif
+  ) {
     if (size != datasize()) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM("EEPROM datasize error.");
+      #if ENABLED(EEPROM_CHITCHAT)
+        SERIAL_ERROR_START_P(port);
+        SERIAL_ERRORLNPGM_P(port, "EEPROM datasize error.");
+      #endif
       return true;
     }
     return false;
@@ -350,7 +356,11 @@ void MarlinSettings::postprocess() {
   /**
    * M500 - Store Configuration
    */
-  bool MarlinSettings::save() {
+  bool MarlinSettings::save(
+    #if ADD_PORT_ARG
+      const int8_t port/*=-1*/
+    #endif
+  ) {
     float dummy = 0.0f;
     char ver[4] = "ERR";
 
@@ -810,10 +820,10 @@ void MarlinSettings::postprocess() {
 
       // Report storage size
       #if ENABLED(EEPROM_CHITCHAT)
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPAIR("Settings Stored (", eeprom_size);
-        SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
-        SERIAL_ECHOLNPGM(")");
+        SERIAL_ECHO_START_P(port);
+        SERIAL_ECHOPAIR_P(port, "Settings Stored (", eeprom_size);
+        SERIAL_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)final_crc);
+        SERIAL_ECHOLNPGM_P(port, ")");
       #endif
 
       eeprom_error |= size_error(eeprom_size);
@@ -834,7 +844,11 @@ void MarlinSettings::postprocess() {
   /**
    * M501 - Retrieve Configuration
    */
-  bool MarlinSettings::_load() {
+  bool MarlinSettings::_load(
+    #if ADD_PORT_ARG
+      const int8_t port/*=-1*/
+    #endif
+  ) {
     uint16_t working_crc = 0;
 
     EEPROM_START();
@@ -852,10 +866,10 @@ void MarlinSettings::postprocess() {
         stored_ver[1] = '\0';
       }
       #if ENABLED(EEPROM_CHITCHAT)
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPGM("EEPROM version mismatch ");
-        SERIAL_ECHOPAIR("(EEPROM=", stored_ver);
-        SERIAL_ECHOLNPGM(" Marlin=" EEPROM_VERSION ")");
+        SERIAL_ECHO_START_P(port);
+        SERIAL_ECHOPGM_P(port, "EEPROM version mismatch ");
+        SERIAL_ECHOPAIR_P(port, "(EEPROM=", stored_ver);
+        SERIAL_ECHOLNPGM_P(port, " Marlin=" EEPROM_VERSION ")");
       #endif
       if (!validating) reset();
       eeprom_error = true;
@@ -1334,28 +1348,28 @@ void MarlinSettings::postprocess() {
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)));
-        SERIAL_ECHOLNPAIR(" Size: ", datasize());
+        SERIAL_ECHO_START_P(port);
+        SERIAL_ECHOPAIR_P(port, "Index: ", int(eeprom_index - (EEPROM_OFFSET)));
+        SERIAL_ECHOLNPAIR_P(port, " Size: ", datasize());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ERROR_START();
-          SERIAL_ERRORPGM("EEPROM CRC mismatch - (stored) ");
-          SERIAL_ERROR(stored_crc);
-          SERIAL_ERRORPGM(" != ");
-          SERIAL_ERROR(working_crc);
-          SERIAL_ERRORLNPGM(" (calculated)!");
+          SERIAL_ERROR_START_P(port);
+          SERIAL_ERRORPGM_P(port, "EEPROM CRC mismatch - (stored) ");
+          SERIAL_ERROR_P(port, stored_crc);
+          SERIAL_ERRORPGM_P(port, " != ");
+          SERIAL_ERROR_P(port, working_crc);
+          SERIAL_ERRORLNPGM_P(port, " (calculated)!");
         #endif
       }
       else if (!validating) {
         #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ECHO_START();
-          SERIAL_ECHO(version);
-          SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-          SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
-          SERIAL_ECHOLNPGM(")");
+          SERIAL_ECHO_START_P(port);
+          SERIAL_ECHO_P(port, version);
+          SERIAL_ECHOPAIR_P(port, " stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+          SERIAL_ECHOPAIR_P(port, " bytes; crc ", (uint32_t)working_crc);
+          SERIAL_ECHOLNPGM_P(port, ")");
         #endif
       }
 
@@ -1368,18 +1382,18 @@ void MarlinSettings::postprocess() {
 
         if (!validating) {
           if (!ubl.sanity_check()) {
-            SERIAL_EOL();
+            SERIAL_EOL_P(port);
             #if ENABLED(EEPROM_CHITCHAT)
               ubl.echo_name();
-              SERIAL_ECHOLNPGM(" initialized.\n");
+              SERIAL_ECHOLNPGM_P(port, " initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_PROTOCOLPGM("?Can't enable ");
+              SERIAL_PROTOCOLPGM_P(port, "?Can't enable ");
               ubl.echo_name();
-              SERIAL_PROTOCOLLNPGM(".");
+              SERIAL_PROTOCOLLNPGM_P(port, ".");
             #endif
             ubl.reset();
           }
@@ -1387,14 +1401,14 @@ void MarlinSettings::postprocess() {
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
             #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_ECHOPAIR("Mesh ", ubl.storage_slot);
-              SERIAL_ECHOLNPGM(" loaded from storage.");
+              SERIAL_ECHOPAIR_P(port, "Mesh ", ubl.storage_slot);
+              SERIAL_ECHOLNPGM_P(port, " loaded from storage.");
             #endif
           }
           else {
             ubl.reset();
             #if ENABLED(EEPROM_CHITCHAT)
-              SERIAL_ECHOLNPGM("UBL System reset()");
+              SERIAL_ECHOLNPGM_P(port, "UBL System reset()");
             #endif
           }
         }
@@ -1402,22 +1416,42 @@ void MarlinSettings::postprocess() {
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      if (!validating) report();
+      if (!validating) report(
+        #if NUM_SERIAL > 1
+          port
+        #endif
+      );
     #endif
     EEPROM_FINISH();
 
     return !eeprom_error;
   }
 
-  bool MarlinSettings::validate() {
+  bool MarlinSettings::validate(
+    #if NUM_SERIAL > 1
+      const int8_t port/*=-1*/
+    #endif
+  ) {
     validating = true;
-    const bool success = _load();
+    const bool success = _load(
+      #if NUM_SERIAL > 1
+        port
+      #endif
+    );
     validating = false;
     return success;
   }
 
-  bool MarlinSettings::load() {
-    if (validate()) return _load();
+  bool MarlinSettings::load(
+    #if ADD_PORT_ARG
+      const int8_t port/*=-1*/
+    #endif
+  ) {
+    if (validate()) return _load(
+      #if ADD_PORT_ARG
+        port
+      #endif
+    );
     reset();
     return true;
   }
@@ -1524,9 +1558,15 @@ void MarlinSettings::postprocess() {
 
 #else // !EEPROM_SETTINGS
 
-  bool MarlinSettings::save() {
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM("EEPROM disabled");
+  bool MarlinSettings::save(
+    #if ADD_PORT_ARG
+      const int8_t port/*=-1*/
+    #endif
+  ) {
+    #if ENABLED(EEPROM_CHITCHAT)
+      SERIAL_ERROR_START_P(port);
+      SERIAL_ERRORLNPGM_P(port, "EEPROM disabled");
+    #endif
     return false;
   }
 
@@ -1535,7 +1575,11 @@ void MarlinSettings::postprocess() {
 /**
  * M502 - Reset Configuration
  */
-void MarlinSettings::reset() {
+void MarlinSettings::reset(
+  #if ADD_PORT_ARG
+    const int8_t port/*=-1*/
+  #endif
+) {
   static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
   static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
   LOOP_XYZE_N(i) {
@@ -1775,22 +1819,25 @@ void MarlinSettings::reset() {
   postprocess();
 
   #if ENABLED(EEPROM_CHITCHAT)
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPGM("Hardcoded Default Settings Loaded");
+    SERIAL_ECHO_START_P(port);
+    SERIAL_ECHOLNPGM_P(port, "Hardcoded Default Settings Loaded");
   #endif
 }
 
 #if DISABLED(DISABLE_M503)
 
-  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START_P(port); }while(0)
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
-  void MarlinSettings::report(const bool forReplay) {
-
+  void MarlinSettings::report(const bool forReplay
+    #if NUM_SERIAL > 1
+      , const int8_t port/*=-1*/
+    #endif
+  ) {
     /**
      * Announce current units, in case inches are being displayed
      */
@@ -1798,14 +1845,14 @@ void MarlinSettings::reset() {
     #if ENABLED(INCH_MODE_SUPPORT)
       #define LINEAR_UNIT(N) (float(N) / parser.linear_unit_factor)
       #define VOLUMETRIC_UNIT(N) (float(N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
-      SERIAL_ECHOPGM("  G2");
-      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
-      SERIAL_ECHOPGM(" ; Units in ");
+      SERIAL_ECHOPGM_P(port, "  G2");
+      SERIAL_CHAR_P(port, parser.linear_unit_factor == 1.0 ? '1' : '0');
+      SERIAL_ECHOPGM_P(port, " ; Units in ");
       serialprintPGM(parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
     #else
       #define LINEAR_UNIT(N) (N)
       #define VOLUMETRIC_UNIT(N) (N)
-      SERIAL_ECHOLNPGM("  G21    ; Units in mm");
+      SERIAL_ECHOLNPGM_P(port, "  G21    ; Units in mm");
     #endif
 
     #if ENABLED(ULTIPANEL)
@@ -1815,18 +1862,18 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START;
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
         #define TEMP_UNIT(N) parser.to_temp_units(N)
-        SERIAL_ECHOPGM("  M149 ");
-        SERIAL_CHAR(parser.temp_units_code());
-        SERIAL_ECHOPGM(" ; Units in ");
-        serialprintPGM(parser.temp_units_name());
+        SERIAL_ECHOPGM_P(port, "  M149 ");
+        SERIAL_CHAR_P(port, parser.temp_units_code());
+        SERIAL_ECHOPGM_P(port, " ; Units in ");
+        serialprintPGM_P(port, parser.temp_units_name());
       #else
         #define TEMP_UNIT(N) (N)
-        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
+        SERIAL_ECHOLNPGM_P(port, "  M149 C ; Units in Celsius");
       #endif
 
     #endif
 
-    SERIAL_EOL();
+    SERIAL_EOL_P(port);
 
     #if DISABLED(NO_VOLUMETRICS)
 
@@ -1835,32 +1882,32 @@ void MarlinSettings::reset() {
        */
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOPGM("Filament settings:");
+        SERIAL_ECHOPGM_P(port, "Filament settings:");
         if (parser.volumetric_enabled)
-          SERIAL_EOL();
+          SERIAL_EOL_P(port);
         else
-          SERIAL_ECHOLNPGM(" Disabled");
+          SERIAL_ECHOLNPGM_P(port, " Disabled");
       }
 
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-      SERIAL_EOL();
+      SERIAL_ECHOPAIR_P(port, "  M200 D", LINEAR_UNIT(planner.filament_size[0]));
+      SERIAL_EOL_P(port);
       #if EXTRUDERS > 1
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
-        SERIAL_EOL();
+        SERIAL_ECHOPAIR_P(port, "  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
+        SERIAL_EOL_P(port);
         #if EXTRUDERS > 2
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR_P(port, "  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
+          SERIAL_EOL_P(port);
           #if EXTRUDERS > 3
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
-            SERIAL_EOL();
+            SERIAL_ECHOPAIR_P(port, "  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
+            SERIAL_EOL_P(port);
             #if EXTRUDERS > 4
               CONFIG_ECHO_START;
-              SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
-              SERIAL_EOL();
+              SERIAL_ECHOPAIR_P(port, "  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
+              SERIAL_EOL_P(port);
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2
@@ -1868,118 +1915,118 @@ void MarlinSettings::reset() {
 
       if (!parser.volumetric_enabled) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("  M200 D0");
+        SERIAL_ECHOLNPGM_P(port, "  M200 D0");
       }
 
     #endif // !NO_VOLUMETRICS
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Steps per unit:");
+      SERIAL_ECHOLNPGM_P(port, "Steps per unit:");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M92 X", LINEAR_UNIT(planner.axis_steps_per_mm[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.axis_steps_per_mm[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.axis_steps_per_mm[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M92 X", LINEAR_UNIT(planner.axis_steps_per_mm[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.axis_steps_per_mm[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.axis_steps_per_mm[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS]));
     #endif
-    SERIAL_EOL();
+    SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR("  M92 T", (int)i);
-        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS + i]));
+        SERIAL_ECHOPAIR_P(port, "  M92 T", (int)i);
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS + i]));
       }
     #endif
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum feedrates (units/s):");
+      SERIAL_ECHOLNPGM_P(port, "Maximum feedrates (units/s):");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M203 X", LINEAR_UNIT(planner.max_feedrate_mm_s[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_feedrate_mm_s[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_feedrate_mm_s[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M203 X", LINEAR_UNIT(planner.max_feedrate_mm_s[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_feedrate_mm_s[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_feedrate_mm_s[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS]));
     #endif
-    SERIAL_EOL();
+    SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR("  M203 T", (int)i);
-        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS + i]));
+        SERIAL_ECHOPAIR_P(port, "  M203 T", (int)i);
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS + i]));
       }
     #endif
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Maximum Acceleration (units/s2):");
+      SERIAL_ECHOLNPGM_P(port, "Maximum Acceleration (units/s2):");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M201 X", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Z_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M201 X", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Z_AXIS]));
     #if DISABLED(DISTINCT_E_FACTORS)
-      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS]));
     #endif
-    SERIAL_EOL();
+    SERIAL_EOL_P(port);
     #if ENABLED(DISTINCT_E_FACTORS)
       CONFIG_ECHO_START;
       for (uint8_t i = 0; i < E_STEPPERS; i++) {
-        SERIAL_ECHOPAIR("  M201 T", (int)i);
-        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS + i]));
+        SERIAL_ECHOPAIR_P(port, "  M201 T", (int)i);
+        SERIAL_ECHOLNPAIR_P(port, " E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS + i]));
       }
     #endif
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
+      SERIAL_ECHOLNPGM_P(port, "Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M204 P", LINEAR_UNIT(planner.acceleration));
-    SERIAL_ECHOPAIR(" R", LINEAR_UNIT(planner.retract_acceleration));
-    SERIAL_ECHOLNPAIR(" T", LINEAR_UNIT(planner.travel_acceleration));
+    SERIAL_ECHOPAIR_P(port, "  M204 P", LINEAR_UNIT(planner.acceleration));
+    SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(planner.retract_acceleration));
+    SERIAL_ECHOLNPAIR_P(port, " T", LINEAR_UNIT(planner.travel_acceleration));
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_us> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
+      SERIAL_ECHOLNPGM_P(port, "Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_us> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
     }
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
-    SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
-    SERIAL_ECHOPAIR(" B", planner.min_segment_time_us);
-    SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
-    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
-    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
-    SERIAL_ECHOLNPAIR(" E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+    SERIAL_ECHOPAIR_P(port, "  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
+    SERIAL_ECHOPAIR_P(port, " T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
+    SERIAL_ECHOPAIR_P(port, " B", planner.min_segment_time_us);
+    SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
+    SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
+    SERIAL_ECHOLNPAIR_P(port, " E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
 
     #if HAS_M206_COMMAND
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Home offset:");
+        SERIAL_ECHOLNPGM_P(port, "Home offset:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(home_offset[Y_AXIS]));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(home_offset[Z_AXIS]));
+      SERIAL_ECHOPAIR_P(port, "  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(home_offset[Y_AXIS]));
+      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(home_offset[Z_AXIS]));
     #endif
 
     #if HOTENDS > 1
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Hotend offsets:");
+        SERIAL_ECHOLNPGM_P(port, "Hotend offsets:");
       }
       CONFIG_ECHO_START;
       for (uint8_t e = 1; e < HOTENDS; e++) {
-        SERIAL_ECHOPAIR("  M218 T", (int)e);
-        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
-        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
+        SERIAL_ECHOPAIR_P(port, "  M218 T", (int)e);
+        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
+        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
         #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) ||ENABLED(PARKING_EXTRUDER)
-          SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
+          SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
         #endif
-        SERIAL_EOL();
+        SERIAL_EOL_P(port);
       }
     #endif
 
@@ -1992,7 +2039,7 @@ void MarlinSettings::reset() {
 
         if (!forReplay) {
           CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
+          SERIAL_ECHOLNPGM_P(port, "Mesh Bed Leveling:");
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
@@ -2000,46 +2047,46 @@ void MarlinSettings::reset() {
         if (!forReplay) {
           CONFIG_ECHO_START;
           ubl.echo_name();
-          SERIAL_ECHOLNPGM(":");
+          SERIAL_ECHOLNPGM_P(port, ":");
         }
 
       #elif HAS_ABL
 
         if (!forReplay) {
           CONFIG_ECHO_START;
-          SERIAL_ECHOLNPGM("Auto Bed Leveling:");
+          SERIAL_ECHOLNPGM_P(port, "Auto Bed Leveling:");
         }
 
       #endif
 
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
+      SERIAL_ECHOPAIR_P(port, "  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
+        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(planner.z_fade_height));
       #endif
-      SERIAL_EOL();
+      SERIAL_EOL_P(port);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
           for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
-            SERIAL_ECHOPAIR(" Y", (int)py + 1);
-            SERIAL_ECHOPGM(" Z");
-            SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
-            SERIAL_EOL();
+            SERIAL_ECHOPAIR_P(port, "  G29 S3 X", (int)px + 1);
+            SERIAL_ECHOPAIR_P(port, " Y", (int)py + 1);
+            SERIAL_ECHOPGM_P(port, " Z");
+            SERIAL_PROTOCOL_F_P(port, LINEAR_UNIT(mbl.z_values[px][py]), 5);
+            SERIAL_EOL_P(port);
           }
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
-          SERIAL_EOL();
+          SERIAL_EOL_P(port);
           ubl.report_state();
-          SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
-          SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
-          SERIAL_ECHOLNPGM(" meshes.\n");
+          SERIAL_ECHOLNPAIR_P(port, "\nActive Mesh Slot: ", ubl.storage_slot);
+          SERIAL_ECHOPAIR_P(port, "EEPROM can hold ", calc_num_meshes());
+          SERIAL_ECHOLNPGM_P(port, " meshes.\n");
         }
 
       #endif
@@ -2047,59 +2094,62 @@ void MarlinSettings::reset() {
     #endif // HAS_LEVELING
 
     #if ENABLED(DELTA)
+
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Endstop adjustment:");
+        SERIAL_ECHOLNPGM_P(port, "Endstop adjustment:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
+      SERIAL_ECHOPAIR_P(port, "  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
+      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
+        SERIAL_ECHOLNPGM_P(port, "Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
-      SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
-      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(delta_height));
-      SERIAL_ECHOPAIR(" S", delta_segments_per_second);
-      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
-      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
-      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
-      SERIAL_EOL();
+      SERIAL_ECHOPAIR_P(port, "  M665 L", LINEAR_UNIT(delta_diagonal_rod));
+      SERIAL_ECHOPAIR_P(port, " R", LINEAR_UNIT(delta_radius));
+      SERIAL_ECHOPAIR_P(port, " H", LINEAR_UNIT(delta_height));
+      SERIAL_ECHOPAIR_P(port, " S", delta_segments_per_second);
+      SERIAL_ECHOPAIR_P(port, " B", LINEAR_UNIT(delta_calibration_radius));
+      SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
+      SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
+      SERIAL_EOL_P(port);
 
     #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Endstop adjustment:");
+        SERIAL_ECHOLNPGM_P(port, "Endstop adjustment:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPGM("  M666");
+      SERIAL_ECHOPGM_P(port, "  M666");
       #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(endstops.x_endstop_adj));
+        SERIAL_ECHOPAIR_P(port, " X", LINEAR_UNIT(endstops.x_endstop_adj));
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstops.y_endstop_adj));
+        SERIAL_ECHOPAIR_P(port, " Y", LINEAR_UNIT(endstops.y_endstop_adj));
       #endif
       #if ENABLED(Z_DUAL_ENDSTOPS)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(endstops.z_endstop_adj));
+        SERIAL_ECHOPAIR_P(port, " Z", LINEAR_UNIT(endstops.z_endstop_adj));
       #endif
-      SERIAL_EOL();
-    #endif // DELTA
+      SERIAL_EOL_P(port);
+
+    #endif // [XYZ]_DUAL_ENDSTOPS
 
     #if ENABLED(ULTIPANEL)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Material heatup parameters:");
+        SERIAL_ECHOLNPGM_P(port, "Material heatup parameters:");
       }
       for (uint8_t i = 0; i < COUNT(lcd_preheat_hotend_temp); i++) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M145 S", (int)i);
-        SERIAL_ECHOPAIR(" H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
-        SERIAL_ECHOPAIR(" B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
-        SERIAL_ECHOLNPAIR(" F", lcd_preheat_fan_speed[i]);
+        SERIAL_ECHOPAIR_P(port, "  M145 S", (int)i);
+        SERIAL_ECHOPAIR_P(port, " H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
+        SERIAL_ECHOPAIR_P(port, " B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
+        SERIAL_ECHOLNPAIR_P(port, " F", lcd_preheat_fan_speed[i]);
       }
     #endif // ULTIPANEL
 
@@ -2107,22 +2157,22 @@ void MarlinSettings::reset() {
 
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("PID settings:");
+        SERIAL_ECHOLNPGM_P(port, "PID settings:");
       }
       #if ENABLED(PIDTEMP)
         #if HOTENDS > 1
           if (forReplay) {
             HOTEND_LOOP() {
               CONFIG_ECHO_START;
-              SERIAL_ECHOPAIR("  M301 E", e);
-              SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
-              SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
-              SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
+              SERIAL_ECHOPAIR_P(port, "  M301 E", e);
+              SERIAL_ECHOPAIR_P(port, " P", PID_PARAM(Kp, e));
+              SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, e)));
+              SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, e)));
               #if ENABLED(PID_EXTRUSION_SCALING)
-                SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
-                if (e == 0) SERIAL_ECHOPAIR(" L", lpq_len);
+                SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, e));
+                if (e == 0) SERIAL_ECHOPAIR_P(port, " L", lpq_len);
               #endif
-              SERIAL_EOL();
+              SERIAL_EOL_P(port);
             }
           }
           else
@@ -2130,23 +2180,23 @@ void MarlinSettings::reset() {
         // !forReplay || HOTENDS == 1
         {
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
-          SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
-          SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
+          SERIAL_ECHOPAIR_P(port, "  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
+          SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(PID_PARAM(Ki, 0)));
+          SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(PID_PARAM(Kd, 0)));
           #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
-            SERIAL_ECHOPAIR(" L", lpq_len);
+            SERIAL_ECHOPAIR_P(port, " C", PID_PARAM(Kc, 0));
+            SERIAL_ECHOPAIR_P(port, " L", lpq_len);
           #endif
-          SERIAL_EOL();
+          SERIAL_EOL_P(port);
         }
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M304 P", thermalManager.bedKp);
-        SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bedKi));
-        SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bedKd));
-        SERIAL_EOL();
+        SERIAL_ECHOPAIR_P(port, "  M304 P", thermalManager.bedKp);
+        SERIAL_ECHOPAIR_P(port, " I", unscalePID_i(thermalManager.bedKi));
+        SERIAL_ECHOPAIR_P(port, " D", unscalePID_d(thermalManager.bedKd));
+        SERIAL_EOL_P(port);
       #endif
 
     #endif // PIDTEMP || PIDTEMPBED
@@ -2154,39 +2204,39 @@ void MarlinSettings::reset() {
     #if HAS_LCD_CONTRAST
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("LCD Contrast:");
+        SERIAL_ECHOLNPGM_P(port, "LCD Contrast:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M250 C", lcd_contrast);
+      SERIAL_ECHOLNPAIR_P(port, "  M250 C", lcd_contrast);
     #endif
 
     #if ENABLED(FWRETRACT)
 
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Retract: S<length> F<units/m> Z<lift>");
+        SERIAL_ECHOLNPGM_P(port, "Retract: S<length> F<units/m> Z<lift>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(fwretract.retract_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.swap_retract_length));
-      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(fwretract.retract_zlift));
+      SERIAL_ECHOPAIR_P(port, "  M207 S", LINEAR_UNIT(fwretract.retract_length));
+      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.swap_retract_length));
+      SERIAL_ECHOPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR_P(port, " Z", LINEAR_UNIT(fwretract.retract_zlift));
 
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Recover: S<length> F<units/m>");
+        SERIAL_ECHOLNPGM_P(port, "Recover: S<length> F<units/m>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(fwretract.retract_recover_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.swap_retract_recover_length));
-      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_recover_feedrate_mm_s)));
+      SERIAL_ECHOPAIR_P(port, "  M208 S", LINEAR_UNIT(fwretract.retract_recover_length));
+      SERIAL_ECHOPAIR_P(port, " W", LINEAR_UNIT(fwretract.swap_retract_recover_length));
+      SERIAL_ECHOLNPAIR_P(port, " F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_recover_feedrate_mm_s)));
 
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
+        SERIAL_ECHOLNPGM_P(port, "Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+      SERIAL_ECHOLNPAIR_P(port, "  M209 S", fwretract.autoretract_enabled ? 1 : 0);
 
     #endif // FWRETRACT
 
@@ -2196,10 +2246,10 @@ void MarlinSettings::reset() {
     #if HAS_BED_PROBE
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Z-Probe Offset (mm):");
+        SERIAL_ECHOLNPGM_P(port, "Z-Probe Offset (mm):");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M851 Z", LINEAR_UNIT(zprobe_zoffset));
+      SERIAL_ECHOLNPAIR_P(port, "  M851 Z", LINEAR_UNIT(zprobe_zoffset));
     #endif
 
     /**
@@ -2208,18 +2258,18 @@ void MarlinSettings::reset() {
     #if ENABLED(SKEW_CORRECTION_GCODE)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Skew Factor: ");
+        SERIAL_ECHOLNPGM_P(port, "Skew Factor: ");
       }
       CONFIG_ECHO_START;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHO("  M852 I");
-        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor), 6);
-        SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.xz_skew_factor));
-        SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
+        SERIAL_ECHO_P(port, "  M852 I");
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
+        SERIAL_ECHOPAIR_P(port, " J", LINEAR_UNIT(planner.xz_skew_factor));
+        SERIAL_ECHOLNPAIR_P(port, " K", LINEAR_UNIT(planner.yz_skew_factor));
       #else
-        SERIAL_ECHO("  M852 S");
-        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor), 6);
-        SERIAL_EOL();
+        SERIAL_ECHO_P(port, "  M852 S");
+        SERIAL_ECHO_F_P(port, LINEAR_UNIT(planner.xy_skew_factor), 6);
+        SERIAL_EOL_P(port);
       #endif
     #endif
 
@@ -2229,44 +2279,44 @@ void MarlinSettings::reset() {
     #if HAS_TRINAMIC
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Stepper driver current:");
+        SERIAL_ECHOLNPGM_P(port, "Stepper driver current:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHO("  M906");
+      SERIAL_ECHO_P(port, "  M906");
       #if ENABLED(X_IS_TMC2130) || ENABLED(X_IS_TMC2208)
-        SERIAL_ECHOPAIR(" X ", stepperX.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " X ", stepperX.getCurrent());
       #endif
       #if ENABLED(Y_IS_TMC2130) || ENABLED(Y_IS_TMC2208)
-        SERIAL_ECHOPAIR(" Y ", stepperY.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Y ", stepperY.getCurrent());
       #endif
       #if ENABLED(Z_IS_TMC2130) || ENABLED(Z_IS_TMC2208)
-        SERIAL_ECHOPAIR(" Z ", stepperZ.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Z ", stepperZ.getCurrent());
       #endif
       #if ENABLED(X2_IS_TMC2130) || ENABLED(X2_IS_TMC2208)
-        SERIAL_ECHOPAIR(" X2 ", stepperX2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.getCurrent());
       #endif
       #if ENABLED(Y2_IS_TMC2130) || ENABLED(Y2_IS_TMC2208)
-        SERIAL_ECHOPAIR(" Y2 ", stepperY2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.getCurrent());
       #endif
       #if ENABLED(Z2_IS_TMC2130) || ENABLED(Z2_IS_TMC2208)
-        SERIAL_ECHOPAIR(" Z2 ", stepperZ2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " Z2 ", stepperZ2.getCurrent());
       #endif
       #if ENABLED(E0_IS_TMC2130) || ENABLED(E0_IS_TMC2208)
-        SERIAL_ECHOPAIR(" E0 ", stepperE0.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " E0 ", stepperE0.getCurrent());
       #endif
       #if ENABLED(E1_IS_TMC2130) || ENABLED(E1_IS_TMC2208)
-        SERIAL_ECHOPAIR(" E1 ", stepperE1.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " E1 ", stepperE1.getCurrent());
       #endif
       #if ENABLED(E2_IS_TMC2130) || ENABLED(E2_IS_TMC2208)
-        SERIAL_ECHOPAIR(" E2 ", stepperE2.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " E2 ", stepperE2.getCurrent());
       #endif
       #if ENABLED(E3_IS_TMC2130) || ENABLED(E3_IS_TMC2208)
-        SERIAL_ECHOPAIR(" E3 ", stepperE3.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " E3 ", stepperE3.getCurrent());
       #endif
       #if ENABLED(E4_IS_TMC2130) || ENABLED(E4_IS_TMC2208)
-        SERIAL_ECHOPAIR(" E4 ", stepperE4.getCurrent());
+        SERIAL_ECHOPAIR_P(port, " E4 ", stepperE4.getCurrent());
       #endif
-      SERIAL_EOL();
+      SERIAL_EOL_P(port);
     #endif
 
     /**
@@ -2275,23 +2325,23 @@ void MarlinSettings::reset() {
     #if ENABLED(SENSORLESS_HOMING)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Sensorless homing threshold:");
+        SERIAL_ECHOLNPGM_P(port, "Sensorless homing threshold:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHO("  M914");
+      SERIAL_ECHO_P(port, "  M914");
       #if ENABLED(X_IS_TMC2130)
-        SERIAL_ECHOPAIR(" X", stepperX.sgt());
+        SERIAL_ECHOPAIR_P(port, " X", stepperX.sgt());
       #endif
       #if ENABLED(X2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" X2 ", stepperX2.sgt());
+        SERIAL_ECHOPAIR_P(port, " X2 ", stepperX2.sgt());
       #endif
       #if ENABLED(Y_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Y", stepperY.sgt());
+        SERIAL_ECHOPAIR_P(port, " Y", stepperY.sgt());
       #endif
       #if ENABLED(X2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Y2 ", stepperY2.sgt());
+        SERIAL_ECHOPAIR_P(port, " Y2 ", stepperY2.sgt());
       #endif
-      SERIAL_EOL();
+      SERIAL_EOL_P(port);
     #endif
 
     /**
@@ -2300,23 +2350,23 @@ void MarlinSettings::reset() {
     #if ENABLED(LIN_ADVANCE)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Linear Advance:");
+        SERIAL_ECHOLNPGM_P(port, "Linear Advance:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M900 K", planner.extruder_advance_k);
-      SERIAL_ECHOLNPAIR(" R", planner.advance_ed_ratio);
+      SERIAL_ECHOPAIR_P(port, "  M900 K", planner.extruder_advance_k);
+      SERIAL_ECHOLNPAIR_P(port, " R", planner.advance_ed_ratio);
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_START;
       if (!forReplay) {
-        SERIAL_ECHOLNPGM("Stepper motor currents:");
+        SERIAL_ECHOLNPGM_P(port, "Stepper motor currents:");
         CONFIG_ECHO_START;
       }
-      SERIAL_ECHOPAIR("  M907 X", stepper.motor_current_setting[0]);
-      SERIAL_ECHOPAIR(" Z", stepper.motor_current_setting[1]);
-      SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
-      SERIAL_EOL();
+      SERIAL_ECHOPAIR_P(port, "  M907 X", stepper.motor_current_setting[0]);
+      SERIAL_ECHOPAIR_P(port, " Z", stepper.motor_current_setting[1]);
+      SERIAL_ECHOPAIR_P(port, " E", stepper.motor_current_setting[2]);
+      SERIAL_EOL_P(port);
     #endif
 
     /**
@@ -2325,30 +2375,30 @@ void MarlinSettings::reset() {
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Filament load/unload lengths:");
+        SERIAL_ECHOLNPGM_P(port, "Filament load/unload lengths:");
       }
       CONFIG_ECHO_START;
       #if EXTRUDERS == 1
-        SERIAL_ECHOPAIR("  M603 L", LINEAR_UNIT(filament_change_load_length[0]));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+        SERIAL_ECHOPAIR_P(port, "  M603 L", LINEAR_UNIT(filament_change_load_length[0]));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
       #else
-        SERIAL_ECHOPAIR("  M603 T0 L", LINEAR_UNIT(filament_change_load_length[0]));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+        SERIAL_ECHOPAIR_P(port, "  M603 T0 L", LINEAR_UNIT(filament_change_load_length[0]));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[0]));
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M603 T1 L", LINEAR_UNIT(filament_change_load_length[1]));
-        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[1]));
+        SERIAL_ECHOPAIR_P(port, "  M603 T1 L", LINEAR_UNIT(filament_change_load_length[1]));
+        SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[1]));
         #if EXTRUDERS > 2
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M603 T2 L", LINEAR_UNIT(filament_change_load_length[2]));
-          SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[2]));
+          SERIAL_ECHOPAIR_P(port, "  M603 T2 L", LINEAR_UNIT(filament_change_load_length[2]));
+          SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[2]));
           #if EXTRUDERS > 3
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M603 T3 L", LINEAR_UNIT(filament_change_load_length[3]));
-            SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[3]));
+            SERIAL_ECHOPAIR_P(port, "  M603 T3 L", LINEAR_UNIT(filament_change_load_length[3]));
+            SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[3]));
             #if EXTRUDERS > 4
               CONFIG_ECHO_START;
-              SERIAL_ECHOPAIR("  M603 T4 L", LINEAR_UNIT(filament_change_load_length[4]));
-              SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[4]));
+              SERIAL_ECHOPAIR_P(port, "  M603 T4 L", LINEAR_UNIT(filament_change_load_length[4]));
+              SERIAL_ECHOLNPAIR_P(port, " U", LINEAR_UNIT(filament_change_unload_length[4]));
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2

commit 7e000e6af460d32203f1278fa4b20c4b72d2d26d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 18:33:44 2018 -0600

    More EEPROM field debugging (#9123)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 88e44555f2..1ab2a26cf2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V49"
+#define EEPROM_VERSION "V50"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -165,9 +165,6 @@ typedef struct SettingsDataStruct {
     float x_endstop_adj,                                // M666 X
           y_endstop_adj,                                // M666 Y
           z_endstop_adj;                                // M666 Z
-    float xyz_dual_reserved[8];
-  #else
-    float xyz_dual_placeholder[11];
   #endif
 
   //
@@ -496,7 +493,9 @@ void MarlinSettings::postprocess() {
 
     // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
+
       _FIELD_TEST(delta_height);
+
       EEPROM_WRITE(delta_height);              // 1 float
       EEPROM_WRITE(delta_endstop_adj);         // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
@@ -506,7 +505,9 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
     #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+
       _FIELD_TEST(x_endstop_adj);
+
       // Write dual endstops in X, Y, Z order. Unused = 0.0
       dummy = 0.0f;
       #if ENABLED(X_DUAL_ENDSTOPS)
@@ -527,11 +528,6 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(dummy);
       #endif
 
-      for (uint8_t q = 8; q--;) EEPROM_WRITE(dummy);
-
-    #else
-      dummy = 0.0f;
-      for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
     #endif
 
     _FIELD_TEST(lcd_preheat_hotend_temp);
@@ -571,6 +567,8 @@ void MarlinSettings::postprocess() {
 
     } // Hotends Loop
 
+    _FIELD_TEST(lpq_len);
+
     #if DISABLED(PID_EXTRUSION_SCALING)
       int lpq_len = 20;
     #endif
@@ -612,7 +610,9 @@ void MarlinSettings::postprocess() {
     //
     // Volumetric & Filament Size
     //
+
     _FIELD_TEST(parser_volumetric_enabled);
+
     #if DISABLED(NO_VOLUMETRICS)
 
       EEPROM_WRITE(parser.volumetric_enabled);
@@ -635,7 +635,9 @@ void MarlinSettings::postprocess() {
     //
     // Save TMC2130 or TMC2208 Configuration, and placeholder values
     //
+
     _FIELD_TEST(tmc_stepper_current);
+
     uint16_t currents[11] = {
       #if HAS_TRINAMIC
         #if X_IS_TRINAMIC
@@ -724,7 +726,9 @@ void MarlinSettings::postprocess() {
     //
     // Linear Advance
     //
+
     _FIELD_TEST(planner_extruder_advance_k);
+
     #if ENABLED(LIN_ADVANCE)
       EEPROM_WRITE(planner.extruder_advance_k);
       EEPROM_WRITE(planner.advance_ed_ratio);
@@ -734,6 +738,8 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(dummy);
     #endif
 
+    _FIELD_TEST(motor_current_setting);
+
     #if HAS_MOTOR_CURRENT_PWM
       for (uint8_t q = 3; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
     #else
@@ -744,7 +750,9 @@ void MarlinSettings::postprocess() {
     //
     // CNC Coordinate Systems
     //
+
     _FIELD_TEST(coordinate_system);
+
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
       EEPROM_WRITE(coordinate_system); // 27 floats
     #else
@@ -755,7 +763,9 @@ void MarlinSettings::postprocess() {
     //
     // Skew correction factors
     //
+
     _FIELD_TEST(planner_xy_skew_factor);
+
     #if ENABLED(SKEW_CORRECTION)
       EEPROM_WRITE(planner.xy_skew_factor);
       EEPROM_WRITE(planner.xz_skew_factor);
@@ -768,7 +778,9 @@ void MarlinSettings::postprocess() {
     //
     // Advanced Pause filament load & unload lengths
     //
+
     _FIELD_TEST(filament_change_unload_length);
+
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
         if (q < COUNT(filament_change_unload_length)) dummy = filament_change_unload_length[q];
@@ -856,6 +868,8 @@ void MarlinSettings::postprocess() {
 
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
+      _FIELD_TEST(esteppers);
+
       // Number of esteppers may change
       uint8_t esteppers;
       EEPROM_READ_ALWAYS(esteppers);
@@ -891,6 +905,8 @@ void MarlinSettings::postprocess() {
       // Home Offset (M206)
       //
 
+      _FIELD_TEST(home_offset);
+
       #if !HAS_HOME_OFFSET
         float home_offset[XYZ];
       #endif
@@ -941,6 +957,8 @@ void MarlinSettings::postprocess() {
         for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
       #endif // MESH_BED_LEVELING
 
+      _FIELD_TEST(zprobe_zoffset);
+
       #if !HAS_BED_PROBE
         float zprobe_zoffset;
       #endif
@@ -984,6 +1002,8 @@ void MarlinSettings::postprocess() {
       // Unified Bed Leveling active state
       //
 
+      _FIELD_TEST(planner_leveling_active);
+
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EEPROM_READ(planner.leveling_active);
         EEPROM_READ(ubl.storage_slot);
@@ -998,6 +1018,9 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(DELTA)
+
+        _FIELD_TEST(delta_height);
+
         EEPROM_READ(delta_height);              // 1 float
         EEPROM_READ(delta_endstop_adj);         // 3 floats
         EEPROM_READ(delta_radius);              // 1 float
@@ -1008,6 +1031,8 @@ void MarlinSettings::postprocess() {
 
       #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 
+        _FIELD_TEST(x_endstop_adj);
+
         #if ENABLED(X_DUAL_ENDSTOPS)
           EEPROM_READ(endstops.x_endstop_adj);  // 1 float
         #else
@@ -1024,18 +1049,14 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(dummy);
         #endif
 
-        for (uint8_t q=8; q--;) EEPROM_READ(dummy);
-
-      #else
-
-        for (uint8_t q=11; q--;) EEPROM_READ(dummy);
-
       #endif
 
       //
       // LCD Preheat settings
       //
 
+      _FIELD_TEST(lcd_preheat_hotend_temp);
+
       #if DISABLED(ULTIPANEL)
         int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
       #endif
@@ -1079,6 +1100,8 @@ void MarlinSettings::postprocess() {
       // PID Extrusion Scaling
       //
 
+      _FIELD_TEST(lpq_len);
+
       #if DISABLED(PID_EXTRUSION_SCALING)
         int lpq_len;
       #endif
@@ -1103,6 +1126,8 @@ void MarlinSettings::postprocess() {
       // LCD Contrast
       //
 
+      _FIELD_TEST(lcd_contrast);
+
       #if !HAS_LCD_CONTRAST
         uint16_t lcd_contrast;
       #endif
@@ -1130,6 +1155,9 @@ void MarlinSettings::postprocess() {
       //
       // Volumetric & Filament Size
       //
+
+      _FIELD_TEST(parser_volumetric_enabled);
+
       #if DISABLED(NO_VOLUMETRICS)
 
         EEPROM_READ(parser.volumetric_enabled);
@@ -1150,10 +1178,13 @@ void MarlinSettings::postprocess() {
       //
       // TMC2130 Stepper Current
       //
+
+      _FIELD_TEST(tmc_stepper_current);
+
       #if HAS_TRINAMIC
-        #define SET_CURR(N,Q) stepper##Q.setCurrent(val[N] ? val[N] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
-        uint16_t val[11];
-        EEPROM_READ(val);
+        #define SET_CURR(N,Q) stepper##Q.setCurrent(currents[N] ? currents[N] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
+        uint16_t currents[11];
+        EEPROM_READ(currents);
         if (!validating) {
           #if X_IS_TRINAMIC
             SET_CURR(0, X);
@@ -1227,6 +1258,8 @@ void MarlinSettings::postprocess() {
       // Linear Advance
       //
 
+      _FIELD_TEST(planner_extruder_advance_k);
+
       #if ENABLED(LIN_ADVANCE)
         EEPROM_READ(planner.extruder_advance_k);
         EEPROM_READ(planner.advance_ed_ratio);
@@ -1239,6 +1272,8 @@ void MarlinSettings::postprocess() {
       // Motor Current PWM
       //
 
+      _FIELD_TEST(motor_current_setting);
+
       #if HAS_MOTOR_CURRENT_PWM
         for (uint8_t q = 3; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
       #else
@@ -1250,6 +1285,8 @@ void MarlinSettings::postprocess() {
       // CNC Coordinate System
       //
 
+      _FIELD_TEST(coordinate_system);
+
       #if ENABLED(CNC_COORDINATE_SYSTEMS)
         if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
         EEPROM_READ(gcode.coordinate_system);                  // 27 floats
@@ -1261,6 +1298,8 @@ void MarlinSettings::postprocess() {
       // Skew correction factors
       //
 
+      _FIELD_TEST(planner_xy_skew_factor);
+
       #if ENABLED(SKEW_CORRECTION_GCODE)
         EEPROM_READ(planner.xy_skew_factor);
         #if ENABLED(SKEW_CORRECTION_FOR_Z)
@@ -1278,6 +1317,8 @@ void MarlinSettings::postprocess() {
       // Advanced Pause filament load & unload lengths
       //
 
+      _FIELD_TEST(filament_change_unload_length);
+
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
           EEPROM_READ(dummy);

commit 99516572b18bab723997d60467284241252c52a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 7 20:48:46 2018 -0600

    Fix TMC current read from EEPROM

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f2a2c366be..88e44555f2 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1151,7 +1151,7 @@ void MarlinSettings::postprocess() {
       // TMC2130 Stepper Current
       //
       #if HAS_TRINAMIC
-        #define SET_CURR(N,Q) stepper##Q.setCurrent(val[N], R_SENSE, HOLD_MULTIPLIER)
+        #define SET_CURR(N,Q) stepper##Q.setCurrent(val[N] ? val[N] : Q##_CURRENT, R_SENSE, HOLD_MULTIPLIER)
         uint16_t val[11];
         EEPROM_READ(val);
         if (!validating) {

commit 60d07f20e75c11cb1281880d5f19f45ce942dac1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 6 23:47:29 2018 -0600

    Make mbl.has_mesh() a method

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9926b4d972..f2a2c366be 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -37,7 +37,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V48"
+#define EEPROM_VERSION "V49"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -114,7 +114,6 @@ typedef struct SettingsDataStruct {
   //
   // MESH_BED_LEVELING
   //
-  bool mbl_has_mesh;                                    // mbl.has_mesh
   float mbl_z_offset;                                   // mbl.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   #if ENABLED(MESH_BED_LEVELING)
@@ -297,7 +296,6 @@ void MarlinSettings::postprocess() {
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     refresh_bed_level();
-    //set_bed_leveling_enabled(leveling_is_on);
   #endif
 
   #if HAS_MOTOR_CURRENT_PWM
@@ -425,16 +423,13 @@ void MarlinSettings::postprocess() {
         "MBL Z array is the wrong size."
       );
       const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
-      EEPROM_WRITE(mbl.has_mesh);
       EEPROM_WRITE(mbl.z_offset);
       EEPROM_WRITE(mesh_num_x);
       EEPROM_WRITE(mesh_num_y);
       EEPROM_WRITE(mbl.z_values);
     #else // For disabled MBL write a default mesh
-      const bool leveling_is_on = false;
       dummy = 0.0f;
       const uint8_t mesh_num_x = 3, mesh_num_y = 3;
-      EEPROM_WRITE(leveling_is_on);
       EEPROM_WRITE(dummy); // z_offset
       EEPROM_WRITE(mesh_num_x);
       EEPROM_WRITE(mesh_num_y);
@@ -925,18 +920,13 @@ void MarlinSettings::postprocess() {
       // Mesh (Manual) Bed Leveling
       //
 
-      bool leveling_is_on;
       uint8_t mesh_num_x, mesh_num_y;
-      EEPROM_READ_ALWAYS(leveling_is_on);
       EEPROM_READ(dummy);
       EEPROM_READ_ALWAYS(mesh_num_x);
       EEPROM_READ_ALWAYS(mesh_num_y);
 
       #if ENABLED(MESH_BED_LEVELING)
-        if (!validating) {
-          mbl.has_mesh = leveling_is_on;
-          mbl.z_offset = dummy;
-        }
+        if (!validating) mbl.z_offset = dummy;
         if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
           // EEPROM data fits the current mesh
           EEPROM_READ(mbl.z_values);

commit 2b5a9be49c4a7fe36a25842e341fc5ad1d81e52e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 6 20:55:57 2018 -0600

    Fix M503 skew output
    
    Followup to 19e75ccf8618b3691f14f6d51b1e73f56fb1355e

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 48dd33649a..9926b4d972 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2187,7 +2187,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
       #else
         SERIAL_ECHO("  M852 S");
-        SERIAL_ECHO_F(planner.xy_skew_factor, 6);
+        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_EOL();
       #endif
     #endif

commit 702c8acdd5ac009363c12e532924b828a3e804ac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 5 19:00:26 2018 -0600

    Settings FIELD_TEST fix

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 6c4d21f96c..48dd33649a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -330,10 +330,10 @@ void MarlinSettings::postprocess() {
   #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_error = true; }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
-    #define _FIELD_TEST(FIELD)                                          \
-      EEPROM_ASSERT(                                                    \
-        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD),  \
-        "Field " STRINGIFY(FIELD) " mismatch."                          \
+    #define _FIELD_TEST(FIELD) \
+      EEPROM_ASSERT( \
+        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
+        "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else
     #define _FIELD_TEST(FIELD) NOOP
@@ -357,7 +357,7 @@ void MarlinSettings::postprocess() {
    */
   bool MarlinSettings::save() {
     float dummy = 0.0f;
-    char ver[4] = "000";
+    char ver[4] = "ERR";
 
     uint16_t working_crc = 0;
 
@@ -840,7 +840,7 @@ void MarlinSettings::postprocess() {
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
-      if (stored_ver[0] != 'V') {
+      if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }

commit e89f1453ab75cd2e1cdb0a314bc61e46082234a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 21:09:56 2018 -0600

    UBL G29 works without settings.load()

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 914cb25d25..6c4d21f96c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -343,10 +343,6 @@ void MarlinSettings::postprocess() {
 
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    int16_t MarlinSettings::meshes_begin;
-  #endif
-
   bool MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
       SERIAL_ERROR_START();
@@ -1337,9 +1333,6 @@ void MarlinSettings::postprocess() {
       }
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        meshes_begin = (eeprom_index + 32) & 0xFFF8;  // Pad the end of configuration data so it
-                                                      // can float up or down a little bit without
-                                                      // disrupting the mesh data
         ubl.report_state();
 
         if (!validating) {
@@ -1408,12 +1401,13 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
-    uint16_t MarlinSettings::calc_num_meshes() {
-      //obviously this will get more sophisticated once we've added an actual MAT
-
-      if (meshes_begin <= 0) return 0;
+    int16_t MarlinSettings::meshes_start_index() {
+      return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
+                                                          // or down a little bit without disrupting the mesh data
+    }
 
-      return (meshes_end - meshes_begin) / sizeof(ubl.z_values);
+    uint16_t MarlinSettings::calc_num_meshes() {
+      return (meshes_end - meshes_start_index()) / sizeof(ubl.z_values);
     }
 
     void MarlinSettings::store_mesh(const int8_t slot) {

commit 950be70a338dbc9644fda62f262b82f69858cb8a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 20:27:17 2018 -0600

    Add FIELD_TEST to validate storage

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4067a6629a..914cb25d25 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -40,6 +40,10 @@
 #define EEPROM_VERSION "V48"
 #define EEPROM_OFFSET 100
 
+// Check the integrity of data offsets.
+// Can be disabled for production build.
+//#define DEBUG_EEPROM_READWRITE
+
 #include "configuration_store.h"
 #include "endstops.h"
 #include "planner.h"
@@ -323,7 +327,17 @@ void MarlinSettings::postprocess() {
   #define EEPROM_WRITE(VAR) HAL::PersistentStore::write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
   #define EEPROM_READ_ALWAYS(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_read_error = true; }while(0)
+  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_error = true; }while(0)
+
+  #if ENABLED(DEBUG_EEPROM_READWRITE)
+    #define _FIELD_TEST(FIELD)                                          \
+      EEPROM_ASSERT(                                                    \
+        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD),  \
+        "Field " STRINGIFY(FIELD) " mismatch."                          \
+      )
+  #else
+    #define _FIELD_TEST(FIELD) NOOP
+  #endif
 
   const char version[4] = EEPROM_VERSION;
 
@@ -363,6 +377,8 @@ void MarlinSettings::postprocess() {
 
     working_crc = 0; // clear before first "real data"
 
+    _FIELD_TEST(esteppers);
+
     const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
 
@@ -377,6 +393,9 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
     EEPROM_WRITE(planner.min_segment_time_us);
     EEPROM_WRITE(planner.max_jerk);
+
+    _FIELD_TEST(home_offset);
+
     #if !HAS_HOME_OFFSET
       const float home_offset[XYZ] = { 0 };
     #endif
@@ -426,6 +445,8 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
     #endif // MESH_BED_LEVELING
 
+    _FIELD_TEST(zprobe_zoffset);
+
     #if !HAS_BED_PROBE
       const float zprobe_zoffset = 0;
     #endif
@@ -470,6 +491,8 @@ void MarlinSettings::postprocess() {
       for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummy);
     #endif // AUTO_BED_LEVELING_BILINEAR
 
+    _FIELD_TEST(planner_leveling_active);
+
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       EEPROM_WRITE(planner.leveling_active);
       EEPROM_WRITE(ubl.storage_slot);
@@ -482,6 +505,7 @@ void MarlinSettings::postprocess() {
 
     // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
+      _FIELD_TEST(delta_height);
       EEPROM_WRITE(delta_height);              // 1 float
       EEPROM_WRITE(delta_endstop_adj);         // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
@@ -491,6 +515,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 
     #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+      _FIELD_TEST(x_endstop_adj);
       // Write dual endstops in X, Y, Z order. Unused = 0.0
       dummy = 0.0f;
       #if ENABLED(X_DUAL_ENDSTOPS)
@@ -518,6 +543,8 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
     #endif
 
+    _FIELD_TEST(lcd_preheat_hotend_temp);
+
     #if DISABLED(ULTIPANEL)
       constexpr int lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
                     lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
@@ -567,6 +594,8 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(thermalManager.bedKd);
     #endif
 
+    _FIELD_TEST(lcd_contrast);
+
     #if !HAS_LCD_CONTRAST
       const uint16_t lcd_contrast = 32;
     #endif
@@ -592,6 +621,7 @@ void MarlinSettings::postprocess() {
     //
     // Volumetric & Filament Size
     //
+    _FIELD_TEST(parser_volumetric_enabled);
     #if DISABLED(NO_VOLUMETRICS)
 
       EEPROM_WRITE(parser.volumetric_enabled);
@@ -614,6 +644,7 @@ void MarlinSettings::postprocess() {
     //
     // Save TMC2130 or TMC2208 Configuration, and placeholder values
     //
+    _FIELD_TEST(tmc_stepper_current);
     uint16_t currents[11] = {
       #if HAS_TRINAMIC
         #if X_IS_TRINAMIC
@@ -702,7 +733,7 @@ void MarlinSettings::postprocess() {
     //
     // Linear Advance
     //
-
+    _FIELD_TEST(planner_extruder_advance_k);
     #if ENABLED(LIN_ADVANCE)
       EEPROM_WRITE(planner.extruder_advance_k);
       EEPROM_WRITE(planner.advance_ed_ratio);
@@ -722,7 +753,7 @@ void MarlinSettings::postprocess() {
     //
     // CNC Coordinate Systems
     //
-
+    _FIELD_TEST(coordinate_system);
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
       EEPROM_WRITE(coordinate_system); // 27 floats
     #else
@@ -733,7 +764,7 @@ void MarlinSettings::postprocess() {
     //
     // Skew correction factors
     //
-
+    _FIELD_TEST(planner_xy_skew_factor);
     #if ENABLED(SKEW_CORRECTION)
       EEPROM_WRITE(planner.xy_skew_factor);
       EEPROM_WRITE(planner.xz_skew_factor);
@@ -746,6 +777,7 @@ void MarlinSettings::postprocess() {
     //
     // Advanced Pause filament load & unload lengths
     //
+    _FIELD_TEST(filament_change_unload_length);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
         if (q < COUNT(filament_change_unload_length)) dummy = filament_change_unload_length[q];

commit 760c912ab98c028c5bcc99e04de4fc34744eb2a4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 20:01:25 2018 -0600

    Add data size validation

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4ced3576ce..4067a6629a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -249,6 +249,8 @@ typedef struct SettingsDataStruct {
 
 MarlinSettings settings;
 
+uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
+
 /**
  * Post-process after Retrieve or Reset
  */
@@ -331,6 +333,15 @@ void MarlinSettings::postprocess() {
     int16_t MarlinSettings::meshes_begin;
   #endif
 
+  bool MarlinSettings::size_error(const uint16_t size) {
+    if (size != datasize()) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM("EEPROM datasize error.");
+      return true;
+    }
+    return false;
+  }
+
   /**
    * M500 - Store Configuration
    */
@@ -750,7 +761,7 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
-    // Validate CRC
+    // Validate CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
@@ -769,6 +780,8 @@ void MarlinSettings::postprocess() {
         SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
         SERIAL_ECHOLNPGM(")");
       #endif
+
+      eeprom_error |= size_error(eeprom_size);
     }
     EEPROM_FINISH();
 
@@ -1260,19 +1273,14 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
       #endif
 
-      if (working_crc == stored_crc) {
-        if (!validating) {
-          postprocess();
-          #if ENABLED(EEPROM_CHITCHAT)
-            SERIAL_ECHO_START();
-            SERIAL_ECHO(version);
-            SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-            SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
-            SERIAL_ECHOLNPGM(")");
-          #endif
-        }
+      eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
+      if (eeprom_error) {
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)));
+        SERIAL_ECHOLNPAIR(" Size: ", datasize());
       }
-      else {
+      else if (working_crc != stored_crc) {
+        eeprom_error = true;
         #if ENABLED(EEPROM_CHITCHAT)
           SERIAL_ERROR_START();
           SERIAL_ERRORPGM("EEPROM CRC mismatch - (stored) ");
@@ -1281,7 +1289,19 @@ void MarlinSettings::postprocess() {
           SERIAL_ERROR(working_crc);
           SERIAL_ERRORLNPGM(" (calculated)!");
         #endif
-        reset();
+      }
+      else if (!validating) {
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_ECHO_START();
+          SERIAL_ECHO(version);
+          SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+          SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
+          SERIAL_ECHOLNPGM(")");
+        #endif
+      }
+
+      if (!validating) {
+        if (eeprom_error) reset(); else postprocess();
       }
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)

commit b91ca168fbb09807b8203fc1791e4095a57e34af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 19:59:43 2018 -0600

    Add a struct defining EEPROM storage

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4415a043a6..4ced3576ce 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,174 +36,21 @@
  *
  */
 
+// Change EEPROM version if the structure changes
 #define EEPROM_VERSION "V48"
-
-// Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
-/**
- * V48 EEPROM Layout:
- *
- *  100  Version                                    (char x4)
- *  104  EEPROM CRC16                               (uint16_t)
- *
- *  106            E_STEPPERS                       (uint8_t)
- *  107  M92 XYZE  planner.axis_steps_per_mm        (float x4 ... x8) + 64
- *  123  M203 XYZE planner.max_feedrate_mm_s        (float x4 ... x8) + 64
- *  139  M201 XYZE planner.max_acceleration_mm_per_s2 (uint32_t x4 ... x8) + 64
- *  155  M204 P    planner.acceleration             (float)
- *  159  M204 R    planner.retract_acceleration     (float)
- *  163  M204 T    planner.travel_acceleration      (float)
- *  167  M205 S    planner.min_feedrate_mm_s        (float)
- *  171  M205 T    planner.min_travel_feedrate_mm_s (float)
- *  175  M205 B    planner.min_segment_time_us      (ulong)
- *  179  M205 X    planner.max_jerk[X_AXIS]         (float)
- *  183  M205 Y    planner.max_jerk[Y_AXIS]         (float)
- *  187  M205 Z    planner.max_jerk[Z_AXIS]         (float)
- *  191  M205 E    planner.max_jerk[E_AXIS]         (float)
- *  195  M206 XYZ  home_offset                      (float x3)
- *  207  M218 XYZ  hotend_offset                    (float x3 per additional hotend) +16
- *
- * Global Leveling:                                 4 bytes
- *  219            z_fade_height                    (float)
- *
- * MESH_BED_LEVELING:                               43 bytes
- *  223  M420 S    planner.leveling_active          (bool)
- *  224            mbl.z_offset                     (float)
- *  228            GRID_MAX_POINTS_X                (uint8_t)
- *  229            GRID_MAX_POINTS_Y                (uint8_t)
- *  230 G29 S3 XYZ z_values[][]                     (float x9, up to float x81) +288
- *
- * HAS_BED_PROBE:                                   4 bytes
- *  266  M851      zprobe_zoffset                   (float)
- *
- * ABL_PLANAR:                                      36 bytes
- *  270            planner.bed_level_matrix         (matrix_3x3 = float x9)
- *
- * AUTO_BED_LEVELING_BILINEAR:                      46 bytes
- *  306            GRID_MAX_POINTS_X                (uint8_t)
- *  307            GRID_MAX_POINTS_Y                (uint8_t)
- *  308            bilinear_grid_spacing            (int x2)
- *  312  G29 L F   bilinear_start                   (int x2)
- *  316            z_values[][]                     (float x9, up to float x256) +988
- *
- * AUTO_BED_LEVELING_UBL:                           2 bytes
- *  352  G29 A     planner.leveling_active          (bool)
- *  353  G29 S     ubl.storage_slot                 (int8_t)
- *
- * DELTA:                                           44 bytes
- *  354  M666 H    delta_height                     (float)
- *  358  M666 XYZ  delta_endstop_adj                (float x3)
- *  370  M665 R    delta_radius                     (float)
- *  374  M665 L    delta_diagonal_rod               (float)
- *  378  M665 S    delta_segments_per_second        (float)
- *  382  M665 B    delta_calibration_radius         (float)
- *  386  M665 X    delta_tower_angle_trim[A]        (float)
- *  390  M665 Y    delta_tower_angle_trim[B]        (float)
- *  394  M665 Z    delta_tower_angle_trim[C]        (float)
- *
- * [XYZ]_DUAL_ENDSTOPS:                             12 bytes
- *  354  M666 X    x_endstop_adj                    (float)
- *  358  M666 Y    y_endstop_adj                    (float)
- *  362  M666 Z    z_endstop_adj                    (float)
- *
- * ULTIPANEL:                                       6 bytes
- *  398  M145 S0 H lcd_preheat_hotend_temp          (int x2)
- *  402  M145 S0 B lcd_preheat_bed_temp             (int x2)
- *  406  M145 S0 F lcd_preheat_fan_speed            (int x2)
- *
- * PIDTEMP:                                         82 bytes
- *  410  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
- *  426  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
- *  442  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
- *  458  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  474  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  490  M301 L        lpq_len                      (int)
- *
- * PIDTEMPBED:                                      12 bytes
- *  492  M304 PID  bedKp, .bedKi, .bedKd            (float x3)
- *
- * DOGLCD:                                          2 bytes
- *  504  M250 C    lcd_contrast                     (uint16_t)
- *
- * FWRETRACT:                                       33 bytes
- *  506  M209 S    autoretract_enabled              (bool)
- *  507  M207 S    retract_length                   (float)
- *  511  M207 F    retract_feedrate_mm_s            (float)
- *  515  M207 Z    retract_zlift                    (float)
- *  519  M208 S    retract_recover_length           (float)
- *  523  M208 F    retract_recover_feedrate_mm_s    (float)
- *  527  M207 W    swap_retract_length              (float)
- *  531  M208 W    swap_retract_recover_length      (float)
- *  535  M208 R    swap_retract_recover_feedrate_mm_s (float)
- *
- * Volumetric Extrusion:                            21 bytes
- *  539  M200 D    parser.volumetric_enabled        (bool)
- *  540  M200 T D  planner.filament_size            (float x5) (T0..4)
- *
- * HAS_TRINAMIC:                                    22 bytes
- *  560  M906 X    Stepper X current                (uint16_t)
- *  562  M906 Y    Stepper Y current                (uint16_t)
- *  564  M906 Z    Stepper Z current                (uint16_t)
- *  566  M906 X2   Stepper X2 current               (uint16_t)
- *  568  M906 Y2   Stepper Y2 current               (uint16_t)
- *  570  M906 Z2   Stepper Z2 current               (uint16_t)
- *  572  M906 E0   Stepper E0 current               (uint16_t)
- *  574  M906 E1   Stepper E1 current               (uint16_t)
- *  576  M906 E2   Stepper E2 current               (uint16_t)
- *  578  M906 E3   Stepper E3 current               (uint16_t)
- *  580  M906 E4   Stepper E4 current               (uint16_t)
- *
- * SENSORLESS_HOMING:                               4 bytes
- *  582  M914 X    Stepper X and X2 threshold       (int16_t)
- *  584  M914 Y    Stepper Y and Y2 threshold       (int16_t)
- *
- * LIN_ADVANCE:                                     8 bytes
- *  586  M900 K    extruder_advance_k               (float)
- *  590  M900 WHD  advance_ed_ratio                 (float)
- *
- * HAS_MOTOR_CURRENT_PWM:
- *  594  M907 X    Stepper XY current               (uint32_t)
- *  598  M907 Z    Stepper Z current                (uint32_t)
- *  602  M907 E    Stepper E current                (uint32_t)
- *
- * CNC_COORDINATE_SYSTEMS:                          108 bytes
- *  606  G54-G59.3 coordinate_system                (float x 27)
- *
- * SKEW_CORRECTION:                                 12 bytes
- *  714  M852 I    planner.xy_skew_factor           (float)
- *  718  M852 J    planner.xz_skew_factor           (float)
- *  722  M852 K    planner.yz_skew_factor           (float)
- *
- * ADVANCED_PAUSE_FEATURE:                          40 bytes
- *  726  M603 T U  filament_change_unload_length    (float x 5) (T0..4)
- *  746  M603 T L  filament_change_load_length      (float x 5) (T0..4)
- *
- *  766                                   Minimum end-point
- * 2295 (766 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
- *
- * ========================================================================
- * meshes_begin (between max and min end-point, directly above)
- * -- MESHES --
- * meshes_end
- * -- MAT (Mesh Allocation Table) --                128 bytes (placeholder size)
- * mat_end = E2END (0xFFF)
- *
- */
 #include "configuration_store.h"
-
-MarlinSettings settings;
-
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
+#include "../libs/vector_3.h"
+#include "../gcode/gcode.h"
 #include "../Marlin.h"
 
-#include "../gcode/parser.h"
-
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
@@ -220,13 +67,196 @@ MarlinSettings settings;
   #include "../feature/fwretract.h"
 #endif
 
-#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-  float new_z_fade_height;
-#endif
+typedef struct PID { float Kp, Ki, Kd; } PID;
+typedef struct PIDC { float Kp, Ki, Kd, Kc; } PIDC;
+
+/**
+ * Current EEPROM Layout
+ *
+ * Keep this data structure up to date so
+ * EEPROM size is known at compile time!
+ */
+typedef struct SettingsDataStruct {
+  char      version[4];                                 // Vnn\0
+  uint16_t  crc;                                        // Data Checksum
+
+  //
+  // DISTINCT_E_FACTORS
+  //
+  uint8_t   esteppers;                                  // XYZE_N - XYZ
+
+  float     planner_axis_steps_per_mm[XYZE_N],          // M92 XYZE   planner.axis_steps_per_mm[XYZE_N]
+            planner_max_feedrate_mm_s[XYZE_N];          // M203 XYZE  planner.max_feedrate_mm_s[XYZE_N]
+  uint32_t  planner_max_acceleration_mm_per_s2[XYZE_N]; // M201 XYZE  planner.max_acceleration_mm_per_s2[XYZE_N]
+  float     planner_acceleration,                       // M204 P     planner.acceleration
+            planner_retract_acceleration,               // M204 R     planner.retract_acceleration
+            planner_travel_acceleration,                // M204 T     planner.travel_acceleration
+            planner_min_feedrate_mm_s,                  // M205 S     planner.min_feedrate_mm_s
+            planner_min_travel_feedrate_mm_s;           // M205 T     planner.min_travel_feedrate_mm_s
+  uint32_t  planner_min_segment_time_us;                // M205 B     planner.min_segment_time_us
+  float     planner_max_jerk[XYZE];                     // M205 XYZE  planner.max_jerk[XYZE]
+
+  float home_offset[XYZ];                               // M206 XYZ
+
+  #if HOTENDS > 1
+    float hotend_offset[XYZ][HOTENDS - 1];              // M218 XYZ
+  #endif
+
+  //
+  // ENABLE_LEVELING_FADE_HEIGHT
+  //
+  float planner_z_fade_height;                          // M420 Zn  planner.z_fade_height
+
+  //
+  // MESH_BED_LEVELING
+  //
+  bool mbl_has_mesh;                                    // mbl.has_mesh
+  float mbl_z_offset;                                   // mbl.z_offset
+  uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  #if ENABLED(MESH_BED_LEVELING)
+    float mbl_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y]; // mbl.z_values
+  #else
+    float mbl_z_values[3][3];
+  #endif
+
+  //
+  // HAS_BED_PROBE
+  //
+  float zprobe_zoffset;                                 // M851 Z
+
+  //
+  // ABL_PLANAR
+  //
+  matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
+
+  //
+  // AUTO_BED_LEVELING_BILINEAR
+  //
+  uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  int bilinear_grid_spacing[2],
+      bilinear_start[2];                                // G29 L F
+  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y]; // G29
+  #else
+    float z_values[3][3];
+  #endif
+
+  //
+  // AUTO_BED_LEVELING_UBL
+  //
+  bool planner_leveling_active;                         // M420 S  planner.leveling_active
+  int8_t ubl_storage_slot;                              // ubl.storage_slot
+
+  //
+  // DELTA / [XYZ]_DUAL_ENDSTOPS
+  //
+  #if ENABLED(DELTA)
+    float delta_height,                                 // M666 H
+          delta_endstop_adj[ABC],                       // M666 XYZ
+          delta_radius,                                 // M665 R
+          delta_diagonal_rod,                           // M665 L
+          delta_segments_per_second,                    // M665 S
+          delta_calibration_radius,                     // M665 B
+          delta_tower_angle_trim[ABC];                  // M665 XYZ
+  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+    float x_endstop_adj,                                // M666 X
+          y_endstop_adj,                                // M666 Y
+          z_endstop_adj;                                // M666 Z
+    float xyz_dual_reserved[8];
+  #else
+    float xyz_dual_placeholder[11];
+  #endif
+
+  //
+  // ULTIPANEL
+  //
+  int lcd_preheat_hotend_temp[2],                       // M145 S0 H
+      lcd_preheat_bed_temp[2],                          // M145 S0 B
+      lcd_preheat_fan_speed[2];                         // M145 S0 F
+
+  //
+  // PIDTEMP
+  //
+  PIDC hotendPID[MAX_EXTRUDERS];                        // M301 En PIDC / M303 En U
+
+  int lpq_len;                                          // M301 L
+
+  //
+  // PIDTEMPBED
+  //
+  PID bedPID;                                           // M304 PID / M303 E-1 U
+
+  //
+  // HAS_LCD_CONTRAST
+  //
+  uint16_t lcd_contrast;                                // M250 C
+
+  //
+  // FWRETRACT
+  //
+  bool autoretract_enabled;                             // M209 S
+  float retract_length,                                 // M207 S
+        retract_feedrate_mm_s,                          // M207 F
+        retract_zlift,                                  // M207 Z
+        retract_recover_length,                         // M208 S
+        retract_recover_feedrate_mm_s,                  // M208 F
+        swap_retract_length,                            // M207 W
+        swap_retract_recover_length,                    // M208 W
+        swap_retract_recover_feedrate_mm_s;             // M208 R
+
+  //
+  // !NO_VOLUMETRIC
+  //
+  bool parser_volumetric_enabled;                       // M200 D  parser.volumetric_enabled
+  float planner_filament_size[MAX_EXTRUDERS];           // M200 T D  planner.filament_size[]
+
+  //
+  // HAS_TRINAMIC
+  //
+  uint16_t tmc_stepper_current[11];                     // M906 X Y Z X2 Y2 Z2 E0 E1 E2 E3 E4
+  int16_t tmc_sgt[2];                                   // M914 X Y
+
+  //
+  // LIN_ADVANCE
+  //
+  float planner_extruder_advance_k,                     // M900 K    planner.extruder_advance_k
+        planner_advance_ed_ratio;                       // M900 WHD  planner.advance_ed_ratio
+
+  //
+  // HAS_MOTOR_CURRENT_PWM
+  //
+  uint32_t motor_current_setting[XYZ];                  // M907 X Z E
+
+  //
+  // CNC_COORDINATE_SYSTEMS
+  //
+  float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ]; // G54-G59.3
+
+  //
+  // SKEW_CORRECTION
+  //
+  float planner_xy_skew_factor,                         // M852 I  planner.xy_skew_factor
+        planner_xz_skew_factor,                         // M852 J  planner.xz_skew_factor
+        planner_yz_skew_factor;                         // M852 K  planner.yz_skew_factor
+
+  //
+  // ADVANCED_PAUSE_FEATURE
+  //
+  float filament_change_unload_length[MAX_EXTRUDERS],   // M603 T U
+        filament_change_load_length[MAX_EXTRUDERS];     // M603 T L
+
+} SettingsData;
+
+MarlinSettings settings;
 
 /**
  * Post-process after Retrieve or Reset
  */
+
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+  float new_z_fade_height;
+#endif
+
 void MarlinSettings::postprocess() {
   const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
 
@@ -686,7 +716,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(coordinate_system); // 27 floats
     #else
       dummy = 0.0f;
-      for (uint8_t q = 27; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_WRITE(dummy);
     #endif
 
     //
@@ -723,11 +753,8 @@ void MarlinSettings::postprocess() {
     // Validate CRC
     //
     if (!eeprom_error) {
-      #if ENABLED(EEPROM_CHITCHAT)
-        const int eeprom_size = eeprom_index;
-      #endif
-
-      const uint16_t final_crc = working_crc;
+      const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
+                     final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
@@ -738,7 +765,7 @@ void MarlinSettings::postprocess() {
       // Report storage size
       #if ENABLED(EEPROM_CHITCHAT)
         SERIAL_ECHO_START();
-        SERIAL_ECHOPAIR("Settings Stored (", eeprom_size - (EEPROM_OFFSET));
+        SERIAL_ECHOPAIR("Settings Stored (", eeprom_size);
         SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
         SERIAL_ECHOLNPGM(")");
       #endif
@@ -1196,7 +1223,7 @@ void MarlinSettings::postprocess() {
         if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
         EEPROM_READ(gcode.coordinate_system);                  // 27 floats
       #else
-        for (uint8_t q = 27; q--;) EEPROM_READ(dummy);
+        for (uint8_t q = MAX_COORDINATE_SYSTEMS * XYZ; q--;) EEPROM_READ(dummy);
       #endif
 
       //

commit 51e0f2bee34e485d038ad0ca35fca7398a1576de
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 19:51:18 2018 -0600

    Add MarlinSettings::validate()

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 57a12f3223..4415a043a6 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -289,12 +289,13 @@ void MarlinSettings::postprocess() {
   #define EEPROM_FINISH() HAL::PersistentStore::access_finish()
   #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
   #define EEPROM_WRITE(VAR) HAL::PersistentStore::write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
-  #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
+  #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating)
+  #define EEPROM_READ_ALWAYS(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
   #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_read_error = true; }while(0)
 
   const char version[4] = EEPROM_VERSION;
 
-  bool MarlinSettings::eeprom_error;
+  bool MarlinSettings::eeprom_error, MarlinSettings::validating;
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     int16_t MarlinSettings::meshes_begin;
@@ -718,6 +719,9 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
     #endif
 
+    //
+    // Validate CRC
+    //
     if (!eeprom_error) {
       #if ENABLED(EEPROM_CHITCHAT)
         const int eeprom_size = eeprom_index;
@@ -741,6 +745,9 @@ void MarlinSettings::postprocess() {
     }
     EEPROM_FINISH();
 
+    //
+    // UBL Mesh
+    //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
@@ -752,16 +759,16 @@ void MarlinSettings::postprocess() {
   /**
    * M501 - Retrieve Configuration
    */
-  bool MarlinSettings::load() {
+  bool MarlinSettings::_load() {
     uint16_t working_crc = 0;
 
     EEPROM_START();
 
     char stored_ver[4];
-    EEPROM_READ(stored_ver);
+    EEPROM_READ_ALWAYS(stored_ver);
 
     uint16_t stored_crc;
-    EEPROM_READ(stored_crc);
+    EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
@@ -775,7 +782,8 @@ void MarlinSettings::postprocess() {
         SERIAL_ECHOPAIR("(EEPROM=", stored_ver);
         SERIAL_ECHOLNPGM(" Marlin=" EEPROM_VERSION ")");
       #endif
-      reset();
+      if (!validating) reset();
+      eeprom_error = true;
     }
     else {
       float dummy = 0;
@@ -787,7 +795,7 @@ void MarlinSettings::postprocess() {
 
       // Number of esteppers may change
       uint8_t esteppers;
-      EEPROM_READ(esteppers);
+      EEPROM_READ_ALWAYS(esteppers);
 
       //
       // Planner Motion
@@ -802,7 +810,7 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(tmp1);
       EEPROM_READ(tmp2);
       EEPROM_READ(tmp3);
-      LOOP_XYZE_N(i) {
+      if (!validating) LOOP_XYZE_N(i) {
         planner.axis_steps_per_mm[i]          = i < XYZ + esteppers ? tmp1[i] : def1[i < COUNT(def1) ? i : COUNT(def1) - 1];
         planner.max_feedrate_mm_s[i]          = i < XYZ + esteppers ? tmp2[i] : def2[i < COUNT(def2) ? i : COUNT(def2) - 1];
         planner.max_acceleration_mm_per_s2[i] = i < XYZ + esteppers ? tmp3[i] : def3[i < COUNT(def3) ? i : COUNT(def3) - 1];
@@ -851,21 +859,23 @@ void MarlinSettings::postprocess() {
 
       bool leveling_is_on;
       uint8_t mesh_num_x, mesh_num_y;
-      EEPROM_READ(leveling_is_on);
+      EEPROM_READ_ALWAYS(leveling_is_on);
       EEPROM_READ(dummy);
-      EEPROM_READ(mesh_num_x);
-      EEPROM_READ(mesh_num_y);
+      EEPROM_READ_ALWAYS(mesh_num_x);
+      EEPROM_READ_ALWAYS(mesh_num_y);
 
       #if ENABLED(MESH_BED_LEVELING)
-        mbl.has_mesh = leveling_is_on;
-        mbl.z_offset = dummy;
+        if (!validating) {
+          mbl.has_mesh = leveling_is_on;
+          mbl.z_offset = dummy;
+        }
         if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
           // EEPROM data fits the current mesh
           EEPROM_READ(mbl.z_values);
         }
         else {
           // EEPROM data is stale
-          mbl.reset();
+          if (!validating) mbl.reset();
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
         }
       #else
@@ -893,11 +903,11 @@ void MarlinSettings::postprocess() {
       //
 
       uint8_t grid_max_x, grid_max_y;
-      EEPROM_READ(grid_max_x);                       // 1 byte
-      EEPROM_READ(grid_max_y);                       // 1 byte
+      EEPROM_READ_ALWAYS(grid_max_x);                       // 1 byte
+      EEPROM_READ_ALWAYS(grid_max_y);                       // 1 byte
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
-          set_bed_leveling_enabled(false);
+          if (!validating) set_bed_leveling_enabled(false);
           EEPROM_READ(bilinear_grid_spacing);        // 2 ints
           EEPROM_READ(bilinear_start);               // 2 ints
           EEPROM_READ(z_values);                     // 9 to 256 floats
@@ -989,7 +999,7 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(dummy); // Kp
           if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
             // do not need to scale PID values as the values in EEPROM are already scaled
-            PID_PARAM(Kp, e) = dummy;
+            if (!validating) PID_PARAM(Kp, e) = dummy;
             EEPROM_READ(PID_PARAM(Ki, e));
             EEPROM_READ(PID_PARAM(Kd, e));
             #if ENABLED(PID_EXTRUSION_SCALING)
@@ -1023,7 +1033,7 @@ void MarlinSettings::postprocess() {
       #if ENABLED(PIDTEMPBED)
         EEPROM_READ(dummy); // bedKp
         if (dummy != DUMMY_PID_VALUE) {
-          thermalManager.bedKp = dummy;
+          if (!validating) thermalManager.bedKp = dummy;
           EEPROM_READ(thermalManager.bedKi);
           EEPROM_READ(thermalManager.bedKd);
         }
@@ -1068,7 +1078,8 @@ void MarlinSettings::postprocess() {
 
         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
           EEPROM_READ(dummy);
-          if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
+          if (!validating && q < COUNT(planner.filament_size))
+            planner.filament_size[q] = dummy;
         }
 
       #else
@@ -1081,55 +1092,48 @@ void MarlinSettings::postprocess() {
       //
       // TMC2130 Stepper Current
       //
-
-      uint16_t val;
       #if HAS_TRINAMIC
+        #define SET_CURR(N,Q) stepper##Q.setCurrent(val[N], R_SENSE, HOLD_MULTIPLIER)
+        uint16_t val[11];
         EEPROM_READ(val);
-        #if X_IS_TRINAMIC
-          stepperX.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if Y_IS_TRINAMIC
-          stepperY.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if Z_IS_TRINAMIC
-          stepperZ.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if X2_IS_TRINAMIC
-          stepperX2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if Y2_IS_TRINAMIC
-          stepperY2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if Z2_IS_TRINAMIC
-          stepperZ2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if E0_IS_TRINAMIC
-          stepperE0.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if E1_IS_TRINAMIC
-          stepperE1.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if E2_IS_TRINAMIC
-          stepperE2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if E3_IS_TRINAMIC
-          stepperE3.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
-        EEPROM_READ(val);
-        #if E4_IS_TRINAMIC
-          stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
-        #endif
+        if (!validating) {
+          #if X_IS_TRINAMIC
+            SET_CURR(0, X);
+          #endif
+          #if Y_IS_TRINAMIC
+            SET_CURR(1, Y);
+          #endif
+          #if Z_IS_TRINAMIC
+            SET_CURR(2, Z);
+          #endif
+          #if X2_IS_TRINAMIC
+            SET_CURR(3, X2);
+          #endif
+          #if Y2_IS_TRINAMIC
+            SET_CURR(4, Y2);
+          #endif
+          #if Z2_IS_TRINAMIC
+            SET_CURR(5, Z2);
+          #endif
+          #if E0_IS_TRINAMIC
+            SET_CURR(6, E0);
+          #endif
+          #if E1_IS_TRINAMIC
+            SET_CURR(7, E1);
+          #endif
+          #if E2_IS_TRINAMIC
+            SET_CURR(8, E2);
+          #endif
+          #if E3_IS_TRINAMIC
+            SET_CURR(9, E3);
+          #endif
+          #if E4_IS_TRINAMIC
+            SET_CURR(10, E4);
+          #endif
+        }
       #else
-        for (uint8_t q = 11; q--;) EEPROM_READ(val);
+        uint16_t val;
+        for (uint8_t q=11; q--;) EEPROM_READ(val);
       #endif
 
       /*
@@ -1140,19 +1144,23 @@ void MarlinSettings::postprocess() {
       int16_t thrs;
       #if ENABLED(SENSORLESS_HOMING)
         EEPROM_READ(thrs);
-        #if ENABLED(X_IS_TMC2130)
-          stepperX.sgt(thrs);
-        #endif
-        #if ENABLED(X2_IS_TMC2130)
-          stepperX2.sgt(thrs);
-        #endif
+        if (!validating) {
+          #if ENABLED(X_IS_TMC2130)
+            stepperX.sgt(thrs);
+          #endif
+          #if ENABLED(X2_IS_TMC2130)
+            stepperX2.sgt(thrs);
+          #endif
+        }
         EEPROM_READ(thrs);
-        #if ENABLED(Y_IS_TMC2130)
-          stepperY.sgt(thrs);
-        #endif
-        #if ENABLED(Y2_IS_TMC2130)
-          stepperY2.sgt(thrs);
-        #endif
+        if (!validating) {
+          #if ENABLED(Y_IS_TMC2130)
+            stepperY.sgt(thrs);
+          #endif
+          #if ENABLED(Y2_IS_TMC2130)
+            stepperY2.sgt(thrs);
+          #endif
+        }
       #else
         for (uint8_t q = 0; q < 2; q++) EEPROM_READ(thrs);
       #endif
@@ -1185,7 +1193,7 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(CNC_COORDINATE_SYSTEMS)
-        (void)gcode.select_coordinate_system(-1); // Go back to machine space
+        if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
         EEPROM_READ(gcode.coordinate_system);                  // 27 floats
       #else
         for (uint8_t q = 27; q--;) EEPROM_READ(dummy);
@@ -1215,25 +1223,27 @@ void MarlinSettings::postprocess() {
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
           EEPROM_READ(dummy);
-          if (q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
+          if (!validating && q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
         }
         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
           EEPROM_READ(dummy);
-          if (q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
+          if (!validating && q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
         }
       #else
         for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
       #endif
 
       if (working_crc == stored_crc) {
-        postprocess();
-        #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_ECHO_START();
-          SERIAL_ECHO(version);
-          SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
-          SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
-          SERIAL_ECHOLNPGM(")");
-        #endif
+        if (!validating) {
+          postprocess();
+          #if ENABLED(EEPROM_CHITCHAT)
+            SERIAL_ECHO_START();
+            SERIAL_ECHO(version);
+            SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+            SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
+            SERIAL_ECHOLNPGM(")");
+          #endif
+        }
       }
       else {
         #if ENABLED(EEPROM_CHITCHAT)
@@ -1253,46 +1263,62 @@ void MarlinSettings::postprocess() {
                                                       // disrupting the mesh data
         ubl.report_state();
 
-        if (!ubl.sanity_check()) {
-          SERIAL_EOL();
-          #if ENABLED(EEPROM_CHITCHAT)
-            ubl.echo_name();
-            SERIAL_ECHOLNPGM(" initialized.\n");
-          #endif
-        }
-        else {
-          #if ENABLED(EEPROM_CHITCHAT)
-            SERIAL_PROTOCOLPGM("?Can't enable ");
-            ubl.echo_name();
-            SERIAL_PROTOCOLLNPGM(".");
-          #endif
-          ubl.reset();
-        }
+        if (!validating) {
+          if (!ubl.sanity_check()) {
+            SERIAL_EOL();
+            #if ENABLED(EEPROM_CHITCHAT)
+              ubl.echo_name();
+              SERIAL_ECHOLNPGM(" initialized.\n");
+            #endif
+          }
+          else {
+            eeprom_error = true;
+            #if ENABLED(EEPROM_CHITCHAT)
+              SERIAL_PROTOCOLPGM("?Can't enable ");
+              ubl.echo_name();
+              SERIAL_PROTOCOLLNPGM(".");
+            #endif
+            ubl.reset();
+          }
 
-        if (ubl.storage_slot >= 0) {
-          load_mesh(ubl.storage_slot);
-          #if ENABLED(EEPROM_CHITCHAT)
-            SERIAL_ECHOPAIR("Mesh ", ubl.storage_slot);
-            SERIAL_ECHOLNPGM(" loaded from storage.");
-          #endif
-        }
-        else {
-          ubl.reset();
-          #if ENABLED(EEPROM_CHITCHAT)
-            SERIAL_ECHOLNPGM("UBL System reset()");
-          #endif
+          if (ubl.storage_slot >= 0) {
+            load_mesh(ubl.storage_slot);
+            #if ENABLED(EEPROM_CHITCHAT)
+              SERIAL_ECHOPAIR("Mesh ", ubl.storage_slot);
+              SERIAL_ECHOLNPGM(" loaded from storage.");
+            #endif
+          }
+          else {
+            ubl.reset();
+            #if ENABLED(EEPROM_CHITCHAT)
+              SERIAL_ECHOLNPGM("UBL System reset()");
+            #endif
+          }
         }
       #endif
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
-      report();
+      if (!validating) report();
     #endif
     EEPROM_FINISH();
 
     return !eeprom_error;
   }
 
+  bool MarlinSettings::validate() {
+    validating = true;
+    const bool success = _load();
+    validating = false;
+    return success;
+  }
+
+  bool MarlinSettings::load() {
+    if (validate()) return _load();
+    reset();
+    return true;
+  }
+
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     #if ENABLED(EEPROM_CHITCHAT)

commit 878f54c27b28d276c76f1d12f3092b57c73212f8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 20:23:24 2018 -0600

    Write filler with NO_VOLUMETRICS

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 06fc846f9a..57a12f3223 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -560,6 +560,13 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(dummy);
       }
 
+    #else
+
+      const bool volumetric_enabled = false;
+      dummy = DEFAULT_NOMINAL_FILAMENT_DIA;
+      EEPROM_WRITE(volumetric_enabled);
+      for (uint8_t q = MAX_EXTRUDERS; q--;) EEPROM_WRITE(dummy);
+
     #endif
 
     //
@@ -1064,6 +1071,11 @@ void MarlinSettings::postprocess() {
           if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
         }
 
+      #else
+
+        EEPROM_READ(dummyb);
+        for (uint8_t q=MAX_EXTRUDERS; q--;) EEPROM_READ(dummy);
+
       #endif
 
       //

commit 3ea6745b368c913975fdbe1787738e7283a02c90
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 19:47:42 2018 -0600

    Pretty up TMC current write

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f872dd2cb1..06fc846f9a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -562,79 +562,71 @@ void MarlinSettings::postprocess() {
 
     #endif
 
+    //
     // Save TMC2130 or TMC2208 Configuration, and placeholder values
-    uint16_t val;
-    #if HAS_TRINAMIC
-      #if X_IS_TRINAMIC
-        val = stepperX.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if Y_IS_TRINAMIC
-        val = stepperY.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if Z_IS_TRINAMIC
-        val = stepperZ.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if X2_IS_TRINAMIC
-        val = stepperX2.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if Y2_IS_TRINAMIC
-        val = stepperY2.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if Z2_IS_TRINAMIC
-        val = stepperZ2.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if E0_IS_TRINAMIC
-        val = stepperE0.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if E1_IS_TRINAMIC
-        val = stepperE1.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if E2_IS_TRINAMIC
-        val = stepperE2.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if E3_IS_TRINAMIC
-        val = stepperE3.getCurrent();
-      #else
-        val = 0;
-      #endif
-      EEPROM_WRITE(val);
-      #if E4_IS_TRINAMIC
-        val = stepperE4.getCurrent();
+    //
+    uint16_t currents[11] = {
+      #if HAS_TRINAMIC
+        #if X_IS_TRINAMIC
+          stepperX.getCurrent(),
+        #else
+          0,
+        #endif
+        #if Y_IS_TRINAMIC
+          stepperY.getCurrent(),
+        #else
+          0,
+        #endif
+        #if Z_IS_TRINAMIC
+          stepperZ.getCurrent(),
+        #else
+          0,
+        #endif
+        #if X2_IS_TRINAMIC
+          stepperX2.getCurrent(),
+        #else
+          0,
+        #endif
+        #if Y2_IS_TRINAMIC
+          stepperY2.getCurrent(),
+        #else
+          0,
+        #endif
+        #if Z2_IS_TRINAMIC
+          stepperZ2.getCurrent(),
+        #else
+          0,
+        #endif
+        #if E0_IS_TRINAMIC
+          stepperE0.getCurrent(),
+        #else
+          0,
+        #endif
+        #if E1_IS_TRINAMIC
+          stepperE1.getCurrent(),
+        #else
+          0,
+        #endif
+        #if E2_IS_TRINAMIC
+          stepperE2.getCurrent(),
+        #else
+          0,
+        #endif
+        #if E3_IS_TRINAMIC
+          stepperE3.getCurrent(),
+        #else
+          0,
+        #endif
+        #if E4_IS_TRINAMIC
+          stepperE4.getCurrent()
+        #else
+          0
+        #endif
       #else
-        val = 0;
+        0
       #endif
-      EEPROM_WRITE(val);
-    #else
-      val = 0;
-      for (uint8_t q = 11; q--;) EEPROM_WRITE(val);
-    #endif
+    };
+    EEPROM_WRITE(currents);
 
     //
     // TMC2130 Sensorless homing threshold

commit 1c41de16d4a2e63bfb713041eeae1f3bc22882a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 5 10:10:55 2018 -0600

    Trailing whitespace clean

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 5b986e9e41..f872dd2cb1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2079,7 +2079,7 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         SERIAL_ECHO("  M852 I");
-        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor),6);
+        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor), 6);
         SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.xz_skew_factor));
         SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
       #else

commit 1746a7352efb51d44d47ba5e1deb669fa2b2269f
Merge: 048d8a0158 4fb60e1562
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 19:41:58 2018 -0600

    Merge pull request #9042 from thinkyhead/bf2_M701_M702
    
    [2.0.x] Improved Pause/Load/Unload, M701-M702

diff --combined Marlin/src/module/configuration_store.cpp
index 9cc2b66782,ee7e755630..5b986e9e41
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@@ -36,13 -36,13 +36,13 @@@
   *
   */
  
- #define EEPROM_VERSION "V47"
+ #define EEPROM_VERSION "V48"
  
  // Change EEPROM version if these are changed:
  #define EEPROM_OFFSET 100
  
  /**
-  * V47 EEPROM Layout:
+  * V48 EEPROM Layout:
   *
   *  100  Version                                    (char x4)
   *  104  EEPROM CRC16                               (uint16_t)
@@@ -139,7 -139,7 +139,7 @@@
   *
   * Volumetric Extrusion:                            21 bytes
   *  539  M200 D    parser.volumetric_enabled        (bool)
-  *  540  M200 T D  planner.filament_size            (float x5) (T0..3)
+  *  540  M200 T D  planner.filament_size            (float x5) (T0..4)
   *
   * HAS_TRINAMIC:                                    22 bytes
   *  560  M906 X    Stepper X current                (uint16_t)
@@@ -154,7 -154,7 +154,7 @@@
   *  578  M906 E3   Stepper E3 current               (uint16_t)
   *  580  M906 E4   Stepper E4 current               (uint16_t)
   *
-  * SENSORLESS HOMING                                4 bytes
+  * SENSORLESS_HOMING:                               4 bytes
   *  582  M914 X    Stepper X and X2 threshold       (int16_t)
   *  584  M914 Y    Stepper Y and Y2 threshold       (int16_t)
   *
@@@ -167,7 -167,7 +167,7 @@@
   *  598  M907 Z    Stepper Z current                (uint32_t)
   *  602  M907 E    Stepper E current                (uint32_t)
   *
-  * CNC_COORDINATE_SYSTEMS                           108 bytes
+  * CNC_COORDINATE_SYSTEMS:                          108 bytes
   *  606  G54-G59.3 coordinate_system                (float x 27)
   *
   * SKEW_CORRECTION:                                 12 bytes
@@@ -175,8 -175,12 +175,12 @@@
   *  718  M852 J    planner.xz_skew_factor           (float)
   *  722  M852 K    planner.yz_skew_factor           (float)
   *
-  *  726                                   Minimum end-point
-  * 2255 (726 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
+  * ADVANCED_PAUSE_FEATURE:                          40 bytes
+  *  726  M603 T U  filament_change_unload_length    (float x 5) (T0..4)
+  *  746  M603 T L  filament_change_load_length      (float x 5) (T0..4)
+  *
+  *  766                                   Minimum end-point
+  * 2295 (766 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
   *
   * ========================================================================
   * meshes_begin (between max and min end-point, directly above)
@@@ -698,6 -702,23 +702,23 @@@ void MarlinSettings::postprocess() 
        for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
      #endif
  
+     //
+     // Advanced Pause filament load & unload lengths
+     //
+     #if ENABLED(ADVANCED_PAUSE_FEATURE)
+       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+         if (q < COUNT(filament_change_unload_length)) dummy = filament_change_unload_length[q];
+         EEPROM_WRITE(dummy);
+       }
+       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+         if (q < COUNT(filament_change_load_length)) dummy = filament_change_load_length[q];
+         EEPROM_WRITE(dummy);
+       }
+     #else
+       dummy = 0.0f;
+       for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
+     #endif
+ 
      if (!eeprom_error) {
        #if ENABLED(EEPROM_CHITCHAT)
          const int eeprom_size = eeprom_index;
@@@ -1183,6 -1204,23 +1204,23 @@@
          for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
        #endif
  
+       //
+       // Advanced Pause filament load & unload lengths
+       //
+ 
+       #if ENABLED(ADVANCED_PAUSE_FEATURE)
+         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+           EEPROM_READ(dummy);
+           if (q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
+         }
+         for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+           EEPROM_READ(dummy);
+           if (q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
+         }
+       #else
+         for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
+       #endif
+ 
        if (working_crc == stored_crc) {
          postprocess();
          #if ENABLED(EEPROM_CHITCHAT)
@@@ -1593,6 -1631,13 +1631,13 @@@ void MarlinSettings::reset() 
      #endif
    #endif
  
+   #if ENABLED(ADVANCED_PAUSE_FEATURE)
+     for (uint8_t e = 0; e < E_STEPPERS; e++) {
+       filament_change_unload_length[e] = FILAMENT_CHANGE_UNLOAD_LENGTH;
+       filament_change_load_length[e] = FILAMENT_CHANGE_LOAD_LENGTH;
+     }
+   #endif
+ 
    postprocess();
  
    #if ENABLED(EEPROM_CHITCHAT)
@@@ -1804,36 -1849,35 +1849,35 @@@
        }
      #endif
  
-     #if ENABLED(MESH_BED_LEVELING)
+     /**
+      * Bed Leveling
+      */
+     #if HAS_LEVELING
  
-       if (!forReplay) {
-         CONFIG_ECHO_START;
-         SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
-       }
-       CONFIG_ECHO_START;
-       SERIAL_ECHOPAIR("  M420 S", leveling_is_valid() ? 1 : 0);
-       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-         SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
-       #endif
-       SERIAL_EOL();
-       for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
-         for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+       #if ENABLED(MESH_BED_LEVELING)
+ 
+         if (!forReplay) {
            CONFIG_ECHO_START;
-           SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
-           SERIAL_ECHOPAIR(" Y", (int)py + 1);
-           SERIAL_ECHOPGM(" Z");
-           SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
-           SERIAL_EOL();
+           SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
          }
-       }
  
-     #elif ENABLED(AUTO_BED_LEVELING_UBL)
+       #elif ENABLED(AUTO_BED_LEVELING_UBL)
+ 
+         if (!forReplay) {
+           CONFIG_ECHO_START;
+           ubl.echo_name();
+           SERIAL_ECHOLNPGM(":");
+         }
+ 
+       #elif HAS_ABL
+ 
+         if (!forReplay) {
+           CONFIG_ECHO_START;
+           SERIAL_ECHOLNPGM("Auto Bed Leveling:");
+         }
+ 
+       #endif
  
-       if (!forReplay) {
-         CONFIG_ECHO_START;
-         ubl.echo_name();
-         SERIAL_ECHOLNPGM(":");
-       }
        CONFIG_ECHO_START;
        SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@@ -1841,29 -1885,32 +1885,32 @@@
        #endif
        SERIAL_EOL();
  
-       if (!forReplay) {
-         SERIAL_EOL();
-         ubl.report_state();
+       #if ENABLED(MESH_BED_LEVELING)
  
-         SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
-         SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
-         SERIAL_ECHOLNPGM(" meshes.\n");
-       }
+         for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
+           for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+             CONFIG_ECHO_START;
+             SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
+             SERIAL_ECHOPAIR(" Y", (int)py + 1);
+             SERIAL_ECHOPGM(" Z");
+             SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
+             SERIAL_EOL();
+           }
+         }
  
-     #elif HAS_ABL
+       #elif ENABLED(AUTO_BED_LEVELING_UBL)
+ 
+         if (!forReplay) {
+           SERIAL_EOL();
+           ubl.report_state();
+           SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
+           SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
+           SERIAL_ECHOLNPGM(" meshes.\n");
+         }
  
-       if (!forReplay) {
-         CONFIG_ECHO_START;
-         SERIAL_ECHOLNPGM("Auto Bed Leveling:");
-       }
-       CONFIG_ECHO_START;
-       SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
-       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-         SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
        #endif
-       SERIAL_EOL();
  
-     #endif
+     #endif // HAS_LEVELING
  
      #if ENABLED(DELTA)
        if (!forReplay) {
@@@ -2031,21 -2078,18 +2078,21 @@@
        }
        CONFIG_ECHO_START;
        #if ENABLED(SKEW_CORRECTION_FOR_Z)
 -        SERIAL_ECHOPAIR("  M852 I", LINEAR_UNIT(planner.xy_skew_factor));
 +        SERIAL_ECHO("  M852 I");
 +        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor),6);
          SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.xz_skew_factor));
          SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
        #else
 -        SERIAL_ECHOLNPAIR("  M852 S", LINEAR_UNIT(planner.xy_skew_factor));
 +        SERIAL_ECHO("  M852 S");
 +        SERIAL_ECHO_F(planner.xy_skew_factor, 6);
 +        SERIAL_EOL();
        #endif
      #endif
  
      /**
       * TMC2130 stepper driver current
       */
-     #if ENABLED(HAVE_TMC2130)
+     #if HAS_TRINAMIC
        if (!forReplay) {
          CONFIG_ECHO_START;
          SERIAL_ECHOLNPGM("Stepper driver current:");
@@@ -2091,7 -2135,7 +2138,7 @@@
      /**
       * TMC2130 Sensorless homing thresholds
       */
-     #if ENABLED(HAVE_TMC2130) && ENABLED(SENSORLESS_HOMING)
+     #if ENABLED(SENSORLESS_HOMING)
        if (!forReplay) {
          CONFIG_ECHO_START;
          SERIAL_ECHOLNPGM("Sensorless homing threshold:");
@@@ -2137,6 -2181,42 +2184,42 @@@
        SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
        SERIAL_EOL();
      #endif
+ 
+     /**
+      * Advanced Pause filament load & unload lengths
+      */
+     #if ENABLED(ADVANCED_PAUSE_FEATURE)
+       if (!forReplay) {
+         CONFIG_ECHO_START;
+         SERIAL_ECHOLNPGM("Filament load/unload lengths:");
+       }
+       CONFIG_ECHO_START;
+       #if EXTRUDERS == 1
+         SERIAL_ECHOPAIR("  M603 L", LINEAR_UNIT(filament_change_load_length[0]));
+         SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+       #else
+         SERIAL_ECHOPAIR("  M603 T0 L", LINEAR_UNIT(filament_change_load_length[0]));
+         SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+         CONFIG_ECHO_START;
+         SERIAL_ECHOPAIR("  M603 T1 L", LINEAR_UNIT(filament_change_load_length[1]));
+         SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[1]));
+         #if EXTRUDERS > 2
+           CONFIG_ECHO_START;
+           SERIAL_ECHOPAIR("  M603 T2 L", LINEAR_UNIT(filament_change_load_length[2]));
+           SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[2]));
+           #if EXTRUDERS > 3
+             CONFIG_ECHO_START;
+             SERIAL_ECHOPAIR("  M603 T3 L", LINEAR_UNIT(filament_change_load_length[3]));
+             SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[3]));
+             #if EXTRUDERS > 4
+               CONFIG_ECHO_START;
+               SERIAL_ECHOPAIR("  M603 T4 L", LINEAR_UNIT(filament_change_load_length[4]));
+               SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[4]));
+             #endif // EXTRUDERS > 4
+           #endif // EXTRUDERS > 3
+         #endif // EXTRUDERS > 2
+       #endif // EXTRUDERS == 1
+     #endif // ADVANCED_PAUSE_FEATURE
    }
  
  #endif // !DISABLE_M503

commit 3a4e107b6b58443096265f881694e432bc2f707b
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jan 4 16:20:18 2018 -0600

    use SERIAL_EOL(); instead of new line string

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f7ee80cea4..9cc2b66782 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2038,7 +2038,7 @@ void MarlinSettings::reset() {
       #else
         SERIAL_ECHO("  M852 S");
         SERIAL_ECHO_F(planner.xy_skew_factor, 6);
-        SERIAL_ECHO("\n");
+        SERIAL_EOL();
       #endif
     #endif
 

commit 19e75ccf8618b3691f14f6d51b1e73f56fb1355e
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jan 4 16:02:22 2018 -0600

    Add enough precision so planner.xy_skew_factor doesn't print as 0.00

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e5088e0777..f7ee80cea4 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -2031,11 +2031,14 @@ void MarlinSettings::reset() {
       }
       CONFIG_ECHO_START;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHOPAIR("  M852 I", LINEAR_UNIT(planner.xy_skew_factor));
+        SERIAL_ECHO("  M852 I");
+        SERIAL_ECHO_F(LINEAR_UNIT(planner.xy_skew_factor),6);
         SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.xz_skew_factor));
         SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
       #else
-        SERIAL_ECHOLNPAIR("  M852 S", LINEAR_UNIT(planner.xy_skew_factor));
+        SERIAL_ECHO("  M852 S");
+        SERIAL_ECHO_F(planner.xy_skew_factor, 6);
+        SERIAL_ECHO("\n");
       #endif
     #endif
 

commit 7541316bb49303ce97e062da601e26426321c4ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 05:06:34 2018 -0600

    Add M701/M702 Filament Load/Unload, M603

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index dc1fc37928..ee7e755630 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V47"
+#define EEPROM_VERSION "V48"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V47 EEPROM Layout:
+ * V48 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -139,7 +139,7 @@
  *
  * Volumetric Extrusion:                            21 bytes
  *  539  M200 D    parser.volumetric_enabled        (bool)
- *  540  M200 T D  planner.filament_size            (float x5) (T0..3)
+ *  540  M200 T D  planner.filament_size            (float x5) (T0..4)
  *
  * HAS_TRINAMIC:                                    22 bytes
  *  560  M906 X    Stepper X current                (uint16_t)
@@ -154,7 +154,7 @@
  *  578  M906 E3   Stepper E3 current               (uint16_t)
  *  580  M906 E4   Stepper E4 current               (uint16_t)
  *
- * SENSORLESS HOMING                                4 bytes
+ * SENSORLESS_HOMING:                               4 bytes
  *  582  M914 X    Stepper X and X2 threshold       (int16_t)
  *  584  M914 Y    Stepper Y and Y2 threshold       (int16_t)
  *
@@ -167,7 +167,7 @@
  *  598  M907 Z    Stepper Z current                (uint32_t)
  *  602  M907 E    Stepper E current                (uint32_t)
  *
- * CNC_COORDINATE_SYSTEMS                           108 bytes
+ * CNC_COORDINATE_SYSTEMS:                          108 bytes
  *  606  G54-G59.3 coordinate_system                (float x 27)
  *
  * SKEW_CORRECTION:                                 12 bytes
@@ -175,8 +175,12 @@
  *  718  M852 J    planner.xz_skew_factor           (float)
  *  722  M852 K    planner.yz_skew_factor           (float)
  *
- *  726                                   Minimum end-point
- * 2255 (726 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
+ * ADVANCED_PAUSE_FEATURE:                          40 bytes
+ *  726  M603 T U  filament_change_unload_length    (float x 5) (T0..4)
+ *  746  M603 T L  filament_change_load_length      (float x 5) (T0..4)
+ *
+ *  766                                   Minimum end-point
+ * 2295 (766 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -698,6 +702,23 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
     #endif
 
+    //
+    // Advanced Pause filament load & unload lengths
+    //
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        if (q < COUNT(filament_change_unload_length)) dummy = filament_change_unload_length[q];
+        EEPROM_WRITE(dummy);
+      }
+      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        if (q < COUNT(filament_change_load_length)) dummy = filament_change_load_length[q];
+        EEPROM_WRITE(dummy);
+      }
+    #else
+      dummy = 0.0f;
+      for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_WRITE(dummy);
+    #endif
+
     if (!eeprom_error) {
       #if ENABLED(EEPROM_CHITCHAT)
         const int eeprom_size = eeprom_index;
@@ -1183,6 +1204,23 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
       #endif
 
+      //
+      // Advanced Pause filament load & unload lengths
+      //
+
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+          EEPROM_READ(dummy);
+          if (q < COUNT(filament_change_unload_length)) filament_change_unload_length[q] = dummy;
+        }
+        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+          EEPROM_READ(dummy);
+          if (q < COUNT(filament_change_load_length)) filament_change_load_length[q] = dummy;
+        }
+      #else
+        for (uint8_t q = MAX_EXTRUDERS * 2; q--;) EEPROM_READ(dummy);
+      #endif
+
       if (working_crc == stored_crc) {
         postprocess();
         #if ENABLED(EEPROM_CHITCHAT)
@@ -1593,6 +1631,13 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    for (uint8_t e = 0; e < E_STEPPERS; e++) {
+      filament_change_unload_length[e] = FILAMENT_CHANGE_UNLOAD_LENGTH;
+      filament_change_load_length[e] = FILAMENT_CHANGE_LOAD_LENGTH;
+    }
+  #endif
+
   postprocess();
 
   #if ENABLED(EEPROM_CHITCHAT)
@@ -2136,6 +2181,42 @@ void MarlinSettings::reset() {
       SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
       SERIAL_EOL();
     #endif
+
+    /**
+     * Advanced Pause filament load & unload lengths
+     */
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Filament load/unload lengths:");
+      }
+      CONFIG_ECHO_START;
+      #if EXTRUDERS == 1
+        SERIAL_ECHOPAIR("  M603 L", LINEAR_UNIT(filament_change_load_length[0]));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+      #else
+        SERIAL_ECHOPAIR("  M603 T0 L", LINEAR_UNIT(filament_change_load_length[0]));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[0]));
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR("  M603 T1 L", LINEAR_UNIT(filament_change_load_length[1]));
+        SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[1]));
+        #if EXTRUDERS > 2
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  M603 T2 L", LINEAR_UNIT(filament_change_load_length[2]));
+          SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[2]));
+          #if EXTRUDERS > 3
+            CONFIG_ECHO_START;
+            SERIAL_ECHOPAIR("  M603 T3 L", LINEAR_UNIT(filament_change_load_length[3]));
+            SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[3]));
+            #if EXTRUDERS > 4
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR("  M603 T4 L", LINEAR_UNIT(filament_change_load_length[4]));
+              SERIAL_ECHOLNPAIR(" U", LINEAR_UNIT(filament_change_unload_length[4]));
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS == 1
+    #endif // ADVANCED_PAUSE_FEATURE
   }
 
 #endif // !DISABLE_M503

commit a80f2eea2373a6dfe7395dc0c2b0e20bc9f14dbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 3 21:55:07 2018 -0600

    Group leveling reports for folding

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e5088e0777..dc1fc37928 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1804,36 +1804,35 @@ void MarlinSettings::reset() {
       }
     #endif
 
-    #if ENABLED(MESH_BED_LEVELING)
+    /**
+     * Bed Leveling
+     */
+    #if HAS_LEVELING
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
-      }
-      CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", leveling_is_valid() ? 1 : 0);
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
-      #endif
-      SERIAL_EOL();
-      for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
-        for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+      #if ENABLED(MESH_BED_LEVELING)
+
+        if (!forReplay) {
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
-          SERIAL_ECHOPAIR(" Y", (int)py + 1);
-          SERIAL_ECHOPGM(" Z");
-          SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
-          SERIAL_EOL();
+          SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
         }
-      }
 
-    #elif ENABLED(AUTO_BED_LEVELING_UBL)
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+        if (!forReplay) {
+          CONFIG_ECHO_START;
+          ubl.echo_name();
+          SERIAL_ECHOLNPGM(":");
+        }
+
+      #elif HAS_ABL
+
+        if (!forReplay) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOLNPGM("Auto Bed Leveling:");
+        }
+
+      #endif
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        ubl.echo_name();
-        SERIAL_ECHOLNPGM(":");
-      }
       CONFIG_ECHO_START;
       SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -1841,29 +1840,32 @@ void MarlinSettings::reset() {
       #endif
       SERIAL_EOL();
 
-      if (!forReplay) {
-        SERIAL_EOL();
-        ubl.report_state();
+      #if ENABLED(MESH_BED_LEVELING)
 
-        SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
-        SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
-        SERIAL_ECHOLNPGM(" meshes.\n");
-      }
+        for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
+          for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+            CONFIG_ECHO_START;
+            SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
+            SERIAL_ECHOPAIR(" Y", (int)py + 1);
+            SERIAL_ECHOPGM(" Z");
+            SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
+            SERIAL_EOL();
+          }
+        }
 
-    #elif HAS_ABL
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+        if (!forReplay) {
+          SERIAL_EOL();
+          ubl.report_state();
+          SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
+          SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
+          SERIAL_ECHOLNPGM(" meshes.\n");
+        }
 
-      if (!forReplay) {
-        CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Auto Bed Leveling:");
-      }
-      CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
       #endif
-      SERIAL_EOL();
 
-    #endif
+    #endif // HAS_LEVELING
 
     #if ENABLED(DELTA)
       if (!forReplay) {
@@ -2042,7 +2044,7 @@ void MarlinSettings::reset() {
     /**
      * TMC2130 stepper driver current
      */
-    #if ENABLED(HAVE_TMC2130)
+    #if HAS_TRINAMIC
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Stepper driver current:");
@@ -2088,7 +2090,7 @@ void MarlinSettings::reset() {
     /**
      * TMC2130 Sensorless homing thresholds
      */
-    #if ENABLED(HAVE_TMC2130) && ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(SENSORLESS_HOMING)
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Sensorless homing threshold:");

commit 8afc4f8d9d629781f847b628ca1708e44be83725
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Tue Jan 2 21:00:06 2018 -0600

    Fix UBL compilation warnings

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f5f8684847..e5088e0777 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -759,7 +759,9 @@ void MarlinSettings::postprocess() {
     }
     else {
       float dummy = 0;
-      bool dummyb;
+      #if DISABLED(AUTO_BED_LEVELING_UBL) || DISABLED(FWRETRACT)
+        bool dummyb;
+      #endif
 
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 

commit 5effe1590c01e271ae2c4474bbdd8fbdfa1f57be
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 26 20:04:39 2017 -0600

    Fix NO_VOLUMETRICS bug

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f697666756..f5f8684847 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -241,6 +241,9 @@ void MarlinSettings::postprocess() {
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
+  #else
+    for (uint8_t i = COUNT(planner.e_factor); i--;)
+      planner.refresh_e_factor(i);
   #endif
 
   #if HAS_HOME_OFFSET || ENABLED(DUAL_X_CARRIAGE)

commit 4b49ea1e92d2963f261bfc7ea1233b49200407af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 03:32:31 2017 -0600

    General cleanup of config-store, reset_bed_level

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d6252eb2c3..f697666756 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -141,7 +141,7 @@
  *  539  M200 D    parser.volumetric_enabled        (bool)
  *  540  M200 T D  planner.filament_size            (float x5) (T0..3)
  *
- * HAVE_TMC2130:                                    22 bytes
+ * HAS_TRINAMIC:                                    22 bytes
  *  560  M906 X    Stepper X current                (uint16_t)
  *  562  M906 Y    Stepper Y current                (uint16_t)
  *  564  M906 Z    Stepper Z current                (uint16_t)
@@ -155,28 +155,28 @@
  *  580  M906 E4   Stepper E4 current               (uint16_t)
  *
  * SENSORLESS HOMING                                4 bytes
- *  580  M914 X    Stepper X and X2 threshold       (int16_t)
- *  582  M914 Y    Stepper Y and Y2 threshold       (int16_t)
+ *  582  M914 X    Stepper X and X2 threshold       (int16_t)
+ *  584  M914 Y    Stepper Y and Y2 threshold       (int16_t)
  *
  * LIN_ADVANCE:                                     8 bytes
- *  582  M900 K    extruder_advance_k               (float)
- *  586  M900 WHD  advance_ed_ratio                 (float)
+ *  586  M900 K    extruder_advance_k               (float)
+ *  590  M900 WHD  advance_ed_ratio                 (float)
  *
  * HAS_MOTOR_CURRENT_PWM:
- *  590  M907 X    Stepper XY current               (uint32_t)
- *  594  M907 Z    Stepper Z current                (uint32_t)
- *  598  M907 E    Stepper E current                (uint32_t)
+ *  594  M907 X    Stepper XY current               (uint32_t)
+ *  598  M907 Z    Stepper Z current                (uint32_t)
+ *  602  M907 E    Stepper E current                (uint32_t)
  *
  * CNC_COORDINATE_SYSTEMS                           108 bytes
- *  602  G54-G59.3 coordinate_system                (float x 27)
+ *  606  G54-G59.3 coordinate_system                (float x 27)
  *
  * SKEW_CORRECTION:                                 12 bytes
- *  710  M852 I    planner.xy_skew_factor           (float)
- *  714  M852 J    planner.xz_skew_factor           (float)
- *  718  M852 K    planner.yz_skew_factor           (float)
+ *  714  M852 I    planner.xy_skew_factor           (float)
+ *  718  M852 J    planner.xz_skew_factor           (float)
+ *  722  M852 K    planner.yz_skew_factor           (float)
  *
- *  722                                   Minimum end-point
- * 2251 (722 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
+ *  726                                   Minimum end-point
+ * 2255 (726 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -290,7 +290,7 @@ void MarlinSettings::postprocess() {
   bool MarlinSettings::eeprom_error;
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
-    int MarlinSettings::meshes_begin;
+    int16_t MarlinSettings::meshes_begin;
   #endif
 
   /**
@@ -1256,7 +1256,7 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
-    int MarlinSettings::calc_num_meshes() {
+    uint16_t MarlinSettings::calc_num_meshes() {
       //obviously this will get more sophisticated once we've added an actual MAT
 
       if (meshes_begin <= 0) return 0;
@@ -1264,10 +1264,10 @@ void MarlinSettings::postprocess() {
       return (meshes_end - meshes_begin) / sizeof(ubl.z_values);
     }
 
-    void MarlinSettings::store_mesh(int8_t slot) {
+    void MarlinSettings::store_mesh(const int8_t slot) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        const int a = calc_num_meshes();
+        const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
           #if ENABLED(EEPROM_CHITCHAT)
             ubl_invalid_slot(a);
@@ -1280,11 +1280,10 @@ void MarlinSettings::postprocess() {
         }
 
         uint16_t crc = 0;
-        bool status;
         int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
 
         HAL::PersistentStore::access_start();
-        status = HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        const bool status = HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
         HAL::PersistentStore::access_finish();
 
         if (status)
@@ -1304,7 +1303,7 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
-    void MarlinSettings::load_mesh(int8_t slot, void *into /* = 0 */) {
+    void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=NULL*/) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
 
@@ -1320,10 +1319,9 @@ void MarlinSettings::postprocess() {
         uint16_t crc = 0;
         int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
         uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
-        uint16_t status;
 
         HAL::PersistentStore::access_start();
-        status = HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        const uint16_t status = HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
         HAL::PersistentStore::access_finish();
 
         if (status)
@@ -1373,17 +1371,13 @@ void MarlinSettings::reset() {
   planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
-  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
+  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
   planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
   planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
   planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
 
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    new_z_fade_height = 0.0;
-  #endif
-
   #if HAS_HOME_OFFSET
     ZERO(home_offset);
   #endif
@@ -1405,7 +1399,14 @@ void MarlinSettings::reset() {
     LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp4[i][e];
   #endif
 
-  // Applies to all MBL and ABL
+  //
+  // Global Leveling
+  //
+
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    new_z_fade_height = 0.0;
+  #endif
+
   #if HAS_LEVELING
     reset_bed_level();
   #endif
@@ -1466,10 +1467,6 @@ void MarlinSettings::reset() {
     lcd_preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
   #endif
 
-  #if HAS_LCD_CONTRAST
-    lcd_contrast = DEFAULT_LCD_CONTRAST;
-  #endif
-
   #if ENABLED(PIDTEMP)
     #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
       HOTEND_LOOP()
@@ -1493,6 +1490,10 @@ void MarlinSettings::reset() {
     thermalManager.bedKd = scalePID_d(DEFAULT_bedKd);
   #endif
 
+  #if HAS_LCD_CONTRAST
+    lcd_contrast = DEFAULT_LCD_CONTRAST;
+  #endif
+
   #if ENABLED(FWRETRACT)
     fwretract.reset();
   #endif
@@ -1579,10 +1580,6 @@ void MarlinSettings::reset() {
       stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    ubl.reset();
-  #endif
-
   #if ENABLED(SKEW_CORRECTION_GCODE)
     planner.xy_skew_factor = XY_SKEW_FACTOR;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)

commit 933f76fda3a2e8ecd9b3e8493b2885f4356b0430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 19:44:11 2017 -0600

    Option to disable all volumetric extrusion

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 38c56602df..d6252eb2c3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -239,7 +239,9 @@ void MarlinSettings::postprocess() {
     thermalManager.updatePID();
   #endif
 
-  planner.calculate_volumetric_multipliers();
+  #if DISABLED(NO_VOLUMETRICS)
+    planner.calculate_volumetric_multipliers();
+  #endif
 
   #if HAS_HOME_OFFSET || ENABLED(DUAL_X_CARRIAGE)
     // Software endstops depend on home_offset
@@ -538,13 +540,20 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(fwretract.swap_retract_recover_feedrate_mm_s);
     #endif
 
-    EEPROM_WRITE(parser.volumetric_enabled);
+    //
+    // Volumetric & Filament Size
+    //
+    #if DISABLED(NO_VOLUMETRICS)
 
-    // Save filament sizes
-    for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-      if (q < COUNT(planner.filament_size)) dummy = planner.filament_size[q];
-      EEPROM_WRITE(dummy);
-    }
+      EEPROM_WRITE(parser.volumetric_enabled);
+
+      // Save filament sizes
+      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        if (q < COUNT(planner.filament_size)) dummy = planner.filament_size[q];
+        EEPROM_WRITE(dummy);
+      }
+
+    #endif
 
     // Save TMC2130 or TMC2208 Configuration, and placeholder values
     uint16_t val;
@@ -1028,12 +1037,16 @@ void MarlinSettings::postprocess() {
       //
       // Volumetric & Filament Size
       //
+      #if DISABLED(NO_VOLUMETRICS)
 
-      EEPROM_READ(parser.volumetric_enabled);
-      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-        EEPROM_READ(dummy);
-        if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
-      }
+        EEPROM_READ(parser.volumetric_enabled);
+
+        for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+          EEPROM_READ(dummy);
+          if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
+        }
+
+      #endif
 
       //
       // TMC2130 Stepper Current
@@ -1484,15 +1497,19 @@ void MarlinSettings::reset() {
     fwretract.reset();
   #endif
 
-  parser.volumetric_enabled =
-    #if ENABLED(VOLUMETRIC_DEFAULT_ON)
-      true
-    #else
-      false
-    #endif
-  ;
-  for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
-    planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+  #if DISABLED(NO_VOLUMETRICS)
+
+    parser.volumetric_enabled =
+      #if ENABLED(VOLUMETRIC_DEFAULT_ON)
+        true
+      #else
+        false
+      #endif
+    ;
+    for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
+      planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+
+  #endif
 
   endstops.enable_globally(
     #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
@@ -1630,46 +1647,50 @@ void MarlinSettings::reset() {
 
     SERIAL_EOL();
 
-    /**
-     * Volumetric extrusion M200
-     */
-    if (!forReplay) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOPGM("Filament settings:");
-      if (parser.volumetric_enabled)
-        SERIAL_EOL();
-      else
-        SERIAL_ECHOLNPGM(" Disabled");
-    }
+    #if DISABLED(NO_VOLUMETRICS)
+
+      /**
+       * Volumetric extrusion M200
+       */
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPGM("Filament settings:");
+        if (parser.volumetric_enabled)
+          SERIAL_EOL();
+        else
+          SERIAL_ECHOLNPGM(" Disabled");
+      }
 
-    CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
-    SERIAL_EOL();
-    #if EXTRUDERS > 1
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
+      SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
       SERIAL_EOL();
-      #if EXTRUDERS > 2
+      #if EXTRUDERS > 1
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
+        SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
         SERIAL_EOL();
-        #if EXTRUDERS > 3
+        #if EXTRUDERS > 2
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
+          SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
           SERIAL_EOL();
-          #if EXTRUDERS > 4
+          #if EXTRUDERS > 3
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
+            SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
             SERIAL_EOL();
-          #endif // EXTRUDERS > 4
-        #endif // EXTRUDERS > 3
-      #endif // EXTRUDERS > 2
-    #endif // EXTRUDERS > 1
+            #if EXTRUDERS > 4
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
+              SERIAL_EOL();
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
 
-    if (!parser.volumetric_enabled) {
-      CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("  M200 D0");
-    }
+      if (!parser.volumetric_enabled) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("  M200 D0");
+      }
+
+    #endif // !NO_VOLUMETRICS
 
     if (!forReplay) {
       CONFIG_ECHO_START;

commit fc9ee1a4dedbffc1fd4d5e0934be204280f51f76
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 19:11:07 2017 -0600

    Fix up serial sanity check

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 402e679fbf..38c56602df 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -262,7 +262,7 @@ void MarlinSettings::postprocess() {
   #if ENABLED(FWRETRACT)
     fwretract.refresh_autoretract();
   #endif
- 
+
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 81260a5c9f..402e679fbf 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V46"
+#define EEPROM_VERSION "V47"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V46 EEPROM Layout:
+ * V47 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -154,6 +154,10 @@
  *  578  M906 E3   Stepper E3 current               (uint16_t)
  *  580  M906 E4   Stepper E4 current               (uint16_t)
  *
+ * SENSORLESS HOMING                                4 bytes
+ *  580  M914 X    Stepper X and X2 threshold       (int16_t)
+ *  582  M914 Y    Stepper Y and Y2 threshold       (int16_t)
+ *
  * LIN_ADVANCE:                                     8 bytes
  *  582  M900 K    extruder_advance_k               (float)
  *  586  M900 WHD  advance_ed_ratio                 (float)
@@ -542,70 +546,70 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(dummy);
     }
 
-    // Save TMC2130 Configuration, and placeholder values
+    // Save TMC2130 or TMC2208 Configuration, and placeholder values
     uint16_t val;
-    #if ENABLED(HAVE_TMC2130)
-      #if ENABLED(X_IS_TMC2130)
+    #if HAS_TRINAMIC
+      #if X_IS_TRINAMIC
         val = stepperX.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(Y_IS_TMC2130)
+      #if Y_IS_TRINAMIC
         val = stepperY.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(Z_IS_TMC2130)
+      #if Z_IS_TRINAMIC
         val = stepperZ.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(X2_IS_TMC2130)
+      #if X2_IS_TRINAMIC
         val = stepperX2.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(Y2_IS_TMC2130)
+      #if Y2_IS_TRINAMIC
         val = stepperY2.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(Z2_IS_TMC2130)
+      #if Z2_IS_TRINAMIC
         val = stepperZ2.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(E0_IS_TMC2130)
+      #if E0_IS_TRINAMIC
         val = stepperE0.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(E1_IS_TMC2130)
+      #if E1_IS_TRINAMIC
         val = stepperE1.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(E2_IS_TMC2130)
+      #if E2_IS_TRINAMIC
         val = stepperE2.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(E3_IS_TMC2130)
+      #if E3_IS_TRINAMIC
         val = stepperE3.getCurrent();
       #else
         val = 0;
       #endif
       EEPROM_WRITE(val);
-      #if ENABLED(E4_IS_TMC2130)
+      #if E4_IS_TRINAMIC
         val = stepperE4.getCurrent();
       #else
         val = 0;
@@ -616,6 +620,28 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 11; q--;) EEPROM_WRITE(val);
     #endif
 
+    //
+    // TMC2130 Sensorless homing threshold
+    //
+    int16_t thrs;
+    #if ENABLED(SENSORLESS_HOMING)
+      #if ENABLED(X_IS_TMC2130)
+        thrs = stepperX.sgt();
+      #else
+        thrs = 0;
+      #endif
+      EEPROM_WRITE(thrs);
+      #if ENABLED(Y_IS_TMC2130)
+        thrs = stepperY.sgt();
+      #else
+        thrs = 0;
+      #endif
+      EEPROM_WRITE(thrs);
+    #else
+      thrs = 0;
+      for (uint8_t q = 2; q--;) EEPROM_WRITE(thrs);
+    #endif
+
     //
     // Linear Advance
     //
@@ -1014,55 +1040,80 @@ void MarlinSettings::postprocess() {
       //
 
       uint16_t val;
-      #if ENABLED(HAVE_TMC2130)
+      #if HAS_TRINAMIC
         EEPROM_READ(val);
-        #if ENABLED(X_IS_TMC2130)
+        #if X_IS_TRINAMIC
           stepperX.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(Y_IS_TMC2130)
+        #if Y_IS_TRINAMIC
           stepperY.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(Z_IS_TMC2130)
+        #if Z_IS_TRINAMIC
           stepperZ.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(X2_IS_TMC2130)
+        #if X2_IS_TRINAMIC
           stepperX2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(Y2_IS_TMC2130)
+        #if Y2_IS_TRINAMIC
           stepperY2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(Z2_IS_TMC2130)
+        #if Z2_IS_TRINAMIC
           stepperZ2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(E0_IS_TMC2130)
+        #if E0_IS_TRINAMIC
           stepperE0.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(E1_IS_TMC2130)
+        #if E1_IS_TRINAMIC
           stepperE1.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(E2_IS_TMC2130)
+        #if E2_IS_TRINAMIC
           stepperE2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(E3_IS_TMC2130)
+        #if E3_IS_TRINAMIC
           stepperE3.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
         EEPROM_READ(val);
-        #if ENABLED(E4_IS_TMC2130)
+        #if E4_IS_TRINAMIC
           stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
       #else
         for (uint8_t q = 11; q--;) EEPROM_READ(val);
       #endif
 
+      /*
+       * TMC2130 Sensorless homing threshold.
+       * X and X2 use the same value
+       * Y and Y2 use the same value
+       */
+      int16_t thrs;
+      #if ENABLED(SENSORLESS_HOMING)
+        EEPROM_READ(thrs);
+        #if ENABLED(X_IS_TMC2130)
+          stepperX.sgt(thrs);
+        #endif
+        #if ENABLED(X2_IS_TMC2130)
+          stepperX2.sgt(thrs);
+        #endif
+        EEPROM_READ(thrs);
+        #if ENABLED(Y_IS_TMC2130)
+          stepperY.sgt(thrs);
+        #endif
+        #if ENABLED(Y2_IS_TMC2130)
+          stepperY2.sgt(thrs);
+        #endif
+      #else
+        for (uint8_t q = 0; q < 2; q++) EEPROM_READ(thrs);
+      #endif
+
       //
       // Linear Advance
       //
@@ -1451,36 +1502,52 @@ void MarlinSettings::reset() {
     #endif
   );
 
-  #if ENABLED(HAVE_TMC2130)
+  #if X_IS_TRINAMIC
+    stepperX.setCurrent(X_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if Y_IS_TRINAMIC
+    stepperY.setCurrent(Y_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if Z_IS_TRINAMIC
+    stepperZ.setCurrent(Z_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if X2_IS_TRINAMIC
+    stepperX2.setCurrent(X2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if Y2_IS_TRINAMIC
+    stepperY2.setCurrent(Y2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if Z2_IS_TRINAMIC
+    stepperZ2.setCurrent(Z2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if E0_IS_TRINAMIC
+    stepperE0.setCurrent(E0_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if E1_IS_TRINAMIC
+    stepperE1.setCurrent(E1_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if E2_IS_TRINAMIC
+    stepperE2.setCurrent(E2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if E3_IS_TRINAMIC
+    stepperE3.setCurrent(E3_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+  #if E4_IS_TRINAMIC
+    stepperE4.setCurrent(E4_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+  #endif
+
+  #if ENABLED(SENSORLESS_HOMING)
     #if ENABLED(X_IS_TMC2130)
-      stepperX.setCurrent(X_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      stepperY.setCurrent(Y_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(Z_IS_TMC2130)
-      stepperZ.setCurrent(Z_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+      stepperX.sgt(X_HOMING_SENSITIVITY);
     #endif
     #if ENABLED(X2_IS_TMC2130)
-      stepperX2.setCurrent(X2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+      stepperX2.sgt(X_HOMING_SENSITIVITY);
     #endif
-    #if ENABLED(Y2_IS_TMC2130)
-      stepperY2.setCurrent(Y2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(Z2_IS_TMC2130)
-      stepperZ2.setCurrent(Z2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(E0_IS_TMC2130)
-      stepperE0.setCurrent(E0_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(E1_IS_TMC2130)
-      stepperE1.setCurrent(E1_CURRENT, R_SENSE, HOLD_MULTIPLIER);
-    #endif
-    #if ENABLED(E2_IS_TMC2130)
-      stepperE2.setCurrent(E2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #if ENABLED(Y_IS_TMC2130)
+      stepperY.sgt(Y_HOMING_SENSITIVITY);
     #endif
-    #if ENABLED(E3_IS_TMC2130)
-      stepperE3.setCurrent(E3_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #if ENABLED(Y2_IS_TMC2130)
+      stepperY2.sgt(Y_HOMING_SENSITIVITY);
     #endif
   #endif
 
@@ -1959,35 +2026,63 @@ void MarlinSettings::reset() {
       }
       CONFIG_ECHO_START;
       SERIAL_ECHO("  M906");
-      #if ENABLED(X_IS_TMC2130)
-        SERIAL_ECHOPAIR(" X", stepperX.getCurrent());
+      #if ENABLED(X_IS_TMC2130) || ENABLED(X_IS_TMC2208)
+        SERIAL_ECHOPAIR(" X ", stepperX.getCurrent());
       #endif
-      #if ENABLED(Y_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Y", stepperY.getCurrent());
+      #if ENABLED(Y_IS_TMC2130) || ENABLED(Y_IS_TMC2208)
+        SERIAL_ECHOPAIR(" Y ", stepperY.getCurrent());
       #endif
-      #if ENABLED(Z_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Z", stepperZ.getCurrent());
+      #if ENABLED(Z_IS_TMC2130) || ENABLED(Z_IS_TMC2208)
+        SERIAL_ECHOPAIR(" Z ", stepperZ.getCurrent());
       #endif
-      #if ENABLED(X2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" X2", stepperX2.getCurrent());
+      #if ENABLED(X2_IS_TMC2130) || ENABLED(X2_IS_TMC2208)
+        SERIAL_ECHOPAIR(" X2 ", stepperX2.getCurrent());
       #endif
-      #if ENABLED(Y2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Y2", stepperY2.getCurrent());
+      #if ENABLED(Y2_IS_TMC2130) || ENABLED(Y2_IS_TMC2208)
+        SERIAL_ECHOPAIR(" Y2 ", stepperY2.getCurrent());
       #endif
-      #if ENABLED(Z2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" Z2", stepperZ2.getCurrent());
+      #if ENABLED(Z2_IS_TMC2130) || ENABLED(Z2_IS_TMC2208)
+        SERIAL_ECHOPAIR(" Z2 ", stepperZ2.getCurrent());
       #endif
-      #if ENABLED(E0_IS_TMC2130)
-        SERIAL_ECHOPAIR(" E0", stepperE0.getCurrent());
+      #if ENABLED(E0_IS_TMC2130) || ENABLED(E0_IS_TMC2208)
+        SERIAL_ECHOPAIR(" E0 ", stepperE0.getCurrent());
       #endif
-      #if ENABLED(E1_IS_TMC2130)
-        SERIAL_ECHOPAIR(" E1", stepperE1.getCurrent());
+      #if ENABLED(E1_IS_TMC2130) || ENABLED(E1_IS_TMC2208)
+        SERIAL_ECHOPAIR(" E1 ", stepperE1.getCurrent());
       #endif
-      #if ENABLED(E2_IS_TMC2130)
-        SERIAL_ECHOPAIR(" E2", stepperE2.getCurrent());
+      #if ENABLED(E2_IS_TMC2130) || ENABLED(E2_IS_TMC2208)
+        SERIAL_ECHOPAIR(" E2 ", stepperE2.getCurrent());
       #endif
-      #if ENABLED(E3_IS_TMC2130)
-        SERIAL_ECHOPAIR(" E3", stepperE3.getCurrent());
+      #if ENABLED(E3_IS_TMC2130) || ENABLED(E3_IS_TMC2208)
+        SERIAL_ECHOPAIR(" E3 ", stepperE3.getCurrent());
+      #endif
+      #if ENABLED(E4_IS_TMC2130) || ENABLED(E4_IS_TMC2208)
+        SERIAL_ECHOPAIR(" E4 ", stepperE4.getCurrent());
+      #endif
+      SERIAL_EOL();
+    #endif
+
+    /**
+     * TMC2130 Sensorless homing thresholds
+     */
+    #if ENABLED(HAVE_TMC2130) && ENABLED(SENSORLESS_HOMING)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Sensorless homing threshold:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHO("  M914");
+      #if ENABLED(X_IS_TMC2130)
+        SERIAL_ECHOPAIR(" X", stepperX.sgt());
+      #endif
+      #if ENABLED(X2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" X2 ", stepperX2.sgt());
+      #endif
+      #if ENABLED(Y_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Y", stepperY.sgt());
+      #endif
+      #if ENABLED(X2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Y2 ", stepperY2.sgt());
       #endif
       SERIAL_EOL();
     #endif

commit a5150c83a2e0e686a9cc1ae2d4bea4fb75dacbc4
Author: victorpv <victor_pv@hotmail.com>
Date:   Sun Dec 10 23:12:45 2017 -0600

    [2.0.x] Multiple updates to STM32F1 HAL (#8733)
    
    * STM32F1 HAL
    
    Adding files for STM32F1 HAL based on libmaple/stm32duino core.
    Current persistent_store uses cardreader changes to be sent in separate
    commit, but could be changed to use i2c eeprom.
    There is another persistent_store implementation that uses the MCU flash memory
    to emulate eeprom
    Adding readme with some information about the stm32 HAL.
    
    * Switch to Timer4 to avoid a hard reset on STM32F103C6 boards
    
    On bluepill STM32F103C6 boards, using Timer5 results in a error() vector call. Switch to 4 since these are both general purpose, 16 bit timers.
    
    * Add support for EEPROM emulation using Flash
    
    Some low end machines doe not have EEPROM support. Simulate it using the last two pages of flash. Flash does not allow rewrite between erases, so skip writing the working version if that's enabled.
    
    * Basic Pins for a malyan M200
    
    This is a work in progress to go hand in hand with the STM32 work.
    
    * Add support for ADC with DMA. This work has exposed a problem with the pin enumerations in STM boards vs what marlin expects (i.e, try defining PA0 as a temp pin). The hack can be removed with we go to fastio completely. To see this work, set something in adc_pins to a value like PA0 and connect your pullup resistor'd thermistor.
    
    * Missing file - change HAL_adc_init to actually do something
    
    We have an actual ADC init function now.
    
    * Remove pinmode hack
    
    Remove the pin mode hack that I was using to init PA0.
    
    Updated Readme.md
    
    * Several changes to timers and GPIO
    
    Faster GPIO, and faster timer functions by accesing registers and
    libmaple.
    Still more changes pending for the Timer's code to skip using the
    HardwareTimer class altogether.
    
    Switch all enums to be within #defines
    
    This change allows a user to have, for instance, TEMP_4 and TEMP_BED definied but nothing else. The enums which are not defined move "out", allowing the first ones to take the slots in the enum, and since the array is sized on ADC_PIN_COUNT, we always have the right size data and in order.
    
    * Update Malyan M200 pins
    
    Update Malyan M200 pins with correct fan values.
    
    * Test all pins on actual hardware, update definitions
    
    Some of the pin definitions were from knowlege base/pdfs. Now they've been tested against actual hardware. This should be very close to final.
    
    * Update HAL_timers_Stm32f1.cpp
    
    * Add sample configurations for Malyan M200
    
    Add sample configuration for Malyan M200 without bed leveling, and move fan to auto cool E0 since this printer by default has only one fan.
    
    
    Choose the timer based on MCU defintion. Timer5 is not valid on C8/CB class boards, so use Timer4 for the step timer.
    
    
    readme.md update
    
    * Updates to timers, and some stm32 boards definitiions
    
    * Correct pin toggle macro.
    
    * Remove duplicated Malyan M200 entry from pins.h
    
    * Update configuration_store.cpp
    
    * Formatting, indentation
    
    * Formatting in HAL_Stm32f1.cpp

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d076cf02c0..81260a5c9f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -299,8 +299,11 @@ void MarlinSettings::postprocess() {
     EEPROM_START();
 
     eeprom_error = false;
-
-    EEPROM_WRITE(ver);     // invalidate data first
+    #if ENABLED(FLASH_EEPROM_EMULATION)
+      EEPROM_SKIP(ver);   // Flash doesn't allow rewriting without erase
+    #else
+      EEPROM_WRITE(ver);  // invalidate data first
+    #endif
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"

commit 204199e1ce30ecb17fb922cbf27a7cb0c2b51680
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 10 22:57:24 2017 -0600

    Only compare XYZ to check motion

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 1ee19e46a3..d076cf02c0 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -220,10 +220,7 @@ MarlinSettings settings;
  * Post-process after Retrieve or Reset
  */
 void MarlinSettings::postprocess() {
-  const float oldpos[XYZE] = {
-    current_position[X_AXIS], current_position[Y_AXIS],
-    current_position[Z_AXIS], current_position[E_AXIS]
-  };
+  const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
 
   // steps per s2 needs to be updated to agree with units per s2
   planner.reset_acceleration_rates();

commit 6686d937fb9c08de14b9f0b8ecf07fa5a7433719
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 10 21:39:07 2017 -0600

    Always report position on config load/reset

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3eef0d8b3d..1ee19e46a3 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -216,14 +216,15 @@ MarlinSettings settings;
   float new_z_fade_height;
 #endif
 
-#if ENABLED(CNC_COORDINATE_SYSTEMS)
-  bool position_changed;
-#endif
-
 /**
  * Post-process after Retrieve or Reset
  */
 void MarlinSettings::postprocess() {
+  const float oldpos[XYZE] = {
+    current_position[X_AXIS], current_position[Y_AXIS],
+    current_position[Z_AXIS], current_position[E_AXIS]
+  };
+
   // steps per s2 needs to be updated to agree with units per s2
   planner.reset_acceleration_rates();
 
@@ -233,10 +234,6 @@ void MarlinSettings::postprocess() {
     recalc_delta_settings();
   #endif
 
-  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
-  // and init stepper.count[], planner.position[] with current_position
-  planner.refresh_positioning();
-
   #if ENABLED(PIDTEMP)
     thermalManager.updatePID();
   #endif
@@ -249,7 +246,7 @@ void MarlinSettings::postprocess() {
   #endif
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    set_z_fade_height(new_z_fade_height);
+    set_z_fade_height(new_z_fade_height, false); // false = no report
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -264,13 +261,14 @@ void MarlinSettings::postprocess() {
   #if ENABLED(FWRETRACT)
     fwretract.refresh_autoretract();
   #endif
+ 
+  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
+  // and init stepper.count[], planner.position[] with current_position
+  planner.refresh_positioning();
 
-  #if ENABLED(CNC_COORDINATE_SYSTEMS)
-    if (position_changed) {
-      report_current_position();
-      position_changed = false;
-    }
-  #endif
+  // Various factors can change the current position
+  if (memcmp(oldpos, current_position, sizeof(oldpos)))
+    report_current_position();
 }
 
 #if ENABLED(EEPROM_SETTINGS)
@@ -308,7 +306,7 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(ver);     // invalidate data first
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
-    working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
+    working_crc = 0; // clear before first "real data"
 
     const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
@@ -342,7 +340,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       const float zfh = planner.z_fade_height;
     #else
-      const float zfh = 0.0;
+      const float zfh = 10.0;
     #endif
     EEPROM_WRITE(zfh);
 
@@ -725,7 +723,7 @@ void MarlinSettings::postprocess() {
       float dummy = 0;
       bool dummyb;
 
-      working_crc = 0; //clear before reading first "real data"
+      working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       // Number of esteppers may change
       uint8_t esteppers;
@@ -913,7 +911,6 @@ void MarlinSettings::postprocess() {
       #if DISABLED(ULTIPANEL)
         int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
       #endif
-
       EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
       EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
       EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
@@ -1094,7 +1091,7 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(CNC_COORDINATE_SYSTEMS)
-        position_changed = gcode.select_coordinate_system(-1); // Go back to machine space
+        (void)gcode.select_coordinate_system(-1); // Go back to machine space
         EEPROM_READ(gcode.coordinate_system);                  // 27 floats
       #else
         for (uint8_t q = 27; q--;) EEPROM_READ(dummy);

commit a4e1d83599f0daeabf7e7096e131b5c66b7bb017
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:16:00 2017 -0600

    Fix M503 S parameter

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 9caebff1ac..3eef0d8b3d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1527,7 +1527,7 @@ void MarlinSettings::reset() {
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
-  void MarlinSettings::report(bool forReplay) {
+  void MarlinSettings::report(const bool forReplay) {
 
     /**
      * Announce current units, in case inches are being displayed

commit 05f8e98c4ab1f96ddb0af0dcc51af838ec9b0c30
Author: Jonathan Barchi <barchij@gmail.com>
Date:   Sat Dec 2 17:04:58 2017 -0800

    Fix for issue #8629 - mismatch between number of stored and loaded dummy items on non-delta machines. (#8631)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index bd313caab5..9caebff1ac 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -898,11 +898,11 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(dummy);
         #endif
 
-        for (uint8_t q=7; q--;) EEPROM_READ(dummy);
+        for (uint8_t q=8; q--;) EEPROM_READ(dummy);
 
       #else
 
-        for (uint8_t q=10; q--;) EEPROM_READ(dummy);
+        for (uint8_t q=11; q--;) EEPROM_READ(dummy);
 
       #endif
 

commit 0154e3480c44bf9d96d662382da25afaaf3fd854
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 16:42:23 2017 -0600

    New feature: BED_SKEW_CORRECTION

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index c2239c6c3a..bd313caab5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V45"
+#define EEPROM_VERSION "V46"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V45 EEPROM Layout:
+ * V46 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -166,8 +166,13 @@
  * CNC_COORDINATE_SYSTEMS                           108 bytes
  *  602  G54-G59.3 coordinate_system                (float x 27)
  *
- *  710                                   Minimum end-point
- * 2239 (710 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
+ * SKEW_CORRECTION:                                 12 bytes
+ *  710  M852 I    planner.xy_skew_factor           (float)
+ *  714  M852 J    planner.xz_skew_factor           (float)
+ *  718  M852 K    planner.yz_skew_factor           (float)
+ *
+ *  722                                   Minimum end-point
+ * 2251 (722 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -633,6 +638,10 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 3; q--;) EEPROM_WRITE(dummyui32);
     #endif
 
+    //
+    // CNC Coordinate Systems
+    //
+
     #if ENABLED(CNC_COORDINATE_SYSTEMS)
       EEPROM_WRITE(coordinate_system); // 27 floats
     #else
@@ -640,6 +649,19 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 27; q--;) EEPROM_WRITE(dummy);
     #endif
 
+    //
+    // Skew correction factors
+    //
+
+    #if ENABLED(SKEW_CORRECTION)
+      EEPROM_WRITE(planner.xy_skew_factor);
+      EEPROM_WRITE(planner.xz_skew_factor);
+      EEPROM_WRITE(planner.yz_skew_factor);
+    #else
+      dummy = 0.0f;
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
+    #endif
+
     if (!eeprom_error) {
       #if ENABLED(EEPROM_CHITCHAT)
         const int eeprom_size = eeprom_index;
@@ -1078,6 +1100,23 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 27; q--;) EEPROM_READ(dummy);
       #endif
 
+      //
+      // Skew correction factors
+      //
+
+      #if ENABLED(SKEW_CORRECTION_GCODE)
+        EEPROM_READ(planner.xy_skew_factor);
+        #if ENABLED(SKEW_CORRECTION_FOR_Z)
+          EEPROM_READ(planner.xz_skew_factor);
+          EEPROM_READ(planner.yz_skew_factor);
+        #else
+          EEPROM_READ(dummy);
+          EEPROM_READ(dummy);
+        #endif
+      #else
+        for (uint8_t q = 3; q--;) EEPROM_READ(dummy);
+      #endif
+
       if (working_crc == stored_crc) {
         postprocess();
         #if ENABLED(EEPROM_CHITCHAT)
@@ -1463,6 +1502,14 @@ void MarlinSettings::reset() {
     ubl.reset();
   #endif
 
+  #if ENABLED(SKEW_CORRECTION_GCODE)
+    planner.xy_skew_factor = XY_SKEW_FACTOR;
+    #if ENABLED(SKEW_CORRECTION_FOR_Z)
+      planner.xz_skew_factor = XZ_SKEW_FACTOR;
+      planner.yz_skew_factor = YZ_SKEW_FACTOR;
+    #endif
+  #endif
+
   postprocess();
 
   #if ENABLED(EEPROM_CHITCHAT)
@@ -1887,6 +1934,24 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR("  M851 Z", LINEAR_UNIT(zprobe_zoffset));
     #endif
 
+    /**
+     * Bed Skew Correction
+     */
+    #if ENABLED(SKEW_CORRECTION_GCODE)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Skew Factor: ");
+      }
+      CONFIG_ECHO_START;
+      #if ENABLED(SKEW_CORRECTION_FOR_Z)
+        SERIAL_ECHOPAIR("  M852 I", LINEAR_UNIT(planner.xy_skew_factor));
+        SERIAL_ECHOPAIR(" J", LINEAR_UNIT(planner.xz_skew_factor));
+        SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(planner.yz_skew_factor));
+      #else
+        SERIAL_ECHOLNPAIR("  M852 S", LINEAR_UNIT(planner.xy_skew_factor));
+      #endif
+    #endif
+
     /**
      * TMC2130 stepper driver current
      */

commit 91fb6231b2a779c86b15a552add2e16aa09ce5f1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 22:45:17 2017 -0600

    Fix EEPROM V45 header, layout

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 821b97fc59..c2239c6c3a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -42,15 +42,15 @@
 #define EEPROM_OFFSET 100
 
 /**
- * V44 EEPROM Layout:
+ * V45 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
  *
  *  106            E_STEPPERS                       (uint8_t)
- *  107  M92 XYZE  planner.axis_steps_per_mm        (float x4 ... x8)
- *  123  M203 XYZE planner.max_feedrate_mm_s        (float x4 ... x8)
- *  139  M201 XYZE planner.max_acceleration_mm_per_s2 (uint32_t x4 ... x8)
+ *  107  M92 XYZE  planner.axis_steps_per_mm        (float x4 ... x8) + 64
+ *  123  M203 XYZE planner.max_feedrate_mm_s        (float x4 ... x8) + 64
+ *  139  M201 XYZE planner.max_acceleration_mm_per_s2 (uint32_t x4 ... x8) + 64
  *  155  M204 P    planner.acceleration             (float)
  *  159  M204 R    planner.retract_acceleration     (float)
  *  163  M204 T    planner.travel_acceleration      (float)
@@ -62,7 +62,7 @@
  *  187  M205 Z    planner.max_jerk[Z_AXIS]         (float)
  *  191  M205 E    planner.max_jerk[E_AXIS]         (float)
  *  195  M206 XYZ  home_offset                      (float x3)
- *  207  M218 XYZ  hotend_offset                    (float x3 per additional hotend)
+ *  207  M218 XYZ  hotend_offset                    (float x3 per additional hotend) +16
  *
  * Global Leveling:                                 4 bytes
  *  219            z_fade_height                    (float)
@@ -88,86 +88,86 @@
  *  316            z_values[][]                     (float x9, up to float x256) +988
  *
  * AUTO_BED_LEVELING_UBL:                           2 bytes
- *  324  G29 A     planner.leveling_active          (bool)
- *  325  G29 S     ubl.storage_slot                 (int8_t)
+ *  352  G29 A     planner.leveling_active          (bool)
+ *  353  G29 S     ubl.storage_slot                 (int8_t)
  *
  * DELTA:                                           44 bytes
- *  352  M666 H    delta_height                     (float)
- *  364  M666 XYZ  delta_endstop_adj                (float x3)
- *  368  M665 R    delta_radius                     (float)
- *  372  M665 L    delta_diagonal_rod               (float)
- *  376  M665 S    delta_segments_per_second        (float)
- *  380  M665 B    delta_calibration_radius         (float)
- *  384  M665 X    delta_tower_angle_trim[A]        (float)
- *  388  M665 Y    delta_tower_angle_trim[B]        (float)
- *  392  M665 Z    delta_tower_angle_trim[C]        (float)
+ *  354  M666 H    delta_height                     (float)
+ *  358  M666 XYZ  delta_endstop_adj                (float x3)
+ *  370  M665 R    delta_radius                     (float)
+ *  374  M665 L    delta_diagonal_rod               (float)
+ *  378  M665 S    delta_segments_per_second        (float)
+ *  382  M665 B    delta_calibration_radius         (float)
+ *  386  M665 X    delta_tower_angle_trim[A]        (float)
+ *  390  M665 Y    delta_tower_angle_trim[B]        (float)
+ *  394  M665 Z    delta_tower_angle_trim[C]        (float)
  *
  * [XYZ]_DUAL_ENDSTOPS:                             12 bytes
- *  352  M666 X    endstops.x_endstop_adj           (float)
- *  356  M666 Y    endstops.y_endstop_adj           (float)
- *  360  M666 Z    endstops.z_endstop_adj           (float)
+ *  354  M666 X    x_endstop_adj                    (float)
+ *  358  M666 Y    y_endstop_adj                    (float)
+ *  362  M666 Z    z_endstop_adj                    (float)
  *
  * ULTIPANEL:                                       6 bytes
- *  396  M145 S0 H lcd_preheat_hotend_temp          (int x2)
- *  400  M145 S0 B lcd_preheat_bed_temp             (int x2)
- *  404  M145 S0 F lcd_preheat_fan_speed            (int x2)
+ *  398  M145 S0 H lcd_preheat_hotend_temp          (int x2)
+ *  402  M145 S0 B lcd_preheat_bed_temp             (int x2)
+ *  406  M145 S0 F lcd_preheat_fan_speed            (int x2)
  *
  * PIDTEMP:                                         82 bytes
- *  408  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
- *  428  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
- *  440  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
- *  456  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  472  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  488  M301 L        lpq_len                      (int)
+ *  410  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
+ *  426  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
+ *  442  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
+ *  458  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  474  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  490  M301 L        lpq_len                      (int)
  *
  * PIDTEMPBED:                                      12 bytes
- *  490  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
+ *  492  M304 PID  bedKp, .bedKi, .bedKd            (float x3)
  *
  * DOGLCD:                                          2 bytes
- *  502  M250 C    lcd_contrast                     (uint16_t)
+ *  504  M250 C    lcd_contrast                     (uint16_t)
  *
  * FWRETRACT:                                       33 bytes
- *  504  M209 S    autoretract_enabled              (bool)
- *  505  M207 S    retract_length                   (float)
- *  509  M207 F    retract_feedrate_mm_s            (float)
- *  513  M207 Z    retract_zlift                    (float)
- *  517  M208 S    retract_recover_length           (float)
- *  521  M208 F    retract_recover_feedrate_mm_s    (float)
- *  525  M207 W    swap_retract_length              (float)
- *  529  M208 W    swap_retract_recover_length      (float)
- *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
+ *  506  M209 S    autoretract_enabled              (bool)
+ *  507  M207 S    retract_length                   (float)
+ *  511  M207 F    retract_feedrate_mm_s            (float)
+ *  515  M207 Z    retract_zlift                    (float)
+ *  519  M208 S    retract_recover_length           (float)
+ *  523  M208 F    retract_recover_feedrate_mm_s    (float)
+ *  527  M207 W    swap_retract_length              (float)
+ *  531  M208 W    swap_retract_recover_length      (float)
+ *  535  M208 R    swap_retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:                            21 bytes
- *  537  M200 D    parser.volumetric_enabled        (bool)
- *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
+ *  539  M200 D    parser.volumetric_enabled        (bool)
+ *  540  M200 T D  planner.filament_size            (float x5) (T0..3)
  *
  * HAVE_TMC2130:                                    22 bytes
- *  558  M906 X    Stepper X current                (uint16_t)
- *  560  M906 Y    Stepper Y current                (uint16_t)
- *  562  M906 Z    Stepper Z current                (uint16_t)
- *  564  M906 X2   Stepper X2 current               (uint16_t)
- *  566  M906 Y2   Stepper Y2 current               (uint16_t)
- *  568  M906 Z2   Stepper Z2 current               (uint16_t)
- *  570  M906 E0   Stepper E0 current               (uint16_t)
- *  572  M906 E1   Stepper E1 current               (uint16_t)
- *  574  M906 E2   Stepper E2 current               (uint16_t)
- *  576  M906 E3   Stepper E3 current               (uint16_t)
- *  578  M906 E4   Stepper E4 current               (uint16_t)
+ *  560  M906 X    Stepper X current                (uint16_t)
+ *  562  M906 Y    Stepper Y current                (uint16_t)
+ *  564  M906 Z    Stepper Z current                (uint16_t)
+ *  566  M906 X2   Stepper X2 current               (uint16_t)
+ *  568  M906 Y2   Stepper Y2 current               (uint16_t)
+ *  570  M906 Z2   Stepper Z2 current               (uint16_t)
+ *  572  M906 E0   Stepper E0 current               (uint16_t)
+ *  574  M906 E1   Stepper E1 current               (uint16_t)
+ *  576  M906 E2   Stepper E2 current               (uint16_t)
+ *  578  M906 E3   Stepper E3 current               (uint16_t)
+ *  580  M906 E4   Stepper E4 current               (uint16_t)
  *
  * LIN_ADVANCE:                                     8 bytes
- *  580  M900 K    extruder_advance_k               (float)
- *  584  M900 WHD  advance_ed_ratio                 (float)
+ *  582  M900 K    extruder_advance_k               (float)
+ *  586  M900 WHD  advance_ed_ratio                 (float)
  *
  * HAS_MOTOR_CURRENT_PWM:
- *  588  M907 X    Stepper XY current               (uint32_t)
- *  592  M907 Z    Stepper Z current                (uint32_t)
- *  596  M907 E    Stepper E current                (uint32_t)
+ *  590  M907 X    Stepper XY current               (uint32_t)
+ *  594  M907 Z    Stepper Z current                (uint32_t)
+ *  598  M907 E    Stepper E current                (uint32_t)
  *
  * CNC_COORDINATE_SYSTEMS                           108 bytes
- *  600  G54-G59.3 coordinate_system                (float x 27)
+ *  602  G54-G59.3 coordinate_system                (float x 27)
  *
- *  708                                Minimum end-point
- * 2025 (704 + 36 + 9 + 288 + 988)     Maximum end-point
+ *  710                                   Minimum end-point
+ * 2239 (710 + 208 + 36 + 9 + 288 + 988)  Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -422,7 +422,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
-    // 10 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
+    // 11 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
       EEPROM_WRITE(delta_height);              // 1 float
       EEPROM_WRITE(delta_endstop_adj);         // 3 floats
@@ -453,11 +453,11 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(dummy);
       #endif
 
-      for (uint8_t q = 7; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = 8; q--;) EEPROM_WRITE(dummy);
 
     #else
       dummy = 0.0f;
-      for (uint8_t q = 10; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
     #endif
 
     #if DISABLED(ULTIPANEL)

commit a9ecb975b2a0fbaa97a1051b77d5d78d02e8e7bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 24 17:27:56 2017 -0600

    Apply LINEAR_UNIT to M503 output for M200

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 404a987611..821b97fc59 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1487,15 +1487,15 @@ void MarlinSettings::reset() {
      */
     CONFIG_ECHO_START;
     #if ENABLED(INCH_MODE_SUPPORT)
-      #define LINEAR_UNIT(N) ((N) / parser.linear_unit_factor)
-      #define VOLUMETRIC_UNIT(N) ((N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
+      #define LINEAR_UNIT(N) (float(N) / parser.linear_unit_factor)
+      #define VOLUMETRIC_UNIT(N) (float(N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
       SERIAL_ECHOPGM("  G2");
       SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
       SERIAL_ECHOPGM(" ; Units in ");
       serialprintPGM(parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
     #else
-      #define LINEAR_UNIT(N) N
-      #define VOLUMETRIC_UNIT(N) N
+      #define LINEAR_UNIT(N) (N)
+      #define VOLUMETRIC_UNIT(N) (N)
       SERIAL_ECHOLNPGM("  G21    ; Units in mm");
     #endif
 
@@ -1511,7 +1511,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOPGM(" ; Units in ");
         serialprintPGM(parser.temp_units_name());
       #else
-        #define TEMP_UNIT(N) N
+        #define TEMP_UNIT(N) (N)
         SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
       #endif
 
@@ -1532,23 +1532,23 @@ void MarlinSettings::reset() {
     }
 
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M200 D", planner.filament_size[0]);
+    SERIAL_ECHOPAIR("  M200 D", LINEAR_UNIT(planner.filament_size[0]));
     SERIAL_EOL();
     #if EXTRUDERS > 1
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M200 T1 D", planner.filament_size[1]);
+      SERIAL_ECHOPAIR("  M200 T1 D", LINEAR_UNIT(planner.filament_size[1]));
       SERIAL_EOL();
       #if EXTRUDERS > 2
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M200 T2 D", planner.filament_size[2]);
+        SERIAL_ECHOPAIR("  M200 T2 D", LINEAR_UNIT(planner.filament_size[2]));
         SERIAL_EOL();
         #if EXTRUDERS > 3
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M200 T3 D", planner.filament_size[3]);
+          SERIAL_ECHOPAIR("  M200 T3 D", LINEAR_UNIT(planner.filament_size[3]));
           SERIAL_EOL();
           #if EXTRUDERS > 4
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M200 T4 D", planner.filament_size[4]);
+            SERIAL_ECHOPAIR("  M200 T4 D", LINEAR_UNIT(planner.filament_size[4]));
             SERIAL_EOL();
           #endif // EXTRUDERS > 4
         #endif // EXTRUDERS > 3

commit 3bba7d60f352c7da638bc1fb65b279cd972d9b79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 16:53:55 2017 -0600

    No retroactive changes with M851 Z
    
    If using babystep to adjust the Z probe offset, the axis will move and the mesh will be updated at the same time, causing a doubling of the Z offset over the rest of the print.
    
    To correct for this, the current Z position would need to be modified in the opposite direction, canceling out the additional Z offset added to the mesh. This would be confusing to users, and moreover it would not be accurate without also taking the current Z fade level and current Z height into account.
    
    It might make sense to change the mesh in the case where no babystepping is taking place, but this could be considered an undesirable side-effect of changing the `zprobe_zoffset`.
    
    One way to remedy this would be to return to storing the mesh with `zprobe_zoffset` included, then subtracting `zprobe_zoffset` from the returned Z value. Thus, a babystep moving the Z axis up 1mm would subtract 1 from `zprobe_zoffset` while adding 1 to all mesh Z values.
    
    Without including the `zprobe_zoffset` in the `z_values` there is no safe way to alter the mesh in conjunction with babystepping, although it's fine without it.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 65c55c145c..404a987611 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -247,10 +247,6 @@ void MarlinSettings::postprocess() {
     set_z_fade_height(new_z_fade_height);
   #endif
 
-  #if HAS_BED_PROBE
-    refresh_zprobe_zoffset();
-  #endif
-
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     refresh_bed_level();
     //set_bed_leveling_enabled(leveling_is_on);
@@ -355,9 +351,8 @@ void MarlinSettings::postprocess() {
         sizeof(mbl.z_values) == GRID_MAX_POINTS * sizeof(mbl.z_values[0][0]),
         "MBL Z array is the wrong size."
       );
-      const bool leveling_is_on = mbl.has_mesh;
       const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
-      EEPROM_WRITE(leveling_is_on);
+      EEPROM_WRITE(mbl.has_mesh);
       EEPROM_WRITE(mbl.z_offset);
       EEPROM_WRITE(mesh_num_x);
       EEPROM_WRITE(mesh_num_y);

commit 63257dc0831555791eed5d016ab6fb9b7a70957f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 15 03:58:43 2017 -0600

    Fix M503 output for M145
    
    Fixes #7978

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index ca51a40133..65c55c145c 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1784,8 +1784,8 @@ void MarlinSettings::reset() {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Material heatup parameters:");
       }
-      CONFIG_ECHO_START;
       for (uint8_t i = 0; i < COUNT(lcd_preheat_hotend_temp); i++) {
+        CONFIG_ECHO_START;
         SERIAL_ECHOPAIR("  M145 S", (int)i);
         SERIAL_ECHOPAIR(" H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
         SERIAL_ECHOPAIR(" B", TEMP_UNIT(lcd_preheat_bed_temp[i]));

commit 36426af564cb2c11825b83cdd6c1976b874b6ab7
Merge: c0fe6cc34d cba9c1cf9e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 10 19:44:08 2017 -0600

    Merge pull request #8356 from tcm0116/2.0.x-M600
    
    [2.0.x] Normalize load/unload length in M600

diff --combined Marlin/src/module/configuration_store.cpp
index 30e6857188,c75a58a64d..ca51a40133
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@@ -138,8 -138,8 +138,8 @@@
   *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
   *
   * Volumetric Extrusion:                            21 bytes
-  *  537  M200 D    volumetric_enabled               (bool)
-  *  538  M200 T D  filament_size                    (float x5) (T0..3)
+  *  537  M200 D    parser.volumetric_enabled        (bool)
+  *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
   *
   * HAVE_TMC2130:                                    22 bytes
   *  558  M906 X    Stepper X current                (uint16_t)
@@@ -225,7 -225,7 +225,7 @@@ void MarlinSettings::postprocess() 
    // Make sure delta kinematics are updated before refreshing the
    // planner position so the stepper counts will be set correctly.
    #if ENABLED(DELTA)
 -    recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
 +    recalc_delta_settings();
    #endif
  
    // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm

commit e334efb2a7914b6a39fb3c060790319664d98b2d
Author: LVD-AC <lvd@sound-silence.com>
Date:   Wed Nov 8 10:07:17 2017 +0100

    PROBE_MANUALLY etc.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 60a5da4da5..30e6857188 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -225,7 +225,7 @@ void MarlinSettings::postprocess() {
   // Make sure delta kinematics are updated before refreshing the
   // planner position so the stepper counts will be set correctly.
   #if ENABLED(DELTA)
-    recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+    recalc_delta_settings();
   #endif
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 60a5da4da5..c75a58a64d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -138,8 +138,8 @@
  *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:                            21 bytes
- *  537  M200 D    volumetric_enabled               (bool)
- *  538  M200 T D  filament_size                    (float x5) (T0..3)
+ *  537  M200 D    parser.volumetric_enabled        (bool)
+ *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
  *
  * HAVE_TMC2130:                                    22 bytes
  *  558  M906 X    Stepper X current                (uint16_t)

commit f34c3597dcaef54624c82f732f13151215bbe650
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Wed Nov 8 22:10:08 2017 -0600

    Add delta_height variable in lieu of using home_offset

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index c7b99a91c5..60a5da4da5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,7 +36,7 @@
  *
  */
 
-#define EEPROM_VERSION "V44"
+#define EEPROM_VERSION "V45"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
@@ -91,15 +91,16 @@
  *  324  G29 A     planner.leveling_active          (bool)
  *  325  G29 S     ubl.storage_slot                 (int8_t)
  *
- * DELTA:                                           40 bytes
- *  352  M666 XYZ  delta_endstop_adj                (float x3)
- *  364  M665 R    delta_radius                     (float)
- *  368  M665 L    delta_diagonal_rod               (float)
- *  372  M665 S    delta_segments_per_second        (float)
- *  376  M665 B    delta_calibration_radius         (float)
- *  380  M665 X    delta_tower_angle_trim[A]        (float)
- *  384  M665 Y    delta_tower_angle_trim[B]        (float)
- *  388  M665 Z    delta_tower_angle_trim[C]        (float)
+ * DELTA:                                           44 bytes
+ *  352  M666 H    delta_height                     (float)
+ *  364  M666 XYZ  delta_endstop_adj                (float x3)
+ *  368  M665 R    delta_radius                     (float)
+ *  372  M665 L    delta_diagonal_rod               (float)
+ *  376  M665 S    delta_segments_per_second        (float)
+ *  380  M665 B    delta_calibration_radius         (float)
+ *  384  M665 X    delta_tower_angle_trim[A]        (float)
+ *  388  M665 Y    delta_tower_angle_trim[B]        (float)
+ *  392  M665 Z    delta_tower_angle_trim[C]        (float)
  *
  * [XYZ]_DUAL_ENDSTOPS:                             12 bytes
  *  352  M666 X    endstops.x_endstop_adj           (float)
@@ -107,65 +108,65 @@
  *  360  M666 Z    endstops.z_endstop_adj           (float)
  *
  * ULTIPANEL:                                       6 bytes
- *  392  M145 S0 H lcd_preheat_hotend_temp          (int x2)
- *  396  M145 S0 B lcd_preheat_bed_temp             (int x2)
- *  400  M145 S0 F lcd_preheat_fan_speed            (int x2)
+ *  396  M145 S0 H lcd_preheat_hotend_temp          (int x2)
+ *  400  M145 S0 B lcd_preheat_bed_temp             (int x2)
+ *  404  M145 S0 F lcd_preheat_fan_speed            (int x2)
  *
  * PIDTEMP:                                         82 bytes
- *  404  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
- *  420  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
- *  436  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
- *  452  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  468  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  484  M301 L        lpq_len                      (int)
+ *  408  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
+ *  428  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
+ *  440  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
+ *  456  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  472  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  488  M301 L        lpq_len                      (int)
  *
  * PIDTEMPBED:                                      12 bytes
- *  486  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
+ *  490  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
  *
  * DOGLCD:                                          2 bytes
- *  498  M250 C    lcd_contrast                     (uint16_t)
+ *  502  M250 C    lcd_contrast                     (uint16_t)
  *
  * FWRETRACT:                                       33 bytes
- *  500  M209 S    autoretract_enabled              (bool)
- *  501  M207 S    retract_length                   (float)
- *  505  M207 F    retract_feedrate_mm_s            (float)
- *  509  M207 Z    retract_zlift                    (float)
- *  513  M208 S    retract_recover_length           (float)
- *  517  M208 F    retract_recover_feedrate_mm_s    (float)
- *  521  M207 W    swap_retract_length              (float)
- *  525  M208 W    swap_retract_recover_length      (float)
- *  529  M208 R    swap_retract_recover_feedrate_mm_s (float)
+ *  504  M209 S    autoretract_enabled              (bool)
+ *  505  M207 S    retract_length                   (float)
+ *  509  M207 F    retract_feedrate_mm_s            (float)
+ *  513  M207 Z    retract_zlift                    (float)
+ *  517  M208 S    retract_recover_length           (float)
+ *  521  M208 F    retract_recover_feedrate_mm_s    (float)
+ *  525  M207 W    swap_retract_length              (float)
+ *  529  M208 W    swap_retract_recover_length      (float)
+ *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:                            21 bytes
- *  533  M200 D    volumetric_enabled               (bool)
- *  534  M200 T D  filament_size                    (float x5) (T0..3)
+ *  537  M200 D    volumetric_enabled               (bool)
+ *  538  M200 T D  filament_size                    (float x5) (T0..3)
  *
  * HAVE_TMC2130:                                    22 bytes
- *  554  M906 X    Stepper X current                (uint16_t)
- *  556  M906 Y    Stepper Y current                (uint16_t)
- *  558  M906 Z    Stepper Z current                (uint16_t)
- *  560  M906 X2   Stepper X2 current               (uint16_t)
- *  562  M906 Y2   Stepper Y2 current               (uint16_t)
- *  564  M906 Z2   Stepper Z2 current               (uint16_t)
- *  566  M906 E0   Stepper E0 current               (uint16_t)
- *  568  M906 E1   Stepper E1 current               (uint16_t)
- *  570  M906 E2   Stepper E2 current               (uint16_t)
- *  572  M906 E3   Stepper E3 current               (uint16_t)
- *  574  M906 E4   Stepper E4 current               (uint16_t)
+ *  558  M906 X    Stepper X current                (uint16_t)
+ *  560  M906 Y    Stepper Y current                (uint16_t)
+ *  562  M906 Z    Stepper Z current                (uint16_t)
+ *  564  M906 X2   Stepper X2 current               (uint16_t)
+ *  566  M906 Y2   Stepper Y2 current               (uint16_t)
+ *  568  M906 Z2   Stepper Z2 current               (uint16_t)
+ *  570  M906 E0   Stepper E0 current               (uint16_t)
+ *  572  M906 E1   Stepper E1 current               (uint16_t)
+ *  574  M906 E2   Stepper E2 current               (uint16_t)
+ *  576  M906 E3   Stepper E3 current               (uint16_t)
+ *  578  M906 E4   Stepper E4 current               (uint16_t)
  *
  * LIN_ADVANCE:                                     8 bytes
- *  576  M900 K    extruder_advance_k               (float)
- *  580  M900 WHD  advance_ed_ratio                 (float)
+ *  580  M900 K    extruder_advance_k               (float)
+ *  584  M900 WHD  advance_ed_ratio                 (float)
  *
  * HAS_MOTOR_CURRENT_PWM:
- *  584  M907 X    Stepper XY current               (uint32_t)
- *  588  M907 Z    Stepper Z current                (uint32_t)
- *  592  M907 E    Stepper E current                (uint32_t)
+ *  588  M907 X    Stepper XY current               (uint32_t)
+ *  592  M907 Z    Stepper Z current                (uint32_t)
+ *  596  M907 E    Stepper E current                (uint32_t)
  *
  * CNC_COORDINATE_SYSTEMS                           108 bytes
- *  596  G54-G59.3 coordinate_system                (float x 27)
+ *  600  G54-G59.3 coordinate_system                (float x 27)
  *
- *  704                                Minimum end-point
+ *  708                                Minimum end-point
  * 2025 (704 + 36 + 9 + 288 + 988)     Maximum end-point
  *
  * ========================================================================
@@ -325,15 +326,7 @@ void MarlinSettings::postprocess() {
     #if !HAS_HOME_OFFSET
       const float home_offset[XYZ] = { 0 };
     #endif
-    #if ENABLED(DELTA)
-      dummy = 0.0;
-      EEPROM_WRITE(dummy);
-      EEPROM_WRITE(dummy);
-      dummy = DELTA_HEIGHT + home_offset[Z_AXIS];
-      EEPROM_WRITE(dummy);
-    #else
-      EEPROM_WRITE(home_offset);
-    #endif
+    EEPROM_WRITE(home_offset);
 
     #if HOTENDS > 1
       // Skip hotend 0 which must be 0
@@ -436,6 +429,7 @@ void MarlinSettings::postprocess() {
 
     // 10 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
+      EEPROM_WRITE(delta_height);              // 1 float
       EEPROM_WRITE(delta_endstop_adj);         // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
       EEPROM_WRITE(delta_diagonal_rod);        // 1 float
@@ -756,12 +750,6 @@ void MarlinSettings::postprocess() {
       #endif
       EEPROM_READ(home_offset);
 
-      #if ENABLED(DELTA)
-        home_offset[X_AXIS] = 0.0;
-        home_offset[Y_AXIS] = 0.0;
-        home_offset[Z_AXIS] -= DELTA_HEIGHT;
-      #endif
-
       //
       // Hotend Offsets, if any
       //
@@ -867,6 +855,7 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(DELTA)
+        EEPROM_READ(delta_height);              // 1 float
         EEPROM_READ(delta_endstop_adj);         // 3 floats
         EEPROM_READ(delta_radius);              // 1 float
         EEPROM_READ(delta_diagonal_rod);        // 1 float
@@ -1333,13 +1322,13 @@ void MarlinSettings::reset() {
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ,
                 dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
+    delta_height = DELTA_HEIGHT;
     COPY(delta_endstop_adj, adj);
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
     COPY(delta_tower_angle_trim, dta);
-    home_offset[Z_AXIS] = 0;
 
   #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 
@@ -1763,7 +1752,7 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START;
       SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
       SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
-      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(DELTA_HEIGHT + home_offset[Z_AXIS]));
+      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(delta_height));
       SERIAL_ECHOPAIR(" S", delta_segments_per_second);
       SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
       SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));

commit 73ca5345e1aacd3726ff492057940f513b2be396
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Tue Nov 7 16:48:21 2017 +0000

    Fix Delta EEPROM

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 0462f16fee..c7b99a91c5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -873,8 +873,6 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(delta_segments_per_second); // 1 float
         EEPROM_READ(delta_calibration_radius);  // 1 float
         EEPROM_READ(delta_tower_angle_trim);    // 3 floats
-        dummy = 0.0f;
-        for (uint8_t q=2; q--;) EEPROM_READ(dummy);
 
       #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 

commit 85a62bbf46c13b4e01ecafc9f3ce50ed92f67f3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 6 22:57:05 2017 -0600

    Misc. fixes to compiler warnings, etc.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 04f4003287..0462f16fee 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -64,7 +64,7 @@
  *  195  M206 XYZ  home_offset                      (float x3)
  *  207  M218 XYZ  hotend_offset                    (float x3 per additional hotend)
  *
- * Global Leveling:
+ * Global Leveling:                                 4 bytes
  *  219            z_fade_height                    (float)
  *
  * MESH_BED_LEVELING:                               43 bytes
@@ -80,7 +80,7 @@
  * ABL_PLANAR:                                      36 bytes
  *  270            planner.bed_level_matrix         (matrix_3x3 = float x9)
  *
- * AUTO_BED_LEVELING_BILINEAR:                      47 bytes
+ * AUTO_BED_LEVELING_BILINEAR:                      46 bytes
  *  306            GRID_MAX_POINTS_X                (uint8_t)
  *  307            GRID_MAX_POINTS_Y                (uint8_t)
  *  308            bilinear_grid_spacing            (int x2)

commit 6324b099340c414fa02ed6a11a1a89eed5d07f0f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Nov 6 19:52:05 2017 -0600

    Revert "Fix EEPROM crc (#8284)" (#8292)
    
    This reverts commit 172c36f5176e9405d80e93350cccb03e6960a470.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 54cd7f25a9..04f4003287 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1059,7 +1059,7 @@ void MarlinSettings::postprocess() {
           stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
       #else
-        for (uint8_t q = 0; q < 11; q++) EEPROM_READ(val);
+        for (uint8_t q = 11; q--;) EEPROM_READ(val);
       #endif
 
       //

commit 172c36f5176e9405d80e93350cccb03e6960a470
Author: Rowan Meara <rowanmeara@gmail.com>
Date:   Mon Nov 6 17:19:30 2017 -0800

    Fix EEPROM crc (#8284)

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 04f4003287..54cd7f25a9 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1059,7 +1059,7 @@ void MarlinSettings::postprocess() {
           stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
       #else
-        for (uint8_t q = 11; q--;) EEPROM_READ(val);
+        for (uint8_t q = 0; q < 11; q++) EEPROM_READ(val);
       #endif
 
       //

commit 1b40e9c46475a9f9c712eba5588c72256f7dd584
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 16:36:41 2017 -0500

    Implement CNC_COORDINATE_SYSTEMS

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2a7ea53975..04f4003287 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V43"
+#define EEPROM_VERSION "V44"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V43 EEPROM Layout:
+ * V44 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -162,8 +162,11 @@
  *  588  M907 Z    Stepper Z current                (uint32_t)
  *  592  M907 E    Stepper E current                (uint32_t)
  *
- *  596                                Minimum end-point
- * 1917 (596 + 36 + 9 + 288 + 988)     Maximum end-point
+ * CNC_COORDINATE_SYSTEMS                           108 bytes
+ *  596  G54-G59.3 coordinate_system                (float x 27)
+ *
+ *  704                                Minimum end-point
+ * 2025 (704 + 36 + 9 + 288 + 988)     Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -207,6 +210,10 @@ MarlinSettings settings;
   float new_z_fade_height;
 #endif
 
+#if ENABLED(CNC_COORDINATE_SYSTEMS)
+  bool position_changed;
+#endif
+
 /**
  * Post-process after Retrieve or Reset
  */
@@ -255,6 +262,13 @@ void MarlinSettings::postprocess() {
   #if ENABLED(FWRETRACT)
     fwretract.refresh_autoretract();
   #endif
+
+  #if ENABLED(CNC_COORDINATE_SYSTEMS)
+    if (position_changed) {
+      report_current_position();
+      position_changed = false;
+    }
+  #endif
 }
 
 #if ENABLED(EEPROM_SETTINGS)
@@ -630,6 +644,13 @@ void MarlinSettings::postprocess() {
       for (uint8_t q = 3; q--;) EEPROM_WRITE(dummyui32);
     #endif
 
+    #if ENABLED(CNC_COORDINATE_SYSTEMS)
+      EEPROM_WRITE(coordinate_system); // 27 floats
+    #else
+      dummy = 0.0f;
+      for (uint8_t q = 27; q--;) EEPROM_WRITE(dummy);
+    #endif
+
     if (!eeprom_error) {
       #if ENABLED(EEPROM_CHITCHAT)
         const int eeprom_size = eeprom_index;
@@ -1064,6 +1085,17 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 3; q--;) EEPROM_READ(dummyui32);
       #endif
 
+      //
+      // CNC Coordinate System
+      //
+
+      #if ENABLED(CNC_COORDINATE_SYSTEMS)
+        position_changed = gcode.select_coordinate_system(-1); // Go back to machine space
+        EEPROM_READ(gcode.coordinate_system);                  // 27 floats
+      #else
+        for (uint8_t q = 27; q--;) EEPROM_READ(dummy);
+      #endif
+
       if (working_crc == stored_crc) {
         postprocess();
         #if ENABLED(EEPROM_CHITCHAT)

commit c07bbd4154e31736d28dce1d09ba43c1cd17ce54
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 15:34:24 2017 -0500

    Prettify some EEPROM code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 2c2079224b..2a7ea53975 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -292,7 +292,7 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(ver);     // invalidate data first
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
-    working_crc = 0; // clear before first "real data"
+    working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
     const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
@@ -699,6 +699,10 @@ void MarlinSettings::postprocess() {
       uint8_t esteppers;
       EEPROM_READ(esteppers);
 
+      //
+      // Planner Motion
+      //
+
       // Get only the number of E stepper parameters previously stored
       // Any steppers added later are set to their defaults
       const float def1[] = DEFAULT_AXIS_STEPS_PER_UNIT, def2[] = DEFAULT_MAX_FEEDRATE;
@@ -722,6 +726,10 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(planner.min_segment_time_us);
       EEPROM_READ(planner.max_jerk);
 
+      //
+      // Home Offset (M206)
+      //
+
       #if !HAS_HOME_OFFSET
         float home_offset[XYZ];
       #endif
@@ -733,6 +741,10 @@ void MarlinSettings::postprocess() {
         home_offset[Z_AXIS] -= DELTA_HEIGHT;
       #endif
 
+      //
+      // Hotend Offsets, if any
+      //
+
       #if HOTENDS > 1
         // Skip hotend 0 which must be 0
         for (uint8_t e = 1; e < HOTENDS; e++)
@@ -816,6 +828,10 @@ void MarlinSettings::postprocess() {
           for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
         }
 
+      //
+      // Unified Bed Leveling active state
+      //
+
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EEPROM_READ(planner.leveling_active);
         EEPROM_READ(ubl.storage_slot);
@@ -825,6 +841,10 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(dummyui8);
       #endif // AUTO_BED_LEVELING_UBL
 
+      //
+      // DELTA Geometry or Dual Endstops offsets
+      //
+
       #if ENABLED(DELTA)
         EEPROM_READ(delta_endstop_adj);         // 3 floats
         EEPROM_READ(delta_radius);              // 1 float
@@ -861,19 +881,27 @@ void MarlinSettings::postprocess() {
 
       #endif
 
+      //
+      // LCD Preheat settings
+      //
+
       #if DISABLED(ULTIPANEL)
         int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
       #endif
 
-      EEPROM_READ(lcd_preheat_hotend_temp);
-      EEPROM_READ(lcd_preheat_bed_temp);
-      EEPROM_READ(lcd_preheat_fan_speed);
+      EEPROM_READ(lcd_preheat_hotend_temp); // 2 floats
+      EEPROM_READ(lcd_preheat_bed_temp);    // 2 floats
+      EEPROM_READ(lcd_preheat_fan_speed);   // 2 floats
 
       //EEPROM_ASSERT(
       //  WITHIN(lcd_preheat_fan_speed, 0, 255),
       //  "lcd_preheat_fan_speed out of range"
       //);
 
+      //
+      // Hotend PID
+      //
+
       #if ENABLED(PIDTEMP)
         for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
           EEPROM_READ(dummy); // Kp
@@ -897,11 +925,19 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
       #endif // !PIDTEMP
 
+      //
+      // PID Extrusion Scaling
+      //
+
       #if DISABLED(PID_EXTRUSION_SCALING)
         int lpq_len;
       #endif
       EEPROM_READ(lpq_len);
 
+      //
+      // Heated Bed PID
+      //
+
       #if ENABLED(PIDTEMPBED)
         EEPROM_READ(dummy); // bedKp
         if (dummy != DUMMY_PID_VALUE) {
@@ -913,11 +949,19 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
       #endif
 
+      //
+      // LCD Contrast
+      //
+
       #if !HAS_LCD_CONTRAST
         uint16_t lcd_contrast;
       #endif
       EEPROM_READ(lcd_contrast);
 
+      //
+      // Firmware Retraction
+      //
+
       #if ENABLED(FWRETRACT)
         EEPROM_READ(fwretract.autoretract_enabled);
         EEPROM_READ(fwretract.retract_length);
@@ -933,13 +977,20 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=8; q--;) EEPROM_READ(dummy);
       #endif
 
-      EEPROM_READ(parser.volumetric_enabled);
+      //
+      // Volumetric & Filament Size
+      //
 
+      EEPROM_READ(parser.volumetric_enabled);
       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
         EEPROM_READ(dummy);
         if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
       }
 
+      //
+      // TMC2130 Stepper Current
+      //
+
       uint16_t val;
       #if ENABLED(HAVE_TMC2130)
         EEPROM_READ(val);
@@ -987,7 +1038,7 @@ void MarlinSettings::postprocess() {
           stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
         #endif
       #else
-        for (uint8_t q = 0; q < 11; q++) EEPROM_READ(val);
+        for (uint8_t q = 11; q--;) EEPROM_READ(val);
       #endif
 
       //
@@ -1002,6 +1053,10 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(dummy);
       #endif
 
+      //
+      // Motor Current PWM
+      //
+
       #if HAS_MOTOR_CURRENT_PWM
         for (uint8_t q = 3; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
       #else

commit 817175613aaa84644de31e8b4f20386e0f0337be
Merge: 233ddf80da 3e8754a38a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 29 19:55:00 2017 -0500

    Merge pull request #8157 from thinkyhead/bf2_anet_10_servo
    
    [2.0.x] Define a default SERVO0_PIN for Anet 1.0

diff --combined Marlin/src/module/configuration_store.cpp
index 2b67ad5024,5d6caf98e8..2c2079224b
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@@ -36,13 -36,13 +36,13 @@@
   *
   */
  
 -#define EEPROM_VERSION "V42"
 +#define EEPROM_VERSION "V43"
  
  // Change EEPROM version if these are changed:
  #define EEPROM_OFFSET 100
  
  /**
 - * V42 EEPROM Layout:
 + * V43 EEPROM Layout:
   *
   *  100  Version                                    (char x4)
   *  104  EEPROM CRC16                               (uint16_t)
@@@ -56,7 -56,7 +56,7 @@@
   *  163  M204 T    planner.travel_acceleration      (float)
   *  167  M205 S    planner.min_feedrate_mm_s        (float)
   *  171  M205 T    planner.min_travel_feedrate_mm_s (float)
-  *  175  M205 B    planner.min_segment_time         (ulong)
+  *  175  M205 B    planner.min_segment_time_us      (ulong)
   *  179  M205 X    planner.max_jerk[X_AXIS]         (float)
   *  183  M205 Y    planner.max_jerk[Y_AXIS]         (float)
   *  187  M205 Z    planner.max_jerk[Z_AXIS]         (float)
@@@ -91,79 -91,78 +91,79 @@@
   *  324  G29 A     planner.leveling_active          (bool)
   *  325  G29 S     ubl.storage_slot                 (int8_t)
   *
 - * DELTA:                                           48 bytes
 - *  344  M666 XYZ  delta_endstop_adj                (float x3)
 - *  360  M665 R    delta_radius                     (float)
 - *  364  M665 L    delta_diagonal_rod               (float)
 - *  368  M665 S    delta_segments_per_second        (float)
 - *  372  M665 B    delta_calibration_radius         (float)
 - *  376  M665 X    delta_tower_angle_trim[A]        (float)
 - *  380  M665 Y    delta_tower_angle_trim[B]        (float)
 - *  384  M665 Z    delta_tower_angle_trim[C]        (float)
 + * DELTA:                                           40 bytes
 + *  352  M666 XYZ  delta_endstop_adj                (float x3)
 + *  364  M665 R    delta_radius                     (float)
 + *  368  M665 L    delta_diagonal_rod               (float)
 + *  372  M665 S    delta_segments_per_second        (float)
 + *  376  M665 B    delta_calibration_radius         (float)
 + *  380  M665 X    delta_tower_angle_trim[A]        (float)
 + *  384  M665 Y    delta_tower_angle_trim[B]        (float)
 + *  388  M665 Z    delta_tower_angle_trim[C]        (float)
   *
 - * Z_DUAL_ENDSTOPS:                                 48 bytes
 - *  348  M666 Z    endstops.z_endstop_adj           (float)
 - *  ---            dummy data                       (float x11)
 + * [XYZ]_DUAL_ENDSTOPS:                             12 bytes
 + *  352  M666 X    endstops.x_endstop_adj           (float)
 + *  356  M666 Y    endstops.y_endstop_adj           (float)
 + *  360  M666 Z    endstops.z_endstop_adj           (float)
   *
   * ULTIPANEL:                                       6 bytes
 - *  396  M145 S0 H lcd_preheat_hotend_temp          (int x2)
 - *  400  M145 S0 B lcd_preheat_bed_temp             (int x2)
 - *  404  M145 S0 F lcd_preheat_fan_speed            (int x2)
 + *  392  M145 S0 H lcd_preheat_hotend_temp          (int x2)
 + *  396  M145 S0 B lcd_preheat_bed_temp             (int x2)
 + *  400  M145 S0 F lcd_preheat_fan_speed            (int x2)
   *
 - * PIDTEMP:                                         66 bytes
 - *  408  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
 - *  424  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
 - *  440  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
 - *  456  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
 - *  472  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
 - *  488  M301 L        lpq_len                      (int)
 + * PIDTEMP:                                         82 bytes
 + *  404  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
 + *  420  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
 + *  436  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
 + *  452  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
 + *  468  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
 + *  484  M301 L        lpq_len                      (int)
   *
   * PIDTEMPBED:                                      12 bytes
 - *  490  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
 + *  486  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
   *
   * DOGLCD:                                          2 bytes
 - *  502  M250 C    lcd_contrast                     (uint16_t)
 + *  498  M250 C    lcd_contrast                     (uint16_t)
   *
   * FWRETRACT:                                       33 bytes
 - *  504  M209 S    autoretract_enabled              (bool)
 - *  505  M207 S    retract_length                   (float)
 - *  509  M207 F    retract_feedrate_mm_s            (float)
 - *  513  M207 Z    retract_zlift                    (float)
 - *  517  M208 S    retract_recover_length           (float)
 - *  521  M208 F    retract_recover_feedrate_mm_s    (float)
 - *  525  M207 W    swap_retract_length              (float)
 - *  529  M208 W    swap_retract_recover_length      (float)
 - *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
 + *  500  M209 S    autoretract_enabled              (bool)
 + *  501  M207 S    retract_length                   (float)
 + *  505  M207 F    retract_feedrate_mm_s            (float)
 + *  509  M207 Z    retract_zlift                    (float)
 + *  513  M208 S    retract_recover_length           (float)
 + *  517  M208 F    retract_recover_feedrate_mm_s    (float)
 + *  521  M207 W    swap_retract_length              (float)
 + *  525  M208 W    swap_retract_recover_length      (float)
 + *  529  M208 R    swap_retract_recover_feedrate_mm_s (float)
   *
   * Volumetric Extrusion:                            21 bytes
 - *  537  M200 D    parser.volumetric_enabled        (bool)
 - *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
 + *  533  M200 D    volumetric_enabled               (bool)
 + *  534  M200 T D  filament_size                    (float x5) (T0..3)
   *
 - * HAVE_TMC2130:                                    20 bytes
 - *  558  M906 X    Stepper X current                (uint16_t)
 - *  560  M906 Y    Stepper Y current                (uint16_t)
 - *  562  M906 Z    Stepper Z current                (uint16_t)
 - *  564  M906 X2   Stepper X2 current               (uint16_t)
 - *  566  M906 Y2   Stepper Y2 current               (uint16_t)
 - *  568  M906 Z2   Stepper Z2 current               (uint16_t)
 - *  570  M906 E0   Stepper E0 current               (uint16_t)
 - *  572  M906 E1   Stepper E1 current               (uint16_t)
 - *  574  M906 E2   Stepper E2 current               (uint16_t)
 - *  576  M906 E3   Stepper E3 current               (uint16_t)
 - *  580  M906 E4   Stepper E4 current               (uint16_t)
 + * HAVE_TMC2130:                                    22 bytes
 + *  554  M906 X    Stepper X current                (uint16_t)
 + *  556  M906 Y    Stepper Y current                (uint16_t)
 + *  558  M906 Z    Stepper Z current                (uint16_t)
 + *  560  M906 X2   Stepper X2 current               (uint16_t)
 + *  562  M906 Y2   Stepper Y2 current               (uint16_t)
 + *  564  M906 Z2   Stepper Z2 current               (uint16_t)
 + *  566  M906 E0   Stepper E0 current               (uint16_t)
 + *  568  M906 E1   Stepper E1 current               (uint16_t)
 + *  570  M906 E2   Stepper E2 current               (uint16_t)
 + *  572  M906 E3   Stepper E3 current               (uint16_t)
 + *  574  M906 E4   Stepper E4 current               (uint16_t)
   *
   * LIN_ADVANCE:                                     8 bytes
 - *  584  M900 K    extruder_advance_k               (float)
 - *  588  M900 WHD  advance_ed_ratio                 (float)
 + *  576  M900 K    extruder_advance_k               (float)
 + *  580  M900 WHD  advance_ed_ratio                 (float)
   *
   * HAS_MOTOR_CURRENT_PWM:
 - *  592  M907 X    Stepper XY current               (uint32_t)
 - *  596  M907 Z    Stepper Z current                (uint32_t)
 - *  600  M907 E    Stepper E current                (uint32_t)
 + *  584  M907 X    Stepper XY current               (uint32_t)
 + *  588  M907 Z    Stepper Z current                (uint32_t)
 + *  592  M907 E    Stepper E current                (uint32_t)
   *
 - *  604                                Minimum end-point
 - * 1925 (604 + 36 + 9 + 288 + 988)     Maximum end-point
 + *  596                                Minimum end-point
 + * 1917 (596 + 36 + 9 + 288 + 988)     Maximum end-point
   *
   * ========================================================================
   * meshes_begin (between max and min end-point, directly above)
@@@ -306,7 -305,7 +306,7 @@@ void MarlinSettings::postprocess() 
      EEPROM_WRITE(planner.travel_acceleration);
      EEPROM_WRITE(planner.min_feedrate_mm_s);
      EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
-     EEPROM_WRITE(planner.min_segment_time);
+     EEPROM_WRITE(planner.min_segment_time_us);
      EEPROM_WRITE(planner.max_jerk);
      #if !HAS_HOME_OFFSET
        const float home_offset[XYZ] = { 0 };
@@@ -420,7 -419,7 +420,7 @@@
        EEPROM_WRITE(storage_slot);
      #endif // AUTO_BED_LEVELING_UBL
  
 -    // 10 floats for DELTA / Z_DUAL_ENDSTOPS
 +    // 10 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
      #if ENABLED(DELTA)
        EEPROM_WRITE(delta_endstop_adj);         // 3 floats
        EEPROM_WRITE(delta_radius);              // 1 float
@@@ -428,33 -427,15 +428,33 @@@
        EEPROM_WRITE(delta_segments_per_second); // 1 float
        EEPROM_WRITE(delta_calibration_radius);  // 1 float
        EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
 +
 +    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 +      // Write dual endstops in X, Y, Z order. Unused = 0.0
        dummy = 0.0f;
 -      for (uint8_t q = 2; q--;) EEPROM_WRITE(dummy);
 -    #elif ENABLED(Z_DUAL_ENDSTOPS)
 -      EEPROM_WRITE(endstops.z_endstop_adj);    // 1 float
 -      dummy = 0.0f;
 -      for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
 +      #if ENABLED(X_DUAL_ENDSTOPS)
 +        EEPROM_WRITE(endstops.x_endstop_adj);   // 1 float
 +      #else
 +        EEPROM_WRITE(dummy);
 +      #endif
 +
 +      #if ENABLED(Y_DUAL_ENDSTOPS)
 +        EEPROM_WRITE(endstops.y_endstop_adj);   // 1 float
 +      #else
 +        EEPROM_WRITE(dummy);
 +      #endif
 +
 +      #if ENABLED(Z_DUAL_ENDSTOPS)
 +        EEPROM_WRITE(endstops.z_endstop_adj);   // 1 float
 +      #else
 +        EEPROM_WRITE(dummy);
 +      #endif
 +
 +      for (uint8_t q = 7; q--;) EEPROM_WRITE(dummy);
 +
      #else
        dummy = 0.0f;
 -      for (uint8_t q = 12; q--;) EEPROM_WRITE(dummy);
 +      for (uint8_t q = 10; q--;) EEPROM_WRITE(dummy);
      #endif
  
      #if DISABLED(ULTIPANEL)
@@@ -657,7 -638,6 +657,7 @@@
        if (ubl.storage_slot >= 0)
          store_mesh(ubl.storage_slot);
      #endif
 +
      return !eeprom_error;
    }
  
@@@ -719,7 -699,7 +719,7 @@@
        EEPROM_READ(planner.travel_acceleration);
        EEPROM_READ(planner.min_feedrate_mm_s);
        EEPROM_READ(planner.min_travel_feedrate_mm_s);
-       EEPROM_READ(planner.min_segment_time);
+       EEPROM_READ(planner.min_segment_time_us);
        EEPROM_READ(planner.max_jerk);
  
        #if !HAS_HOME_OFFSET
@@@ -834,31 -814,13 +834,31 @@@
          EEPROM_READ(delta_tower_angle_trim);    // 3 floats
          dummy = 0.0f;
          for (uint8_t q=2; q--;) EEPROM_READ(dummy);
 -      #elif ENABLED(Z_DUAL_ENDSTOPS)
 -        EEPROM_READ(endstops.z_endstop_adj);    // 1 float
 -        dummy = 0.0f;
 -        for (uint8_t q=11; q--;) EEPROM_READ(dummy);
 +
 +      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 +
 +        #if ENABLED(X_DUAL_ENDSTOPS)
 +          EEPROM_READ(endstops.x_endstop_adj);  // 1 float
 +        #else
 +          EEPROM_READ(dummy);
 +        #endif
 +        #if ENABLED(Y_DUAL_ENDSTOPS)
 +          EEPROM_READ(endstops.y_endstop_adj);  // 1 float
 +        #else
 +          EEPROM_READ(dummy);
 +        #endif
 +        #if ENABLED(Z_DUAL_ENDSTOPS)
 +          EEPROM_READ(endstops.z_endstop_adj); // 1 float
 +        #else
 +          EEPROM_READ(dummy);
 +        #endif
 +
 +        for (uint8_t q=7; q--;) EEPROM_READ(dummy);
 +
        #else
 -        dummy = 0.0f;
 -        for (uint8_t q=12; q--;) EEPROM_READ(dummy);
 +
 +        for (uint8_t q=10; q--;) EEPROM_READ(dummy);
 +
        #endif
  
        #if DISABLED(ULTIPANEL)
@@@ -1204,7 -1166,7 +1204,7 @@@ void MarlinSettings::reset() 
    planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
    planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
    planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
-   planner.min_segment_time = DEFAULT_MINSEGMENTTIME;
+   planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
    planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
    planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
    planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
@@@ -1256,35 -1218,15 +1256,35 @@@
      COPY(delta_tower_angle_trim, dta);
      home_offset[Z_AXIS] = 0;
  
 -  #elif ENABLED(Z_DUAL_ENDSTOPS)
 +  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  
 -    endstops.z_endstop_adj =
 -      #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
 -        Z_DUAL_ENDSTOPS_ADJUSTMENT
 -      #else
 -        0
 -      #endif
 -    ;
 +    #if ENABLED(X_DUAL_ENDSTOPS)
 +      endstops.x_endstop_adj = (
 +        #ifdef X_DUAL_ENDSTOPS_ADJUSTMENT
 +          X_DUAL_ENDSTOPS_ADJUSTMENT
 +        #else
 +          0
 +        #endif
 +      );
 +    #endif
 +    #if ENABLED(Y_DUAL_ENDSTOPS)
 +      endstops.y_endstop_adj = (
 +        #ifdef Y_DUAL_ENDSTOPS_ADJUSTMENT
 +          Y_DUAL_ENDSTOPS_ADJUSTMENT
 +        #else
 +          0
 +        #endif
 +      );
 +    #endif
 +    #if ENABLED(Z_DUAL_ENDSTOPS)
 +      endstops.z_endstop_adj = (
 +        #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
 +          Z_DUAL_ENDSTOPS_ADJUSTMENT
 +        #else
 +          0
 +        #endif
 +      );
 +    #endif
  
    #endif
  
@@@ -1562,12 -1504,12 +1562,12 @@@
  
      if (!forReplay) {
        CONFIG_ECHO_START;
-       SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_ms> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
+       SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_us> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
      }
      CONFIG_ECHO_START;
      SERIAL_ECHOPAIR("  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
      SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
-     SERIAL_ECHOPAIR(" B", planner.min_segment_time);
+     SERIAL_ECHOPAIR(" B", planner.min_segment_time_us);
      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
@@@ -1685,24 -1627,13 +1685,24 @@@
        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
        SERIAL_EOL();
 -    #elif ENABLED(Z_DUAL_ENDSTOPS)
 +
 +    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
        if (!forReplay) {
          CONFIG_ECHO_START;
 -        SERIAL_ECHOLNPGM("Z2 Endstop adjustment:");
 +        SERIAL_ECHOLNPGM("Endstop adjustment:");
        }
        CONFIG_ECHO_START;
 -      SERIAL_ECHOLNPAIR("  M666 Z", LINEAR_UNIT(endstops.z_endstop_adj));
 +      SERIAL_ECHOPGM("  M666");
 +      #if ENABLED(X_DUAL_ENDSTOPS)
 +        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(endstops.x_endstop_adj));
 +      #endif
 +      #if ENABLED(Y_DUAL_ENDSTOPS)
 +        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstops.y_endstop_adj));
 +      #endif
 +      #if ENABLED(Z_DUAL_ENDSTOPS)
 +        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(endstops.z_endstop_adj));
 +      #endif
 +      SERIAL_EOL();
      #endif // DELTA
  
      #if ENABLED(ULTIPANEL)
@@@ -1807,7 -1738,7 +1807,7 @@@
      #endif // FWRETRACT
  
      /**
 -     * Auto Bed Leveling
 +     * Probe Offset
       */
      #if HAS_BED_PROBE
        if (!forReplay) {

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 99d9eb9f4d..2b67ad5024 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V42"
+#define EEPROM_VERSION "V43"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V42 EEPROM Layout:
+ * V43 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -68,7 +68,7 @@
  *  219            z_fade_height                    (float)
  *
  * MESH_BED_LEVELING:                               43 bytes
- *  223  M420 S    planner.leveling_active         (bool)
+ *  223  M420 S    planner.leveling_active          (bool)
  *  224            mbl.z_offset                     (float)
  *  228            GRID_MAX_POINTS_X                (uint8_t)
  *  229            GRID_MAX_POINTS_Y                (uint8_t)
@@ -91,78 +91,79 @@
  *  324  G29 A     planner.leveling_active          (bool)
  *  325  G29 S     ubl.storage_slot                 (int8_t)
  *
- * DELTA:                                           48 bytes
- *  344  M666 XYZ  delta_endstop_adj                (float x3)
- *  360  M665 R    delta_radius                     (float)
- *  364  M665 L    delta_diagonal_rod               (float)
- *  368  M665 S    delta_segments_per_second        (float)
- *  372  M665 B    delta_calibration_radius         (float)
- *  376  M665 X    delta_tower_angle_trim[A]        (float)
- *  380  M665 Y    delta_tower_angle_trim[B]        (float)
- *  384  M665 Z    delta_tower_angle_trim[C]        (float)
+ * DELTA:                                           40 bytes
+ *  352  M666 XYZ  delta_endstop_adj                (float x3)
+ *  364  M665 R    delta_radius                     (float)
+ *  368  M665 L    delta_diagonal_rod               (float)
+ *  372  M665 S    delta_segments_per_second        (float)
+ *  376  M665 B    delta_calibration_radius         (float)
+ *  380  M665 X    delta_tower_angle_trim[A]        (float)
+ *  384  M665 Y    delta_tower_angle_trim[B]        (float)
+ *  388  M665 Z    delta_tower_angle_trim[C]        (float)
  *
- * Z_DUAL_ENDSTOPS:                                 48 bytes
- *  348  M666 Z    endstops.z_endstop_adj           (float)
- *  ---            dummy data                       (float x11)
+ * [XYZ]_DUAL_ENDSTOPS:                             12 bytes
+ *  352  M666 X    endstops.x_endstop_adj           (float)
+ *  356  M666 Y    endstops.y_endstop_adj           (float)
+ *  360  M666 Z    endstops.z_endstop_adj           (float)
  *
  * ULTIPANEL:                                       6 bytes
- *  396  M145 S0 H lcd_preheat_hotend_temp          (int x2)
- *  400  M145 S0 B lcd_preheat_bed_temp             (int x2)
- *  404  M145 S0 F lcd_preheat_fan_speed            (int x2)
+ *  392  M145 S0 H lcd_preheat_hotend_temp          (int x2)
+ *  396  M145 S0 B lcd_preheat_bed_temp             (int x2)
+ *  400  M145 S0 F lcd_preheat_fan_speed            (int x2)
  *
- * PIDTEMP:                                         66 bytes
- *  408  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
- *  424  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
- *  440  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
- *  456  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  472  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
- *  488  M301 L        lpq_len                      (int)
+ * PIDTEMP:                                         82 bytes
+ *  404  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
+ *  420  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
+ *  436  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
+ *  452  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  468  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  484  M301 L        lpq_len                      (int)
  *
  * PIDTEMPBED:                                      12 bytes
- *  490  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
+ *  486  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
  *
  * DOGLCD:                                          2 bytes
- *  502  M250 C    lcd_contrast                     (uint16_t)
+ *  498  M250 C    lcd_contrast                     (uint16_t)
  *
  * FWRETRACT:                                       33 bytes
- *  504  M209 S    autoretract_enabled              (bool)
- *  505  M207 S    retract_length                   (float)
- *  509  M207 F    retract_feedrate_mm_s            (float)
- *  513  M207 Z    retract_zlift                    (float)
- *  517  M208 S    retract_recover_length           (float)
- *  521  M208 F    retract_recover_feedrate_mm_s    (float)
- *  525  M207 W    swap_retract_length              (float)
- *  529  M208 W    swap_retract_recover_length      (float)
- *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
+ *  500  M209 S    autoretract_enabled              (bool)
+ *  501  M207 S    retract_length                   (float)
+ *  505  M207 F    retract_feedrate_mm_s            (float)
+ *  509  M207 Z    retract_zlift                    (float)
+ *  513  M208 S    retract_recover_length           (float)
+ *  517  M208 F    retract_recover_feedrate_mm_s    (float)
+ *  521  M207 W    swap_retract_length              (float)
+ *  525  M208 W    swap_retract_recover_length      (float)
+ *  529  M208 R    swap_retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:                            21 bytes
- *  537  M200 D    parser.volumetric_enabled        (bool)
- *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
+ *  533  M200 D    volumetric_enabled               (bool)
+ *  534  M200 T D  filament_size                    (float x5) (T0..3)
  *
- * HAVE_TMC2130:                                    20 bytes
- *  558  M906 X    Stepper X current                (uint16_t)
- *  560  M906 Y    Stepper Y current                (uint16_t)
- *  562  M906 Z    Stepper Z current                (uint16_t)
- *  564  M906 X2   Stepper X2 current               (uint16_t)
- *  566  M906 Y2   Stepper Y2 current               (uint16_t)
- *  568  M906 Z2   Stepper Z2 current               (uint16_t)
- *  570  M906 E0   Stepper E0 current               (uint16_t)
- *  572  M906 E1   Stepper E1 current               (uint16_t)
- *  574  M906 E2   Stepper E2 current               (uint16_t)
- *  576  M906 E3   Stepper E3 current               (uint16_t)
- *  580  M906 E4   Stepper E4 current               (uint16_t)
+ * HAVE_TMC2130:                                    22 bytes
+ *  554  M906 X    Stepper X current                (uint16_t)
+ *  556  M906 Y    Stepper Y current                (uint16_t)
+ *  558  M906 Z    Stepper Z current                (uint16_t)
+ *  560  M906 X2   Stepper X2 current               (uint16_t)
+ *  562  M906 Y2   Stepper Y2 current               (uint16_t)
+ *  564  M906 Z2   Stepper Z2 current               (uint16_t)
+ *  566  M906 E0   Stepper E0 current               (uint16_t)
+ *  568  M906 E1   Stepper E1 current               (uint16_t)
+ *  570  M906 E2   Stepper E2 current               (uint16_t)
+ *  572  M906 E3   Stepper E3 current               (uint16_t)
+ *  574  M906 E4   Stepper E4 current               (uint16_t)
  *
  * LIN_ADVANCE:                                     8 bytes
- *  584  M900 K    extruder_advance_k               (float)
- *  588  M900 WHD  advance_ed_ratio                 (float)
+ *  576  M900 K    extruder_advance_k               (float)
+ *  580  M900 WHD  advance_ed_ratio                 (float)
  *
  * HAS_MOTOR_CURRENT_PWM:
- *  592  M907 X    Stepper XY current               (uint32_t)
- *  596  M907 Z    Stepper Z current                (uint32_t)
- *  600  M907 E    Stepper E current                (uint32_t)
+ *  584  M907 X    Stepper XY current               (uint32_t)
+ *  588  M907 Z    Stepper Z current                (uint32_t)
+ *  592  M907 E    Stepper E current                (uint32_t)
  *
- *  604                                Minimum end-point
- * 1925 (604 + 36 + 9 + 288 + 988)     Maximum end-point
+ *  596                                Minimum end-point
+ * 1917 (596 + 36 + 9 + 288 + 988)     Maximum end-point
  *
  * ========================================================================
  * meshes_begin (between max and min end-point, directly above)
@@ -419,7 +420,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
-    // 10 floats for DELTA / Z_DUAL_ENDSTOPS
+    // 10 floats for DELTA / [XYZ]_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
       EEPROM_WRITE(delta_endstop_adj);         // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
@@ -427,15 +428,33 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(delta_segments_per_second); // 1 float
       EEPROM_WRITE(delta_calibration_radius);  // 1 float
       EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
+
+    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+      // Write dual endstops in X, Y, Z order. Unused = 0.0
       dummy = 0.0f;
-      for (uint8_t q = 2; q--;) EEPROM_WRITE(dummy);
-    #elif ENABLED(Z_DUAL_ENDSTOPS)
-      EEPROM_WRITE(endstops.z_endstop_adj);    // 1 float
-      dummy = 0.0f;
-      for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        EEPROM_WRITE(endstops.x_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummy);
+      #endif
+
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        EEPROM_WRITE(endstops.y_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummy);
+      #endif
+
+      #if ENABLED(Z_DUAL_ENDSTOPS)
+        EEPROM_WRITE(endstops.z_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummy);
+      #endif
+
+      for (uint8_t q = 7; q--;) EEPROM_WRITE(dummy);
+
     #else
       dummy = 0.0f;
-      for (uint8_t q = 12; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = 10; q--;) EEPROM_WRITE(dummy);
     #endif
 
     #if DISABLED(ULTIPANEL)
@@ -638,6 +657,7 @@ void MarlinSettings::postprocess() {
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
     #endif
+
     return !eeprom_error;
   }
 
@@ -814,13 +834,31 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(delta_tower_angle_trim);    // 3 floats
         dummy = 0.0f;
         for (uint8_t q=2; q--;) EEPROM_READ(dummy);
-      #elif ENABLED(Z_DUAL_ENDSTOPS)
-        EEPROM_READ(endstops.z_endstop_adj);    // 1 float
-        dummy = 0.0f;
-        for (uint8_t q=11; q--;) EEPROM_READ(dummy);
+
+      #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          EEPROM_READ(endstops.x_endstop_adj);  // 1 float
+        #else
+          EEPROM_READ(dummy);
+        #endif
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          EEPROM_READ(endstops.y_endstop_adj);  // 1 float
+        #else
+          EEPROM_READ(dummy);
+        #endif
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          EEPROM_READ(endstops.z_endstop_adj); // 1 float
+        #else
+          EEPROM_READ(dummy);
+        #endif
+
+        for (uint8_t q=7; q--;) EEPROM_READ(dummy);
+
       #else
-        dummy = 0.0f;
-        for (uint8_t q=12; q--;) EEPROM_READ(dummy);
+
+        for (uint8_t q=10; q--;) EEPROM_READ(dummy);
+
       #endif
 
       #if DISABLED(ULTIPANEL)
@@ -1218,15 +1256,35 @@ void MarlinSettings::reset() {
     COPY(delta_tower_angle_trim, dta);
     home_offset[Z_AXIS] = 0;
 
-  #elif ENABLED(Z_DUAL_ENDSTOPS)
+  #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
 
-    endstops.z_endstop_adj =
-      #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
-        Z_DUAL_ENDSTOPS_ADJUSTMENT
-      #else
-        0
-      #endif
-    ;
+    #if ENABLED(X_DUAL_ENDSTOPS)
+      endstops.x_endstop_adj = (
+        #ifdef X_DUAL_ENDSTOPS_ADJUSTMENT
+          X_DUAL_ENDSTOPS_ADJUSTMENT
+        #else
+          0
+        #endif
+      );
+    #endif
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      endstops.y_endstop_adj = (
+        #ifdef Y_DUAL_ENDSTOPS_ADJUSTMENT
+          Y_DUAL_ENDSTOPS_ADJUSTMENT
+        #else
+          0
+        #endif
+      );
+    #endif
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      endstops.z_endstop_adj = (
+        #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
+          Z_DUAL_ENDSTOPS_ADJUSTMENT
+        #else
+          0
+        #endif
+      );
+    #endif
 
   #endif
 
@@ -1627,13 +1685,24 @@ void MarlinSettings::reset() {
       SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
       SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
       SERIAL_EOL();
-    #elif ENABLED(Z_DUAL_ENDSTOPS)
+
+    #elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Z2 Endstop adjustment:");
+        SERIAL_ECHOLNPGM("Endstop adjustment:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M666 Z", LINEAR_UNIT(endstops.z_endstop_adj));
+      SERIAL_ECHOPGM("  M666");
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(endstops.x_endstop_adj));
+      #endif
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstops.y_endstop_adj));
+      #endif
+      #if ENABLED(Z_DUAL_ENDSTOPS)
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(endstops.z_endstop_adj));
+      #endif
+      SERIAL_EOL();
     #endif // DELTA
 
     #if ENABLED(ULTIPANEL)
@@ -1738,7 +1807,7 @@ void MarlinSettings::reset() {
     #endif // FWRETRACT
 
     /**
-     * Auto Bed Leveling
+     * Probe Offset
      */
     #if HAS_BED_PROBE
       if (!forReplay) {

commit 3e8754a38a57f0b37e6880b1ddc6214890f6cf5e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 18:21:15 2017 -0500

    Add/correct time units on planner vars / M205 B

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 99d9eb9f4d..5d6caf98e8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -56,7 +56,7 @@
  *  163  M204 T    planner.travel_acceleration      (float)
  *  167  M205 S    planner.min_feedrate_mm_s        (float)
  *  171  M205 T    planner.min_travel_feedrate_mm_s (float)
- *  175  M205 B    planner.min_segment_time         (ulong)
+ *  175  M205 B    planner.min_segment_time_us      (ulong)
  *  179  M205 X    planner.max_jerk[X_AXIS]         (float)
  *  183  M205 Y    planner.max_jerk[Y_AXIS]         (float)
  *  187  M205 Z    planner.max_jerk[Z_AXIS]         (float)
@@ -68,7 +68,7 @@
  *  219            z_fade_height                    (float)
  *
  * MESH_BED_LEVELING:                               43 bytes
- *  223  M420 S    planner.leveling_active         (bool)
+ *  223  M420 S    planner.leveling_active          (bool)
  *  224            mbl.z_offset                     (float)
  *  228            GRID_MAX_POINTS_X                (uint8_t)
  *  229            GRID_MAX_POINTS_Y                (uint8_t)
@@ -305,7 +305,7 @@ void MarlinSettings::postprocess() {
     EEPROM_WRITE(planner.travel_acceleration);
     EEPROM_WRITE(planner.min_feedrate_mm_s);
     EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
-    EEPROM_WRITE(planner.min_segment_time);
+    EEPROM_WRITE(planner.min_segment_time_us);
     EEPROM_WRITE(planner.max_jerk);
     #if !HAS_HOME_OFFSET
       const float home_offset[XYZ] = { 0 };
@@ -699,7 +699,7 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(planner.travel_acceleration);
       EEPROM_READ(planner.min_feedrate_mm_s);
       EEPROM_READ(planner.min_travel_feedrate_mm_s);
-      EEPROM_READ(planner.min_segment_time);
+      EEPROM_READ(planner.min_segment_time_us);
       EEPROM_READ(planner.max_jerk);
 
       #if !HAS_HOME_OFFSET
@@ -1166,7 +1166,7 @@ void MarlinSettings::reset() {
   planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
-  planner.min_segment_time = DEFAULT_MINSEGMENTTIME;
+  planner.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
   planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
   planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
@@ -1504,12 +1504,12 @@ void MarlinSettings::reset() {
 
     if (!forReplay) {
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_ms> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
+      SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_us> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
     }
     CONFIG_ECHO_START;
     SERIAL_ECHOPAIR("  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
     SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
-    SERIAL_ECHOPAIR(" B", planner.min_segment_time);
+    SERIAL_ECHOPAIR(" B", planner.min_segment_time_us);
     SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
     SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
     SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));

commit 572cf0ec951f9a1703d50d2e10b62f323b76941f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Oct 18 14:00:29 2017 -0500

    UBL able to generate mesh and save and load it on 32-bit platforms (#8015)
    
    * Get UBL Mesh Generation, Mesh Save & Mesh Load working with 32-Bit platforms
    
    * clean up read_data() and write_data() for non-LPC1768 HAL's
    
    * Get read_data() and write_data() return codes consistent
    
    All HAL's read_data() and write_data() return false if they succeed.
    
    * Get read_data() and write_data() return codes to be consistent
    
    Make read_data() and write_data() return true if an error happens.
    
    * Say UBL is now checked out on machine types in default Configuration.h file.

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 4a37e477e8..99d9eb9f4d 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -632,12 +632,12 @@ void MarlinSettings::postprocess() {
         SERIAL_ECHOLNPGM(")");
       #endif
     }
+    EEPROM_FINISH();
 
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
     #endif
-    EEPROM_FINISH();
     return !eeprom_error;
   }
 
@@ -1073,14 +1073,21 @@ void MarlinSettings::postprocess() {
         }
 
         uint16_t crc = 0;
+        bool status;
         int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
 
-        HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        HAL::PersistentStore::access_start();
+        status = HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        HAL::PersistentStore::access_finish();
+
+        if (status)
+          SERIAL_PROTOCOL("?Unable to save mesh data.\n");
 
         // Write crc to MAT along with other data, or just tack on to the beginning or end
 
         #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_PROTOCOLLNPAIR("Mesh saved in slot ", slot);
+          if (!status)
+            SERIAL_PROTOCOLLNPAIR("Mesh saved in slot ", slot);
         #endif
 
       #else
@@ -1106,13 +1113,20 @@ void MarlinSettings::postprocess() {
         uint16_t crc = 0;
         int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
         uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
-        HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        uint16_t status;
 
-        // Compare crc with crc from MAT, or read from end
+        HAL::PersistentStore::access_start();
+        status = HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        HAL::PersistentStore::access_finish();
+
+        if (status)
+          SERIAL_PROTOCOL("?Unable to load mesh data.\n");
 
         #if ENABLED(EEPROM_CHITCHAT)
-          SERIAL_PROTOCOLLNPAIR("Mesh loaded from slot ", slot);
+          else
+            SERIAL_PROTOCOLLNPAIR("Mesh loaded from slot ", slot);
         #endif
+        EEPROM_FINISH();
 
       #else
 

commit 1344ca4b2fa6c9dea4e6ea257908302add185018
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 21:56:27 2017 -0500

    UBL no longer needs ubl_state

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 85dae24751..4a37e477e8 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -89,7 +89,7 @@
  *
  * AUTO_BED_LEVELING_UBL:                           2 bytes
  *  324  G29 A     planner.leveling_active          (bool)
- *  325  G29 S     ubl.state.storage_slot           (int8_t)
+ *  325  G29 S     ubl.storage_slot                 (int8_t)
  *
  * DELTA:                                           48 bytes
  *  344  M666 XYZ  delta_endstop_adj                (float x3)
@@ -411,7 +411,7 @@ void MarlinSettings::postprocess() {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       EEPROM_WRITE(planner.leveling_active);
-      EEPROM_WRITE(ubl.state.storage_slot);
+      EEPROM_WRITE(ubl.storage_slot);
     #else
       const bool ubl_active = false;
       const int8_t storage_slot = -1;
@@ -634,8 +634,8 @@ void MarlinSettings::postprocess() {
     }
 
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
-      if (ubl.state.storage_slot >= 0)
-        store_mesh(ubl.state.storage_slot);
+      if (ubl.storage_slot >= 0)
+        store_mesh(ubl.storage_slot);
     #endif
     EEPROM_FINISH();
     return !eeprom_error;
@@ -798,7 +798,7 @@ void MarlinSettings::postprocess() {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EEPROM_READ(planner.leveling_active);
-        EEPROM_READ(ubl.state.storage_slot);
+        EEPROM_READ(ubl.storage_slot);
       #else
         uint8_t dummyui8;
         EEPROM_READ(dummyb);
@@ -1015,10 +1015,10 @@ void MarlinSettings::postprocess() {
           ubl.reset();
         }
 
-        if (ubl.state.storage_slot >= 0) {
-          load_mesh(ubl.state.storage_slot);
+        if (ubl.storage_slot >= 0) {
+          load_mesh(ubl.storage_slot);
           #if ENABLED(EEPROM_CHITCHAT)
-            SERIAL_ECHOPAIR("Mesh ", ubl.state.storage_slot);
+            SERIAL_ECHOPAIR("Mesh ", ubl.storage_slot);
             SERIAL_ECHOLNPGM(" loaded from storage.");
           #endif
         }
@@ -1570,7 +1570,7 @@ void MarlinSettings::reset() {
         SERIAL_EOL();
         ubl.report_state();
 
-        SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.state.storage_slot);
+        SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.storage_slot);
         SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
         SERIAL_ECHOLNPGM(" meshes.\n");
       }

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 49cc205c5f..85dae24751 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -68,7 +68,7 @@
  *  219            z_fade_height                    (float)
  *
  * MESH_BED_LEVELING:                               43 bytes
- *  223  M420 S    from mbl.status                  (bool)
+ *  223  M420 S    planner.leveling_active         (bool)
  *  224            mbl.z_offset                     (float)
  *  228            GRID_MAX_POINTS_X                (uint8_t)
  *  229            GRID_MAX_POINTS_Y                (uint8_t)
@@ -88,7 +88,7 @@
  *  316            z_values[][]                     (float x9, up to float x256) +988
  *
  * AUTO_BED_LEVELING_UBL:                           2 bytes
- *  324  G29 A     ubl.state.active                 (bool)
+ *  324  G29 A     planner.leveling_active          (bool)
  *  325  G29 S     ubl.state.storage_slot           (int8_t)
  *
  * DELTA:                                           48 bytes
@@ -202,6 +202,10 @@ MarlinSettings settings;
   #include "../feature/fwretract.h"
 #endif
 
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+  float new_z_fade_height;
+#endif
+
 /**
  * Post-process after Retrieve or Reset
  */
@@ -231,7 +235,7 @@ void MarlinSettings::postprocess() {
   #endif
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    set_z_fade_height(planner.z_fade_height);
+    set_z_fade_height(new_z_fade_height);
   #endif
 
   #if HAS_BED_PROBE
@@ -329,7 +333,7 @@ void MarlinSettings::postprocess() {
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       const float zfh = planner.z_fade_height;
     #else
-      const float zfh = 10.0;
+      const float zfh = 0.0;
     #endif
     EEPROM_WRITE(zfh);
 
@@ -343,7 +347,7 @@ void MarlinSettings::postprocess() {
         sizeof(mbl.z_values) == GRID_MAX_POINTS * sizeof(mbl.z_values[0][0]),
         "MBL Z array is the wrong size."
       );
-      const bool leveling_is_on = TEST(mbl.status, MBL_STATUS_HAS_MESH_BIT);
+      const bool leveling_is_on = mbl.has_mesh;
       const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
       EEPROM_WRITE(leveling_is_on);
       EEPROM_WRITE(mbl.z_offset);
@@ -406,7 +410,7 @@ void MarlinSettings::postprocess() {
     #endif // AUTO_BED_LEVELING_BILINEAR
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      EEPROM_WRITE(ubl.state.active);
+      EEPROM_WRITE(planner.leveling_active);
       EEPROM_WRITE(ubl.state.storage_slot);
     #else
       const bool ubl_active = false;
@@ -720,7 +724,7 @@ void MarlinSettings::postprocess() {
       //
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        EEPROM_READ(planner.z_fade_height);
+        EEPROM_READ(new_z_fade_height);
       #else
         EEPROM_READ(dummy);
       #endif
@@ -737,7 +741,7 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(mesh_num_y);
 
       #if ENABLED(MESH_BED_LEVELING)
-        mbl.status = leveling_is_on ? _BV(MBL_STATUS_HAS_MESH_BIT) : 0;
+        mbl.has_mesh = leveling_is_on;
         mbl.z_offset = dummy;
         if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
           // EEPROM data fits the current mesh
@@ -793,7 +797,7 @@ void MarlinSettings::postprocess() {
         }
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EEPROM_READ(ubl.state.active);
+        EEPROM_READ(planner.leveling_active);
         EEPROM_READ(ubl.state.storage_slot);
       #else
         uint8_t dummyui8;
@@ -1156,7 +1160,7 @@ void MarlinSettings::reset() {
   planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    planner.z_fade_height = 0.0;
+    new_z_fade_height = 0.0;
   #endif
 
   #if HAS_HOME_OFFSET
@@ -1556,9 +1560,9 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM(":");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", LEVELING_IS_ACTIVE() ? 1 : 0);
+      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOPAIR(" Z", planner.z_fade_height);
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
       #endif
       SERIAL_EOL();
 
@@ -1578,7 +1582,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM("Auto Bed Leveling:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", LEVELING_IS_ACTIVE() ? 1 : 0);
+      SERIAL_ECHOPAIR("  M420 S", planner.leveling_active ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
       #endif

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 88bd2ad867..49cc205c5f 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -1556,7 +1556,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM(":");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", leveling_is_active() ? 1 : 0);
+      SERIAL_ECHOPAIR("  M420 S", LEVELING_IS_ACTIVE() ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOPAIR(" Z", planner.z_fade_height);
       #endif
@@ -1578,7 +1578,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM("Auto Bed Leveling:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M420 S", leveling_is_active() ? 1 : 0);
+      SERIAL_ECHOPAIR("  M420 S", LEVELING_IS_ACTIVE() ? 1 : 0);
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
       #endif

commit 1adb5a6a4800e65e04cef5833dc1cf21c7e13c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 12 22:20:02 2017 -0500

    Remove obsolete UBL z_offset

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 7fbcbf0e79..88bd2ad867 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V41"
+#define EEPROM_VERSION "V42"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V41 EEPROM Layout:
+ * V42 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -87,13 +87,12 @@
  *  312  G29 L F   bilinear_start                   (int x2)
  *  316            z_values[][]                     (float x9, up to float x256) +988
  *
- * AUTO_BED_LEVELING_UBL:                           6 bytes
+ * AUTO_BED_LEVELING_UBL:                           2 bytes
  *  324  G29 A     ubl.state.active                 (bool)
- *  325  G29 Z     ubl.state.z_offset               (float)
- *  329  G29 S     ubl.state.storage_slot           (int8_t)
+ *  325  G29 S     ubl.state.storage_slot           (int8_t)
  *
  * DELTA:                                           48 bytes
- *  348  M666 XYZ  delta_endstop_adj                (float x3)
+ *  344  M666 XYZ  delta_endstop_adj                (float x3)
  *  360  M665 R    delta_radius                     (float)
  *  364  M665 L    delta_diagonal_rod               (float)
  *  368  M665 S    delta_segments_per_second        (float)
@@ -408,14 +407,11 @@ void MarlinSettings::postprocess() {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       EEPROM_WRITE(ubl.state.active);
-      EEPROM_WRITE(ubl.state.z_offset);
       EEPROM_WRITE(ubl.state.storage_slot);
     #else
       const bool ubl_active = false;
-      dummy = 0.0f;
       const int8_t storage_slot = -1;
       EEPROM_WRITE(ubl_active);
-      EEPROM_WRITE(dummy);
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
@@ -798,12 +794,10 @@ void MarlinSettings::postprocess() {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EEPROM_READ(ubl.state.active);
-        EEPROM_READ(ubl.state.z_offset);
         EEPROM_READ(ubl.state.storage_slot);
       #else
         uint8_t dummyui8;
         EEPROM_READ(dummyb);
-        EEPROM_READ(dummy);
         EEPROM_READ(dummyui8);
       #endif // AUTO_BED_LEVELING_UBL
 
@@ -1573,11 +1567,6 @@ void MarlinSettings::reset() {
         ubl.report_state();
 
         SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.state.storage_slot);
-
-        SERIAL_ECHOPGM("z_offset: ");
-        SERIAL_ECHO_F(ubl.state.z_offset, 6);
-        SERIAL_EOL();
-
         SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
         SERIAL_ECHOLNPGM(" meshes.\n");
       }

commit ae2173cd52eab7f63ef7e7850ab6459b1b7b5a9b
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Fri Sep 29 08:03:28 2017 -0500

    Synchronize retractions

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 36043f2fed..7fbcbf0e79 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -247,6 +247,10 @@ void MarlinSettings::postprocess() {
   #if HAS_MOTOR_CURRENT_PWM
     stepper.refresh_motor_power();
   #endif
+
+  #if ENABLED(FWRETRACT)
+    fwretract.refresh_autoretract();
+  #endif
 }
 
 #if ENABLED(EEPROM_SETTINGS)

commit 6d5fcac54ae76374065aed322e9f66f71756af70
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 24 02:18:15 2017 -0500

    G33 changes from 1.1.x

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f402cc33a5..36043f2fed 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -36,13 +36,13 @@
  *
  */
 
-#define EEPROM_VERSION "V40"
+#define EEPROM_VERSION "V41"
 
 // Change EEPROM version if these are changed:
 #define EEPROM_OFFSET 100
 
 /**
- * V39 EEPROM Layout:
+ * V41 EEPROM Layout:
  *
  *  100  Version                                    (char x4)
  *  104  EEPROM CRC16                               (uint16_t)
@@ -93,14 +93,14 @@
  *  329  G29 S     ubl.state.storage_slot           (int8_t)
  *
  * DELTA:                                           48 bytes
- *  348  M666 XYZ  delta_endstop_adj                      (float x3)
+ *  348  M666 XYZ  delta_endstop_adj                (float x3)
  *  360  M665 R    delta_radius                     (float)
  *  364  M665 L    delta_diagonal_rod               (float)
  *  368  M665 S    delta_segments_per_second        (float)
  *  372  M665 B    delta_calibration_radius         (float)
  *  376  M665 X    delta_tower_angle_trim[A]        (float)
  *  380  M665 Y    delta_tower_angle_trim[B]        (float)
- *  ---  M665 Z    delta_tower_angle_trim[C]        (float) is always 0.0
+ *  384  M665 Z    delta_tower_angle_trim[C]        (float)
  *
  * Z_DUAL_ENDSTOPS:                                 48 bytes
  *  348  M666 Z    endstops.z_endstop_adj           (float)
@@ -213,7 +213,7 @@ void MarlinSettings::postprocess() {
   // Make sure delta kinematics are updated before refreshing the
   // planner position so the stepper counts will be set correctly.
   #if ENABLED(DELTA)
-    recalc_delta_settings(delta_radius, delta_diagonal_rod);
+    recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
   #endif
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
@@ -415,16 +415,16 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(storage_slot);
     #endif // AUTO_BED_LEVELING_UBL
 
-    // 9 floats for DELTA / Z_DUAL_ENDSTOPS
+    // 10 floats for DELTA / Z_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
-      EEPROM_WRITE(delta_endstop_adj);               // 3 floats
+      EEPROM_WRITE(delta_endstop_adj);         // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
       EEPROM_WRITE(delta_diagonal_rod);        // 1 float
       EEPROM_WRITE(delta_segments_per_second); // 1 float
       EEPROM_WRITE(delta_calibration_radius);  // 1 float
-      EEPROM_WRITE(delta_tower_angle_trim);    // 2 floats
+      EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
       dummy = 0.0f;
-      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
+      for (uint8_t q = 2; q--;) EEPROM_WRITE(dummy);
     #elif ENABLED(Z_DUAL_ENDSTOPS)
       EEPROM_WRITE(endstops.z_endstop_adj);    // 1 float
       dummy = 0.0f;
@@ -804,14 +804,14 @@ void MarlinSettings::postprocess() {
       #endif // AUTO_BED_LEVELING_UBL
 
       #if ENABLED(DELTA)
-        EEPROM_READ(delta_endstop_adj);               // 3 floats
+        EEPROM_READ(delta_endstop_adj);         // 3 floats
         EEPROM_READ(delta_radius);              // 1 float
         EEPROM_READ(delta_diagonal_rod);        // 1 float
         EEPROM_READ(delta_segments_per_second); // 1 float
         EEPROM_READ(delta_calibration_radius);  // 1 float
-        EEPROM_READ(delta_tower_angle_trim);    // 2 floats
+        EEPROM_READ(delta_tower_angle_trim);    // 3 floats
         dummy = 0.0f;
-        for (uint8_t q=3; q--;) EEPROM_READ(dummy);
+        for (uint8_t q=2; q--;) EEPROM_READ(dummy);
       #elif ENABLED(Z_DUAL_ENDSTOPS)
         EEPROM_READ(endstops.z_endstop_adj);    // 1 float
         dummy = 0.0f;
@@ -1199,8 +1199,7 @@ void MarlinSettings::reset() {
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
-    delta_tower_angle_trim[A_AXIS] = dta[A_AXIS] - dta[C_AXIS];
-    delta_tower_angle_trim[B_AXIS] = dta[B_AXIS] - dta[C_AXIS];
+    COPY(delta_tower_angle_trim, dta);
     home_offset[Z_AXIS] = 0;
 
   #elif ENABLED(Z_DUAL_ENDSTOPS)
@@ -1615,7 +1614,7 @@ void MarlinSettings::reset() {
       SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
       SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
       SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
-      SERIAL_ECHOPAIR(" Z", 0.00);
+      SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
       SERIAL_EOL();
     #elif ENABLED(Z_DUAL_ENDSTOPS)
       if (!forReplay) {

commit 00b1b33816ac8bb5dc8b89e200ff25621c06e894
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Sat Sep 23 15:31:51 2017 +0200

    Fix compiler warning

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 5edf67f874..f402cc33a5 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -608,7 +608,9 @@ void MarlinSettings::postprocess() {
     #endif
 
     if (!eeprom_error) {
-      const int eeprom_size = eeprom_index;
+      #if ENABLED(EEPROM_CHITCHAT)
+        const int eeprom_size = eeprom_index;
+      #endif
 
       const uint16_t final_crc = working_crc;
 

commit 64dfb464610e35c3a65748170b5f015ffe1bc9bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:56:10 2017 -0500

    Move z_endstop_adj to Endstops

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index e32ce4fa7a..5edf67f874 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -103,7 +103,7 @@
  *  ---  M665 Z    delta_tower_angle_trim[C]        (float) is always 0.0
  *
  * Z_DUAL_ENDSTOPS:                                 48 bytes
- *  348  M666 Z    z_endstop_adj                    (float)
+ *  348  M666 Z    endstops.z_endstop_adj           (float)
  *  ---            dummy data                       (float x11)
  *
  * ULTIPANEL:                                       6 bytes
@@ -426,7 +426,7 @@ void MarlinSettings::postprocess() {
       dummy = 0.0f;
       for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
     #elif ENABLED(Z_DUAL_ENDSTOPS)
-      EEPROM_WRITE(z_endstop_adj);             // 1 float
+      EEPROM_WRITE(endstops.z_endstop_adj);    // 1 float
       dummy = 0.0f;
       for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
     #else
@@ -811,7 +811,7 @@ void MarlinSettings::postprocess() {
         dummy = 0.0f;
         for (uint8_t q=3; q--;) EEPROM_READ(dummy);
       #elif ENABLED(Z_DUAL_ENDSTOPS)
-        EEPROM_READ(z_endstop_adj);
+        EEPROM_READ(endstops.z_endstop_adj);    // 1 float
         dummy = 0.0f;
         for (uint8_t q=11; q--;) EEPROM_READ(dummy);
       #else
@@ -1203,7 +1203,7 @@ void MarlinSettings::reset() {
 
   #elif ENABLED(Z_DUAL_ENDSTOPS)
 
-    z_endstop_adj =
+    endstops.z_endstop_adj =
       #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
         Z_DUAL_ENDSTOPS_ADJUSTMENT
       #else
@@ -1621,7 +1621,7 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM("Z2 Endstop adjustment:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M666 Z", LINEAR_UNIT(z_endstop_adj));
+      SERIAL_ECHOLNPAIR("  M666 Z", LINEAR_UNIT(endstops.z_endstop_adj));
     #endif // DELTA
 
     #if ENABLED(ULTIPANEL)

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index f481067419..e32ce4fa7a 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -138,7 +138,7 @@
  *
  * Volumetric Extrusion:                            21 bytes
  *  537  M200 D    parser.volumetric_enabled        (bool)
- *  538  M200 T D  filament_size                    (float x5) (T0..3)
+ *  538  M200 T D  planner.filament_size            (float x5) (T0..3)
  *
  * HAVE_TMC2130:                                    20 bytes
  *  558  M906 X    Stepper X current                (uint16_t)
@@ -224,7 +224,7 @@ void MarlinSettings::postprocess() {
     thermalManager.updatePID();
   #endif
 
-  calculate_volumetric_multipliers();
+  planner.calculate_volumetric_multipliers();
 
   #if HAS_HOME_OFFSET || ENABLED(DUAL_X_CARRIAGE)
     // Software endstops depend on home_offset
@@ -509,7 +509,7 @@ void MarlinSettings::postprocess() {
 
     // Save filament sizes
     for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
-      if (q < COUNT(filament_size)) dummy = filament_size[q];
+      if (q < COUNT(planner.filament_size)) dummy = planner.filament_size[q];
       EEPROM_WRITE(dummy);
     }
 
@@ -895,7 +895,7 @@ void MarlinSettings::postprocess() {
 
       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
         EEPROM_READ(dummy);
-        if (q < COUNT(filament_size)) filament_size[q] = dummy;
+        if (q < COUNT(planner.filament_size)) planner.filament_size[q] = dummy;
       }
 
       uint16_t val;
@@ -1260,8 +1260,8 @@ void MarlinSettings::reset() {
       false
     #endif
   ;
-  for (uint8_t q = 0; q < COUNT(filament_size); q++)
-    filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+  for (uint8_t q = 0; q < COUNT(planner.filament_size); q++)
+    planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
 
   endstops.enable_globally(
     #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
@@ -1388,23 +1388,23 @@ void MarlinSettings::reset() {
     }
 
     CONFIG_ECHO_START;
-    SERIAL_ECHOPAIR("  M200 D", filament_size[0]);
+    SERIAL_ECHOPAIR("  M200 D", planner.filament_size[0]);
     SERIAL_EOL();
     #if EXTRUDERS > 1
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M200 T1 D", filament_size[1]);
+      SERIAL_ECHOPAIR("  M200 T1 D", planner.filament_size[1]);
       SERIAL_EOL();
       #if EXTRUDERS > 2
         CONFIG_ECHO_START;
-        SERIAL_ECHOPAIR("  M200 T2 D", filament_size[2]);
+        SERIAL_ECHOPAIR("  M200 T2 D", planner.filament_size[2]);
         SERIAL_EOL();
         #if EXTRUDERS > 3
           CONFIG_ECHO_START;
-          SERIAL_ECHOPAIR("  M200 T3 D", filament_size[3]);
+          SERIAL_ECHOPAIR("  M200 T3 D", planner.filament_size[3]);
           SERIAL_EOL();
           #if EXTRUDERS > 4
             CONFIG_ECHO_START;
-            SERIAL_ECHOPAIR("  M200 T4 D", filament_size[4]);
+            SERIAL_ECHOPAIR("  M200 T4 D", planner.filament_size[4]);
             SERIAL_EOL();
           #endif // EXTRUDERS > 4
         #endif // EXTRUDERS > 3

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 3eb692f430..f481067419 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -93,7 +93,7 @@
  *  329  G29 S     ubl.state.storage_slot           (int8_t)
  *
  * DELTA:                                           48 bytes
- *  348  M666 XYZ  endstop_adj                      (float x3)
+ *  348  M666 XYZ  delta_endstop_adj                      (float x3)
  *  360  M665 R    delta_radius                     (float)
  *  364  M665 L    delta_diagonal_rod               (float)
  *  368  M665 S    delta_segments_per_second        (float)
@@ -187,6 +187,10 @@ MarlinSettings settings;
 
 #include "../gcode/parser.h"
 
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
 #if HAS_BED_PROBE
   #include "../module/probe.h"
 #endif
@@ -199,14 +203,6 @@ MarlinSettings settings;
   #include "../feature/fwretract.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-  extern void refresh_bed_level();
-#endif
-
-#if ENABLED(FWRETRACT)
-  #include "../gcode/feature/fwretract/fwretract.h"
-#endif
-
 /**
  * Post-process after Retrieve or Reset
  */
@@ -421,7 +417,7 @@ void MarlinSettings::postprocess() {
 
     // 9 floats for DELTA / Z_DUAL_ENDSTOPS
     #if ENABLED(DELTA)
-      EEPROM_WRITE(endstop_adj);               // 3 floats
+      EEPROM_WRITE(delta_endstop_adj);               // 3 floats
       EEPROM_WRITE(delta_radius);              // 1 float
       EEPROM_WRITE(delta_diagonal_rod);        // 1 float
       EEPROM_WRITE(delta_segments_per_second); // 1 float
@@ -806,7 +802,7 @@ void MarlinSettings::postprocess() {
       #endif // AUTO_BED_LEVELING_UBL
 
       #if ENABLED(DELTA)
-        EEPROM_READ(endstop_adj);               // 3 floats
+        EEPROM_READ(delta_endstop_adj);               // 3 floats
         EEPROM_READ(delta_radius);              // 1 float
         EEPROM_READ(delta_diagonal_rod);        // 1 float
         EEPROM_READ(delta_segments_per_second); // 1 float
@@ -1196,7 +1192,7 @@ void MarlinSettings::reset() {
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ,
                 dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
-    COPY(endstop_adj, adj);
+    COPY(delta_endstop_adj, adj);
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
@@ -1602,9 +1598,9 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM("Endstop adjustment:");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(endstop_adj[X_AXIS]));
-      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstop_adj[Y_AXIS]));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(endstop_adj[Z_AXIS]));
+      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(delta_endstop_adj[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_endstop_adj[Y_AXIS]));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(delta_endstop_adj[Z_AXIS]));
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");

commit 63228fc45355232ba2c6a7838666ed76958623f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 11:41:12 2017 -0500

    Move volumetric flag to GCodeParser

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 898c496cd1..3eb692f430 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -137,7 +137,7 @@
  *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
  *
  * Volumetric Extrusion:                            21 bytes
- *  537  M200 D    volumetric_enabled               (bool)
+ *  537  M200 D    parser.volumetric_enabled        (bool)
  *  538  M200 T D  filament_size                    (float x5) (T0..3)
  *
  * HAVE_TMC2130:                                    20 bytes
@@ -185,9 +185,7 @@ MarlinSettings settings;
 #include "../core/language.h"
 #include "../Marlin.h"
 
-#if ENABLED(INCH_MODE_SUPPORT) || (ENABLED(ULTIPANEL) && ENABLED(TEMPERATURE_UNITS_SUPPORT))
-  #include "../gcode/parser.h"
-#endif
+#include "../gcode/parser.h"
 
 #if HAS_BED_PROBE
   #include "../module/probe.h"
@@ -511,7 +509,7 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(fwretract.swap_retract_recover_feedrate_mm_s);
     #endif
 
-    EEPROM_WRITE(volumetric_enabled);
+    EEPROM_WRITE(parser.volumetric_enabled);
 
     // Save filament sizes
     for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
@@ -897,7 +895,7 @@ void MarlinSettings::postprocess() {
         for (uint8_t q=8; q--;) EEPROM_READ(dummy);
       #endif
 
-      EEPROM_READ(volumetric_enabled);
+      EEPROM_READ(parser.volumetric_enabled);
 
       for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
         EEPROM_READ(dummy);
@@ -1259,7 +1257,7 @@ void MarlinSettings::reset() {
     fwretract.reset();
   #endif
 
-  volumetric_enabled =
+  parser.volumetric_enabled =
     #if ENABLED(VOLUMETRIC_DEFAULT_ON)
       true
     #else
@@ -1350,7 +1348,7 @@ void MarlinSettings::reset() {
     CONFIG_ECHO_START;
     #if ENABLED(INCH_MODE_SUPPORT)
       #define LINEAR_UNIT(N) ((N) / parser.linear_unit_factor)
-      #define VOLUMETRIC_UNIT(N) ((N) / (volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
+      #define VOLUMETRIC_UNIT(N) ((N) / (parser.volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
       SERIAL_ECHOPGM("  G2");
       SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
       SERIAL_ECHOPGM(" ; Units in ");
@@ -1387,7 +1385,7 @@ void MarlinSettings::reset() {
     if (!forReplay) {
       CONFIG_ECHO_START;
       SERIAL_ECHOPGM("Filament settings:");
-      if (volumetric_enabled)
+      if (parser.volumetric_enabled)
         SERIAL_EOL();
       else
         SERIAL_ECHOLNPGM(" Disabled");
@@ -1417,7 +1415,7 @@ void MarlinSettings::reset() {
       #endif // EXTRUDERS > 2
     #endif // EXTRUDERS > 1
 
-    if (!volumetric_enabled) {
+    if (!parser.volumetric_enabled) {
       CONFIG_ECHO_START;
       SERIAL_ECHOLNPGM("  M200 D0");
     }

commit a98e9874dbf24a73874ecbda86b5fe739a8223d0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:40:32 2017 -0500

    FWRETRACT as a feature

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index 362f629de7..898c496cd1 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -205,6 +205,10 @@ MarlinSettings settings;
   extern void refresh_bed_level();
 #endif
 
+#if ENABLED(FWRETRACT)
+  #include "../gcode/feature/fwretract/fwretract.h"
+#endif
+
 /**
  * Post-process after Retrieve or Reset
  */
@@ -492,24 +496,20 @@ void MarlinSettings::postprocess() {
 
     #if DISABLED(FWRETRACT)
       const bool autoretract_enabled = false;
-      const float retract_length = 3,
-                  retract_feedrate_mm_s = 45,
-                  retract_zlift = 0,
-                  retract_recover_length = 0,
-                  retract_recover_feedrate_mm_s = 0,
-                  swap_retract_length = 13,
-                  swap_retract_recover_length = 0,
-                  swap_retract_recover_feedrate_mm_s = 8;
+      const float autoretract_defaults[] = { 3, 45, 0, 0, 0, 13, 0, 8 };
+      EEPROM_WRITE(autoretract_enabled);
+      EEPROM_WRITE(autoretract_defaults);
+    #else
+      EEPROM_WRITE(fwretract.autoretract_enabled);
+      EEPROM_WRITE(fwretract.retract_length);
+      EEPROM_WRITE(fwretract.retract_feedrate_mm_s);
+      EEPROM_WRITE(fwretract.retract_zlift);
+      EEPROM_WRITE(fwretract.retract_recover_length);
+      EEPROM_WRITE(fwretract.retract_recover_feedrate_mm_s);
+      EEPROM_WRITE(fwretract.swap_retract_length);
+      EEPROM_WRITE(fwretract.swap_retract_recover_length);
+      EEPROM_WRITE(fwretract.swap_retract_recover_feedrate_mm_s);
     #endif
-    EEPROM_WRITE(autoretract_enabled);
-    EEPROM_WRITE(retract_length);
-    EEPROM_WRITE(retract_feedrate_mm_s);
-    EEPROM_WRITE(retract_zlift);
-    EEPROM_WRITE(retract_recover_length);
-    EEPROM_WRITE(retract_recover_feedrate_mm_s);
-    EEPROM_WRITE(swap_retract_length);
-    EEPROM_WRITE(swap_retract_recover_length);
-    EEPROM_WRITE(swap_retract_recover_feedrate_mm_s);
 
     EEPROM_WRITE(volumetric_enabled);
 
@@ -883,15 +883,15 @@ void MarlinSettings::postprocess() {
       EEPROM_READ(lcd_contrast);
 
       #if ENABLED(FWRETRACT)
-        EEPROM_READ(autoretract_enabled);
-        EEPROM_READ(retract_length);
-        EEPROM_READ(retract_feedrate_mm_s);
-        EEPROM_READ(retract_zlift);
-        EEPROM_READ(retract_recover_length);
-        EEPROM_READ(retract_recover_feedrate_mm_s);
-        EEPROM_READ(swap_retract_length);
-        EEPROM_READ(swap_retract_recover_length);
-        EEPROM_READ(swap_retract_recover_feedrate_mm_s);
+        EEPROM_READ(fwretract.autoretract_enabled);
+        EEPROM_READ(fwretract.retract_length);
+        EEPROM_READ(fwretract.retract_feedrate_mm_s);
+        EEPROM_READ(fwretract.retract_zlift);
+        EEPROM_READ(fwretract.retract_recover_length);
+        EEPROM_READ(fwretract.retract_recover_feedrate_mm_s);
+        EEPROM_READ(fwretract.swap_retract_length);
+        EEPROM_READ(fwretract.swap_retract_recover_length);
+        EEPROM_READ(fwretract.swap_retract_recover_feedrate_mm_s);
       #else
         EEPROM_READ(dummyb);
         for (uint8_t q=8; q--;) EEPROM_READ(dummy);
@@ -1256,16 +1256,8 @@ void MarlinSettings::reset() {
   #endif
 
   #if ENABLED(FWRETRACT)
-    autoretract_enabled = false;
-    retract_length = RETRACT_LENGTH;
-    retract_feedrate_mm_s = RETRACT_FEEDRATE;
-    retract_zlift = RETRACT_ZLIFT;
-    retract_recover_length = RETRACT_RECOVER_LENGTH;
-    retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE;
-    swap_retract_length = RETRACT_LENGTH_SWAP;
-    swap_retract_recover_length = RETRACT_RECOVER_LENGTH_SWAP;
-    swap_retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE_SWAP;
-  #endif // FWRETRACT
+    fwretract.reset();
+  #endif
 
   volumetric_enabled =
     #if ENABLED(VOLUMETRIC_DEFAULT_ON)
@@ -1716,26 +1708,26 @@ void MarlinSettings::reset() {
         SERIAL_ECHOLNPGM("Retract: S<length> F<units/m> Z<lift>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(retract_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(swap_retract_length));
-      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(retract_feedrate_mm_s)));
-      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(retract_zlift));
+      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(fwretract.retract_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.swap_retract_length));
+      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(fwretract.retract_zlift));
 
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Recover: S<length> F<units/m>");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(retract_recover_length));
-      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(swap_retract_recover_length));
-      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(retract_recover_feedrate_mm_s)));
+      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(fwretract.retract_recover_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(fwretract.swap_retract_recover_length));
+      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(fwretract.retract_recover_feedrate_mm_s)));
 
       if (!forReplay) {
         CONFIG_ECHO_START;
         SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
       }
       CONFIG_ECHO_START;
-      SERIAL_ECHOLNPAIR("  M209 S", autoretract_enabled ? 1 : 0);
+      SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
 
     #endif // FWRETRACT
 

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
index d90cefdb7b..362f629de7 100644
--- a/Marlin/src/module/configuration_store.cpp
+++ b/Marlin/src/module/configuration_store.cpp
@@ -177,28 +177,28 @@
 
 MarlinSettings settings;
 
-#include "Marlin.h"
-#include "language.h"
 #include "endstops.h"
 #include "planner.h"
-#include "temperature.h"
-#include "ultralcd.h"
 #include "stepper.h"
+#include "temperature.h"
+#include "../lcd/ultralcd.h"
+#include "../core/language.h"
+#include "../Marlin.h"
 
 #if ENABLED(INCH_MODE_SUPPORT) || (ENABLED(ULTIPANEL) && ENABLED(TEMPERATURE_UNITS_SUPPORT))
-  #include "gcode.h"
+  #include "../gcode/parser.h"
 #endif
 
-#if ENABLED(MESH_BED_LEVELING)
-  #include "mesh_bed_leveling.h"
+#if HAS_BED_PROBE
+  #include "../module/probe.h"
 #endif
 
 #if ENABLED(HAVE_TMC2130)
   #include "stepper_indirection.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "ubl.h"
+#if ENABLED(FWRETRACT)
+  #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -252,7 +252,7 @@ void MarlinSettings::postprocess() {
 }
 
 #if ENABLED(EEPROM_SETTINGS)
-  #include "src/HAL/persistent_store_api.h"
+  #include "../HAL/persistent_store_api.h"
 
   #define DUMMY_PID_VALUE 3000.0f
   #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; HAL::PersistentStore::access_start()

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/configuration_store.cpp b/Marlin/src/module/configuration_store.cpp
new file mode 100644
index 0000000000..d90cefdb7b
--- /dev/null
+++ b/Marlin/src/module/configuration_store.cpp
@@ -0,0 +1,1823 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * configuration_store.cpp
+ *
+ * Settings and EEPROM storage
+ *
+ * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
+ * in the functions below, also increment the version number. This makes sure that
+ * the default values are used whenever there is a change to the data, to prevent
+ * wrong data being written to the variables.
+ *
+ * ALSO: Variables in the Store and Retrieve sections must be in the same order.
+ *       If a feature is disabled, some data must still be written that, when read,
+ *       either sets a Sane Default, or results in No Change to the existing value.
+ *
+ */
+
+#define EEPROM_VERSION "V40"
+
+// Change EEPROM version if these are changed:
+#define EEPROM_OFFSET 100
+
+/**
+ * V39 EEPROM Layout:
+ *
+ *  100  Version                                    (char x4)
+ *  104  EEPROM CRC16                               (uint16_t)
+ *
+ *  106            E_STEPPERS                       (uint8_t)
+ *  107  M92 XYZE  planner.axis_steps_per_mm        (float x4 ... x8)
+ *  123  M203 XYZE planner.max_feedrate_mm_s        (float x4 ... x8)
+ *  139  M201 XYZE planner.max_acceleration_mm_per_s2 (uint32_t x4 ... x8)
+ *  155  M204 P    planner.acceleration             (float)
+ *  159  M204 R    planner.retract_acceleration     (float)
+ *  163  M204 T    planner.travel_acceleration      (float)
+ *  167  M205 S    planner.min_feedrate_mm_s        (float)
+ *  171  M205 T    planner.min_travel_feedrate_mm_s (float)
+ *  175  M205 B    planner.min_segment_time         (ulong)
+ *  179  M205 X    planner.max_jerk[X_AXIS]         (float)
+ *  183  M205 Y    planner.max_jerk[Y_AXIS]         (float)
+ *  187  M205 Z    planner.max_jerk[Z_AXIS]         (float)
+ *  191  M205 E    planner.max_jerk[E_AXIS]         (float)
+ *  195  M206 XYZ  home_offset                      (float x3)
+ *  207  M218 XYZ  hotend_offset                    (float x3 per additional hotend)
+ *
+ * Global Leveling:
+ *  219            z_fade_height                    (float)
+ *
+ * MESH_BED_LEVELING:                               43 bytes
+ *  223  M420 S    from mbl.status                  (bool)
+ *  224            mbl.z_offset                     (float)
+ *  228            GRID_MAX_POINTS_X                (uint8_t)
+ *  229            GRID_MAX_POINTS_Y                (uint8_t)
+ *  230 G29 S3 XYZ z_values[][]                     (float x9, up to float x81) +288
+ *
+ * HAS_BED_PROBE:                                   4 bytes
+ *  266  M851      zprobe_zoffset                   (float)
+ *
+ * ABL_PLANAR:                                      36 bytes
+ *  270            planner.bed_level_matrix         (matrix_3x3 = float x9)
+ *
+ * AUTO_BED_LEVELING_BILINEAR:                      47 bytes
+ *  306            GRID_MAX_POINTS_X                (uint8_t)
+ *  307            GRID_MAX_POINTS_Y                (uint8_t)
+ *  308            bilinear_grid_spacing            (int x2)
+ *  312  G29 L F   bilinear_start                   (int x2)
+ *  316            z_values[][]                     (float x9, up to float x256) +988
+ *
+ * AUTO_BED_LEVELING_UBL:                           6 bytes
+ *  324  G29 A     ubl.state.active                 (bool)
+ *  325  G29 Z     ubl.state.z_offset               (float)
+ *  329  G29 S     ubl.state.storage_slot           (int8_t)
+ *
+ * DELTA:                                           48 bytes
+ *  348  M666 XYZ  endstop_adj                      (float x3)
+ *  360  M665 R    delta_radius                     (float)
+ *  364  M665 L    delta_diagonal_rod               (float)
+ *  368  M665 S    delta_segments_per_second        (float)
+ *  372  M665 B    delta_calibration_radius         (float)
+ *  376  M665 X    delta_tower_angle_trim[A]        (float)
+ *  380  M665 Y    delta_tower_angle_trim[B]        (float)
+ *  ---  M665 Z    delta_tower_angle_trim[C]        (float) is always 0.0
+ *
+ * Z_DUAL_ENDSTOPS:                                 48 bytes
+ *  348  M666 Z    z_endstop_adj                    (float)
+ *  ---            dummy data                       (float x11)
+ *
+ * ULTIPANEL:                                       6 bytes
+ *  396  M145 S0 H lcd_preheat_hotend_temp          (int x2)
+ *  400  M145 S0 B lcd_preheat_bed_temp             (int x2)
+ *  404  M145 S0 F lcd_preheat_fan_speed            (int x2)
+ *
+ * PIDTEMP:                                         66 bytes
+ *  408  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]   (float x4)
+ *  424  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]   (float x4)
+ *  440  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]   (float x4)
+ *  456  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  472  M301 E4 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]   (float x4)
+ *  488  M301 L        lpq_len                      (int)
+ *
+ * PIDTEMPBED:                                      12 bytes
+ *  490  M304 PID  thermalManager.bedKp, .bedKi, .bedKd (float x3)
+ *
+ * DOGLCD:                                          2 bytes
+ *  502  M250 C    lcd_contrast                     (uint16_t)
+ *
+ * FWRETRACT:                                       33 bytes
+ *  504  M209 S    autoretract_enabled              (bool)
+ *  505  M207 S    retract_length                   (float)
+ *  509  M207 F    retract_feedrate_mm_s            (float)
+ *  513  M207 Z    retract_zlift                    (float)
+ *  517  M208 S    retract_recover_length           (float)
+ *  521  M208 F    retract_recover_feedrate_mm_s    (float)
+ *  525  M207 W    swap_retract_length              (float)
+ *  529  M208 W    swap_retract_recover_length      (float)
+ *  533  M208 R    swap_retract_recover_feedrate_mm_s (float)
+ *
+ * Volumetric Extrusion:                            21 bytes
+ *  537  M200 D    volumetric_enabled               (bool)
+ *  538  M200 T D  filament_size                    (float x5) (T0..3)
+ *
+ * HAVE_TMC2130:                                    20 bytes
+ *  558  M906 X    Stepper X current                (uint16_t)
+ *  560  M906 Y    Stepper Y current                (uint16_t)
+ *  562  M906 Z    Stepper Z current                (uint16_t)
+ *  564  M906 X2   Stepper X2 current               (uint16_t)
+ *  566  M906 Y2   Stepper Y2 current               (uint16_t)
+ *  568  M906 Z2   Stepper Z2 current               (uint16_t)
+ *  570  M906 E0   Stepper E0 current               (uint16_t)
+ *  572  M906 E1   Stepper E1 current               (uint16_t)
+ *  574  M906 E2   Stepper E2 current               (uint16_t)
+ *  576  M906 E3   Stepper E3 current               (uint16_t)
+ *  580  M906 E4   Stepper E4 current               (uint16_t)
+ *
+ * LIN_ADVANCE:                                     8 bytes
+ *  584  M900 K    extruder_advance_k               (float)
+ *  588  M900 WHD  advance_ed_ratio                 (float)
+ *
+ * HAS_MOTOR_CURRENT_PWM:
+ *  592  M907 X    Stepper XY current               (uint32_t)
+ *  596  M907 Z    Stepper Z current                (uint32_t)
+ *  600  M907 E    Stepper E current                (uint32_t)
+ *
+ *  604                                Minimum end-point
+ * 1925 (604 + 36 + 9 + 288 + 988)     Maximum end-point
+ *
+ * ========================================================================
+ * meshes_begin (between max and min end-point, directly above)
+ * -- MESHES --
+ * meshes_end
+ * -- MAT (Mesh Allocation Table) --                128 bytes (placeholder size)
+ * mat_end = E2END (0xFFF)
+ *
+ */
+#include "configuration_store.h"
+
+MarlinSettings settings;
+
+#include "Marlin.h"
+#include "language.h"
+#include "endstops.h"
+#include "planner.h"
+#include "temperature.h"
+#include "ultralcd.h"
+#include "stepper.h"
+
+#if ENABLED(INCH_MODE_SUPPORT) || (ENABLED(ULTIPANEL) && ENABLED(TEMPERATURE_UNITS_SUPPORT))
+  #include "gcode.h"
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
+  #include "mesh_bed_leveling.h"
+#endif
+
+#if ENABLED(HAVE_TMC2130)
+  #include "stepper_indirection.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "ubl.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  extern void refresh_bed_level();
+#endif
+
+/**
+ * Post-process after Retrieve or Reset
+ */
+void MarlinSettings::postprocess() {
+  // steps per s2 needs to be updated to agree with units per s2
+  planner.reset_acceleration_rates();
+
+  // Make sure delta kinematics are updated before refreshing the
+  // planner position so the stepper counts will be set correctly.
+  #if ENABLED(DELTA)
+    recalc_delta_settings(delta_radius, delta_diagonal_rod);
+  #endif
+
+  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
+  // and init stepper.count[], planner.position[] with current_position
+  planner.refresh_positioning();
+
+  #if ENABLED(PIDTEMP)
+    thermalManager.updatePID();
+  #endif
+
+  calculate_volumetric_multipliers();
+
+  #if HAS_HOME_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+    // Software endstops depend on home_offset
+    LOOP_XYZ(i) update_software_endstops((AxisEnum)i);
+  #endif
+
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    set_z_fade_height(planner.z_fade_height);
+  #endif
+
+  #if HAS_BED_PROBE
+    refresh_zprobe_zoffset();
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    refresh_bed_level();
+    //set_bed_leveling_enabled(leveling_is_on);
+  #endif
+
+  #if HAS_MOTOR_CURRENT_PWM
+    stepper.refresh_motor_power();
+  #endif
+}
+
+#if ENABLED(EEPROM_SETTINGS)
+  #include "src/HAL/persistent_store_api.h"
+
+  #define DUMMY_PID_VALUE 3000.0f
+  #define EEPROM_START() int eeprom_index = EEPROM_OFFSET; HAL::PersistentStore::access_start()
+  #define EEPROM_FINISH() HAL::PersistentStore::access_finish()
+  #define EEPROM_SKIP(VAR) eeprom_index += sizeof(VAR)
+  #define EEPROM_WRITE(VAR) HAL::PersistentStore::write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
+  #define EEPROM_READ(VAR) HAL::PersistentStore::read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc)
+  #define EEPROM_ASSERT(TST,ERR) if (!(TST)) do{ SERIAL_ERROR_START(); SERIAL_ERRORLNPGM(ERR); eeprom_read_error = true; }while(0)
+
+  const char version[4] = EEPROM_VERSION;
+
+  bool MarlinSettings::eeprom_error;
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    int MarlinSettings::meshes_begin;
+  #endif
+
+  /**
+   * M500 - Store Configuration
+   */
+  bool MarlinSettings::save() {
+    float dummy = 0.0f;
+    char ver[4] = "000";
+
+    uint16_t working_crc = 0;
+
+    EEPROM_START();
+
+    eeprom_error = false;
+
+    EEPROM_WRITE(ver);     // invalidate data first
+    EEPROM_SKIP(working_crc); // Skip the checksum slot
+
+    working_crc = 0; // clear before first "real data"
+
+    const uint8_t esteppers = COUNT(planner.axis_steps_per_mm) - XYZ;
+    EEPROM_WRITE(esteppers);
+
+    EEPROM_WRITE(planner.axis_steps_per_mm);
+    EEPROM_WRITE(planner.max_feedrate_mm_s);
+    EEPROM_WRITE(planner.max_acceleration_mm_per_s2);
+
+    EEPROM_WRITE(planner.acceleration);
+    EEPROM_WRITE(planner.retract_acceleration);
+    EEPROM_WRITE(planner.travel_acceleration);
+    EEPROM_WRITE(planner.min_feedrate_mm_s);
+    EEPROM_WRITE(planner.min_travel_feedrate_mm_s);
+    EEPROM_WRITE(planner.min_segment_time);
+    EEPROM_WRITE(planner.max_jerk);
+    #if !HAS_HOME_OFFSET
+      const float home_offset[XYZ] = { 0 };
+    #endif
+    #if ENABLED(DELTA)
+      dummy = 0.0;
+      EEPROM_WRITE(dummy);
+      EEPROM_WRITE(dummy);
+      dummy = DELTA_HEIGHT + home_offset[Z_AXIS];
+      EEPROM_WRITE(dummy);
+    #else
+      EEPROM_WRITE(home_offset);
+    #endif
+
+    #if HOTENDS > 1
+      // Skip hotend 0 which must be 0
+      for (uint8_t e = 1; e < HOTENDS; e++)
+        LOOP_XYZ(i) EEPROM_WRITE(hotend_offset[i][e]);
+    #endif
+
+    //
+    // Global Leveling
+    //
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      const float zfh = planner.z_fade_height;
+    #else
+      const float zfh = 10.0;
+    #endif
+    EEPROM_WRITE(zfh);
+
+    //
+    // Mesh Bed Leveling
+    //
+
+    #if ENABLED(MESH_BED_LEVELING)
+      // Compile time test that sizeof(mbl.z_values) is as expected
+      static_assert(
+        sizeof(mbl.z_values) == GRID_MAX_POINTS * sizeof(mbl.z_values[0][0]),
+        "MBL Z array is the wrong size."
+      );
+      const bool leveling_is_on = TEST(mbl.status, MBL_STATUS_HAS_MESH_BIT);
+      const uint8_t mesh_num_x = GRID_MAX_POINTS_X, mesh_num_y = GRID_MAX_POINTS_Y;
+      EEPROM_WRITE(leveling_is_on);
+      EEPROM_WRITE(mbl.z_offset);
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+      EEPROM_WRITE(mbl.z_values);
+    #else // For disabled MBL write a default mesh
+      const bool leveling_is_on = false;
+      dummy = 0.0f;
+      const uint8_t mesh_num_x = 3, mesh_num_y = 3;
+      EEPROM_WRITE(leveling_is_on);
+      EEPROM_WRITE(dummy); // z_offset
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+      for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummy);
+    #endif // MESH_BED_LEVELING
+
+    #if !HAS_BED_PROBE
+      const float zprobe_zoffset = 0;
+    #endif
+    EEPROM_WRITE(zprobe_zoffset);
+
+    //
+    // Planar Bed Leveling matrix
+    //
+
+    #if ABL_PLANAR
+      EEPROM_WRITE(planner.bed_level_matrix);
+    #else
+      dummy = 0.0;
+      for (uint8_t q = 9; q--;) EEPROM_WRITE(dummy);
+    #endif
+
+    //
+    // Bilinear Auto Bed Leveling
+    //
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      // Compile time test that sizeof(z_values) is as expected
+      static_assert(
+        sizeof(z_values) == GRID_MAX_POINTS * sizeof(z_values[0][0]),
+        "Bilinear Z array is the wrong size."
+      );
+      const uint8_t grid_max_x = GRID_MAX_POINTS_X, grid_max_y = GRID_MAX_POINTS_Y;
+      EEPROM_WRITE(grid_max_x);            // 1 byte
+      EEPROM_WRITE(grid_max_y);            // 1 byte
+      EEPROM_WRITE(bilinear_grid_spacing); // 2 ints
+      EEPROM_WRITE(bilinear_start);        // 2 ints
+      EEPROM_WRITE(z_values);              // 9-256 floats
+    #else
+      // For disabled Bilinear Grid write an empty 3x3 grid
+      const uint8_t grid_max_x = 3, grid_max_y = 3;
+      const int bilinear_start[2] = { 0 }, bilinear_grid_spacing[2] = { 0 };
+      dummy = 0.0f;
+      EEPROM_WRITE(grid_max_x);
+      EEPROM_WRITE(grid_max_y);
+      EEPROM_WRITE(bilinear_grid_spacing);
+      EEPROM_WRITE(bilinear_start);
+      for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummy);
+    #endif // AUTO_BED_LEVELING_BILINEAR
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      EEPROM_WRITE(ubl.state.active);
+      EEPROM_WRITE(ubl.state.z_offset);
+      EEPROM_WRITE(ubl.state.storage_slot);
+    #else
+      const bool ubl_active = false;
+      dummy = 0.0f;
+      const int8_t storage_slot = -1;
+      EEPROM_WRITE(ubl_active);
+      EEPROM_WRITE(dummy);
+      EEPROM_WRITE(storage_slot);
+    #endif // AUTO_BED_LEVELING_UBL
+
+    // 9 floats for DELTA / Z_DUAL_ENDSTOPS
+    #if ENABLED(DELTA)
+      EEPROM_WRITE(endstop_adj);               // 3 floats
+      EEPROM_WRITE(delta_radius);              // 1 float
+      EEPROM_WRITE(delta_diagonal_rod);        // 1 float
+      EEPROM_WRITE(delta_segments_per_second); // 1 float
+      EEPROM_WRITE(delta_calibration_radius);  // 1 float
+      EEPROM_WRITE(delta_tower_angle_trim);    // 2 floats
+      dummy = 0.0f;
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
+    #elif ENABLED(Z_DUAL_ENDSTOPS)
+      EEPROM_WRITE(z_endstop_adj);             // 1 float
+      dummy = 0.0f;
+      for (uint8_t q = 11; q--;) EEPROM_WRITE(dummy);
+    #else
+      dummy = 0.0f;
+      for (uint8_t q = 12; q--;) EEPROM_WRITE(dummy);
+    #endif
+
+    #if DISABLED(ULTIPANEL)
+      constexpr int lcd_preheat_hotend_temp[2] = { PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND },
+                    lcd_preheat_bed_temp[2] = { PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED },
+                    lcd_preheat_fan_speed[2] = { PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED };
+    #endif
+
+    EEPROM_WRITE(lcd_preheat_hotend_temp);
+    EEPROM_WRITE(lcd_preheat_bed_temp);
+    EEPROM_WRITE(lcd_preheat_fan_speed);
+
+    for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
+
+      #if ENABLED(PIDTEMP)
+        if (e < HOTENDS) {
+          EEPROM_WRITE(PID_PARAM(Kp, e));
+          EEPROM_WRITE(PID_PARAM(Ki, e));
+          EEPROM_WRITE(PID_PARAM(Kd, e));
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            EEPROM_WRITE(PID_PARAM(Kc, e));
+          #else
+            dummy = 1.0f; // 1.0 = default kc
+            EEPROM_WRITE(dummy);
+          #endif
+        }
+        else
+      #endif // !PIDTEMP
+        {
+          dummy = DUMMY_PID_VALUE; // When read, will not change the existing value
+          EEPROM_WRITE(dummy); // Kp
+          dummy = 0.0f;
+          for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy); // Ki, Kd, Kc
+        }
+
+    } // Hotends Loop
+
+    #if DISABLED(PID_EXTRUSION_SCALING)
+      int lpq_len = 20;
+    #endif
+    EEPROM_WRITE(lpq_len);
+
+    #if DISABLED(PIDTEMPBED)
+      dummy = DUMMY_PID_VALUE;
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummy);
+    #else
+      EEPROM_WRITE(thermalManager.bedKp);
+      EEPROM_WRITE(thermalManager.bedKi);
+      EEPROM_WRITE(thermalManager.bedKd);
+    #endif
+
+    #if !HAS_LCD_CONTRAST
+      const uint16_t lcd_contrast = 32;
+    #endif
+    EEPROM_WRITE(lcd_contrast);
+
+    #if DISABLED(FWRETRACT)
+      const bool autoretract_enabled = false;
+      const float retract_length = 3,
+                  retract_feedrate_mm_s = 45,
+                  retract_zlift = 0,
+                  retract_recover_length = 0,
+                  retract_recover_feedrate_mm_s = 0,
+                  swap_retract_length = 13,
+                  swap_retract_recover_length = 0,
+                  swap_retract_recover_feedrate_mm_s = 8;
+    #endif
+    EEPROM_WRITE(autoretract_enabled);
+    EEPROM_WRITE(retract_length);
+    EEPROM_WRITE(retract_feedrate_mm_s);
+    EEPROM_WRITE(retract_zlift);
+    EEPROM_WRITE(retract_recover_length);
+    EEPROM_WRITE(retract_recover_feedrate_mm_s);
+    EEPROM_WRITE(swap_retract_length);
+    EEPROM_WRITE(swap_retract_recover_length);
+    EEPROM_WRITE(swap_retract_recover_feedrate_mm_s);
+
+    EEPROM_WRITE(volumetric_enabled);
+
+    // Save filament sizes
+    for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+      if (q < COUNT(filament_size)) dummy = filament_size[q];
+      EEPROM_WRITE(dummy);
+    }
+
+    // Save TMC2130 Configuration, and placeholder values
+    uint16_t val;
+    #if ENABLED(HAVE_TMC2130)
+      #if ENABLED(X_IS_TMC2130)
+        val = stepperX.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(Y_IS_TMC2130)
+        val = stepperY.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(Z_IS_TMC2130)
+        val = stepperZ.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(X2_IS_TMC2130)
+        val = stepperX2.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(Y2_IS_TMC2130)
+        val = stepperY2.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(Z2_IS_TMC2130)
+        val = stepperZ2.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(E0_IS_TMC2130)
+        val = stepperE0.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(E1_IS_TMC2130)
+        val = stepperE1.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(E2_IS_TMC2130)
+        val = stepperE2.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(E3_IS_TMC2130)
+        val = stepperE3.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+      #if ENABLED(E4_IS_TMC2130)
+        val = stepperE4.getCurrent();
+      #else
+        val = 0;
+      #endif
+      EEPROM_WRITE(val);
+    #else
+      val = 0;
+      for (uint8_t q = 11; q--;) EEPROM_WRITE(val);
+    #endif
+
+    //
+    // Linear Advance
+    //
+
+    #if ENABLED(LIN_ADVANCE)
+      EEPROM_WRITE(planner.extruder_advance_k);
+      EEPROM_WRITE(planner.advance_ed_ratio);
+    #else
+      dummy = 0.0f;
+      EEPROM_WRITE(dummy);
+      EEPROM_WRITE(dummy);
+    #endif
+
+    #if HAS_MOTOR_CURRENT_PWM
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(stepper.motor_current_setting[q]);
+    #else
+      const uint32_t dummyui32 = 0;
+      for (uint8_t q = 3; q--;) EEPROM_WRITE(dummyui32);
+    #endif
+
+    if (!eeprom_error) {
+      const int eeprom_size = eeprom_index;
+
+      const uint16_t final_crc = working_crc;
+
+      // Write the EEPROM header
+      eeprom_index = EEPROM_OFFSET;
+
+      EEPROM_WRITE(version);
+      EEPROM_WRITE(final_crc);
+
+      // Report storage size
+      #if ENABLED(EEPROM_CHITCHAT)
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPAIR("Settings Stored (", eeprom_size - (EEPROM_OFFSET));
+        SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)final_crc);
+        SERIAL_ECHOLNPGM(")");
+      #endif
+    }
+
+    #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
+      if (ubl.state.storage_slot >= 0)
+        store_mesh(ubl.state.storage_slot);
+    #endif
+    EEPROM_FINISH();
+    return !eeprom_error;
+  }
+
+  /**
+   * M501 - Retrieve Configuration
+   */
+  bool MarlinSettings::load() {
+    uint16_t working_crc = 0;
+
+    EEPROM_START();
+
+    char stored_ver[4];
+    EEPROM_READ(stored_ver);
+
+    uint16_t stored_crc;
+    EEPROM_READ(stored_crc);
+
+    // Version has to match or defaults are used
+    if (strncmp(version, stored_ver, 3) != 0) {
+      if (stored_ver[0] != 'V') {
+        stored_ver[0] = '?';
+        stored_ver[1] = '\0';
+      }
+      #if ENABLED(EEPROM_CHITCHAT)
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPGM("EEPROM version mismatch ");
+        SERIAL_ECHOPAIR("(EEPROM=", stored_ver);
+        SERIAL_ECHOLNPGM(" Marlin=" EEPROM_VERSION ")");
+      #endif
+      reset();
+    }
+    else {
+      float dummy = 0;
+      bool dummyb;
+
+      working_crc = 0; //clear before reading first "real data"
+
+      // Number of esteppers may change
+      uint8_t esteppers;
+      EEPROM_READ(esteppers);
+
+      // Get only the number of E stepper parameters previously stored
+      // Any steppers added later are set to their defaults
+      const float def1[] = DEFAULT_AXIS_STEPS_PER_UNIT, def2[] = DEFAULT_MAX_FEEDRATE;
+      const uint32_t def3[] = DEFAULT_MAX_ACCELERATION;
+      float tmp1[XYZ + esteppers], tmp2[XYZ + esteppers];
+      uint32_t tmp3[XYZ + esteppers];
+      EEPROM_READ(tmp1);
+      EEPROM_READ(tmp2);
+      EEPROM_READ(tmp3);
+      LOOP_XYZE_N(i) {
+        planner.axis_steps_per_mm[i]          = i < XYZ + esteppers ? tmp1[i] : def1[i < COUNT(def1) ? i : COUNT(def1) - 1];
+        planner.max_feedrate_mm_s[i]          = i < XYZ + esteppers ? tmp2[i] : def2[i < COUNT(def2) ? i : COUNT(def2) - 1];
+        planner.max_acceleration_mm_per_s2[i] = i < XYZ + esteppers ? tmp3[i] : def3[i < COUNT(def3) ? i : COUNT(def3) - 1];
+      }
+
+      EEPROM_READ(planner.acceleration);
+      EEPROM_READ(planner.retract_acceleration);
+      EEPROM_READ(planner.travel_acceleration);
+      EEPROM_READ(planner.min_feedrate_mm_s);
+      EEPROM_READ(planner.min_travel_feedrate_mm_s);
+      EEPROM_READ(planner.min_segment_time);
+      EEPROM_READ(planner.max_jerk);
+
+      #if !HAS_HOME_OFFSET
+        float home_offset[XYZ];
+      #endif
+      EEPROM_READ(home_offset);
+
+      #if ENABLED(DELTA)
+        home_offset[X_AXIS] = 0.0;
+        home_offset[Y_AXIS] = 0.0;
+        home_offset[Z_AXIS] -= DELTA_HEIGHT;
+      #endif
+
+      #if HOTENDS > 1
+        // Skip hotend 0 which must be 0
+        for (uint8_t e = 1; e < HOTENDS; e++)
+          LOOP_XYZ(i) EEPROM_READ(hotend_offset[i][e]);
+      #endif
+
+      //
+      // Global Leveling
+      //
+
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        EEPROM_READ(planner.z_fade_height);
+      #else
+        EEPROM_READ(dummy);
+      #endif
+
+      //
+      // Mesh (Manual) Bed Leveling
+      //
+
+      bool leveling_is_on;
+      uint8_t mesh_num_x, mesh_num_y;
+      EEPROM_READ(leveling_is_on);
+      EEPROM_READ(dummy);
+      EEPROM_READ(mesh_num_x);
+      EEPROM_READ(mesh_num_y);
+
+      #if ENABLED(MESH_BED_LEVELING)
+        mbl.status = leveling_is_on ? _BV(MBL_STATUS_HAS_MESH_BIT) : 0;
+        mbl.z_offset = dummy;
+        if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
+          // EEPROM data fits the current mesh
+          EEPROM_READ(mbl.z_values);
+        }
+        else {
+          // EEPROM data is stale
+          mbl.reset();
+          for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
+        }
+      #else
+        // MBL is disabled - skip the stored data
+        for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummy);
+      #endif // MESH_BED_LEVELING
+
+      #if !HAS_BED_PROBE
+        float zprobe_zoffset;
+      #endif
+      EEPROM_READ(zprobe_zoffset);
+
+      //
+      // Planar Bed Leveling matrix
+      //
+
+      #if ABL_PLANAR
+        EEPROM_READ(planner.bed_level_matrix);
+      #else
+        for (uint8_t q = 9; q--;) EEPROM_READ(dummy);
+      #endif
+
+      //
+      // Bilinear Auto Bed Leveling
+      //
+
+      uint8_t grid_max_x, grid_max_y;
+      EEPROM_READ(grid_max_x);                       // 1 byte
+      EEPROM_READ(grid_max_y);                       // 1 byte
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
+          set_bed_leveling_enabled(false);
+          EEPROM_READ(bilinear_grid_spacing);        // 2 ints
+          EEPROM_READ(bilinear_start);               // 2 ints
+          EEPROM_READ(z_values);                     // 9 to 256 floats
+        }
+        else // EEPROM data is stale
+      #endif // AUTO_BED_LEVELING_BILINEAR
+        {
+          // Skip past disabled (or stale) Bilinear Grid data
+          int bgs[2], bs[2];
+          EEPROM_READ(bgs);
+          EEPROM_READ(bs);
+          for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummy);
+        }
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        EEPROM_READ(ubl.state.active);
+        EEPROM_READ(ubl.state.z_offset);
+        EEPROM_READ(ubl.state.storage_slot);
+      #else
+        uint8_t dummyui8;
+        EEPROM_READ(dummyb);
+        EEPROM_READ(dummy);
+        EEPROM_READ(dummyui8);
+      #endif // AUTO_BED_LEVELING_UBL
+
+      #if ENABLED(DELTA)
+        EEPROM_READ(endstop_adj);               // 3 floats
+        EEPROM_READ(delta_radius);              // 1 float
+        EEPROM_READ(delta_diagonal_rod);        // 1 float
+        EEPROM_READ(delta_segments_per_second); // 1 float
+        EEPROM_READ(delta_calibration_radius);  // 1 float
+        EEPROM_READ(delta_tower_angle_trim);    // 2 floats
+        dummy = 0.0f;
+        for (uint8_t q=3; q--;) EEPROM_READ(dummy);
+      #elif ENABLED(Z_DUAL_ENDSTOPS)
+        EEPROM_READ(z_endstop_adj);
+        dummy = 0.0f;
+        for (uint8_t q=11; q--;) EEPROM_READ(dummy);
+      #else
+        dummy = 0.0f;
+        for (uint8_t q=12; q--;) EEPROM_READ(dummy);
+      #endif
+
+      #if DISABLED(ULTIPANEL)
+        int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+      #endif
+
+      EEPROM_READ(lcd_preheat_hotend_temp);
+      EEPROM_READ(lcd_preheat_bed_temp);
+      EEPROM_READ(lcd_preheat_fan_speed);
+
+      //EEPROM_ASSERT(
+      //  WITHIN(lcd_preheat_fan_speed, 0, 255),
+      //  "lcd_preheat_fan_speed out of range"
+      //);
+
+      #if ENABLED(PIDTEMP)
+        for (uint8_t e = 0; e < MAX_EXTRUDERS; e++) {
+          EEPROM_READ(dummy); // Kp
+          if (e < HOTENDS && dummy != DUMMY_PID_VALUE) {
+            // do not need to scale PID values as the values in EEPROM are already scaled
+            PID_PARAM(Kp, e) = dummy;
+            EEPROM_READ(PID_PARAM(Ki, e));
+            EEPROM_READ(PID_PARAM(Kd, e));
+            #if ENABLED(PID_EXTRUSION_SCALING)
+              EEPROM_READ(PID_PARAM(Kc, e));
+            #else
+              EEPROM_READ(dummy);
+            #endif
+          }
+          else {
+            for (uint8_t q=3; q--;) EEPROM_READ(dummy); // Ki, Kd, Kc
+          }
+        }
+      #else // !PIDTEMP
+        // 4 x 4 = 16 slots for PID parameters
+        for (uint8_t q = MAX_EXTRUDERS * 4; q--;) EEPROM_READ(dummy);  // Kp, Ki, Kd, Kc
+      #endif // !PIDTEMP
+
+      #if DISABLED(PID_EXTRUSION_SCALING)
+        int lpq_len;
+      #endif
+      EEPROM_READ(lpq_len);
+
+      #if ENABLED(PIDTEMPBED)
+        EEPROM_READ(dummy); // bedKp
+        if (dummy != DUMMY_PID_VALUE) {
+          thermalManager.bedKp = dummy;
+          EEPROM_READ(thermalManager.bedKi);
+          EEPROM_READ(thermalManager.bedKd);
+        }
+      #else
+        for (uint8_t q=3; q--;) EEPROM_READ(dummy); // bedKp, bedKi, bedKd
+      #endif
+
+      #if !HAS_LCD_CONTRAST
+        uint16_t lcd_contrast;
+      #endif
+      EEPROM_READ(lcd_contrast);
+
+      #if ENABLED(FWRETRACT)
+        EEPROM_READ(autoretract_enabled);
+        EEPROM_READ(retract_length);
+        EEPROM_READ(retract_feedrate_mm_s);
+        EEPROM_READ(retract_zlift);
+        EEPROM_READ(retract_recover_length);
+        EEPROM_READ(retract_recover_feedrate_mm_s);
+        EEPROM_READ(swap_retract_length);
+        EEPROM_READ(swap_retract_recover_length);
+        EEPROM_READ(swap_retract_recover_feedrate_mm_s);
+      #else
+        EEPROM_READ(dummyb);
+        for (uint8_t q=8; q--;) EEPROM_READ(dummy);
+      #endif
+
+      EEPROM_READ(volumetric_enabled);
+
+      for (uint8_t q = 0; q < MAX_EXTRUDERS; q++) {
+        EEPROM_READ(dummy);
+        if (q < COUNT(filament_size)) filament_size[q] = dummy;
+      }
+
+      uint16_t val;
+      #if ENABLED(HAVE_TMC2130)
+        EEPROM_READ(val);
+        #if ENABLED(X_IS_TMC2130)
+          stepperX.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(Y_IS_TMC2130)
+          stepperY.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(Z_IS_TMC2130)
+          stepperZ.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(X2_IS_TMC2130)
+          stepperX2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(Y2_IS_TMC2130)
+          stepperY2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(Z2_IS_TMC2130)
+          stepperZ2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(E0_IS_TMC2130)
+          stepperE0.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(E1_IS_TMC2130)
+          stepperE1.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(E2_IS_TMC2130)
+          stepperE2.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(E3_IS_TMC2130)
+          stepperE3.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+        EEPROM_READ(val);
+        #if ENABLED(E4_IS_TMC2130)
+          stepperE4.setCurrent(val, R_SENSE, HOLD_MULTIPLIER);
+        #endif
+      #else
+        for (uint8_t q = 0; q < 11; q++) EEPROM_READ(val);
+      #endif
+
+      //
+      // Linear Advance
+      //
+
+      #if ENABLED(LIN_ADVANCE)
+        EEPROM_READ(planner.extruder_advance_k);
+        EEPROM_READ(planner.advance_ed_ratio);
+      #else
+        EEPROM_READ(dummy);
+        EEPROM_READ(dummy);
+      #endif
+
+      #if HAS_MOTOR_CURRENT_PWM
+        for (uint8_t q = 3; q--;) EEPROM_READ(stepper.motor_current_setting[q]);
+      #else
+        uint32_t dummyui32;
+        for (uint8_t q = 3; q--;) EEPROM_READ(dummyui32);
+      #endif
+
+      if (working_crc == stored_crc) {
+        postprocess();
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_ECHO_START();
+          SERIAL_ECHO(version);
+          SERIAL_ECHOPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET));
+          SERIAL_ECHOPAIR(" bytes; crc ", (uint32_t)working_crc);
+          SERIAL_ECHOLNPGM(")");
+        #endif
+      }
+      else {
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_ERROR_START();
+          SERIAL_ERRORPGM("EEPROM CRC mismatch - (stored) ");
+          SERIAL_ERROR(stored_crc);
+          SERIAL_ERRORPGM(" != ");
+          SERIAL_ERROR(working_crc);
+          SERIAL_ERRORLNPGM(" (calculated)!");
+        #endif
+        reset();
+      }
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        meshes_begin = (eeprom_index + 32) & 0xFFF8;  // Pad the end of configuration data so it
+                                                      // can float up or down a little bit without
+                                                      // disrupting the mesh data
+        ubl.report_state();
+
+        if (!ubl.sanity_check()) {
+          SERIAL_EOL();
+          #if ENABLED(EEPROM_CHITCHAT)
+            ubl.echo_name();
+            SERIAL_ECHOLNPGM(" initialized.\n");
+          #endif
+        }
+        else {
+          #if ENABLED(EEPROM_CHITCHAT)
+            SERIAL_PROTOCOLPGM("?Can't enable ");
+            ubl.echo_name();
+            SERIAL_PROTOCOLLNPGM(".");
+          #endif
+          ubl.reset();
+        }
+
+        if (ubl.state.storage_slot >= 0) {
+          load_mesh(ubl.state.storage_slot);
+          #if ENABLED(EEPROM_CHITCHAT)
+            SERIAL_ECHOPAIR("Mesh ", ubl.state.storage_slot);
+            SERIAL_ECHOLNPGM(" loaded from storage.");
+          #endif
+        }
+        else {
+          ubl.reset();
+          #if ENABLED(EEPROM_CHITCHAT)
+            SERIAL_ECHOLNPGM("UBL System reset()");
+          #endif
+        }
+      #endif
+    }
+
+    #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
+      report();
+    #endif
+    EEPROM_FINISH();
+
+    return !eeprom_error;
+  }
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    #if ENABLED(EEPROM_CHITCHAT)
+      void ubl_invalid_slot(const int s) {
+        SERIAL_PROTOCOLLNPGM("?Invalid slot.");
+        SERIAL_PROTOCOL(s);
+        SERIAL_PROTOCOLLNPGM(" mesh slots available.");
+      }
+    #endif
+
+    int MarlinSettings::calc_num_meshes() {
+      //obviously this will get more sophisticated once we've added an actual MAT
+
+      if (meshes_begin <= 0) return 0;
+
+      return (meshes_end - meshes_begin) / sizeof(ubl.z_values);
+    }
+
+    void MarlinSettings::store_mesh(int8_t slot) {
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        const int a = calc_num_meshes();
+        if (!WITHIN(slot, 0, a - 1)) {
+          #if ENABLED(EEPROM_CHITCHAT)
+            ubl_invalid_slot(a);
+            SERIAL_PROTOCOLPAIR("E2END=", E2END);
+            SERIAL_PROTOCOLPAIR(" meshes_end=", meshes_end);
+            SERIAL_PROTOCOLLNPAIR(" slot=", slot);
+            SERIAL_EOL();
+          #endif
+          return;
+        }
+
+        uint16_t crc = 0;
+        int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
+
+        HAL::PersistentStore::write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+
+        // Write crc to MAT along with other data, or just tack on to the beginning or end
+
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_PROTOCOLLNPAIR("Mesh saved in slot ", slot);
+        #endif
+
+      #else
+
+        // Other mesh types
+
+      #endif
+    }
+
+    void MarlinSettings::load_mesh(int8_t slot, void *into /* = 0 */) {
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+        const int16_t a = settings.calc_num_meshes();
+
+        if (!WITHIN(slot, 0, a - 1)) {
+          #if ENABLED(EEPROM_CHITCHAT)
+            ubl_invalid_slot(a);
+          #endif
+          return;
+        }
+
+        uint16_t crc = 0;
+        int pos = meshes_end - (slot + 1) * sizeof(ubl.z_values);
+        uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
+        HAL::PersistentStore::read_data(pos, dest, sizeof(ubl.z_values), &crc);
+
+        // Compare crc with crc from MAT, or read from end
+
+        #if ENABLED(EEPROM_CHITCHAT)
+          SERIAL_PROTOCOLLNPAIR("Mesh loaded from slot ", slot);
+        #endif
+
+      #else
+
+        // Other mesh types
+
+      #endif
+    }
+
+    //void MarlinSettings::delete_mesh() { return; }
+    //void MarlinSettings::defrag_meshes() { return; }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+#else // !EEPROM_SETTINGS
+
+  bool MarlinSettings::save() {
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM("EEPROM disabled");
+    return false;
+  }
+
+#endif // !EEPROM_SETTINGS
+
+/**
+ * M502 - Reset Configuration
+ */
+void MarlinSettings::reset() {
+  static const float tmp1[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT, tmp2[] PROGMEM = DEFAULT_MAX_FEEDRATE;
+  static const uint32_t tmp3[] PROGMEM = DEFAULT_MAX_ACCELERATION;
+  LOOP_XYZE_N(i) {
+    planner.axis_steps_per_mm[i]          = pgm_read_float(&tmp1[i < COUNT(tmp1) ? i : COUNT(tmp1) - 1]);
+    planner.max_feedrate_mm_s[i]          = pgm_read_float(&tmp2[i < COUNT(tmp2) ? i : COUNT(tmp2) - 1]);
+    planner.max_acceleration_mm_per_s2[i] = pgm_read_dword_near(&tmp3[i < COUNT(tmp3) ? i : COUNT(tmp3) - 1]);
+  }
+
+  planner.acceleration = DEFAULT_ACCELERATION;
+  planner.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
+  planner.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
+  planner.min_feedrate_mm_s = DEFAULT_MINIMUMFEEDRATE;
+  planner.min_segment_time = DEFAULT_MINSEGMENTTIME;
+  planner.min_travel_feedrate_mm_s = DEFAULT_MINTRAVELFEEDRATE;
+  planner.max_jerk[X_AXIS] = DEFAULT_XJERK;
+  planner.max_jerk[Y_AXIS] = DEFAULT_YJERK;
+  planner.max_jerk[Z_AXIS] = DEFAULT_ZJERK;
+  planner.max_jerk[E_AXIS] = DEFAULT_EJERK;
+
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    planner.z_fade_height = 0.0;
+  #endif
+
+  #if HAS_HOME_OFFSET
+    ZERO(home_offset);
+  #endif
+
+  #if HOTENDS > 1
+    constexpr float tmp4[XYZ][HOTENDS] = {
+      HOTEND_OFFSET_X,
+      HOTEND_OFFSET_Y
+      #ifdef HOTEND_OFFSET_Z
+        , HOTEND_OFFSET_Z
+      #else
+        , { 0 }
+      #endif
+    };
+    static_assert(
+      tmp4[X_AXIS][0] == 0 && tmp4[Y_AXIS][0] == 0 && tmp4[Z_AXIS][0] == 0,
+      "Offsets for the first hotend must be 0.0."
+    );
+    LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp4[i][e];
+  #endif
+
+  // Applies to all MBL and ABL
+  #if HAS_LEVELING
+    reset_bed_level();
+  #endif
+
+  #if HAS_BED_PROBE
+    zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
+  #endif
+
+  #if ENABLED(DELTA)
+    const float adj[ABC] = DELTA_ENDSTOP_ADJ,
+                dta[ABC] = DELTA_TOWER_ANGLE_TRIM;
+    COPY(endstop_adj, adj);
+    delta_radius = DELTA_RADIUS;
+    delta_diagonal_rod = DELTA_DIAGONAL_ROD;
+    delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
+    delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
+    delta_tower_angle_trim[A_AXIS] = dta[A_AXIS] - dta[C_AXIS];
+    delta_tower_angle_trim[B_AXIS] = dta[B_AXIS] - dta[C_AXIS];
+    home_offset[Z_AXIS] = 0;
+
+  #elif ENABLED(Z_DUAL_ENDSTOPS)
+
+    z_endstop_adj =
+      #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
+        Z_DUAL_ENDSTOPS_ADJUSTMENT
+      #else
+        0
+      #endif
+    ;
+
+  #endif
+
+  #if ENABLED(ULTIPANEL)
+    lcd_preheat_hotend_temp[0] = PREHEAT_1_TEMP_HOTEND;
+    lcd_preheat_hotend_temp[1] = PREHEAT_2_TEMP_HOTEND;
+    lcd_preheat_bed_temp[0] = PREHEAT_1_TEMP_BED;
+    lcd_preheat_bed_temp[1] = PREHEAT_2_TEMP_BED;
+    lcd_preheat_fan_speed[0] = PREHEAT_1_FAN_SPEED;
+    lcd_preheat_fan_speed[1] = PREHEAT_2_FAN_SPEED;
+  #endif
+
+  #if HAS_LCD_CONTRAST
+    lcd_contrast = DEFAULT_LCD_CONTRAST;
+  #endif
+
+  #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+      HOTEND_LOOP()
+    #endif
+    {
+      PID_PARAM(Kp, e) = DEFAULT_Kp;
+      PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);
+      PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        PID_PARAM(Kc, e) = DEFAULT_Kc;
+      #endif
+    }
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      lpq_len = 20; // default last-position-queue size
+    #endif
+  #endif // PIDTEMP
+
+  #if ENABLED(PIDTEMPBED)
+    thermalManager.bedKp = DEFAULT_bedKp;
+    thermalManager.bedKi = scalePID_i(DEFAULT_bedKi);
+    thermalManager.bedKd = scalePID_d(DEFAULT_bedKd);
+  #endif
+
+  #if ENABLED(FWRETRACT)
+    autoretract_enabled = false;
+    retract_length = RETRACT_LENGTH;
+    retract_feedrate_mm_s = RETRACT_FEEDRATE;
+    retract_zlift = RETRACT_ZLIFT;
+    retract_recover_length = RETRACT_RECOVER_LENGTH;
+    retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE;
+    swap_retract_length = RETRACT_LENGTH_SWAP;
+    swap_retract_recover_length = RETRACT_RECOVER_LENGTH_SWAP;
+    swap_retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE_SWAP;
+  #endif // FWRETRACT
+
+  volumetric_enabled =
+    #if ENABLED(VOLUMETRIC_DEFAULT_ON)
+      true
+    #else
+      false
+    #endif
+  ;
+  for (uint8_t q = 0; q < COUNT(filament_size); q++)
+    filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+
+  endstops.enable_globally(
+    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
+      true
+    #else
+      false
+    #endif
+  );
+
+  #if ENABLED(HAVE_TMC2130)
+    #if ENABLED(X_IS_TMC2130)
+      stepperX.setCurrent(X_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      stepperY.setCurrent(Y_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      stepperZ.setCurrent(Z_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(X2_IS_TMC2130)
+      stepperX2.setCurrent(X2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(Y2_IS_TMC2130)
+      stepperY2.setCurrent(Y2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(Z2_IS_TMC2130)
+      stepperZ2.setCurrent(Z2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      stepperE0.setCurrent(E0_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(E1_IS_TMC2130)
+      stepperE1.setCurrent(E1_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(E2_IS_TMC2130)
+      stepperE2.setCurrent(E2_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+    #if ENABLED(E3_IS_TMC2130)
+      stepperE3.setCurrent(E3_CURRENT, R_SENSE, HOLD_MULTIPLIER);
+    #endif
+  #endif
+
+  #if ENABLED(LIN_ADVANCE)
+    planner.extruder_advance_k = LIN_ADVANCE_K;
+    planner.advance_ed_ratio = LIN_ADVANCE_E_D_RATIO;
+  #endif
+
+  #if HAS_MOTOR_CURRENT_PWM
+    uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
+    for (uint8_t q = 3; q--;)
+      stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    ubl.reset();
+  #endif
+
+  postprocess();
+
+  #if ENABLED(EEPROM_CHITCHAT)
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPGM("Hardcoded Default Settings Loaded");
+  #endif
+}
+
+#if DISABLED(DISABLE_M503)
+
+  #define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+
+  /**
+   * M503 - Report current settings in RAM
+   *
+   * Unless specifically disabled, M503 is available even without EEPROM
+   */
+  void MarlinSettings::report(bool forReplay) {
+
+    /**
+     * Announce current units, in case inches are being displayed
+     */
+    CONFIG_ECHO_START;
+    #if ENABLED(INCH_MODE_SUPPORT)
+      #define LINEAR_UNIT(N) ((N) / parser.linear_unit_factor)
+      #define VOLUMETRIC_UNIT(N) ((N) / (volumetric_enabled ? parser.volumetric_unit_factor : parser.linear_unit_factor))
+      SERIAL_ECHOPGM("  G2");
+      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
+      SERIAL_ECHOPGM(" ; Units in ");
+      serialprintPGM(parser.linear_unit_factor == 1.0 ? PSTR("mm\n") : PSTR("inches\n"));
+    #else
+      #define LINEAR_UNIT(N) N
+      #define VOLUMETRIC_UNIT(N) N
+      SERIAL_ECHOLNPGM("  G21    ; Units in mm");
+    #endif
+
+    #if ENABLED(ULTIPANEL)
+
+      // Temperature units - for Ultipanel temperature options
+
+      CONFIG_ECHO_START;
+      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+        #define TEMP_UNIT(N) parser.to_temp_units(N)
+        SERIAL_ECHOPGM("  M149 ");
+        SERIAL_CHAR(parser.temp_units_code());
+        SERIAL_ECHOPGM(" ; Units in ");
+        serialprintPGM(parser.temp_units_name());
+      #else
+        #define TEMP_UNIT(N) N
+        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
+      #endif
+
+    #endif
+
+    SERIAL_EOL();
+
+    /**
+     * Volumetric extrusion M200
+     */
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPGM("Filament settings:");
+      if (volumetric_enabled)
+        SERIAL_EOL();
+      else
+        SERIAL_ECHOLNPGM(" Disabled");
+    }
+
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M200 D", filament_size[0]);
+    SERIAL_EOL();
+    #if EXTRUDERS > 1
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M200 T1 D", filament_size[1]);
+      SERIAL_EOL();
+      #if EXTRUDERS > 2
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR("  M200 T2 D", filament_size[2]);
+        SERIAL_EOL();
+        #if EXTRUDERS > 3
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  M200 T3 D", filament_size[3]);
+          SERIAL_EOL();
+          #if EXTRUDERS > 4
+            CONFIG_ECHO_START;
+            SERIAL_ECHOPAIR("  M200 T4 D", filament_size[4]);
+            SERIAL_EOL();
+          #endif // EXTRUDERS > 4
+        #endif // EXTRUDERS > 3
+      #endif // EXTRUDERS > 2
+    #endif // EXTRUDERS > 1
+
+    if (!volumetric_enabled) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("  M200 D0");
+    }
+
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("Steps per unit:");
+    }
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M92 X", LINEAR_UNIT(planner.axis_steps_per_mm[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.axis_steps_per_mm[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.axis_steps_per_mm[Z_AXIS]));
+    #if DISABLED(DISTINCT_E_FACTORS)
+      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS]));
+    #endif
+    SERIAL_EOL();
+    #if ENABLED(DISTINCT_E_FACTORS)
+      CONFIG_ECHO_START;
+      for (uint8_t i = 0; i < E_STEPPERS; i++) {
+        SERIAL_ECHOPAIR("  M92 T", (int)i);
+        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.axis_steps_per_mm[E_AXIS + i]));
+      }
+    #endif
+
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("Maximum feedrates (units/s):");
+    }
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M203 X", LINEAR_UNIT(planner.max_feedrate_mm_s[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_feedrate_mm_s[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_feedrate_mm_s[Z_AXIS]));
+    #if DISABLED(DISTINCT_E_FACTORS)
+      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS]));
+    #endif
+    SERIAL_EOL();
+    #if ENABLED(DISTINCT_E_FACTORS)
+      CONFIG_ECHO_START;
+      for (uint8_t i = 0; i < E_STEPPERS; i++) {
+        SERIAL_ECHOPAIR("  M203 T", (int)i);
+        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.max_feedrate_mm_s[E_AXIS + i]));
+      }
+    #endif
+
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("Maximum Acceleration (units/s2):");
+    }
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M201 X", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_acceleration_mm_per_s2[Z_AXIS]));
+    #if DISABLED(DISTINCT_E_FACTORS)
+      SERIAL_ECHOPAIR(" E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS]));
+    #endif
+    SERIAL_EOL();
+    #if ENABLED(DISTINCT_E_FACTORS)
+      CONFIG_ECHO_START;
+      for (uint8_t i = 0; i < E_STEPPERS; i++) {
+        SERIAL_ECHOPAIR("  M201 T", (int)i);
+        SERIAL_ECHOLNPAIR(" E", VOLUMETRIC_UNIT(planner.max_acceleration_mm_per_s2[E_AXIS + i]));
+      }
+    #endif
+
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
+    }
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M204 P", LINEAR_UNIT(planner.acceleration));
+    SERIAL_ECHOPAIR(" R", LINEAR_UNIT(planner.retract_acceleration));
+    SERIAL_ECHOLNPAIR(" T", LINEAR_UNIT(planner.travel_acceleration));
+
+    if (!forReplay) {
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPGM("Advanced: S<min_feedrate> T<min_travel_feedrate> B<min_segment_time_ms> X<max_xy_jerk> Z<max_z_jerk> E<max_e_jerk>");
+    }
+    CONFIG_ECHO_START;
+    SERIAL_ECHOPAIR("  M205 S", LINEAR_UNIT(planner.min_feedrate_mm_s));
+    SERIAL_ECHOPAIR(" T", LINEAR_UNIT(planner.min_travel_feedrate_mm_s));
+    SERIAL_ECHOPAIR(" B", planner.min_segment_time);
+    SERIAL_ECHOPAIR(" X", LINEAR_UNIT(planner.max_jerk[X_AXIS]));
+    SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(planner.max_jerk[Y_AXIS]));
+    SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.max_jerk[Z_AXIS]));
+    SERIAL_ECHOLNPAIR(" E", LINEAR_UNIT(planner.max_jerk[E_AXIS]));
+
+    #if HAS_M206_COMMAND
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Home offset:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M206 X", LINEAR_UNIT(home_offset[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(home_offset[Y_AXIS]));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(home_offset[Z_AXIS]));
+    #endif
+
+    #if HOTENDS > 1
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Hotend offsets:");
+      }
+      CONFIG_ECHO_START;
+      for (uint8_t e = 1; e < HOTENDS; e++) {
+        SERIAL_ECHOPAIR("  M218 T", (int)e);
+        SERIAL_ECHOPAIR(" X", LINEAR_UNIT(hotend_offset[X_AXIS][e]));
+        SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(hotend_offset[Y_AXIS][e]));
+        #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) ||ENABLED(PARKING_EXTRUDER)
+          SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(hotend_offset[Z_AXIS][e]));
+        #endif
+        SERIAL_EOL();
+      }
+    #endif
+
+    #if ENABLED(MESH_BED_LEVELING)
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Mesh Bed Leveling:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M420 S", leveling_is_valid() ? 1 : 0);
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
+      #endif
+      SERIAL_EOL();
+      for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; py++) {
+        for (uint8_t px = 0; px < GRID_MAX_POINTS_X; px++) {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  G29 S3 X", (int)px + 1);
+          SERIAL_ECHOPAIR(" Y", (int)py + 1);
+          SERIAL_ECHOPGM(" Z");
+          SERIAL_PROTOCOL_F(LINEAR_UNIT(mbl.z_values[px][py]), 5);
+          SERIAL_EOL();
+        }
+      }
+
+    #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        ubl.echo_name();
+        SERIAL_ECHOLNPGM(":");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M420 S", leveling_is_active() ? 1 : 0);
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        SERIAL_ECHOPAIR(" Z", planner.z_fade_height);
+      #endif
+      SERIAL_EOL();
+
+      if (!forReplay) {
+        SERIAL_EOL();
+        ubl.report_state();
+
+        SERIAL_ECHOLNPAIR("\nActive Mesh Slot: ", ubl.state.storage_slot);
+
+        SERIAL_ECHOPGM("z_offset: ");
+        SERIAL_ECHO_F(ubl.state.z_offset, 6);
+        SERIAL_EOL();
+
+        SERIAL_ECHOPAIR("EEPROM can hold ", calc_num_meshes());
+        SERIAL_ECHOLNPGM(" meshes.\n");
+      }
+
+    #elif HAS_ABL
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Auto Bed Leveling:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M420 S", leveling_is_active() ? 1 : 0);
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        SERIAL_ECHOPAIR(" Z", LINEAR_UNIT(planner.z_fade_height));
+      #endif
+      SERIAL_EOL();
+
+    #endif
+
+    #if ENABLED(DELTA)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Endstop adjustment:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M666 X", LINEAR_UNIT(endstop_adj[X_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(endstop_adj[Y_AXIS]));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(endstop_adj[Z_AXIS]));
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
+      SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
+      SERIAL_ECHOPAIR(" H", LINEAR_UNIT(DELTA_HEIGHT + home_offset[Z_AXIS]));
+      SERIAL_ECHOPAIR(" S", delta_segments_per_second);
+      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
+      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
+      SERIAL_ECHOPAIR(" Z", 0.00);
+      SERIAL_EOL();
+    #elif ENABLED(Z_DUAL_ENDSTOPS)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Z2 Endstop adjustment:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPAIR("  M666 Z", LINEAR_UNIT(z_endstop_adj));
+    #endif // DELTA
+
+    #if ENABLED(ULTIPANEL)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Material heatup parameters:");
+      }
+      CONFIG_ECHO_START;
+      for (uint8_t i = 0; i < COUNT(lcd_preheat_hotend_temp); i++) {
+        SERIAL_ECHOPAIR("  M145 S", (int)i);
+        SERIAL_ECHOPAIR(" H", TEMP_UNIT(lcd_preheat_hotend_temp[i]));
+        SERIAL_ECHOPAIR(" B", TEMP_UNIT(lcd_preheat_bed_temp[i]));
+        SERIAL_ECHOLNPAIR(" F", lcd_preheat_fan_speed[i]);
+      }
+    #endif // ULTIPANEL
+
+    #if HAS_PID_HEATING
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("PID settings:");
+      }
+      #if ENABLED(PIDTEMP)
+        #if HOTENDS > 1
+          if (forReplay) {
+            HOTEND_LOOP() {
+              CONFIG_ECHO_START;
+              SERIAL_ECHOPAIR("  M301 E", e);
+              SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, e));
+              SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, e)));
+              SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, e)));
+              #if ENABLED(PID_EXTRUSION_SCALING)
+                SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, e));
+                if (e == 0) SERIAL_ECHOPAIR(" L", lpq_len);
+              #endif
+              SERIAL_EOL();
+            }
+          }
+          else
+        #endif // HOTENDS > 1
+        // !forReplay || HOTENDS == 1
+        {
+          CONFIG_ECHO_START;
+          SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0
+          SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));
+          SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));
+            SERIAL_ECHOPAIR(" L", lpq_len);
+          #endif
+          SERIAL_EOL();
+        }
+      #endif // PIDTEMP
+
+      #if ENABLED(PIDTEMPBED)
+        CONFIG_ECHO_START;
+        SERIAL_ECHOPAIR("  M304 P", thermalManager.bedKp);
+        SERIAL_ECHOPAIR(" I", unscalePID_i(thermalManager.bedKi));
+        SERIAL_ECHOPAIR(" D", unscalePID_d(thermalManager.bedKd));
+        SERIAL_EOL();
+      #endif
+
+    #endif // PIDTEMP || PIDTEMPBED
+
+    #if HAS_LCD_CONTRAST
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("LCD Contrast:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPAIR("  M250 C", lcd_contrast);
+    #endif
+
+    #if ENABLED(FWRETRACT)
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Retract: S<length> F<units/m> Z<lift>");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M207 S", LINEAR_UNIT(retract_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(swap_retract_length));
+      SERIAL_ECHOPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(retract_feedrate_mm_s)));
+      SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(retract_zlift));
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Recover: S<length> F<units/m>");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M208 S", LINEAR_UNIT(retract_recover_length));
+      SERIAL_ECHOPAIR(" W", LINEAR_UNIT(swap_retract_recover_length));
+      SERIAL_ECHOLNPAIR(" F", MMS_TO_MMM(LINEAR_UNIT(retract_recover_feedrate_mm_s)));
+
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPAIR("  M209 S", autoretract_enabled ? 1 : 0);
+
+    #endif // FWRETRACT
+
+    /**
+     * Auto Bed Leveling
+     */
+    #if HAS_BED_PROBE
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Z-Probe Offset (mm):");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOLNPAIR("  M851 Z", LINEAR_UNIT(zprobe_zoffset));
+    #endif
+
+    /**
+     * TMC2130 stepper driver current
+     */
+    #if ENABLED(HAVE_TMC2130)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Stepper driver current:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHO("  M906");
+      #if ENABLED(X_IS_TMC2130)
+        SERIAL_ECHOPAIR(" X", stepperX.getCurrent());
+      #endif
+      #if ENABLED(Y_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Y", stepperY.getCurrent());
+      #endif
+      #if ENABLED(Z_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Z", stepperZ.getCurrent());
+      #endif
+      #if ENABLED(X2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" X2", stepperX2.getCurrent());
+      #endif
+      #if ENABLED(Y2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Y2", stepperY2.getCurrent());
+      #endif
+      #if ENABLED(Z2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" Z2", stepperZ2.getCurrent());
+      #endif
+      #if ENABLED(E0_IS_TMC2130)
+        SERIAL_ECHOPAIR(" E0", stepperE0.getCurrent());
+      #endif
+      #if ENABLED(E1_IS_TMC2130)
+        SERIAL_ECHOPAIR(" E1", stepperE1.getCurrent());
+      #endif
+      #if ENABLED(E2_IS_TMC2130)
+        SERIAL_ECHOPAIR(" E2", stepperE2.getCurrent());
+      #endif
+      #if ENABLED(E3_IS_TMC2130)
+        SERIAL_ECHOPAIR(" E3", stepperE3.getCurrent());
+      #endif
+      SERIAL_EOL();
+    #endif
+
+    /**
+     * Linear Advance
+     */
+    #if ENABLED(LIN_ADVANCE)
+      if (!forReplay) {
+        CONFIG_ECHO_START;
+        SERIAL_ECHOLNPGM("Linear Advance:");
+      }
+      CONFIG_ECHO_START;
+      SERIAL_ECHOPAIR("  M900 K", planner.extruder_advance_k);
+      SERIAL_ECHOLNPAIR(" R", planner.advance_ed_ratio);
+    #endif
+
+    #if HAS_MOTOR_CURRENT_PWM
+      CONFIG_ECHO_START;
+      if (!forReplay) {
+        SERIAL_ECHOLNPGM("Stepper motor currents:");
+        CONFIG_ECHO_START;
+      }
+      SERIAL_ECHOPAIR("  M907 X", stepper.motor_current_setting[0]);
+      SERIAL_ECHOPAIR(" Z", stepper.motor_current_setting[1]);
+      SERIAL_ECHOPAIR(" E", stepper.motor_current_setting[2]);
+      SERIAL_EOL();
+    #endif
+  }
+
+#endif // !DISABLE_M503
