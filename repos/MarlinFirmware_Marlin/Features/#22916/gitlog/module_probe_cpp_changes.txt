commit f5f6c37c17edd6e710bc48578aa325f317d47d51
Author: Alexander Thomas Julian <ajulian@hawk.iit.edu>
Date:   Sun May 12 13:25:14 2024 -0500

    üêõ LCD Bed Tramming fixes (#26962)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 342ce2bb3a..616414a027 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -992,21 +992,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
     float measured_z = deploy() ? NAN : run_z_probe(sanity_check, z_min_point, z_clearance) + offset.z;
 
     // Deploy succeeded and a successful measurement was done.
     // Raise and/or stow the probe depending on 'raise_after' and settings.
     if (!isnan(measured_z)) {
       switch (raise_after) {
         default: break;
         case PROBE_PT_RAISE:
           if (raise_after_is_relative)
-            do_z_clearance(current_position.z + z_clearance, false);
+            do_z_clearance_by(z_clearance);
           else
             do_z_clearance(z_clearance);
           break;
         case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
           if (stow()) measured_z = NAN;   // Error on stow?
           break;
       }
     }
 
     // If any error occurred stow the probe and set an alert

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 2fec098b8a..342ce2bb3a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -89,22 +89,20 @@
 #if HAS_PTC
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #if ENABLED(X_AXIS_TWIST_COMPENSATION)
   #include "../feature/x_twist.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
-#elif ENABLED(DWIN_LCD_PROUI)
-  #include "../lcd/e3v2/proui/dwin_popup.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
@@ -369,22 +367,25 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       // Allow the user to interrupt
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
       while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();
       TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
       OKAY_BUZZ();
     }
     #endif
 
     TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_fstr));
-    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_fstr));
-    TERN_(DWIN_LCD_PROUI, dwinPopupConfirm(ICON_BLTouch, ds_fstr, FPSTR(CONTINUE_STR)));
+    #if ENABLED(DWIN_LCD_PROUI)
+      ExtUI::onUserConfirmRequired(ICON_BLTouch, ds_fstr, FPSTR(CONTINUE_STR));
+    #elif ENABLED(EXTENSIBLE_UI)
+      ExtUI::onUserConfirmRequired(ds_fstr);
+    #endif
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
 
     ui.reset_status();
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);

commit 38560378fcb99bcdb4b889f3b8e08c7dc5abe366
Author: engrenage <32837871+petaflot@users.noreply.github.com>
Date:   Thu Jan 25 21:24:57 2024 +0100

    üîß Allow float Z_PROBE_LOW_POINT (#26711)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ee9e9b34ac..2fec098b8a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -1003,20 +1003,24 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
             do_z_clearance(z_clearance);
           break;
         case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
           if (stow()) measured_z = NAN;   // Error on stow?
           break;
       }
     }
 
     // If any error occurred stow the probe and set an alert
     if (isnan(measured_z)) {
+      // TODO: Disable steppers (unless G29_RETRY_AND_RECOVER or G29_HALT_ON_FAILURE are set).
+      // Something definitely went wrong at this point, so it might be a good idea to release the steppers.
+      // The user may want to quickly move the carriage or bed by hand to avoid bed damage from the (hot) nozzle.
+      // This would also benefit from the contemplated "Audio Alerts" feature.
       stow();
       LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
       #if DISABLED(G29_RETRY_AND_RECOVER)
         SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
       #endif
     }
     else {
       TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
       TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
       if (verbose_level > 2 || DEBUGGING(LEVELING))

commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0bd83bc3ac..ee9e9b34ac 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -90,21 +90,21 @@
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #if ENABLED(X_AXIS_TWIST_COMPENSATION)
   #include "../feature/x_twist.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_LCD_PROUI)
-  #include "../lcd/e3v2/proui/dwin.h"
+  #include "../lcd/e3v2/proui/dwin_popup.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
@@ -349,42 +349,42 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #endif // HAS_QUIET_PROBING
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     // Start preheating before waiting for user confirmation that the probe is ready.
     TERN_(PREHEAT_BEFORE_PROBING, if (deploy) probe.preheat_for_probing(0, PROBING_BED_TEMP, true));
 
-    FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
+    FSTR_P const ds_fstr = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
     ui.return_to_status();       // To display the new status message
-    ui.set_max_status(ds_str);
+    ui.set_max_status(ds_fstr);
     SERIAL_ECHOLN(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
     OKAY_BUZZ();
 
     #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
+    {
       // Wait for the probe to be attached or detached before asking for explicit user confirmation
       // Allow the user to interrupt
-      {
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
-        while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();
-        TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
-        OKAY_BUZZ();
-      }
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
+      while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();
+      TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
+      OKAY_BUZZ();
+    }
     #endif
 
-    TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_str));
-    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
-    TERN_(DWIN_LCD_PROUI, dwinPopupConfirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_fstr));
+    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_fstr));
+    TERN_(DWIN_LCD_PROUI, dwinPopupConfirm(ICON_BLTouch, ds_fstr, FPSTR(CONTINUE_STR)));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
 
     ui.reset_status();
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);

commit fe8266b59105c24a6dced92bfd604374e5e9ef8d
Author: Erkan Ozgur Yilmaz <eoyilmaz@gmail.com>
Date:   Thu Nov 30 22:52:11 2023 +0000

    üö∏ Fix BLTouch HSMode deploy (#26311)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index deeb53942b..0bd83bc3ac 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -589,25 +589,29 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if ALL(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
-  // Ensure the BLTouch is deployed. Does nothing if already deployed.
-  if (TERN0(BLTOUCH, bltouch.deploy())) return true;
+  #if ENABLED(BLTOUCH)
+    // Ensure the BLTouch is deployed. (Does nothing if already deployed.)
+    // Don't deploy with high_speed_mode enabled. The probe already re-deploys itself.
+    if (TERN(MEASURE_BACKLASH_WHEN_PROBING, true, !bltouch.high_speed_mode) && bltouch.deploy())
+      return true;
+  #endif
 
   #if HAS_Z_SERVO_PROBE && (ENABLED(Z_SERVO_INTERMEDIATE_STOW) || defined(Z_SERVO_MEASURE_ANGLE))
-    probe_specific_action(true);  //  Always re-deploy in this case
+    probe_specific_action(true);  // Always re-deploy in this case
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     if (test_sensitivity.z) {

commit 6a35ab6557f8450845379c90724dc14b55be4b0c
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Oct 14 22:54:54 2023 -0600

    ‚ú® Z_PROBE_ERROR_TOLERANCE (expose) (#26229)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 989965d6d8..deeb53942b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -728,33 +728,33 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
 #endif
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @param sanity_check Flag to compare the probe result with the expected result
  *                     based on the probe Z offset. If the result is too far away
- *                     (more than 2mm too early) then consider it an error.
+ *                     (more than Z_PROBE_ERROR_TOLERANCE too early) then throw an error.
  * @param z_min_point Override the minimum probing height (-2mm), to allow deeper probing.
  * @param z_clearance Z clearance to apply on probe failure.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/, const_float_t z_min_point/*=Z_PROBE_LOW_POINT*/, const_float_t z_clearance/*=Z_TWEEN_SAFE_CLEARANCE*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   const float zoffs = SUM_TERN(HAS_HOTEND_OFFSET, -offset.z, hotend_offset[active_extruder].z);
 
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck) -> bool {
-    constexpr float error_tolerance = 2.0f;
+    constexpr float error_tolerance = Z_PROBE_ERROR_TOLERANCE;
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM_P(plbl);
       DEBUG_ECHOLNPGM("> try_to_probe(..., ", z_probe_low_point, ", ", fr_mm_s, ", ...)");
     }
 
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),              // No probe trigger?

commit ffef8f1b297e83aa37eeb5ffcc5369e5c9c42a09
Author: Mark <niujl123@sina.com>
Date:   Mon Aug 7 12:33:20 2023 +0800

    üö∏ BD Sensor Z axis stop height (#26015)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 68fcfd00e0..989965d6d8 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -973,20 +973,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     if (DEBUGGING(LEVELING)) DEBUG_ECHOPGM("-relative");
     npos -= DIFF_TERN(HAS_HOTEND_OFFSET, offset_xy, xy_pos_t(hotend_offset[active_extruder]));
   }
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" point");
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   #if ENABLED(BD_SENSOR)
 
+    safe_delay(4);
     return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
 
   #else // !BD_SENSOR
 
     float measured_z = deploy() ? NAN : run_z_probe(sanity_check, z_min_point, z_clearance) + offset.z;
 
     // Deploy succeeded and a successful measurement was done.
     // Raise and/or stow the probe depending on 'raise_after' and settings.
     if (!isnan(measured_z)) {
       switch (raise_after) {

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    üîß More endstops refactoring (#25758)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8c13da36f9..68fcfd00e0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -603,22 +603,33 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     probe_specific_action(true);  //  Always re-deploy in this case
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
-    if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);   // All machines will check Z-DIAG for stall
-    endstops.set_homing_current(true);                                            // The "homing" current also applies to probing
+    if (test_sensitivity.z) {
+      stealth_states.z = tmc_enable_stallguard(stepperZ);                         // All machines will check Z-DIAG for stall
+      #if ENABLED(Z_MULTI_ENDSTOPS)
+        stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
+        #if NUM_Z_STEPPERS >= 3
+          stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
+          #if NUM_Z_STEPPERS >= 4
+            stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
+          #endif
+        #endif
+      #endif
+    }
+    endstops.set_z_sensorless_current(true);                                            // The "homing" current also applies to probing
     endstops.enable(true);
   #endif // SENSORLESS_PROBING
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered = (
@@ -636,23 +647,34 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
       if (test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
-    if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
-    endstops.set_homing_current(false);
-  #endif
+    if (test_sensitivity.z) {
+      tmc_disable_stallguard(stepperZ, stealth_states.z);
+      #if ENABLED(Z_MULTI_ENDSTOPS)
+        tmc_disable_stallguard(stepperZ2, stealth_states.z2);
+        #if NUM_Z_STEPPERS >= 3
+          tmc_disable_stallguard(stepperZ3, stealth_states.z3);
+          #if NUM_Z_STEPPERS >= 4
+            tmc_disable_stallguard(stepperZ4, stealth_states.z4);
+          #endif
+        #endif
+      #endif
+    }
+    endstops.set_z_sensorless_current(false);
+  #endif // SENSORLESS_PROBING
 
   #if ENABLED(BLTOUCH)
     if (probe_triggered && !bltouch.high_speed_mode && bltouch.stow())
       return true; // Stow in LOW SPEED MODE on every trigger
   #endif
 
   #if ALL(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
     probe_specific_action(false);  //  Always stow
   #endif
 

commit 381515721481d09c4f30ca8a526e90fc39602fd9
Author: Scott Mikutsky <smikutsky@gmail.com>
Date:   Mon Jul 17 00:29:56 2023 -0400

    üêõ Ensure BLTouch deploy in HS Mode (#26033)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b3872146d1..8c13da36f9 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -589,24 +589,22 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if ALL(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
-  #if ENABLED(BLTOUCH)
-    if (!bltouch.high_speed_mode && bltouch.deploy())
-      return true; // Deploy in LOW SPEED MODE on every probe action
-  #endif
+  // Ensure the BLTouch is deployed. Does nothing if already deployed.
+  if (TERN0(BLTOUCH, bltouch.deploy())) return true;
 
   #if HAS_Z_SERVO_PROBE && (ENABLED(Z_SERVO_INTERMEDIATE_STOW) || defined(Z_SERVO_MEASURE_ANGLE))
     probe_specific_action(true);  //  Always re-deploy in this case
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index e426e3bb4b..b3872146d1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -370,21 +370,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
         while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();
         TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
         OKAY_BUZZ();
       }
     #endif
 
     TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_str));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
-    TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
+    TERN_(DWIN_LCD_PROUI, dwinPopupConfirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
 
     ui.reset_status();
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 204617ba83..e426e3bb4b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -351,21 +351,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     // Start preheating before waiting for user confirmation that the probe is ready.
     TERN_(PREHEAT_BEFORE_PROBING, if (deploy) probe.preheat_for_probing(0, PROBING_BED_TEMP, true));
 
     FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
     ui.return_to_status();       // To display the new status message
-    ui.set_status(ds_str, 99);
+    ui.set_max_status(ds_str);
     SERIAL_ECHOLN(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
     OKAY_BUZZ();
 
     #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
       // Wait for the probe to be attached or detached before asking for explicit user confirmation
       // Allow the user to interrupt
       {
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0bece02c15..204617ba83 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -352,21 +352,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     // Start preheating before waiting for user confirmation that the probe is ready.
     TERN_(PREHEAT_BEFORE_PROBING, if (deploy) probe.preheat_for_probing(0, PROBING_BED_TEMP, true));
 
     FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
     ui.return_to_status();       // To display the new status message
     ui.set_status(ds_str, 99);
-    SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
+    SERIAL_ECHOLN(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
     OKAY_BUZZ();
 
     #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
       // Wait for the probe to be attached or detached before asking for explicit user confirmation
       // Allow the user to interrupt
       {
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
         while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index c3ea161cb4..0bece02c15 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -804,21 +804,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/, const_float_t z_min_p
       // Probe downward slowly to find the bed
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Slow Probe:");
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW), sanity_check)) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
-        LOOP_LE_N(i, p) {                                             // Iterate the saved Zs to insert the new Z
+        for (uint8_t i = 0; i <= p; ++i) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_z_sum += z;
       #else
         UNUSED(z);
@@ -842,21 +842,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/, const_float_t z_min_p
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
 
       // Remove values farthest from the median
       uint8_t min_avg_idx = 0, max_avg_idx = TOTAL_PROBING - 1;
       for (uint8_t i = EXTRA_PROBING; i--;)
         if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
           max_avg_idx--; else min_avg_idx++;
 
       // Return the average value of all remaining probes.
-      LOOP_S_LE_N(i, min_avg_idx, max_avg_idx)
+      for (uint8_t i = min_avg_idx; i <= max_avg_idx; ++i)
         probes_z_sum += probes[i];
 
     #endif
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 1e01cfd9b6..c3ea161cb4 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -50,23 +50,23 @@
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   abc_float_t offset_sensorless_adj{0};
   float largest_sensorless_adj = 0;
 #endif
 
-#if EITHER(HAS_QUIET_PROBING, USE_SENSORLESS)
+#if ANY(HAS_QUIET_PROBING, USE_SENSORLESS)
   #include "stepper/indirection.h"
-  #if BOTH(HAS_QUIET_PROBING, PROBING_ESTEPPERS_OFF)
+  #if ALL(HAS_QUIET_PROBING, PROBING_ESTEPPERS_OFF)
     #include "stepper.h"
   #endif
   #if USE_SENSORLESS
     #include "../feature/tmc_util.h"
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       #include "planner.h"
     #endif
   #endif
 #endif
 
@@ -422,21 +422,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif
 }
 
-#if EITHER(PREHEAT_BEFORE_PROBING, PREHEAT_BEFORE_LEVELING)
+#if ANY(PREHEAT_BEFORE_PROBING, PREHEAT_BEFORE_LEVELING)
 
   #if ENABLED(PREHEAT_BEFORE_PROBING)
     #ifndef PROBING_NOZZLE_TEMP
       #define PROBING_NOZZLE_TEMP 0
     #endif
     #ifndef PROBING_BED_TEMP
       #define PROBING_BED_TEMP 0
     #endif
   #endif
 
@@ -483,21 +483,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   }
 
 #endif
 
 /**
  * Print an error and stop()
  */
 void Probe::probe_error_stop() {
   SERIAL_ERROR_START();
   SERIAL_ECHOPGM(STR_STOP_PRE);
-  #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
+  #if ANY(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     SERIAL_ECHOPGM(STR_STOP_UNHOMED);
   #elif ENABLED(BLTOUCH)
     SERIAL_ECHOPGM(STR_STOP_BLTOUCH);
   #endif
   SERIAL_ECHOLNPGM(STR_STOP_POST);
   stop();
 }
 
 /**
  * Attempt to deploy or stow the probe
@@ -508,33 +508,33 @@ bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPGM("deploy=", deploy, " no_return=", no_return);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
-  #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
+  #if ANY(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
     constexpr bool z_raise_wanted = true;
   #endif
 
   if (z_raise_wanted) {
     const float zdest = DIFF_TERN(HAS_HOTEND_OFFSET, Z_CLEARANCE_DEPLOY_PROBE, hotend_offset[active_extruder].z);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z to ", zdest);
     do_z_clearance(zdest);
   }
 
-  #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
+  #if ANY(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       probe_error_stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;        // Remember location before probe deployment
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
 
@@ -581,25 +581,25 @@ bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
-  #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
+  #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
-  #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
+  #if ALL(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
   #if ENABLED(BLTOUCH)
     if (!bltouch.high_speed_mode && bltouch.deploy())
       return true; // Deploy in LOW SPEED MODE on every probe action
   #endif
 
   #if HAS_Z_SERVO_PROBE && (ENABLED(Z_SERVO_INTERMEDIATE_STOW) || defined(Z_SERVO_MEASURE_ANGLE))
     probe_specific_action(true);  //  Always re-deploy in this case
@@ -647,21 +647,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     #endif
     if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
     endstops.set_homing_current(false);
   #endif
 
   #if ENABLED(BLTOUCH)
     if (probe_triggered && !bltouch.high_speed_mode && bltouch.stow())
       return true; // Stow in LOW SPEED MODE on every trigger
   #endif
 
-  #if BOTH(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
+  #if ALL(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
     probe_specific_action(false);  //  Always stow
   #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
@@ -682,21 +682,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   }
 
   /**
    * @brief Tare the Z probe
    *
    * @details Signal to the probe to tare itself
    *
    * @return TRUE if the tare cold not be completed
    */
   bool Probe::tare() {
-    #if BOTH(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
+    #if ALL(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
       if (endstops.probe_switch_activated()) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Cannot tare an active probe");
         return true;
       }
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Taring probe");
     WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
     delay(PROBE_TARE_TIME);
     WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 96606f30a8..1e01cfd9b6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -608,35 +608,35 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);   // All machines will check Z-DIAG for stall
     endstops.set_homing_current(true);                                            // The "homing" current also applies to probing
     endstops.enable(true);
-  #endif
+  #endif // SENSORLESS_PROBING
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
-  const bool probe_triggered =
+  const bool probe_triggered = (
     #if HAS_DELTA_SENSORLESS_PROBING
       endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
-  ;
+  );
 
   // Offset sensorless probing
   #if HAS_DELTA_SENSORLESS_PROBING
     if (probe_triggered) refresh_largest_sensorless_adj();
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    üêõ Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a03125a73a..96606f30a8 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -515,21 +515,21 @@ bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
     constexpr bool z_raise_wanted = true;
   #endif
 
   if (z_raise_wanted) {
-    const float zdest = DIFF_TERN(HAS_HOTEND_OFFSET, _MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE), hotend_offset[active_extruder].z);
+    const float zdest = DIFF_TERN(HAS_HOTEND_OFFSET, Z_CLEARANCE_DEPLOY_PROBE, hotend_offset[active_extruder].z);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z to ", zdest);
     do_z_clearance(zdest);
   }
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       probe_error_stop();
       return true;
     }
   #endif
@@ -709,24 +709,26 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @param sanity_check Flag to compare the probe result with the expected result
  *                     based on the probe Z offset. If the result is too far away
  *                     (more than 2mm too early) then consider it an error.
+ * @param z_min_point Override the minimum probing height (-2mm), to allow deeper probing.
+ * @param z_clearance Z clearance to apply on probe failure.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
-float Probe::run_z_probe(const bool sanity_check/*=true*/) {
+float Probe::run_z_probe(const bool sanity_check/*=true*/, const_float_t z_min_point/*=Z_PROBE_LOW_POINT*/, const_float_t z_clearance/*=Z_TWEEN_SAFE_CLEARANCE*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   const float zoffs = SUM_TERN(HAS_HOTEND_OFFSET, -offset.z, hotend_offset[active_extruder].z);
 
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck) -> bool {
     constexpr float error_tolerance = 2.0f;
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM_P(plbl);
       DEBUG_ECHOLNPGM("> try_to_probe(..., ", z_probe_low_point, ", ", fr_mm_s, ", ...)");
     }
@@ -743,49 +745,48 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         if (probe_fail) DEBUG_ECHOLNPGM("No trigger.");
         if (early_fail) DEBUG_ECHOLNPGM("Triggered early (above ", zoffs + error_tolerance, "mm)");
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
-  // For known Z probe below the expected trigger point, otherwise -10mm.
-  const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? zoffs + Z_PROBE_LOW_POINT : -10.0f;
-
+  // For known Z probe below the expected trigger point, otherwise -10mm lower.
+  const float z_probe_low_point = zoffs + z_min_point -float((!axis_is_trusted(Z_AXIS)) * 10);
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe Low Point: ", z_probe_low_point);
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s, sanity_check)) return NAN;
 
     const float z1 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", z1);
 
     // Raise to give the probe clearance
-    do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
+    do_z_clearance(z1 + (Z_CLEARANCE_MULTI_PROBE), false);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = (Z_CLEARANCE_DEPLOY_PROBE) + 5.0f + _MAX(zoffs, 0.0f);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
-        do_z_clearance(Z_PROBE_SAFE_CLEARANCE);
+        do_z_clearance(z_clearance);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
@@ -904,40 +905,44 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  * - Revert to previous tool
  *
  * A batch of multiple probing operations should always be preceded by use_probing_tool() invocation
  * and succeeded by use_probing_tool(false), in order to avoid multiple tool changes and to end up
  * with the previously active tool.
  *
  */
-float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
+float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/,
+  const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/,
+  const_float_t z_min_point/*=Z_PROBE_LOW_POINT*/, const_float_t z_clearance/*=Z_TWEEN_SAFE_CLEARANCE*/,
+  const bool raise_after_is_relative/*=false*/
+) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if ENABLED(BLTOUCH)
     // Reset a BLTouch in HS mode if already triggered
     if (bltouch.high_speed_mode && bltouch.triggered()) bltouch._reset();
   #endif
 
   // Use a safe Z height for the XY move
-  const float safe_z = _MAX(current_position.z, Z_PROBE_SAFE_CLEARANCE);
+  const float safe_z = _MAX(current_position.z, z_clearance);
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = NUM_AXIS_ARRAY(
     rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, safe_z), safe_z),
     current_position.i, current_position.j, current_position.k,
     current_position.u, current_position.v, current_position.w
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Not Reachable");
     return NAN;
@@ -952,29 +957,32 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   #if ENABLED(BD_SENSOR)
 
     return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
 
   #else // !BD_SENSOR
 
-    float measured_z = deploy() ? NAN : run_z_probe(sanity_check) + offset.z;
+    float measured_z = deploy() ? NAN : run_z_probe(sanity_check, z_min_point, z_clearance) + offset.z;
 
     // Deploy succeeded and a successful measurement was done.
     // Raise and/or stow the probe depending on 'raise_after' and settings.
     if (!isnan(measured_z)) {
       switch (raise_after) {
         default: break;
         case PROBE_PT_RAISE:
-          do_z_clearance(Z_PROBE_SAFE_CLEARANCE);
+          if (raise_after_is_relative)
+            do_z_clearance(current_position.z + z_clearance, false);
+          else
+            do_z_clearance(z_clearance);
           break;
         case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
           if (stow()) measured_z = NAN;   // Error on stow?
           break;
       }
     }
 
     // If any error occurred stow the probe and set an alert
     if (isnan(measured_z)) {
       stow();

commit 10ed5ab01c43a09429e1eb885196308fca71f492
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 03:17:55 2023 -0500

    üö∏ Improve PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED (#25681)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3e7db5a077..a03125a73a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -345,39 +345,49 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
-    do {
-      #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        if (deploy != PROBE_TRIGGERED()) break;
-      #endif
 
-      OKAY_BUZZ();
+    // Start preheating before waiting for user confirmation that the probe is ready.
+    TERN_(PREHEAT_BEFORE_PROBING, if (deploy) probe.preheat_for_probing(0, PROBING_BED_TEMP, true));
+
+    FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
+    ui.return_to_status();       // To display the new status message
+    ui.set_status(ds_str, 99);
+    SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
+
+    OKAY_BUZZ();
+
+    #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
+      // Wait for the probe to be attached or detached before asking for explicit user confirmation
+      // Allow the user to interrupt
+      {
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        TERN_(HAS_RESUME_CONTINUE, wait_for_user = true);
+        while (deploy == PROBE_TRIGGERED() && TERN1(HAS_RESUME_CONTINUE, wait_for_user)) idle_no_sleep();
+        TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
+        OKAY_BUZZ();
+      }
+    #endif
 
-      FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
-      ui.return_to_status();       // To display the new status message
-      ui.set_status(ds_str, 99);
-      SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_str));
+    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
+    TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
+    TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
 
-      TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_str));
-      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
-      TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
-      TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
-      ui.reset_status();
-
-    } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
+    ui.reset_status();
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(MAGLEV4)
@@ -428,55 +438,55 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     #ifndef PROBING_BED_TEMP
       #define PROBING_BED_TEMP 0
     #endif
   #endif
 
   /**
    * Do preheating as required before leveling or probing.
    *  - If a preheat input is higher than the current target, raise the target temperature.
    *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
-  void Probe::preheat_for_probing(const celsius_t hotend_temp, const celsius_t bed_temp) {
+  void Probe::preheat_for_probing(const celsius_t hotend_temp, const celsius_t bed_temp, const bool early/*=false*/) {
     #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif
     #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
 
-    LCD_MESSAGE(MSG_PREHEATING);
+    if (!early) LCD_MESSAGE(MSG_PREHEATING);
 
     DEBUG_ECHOPGM("Preheating ");
 
     #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
       const celsius_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
       if (hotendPreheat) {
         DEBUG_ECHOPGM("hotend (", hotendPreheat, ")");
         thermalManager.setTargetHotend(hotendPreheat, 0);
       }
-    #elif ENABLED(WAIT_FOR_BED_HEAT)
-      constexpr celsius_t hotendPreheat = 0;
     #endif
 
     #if ENABLED(WAIT_FOR_BED_HEAT)
       const celsius_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
       if (bedPreheat) {
-        if (hotendPreheat) DEBUG_ECHOPGM(" and ");
+        if (TERN0(WAIT_FOR_NOZZLE_HEAT, hotendPreheat)) DEBUG_ECHOPGM(" and ");
         DEBUG_ECHOPGM("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
-    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
-    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp    > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW)) thermalManager.wait_for_bed_heating());
+    if (!early) {
+      TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
+      TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp    > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW)) thermalManager.wait_for_bed_heating());
+    }
   }
 
 #endif
 
 /**
  * Print an error and stop()
  */
 void Probe::probe_error_stop() {
   SERIAL_ERROR_START();
   SERIAL_ECHOPGM(STR_STOP_PRE);

commit 4233e4864f0c621612ce35a9b6ca882312e3aa4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 01:56:10 2023 -0500

    üö∏ MarlinUI Endstop Test Screen, and more (#25667)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 75295c5f5a..3e7db5a077 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -544,20 +544,21 @@ bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
 
   // If preheating is required before any probing...
+  // TODO: Consider skipping this for things like M401, G34, etc.
   TERN_(PREHEAT_BEFORE_PROBING, if (deploy) preheat_for_probing(PROBING_NOZZLE_TEMP, PROBING_BED_TEMP));
 
   if (!no_return) do_blocking_move_to(old_xy); // Return to the original location unless handled externally
 
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 /**
  * @brief Move down until the probe triggers or the low limit is reached
@@ -1013,27 +1014,28 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     if (test_sensitivity.y) offset_sensorless_adj.b = sz;
     if (test_sensitivity.z) offset_sensorless_adj.c = sz;
   }
 
   /**
    * Refresh largest_sensorless_adj based on triggered endstops
    */
   void Probe::refresh_largest_sensorless_adj() {
     DEBUG_SECTION(rso, "Probe::refresh_largest_sensorless_adj", true);
     largest_sensorless_adj = -3;  // A reference away from any real probe height
-    if (TEST(endstops.state(), X_MAX)) {
+    const Endstops::endstop_mask_t state = endstops.state();
+    if (TEST(state, X_MAX)) {
       NOLESS(largest_sensorless_adj, offset_sensorless_adj.a);
       DEBUG_ECHOLNPGM("Endstop_X: ", largest_sensorless_adj, " TowerX");
     }
-    if (TEST(endstops.state(), Y_MAX)) {
+    if (TEST(state, Y_MAX)) {
       NOLESS(largest_sensorless_adj, offset_sensorless_adj.b);
       DEBUG_ECHOLNPGM("Endstop_Y: ", largest_sensorless_adj, " TowerY");
     }
-    if (TEST(endstops.state(), Z_MAX)) {
+    if (TEST(state, Z_MAX)) {
       NOLESS(largest_sensorless_adj, offset_sensorless_adj.c);
       DEBUG_ECHOLNPGM("Endstop_Z: ", largest_sensorless_adj, " TowerZ");
     }
   }
 
 #endif
 
 #endif // HAS_BED_PROBE

commit 78bdf34b7bc56a0a8aa193cfd824ad2841ed25dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 18:06:56 2023 -0500

    üßë‚Äçüíª HostUI::continue_prompt method

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0f2fca119c..75295c5f5a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -161,21 +161,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGE(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
-      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Deploy TouchMI"), FPSTR(CONTINUE_STR)));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(F("Deploy TouchMI")));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
@@ -357,21 +357,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       OKAY_BUZZ();
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
-      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, ds_str, FPSTR(CONTINUE_STR)));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(ds_str));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
       TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)

commit b1537135e4abaf6c0dd85aa00160f63306d8a83f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:18:37 2023 -0500

    üö∏ BLTouch extra clearance for PROBE_PT_RAISE

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7aa6595e28..0f2fca119c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -936,59 +936,59 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   if (probe_relative) { // Get the nozzle position, adjust for active hotend if not 0
     if (DEBUGGING(LEVELING)) DEBUG_ECHOPGM("-relative");
     npos -= DIFF_TERN(HAS_HOTEND_OFFSET, offset_xy, xy_pos_t(hotend_offset[active_extruder]));
   }
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" point");
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   #if ENABLED(BD_SENSOR)
-    return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
-  #endif
 
-  float measured_z = NAN;
-  if (!deploy()) {
-    measured_z = run_z_probe(sanity_check) + offset.z;
-    TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
-    TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
-  }
+    return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
 
-  // Deploy succeeded and a successful measurement was done.
-  // Raise and/or stow the probe depending on 'raise_after' and settings.
-  if (!isnan(measured_z)) {
-    const ProbePtRaise raise_type = (TERN0(BLTOUCH, !bltouch.high_speed_mode) && raise_after == PROBE_PT_RAISE) ? PROBE_PT_STOW : raise_after;
-    switch (raise_type) {
-      default: break;
-      case PROBE_PT_RAISE:
-        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
-        break;
-      case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
-        if (stow()) measured_z = NAN;   // Error on stow?
-        break;
+  #else // !BD_SENSOR
+
+    float measured_z = deploy() ? NAN : run_z_probe(sanity_check) + offset.z;
+
+    // Deploy succeeded and a successful measurement was done.
+    // Raise and/or stow the probe depending on 'raise_after' and settings.
+    if (!isnan(measured_z)) {
+      switch (raise_after) {
+        default: break;
+        case PROBE_PT_RAISE:
+          do_z_clearance(Z_PROBE_SAFE_CLEARANCE);
+          break;
+        case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
+          if (stow()) measured_z = NAN;   // Error on stow?
+          break;
+      }
     }
 
-    if (verbose_level > 2)
-      SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
-  }
+    // If any error occurred stow the probe and set an alert
+    if (isnan(measured_z)) {
+      stow();
+      LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
+      #if DISABLED(G29_RETRY_AND_RECOVER)
+        SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
+      #endif
+    }
+    else {
+      TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
+      TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
+      if (verbose_level > 2 || DEBUGGING(LEVELING))
+        SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
+    }
 
-  // If any error occurred stow the probe and set an alert
-  if (isnan(measured_z)) {
-    stow();
-    LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
-    #if DISABLED(G29_RETRY_AND_RECOVER)
-      SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
-    #endif
-  }
-  DEBUG_ECHOLNPGM("measured_z: ", measured_z);
+    return measured_z;
 
-  return measured_z;
+  #endif // !BD_SENSOR
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.

commit b3a3cf28d244c02f89303d09d6b5d6cbdc90dd53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:14:43 2023 -0500

    üö∏ More clearance on fast probe failure

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ece14caac8..7aa6595e28 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -760,21 +760,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = (Z_CLEARANCE_DEPLOY_PROBE) + 5.0f + _MAX(zoffs, 0.0f);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
-        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+        do_z_clearance(Z_PROBE_SAFE_CLEARANCE);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
@@ -879,21 +879,20 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     old_state = probing;
     if (probing) old_tool = active_extruder;
     const uint8_t tool = probing ? PROBING_TOOL : old_tool;
     if (tool != active_extruder)
       tool_change(tool, ENABLED(PROBE_TOOLCHANGE_NO_MOVE));
   }
 
 #endif
 
 /**
- * - Switch to PROBING_TOOL if necessary
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  * - Revert to previous tool
  *
  * A batch of multiple probing operations should always be preceded by use_probing_tool() invocation

commit b5899a96645894af4cdc6815e8b5def1ef85a347
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:13:24 2023 -0500

    üßë‚Äçüíª Use largest_sensorless_adj in DELTA run_z_probe

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 945ebcdca5..ece14caac8 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -811,21 +811,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING > 0
             < TOTAL_PROBING - 1
           #endif
-        ) do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
+        ) do_z_clearance(z + (Z_CLEARANCE_MULTI_PROBE), false);
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
     #if EXTRA_PROBING > 0
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;

commit c599c939c1d50bcda4cd8f491ac6bd36d9c4d56f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 17:54:02 2023 -0500

    üßë‚Äçüíª Modify try_to_probe sanity-checking

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ff4ca58a6f..945ebcdca5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -695,66 +695,70 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     return false;
   }
 #endif
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
+ * @param sanity_check Flag to compare the probe result with the expected result
+ *                     based on the probe Z offset. If the result is too far away
+ *                     (more than 2mm too early) then consider it an error.
+ *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   const float zoffs = SUM_TERN(HAS_HOTEND_OFFSET, -offset.z, hotend_offset[active_extruder].z);
 
-  auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("try_to_probe(..., ", z_probe_low_point, ", ", fr_mm_s, ", ", scheck, ", ", clearance);
+  auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck) -> bool {
+    constexpr float error_tolerance = 2.0f;
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPGM_P(plbl);
+      DEBUG_ECHOLNPGM("> try_to_probe(..., ", z_probe_low_point, ", ", fr_mm_s, ", ...)");
+    }
 
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
-    const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),          // No probe trigger?
-               early_fail = (scheck && current_position.z > zoffs + clearance);   // Probe triggered too high?
+    const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),              // No probe trigger?
+               early_fail = (scheck && current_position.z > zoffs + error_tolerance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
-        DEBUG_ECHOPGM_P(plbl);
-        DEBUG_ECHOPGM(" Probe fail! -");
-        if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
-        if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
-        DEBUG_EOL();
+        DEBUG_ECHOPGM(" Probe fail! - ");
+        if (probe_fail) DEBUG_ECHOLNPGM("No trigger.");
+        if (early_fail) DEBUG_ECHOLNPGM("Triggered early (above ", zoffs + error_tolerance, "mm)");
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
-  // If Z isn't known then probe to -10mm.
+  // For known Z probe below the expected trigger point, otherwise -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? zoffs + Z_PROBE_LOW_POINT : -10.0f;
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe Low Point: ", z_probe_low_point);
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Fast Probe:");
-    if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
-                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
+    if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s, sanity_check)) return NAN;
 
     const float z1 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", z1);
 
     // Raise to give the probe clearance
     do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
@@ -780,22 +784,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Slow Probe:");
-      if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
-                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
+      if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW), sanity_check)) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                                             // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point

commit f53217b2c5bf7d61d21ee6784ec251bc7a670eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:01 2023 -0500

    üßë‚Äçüíª Probe flag in do_z_clearance

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b2c1c2b8de..ff4ca58a6f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -342,31 +342,20 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
         if (TEST(old_trusted, X_AXIS)) stepper.enable_axis(X_AXIS);
         if (TEST(old_trusted, Y_AXIS)) stepper.enable_axis(Y_AXIS);
         axes_trusted = old_trusted;
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
-/**
- * Raise Z to a minimum height to make room for a probe to move
- */
-void Probe::do_z_raise(const float z_raise) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe::do_z_raise(", z_raise, ")");
-  float z_dest = z_raise;
-  const float zoffs = DIFF_TERN(HAS_HOTEND_OFFSET, offset.z, hotend_offset[active_extruder].z);
-  if (zoffs < 0) z_dest -= zoffs;
-  do_z_clearance(z_dest);
-}
-
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       OKAY_BUZZ();
 
@@ -515,22 +504,25 @@ bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
     constexpr bool z_raise_wanted = true;
   #endif
 
-  if (z_raise_wanted)
-    do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
+  if (z_raise_wanted) {
+    const float zdest = DIFF_TERN(HAS_HOTEND_OFFSET, _MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE), hotend_offset[active_extruder].z);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z to ", zdest);
+    do_z_clearance(zdest);
+  }
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       probe_error_stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;        // Remember location before probe deployment
 

commit 266786406c3e90654e94b91cd74e646d145cc4ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 30 15:12:56 2023 -0500

    üé® Misc. probe-related cleanup

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 230fc30db1..b2c1c2b8de 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -750,31 +750,31 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Fast Probe:");
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
-    const float first_probe_z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
+    const float z1 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", z1);
 
     // Raise to give the probe clearance
     do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0f + _MAX(zoffs, 0.0f);
+    const float z = (Z_CLEARANCE_DEPLOY_PROBE) + 5.0f + _MAX(zoffs, 0.0f);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
         do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
@@ -846,24 +846,24 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         probes_z_sum += probes[i];
 
     #endif
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("2nd Probe Z:", z2, " Discrepancy:", z1 - z2);
 
     // Return a weighted average of the fast and slow probes
-    const float measured_z = (z2 * 3.0f + first_probe_z * 2.0f) * 0.2f;
+    const float measured_z = (z2 * 3.0f + z1 * 2.0f) * 0.2f;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position.z;
 
   #endif
 
   return DIFF_TERN(HAS_HOTEND_OFFSET, measured_z, hotend_offset[active_extruder].z);
 }

commit 49f1cc8efe0fcb8df79581c0b71eedef250e83f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 29 22:55:36 2023 -0500

    üé® Refine probe, more debug

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 25581922f6..230fc30db1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -354,20 +354,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
  */
 void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   const float zoffs = DIFF_TERN(HAS_HOTEND_OFFSET, offset.z, hotend_offset[active_extruder].z);
   if (zoffs < 0) z_dest -= zoffs;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
+  DEBUG_SECTION(log_psa, "Probe::probe_specific_action", DEBUGGING(LEVELING));
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       OKAY_BUZZ();
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
@@ -498,21 +499,20 @@ void Probe::probe_error_stop() {
   SERIAL_ECHOLNPGM(STR_STOP_POST);
   stop();
 }
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
-
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPGM("deploy=", deploy, " no_return=", no_return);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
@@ -681,26 +681,26 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   /**
    * @brief Tare the Z probe
    *
    * @details Signal to the probe to tare itself
    *
    * @return TRUE if the tare cold not be completed
    */
   bool Probe::tare() {
     #if BOTH(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
       if (endstops.probe_switch_activated()) {
-        SERIAL_ECHOLNPGM("Cannot tare an active probe");
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Cannot tare an active probe");
         return true;
       }
     #endif
 
-    SERIAL_ECHOLNPGM("Taring probe");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Taring probe");
     WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
     delay(PROBE_TARE_TIME);
     WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
     delay(PROBE_TARE_DELAY);
 
     endstops.hit_on_purpose();
     return false;
   }
 #endif
 
@@ -711,20 +711,22 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   const float zoffs = SUM_TERN(HAS_HOTEND_OFFSET, -offset.z, hotend_offset[active_extruder].z);
 
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("try_to_probe(..., ", z_probe_low_point, ", ", fr_mm_s, ", ", scheck, ", ", clearance);
+
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),          // No probe trigger?
                early_fail = (scheck && current_position.z > zoffs + clearance);   // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_ECHOPGM_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
@@ -735,45 +737,48 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? zoffs + Z_PROBE_LOW_POINT : -10.0f;
 
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe Low Point: ", z_probe_low_point);
+
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Fast Probe:");
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
-    do_z_clearance(current_position.z + Z_CLEARANCE_MULTI_PROBE);
+    do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0f + (zoffs > 0 ? zoffs : 0);
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0f + _MAX(zoffs, 0.0f);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
-        do_z_clearance(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
+        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
@@ -782,49 +787,50 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Slow Probe:");
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
                        sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
-        LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
+        LOOP_LE_N(i, p) {                                             // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_z_sum += z;
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING > 0
             < TOTAL_PROBING - 1
           #endif
-        ) do_z_clearance(z + Z_CLEARANCE_MULTI_PROBE);
+        ) do_z_clearance(Z_CLEARANCE_MULTI_PROBE);
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
     #if EXTRA_PROBING > 0
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
@@ -912,59 +918,67 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     );
     DEBUG_POS("", current_position);
   }
 
   #if ENABLED(BLTOUCH)
     // Reset a BLTouch in HS mode if already triggered
     if (bltouch.high_speed_mode && bltouch.triggered()) bltouch._reset();
   #endif
 
   // Use a safe Z height for the XY move
-  const float safe_z = _MAX(current_position.z, SUM_TERN(BLTOUCH, Z_CLEARANCE_BETWEEN_PROBES, bltouch.z_extra_clearance()));
+  const float safe_z = _MAX(current_position.z, Z_PROBE_SAFE_CLEARANCE);
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = NUM_AXIS_ARRAY(
     rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, safe_z), safe_z),
     current_position.i, current_position.j, current_position.k,
     current_position.u, current_position.v, current_position.w
   );
   if (!can_reach(npos, probe_relative)) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Not Reachable");
     return NAN;
   }
 
-  if (probe_relative) // Get the nozzle position, adjust for active hotend if not 0
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOPGM("Move to probe");
+  if (probe_relative) { // Get the nozzle position, adjust for active hotend if not 0
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOPGM("-relative");
     npos -= DIFF_TERN(HAS_HOTEND_OFFSET, offset_xy, xy_pos_t(hotend_offset[active_extruder]));
+  }
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(" point");
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   #if ENABLED(BD_SENSOR)
     return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
   #endif
 
   float measured_z = NAN;
   if (!deploy()) {
     measured_z = run_z_probe(sanity_check) + offset.z;
     TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
     TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
   }
 
   // Deploy succeeded and a successful measurement was done.
   // Raise and/or stow the probe depending on 'raise_after' and settings.
   if (!isnan(measured_z)) {
     const ProbePtRaise raise_type = (TERN0(BLTOUCH, !bltouch.high_speed_mode) && raise_after == PROBE_PT_RAISE) ? PROBE_PT_STOW : raise_after;
-    const bool big_raise = raise_type == PROBE_PT_BIG_RAISE;
-    if (big_raise || raise_type == PROBE_PT_RAISE)
-      do_z_clearance(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES));
-    else if (raise_type == PROBE_PT_STOW || raise_type == PROBE_PT_LAST_STOW)
-      if (stow()) measured_z = NAN;   // Error on stow?
+    switch (raise_type) {
+      default: break;
+      case PROBE_PT_RAISE:
+        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+        break;
+      case PROBE_PT_STOW: case PROBE_PT_LAST_STOW:
+        if (stow()) measured_z = NAN;   // Error on stow?
+        break;
+    }
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   // If any error occurred stow the probe and set an alert
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)

commit 06cfd9c54af1537adf458a719b840cd501395278
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Mar 22 02:15:51 2023 +0200

    ‚ú® PROBING_TOOL (#24411)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d48dc1eb1c..25581922f6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -189,87 +189,87 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, homing_feedrate(Z_AXIS));
     do_blocking_move_to_z(oldz, homing_feedrate(Z_AXIS));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
   inline void run_deploy_moves() {
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t deploy_1 = Z_PROBE_ALLEN_KEY_DEPLOY_1;
       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_2
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t deploy_2 = Z_PROBE_ALLEN_KEY_DEPLOY_2;
       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t deploy_3 = Z_PROBE_ALLEN_KEY_DEPLOY_3;
       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_4
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t deploy_4 = Z_PROBE_ALLEN_KEY_DEPLOY_4;
       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_5
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t deploy_5 = Z_PROBE_ALLEN_KEY_DEPLOY_5;
       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
 
   inline void run_stow_moves() {
     #ifdef Z_PROBE_ALLEN_KEY_STOW_1
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t stow_1 = Z_PROBE_ALLEN_KEY_STOW_1;
       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_2
       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t stow_2 = Z_PROBE_ALLEN_KEY_STOW_2;
       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_3
       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t stow_3 = Z_PROBE_ALLEN_KEY_STOW_3;
       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_4
       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t stow_4 = Z_PROBE_ALLEN_KEY_STOW_4;
       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_5
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
+        #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0f
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #elif ENABLED(MAG_MOUNTED_PROBE)
 
   typedef struct { float fr_mm_min; xyz_pos_t where; } mag_probe_move_t;
 
@@ -348,21 +348,22 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
-  if (offset.z < 0) z_dest -= offset.z;
+  const float zoffs = DIFF_TERN(HAS_HOTEND_OFFSET, offset.z, hotend_offset[active_extruder].z);
+  if (zoffs < 0) z_dest -= zoffs;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
@@ -707,44 +708,46 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
+  const float zoffs = SUM_TERN(HAS_HOTEND_OFFSET, -offset.z, hotend_offset[active_extruder].z);
+
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
-    const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
-               early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
+    const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),          // No probe trigger?
+               early_fail = (scheck && current_position.z > zoffs + clearance);   // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_ECHOPGM_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
         if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
         if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
         DEBUG_EOL();
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? zoffs + Z_PROBE_LOW_POINT : -10.0f;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
@@ -752,21 +755,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     const float first_probe_z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_z_clearance(current_position.z + Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0f + (zoffs > 0 ? zoffs : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
         do_z_clearance(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
@@ -840,40 +843,69 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
-    const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
+    const float measured_z = (z2 * 3.0f + first_probe_z * 2.0f) * 0.2f;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position.z;
 
   #endif
 
-  return measured_z;
+  return DIFF_TERN(HAS_HOTEND_OFFSET, measured_z, hotend_offset[active_extruder].z);
 }
 
+#if DO_TOOLCHANGE_FOR_PROBING
+
+  #include "tool_change.h"
+
+  /**
+   * Switches to the appropriate tool (PROBING_TOOL) for probing (probing = true), and switches
+   * back to the old tool when probing = false. Uses statics to avoid unnecessary checks and to
+   * cache the previous tool, so always call with false after calling with true.
+   */
+  void Probe::use_probing_tool(const bool probing/*=true*/) {
+    static uint8_t old_tool;
+    static bool old_state = false;
+    if (probing == old_state) return;
+    old_state = probing;
+    if (probing) old_tool = active_extruder;
+    const uint8_t tool = probing ? PROBING_TOOL : old_tool;
+    if (tool != active_extruder)
+      tool_change(tool, ENABLED(PROBE_TOOLCHANGE_NO_MOVE));
+  }
+
+#endif
+
 /**
+ * - Switch to PROBING_TOOL if necessary
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
+ * - Revert to previous tool
+ *
+ * A batch of multiple probing operations should always be preceded by use_probing_tool() invocation
+ * and succeeded by use_probing_tool(false), in order to avoid multiple tool changes and to end up
+ * with the previously active tool.
+ *
  */
 float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
@@ -892,21 +924,23 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = NUM_AXIS_ARRAY(
     rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, safe_z), safe_z),
     current_position.i, current_position.j, current_position.k,
     current_position.u, current_position.v, current_position.w
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
-  if (probe_relative) npos -= offset_xy;  // Get the nozzle position
+
+  if (probe_relative) // Get the nozzle position, adjust for active hotend if not 0
+    npos -= DIFF_TERN(HAS_HOTEND_OFFSET, offset_xy, xy_pos_t(hotend_offset[active_extruder]));
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   #if ENABLED(BD_SENSOR)
     return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
   #endif
 
   float measured_z = NAN;
   if (!deploy()) {
@@ -931,20 +965,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
   // If any error occurred stow the probe and set an alert
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
   DEBUG_ECHOLNPGM("measured_z: ", measured_z);
+
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow

commit fd36e69bd23b60ef8edb0848f219a5ca65dae181
Author: FilippoR <filippo.rossoni@gmail.com>
Date:   Sun Mar 19 09:55:34 2023 +0100

    ‚ú® Z_SERVO_DEACTIVATE_AFTER_STOW (#24215)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ea17eee6ee..d48dc1eb1c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -396,27 +396,30 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 
+    // i.e., deploy ? DEPLOY_Z_SERVO() : STOW_Z_SERVO();
     servo[Z_PROBE_SERVO_NR].move(servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
     #ifdef Z_SERVO_MEASURE_ANGLE
       // After deploy move back to the measure angle...
-      if (deploy) MOVE_SERVO(Z_PROBE_SERVO_NR, Z_SERVO_MEASURE_ANGLE);
+      if (deploy) servo[Z_PROBE_SERVO_NR].move(Z_SERVO_MEASURE_ANGLE);
     #endif
 
+    if (TERN0(Z_SERVO_DEACTIVATE_AFTER_STOW, !deploy)) servo[Z_PROBE_SERVO_NR].detach();
+
   #elif ANY(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY, MAG_MOUNTED_PROBE)
 
     deploy ? run_deploy_moves() : run_stow_moves();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
@@ -943,20 +946,22 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      */
     STOW_Z_SERVO();
+
+    TERN_(Z_SERVO_DEACTIVATE_AFTER_STOW, servo[Z_PROBE_SERVO_NR].detach());
   }
 
 #endif // HAS_Z_SERVO_PROBE
 
 #if HAS_DELTA_SENSORLESS_PROBING
 
   /**
    * Set the sensorless Z offset
    */
   void Probe::set_offset_sensorless_adj(const_float_t sz) {

commit 5abfc6160f57f5e37c7e88bead4b5eef88832a9e
Author: Farva42 <100859196+Farva42@users.noreply.github.com>
Date:   Sat Mar 18 04:14:51 2023 -0600

    üö∏ Fix / improve LCD_BED_TRAMMING (#25425)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index da69b725b9..ea17eee6ee 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -493,25 +493,25 @@ void Probe::probe_error_stop() {
   #endif
   SERIAL_ECHOLNPGM(STR_STOP_POST);
   stop();
 }
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
-bool Probe::set_deployed(const bool deploy) {
+bool Probe::set_deployed(const bool deploy, const bool no_return/*=false*/) {
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
-    DEBUG_ECHOLNPGM("deploy: ", deploy);
+    DEBUG_ECHOLNPGM("deploy=", deploy, " no_return=", no_return);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
@@ -550,21 +550,22 @@ bool Probe::set_deployed(const bool deploy) {
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
 
   // If preheating is required before any probing...
   TERN_(PREHEAT_BEFORE_PROBING, if (deploy) preheat_for_probing(PROBING_NOZZLE_TEMP, PROBING_BED_TEMP));
 
-  do_blocking_move_to(old_xy);
+  if (!no_return) do_blocking_move_to(old_xy); // Return to the original location unless handled externally
+
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 /**
  * @brief Move down until the probe triggers or the low limit is reached
  *        Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s

commit 88da531e5d873c342a4a6625d9cb57adb2644cce
Author: James Gilliland <neclimdul@gmail.com>
Date:   Sat Mar 18 03:30:30 2023 -0500

    üö∏ Improve Z-Probe raise for deploy (#25498)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index faa3aec03d..da69b725b9 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -140,21 +140,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #elif ENABLED(MAGLEV4)
 
   // Write trigger pin to release the probe
   inline void maglev_deploy() {
     WRITE(MAGLEV_TRIGGER_PIN, HIGH);
     delay(MAGLEV_TRIGGER_DELAY);
     WRITE(MAGLEV_TRIGGER_PIN, LOW);
   }
 
-  inline void maglev_idle() { do_blocking_move_to_z(10); }
+  inline void maglev_idle() { do_z_clearance(10); }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   inline void run_deploy_moves() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
       #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
@@ -742,31 +742,31 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
-    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
+    do_z_clearance(current_position.z + Z_CLEARANCE_MULTI_PROBE);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
-        do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, z_probe_fast_mm_s);
+        do_z_clearance(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
@@ -803,21 +803,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING > 0
             < TOTAL_PROBING - 1
           #endif
-        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
+        ) do_z_clearance(z + Z_CLEARANCE_MULTI_PROBE);
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
     #if EXTRA_PROBING > 0
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
@@ -871,27 +871,30 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     DEBUG_ECHOLNPGM(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if ENABLED(BLTOUCH)
-    if (bltouch.high_speed_mode && bltouch.triggered())
-      bltouch._reset();
+    // Reset a BLTouch in HS mode if already triggered
+    if (bltouch.high_speed_mode && bltouch.triggered()) bltouch._reset();
   #endif
 
+  // Use a safe Z height for the XY move
+  const float safe_z = _MAX(current_position.z, SUM_TERN(BLTOUCH, Z_CLEARANCE_BETWEEN_PROBES, bltouch.z_extra_clearance()));
+
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = NUM_AXIS_ARRAY(
-    rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z),
+    rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, safe_z), safe_z),
     current_position.i, current_position.j, current_position.k,
     current_position.u, current_position.v, current_position.w
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
@@ -900,31 +903,36 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   #if ENABLED(BD_SENSOR)
     return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
   #endif
 
   float measured_z = NAN;
   if (!deploy()) {
     measured_z = run_z_probe(sanity_check) + offset.z;
     TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
     TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
   }
+
+  // Deploy succeeded and a successful measurement was done.
+  // Raise and/or stow the probe depending on 'raise_after' and settings.
   if (!isnan(measured_z)) {
-    const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
-    if (big_raise || raise_after == PROBE_PT_RAISE)
-      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
-    else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
+    const ProbePtRaise raise_type = (TERN0(BLTOUCH, !bltouch.high_speed_mode) && raise_after == PROBE_PT_RAISE) ? PROBE_PT_STOW : raise_after;
+    const bool big_raise = raise_type == PROBE_PT_BIG_RAISE;
+    if (big_raise || raise_type == PROBE_PT_RAISE)
+      do_z_clearance(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES));
+    else if (raise_type == PROBE_PT_STOW || raise_type == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
+  // If any error occurred stow the probe and set an alert
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
   DEBUG_ECHOLNPGM("measured_z: ", measured_z);
   return measured_z;
 }

commit 10983d0cfe3e353ba465cfcadf8aeb51327f1197
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 15 00:29:37 2023 -0500

    üé® Misc. tramming menu cleanup (#25519)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7daafd1139..faa3aec03d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -521,21 +521,21 @@ bool Probe::set_deployed(const bool deploy) {
   if (z_raise_wanted)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       probe_error_stop();
       return true;
     }
   #endif
 
-  const xy_pos_t old_xy = current_position;
+  const xy_pos_t old_xy = current_position;        // Remember location before probe deployment
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
 
     // Only deploy/stow if needed
     if (PROBE_TRIGGERED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
@@ -618,21 +618,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   const bool probe_triggered =
     #if HAS_DELTA_SENSORLESS_PROBING
       endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
   // Offset sensorless probing
   #if HAS_DELTA_SENSORLESS_PROBING
-    if (probe_triggered) probe.refresh_largest_sensorless_adj();
+    if (probe_triggered) refresh_largest_sensorless_adj();
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
       if (test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);

commit db5ff20b72c8769865f1f7a23d3ce5074b0c997e
Author: Kurt Haenen <Misterke@users.noreply.github.com>
Date:   Thu Mar 9 07:20:30 2023 +0100

    ‚ú® Extra Z Servo Probe options (#21427)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f0a3c8584b..7daafd1139 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -398,20 +398,25 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     dock_sled(!deploy);
 
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 
     servo[Z_PROBE_SERVO_NR].move(servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
+    #ifdef Z_SERVO_MEASURE_ANGLE
+      // After deploy move back to the measure angle...
+      if (deploy) MOVE_SERVO(Z_PROBE_SERVO_NR, Z_SERVO_MEASURE_ANGLE);
+    #endif
+
   #elif ANY(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY, MAG_MOUNTED_PROBE)
 
     deploy ? run_deploy_moves() : run_stow_moves();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
@@ -575,25 +580,30 @@ bool Probe::set_deployed(const bool deploy) {
 bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
+
   #if ENABLED(BLTOUCH)
     if (!bltouch.high_speed_mode && bltouch.deploy())
       return true; // Deploy in LOW SPEED MODE on every probe action
   #endif
 
+  #if HAS_Z_SERVO_PROBE && (ENABLED(Z_SERVO_INTERMEDIATE_STOW) || defined(Z_SERVO_MEASURE_ANGLE))
+    probe_specific_action(true);  //  Always re-deploy in this case
+  #endif
+
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);   // All machines will check Z-DIAG for stall
     endstops.set_homing_current(true);                                            // The "homing" current also applies to probing
     endstops.enable(true);
@@ -629,20 +639,24 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     #endif
     if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
     endstops.set_homing_current(false);
   #endif
 
   #if ENABLED(BLTOUCH)
     if (probe_triggered && !bltouch.high_speed_mode && bltouch.stow())
       return true; // Stow in LOW SPEED MODE on every trigger
   #endif
 
+  #if BOTH(HAS_Z_SERVO_PROBE, Z_SERVO_INTERMEDIATE_STOW)
+    probe_specific_action(false);  //  Always stow
+  #endif
+
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
   return !probe_triggered;

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index fa92ae1fb5..f0a3c8584b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -145,21 +145,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     WRITE(MAGLEV_TRIGGER_PIN, HIGH);
     delay(MAGLEV_TRIGGER_DELAY);
     WRITE(MAGLEV_TRIGGER_PIN, LOW);
   }
 
   inline void maglev_idle() { do_blocking_move_to_z(10); }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
-  inline void run_deploy_moves_script() {
+  inline void run_deploy_moves() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
       #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
@@ -176,30 +176,31 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
   }
 
   // Move down to the bed to stow the probe
-  inline void run_stow_moves_script() {
-    const xyz_pos_t oldpos = current_position;
+  // TODO: Handle cases where it would be a bad idea to move down.
+  inline void run_stow_moves() {
+    const float oldz = current_position.z;
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, homing_feedrate(Z_AXIS));
-    do_blocking_move_to(oldpos, homing_feedrate(Z_AXIS));
+    do_blocking_move_to_z(oldz, homing_feedrate(Z_AXIS));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
-  inline void run_deploy_moves_script() {
+  inline void run_deploy_moves() {
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t deploy_1 = Z_PROBE_ALLEN_KEY_DEPLOY_1;
       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_2
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
@@ -223,21 +224,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_5
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t deploy_5 = Z_PROBE_ALLEN_KEY_DEPLOY_5;
       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
 
-  inline void run_stow_moves_script() {
+  inline void run_stow_moves() {
     #ifdef Z_PROBE_ALLEN_KEY_STOW_1
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t stow_1 = Z_PROBE_ALLEN_KEY_STOW_1;
       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_2
       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
@@ -265,21 +266,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #elif ENABLED(MAG_MOUNTED_PROBE)
 
   typedef struct { float fr_mm_min; xyz_pos_t where; } mag_probe_move_t;
 
-  inline void run_deploy_moves_script() {
+  inline void run_deploy_moves() {
     #ifdef MAG_MOUNTED_DEPLOY_1
       constexpr mag_probe_move_t deploy_1 = MAG_MOUNTED_DEPLOY_1;
       do_blocking_move_to(deploy_1.where, MMM_TO_MMS(deploy_1.fr_mm_min));
     #endif
     #ifdef MAG_MOUNTED_DEPLOY_2
       constexpr mag_probe_move_t deploy_2 = MAG_MOUNTED_DEPLOY_2;
       do_blocking_move_to(deploy_2.where, MMM_TO_MMS(deploy_2.fr_mm_min));
     #endif
     #ifdef MAG_MOUNTED_DEPLOY_3
       constexpr mag_probe_move_t deploy_3 = MAG_MOUNTED_DEPLOY_3;
@@ -288,21 +289,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #ifdef MAG_MOUNTED_DEPLOY_4
       constexpr mag_probe_move_t deploy_4 = MAG_MOUNTED_DEPLOY_4;
       do_blocking_move_to(deploy_4.where, MMM_TO_MMS(deploy_4.fr_mm_min));
     #endif
     #ifdef MAG_MOUNTED_DEPLOY_5
       constexpr mag_probe_move_t deploy_5 = MAG_MOUNTED_DEPLOY_5;
       do_blocking_move_to(deploy_5.where, MMM_TO_MMS(deploy_5.fr_mm_min));
     #endif
   }
 
-  inline void run_stow_moves_script() {
+  inline void run_stow_moves() {
     #ifdef MAG_MOUNTED_STOW_1
       constexpr mag_probe_move_t stow_1 = MAG_MOUNTED_STOW_1;
       do_blocking_move_to(stow_1.where, MMM_TO_MMS(stow_1.fr_mm_min));
     #endif
     #ifdef MAG_MOUNTED_STOW_2
       constexpr mag_probe_move_t stow_2 = MAG_MOUNTED_STOW_2;
       do_blocking_move_to(stow_2.where, MMM_TO_MMS(stow_2.fr_mm_min));
     #endif
     #ifdef MAG_MOUNTED_STOW_3
       constexpr mag_probe_move_t stow_3 = MAG_MOUNTED_STOW_3;
@@ -399,21 +400,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 
     servo[Z_PROBE_SERVO_NR].move(servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif ANY(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY, MAG_MOUNTED_PROBE)
 
-    deploy ? run_deploy_moves_script() : run_stow_moves_script();
+    deploy ? run_deploy_moves() : run_stow_moves();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif

commit 42f8cc4606eedeb800c55f5453b114fedc4353b7
Author: Mark <niujl123@sina.com>
Date:   Fri Aug 26 06:50:03 2022 +0800

    üêõ Fix Bed Distance Sensor reading (#24649)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3baef31479..fa92ae1fb5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -875,21 +875,23 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
-  TERN_(BD_SENSOR, return bdl.read());
+  #if ENABLED(BD_SENSOR)
+    return current_position.z - bdl.read(); // Difference between Z-home-relative Z and sensor reading
+  #endif
 
   float measured_z = NAN;
   if (!deploy()) {
     measured_z = run_z_probe(sanity_check) + offset.z;
     TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
     TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
   }
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)

commit 83320f1052dd09bff7aae789372e7bffccbced97
Author: Mark <niujl123@sina.com>
Date:   Sat Aug 6 14:14:58 2022 +0800

    ‚ú® Bed Distance Sensor (#24554)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cc6b521fe1..3baef31479 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -37,20 +37,24 @@
 
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 
 #include "../MarlinCore.h" // for stop(), disable_e_steppers(), wait_for_user_response()
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(BD_SENSOR)
+  #include "../feature/bedlevel/bdl/bdl.h"
+#endif
+
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   abc_float_t offset_sensorless_adj{0};
   float largest_sensorless_adj = 0;
 #endif
 
 #if EITHER(HAS_QUIET_PROBING, USE_SENSORLESS)
@@ -871,20 +875,22 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
+  TERN_(BD_SENSOR, return bdl.read());
+
   float measured_z = NAN;
   if (!deploy()) {
     measured_z = run_z_probe(sanity_check) + offset.z;
     TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
     TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
   }
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);

commit 2dc543c4f58c39e6cdf7a4a001c15100268cdf46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 13 21:22:53 2022 -0500

    üé® ANY => EITHER

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index afe5ba7a74..cc6b521fe1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -46,21 +46,21 @@
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   abc_float_t offset_sensorless_adj{0};
   float largest_sensorless_adj = 0;
 #endif
 
-#if ANY(HAS_QUIET_PROBING, USE_SENSORLESS)
+#if EITHER(HAS_QUIET_PROBING, USE_SENSORLESS)
   #include "stepper/indirection.h"
   #if BOTH(HAS_QUIET_PROBING, PROBING_ESTEPPERS_OFF)
     #include "stepper.h"
   #endif
   #if USE_SENSORLESS
     #include "../feature/tmc_util.h"
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       #include "planner.h"
     #endif
   #endif

commit 5979aab1c7cf96d91b89775ae988e59e3ff40106
Author: Farva42 <100859196+Farva42@users.noreply.github.com>
Date:   Wed Jul 6 19:40:09 2022 -0600

    ‚ú® MAG_MOUNTED_PROBE (#24420)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ed8d4a1429..afe5ba7a74 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -257,21 +257,71 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_5
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
-#endif // Z_PROBE_ALLEN_KEY
+#elif ENABLED(MAG_MOUNTED_PROBE)
+
+  typedef struct { float fr_mm_min; xyz_pos_t where; } mag_probe_move_t;
+
+  inline void run_deploy_moves_script() {
+    #ifdef MAG_MOUNTED_DEPLOY_1
+      constexpr mag_probe_move_t deploy_1 = MAG_MOUNTED_DEPLOY_1;
+      do_blocking_move_to(deploy_1.where, MMM_TO_MMS(deploy_1.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_DEPLOY_2
+      constexpr mag_probe_move_t deploy_2 = MAG_MOUNTED_DEPLOY_2;
+      do_blocking_move_to(deploy_2.where, MMM_TO_MMS(deploy_2.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_DEPLOY_3
+      constexpr mag_probe_move_t deploy_3 = MAG_MOUNTED_DEPLOY_3;
+      do_blocking_move_to(deploy_3.where, MMM_TO_MMS(deploy_3.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_DEPLOY_4
+      constexpr mag_probe_move_t deploy_4 = MAG_MOUNTED_DEPLOY_4;
+      do_blocking_move_to(deploy_4.where, MMM_TO_MMS(deploy_4.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_DEPLOY_5
+      constexpr mag_probe_move_t deploy_5 = MAG_MOUNTED_DEPLOY_5;
+      do_blocking_move_to(deploy_5.where, MMM_TO_MMS(deploy_5.fr_mm_min));
+    #endif
+  }
+
+  inline void run_stow_moves_script() {
+    #ifdef MAG_MOUNTED_STOW_1
+      constexpr mag_probe_move_t stow_1 = MAG_MOUNTED_STOW_1;
+      do_blocking_move_to(stow_1.where, MMM_TO_MMS(stow_1.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_STOW_2
+      constexpr mag_probe_move_t stow_2 = MAG_MOUNTED_STOW_2;
+      do_blocking_move_to(stow_2.where, MMM_TO_MMS(stow_2.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_STOW_3
+      constexpr mag_probe_move_t stow_3 = MAG_MOUNTED_STOW_3;
+      do_blocking_move_to(stow_3.where, MMM_TO_MMS(stow_3.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_STOW_4
+      constexpr mag_probe_move_t stow_4 = MAG_MOUNTED_STOW_4;
+      do_blocking_move_to(stow_4.where, MMM_TO_MMS(stow_4.fr_mm_min));
+    #endif
+    #ifdef MAG_MOUNTED_STOW_5
+      constexpr mag_probe_move_t stow_5 = MAG_MOUNTED_STOW_5;
+      do_blocking_move_to(stow_5.where, MMM_TO_MMS(stow_5.fr_mm_min));
+    #endif
+  }
+
+#endif // MAG_MOUNTED_PROBE
 
 #if HAS_QUIET_PROBING
 
   #ifndef DELAY_BEFORE_PROBING
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
@@ -343,21 +393,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     dock_sled(!deploy);
 
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 
     servo[Z_PROBE_SERVO_NR].move(servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
-  #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
+  #elif ANY(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY, MAG_MOUNTED_PROBE)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);

commit a88e8472954cf57dab1008f6e80a103347e3731e
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jul 6 08:35:08 2022 -0500

    üêõ Fix Sensorless Probing compile (#24455)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 2649aa41b6..ed8d4a1429 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -41,20 +41,25 @@
 #include "../MarlinCore.h" // for stop(), disable_e_steppers(), wait_for_user_response()
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
+#if ENABLED(SENSORLESS_PROBING)
+  abc_float_t offset_sensorless_adj{0};
+  float largest_sensorless_adj = 0;
+#endif
+
 #if ANY(HAS_QUIET_PROBING, USE_SENSORLESS)
   #include "stepper/indirection.h"
   #if BOTH(HAS_QUIET_PROBING, PROBING_ESTEPPERS_OFF)
     #include "stepper.h"
   #endif
   #if USE_SENSORLESS
     #include "../feature/tmc_util.h"
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       #include "planner.h"
     #endif
@@ -860,83 +865,45 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      */
     STOW_Z_SERVO();
   }
 
 #endif // HAS_Z_SERVO_PROBE
 
-#if USE_SENSORLESS
-
-  sensorless_t stealth_states { false };
-
-  /**
-   * Disable stealthChop if used. Enable diag1 pin on driver.
-   */
-  void Probe::enable_stallguard_diag1() {
-    #if ENABLED(SENSORLESS_PROBING)
-      #if HAS_DELTA_SENSORLESS_PROBING
-        stealth_states.x = tmc_enable_stallguard(stepperX);
-        stealth_states.y = tmc_enable_stallguard(stepperY);
-      #endif
-      stealth_states.z = tmc_enable_stallguard(stepperZ);
-      endstops.enable(true);
-    #endif
-  }
-
-  /**
-   * Re-enable stealthChop if used. Disable diag1 pin on driver.
-   */
-  void Probe::disable_stallguard_diag1() {
-    #if ENABLED(SENSORLESS_PROBING)
-      endstops.not_homing();
-      #if HAS_DELTA_SENSORLESS_PROBING
-        tmc_disable_stallguard(stepperX, stealth_states.x);
-        tmc_disable_stallguard(stepperY, stealth_states.y);
-      #endif
-      tmc_disable_stallguard(stepperZ, stealth_states.z);
-    #endif
-  }
+#if HAS_DELTA_SENSORLESS_PROBING
 
   /**
    * Set the sensorless Z offset
    */
   void Probe::set_offset_sensorless_adj(const_float_t sz) {
-    #if ENABLED(SENSORLESS_PROBING)
-      DEBUG_SECTION(pso, "Probe::set_offset_sensorless_adj", true);
-      #if HAS_DELTA_SENSORLESS_PROBING
-        if (test_sensitivity.x) offset_sensorless_adj.a = sz;
-        if (test_sensitivity.y) offset_sensorless_adj.b = sz;
-      #endif
-      if (test_sensitivity.z) offset_sensorless_adj.c = sz;
-    #endif
+    DEBUG_SECTION(pso, "Probe::set_offset_sensorless_adj", true);
+    if (test_sensitivity.x) offset_sensorless_adj.a = sz;
+    if (test_sensitivity.y) offset_sensorless_adj.b = sz;
+    if (test_sensitivity.z) offset_sensorless_adj.c = sz;
   }
 
   /**
    * Refresh largest_sensorless_adj based on triggered endstops
    */
   void Probe::refresh_largest_sensorless_adj() {
-    #if ENABLED(SENSORLESS_PROBING)
-      DEBUG_SECTION(rso, "Probe::refresh_largest_sensorless_adj", true);
-      largest_sensorless_adj = -3;                                             // A reference away from any real probe height
-      #if HAS_DELTA_SENSORLESS_PROBING
-        if (TEST(endstops.state(), X_MAX)) {
-          NOLESS(largest_sensorless_adj, offset_sensorless_adj.a);
-          DEBUG_ECHOLNPGM("Endstop_X: ", largest_sensorless_adj, " TowerX");
-        }
-        if (TEST(endstops.state(), Y_MAX)) {
-          NOLESS(largest_sensorless_adj, offset_sensorless_adj.b);
-          DEBUG_ECHOLNPGM("Endstop_Y: ", largest_sensorless_adj, " TowerY");
-        }
-      #endif
-      if (TEST(endstops.state(), Z_MAX)) {
-        NOLESS(largest_sensorless_adj, offset_sensorless_adj.c);
-        DEBUG_ECHOLNPGM("Endstop_Z: ", largest_sensorless_adj, " TowerZ");
-      }
-    #endif
+    DEBUG_SECTION(rso, "Probe::refresh_largest_sensorless_adj", true);
+    largest_sensorless_adj = -3;  // A reference away from any real probe height
+    if (TEST(endstops.state(), X_MAX)) {
+      NOLESS(largest_sensorless_adj, offset_sensorless_adj.a);
+      DEBUG_ECHOLNPGM("Endstop_X: ", largest_sensorless_adj, " TowerX");
+    }
+    if (TEST(endstops.state(), Y_MAX)) {
+      NOLESS(largest_sensorless_adj, offset_sensorless_adj.b);
+      DEBUG_ECHOLNPGM("Endstop_Y: ", largest_sensorless_adj, " TowerY");
+    }
+    if (TEST(endstops.state(), Z_MAX)) {
+      NOLESS(largest_sensorless_adj, offset_sensorless_adj.c);
+      DEBUG_ECHOLNPGM("Endstop_Z: ", largest_sensorless_adj, " TowerZ");
+    }
   }
 
-#endif // SENSORLESS_PROBING || SENSORLESS_HOMING
+#endif
 
 #endif // HAS_BED_PROBE

commit e4e6abe5af0f97ff5cb0c9334cb298d3584968e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 9 00:51:08 2022 -0500

    üßë‚Äçüíª Remove servo macros

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 66e1c85028..2649aa41b6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -336,21 +336,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 
-    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+    servo[Z_PROBE_SERVO_NR].move(servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index dc97971a25..66e1c85028 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -96,21 +96,21 @@
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
   const xy_pos_t &Probe::offset_xy = Probe::offset;
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
-  Probe::sense_bool_t Probe::test_sensitivity;
+  Probe::sense_bool_t Probe::test_sensitivity = { true, true, true };
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
@@ -524,53 +524,58 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   #endif
   #if ENABLED(BLTOUCH)
     if (!bltouch.high_speed_mode && bltouch.deploy())
       return true; // Deploy in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
-      if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
+      if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX); // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
-    if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
+    if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);   // All machines will check Z-DIAG for stall
+    endstops.set_homing_current(true);                                            // The "homing" current also applies to probing
     endstops.enable(true);
-    set_homing_current(true);                                 // The "homing" current also applies to probing
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if HAS_DELTA_SENSORLESS_PROBING
       endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
+  // Offset sensorless probing
+  #if HAS_DELTA_SENSORLESS_PROBING
+    if (probe_triggered) probe.refresh_largest_sensorless_adj();
+  #endif
+
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
       if (test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
-    set_homing_current(false);
+    endstops.set_homing_current(false);
   #endif
 
   #if ENABLED(BLTOUCH)
     if (probe_triggered && !bltouch.high_speed_mode && bltouch.stow())
       return true; // Stow in LOW SPEED MODE on every trigger
   #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
@@ -659,22 +664,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
-    const float first_probe_z = current_position.z;
-
+    const float first_probe_z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
@@ -702,21 +706,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
                        sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
-      const float z = current_position.z;
+      const float z = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
@@ -753,21 +757,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       // Return the average value of all remaining probes.
       LOOP_S_LE_N(i, min_avg_idx, max_avg_idx)
         probes_z_sum += probes[i];
 
     #endif
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
-    const float z2 = current_position.z;
+    const float z2 = DIFF_TERN(HAS_DELTA_SENSORLESS_PROBING, current_position.z, largest_sensorless_adj);
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position.z;
@@ -836,21 +840,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
-
+  DEBUG_ECHOLNPGM("measured_z: ", measured_z);
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
@@ -889,71 +893,50 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
       endstops.not_homing();
       #if HAS_DELTA_SENSORLESS_PROBING
         tmc_disable_stallguard(stepperX, stealth_states.x);
         tmc_disable_stallguard(stepperY, stealth_states.y);
       #endif
       tmc_disable_stallguard(stepperZ, stealth_states.z);
     #endif
   }
 
   /**
-   * Change the current in the TMC drivers to N##_CURRENT_HOME. And we save the current configuration of each TMC driver.
+   * Set the sensorless Z offset
    */
-  void Probe::set_homing_current(const bool onoff) {
-    #define _defined(N) defined(N)
-    #define HAS_CURRENT_HOME(N) (N##_CURRENT_HOME > 0 && N##_CURRENT_HOME != N##_CURRENT)
-    #define _HOME_ELEM(N) HAS_CURRENT_HOME(N) ||
-    #if MAIN_AXIS_MAP(_HOME_ELEM) 0
-      #if ENABLED(DELTA)
-        static int16_t saved_current_X, saved_current_Y;
-      #endif
-      #if HAS_CURRENT_HOME(Z)
-        static int16_t saved_current_Z;
+  void Probe::set_offset_sensorless_adj(const_float_t sz) {
+    #if ENABLED(SENSORLESS_PROBING)
+      DEBUG_SECTION(pso, "Probe::set_offset_sensorless_adj", true);
+      #if HAS_DELTA_SENSORLESS_PROBING
+        if (test_sensitivity.x) offset_sensorless_adj.a = sz;
+        if (test_sensitivity.y) offset_sensorless_adj.b = sz;
       #endif
-      #if ((ENABLED(DELTA) && (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y))) || HAS_CURRENT_HOME(Z))
-        auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
-          if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
-        };
+      if (test_sensitivity.z) offset_sensorless_adj.c = sz;
+    #endif
+  }
+
+  /**
+   * Refresh largest_sensorless_adj based on triggered endstops
+   */
+  void Probe::refresh_largest_sensorless_adj() {
+    #if ENABLED(SENSORLESS_PROBING)
+      DEBUG_SECTION(rso, "Probe::refresh_largest_sensorless_adj", true);
+      largest_sensorless_adj = -3;                                             // A reference away from any real probe height
+      #if HAS_DELTA_SENSORLESS_PROBING
+        if (TEST(endstops.state(), X_MAX)) {
+          NOLESS(largest_sensorless_adj, offset_sensorless_adj.a);
+          DEBUG_ECHOLNPGM("Endstop_X: ", largest_sensorless_adj, " TowerX");
+        }
+        if (TEST(endstops.state(), Y_MAX)) {
+          NOLESS(largest_sensorless_adj, offset_sensorless_adj.b);
+          DEBUG_ECHOLNPGM("Endstop_Y: ", largest_sensorless_adj, " TowerY");
+        }
       #endif
-      if (onoff) {
-        #if ENABLED(DELTA)
-          #if HAS_CURRENT_HOME(X)
-            saved_current_X = stepperX.getMilliamps();
-            stepperX.rms_current(X_CURRENT_HOME);
-            debug_current_on(PSTR("X"), saved_current_X, X_CURRENT_HOME);
-          #endif
-          #if HAS_CURRENT_HOME(Y)
-            saved_current_Y = stepperY.getMilliamps();
-            stepperY.rms_current(Y_CURRENT_HOME);
-            debug_current_on(PSTR("Y"), saved_current_Y, Y_CURRENT_HOME);
-          #endif
-        #endif
-        #if HAS_CURRENT_HOME(Z)
-          saved_current_Z = stepperZ.getMilliamps();
-          stepperZ.rms_current(Z_CURRENT_HOME);
-          debug_current_on(PSTR("Z"), saved_current_Z, Z_CURRENT_HOME);
-        #endif
-        TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(true));
-      }
-      else {
-        #if ENABLED(DELTA)
-          #if HAS_CURRENT_HOME(X)
-            stepperX.rms_current(saved_current_X);
-            debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_X);
-          #endif
-          #if HAS_CURRENT_HOME(Y)
-            stepperY.rms_current(saved_current_Y);
-            debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_Y);
-          #endif
-        #endif
-        #if HAS_CURRENT_HOME(Z)
-          stepperZ.rms_current(saved_current_Z);
-          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_Z);
-        #endif
-        TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(false));
+      if (TEST(endstops.state(), Z_MAX)) {
+        NOLESS(largest_sensorless_adj, offset_sensorless_adj.c);
+        DEBUG_ECHOLNPGM("Endstop_Z: ", largest_sensorless_adj, " TowerZ");
       }
     #endif
   }
 
 #endif // SENSORLESS_PROBING || SENSORLESS_HOMING
 
 #endif // HAS_BED_PROBE

commit 1f322b565f409ab5068e225a4d9a929907c966f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 26 18:31:05 2022 -0500

    ‚ôªÔ∏è More updates for multi-axis

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 91c100bd72..dc97971a25 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -267,28 +267,28 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
     TERN_(PROBING_ESTEPPERS_OFF, if (dopause) stepper.disable_e_steppers());
     #if ENABLED(PROBING_STEPPERS_OFF) && DISABLED(DELTA)
       static uint8_t old_trusted;
       if (dopause) {
-        old_trusted = axis_trusted;
+        old_trusted = axes_trusted;
         stepper.disable_axis(X_AXIS);
         stepper.disable_axis(Y_AXIS);
       }
       else {
         if (TEST(old_trusted, X_AXIS)) stepper.enable_axis(X_AXIS);
         if (TEST(old_trusted, Y_AXIS)) stepper.enable_axis(Y_AXIS);
-        axis_trusted = old_trusted;
+        axes_trusted = old_trusted;
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */

commit c5126de559719ebdaf4475b0db4ab21c26b90a1a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 16:08:29 2022 -0500

    üßë‚Äçüíª MAP macro for axis lists, etc. (#24191)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 30cd8d5162..91c100bd72 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -892,22 +892,24 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
         tmc_disable_stallguard(stepperY, stealth_states.y);
       #endif
       tmc_disable_stallguard(stepperZ, stealth_states.z);
     #endif
   }
 
   /**
    * Change the current in the TMC drivers to N##_CURRENT_HOME. And we save the current configuration of each TMC driver.
    */
   void Probe::set_homing_current(const bool onoff) {
-    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
+    #define _defined(N) defined(N)
+    #define HAS_CURRENT_HOME(N) (N##_CURRENT_HOME > 0 && N##_CURRENT_HOME != N##_CURRENT)
+    #define _HOME_ELEM(N) HAS_CURRENT_HOME(N) ||
+    #if MAIN_AXIS_MAP(_HOME_ELEM) 0
       #if ENABLED(DELTA)
         static int16_t saved_current_X, saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
         static int16_t saved_current_Z;
       #endif
       #if ((ENABLED(DELTA) && (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y))) || HAS_CURRENT_HOME(Z))
         auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
           if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
         };

commit e2353be24f2c7914c51441c2135cf2eb4cb1262d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 9 22:52:36 2022 -0500

    üé® Misc. cleanup, string optimization

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f9a64a02d3..30cd8d5162 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -408,20 +408,35 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     #endif
 
     DEBUG_EOL();
 
     TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
     TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp    > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW)) thermalManager.wait_for_bed_heating());
   }
 
 #endif
 
+/**
+ * Print an error and stop()
+ */
+void Probe::probe_error_stop() {
+  SERIAL_ERROR_START();
+  SERIAL_ECHOPGM(STR_STOP_PRE);
+  #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
+    SERIAL_ECHOPGM(STR_STOP_UNHOMED);
+  #elif ENABLED(BLTOUCH)
+    SERIAL_ECHOPGM(STR_STOP_BLTOUCH);
+  #endif
+  SERIAL_ECHOLNPGM(STR_STOP_POST);
+  stop();
+}
+
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPGM("deploy: ", deploy);
@@ -436,22 +451,21 @@ bool Probe::set_deployed(const bool deploy) {
     const bool z_raise_wanted = deploy;
   #else
     constexpr bool z_raise_wanted = true;
   #endif
 
   if (z_raise_wanted)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
-      SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
-      stop();
+      probe_error_stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
 
     // Only deploy/stow if needed
     if (PROBE_TRIGGERED() == deploy) {
@@ -477,29 +491,26 @@ bool Probe::set_deployed(const bool deploy) {
 
   // If preheating is required before any probing...
   TERN_(PREHEAT_BEFORE_PROBING, if (deploy) preheat_for_probing(PROBING_NOZZLE_TEMP, PROBING_BED_TEMP));
 
   do_blocking_move_to(old_xy);
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 /**
- * @brief Used by run_z_probe to do a single Z probe move.
+ * @brief Move down until the probe triggers or the low limit is reached
+ *        Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
- */
-
-/**
- * @brief Move down until the probe triggers or the low limit is reached
  *
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5b0bd77d0d..f9a64a02d3 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -787,23 +787,24 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     );
     DEBUG_POS("", current_position);
   }
 
   #if ENABLED(BLTOUCH)
     if (bltouch.high_speed_mode && bltouch.triggered())
       bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
-  xyz_pos_t npos = LINEAR_AXIS_ARRAY(
+  xyz_pos_t npos = NUM_AXIS_ARRAY(
     rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z),
-    current_position.i, current_position.j, current_position.k
+    current_position.i, current_position.j, current_position.k,
+    current_position.u, current_position.v, current_position.w
   );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
@@ -881,21 +882,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
       #endif
       tmc_disable_stallguard(stepperZ, stealth_states.z);
     #endif
   }
 
   /**
    * Change the current in the TMC drivers to N##_CURRENT_HOME. And we save the current configuration of each TMC driver.
    */
   void Probe::set_homing_current(const bool onoff) {
     #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z)
+    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
       #if ENABLED(DELTA)
         static int16_t saved_current_X, saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
         static int16_t saved_current_Z;
       #endif
       #if ((ENABLED(DELTA) && (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y))) || HAS_CURRENT_HOME(Z))
         auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
           if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
         };

commit 8dfdf51678a4a3975df8250bedf3489fd4835796
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:55 2022 -0500

    üé® Format, use status macros

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index c34178412f..5b0bd77d0d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -306,23 +306,23 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       OKAY_BUZZ();
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
-      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
-      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
-      TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, ds_str, FPSTR(CONTINUE_STR)));
+      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(ds_str));
+      TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, ds_str, FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1

commit 6b55eec9bbc72db2777d3ff3577f2bf1ef13a613
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:04:06 2022 -0500

    ü©π Print English to serial out

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ee6323518a..c34178412f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -304,21 +304,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       OKAY_BUZZ();
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
-      SERIAL_ECHOLNF(ds_str);
+      SERIAL_ECHOLNF(deploy ? GET_EN_TEXT_F(MSG_MANUAL_DEPLOY) : GET_EN_TEXT_F(MSG_MANUAL_STOW));
 
       TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
       TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW

commit 89a9c3a391101e4d2d8dbfbf0cdb261ad2d9592b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 16:34:58 2022 -0600

    üßë‚Äçüíª  Add standard BUZZ types

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8793ea49dc..ee6323518a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -299,22 +299,21 @@ void Probe::do_z_raise(const float z_raise) {
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
-      BUZZ(100, 659);
-      BUZZ(100, 698);
+      OKAY_BUZZ();
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
       TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    üîß DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 89d2769247..8793ea49dc 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -80,21 +80,21 @@
 #if HAS_PTC
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #if ENABLED(X_AXIS_TWIST_COMPENSATION)
   #include "../feature/x_twist.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
@@ -309,21 +309,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
+      TERN_(DWIN_LCD_PROUI, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1

commit 2e39bc30fd748b0ade7aafdab4827f942536cdcd
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Mar 2 22:13:46 2022 +0000

    üö∏ Universal X_AXIS_TWIST_COMPENSATION (#23828)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 95776ffda1..89d2769247 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -74,20 +74,24 @@
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if HAS_PTC
   #include "../feature/probe_temp_comp.h"
 #endif
 
+#if ENABLED(X_AXIS_TWIST_COMPENSATION)
+  #include "../feature/x_twist.h"
+#endif
+
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
@@ -801,20 +805,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
   if (!deploy()) {
     measured_z = run_z_probe(sanity_check) + offset.z;
     TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
+    TERN_(X_AXIS_TWIST_COMPENSATION, measured_z += xatc.compensation(npos + offset_xy));
   }
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);

commit 8f8427ec8f69705e09ca226d9f16da6b82634439
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 22 01:15:52 2022 +0000

    ‚ö°Ô∏è Apply PTC on all probing (#23764)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index fdd6897192..95776ffda1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -70,20 +70,24 @@
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
+#if HAS_PTC
+  #include "../feature/probe_temp_comp.h"
+#endif
+
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
@@ -794,21 +798,24 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
-  if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
+  if (!deploy()) {
+    measured_z = run_z_probe(sanity_check) + offset.z;
+    TERN_(HAS_PTC, ptc.apply_compensation(measured_z));
+  }
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    üö∏ Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cc3851597b..fdd6897192 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -73,21 +73,21 @@
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
-  #include "../lcd/e3v2/enhanced/dwin.h"
+  #include "../lcd/e3v2/proui/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d1f3eee207..cc3851597b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -780,21 +780,24 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     );
     DEBUG_POS("", current_position);
   }
 
   #if ENABLED(BLTOUCH)
     if (bltouch.high_speed_mode && bltouch.triggered())
       bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
-  xyz_pos_t npos = { rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z) };
+  xyz_pos_t npos = LINEAR_AXIS_ARRAY(
+    rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z),
+    current_position.i, current_position.j, current_position.k
+  );
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;

commit d557db842598639f4ab49447e216557515b3ba9e
Author: Ave6683 <53094187+Ave6683@users.noreply.github.com>
Date:   Mon Dec 27 22:28:27 2021 +0100

    ‚ú® MagLev V4 probe by MDD (#23192)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 540b4e1ae6..d1f3eee207 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -114,20 +114,31 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("dock_sled(", stow, ")");
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
+#elif ENABLED(MAGLEV4)
+
+  // Write trigger pin to release the probe
+  inline void maglev_deploy() {
+    WRITE(MAGLEV_TRIGGER_PIN, HIGH);
+    delay(MAGLEV_TRIGGER_DELAY);
+    WRITE(MAGLEV_TRIGGER_PIN, LOW);
+  }
+
+  inline void maglev_idle() { do_blocking_move_to_z(10); }
+
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   inline void run_deploy_moves_script() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
       #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
@@ -304,20 +315,24 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
+  #elif ENABLED(MAGLEV4)
+
+    deploy ? maglev_deploy() : maglev_idle();
+
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
   #elif ENABLED(BLTOUCH)
 
     deploy ? bltouch.deploy() : bltouch.stow();
 
   #elif HAS_Z_SERVO_PROBE
 

commit 2893048e2955963bb307a4ca67ec26bb336de2f5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 21 23:09:55 2021 -0500

    ‚ú® BLTouch High Speed mode runtime configuration (#22916)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7e08db7a5b..540b4e1ae6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -482,22 +482,24 @@ bool Probe::set_deployed(const bool deploy) {
 bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
-
-  if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
+  #if ENABLED(BLTOUCH)
+    if (!bltouch.high_speed_mode && bltouch.deploy())
+      return true; // Deploy in LOW SPEED MODE on every probe action
+  #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
       if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
     endstops.enable(true);
@@ -524,22 +526,24 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if HAS_DELTA_SENSORLESS_PROBING
       if (test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
       if (test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
     set_homing_current(false);
   #endif
 
-  if (probe_triggered && TERN0(BLTOUCH_SLOW_MODE, bltouch.stow())) // Stow in LOW SPEED MODE on every trigger
-    return true;
+  #if ENABLED(BLTOUCH)
+    if (probe_triggered && !bltouch.high_speed_mode && bltouch.stow())
+      return true; // Stow in LOW SPEED MODE on every trigger
+  #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
@@ -755,22 +759,23 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
-  #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
-    if (bltouch.triggered()) bltouch._reset();
+  #if ENABLED(BLTOUCH)
+    if (bltouch.high_speed_mode && bltouch.triggered())
+      bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = { rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z) };
   if (!can_reach(npos, probe_relative)) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
     return NAN;
   }
   if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 

commit 4d45fdf0eb605629960d06abb86704cfbd62db49
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 8 18:36:08 2021 -0600

    üé® Misc. probe / endstop cleanup

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 89a043d0f5..7e08db7a5b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -489,24 +489,24 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
   if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if HAS_DELTA_SENSORLESS_PROBING
-      if (probe.test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
-      if (probe.test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
+      if (test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
+      if (test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
-    if (probe.test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
+    if (test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
     endstops.enable(true);
     set_homing_current(true);                                 // The "homing" current also applies to probing
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
@@ -517,24 +517,24 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if HAS_DELTA_SENSORLESS_PROBING
-      if (probe.test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
-      if (probe.test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
+      if (test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
+      if (test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
-    if (probe.test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
+    if (test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
     set_homing_current(false);
   #endif
 
   if (probe_triggered && TERN0(BLTOUCH_SLOW_MODE, bltouch.stow())) // Stow in LOW SPEED MODE on every trigger
     return true;
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted

commit 629498f8d43be6675674671927456b8b6b4ac47b
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Tue Nov 16 16:24:53 2021 +0100

    üêõ Fix G33, Delta radii, reachable (#22795)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 984a3aabb5..89a043d0f5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -761,28 +761,25 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = { rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z) };
-  if (probe_relative) {                                     // The given position is in terms of the probe
-    if (!can_reach(npos)) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
-      return NAN;
-    }
-    npos -= offset_xy;                                      // Get the nozzle position
+  if (!can_reach(npos, probe_relative)) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
+    return NAN;
   }
-  else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
+  if (probe_relative) npos -= offset_xy;  // Get the nozzle position
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);

commit e15f9fdcd9ccff010f188d6b0762cf00956a55c1
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Nov 6 23:09:15 2021 -0700

    üö∏ Indicate Preheating for probe / leveling (#23088)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d9e52a9b43..984a3aabb5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -355,20 +355,22 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
    *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
   void Probe::preheat_for_probing(const celsius_t hotend_temp, const celsius_t bed_temp) {
     #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif
     #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
 
+    LCD_MESSAGE(MSG_PREHEATING);
+
     DEBUG_ECHOPGM("Preheating ");
 
     #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
       const celsius_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
       if (hotendPreheat) {
         DEBUG_ECHOPGM("hotend (", hotendPreheat, ")");
         thermalManager.setTargetHotend(hotendPreheat, 0);
       }
     #elif ENABLED(WAIT_FOR_BED_HEAT)
       constexpr celsius_t hotendPreheat = 0;

commit ee28a14e8e7f6b33fe5813dbedcd85380207c345
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 15 00:24:08 2021 -0500

    üé® Refactor Host Actions as singleton

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 4078effe76..d9e52a9b43 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -133,21 +133,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGE(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
-      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Deploy TouchMI"), FPSTR(CONTINUE_STR)));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Deploy TouchMI"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
@@ -288,21 +288,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
-      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f37d2aa03f..4078effe76 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -290,21 +290,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    üé® Apply F() to some ExtUI functions

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 18e72f401c..f37d2aa03f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -289,21 +289,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
-      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
+      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("Stow Probe")));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 

commit 008bf1bcaef181cd1b74638692e2465bb9e07a4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:55:08 2021 -0500

    üé® Apply F() to Host Actions strings

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5accbc8edd..18e72f401c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -133,21 +133,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGE(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
-      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR));
+      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Deploy TouchMI"), FPSTR(CONTINUE_STR)));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
@@ -288,21 +288,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status(ds_str, 99);
       SERIAL_ECHOLNF(ds_str);
 
-      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
+      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("Stow Probe"), FPSTR(CONTINUE_STR)));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 638bb6be81..5accbc8edd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -130,21 +130,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
-      LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
+      LCD_MESSAGE(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
@@ -283,24 +283,24 @@ void Probe::do_z_raise(const float z_raise) {
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
-      PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
+      FSTR_P const ds_str = deploy ? GET_TEXT_F(MSG_MANUAL_DEPLOY) : GET_TEXT_F(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
-      ui.set_status_P(ds_str, 99);
-      SERIAL_ECHOLNPGM_P(ds_str);
+      ui.set_status(ds_str, 99);
+      SERIAL_ECHOLNF(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
@@ -432,21 +432,21 @@ bool Probe::set_deployed(const bool deploy) {
     // Only deploy/stow if needed
     if (PROBE_TRIGGERED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
     if (PROBE_TRIGGERED() == deploy) {             // Unchanged after deploy/stow action?
       if (IsRunning()) {
         SERIAL_ERROR_MSG("Z-Probe failed");
-        LCD_ALERTMESSAGEPGM_P(PSTR("Err: ZPROBE"));
+        LCD_ALERTMESSAGE_F("Err: ZPROBE");
       }
       stop();
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
@@ -786,21 +786,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   if (isnan(measured_z)) {
     stow();
-    LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
+    LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3aca68845d..638bb6be81 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -244,31 +244,31 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_QUIET_PROBING
 
   #ifndef DELAY_BEFORE_PROBING
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
-    TERN_(PROBING_ESTEPPERS_OFF, if (dopause) disable_e_steppers());
+    TERN_(PROBING_ESTEPPERS_OFF, if (dopause) stepper.disable_e_steppers());
     #if ENABLED(PROBING_STEPPERS_OFF) && DISABLED(DELTA)
       static uint8_t old_trusted;
       if (dopause) {
         old_trusted = axis_trusted;
-        DISABLE_AXIS_X();
-        DISABLE_AXIS_Y();
+        stepper.disable_axis(X_AXIS);
+        stepper.disable_axis(Y_AXIS);
       }
       else {
-        if (TEST(old_trusted, X_AXIS)) ENABLE_AXIS_X();
-        if (TEST(old_trusted, Y_AXIS)) ENABLE_AXIS_Y();
+        if (TEST(old_trusted, X_AXIS)) stepper.enable_axis(X_AXIS);
+        if (TEST(old_trusted, Y_AXIS)) stepper.enable_axis(Y_AXIS);
         axis_trusted = old_trusted;
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move

commit b88117d6364b8919a8a7df6c80d8132af98a6afc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 21 06:25:13 2021 -0500

    üé® Fix L64xx enable, clean up conditionals

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 071ff25c20..3aca68845d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -41,49 +41,49 @@
 #include "../MarlinCore.h" // for stop(), disable_e_steppers(), wait_for_user_response()
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
-#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-  #include "planner.h"
+#if ANY(HAS_QUIET_PROBING, USE_SENSORLESS)
+  #include "stepper/indirection.h"
+  #if BOTH(HAS_QUIET_PROBING, PROBING_ESTEPPERS_OFF)
+    #include "stepper.h"
+  #endif
+  #if USE_SENSORLESS
+    #include "../feature/tmc_util.h"
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      #include "planner.h"
+    #endif
+  #endif
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
-#if EITHER(SENSORLESS_PROBING, SENSORLESS_HOMING)
-  #include "stepper.h"
-  #include "../feature/tmc_util.h"
-#endif
-
-#if HAS_QUIET_PROBING
-  #include "stepper/indirection.h"
-#endif
-
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/enhanced/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
@@ -811,21 +811,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      */
     STOW_Z_SERVO();
   }
 
 #endif // HAS_Z_SERVO_PROBE
 
-#if EITHER(SENSORLESS_PROBING, SENSORLESS_HOMING)
+#if USE_SENSORLESS
 
   sensorless_t stealth_states { false };
 
   /**
    * Disable stealthChop if used. Enable diag1 pin on driver.
    */
   void Probe::enable_stallguard_diag1() {
     #if ENABLED(SENSORLESS_PROBING)
       #if HAS_DELTA_SENSORLESS_PROBING
         stealth_states.x = tmc_enable_stallguard(stepperX);

commit 08e581d5d7c6cfcedf400862fcfcd146c6ce837f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 15:41:42 2021 -0500

    üé® Apply more HAS_DELTA_SENSORLESS_PROBING

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3b8a4a520f..071ff25c20 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -486,49 +486,49 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
 
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
   if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
-    #if ENABLED(DELTA)
+    #if HAS_DELTA_SENSORLESS_PROBING
       if (probe.test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
       if (probe.test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     if (probe.test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
     endstops.enable(true);
     set_homing_current(true);                                 // The "homing" current also applies to probing
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
-    #if BOTH(DELTA, SENSORLESS_PROBING)
+    #if HAS_DELTA_SENSORLESS_PROBING
       endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
-    #if ENABLED(DELTA)
+    #if HAS_DELTA_SENSORLESS_PROBING
       if (probe.test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
       if (probe.test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     if (probe.test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
     set_homing_current(false);
   #endif
 
   if (probe_triggered && TERN0(BLTOUCH_SLOW_MODE, bltouch.stow())) // Stow in LOW SPEED MODE on every trigger
     return true;
 
@@ -758,21 +758,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
-  xyz_pos_t npos = { rx, ry, _MIN(TERN(DELTA, delta_clip_start_height, current_position.z), current_position.z) };
+  xyz_pos_t npos = { rx, ry, TERN(DELTA, _MIN(delta_clip_start_height, current_position.z), current_position.z) };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
       return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   // Move the probe to the starting XYZ
@@ -820,36 +820,36 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
 #if EITHER(SENSORLESS_PROBING, SENSORLESS_HOMING)
 
   sensorless_t stealth_states { false };
 
   /**
    * Disable stealthChop if used. Enable diag1 pin on driver.
    */
   void Probe::enable_stallguard_diag1() {
     #if ENABLED(SENSORLESS_PROBING)
-      #if ENABLED(DELTA)
+      #if HAS_DELTA_SENSORLESS_PROBING
         stealth_states.x = tmc_enable_stallguard(stepperX);
         stealth_states.y = tmc_enable_stallguard(stepperY);
       #endif
       stealth_states.z = tmc_enable_stallguard(stepperZ);
       endstops.enable(true);
     #endif
   }
 
   /**
    * Re-enable stealthChop if used. Disable diag1 pin on driver.
    */
   void Probe::disable_stallguard_diag1() {
     #if ENABLED(SENSORLESS_PROBING)
       endstops.not_homing();
-      #if ENABLED(DELTA)
+      #if HAS_DELTA_SENSORLESS_PROBING
         tmc_disable_stallguard(stepperX, stealth_states.x);
         tmc_disable_stallguard(stepperY, stealth_states.y);
       #endif
       tmc_disable_stallguard(stepperZ, stealth_states.z);
     #endif
   }
 
   /**
    * Change the current in the TMC drivers to N##_CURRENT_HOME. And we save the current configuration of each TMC driver.
    */
@@ -900,13 +900,13 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
         #endif
         #if HAS_CURRENT_HOME(Z)
           stepperZ.rms_current(saved_current_Z);
           debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_Z);
         #endif
         TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(false));
       }
     #endif
   }
 
-#endif // SENSORLESS_PROBING
+#endif // SENSORLESS_PROBING || SENSORLESS_HOMING
 
 #endif // HAS_BED_PROBE

commit 6b9b2c5d7382b30dabc2f1fb360d62a819f5ec3d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 02:15:05 2021 -0500

    ü©π Warn about user feedback requirement

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 16ff166493..3b8a4a520f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -134,21 +134,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR));
-      wait_for_user_response();
+      TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
@@ -291,21 +291,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       SERIAL_ECHOLNPGM_P(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
       TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
-      wait_for_user_response();
+      TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a4469bb209..16ff166493 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -104,21 +104,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
    *              If true, move to MAX_X and release the solenoid
    */
   static void dock_sled(const bool stow) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("dock_sled(", stow, ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("dock_sled(", stow, ")");
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
@@ -267,21 +267,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy != PROBE_TRIGGERED()) break;
@@ -360,32 +360,32 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     #endif
     #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
 
     DEBUG_ECHOPGM("Preheating ");
 
     #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
       const celsius_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
       if (hotendPreheat) {
-        DEBUG_ECHOPAIR("hotend (", hotendPreheat, ")");
+        DEBUG_ECHOPGM("hotend (", hotendPreheat, ")");
         thermalManager.setTargetHotend(hotendPreheat, 0);
       }
     #elif ENABLED(WAIT_FOR_BED_HEAT)
       constexpr celsius_t hotendPreheat = 0;
     #endif
 
     #if ENABLED(WAIT_FOR_BED_HEAT)
       const celsius_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
       if (bedPreheat) {
         if (hotendPreheat) DEBUG_ECHOPGM(" and ");
-        DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
+        DEBUG_ECHOPGM("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
     TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
     TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp    > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW)) thermalManager.wait_for_bed_heating());
   }
 
@@ -393,21 +393,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
-    DEBUG_ECHOLNPAIR("deploy: ", deploy);
+    DEBUG_ECHOLNPGM("deploy: ", deploy);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
@@ -622,21 +622,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
     // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
@@ -716,21 +716,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         probes_z_sum += probes[i];
 
     #endif
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = current_position.z;
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position.z;
 
   #endif
@@ -744,21 +744,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOLNPAIR(
+    DEBUG_ECHOLNPGM(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
@@ -781,21 +781,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
-      SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
+      SERIAL_ECHOLNPGM("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
@@ -857,21 +857,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
     #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
     #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z)
       #if ENABLED(DELTA)
         static int16_t saved_current_X, saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
         static int16_t saved_current_Z;
       #endif
       #if ((ENABLED(DELTA) && (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y))) || HAS_CURRENT_HOME(Z))
         auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
-          if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b); }
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
         };
       #endif
       if (onoff) {
         #if ENABLED(DELTA)
           #if HAS_CURRENT_HOME(X)
             saved_current_X = stepperX.getMilliamps();
             stepperX.rms_current(X_CURRENT_HOME);
             debug_current_on(PSTR("X"), saved_current_X, X_CURRENT_HOME);
           #endif
           #if HAS_CURRENT_HOME(Y)

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ‚ú® Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cbadda2eef..a4469bb209 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -72,20 +72,22 @@
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_QUIET_PROBING
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "../lcd/e3v2/enhanced/dwin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
@@ -288,21 +290,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       SERIAL_ECHOLNPGM_P(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
-
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_Popup_Confirm(ICON_BLTouch, PSTR("Stow Probe"), CONTINUE_STR));
       wait_for_user_response();
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1

commit eccd82b7c1049b098546334fab7ac152e1fa1ce7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 11 18:15:36 2020 -0600

    ‚ö°Ô∏è Add PROBE_PT_LAST_STOW

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ded5d43893..cbadda2eef 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -744,21 +744,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
-      ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
+      ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_LAST_STOW ? "stow (last)" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
@@ -775,21 +775,21 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
-    else if (raise_after == PROBE_PT_STOW)
+    else if (raise_after == PROBE_PT_STOW || raise_after == PROBE_PT_LAST_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)

commit c05de6cbf8b914c9198091423fe19415e802de6e
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Aug 17 20:35:12 2021 -0700

    ‚ö°Ô∏è Simplify PROBING_STEPPERS_OFF (#22581)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d0f32a32c0..ded5d43893 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -243,35 +243,30 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 #if HAS_QUIET_PROBING
 
   #ifndef DELAY_BEFORE_PROBING
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
     TERN_(PROBING_ESTEPPERS_OFF, if (dopause) disable_e_steppers());
-    #if ENABLED(PROBING_STEPPERS_OFF)
-      IF_DISABLED(DELTA, static uint8_t old_trusted);
+    #if ENABLED(PROBING_STEPPERS_OFF) && DISABLED(DELTA)
+      static uint8_t old_trusted;
       if (dopause) {
-        #if DISABLED(DELTA)
-          old_trusted = axis_trusted;
-          DISABLE_AXIS_X();
-          DISABLE_AXIS_Y();
-        #endif
-        IF_DISABLED(PROBING_ESTEPPERS_OFF, disable_e_steppers());
+        old_trusted = axis_trusted;
+        DISABLE_AXIS_X();
+        DISABLE_AXIS_Y();
       }
       else {
-        #if DISABLED(DELTA)
-          if (TEST(old_trusted, X_AXIS)) ENABLE_AXIS_X();
-          if (TEST(old_trusted, Y_AXIS)) ENABLE_AXIS_Y();
-        #endif
+        if (TEST(old_trusted, X_AXIS)) ENABLE_AXIS_X();
+        if (TEST(old_trusted, Y_AXIS)) ENABLE_AXIS_Y();
         axis_trusted = old_trusted;
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move

commit 6efd7285ccbacc55402ca7b704be0f051af34097
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 29 22:23:06 2021 -0500

    üêõ Fix PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED
    
    Fixes #22295. Regression from #20241.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d585afb8b2..d0f32a32c0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -280,21 +280,21 @@ void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        if (deploy == PROBE_TRIGGERED()) break;
+        if (deploy != PROBE_TRIGGERED()) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       SERIAL_ECHOLNPGM_P(ds_str);
 

commit 2d4be74db98c8ab74b5c636cd1899bcaabd760e2
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Jul 20 12:54:02 2021 -0700

    üé® Fix unused lambda warning (#22399)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6831d151f9..d585afb8b2 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -858,23 +858,25 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
    */
   void Probe::set_homing_current(const bool onoff) {
     #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
     #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z)
       #if ENABLED(DELTA)
         static int16_t saved_current_X, saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
         static int16_t saved_current_Z;
       #endif
-      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
-        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b); }
-      };
+      #if ((ENABLED(DELTA) && (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y))) || HAS_CURRENT_HOME(Z))
+        auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b); }
+        };
+      #endif
       if (onoff) {
         #if ENABLED(DELTA)
           #if HAS_CURRENT_HOME(X)
             saved_current_X = stepperX.getMilliamps();
             stepperX.rms_current(X_CURRENT_HOME);
             debug_current_on(PSTR("X"), saved_current_X, X_CURRENT_HOME);
           #endif
           #if HAS_CURRENT_HOME(Y)
             saved_current_Y = stepperY.getMilliamps();
             stepperY.rms_current(Y_CURRENT_HOME);

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index dae25feea3..6831d151f9 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -61,21 +61,21 @@
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
-#if ENABLED(SENSORLESS_PROBING)
+#if EITHER(SENSORLESS_PROBING, SENSORLESS_HOMING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_QUIET_PROBING
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
@@ -85,20 +85,24 @@
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
   const xy_pos_t &Probe::offset_xy = Probe::offset;
 #endif
 
+#if ENABLED(SENSORLESS_PROBING)
+  Probe::sense_bool_t Probe::test_sensitivity;
+#endif
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
@@ -486,25 +490,26 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
   if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
-      stealth_states.x = tmc_enable_stallguard(stepperX);
-      stealth_states.y = tmc_enable_stallguard(stepperY);
+      if (probe.test_sensitivity.x) stealth_states.x = tmc_enable_stallguard(stepperX);  // Delta watches all DIAG pins for a stall
+      if (probe.test_sensitivity.y) stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
-    stealth_states.z = tmc_enable_stallguard(stepperZ);
+    if (probe.test_sensitivity.z) stealth_states.z = tmc_enable_stallguard(stepperZ);    // All machines will check Z-DIAG for stall
     endstops.enable(true);
+    set_homing_current(true);                                 // The "homing" current also applies to probing
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
@@ -513,24 +518,25 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
       TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
-      tmc_disable_stallguard(stepperX, stealth_states.x);
-      tmc_disable_stallguard(stepperY, stealth_states.y);
+      if (probe.test_sensitivity.x) tmc_disable_stallguard(stepperX, stealth_states.x);
+      if (probe.test_sensitivity.y) tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
-    tmc_disable_stallguard(stepperZ, stealth_states.z);
+    if (probe.test_sensitivity.z) tmc_disable_stallguard(stepperZ, stealth_states.z);
+    set_homing_current(false);
   #endif
 
   if (probe_triggered && TERN0(BLTOUCH_SLOW_MODE, bltouch.stow())) // Stow in LOW SPEED MODE on every trigger
     return true;
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
@@ -808,11 +814,100 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      */
     STOW_Z_SERVO();
   }
 
 #endif // HAS_Z_SERVO_PROBE
 
+#if EITHER(SENSORLESS_PROBING, SENSORLESS_HOMING)
+
+  sensorless_t stealth_states { false };
+
+  /**
+   * Disable stealthChop if used. Enable diag1 pin on driver.
+   */
+  void Probe::enable_stallguard_diag1() {
+    #if ENABLED(SENSORLESS_PROBING)
+      #if ENABLED(DELTA)
+        stealth_states.x = tmc_enable_stallguard(stepperX);
+        stealth_states.y = tmc_enable_stallguard(stepperY);
+      #endif
+      stealth_states.z = tmc_enable_stallguard(stepperZ);
+      endstops.enable(true);
+    #endif
+  }
+
+  /**
+   * Re-enable stealthChop if used. Disable diag1 pin on driver.
+   */
+  void Probe::disable_stallguard_diag1() {
+    #if ENABLED(SENSORLESS_PROBING)
+      endstops.not_homing();
+      #if ENABLED(DELTA)
+        tmc_disable_stallguard(stepperX, stealth_states.x);
+        tmc_disable_stallguard(stepperY, stealth_states.y);
+      #endif
+      tmc_disable_stallguard(stepperZ, stealth_states.z);
+    #endif
+  }
+
+  /**
+   * Change the current in the TMC drivers to N##_CURRENT_HOME. And we save the current configuration of each TMC driver.
+   */
+  void Probe::set_homing_current(const bool onoff) {
+    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
+    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Z)
+      #if ENABLED(DELTA)
+        static int16_t saved_current_X, saved_current_Y;
+      #endif
+      #if HAS_CURRENT_HOME(Z)
+        static int16_t saved_current_Z;
+      #endif
+      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
+        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b); }
+      };
+      if (onoff) {
+        #if ENABLED(DELTA)
+          #if HAS_CURRENT_HOME(X)
+            saved_current_X = stepperX.getMilliamps();
+            stepperX.rms_current(X_CURRENT_HOME);
+            debug_current_on(PSTR("X"), saved_current_X, X_CURRENT_HOME);
+          #endif
+          #if HAS_CURRENT_HOME(Y)
+            saved_current_Y = stepperY.getMilliamps();
+            stepperY.rms_current(Y_CURRENT_HOME);
+            debug_current_on(PSTR("Y"), saved_current_Y, Y_CURRENT_HOME);
+          #endif
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          saved_current_Z = stepperZ.getMilliamps();
+          stepperZ.rms_current(Z_CURRENT_HOME);
+          debug_current_on(PSTR("Z"), saved_current_Z, Z_CURRENT_HOME);
+        #endif
+        TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(true));
+      }
+      else {
+        #if ENABLED(DELTA)
+          #if HAS_CURRENT_HOME(X)
+            stepperX.rms_current(saved_current_X);
+            debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_X);
+          #endif
+          #if HAS_CURRENT_HOME(Y)
+            stepperY.rms_current(saved_current_Y);
+            debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_Y);
+          #endif
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          stepperZ.rms_current(saved_current_Z);
+          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_Z);
+        #endif
+        TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(false));
+      }
+    #endif
+  }
+
+#endif // SENSORLESS_PROBING
+
 #endif // HAS_BED_PROBE

commit 33185b090e264a923a8d2fb0687846fe100f5465
Author: cr20-123 <66994235+cr20-123@users.noreply.github.com>
Date:   Sat Jun 26 14:17:18 2021 -0400

    ‚ú® Update/extend Quiet Probing (#22205)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 2b3a189884..dae25feea3 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -238,29 +238,30 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_QUIET_PROBING
 
   #ifndef DELAY_BEFORE_PROBING
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
+    TERN_(PROBING_ESTEPPERS_OFF, if (dopause) disable_e_steppers());
     #if ENABLED(PROBING_STEPPERS_OFF)
       IF_DISABLED(DELTA, static uint8_t old_trusted);
       if (dopause) {
         #if DISABLED(DELTA)
           old_trusted = axis_trusted;
           DISABLE_AXIS_X();
           DISABLE_AXIS_Y();
         #endif
-        disable_e_steppers();
+        IF_DISABLED(PROBING_ESTEPPERS_OFF, disable_e_steppers());
       }
       else {
         #if DISABLED(DELTA)
           if (TEST(old_trusted, X_AXIS)) ENABLE_AXIS_X();
           if (TEST(old_trusted, Y_AXIS)) ENABLE_AXIS_Y();
         #endif
         axis_trusted = old_trusted;
       }
     #endif
     if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));

commit a3e8bb99e472042c7db0b2d0be8d515ee715cf28
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 13 23:08:46 2021 -0400

    üé® ExtUI "user click" and other tweaks (#22122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0042302fc7..2b3a189884 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -377,21 +377,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       if (bedPreheat) {
         if (hotendPreheat) DEBUG_ECHOPGM(" and ");
         DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
     TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
-    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW))    thermalManager.wait_for_bed_heating());
+    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp    > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW)) thermalManager.wait_for_bed_heating());
   }
 
 #endif
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {

commit ff0318c5bd95c6cb18ae9765f1ecb344dc2d6e4e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 21:08:57 2021 -0500

    üé® pause => pause_heaters

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6d4a022882..0042302fc7 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -236,21 +236,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if HAS_QUIET_PROBING
 
   #ifndef DELAY_BEFORE_PROBING
     #define DELAY_BEFORE_PROBING 25
   #endif
 
   void Probe::set_probing_paused(const bool dopause) {
-    TERN_(PROBING_HEATERS_OFF, thermalManager.pause(dopause));
+    TERN_(PROBING_HEATERS_OFF, thermalManager.pause_heaters(dopause));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
     #if ENABLED(PROBING_STEPPERS_OFF)
       IF_DISABLED(DELTA, static uint8_t old_trusted);
       if (dopause) {
         #if DISABLED(DELTA)
           old_trusted = axis_trusted;
           DISABLE_AXIS_X();
           DISABLE_AXIS_Y();
         #endif
         disable_e_steppers();

commit 92dea8e6ccd26950eed817fce6f574fcfe866489
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 01:09:46 2021 -0500

    ‚ôªÔ∏è Refactor, comment endstop/probe enums

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 655b8cc249..6d4a022882 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -502,21 +502,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
-      TEST(endstops.trigger_state(), TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN, Z_MIN_PROBE))
+      TEST(endstops.trigger_state(), Z_MIN_PROBE)
     #endif
   ;
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);

commit 0dae140080c611089f8cb7e937c9f48516eb944d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 23:30:49 2021 -0500

    üêõ Fix DELTA with SENSORLESS_PROBING

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index be991c1d52..655b8cc249 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -500,21 +500,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   #endif
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
-      endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
+      endstops.trigger_state() & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX))
     #else
       TEST(endstops.trigger_state(), TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN, Z_MIN_PROBE))
     #endif
   ;
 
   TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 910db87f55..be991c1d52 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -376,22 +376,22 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       const celsius_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
       if (bedPreheat) {
         if (hotendPreheat) DEBUG_ECHOPGM(" and ");
         DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
-    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.degHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
-    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp > thermalManager.degBed() + (TEMP_BED_WINDOW))    thermalManager.wait_for_bed_heating());
+    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.wholeDegHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
+    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp > thermalManager.wholeDegBed() + (TEMP_BED_WINDOW))    thermalManager.wait_for_bed_heating());
   }
 
 #endif
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {

commit 72e3d2492f2085efe9c5fb0b33d67c24baf8a4bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:14:49 2021 -0500

    Update temperature types

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d4b8409efa..910db87f55 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -345,42 +345,42 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     #ifndef PROBING_BED_TEMP
       #define PROBING_BED_TEMP 0
     #endif
   #endif
 
   /**
    * Do preheating as required before leveling or probing.
    *  - If a preheat input is higher than the current target, raise the target temperature.
    *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
-  void Probe::preheat_for_probing(const int16_t hotend_temp, const int16_t bed_temp) {
+  void Probe::preheat_for_probing(const celsius_t hotend_temp, const celsius_t bed_temp) {
     #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif
     #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
 
     DEBUG_ECHOPGM("Preheating ");
 
     #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
-      const int16_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
+      const celsius_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
       if (hotendPreheat) {
         DEBUG_ECHOPAIR("hotend (", hotendPreheat, ")");
         thermalManager.setTargetHotend(hotendPreheat, 0);
       }
     #elif ENABLED(WAIT_FOR_BED_HEAT)
-      constexpr int16_t hotendPreheat = 0;
+      constexpr celsius_t hotendPreheat = 0;
     #endif
 
     #if ENABLED(WAIT_FOR_BED_HEAT)
-      const int16_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
+      const celsius_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
       if (bedPreheat) {
         if (hotendPreheat) DEBUG_ECHOPGM(" and ");
         DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
     TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.degHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d408dd236d..d4b8409efa 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -576,21 +576,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     return false;
   }
 #endif
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
- * @return The Z position of the bed at the current XY or MFNAN on error.
+ * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
@@ -610,25 +610,25 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
-    if (TERN0(PROBE_TARE, tare())) return MFNAN;
+    if (TERN0(PROBE_TARE, tare())) return NAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
-                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return MFNAN;
+                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
@@ -655,21 +655,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
-                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return MFNAN;
+                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
@@ -758,43 +758,43 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = { rx, ry, _MIN(TERN(DELTA, delta_clip_start_height, current_position.z), current_position.z) };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
-      return MFNAN;
+      return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
-  else if (!position_is_reachable(npos)) return MFNAN;      // The given position is in terms of the nozzle
+  else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
-  float measured_z = MFNAN;
+  float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
-  if (!ISNAN(measured_z)) {
+  if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW)
-      if (stow()) measured_z = MFNAN;   // Error on stow?
+      if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
-  if (ISNAN(measured_z)) {
+  if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
   return measured_z;
 }
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d4b8409efa..d408dd236d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -576,21 +576,21 @@ bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
     return false;
   }
 #endif
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
- * @return The Z position of the bed at the current XY or NAN on error.
+ * @return The Z position of the bed at the current XY or MFNAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
@@ -610,25 +610,25 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Attempt to tare the probe
-    if (TERN0(PROBE_TARE, tare())) return NAN;
+    if (TERN0(PROBE_TARE, tare())) return MFNAN;
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
-                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
+                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return MFNAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
   #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
@@ -655,21 +655,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
-                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
+                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return MFNAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
@@ -758,43 +758,43 @@ float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRai
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort
   xyz_pos_t npos = { rx, ry, _MIN(TERN(DELTA, delta_clip_start_height, current_position.z), current_position.z) };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
-      return NAN;
+      return MFNAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
-  else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
+  else if (!position_is_reachable(npos)) return MFNAN;      // The given position is in terms of the nozzle
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
-  float measured_z = NAN;
+  float measured_z = MFNAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
-  if (!isnan(measured_z)) {
+  if (!ISNAN(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW)
-      if (stow()) measured_z = NAN;   // Error on stow?
+      if (stow()) measured_z = MFNAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
-  if (isnan(measured_z)) {
+  if (ISNAN(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
   return measured_z;
 }
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 28c89e7a00..d4b8409efa 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -468,21 +468,21 @@ bool Probe::set_deployed(const bool deploy) {
 /**
  * @brief Move down until the probe triggers or the low limit is reached
  *
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
-bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
+bool Probe::probe_down_to_z(const_float_t z, const_feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
     thermalManager.wait_for_hotend_heating(active_extruder);
   #endif
 
@@ -581,21 +581,21 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
-  auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
+  auto try_to_probe = [&](PGM_P const plbl, const_float_t z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
                early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_ECHOPGM_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
@@ -736,21 +736,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
+float Probe::probe_at_point(const_float_t rx, const_float_t ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);

commit 35791c6371dad924f9a3f0fb3aebacfd298ecc35
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 1 19:39:43 2021 -0600

    Trust XY after Quiet Probing short sleep (#21237)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7333aaa748..28c89e7a00 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -231,34 +231,46 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if HAS_QUIET_PROBING
 
-  void Probe::set_probing_paused(const bool p) {
-    TERN_(PROBING_HEATERS_OFF, thermalManager.pause(p));
-    TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(p));
+  #ifndef DELAY_BEFORE_PROBING
+    #define DELAY_BEFORE_PROBING 25
+  #endif
+
+  void Probe::set_probing_paused(const bool dopause) {
+    TERN_(PROBING_HEATERS_OFF, thermalManager.pause(dopause));
+    TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(dopause));
     #if ENABLED(PROBING_STEPPERS_OFF)
-      disable_e_steppers();
-      #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
-        DISABLE_AXIS_X(); DISABLE_AXIS_Y();
-      #endif
+      IF_DISABLED(DELTA, static uint8_t old_trusted);
+      if (dopause) {
+        #if DISABLED(DELTA)
+          old_trusted = axis_trusted;
+          DISABLE_AXIS_X();
+          DISABLE_AXIS_Y();
+        #endif
+        disable_e_steppers();
+      }
+      else {
+        #if DISABLED(DELTA)
+          if (TEST(old_trusted, X_AXIS)) ENABLE_AXIS_X();
+          if (TEST(old_trusted, Y_AXIS)) ENABLE_AXIS_Y();
+        #endif
+        axis_trusted = old_trusted;
+      }
     #endif
-    if (p) safe_delay(25
-      #if DELAY_BEFORE_PROBING > 25
-        - 25 + DELAY_BEFORE_PROBING
-      #endif
-    );
+    if (dopause) safe_delay(_MAX(DELAY_BEFORE_PROBING, 25));
   }
 
 #endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;

commit e66e51fa6d92cce79ade66893639a333ca53e88a
Author: Nick <nick@n-wells.co.uk>
Date:   Mon Mar 1 10:23:10 2021 +0000

    Safe Z homing for Power Loss Recovery (#16909)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7dcf1dff31..7333aaa748 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -333,42 +333,42 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     #ifndef PROBING_BED_TEMP
       #define PROBING_BED_TEMP 0
     #endif
   #endif
 
   /**
    * Do preheating as required before leveling or probing.
    *  - If a preheat input is higher than the current target, raise the target temperature.
    *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
-  void Probe::preheat_for_probing(const uint16_t hotend_temp, const uint16_t bed_temp) {
+  void Probe::preheat_for_probing(const int16_t hotend_temp, const int16_t bed_temp) {
     #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif
     #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
 
     DEBUG_ECHOPGM("Preheating ");
 
     #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
-      const uint16_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
+      const int16_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
       if (hotendPreheat) {
         DEBUG_ECHOPAIR("hotend (", hotendPreheat, ")");
         thermalManager.setTargetHotend(hotendPreheat, 0);
       }
     #elif ENABLED(WAIT_FOR_BED_HEAT)
-      constexpr uint16_t hotendPreheat = 0;
+      constexpr int16_t hotendPreheat = 0;
     #endif
 
     #if ENABLED(WAIT_FOR_BED_HEAT)
-      const uint16_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
+      const int16_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
       if (bedPreheat) {
         if (hotendPreheat) DEBUG_ECHOPGM(" and ");
         DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
         thermalManager.setTargetBed(bedPreheat);
       }
     #endif
 
     DEBUG_EOL();
 
     TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.degHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d7fafc8932..7dcf1dff31 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -272,22 +272,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy == PROBE_TRIGGERED()) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
-      serialprintPGM(ds_str);
-      SERIAL_EOL();
+      SERIAL_ECHOLNPGM_P(ds_str);
 
       TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
       TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
 
       wait_for_user_response();
       ui.reset_status();
 
     } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
@@ -579,21 +578,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
   auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
                early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
-        DEBUG_PRINT_P(plbl);
+        DEBUG_ECHOPGM_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
         if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
         if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
         DEBUG_EOL();
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };

commit ee7701c15bc91f7a05f973e03624fb14815f5027
Author: jbuck2005 <59450931+jbuck2005@users.noreply.github.com>
Date:   Sat Feb 27 16:54:43 2021 -0500

    SPEED => FEEDRATE (#21217)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d29123bf4d..d7fafc8932 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -612,21 +612,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
-  #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
+  #elif Z_PROBE_FEEDRATE_FAST != Z_PROBE_FEEDRATE_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, z_probe_fast_mm_s))
         do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, z_probe_fast_mm_s);
     }
   #endif
@@ -643,21 +643,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // If the probe won't tare, return
       if (TERN0(PROBE_TARE, tare())) return true;
 
       // Probe downward slowly to find the bed
-      if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
+      if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW),
                        sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z

commit bcda46e3f3435a1f87d224be2f81778c1855deb7
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Feb 25 17:09:00 2021 +0100

    Combine Z_AFTER_DEACTIVATE with UNKNOWN_Z_NO_RAISE (#20444)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index e59e514a06..d29123bf4d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -394,28 +394,21 @@ bool Probe::set_deployed(const bool deploy) {
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool z_raise_wanted = deploy;
   #else
     constexpr bool z_raise_wanted = true;
   #endif
 
-  // For beds that fall when Z is powered off only raise for trusted Z
-  #if ENABLED(UNKNOWN_Z_NO_RAISE)
-    const bool z_is_trusted = axis_is_trusted(Z_AXIS);
-  #else
-    constexpr float z_is_trusted = true;
-  #endif
-
-  if (z_is_trusted && z_raise_wanted)
+  if (z_raise_wanted)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 

commit 735c1b6183739152eeddade4c06c17e3b0de38bc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Feb 25 06:28:27 2021 -0800

    PROBING_HEATERS_OFF sub-option WAIT_FOR_HOTEND (#20835)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6df115225e..e59e514a06 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -471,20 +471,24 @@ bool Probe::set_deployed(const bool deploy) {
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
+  #if BOTH(HAS_TEMP_HOTEND, WAIT_FOR_HOTEND)
+    thermalManager.wait_for_hotend_heating(active_extruder);
+  #endif
+
   if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);

commit b3ecede429d90e1a493b02e31b2c1d67411ce5da
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Feb 21 15:14:47 2021 +1300

    Fix G29 missing defines (#21145)
    
    Co-authored-by: ellensp <ellensp@hotmsil.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8cda039db6..6df115225e 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -328,28 +328,20 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 #if EITHER(PREHEAT_BEFORE_PROBING, PREHEAT_BEFORE_LEVELING)
 
   #if ENABLED(PREHEAT_BEFORE_PROBING)
     #ifndef PROBING_NOZZLE_TEMP
       #define PROBING_NOZZLE_TEMP 0
     #endif
     #ifndef PROBING_BED_TEMP
       #define PROBING_BED_TEMP 0
     #endif
   #endif
-  #if ENABLED(PREHEAT_BEFORE_LEVELING)
-    #ifndef LEVELING_NOZZLE_TEMP
-      #define LEVELING_NOZZLE_TEMP 0
-    #endif
-    #ifndef LEVELING_BED_TEMP
-      #define LEVELING_BED_TEMP 0
-    #endif
-  #endif
 
   /**
    * Do preheating as required before leveling or probing.
    *  - If a preheat input is higher than the current target, raise the target temperature.
    *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
   void Probe::preheat_for_probing(const uint16_t hotend_temp, const uint16_t bed_temp) {
     #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif

commit 42d00b13df5af260adf44213e5fae0f7e04681ec
Author: Michael Telatynski <7t3chguy@googlemail.com>
Date:   Fri Feb 12 00:32:31 2021 +0000

    Improve probe preheat behavior (#21033)
    
    Co-authored-by: InsanityAutomation <d.menzel@insanityautomation.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 925538ef83..8cda039db6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -320,44 +320,75 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif
 }
 
 #if EITHER(PREHEAT_BEFORE_PROBING, PREHEAT_BEFORE_LEVELING)
 
+  #if ENABLED(PREHEAT_BEFORE_PROBING)
+    #ifndef PROBING_NOZZLE_TEMP
+      #define PROBING_NOZZLE_TEMP 0
+    #endif
+    #ifndef PROBING_BED_TEMP
+      #define PROBING_BED_TEMP 0
+    #endif
+  #endif
+  #if ENABLED(PREHEAT_BEFORE_LEVELING)
+    #ifndef LEVELING_NOZZLE_TEMP
+      #define LEVELING_NOZZLE_TEMP 0
+    #endif
+    #ifndef LEVELING_BED_TEMP
+      #define LEVELING_BED_TEMP 0
+    #endif
+  #endif
+
   /**
-   * Do preheating as required before leveling or probing
+   * Do preheating as required before leveling or probing.
+   *  - If a preheat input is higher than the current target, raise the target temperature.
+   *  - If a preheat input is higher than the current temperature, wait for stabilization.
    */
   void Probe::preheat_for_probing(const uint16_t hotend_temp, const uint16_t bed_temp) {
-    #if PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP
+    #if HAS_HOTEND && (PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP)
       #define WAIT_FOR_NOZZLE_HEAT
     #endif
-    #if PROBING_BED_TEMP || LEVELING_BED_TEMP
+    #if HAS_HEATED_BED && (PROBING_BED_TEMP || LEVELING_BED_TEMP)
       #define WAIT_FOR_BED_HEAT
     #endif
-    const uint16_t hotendPreheat = TERN0(WAIT_FOR_NOZZLE_HEAT, thermalManager.degHotend(0) < hotend_temp) ? hotend_temp : 0,
-                      bedPreheat = TERN0(WAIT_FOR_BED_HEAT,    thermalManager.degBed()     < bed_temp)    ? bed_temp    : 0;
+
     DEBUG_ECHOPGM("Preheating ");
-    if (hotendPreheat) {
-      DEBUG_ECHOPAIR("hotend (", hotendPreheat, ") ");
-      if (bedPreheat) DEBUG_ECHOPGM("and ");
-    }
-    if (bedPreheat) DEBUG_ECHOPAIR("bed (", bedPreheat, ") ");
+
+    #if ENABLED(WAIT_FOR_NOZZLE_HEAT)
+      const uint16_t hotendPreheat = hotend_temp > thermalManager.degTargetHotend(0) ? hotend_temp : 0;
+      if (hotendPreheat) {
+        DEBUG_ECHOPAIR("hotend (", hotendPreheat, ")");
+        thermalManager.setTargetHotend(hotendPreheat, 0);
+      }
+    #elif ENABLED(WAIT_FOR_BED_HEAT)
+      constexpr uint16_t hotendPreheat = 0;
+    #endif
+
+    #if ENABLED(WAIT_FOR_BED_HEAT)
+      const uint16_t bedPreheat = bed_temp > thermalManager.degTargetBed() ? bed_temp : 0;
+      if (bedPreheat) {
+        if (hotendPreheat) DEBUG_ECHOPGM(" and ");
+        DEBUG_ECHOPAIR("bed (", bedPreheat, ")");
+        thermalManager.setTargetBed(bedPreheat);
+      }
+    #endif
+
     DEBUG_EOL();
 
-    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotendPreheat) thermalManager.setTargetHotend(hotendPreheat, 0));
-    TERN_(WAIT_FOR_BED_HEAT,    if (bedPreheat)    thermalManager.setTargetBed(bedPreheat));
-    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotendPreheat) thermalManager.wait_for_hotend(0));
-    TERN_(WAIT_FOR_BED_HEAT,    if (bedPreheat)    thermalManager.wait_for_bed_heating());
+    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotend_temp > thermalManager.degHotend(0) + (TEMP_WINDOW)) thermalManager.wait_for_hotend(0));
+    TERN_(WAIT_FOR_BED_HEAT,    if (bed_temp > thermalManager.degBed() + (TEMP_BED_WINDOW))    thermalManager.wait_for_bed_heating());
   }
 
 #endif
 
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 94c409eb72..925538ef83 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -712,21 +712,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
-      ", ", int(verbose_level),
+      ", ", verbose_level,
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // On delta keep Z below clip height or do_blocking_move_to will abort

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cc5c5e8815..94c409eb72 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,21 +31,21 @@
 #include "probe.h"
 
 #include "../libs/buzzer.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 
-#include "../MarlinCore.h" // for stop(), disable_e_steppers
+#include "../MarlinCore.h" // for stop(), disable_e_steppers(), wait_for_user_response()
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit a87e5197cfb2f302c3eea9271b4c25c49df3ab6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 30 19:13:47 2020 -0600

    Document, adjust some homing code

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 53c35d69f2..cc5c5e8815 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -366,33 +366,33 @@ bool Probe::set_deployed(const bool deploy) {
     DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPAIR("deploy: ", deploy);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
-    const bool deploy_stow_condition = deploy;
+    const bool z_raise_wanted = deploy;
   #else
-    constexpr bool deploy_stow_condition = true;
+    constexpr bool z_raise_wanted = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
-    const bool unknown_condition = axis_is_trusted(Z_AXIS);
+    const bool z_is_trusted = axis_is_trusted(Z_AXIS);
   #else
-    constexpr float unknown_condition = true;
+    constexpr float z_is_trusted = true;
   #endif
 
-  if (deploy_stow_condition && unknown_condition)
+  if (z_is_trusted && z_raise_wanted)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 

commit 45996fd20a71e711925dd5094a6860ec70624d4b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:23:18 2020 -0600

    Init tare pin once

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index df014bdc28..53c35d69f2 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -503,39 +503,49 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
   return !probe_triggered;
 }
 
 #if ENABLED(PROBE_TARE)
+
+  /**
+   * @brief Init the tare pin
+   *
+   * @details Init tare pin to ON state for a strain gauge, otherwise OFF
+   */
+  void Probe::tare_init() {
+    OUT_WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
+  }
+
   /**
    * @brief Tare the Z probe
    *
    * @details Signal to the probe to tare itself
    *
    * @return TRUE if the tare cold not be completed
    */
   bool Probe::tare() {
     #if BOTH(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
       if (endstops.probe_switch_activated()) {
         SERIAL_ECHOLNPGM("Cannot tare an active probe");
         return true;
       }
     #endif
 
     SERIAL_ECHOLNPGM("Taring probe");
-    OUT_WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
+    WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
     delay(PROBE_TARE_TIME);
-    OUT_WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
+    WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
     delay(PROBE_TARE_DELAY);
 
     endstops.hit_on_purpose();
     return false;
   }
 #endif
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *

commit f423edd938dcb593b58844cd7dc3b9164d792686
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:21:01 2020 -0600

    Add probe_switch_activated

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d93eda1303..df014bdc28 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -512,21 +512,21 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
 #if ENABLED(PROBE_TARE)
   /**
    * @brief Tare the Z probe
    *
    * @details Signal to the probe to tare itself
    *
    * @return TRUE if the tare cold not be completed
    */
   bool Probe::tare() {
     #if BOTH(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
-      if (READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE) {
+      if (endstops.probe_switch_activated()) {
         SERIAL_ECHOLNPGM("Cannot tare an active probe");
         return true;
       }
     #endif
 
     SERIAL_ECHOLNPGM("Taring probe");
     OUT_WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
     delay(PROBE_TARE_TIME);
     OUT_WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
     delay(PROBE_TARE_DELAY);

commit 198b3ae0f81f9524479741161ba88306766c3e6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:26:18 2020 -0600

    Fix some comments

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 02c1f55f4a..d93eda1303 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -541,24 +541,24 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
-    // Do a first probe at the fast speed
-
+    // Tare the probe, if supported
     if (TERN0(PROBE_TARE, tare())) return true;
 
+    // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
                early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_PRINT_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
         if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
         if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
         DEBUG_EOL();
       }

commit c87c354403342ea12fce220116665e22efbe8194
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Wed Dec 23 03:10:56 2020 -0300

    Refactor 'Level Corners with Probe' (#20460)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 261fde4913..02c1f55f4a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -448,23 +448,21 @@ bool Probe::set_deployed(const bool deploy) {
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
-  #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
-    if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
-  #endif
+  if (TERN0(BLTOUCH_SLOW_MODE, bltouch.deploy())) return true; // Deploy in LOW SPEED MODE on every probe action
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
@@ -489,23 +487,22 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif
 
-  #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
-    if (probe_triggered && bltouch.stow()) return true; // STOW in LOW SPEED MODE on trigger on every probe action
-  #endif
+  if (probe_triggered && TERN0(BLTOUCH_SLOW_MODE, bltouch.stow())) // Stow in LOW SPEED MODE on every trigger
+    return true;
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
@@ -571,23 +568,24 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
-    // Do a first probe at the fast speed
+    // Attempt to tare the probe
     if (TERN0(PROBE_TARE, tare())) return NAN;
 
+    // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 

commit 2963229dfa6648246951de90e4a86bf537cc876a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:11:43 2020 -0500

    Probe Tare, Probe Activation Switch (#20379)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>
    Co-authored-by: Victor Mateus Oliveira <rhapsodyv@gmail.com>
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 63b1928c76..261fde4913 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -505,33 +505,63 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
   return !probe_triggered;
 }
 
+#if ENABLED(PROBE_TARE)
+  /**
+   * @brief Tare the Z probe
+   *
+   * @details Signal to the probe to tare itself
+   *
+   * @return TRUE if the tare cold not be completed
+   */
+  bool Probe::tare() {
+    #if BOTH(PROBE_ACTIVATION_SWITCH, PROBE_TARE_ONLY_WHILE_INACTIVE)
+      if (READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE) {
+        SERIAL_ECHOLNPGM("Cannot tare an active probe");
+        return true;
+      }
+    #endif
+
+    SERIAL_ECHOLNPGM("Taring probe");
+    OUT_WRITE(PROBE_TARE_PIN, PROBE_TARE_STATE);
+    delay(PROBE_TARE_TIME);
+    OUT_WRITE(PROBE_TARE_PIN, !PROBE_TARE_STATE);
+    delay(PROBE_TARE_DELAY);
+
+    endstops.hit_on_purpose();
+    return false;
+  }
+#endif
+
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
-  auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) {
+  auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) -> bool {
     // Do a first probe at the fast speed
+
+    if (TERN0(PROBE_TARE, tare())) return true;
+
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
                early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_PRINT_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
         if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
         if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
         DEBUG_EOL();
       }
@@ -542,20 +572,22 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
+    if (TERN0(PROBE_TARE, tare())) return NAN;
+
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
@@ -579,20 +611,23 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     float probes_z_sum = 0;
     for (
       #if EXTRA_PROBING > 0
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
+      // If the probe won't tare, return
+      if (TERN0(PROBE_TARE, tare())) return true;
+
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
                        sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.

commit 7a168205eb2463022ab1a4306bafa8152ab2d8bc
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:02:38 2020 -0500

    Minimum temp options for Probing and G12 Nozzle Clean (#20383)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index bcd3a03a9a..63b1928c76 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -318,20 +318,50 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif
 }
 
+#if EITHER(PREHEAT_BEFORE_PROBING, PREHEAT_BEFORE_LEVELING)
+
+  /**
+   * Do preheating as required before leveling or probing
+   */
+  void Probe::preheat_for_probing(const uint16_t hotend_temp, const uint16_t bed_temp) {
+    #if PROBING_NOZZLE_TEMP || LEVELING_NOZZLE_TEMP
+      #define WAIT_FOR_NOZZLE_HEAT
+    #endif
+    #if PROBING_BED_TEMP || LEVELING_BED_TEMP
+      #define WAIT_FOR_BED_HEAT
+    #endif
+    const uint16_t hotendPreheat = TERN0(WAIT_FOR_NOZZLE_HEAT, thermalManager.degHotend(0) < hotend_temp) ? hotend_temp : 0,
+                      bedPreheat = TERN0(WAIT_FOR_BED_HEAT,    thermalManager.degBed()     < bed_temp)    ? bed_temp    : 0;
+    DEBUG_ECHOPGM("Preheating ");
+    if (hotendPreheat) {
+      DEBUG_ECHOPAIR("hotend (", hotendPreheat, ") ");
+      if (bedPreheat) DEBUG_ECHOPGM("and ");
+    }
+    if (bedPreheat) DEBUG_ECHOPAIR("bed (", bedPreheat, ") ");
+    DEBUG_EOL();
+
+    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotendPreheat) thermalManager.setTargetHotend(hotendPreheat, 0));
+    TERN_(WAIT_FOR_BED_HEAT,    if (bedPreheat)    thermalManager.setTargetBed(bedPreheat));
+    TERN_(WAIT_FOR_NOZZLE_HEAT, if (hotendPreheat) thermalManager.wait_for_hotend(0));
+    TERN_(WAIT_FOR_BED_HEAT,    if (bedPreheat)    thermalManager.wait_for_bed_heating());
+  }
+
+#endif
+
 /**
  * Attempt to deploy or stow the probe
  *
  * Return TRUE if the probe could not be deployed/stowed
  */
 bool Probe::set_deployed(const bool deploy) {
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPAIR("deploy: ", deploy);
@@ -385,20 +415,23 @@ bool Probe::set_deployed(const bool deploy) {
       stop();
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
 
+  // If preheating is required before any probing...
+  TERN_(PREHEAT_BEFORE_PROBING, if (deploy) preheat_for_probing(PROBING_NOZZLE_TEMP, PROBING_BED_TEMP));
+
   do_blocking_move_to(old_xy);
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s

commit e5d0b27aafa9c33931e2abf668e498a3532b3dc2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 18 21:13:37 2020 -0600

    Rename QUIET_PROBING

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 17949a4420..bcd3a03a9a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -66,21 +66,21 @@
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
-#if QUIET_PROBING
+#if HAS_QUIET_PROBING
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
@@ -229,39 +229,39 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
-#if QUIET_PROBING
+#if HAS_QUIET_PROBING
 
   void Probe::set_probing_paused(const bool p) {
     TERN_(PROBING_HEATERS_OFF, thermalManager.pause(p));
     TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(p));
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
       #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
         DISABLE_AXIS_X(); DISABLE_AXIS_Y();
       #endif
     #endif
     if (p) safe_delay(25
       #if DELAY_BEFORE_PROBING > 25
         - 25 + DELAY_BEFORE_PROBING
       #endif
     );
   }
 
-#endif // QUIET_PROBING
+#endif // HAS_QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
   do_z_clearance(z_dest);
 }
@@ -430,35 +430,35 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
-  TERN_(QUIET_PROBING, set_probing_paused(true));
+  TERN_(HAS_QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
       TEST(endstops.trigger_state(), TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN, Z_MIN_PROBE))
     #endif
   ;
 
-  TERN_(QUIET_PROBING, set_probing_paused(false));
+  TERN_(HAS_QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif

commit fbcc07261d944222cca30ef8590fb387f53fcc70
Author: rafaljot <rafal@jastrzebscy.org>
Date:   Thu Dec 17 13:02:05 2020 +0100

    Homing feedrates as XYZ array (#20426)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index edf7ba3e20..17949a4420 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -509,39 +509,39 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (try_to_probe(PSTR("FAST"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST),
+    if (try_to_probe(PSTR("FAST"), z_probe_low_point, z_probe_fast_mm_s,
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
-    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
-      if (!probe_down_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
-        do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      if (!probe_down_to_z(z, z_probe_fast_mm_s))
+        do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, z_probe_fast_mm_s);
     }
   #endif
 
   #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
@@ -575,21 +575,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING > 0
             < TOTAL_PROBING - 1
           #endif
-        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, z_probe_fast_mm_s);
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
     #if EXTRA_PROBING > 0
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
@@ -665,21 +665,21 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
-      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), z_probe_fast_mm_s);
     else if (raise_after == PROBE_PT_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);

commit 20b3af1cc2c4a5e8505d1aae3419ab9418ed88ab
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 16 22:18:40 2020 -0600

    Use homing_feedrate function

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 400206f83a..edf7ba3e20 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -145,22 +145,22 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
   }
 
   // Move down to the bed to stow the probe
   inline void run_stow_moves_script() {
     const xyz_pos_t oldpos = current_position;
     endstops.enable_z_probe(false);
-    do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
-    do_blocking_move_to(oldpos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
+    do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, homing_feedrate(Z_AXIS));
+    do_blocking_move_to(oldpos, homing_feedrate(Z_AXIS));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
   inline void run_deploy_moves_script() {
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t deploy_1 = Z_PROBE_ALLEN_KEY_DEPLOY_1;
@@ -657,41 +657,36 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
   xyz_pos_t npos = { rx, ry, _MIN(TERN(DELTA, delta_clip_start_height, current_position.z), current_position.z) };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
       return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
-  const float old_feedrate_mm_s = feedrate_mm_s;
-  feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
-
   // Move the probe to the starting XYZ
-  do_blocking_move_to(npos);
+  do_blocking_move_to(npos, feedRate_t(XY_PROBE_FEEDRATE_MM_S));
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2)
       SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
-  feedrate_mm_s = old_feedrate_mm_s;
-
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
   return measured_z;
 }

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 11447d7129..400206f83a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -343,21 +343,21 @@ bool Probe::set_deployed(const bool deploy) {
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
-    const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
+    const bool unknown_condition = axis_is_trusted(Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
@@ -503,21 +503,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
         DEBUG_EOL();
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = axis_is_trusted(Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST),
                      sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 

commit 5cae4e9f55a851d27efce52b7d67bc9b231a0654
Author: ≈†tƒõp√°n Daleck√Ω <36531759+daleckystepan@users.noreply.github.com>
Date:   Thu Nov 26 22:21:48 2020 +0100

    [WIP] Fix Probe::offset_xy (#20290)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 47c6f569b7..11447d7129 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -82,21 +82,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
-  const xy_pos_t &Probe::offset_xy = xy_pos_t(Probe::offset);
+  const xy_pos_t &Probe::offset_xy = Probe::offset;
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.

commit 58ac815822b4c04f29b66ddf076156e6b4994749
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Thu Nov 26 10:58:19 2020 -0300

    Level Corners with Probe option (#20241)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f02b909150..47c6f569b7 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -263,27 +263,21 @@ void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        if (deploy == (
-          #if HAS_CUSTOM_PROBE_PIN
-            READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING
-          #else
-            READ(Z_MIN_PIN) == Z_MIN_ENDSTOP_INVERTING
-          #endif
-        )) break;
+        if (deploy == PROBE_TRIGGERED()) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
@@ -368,37 +362,29 @@ bool Probe::set_deployed(const bool deploy) {
     if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
-    #if HAS_CUSTOM_PROBE_PIN
-      #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
-    #else
-      #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
-    #endif
-  #endif
-
-  #ifdef PROBE_STOWED
 
     // Only deploy/stow if needed
-    if (PROBE_STOWED() == deploy) {
+    if (PROBE_TRIGGERED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
-    if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
+    if (PROBE_TRIGGERED() == deploy) {             // Unchanged after deploy/stow action?
       if (IsRunning()) {
         SERIAL_ERROR_MSG("Z-Probe failed");
         LCD_ALERTMESSAGEPGM_P(PSTR("Err: ZPROBE"));
       }
       stop();
       return true;
     }
 
   #else
 

commit 296a2ad7e45d88a10db4b3305ea183e5c0c177a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 24 17:38:13 2020 -0600

    Consistent Probe XY offset type

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ff80063d65..f02b909150 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -82,21 +82,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
-  const xyz_pos_t &Probe::offset_xy = Probe::offset;
+  const xy_pos_t &Probe::offset_xy = xy_pos_t(Probe::offset);
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.

commit c753d2b7f4161e2fff30cc9061dba5e6d68a7762
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Nov 9 01:31:14 2020 +0100

    Use extra G35 BLTouch HS Mode clearance in Tramming Wizard (#20057)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d008720389..ff80063d65 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -660,40 +660,31 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
-  // TODO: Adapt for SCARA, where the offset rotates
-  xyz_pos_t npos = { rx, ry };
+  // On delta keep Z below clip height or do_blocking_move_to will abort
+  xyz_pos_t npos = { rx, ry, _MIN(TERN(DELTA, delta_clip_start_height, current_position.z), current_position.z) };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
       return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
-  npos.z =
-    #if ENABLED(DELTA)
-      // Move below clip height or xy move will be aborted by do_blocking_move_to
-      _MIN(current_position.z, delta_clip_start_height)
-    #else
-      current_position.z
-    #endif
-  ;
-
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos);
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 27ceb989c0..d008720389 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -29,21 +29,21 @@
 #if HAS_BED_PROBE
 
 #include "probe.h"
 
 #include "../libs/buzzer.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 
 #include "../MarlinCore.h" // for stop(), disable_e_steppers
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif

commit 0b80841c38dcd8259821f72dc40c194e67042c5d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 16 18:19:48 2020 -0300

    Fix Color UI external_control, wait_for_release (#19771)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index defc22b1fe..27ceb989c0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,21 +31,21 @@
 #include "probe.h"
 
 #include "../libs/buzzer.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#include "../MarlinCore.h" // for stop(), disable_e_steppers, wait_for_user
+#include "../MarlinCore.h" // for stop(), disable_e_steppers
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index dd6bd70d2c..defc22b1fe 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -722,18 +722,17 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
-     *
      */
     STOW_Z_SERVO();
   }
 
 #endif // HAS_Z_SERVO_PROBE
 
 #endif // HAS_BED_PROBE

commit 7415e4e66d84022d19afbd89218addaa80b9e1be
Author: Siana Gearz <siana.sg@live.de>
Date:   Mon Sep 28 04:25:35 2020 +0200

    Fix Allen Key Probe pin test (#19520)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 12b617ec43..dd6bd70d2c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -263,21 +263,27 @@ void Probe::do_z_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
   do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        if (deploy == (READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING)) break;
+        if (deploy == (
+          #if HAS_CUSTOM_PROBE_PIN
+            READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING
+          #else
+            READ(Z_MIN_PIN) == Z_MIN_ENDSTOP_INVERTING
+          #endif
+        )) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 4fab4ec27b..12b617ec43 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -352,21 +352,21 @@ bool Probe::set_deployed(const bool deploy) {
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
-    if (axis_unhomed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
+    if (homing_needed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
     #if HAS_CUSTOM_PROBE_PIN

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 524b6228bc..4fab4ec27b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * module/probe.cpp
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_BED_PROBE

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b077b3a0e3..524b6228bc 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -253,29 +253,24 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       #endif
     );
   }
 
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::move_z(", z_raise, ")");
-
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::do_z_raise(", z_raise, ")");
   float z_dest = z_raise;
   if (offset.z < 0) z_dest -= offset.z;
-
-  NOMORE(z_dest, Z_MAX_POS);
-
-  if (z_dest > current_position.z)
-    do_blocking_move_to_z(z_dest);
+  do_z_clearance(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy == (READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING)) break;
       #endif
 
       BUZZ(100, 659);
@@ -403,50 +398,40 @@ bool Probe::set_deployed(const bool deploy) {
 
     probe_specific_action(deploy);
 
   #endif
 
   do_blocking_move_to(old_xy);
   endstops.enable_z_probe(deploy);
   return false;
 }
 
-#ifdef Z_AFTER_PROBING
-  // After probing move to a preferred Z position
-  void Probe::move_z_after_probing() {
-    if (current_position.z != Z_AFTER_PROBING) {
-      do_blocking_move_to_z(Z_AFTER_PROBING);
-      current_position.z = Z_AFTER_PROBING;
-    }
-  }
-#endif
-
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 /**
  * @brief Move down until the probe triggers or the low limit is reached
  *
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
-  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::probe_down_to_z", current_position);
+  DEBUG_SECTION(log_probe, "Probe::probe_down_to_z", DEBUGGING(LEVELING));
 
   #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
@@ -492,49 +477,45 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
-  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< Probe::probe_down_to_z", current_position);
-
   return !probe_triggered;
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
-
-  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
+  DEBUG_SECTION(log_probe, "Probe::run_z_probe", DEBUGGING(LEVELING));
 
   auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) {
     // Do a first probe at the fast speed
     const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
                early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
         DEBUG_PRINT_P(plbl);
         DEBUG_ECHOPGM(" Probe fail! -");
         if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
         if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
         DEBUG_EOL();
-        DEBUG_POS("<<< run_z_probe", current_position);
       }
     #else
       UNUSED(plbl);
     #endif
     return probe_fail || early_fail;
   };
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
@@ -644,38 +625,38 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position.z;
 
   #endif
 
-  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
-
   return measured_z;
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
+  DEBUG_SECTION(log_probe, "Probe::probe_at_point", DEBUGGING(LEVELING));
+
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
-      ">>> Probe::probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
+      "...(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
@@ -722,22 +703,20 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif
   }
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Probe::probe_at_point");
-
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow

commit 31349fd69af69dc855062ac7f8f6b3750ec5f1ca
Author: JP Flouret <jflouret@microsoft.com>
Date:   Sat Jun 27 21:09:15 2020 -0700

    Fix "probing failed" false positives (#18435)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 08aa53fc96..b077b3a0e3 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -537,21 +537,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (try_to_probe(PSTR("FAST"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST),
-                     sanity_check, _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2) ) return NAN;
+                     sanity_check, Z_CLEARANCE_BETWEEN_PROBES) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
@@ -575,21 +575,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #if EXTRA_PROBING > 0
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
-                       sanity_check, _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2) ) return NAN;
+                       sanity_check, Z_CLEARANCE_MULTI_PROBE) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point

commit 25c7c43a829e3bbc581aae20d24b724a7ad8fbdb
Author: Fabio Santos <fabiosan@live.com>
Date:   Mon Jun 22 19:12:45 2020 -0700

    Add SERIAL_FLOAT_PRECISION option (#18367)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6a75ef4685..08aa53fc96 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -708,25 +708,22 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
-    if (verbose_level > 2) {
-      SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
-      SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
-      SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
-    }
+    if (verbose_level > 2)
+      SERIAL_ECHOLNPAIR("Bed X: ", LOGICAL_X_POSITION(rx), " Y: ", LOGICAL_Y_POSITION(ry), " Z: ", measured_z);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     #if DISABLED(G29_RETRY_AND_RECOVER)
       SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
     #endif

commit 1ea4e393c9e955ac71455ef5f5d703eb9f9028e0
Author: Kirill Vergun <647149+o-nix@users.noreply.github.com>
Date:   Mon Jun 22 03:39:01 2020 +0300

    No 'probing failed' with retry (#18379)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6aefcfa8ac..6a75ef4685 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -720,21 +720,23 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
       SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
       SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
     }
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
-    SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
+    #if DISABLED(G29_RETRY_AND_RECOVER)
+      SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
+    #endif
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Probe::probe_at_point");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {

commit e5b0892f08f605a99dc15d68a6fef4b8f85cbe72
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 10 04:40:19 2020 -0500

    Fix TERN typo, EXTRA_PROBING
    
    Co-Authored-By: Matthew Kennedy <mattkenn4545@gmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d08ba27e1b..6aefcfa8ac 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -558,68 +558,71 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!probe_down_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
-  #ifdef EXTRA_PROBING
+  #if EXTRA_PROBING > 0
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
-      #if EXTRA_PROBING
+      #if EXTRA_PROBING > 0
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
                        sanity_check, _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2) ) return NAN;
 
       TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
-      #if EXTRA_PROBING
+      #if EXTRA_PROBING > 0
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_z_sum += z;
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
-        if (TERN(EXTRA_PROBING, p < TOTAL_PROBING - 1, p))
-          do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+        if (p
+          #if EXTRA_PROBING > 0
+            < TOTAL_PROBING - 1
+          #endif
+        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
-    #if EXTRA_PROBING
+    #if EXTRA_PROBING > 0
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
 
       // Remove values farthest from the median
       uint8_t min_avg_idx = 0, max_avg_idx = TOTAL_PROBING - 1;
       for (uint8_t i = EXTRA_PROBING; i--;)
         if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
           max_avg_idx--; else min_avg_idx++;

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 77e70680df..d08ba27e1b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -434,21 +434,21 @@ bool Probe::set_deployed(const bool deploy) {
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::probe_down_to_z", current_position);
 
-  #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     thermalManager.wait_for_bed_heating();
   #endif
 
   #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a96a9d5e9d..77e70680df 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -127,23 +127,21 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
-      #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR);
-      #endif
+      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR));
       wait_for_user_response();
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
@@ -234,37 +232,31 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if QUIET_PROBING
 
   void Probe::set_probing_paused(const bool p) {
-    #if ENABLED(PROBING_HEATERS_OFF)
-      thermalManager.pause(p);
-    #endif
-    #if ENABLED(PROBING_FANS_OFF)
-      thermalManager.set_fans_paused(p);
-    #endif
+    TERN_(PROBING_HEATERS_OFF, thermalManager.pause(p));
+    TERN_(PROBING_FANS_OFF, thermalManager.set_fans_paused(p));
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
       #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
         DISABLE_AXIS_X(); DISABLE_AXIS_Y();
       #endif
     #endif
-    if (p) safe_delay(
+    if (p) safe_delay(25
       #if DELAY_BEFORE_PROBING > 25
-        DELAY_BEFORE_PROBING
-      #else
-        25
+        - 25 + DELAY_BEFORE_PROBING
       #endif
     );
   }
 
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 void Probe::do_z_raise(const float z_raise) {
@@ -288,36 +280,27 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
-      #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR);
-      #endif
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe"));
-      #endif
+      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR));
+      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe")));
+
       wait_for_user_response();
       ui.reset_status();
 
-    } while(
-      #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        true
-      #else
-        false
-      #endif
-    );
+    } while (ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED));
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)
@@ -374,25 +357,21 @@ bool Probe::set_deployed(const bool deploy) {
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
-    if (axis_unhomed_error(
-      #if ENABLED(Z_PROBE_SLED)
-        _BV(X_AXIS)
-      #endif
-    )) {
+    if (axis_unhomed_error(TERN_(Z_PROBE_SLED, _BV(X_AXIS)))) {
       SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
     #if HAS_CUSTOM_PROBE_PIN
@@ -474,45 +453,35 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
-  #if QUIET_PROBING
-    set_probing_paused(true);
-  #endif
+  TERN_(QUIET_PROBING, set_probing_paused(true));
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
-      TEST(endstops.trigger_state(),
-        #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-          Z_MIN
-        #else
-          Z_MIN_PROBE
-        #endif
-      )
+      TEST(endstops.trigger_state(), TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN, Z_MIN_PROBE))
     #endif
   ;
 
-  #if QUIET_PROBING
-    set_probing_paused(false);
-  #endif
+  TERN_(QUIET_PROBING, set_probing_paused(false));
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif
@@ -608,48 +577,43 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
       if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
                        sanity_check, _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2) ) return NAN;
 
-      #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-        backlash.measure_with_probe();
-      #endif
+      TERN_(MEASURE_BACKLASH_WHEN_PROBING, backlash.measure_with_probe());
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_z_sum += z;
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
-        if (p
-          #if EXTRA_PROBING
-            < TOTAL_PROBING - 1
-          #endif
-        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+        if (TERN(EXTRA_PROBING, p < TOTAL_PROBING - 1, p))
+          do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
       #endif
     }
 
   #if TOTAL_PROBING > 2
 
     #if EXTRA_PROBING
       // Take the center value (or average the two middle values) as the median
       static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;

commit 720795ac7d18522e5403412c310b5b63b02b1e98
Author: Davide Toldo <davidetoldo@posteo.de>
Date:   Thu Apr 16 23:22:37 2020 +0200

    More verbose probing error (#17482)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b4912d30c4..a96a9d5e9d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -540,37 +540,49 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
 
+  auto try_to_probe = [&](PGM_P const plbl, const float &z_probe_low_point, const feedRate_t fr_mm_s, const bool scheck, const float clearance) {
+    // Do a first probe at the fast speed
+    const bool probe_fail = probe_down_to_z(z_probe_low_point, fr_mm_s),            // No probe trigger?
+               early_fail = (scheck && current_position.z > -offset.z + clearance); // Probe triggered too high?
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING) && (probe_fail || early_fail)) {
+        DEBUG_PRINT_P(plbl);
+        DEBUG_ECHOPGM(" Probe fail! -");
+        if (probe_fail) DEBUG_ECHOPGM(" No trigger.");
+        if (early_fail) DEBUG_ECHOPGM(" Triggered early.");
+        DEBUG_EOL();
+        DEBUG_POS("<<< run_z_probe", current_position);
+      }
+    #else
+      UNUSED(plbl);
+    #endif
+    return probe_fail || early_fail;
+  };
+
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))         // No probe trigger?
-      || (sanity_check && current_position.z > -offset.z + _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2)  // Probe triggered too high?
-    ) {
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLNPGM("FAST Probe fail!");
-        DEBUG_POS("<<< run_z_probe", current_position);
-      }
-      return NAN;
-    }
+    if (try_to_probe(PSTR("FAST"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST),
+                     sanity_check, _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2) ) return NAN;
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
@@ -593,29 +605,22 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
     for (
       #if EXTRA_PROBING
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
-      if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))      // No probe trigger?
-        || (sanity_check && current_position.z > -offset.z + _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2)  // Probe triggered too high?
-      ) {
-        if (DEBUGGING(LEVELING)) {
-          DEBUG_ECHOLNPGM("SLOW Probe fail!");
-          DEBUG_POS("<<< run_z_probe", current_position);
-        }
-        return NAN;
-      }
+      if (try_to_probe(PSTR("SLOW"), z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW),
+                       sanity_check, _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2) ) return NAN;
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z

commit f090a927f4094f42efea3455314c46c9ff307a64
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 12 15:16:04 2020 -0500

    Reapply BLTouch deploy/stow patch
    
    - Fixes #14328
    - Originally #14352
    - Reverted in 2580104

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6e3f2baa66..b4912d30c4 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -317,29 +317,27 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
+  #elif ENABLED(BLTOUCH)
+
+    deploy ? bltouch.deploy() : bltouch.stow();
+
   #elif HAS_Z_SERVO_PROBE
 
-    #if DISABLED(BLTOUCH)
-      MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
-    #elif ENABLED(BLTOUCH_HS_MODE)
-      // In HIGH SPEED MODE, use the normal retractable probe logic in this code
-      // i.e. no intermediate STOWs and DEPLOYs in between individual probe actions
-      if (deploy) bltouch.deploy(); else bltouch.stow();
-    #endif
+    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)

commit 747b964295118d425ad41cd7593dae48ccf9f14f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 28 03:18:53 2020 -0500

    Clean up user-wait, SD completion (#17315)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 962c230775..6e3f2baa66 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -127,26 +127,24 @@ xyz_pos_t Probe::offset; // Initialized by settings.load()
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      wait_for_user = true; // LCD click or M108 will clear this
       #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), CONTINUE_STR);
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI"), CONTINUE_STR);
       #endif
-      while (wait_for_user) idle();
+      wait_for_user_response();
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
@@ -290,29 +288,27 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR);
       #endif
       #if ENABLED(EXTENSIBLE_UI)
         ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe"));
       #endif
-      while (wait_for_user) idle();
+      wait_for_user_response();
       ui.reset_status();
 
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true
       #else
         false
       #endif
     );
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6376f92593..962c230775 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -617,21 +617,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
 
       const float z = current_position.z;
 
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
-        for (uint8_t i = 0; i <= p; i++) {                            // Iterate the saved Zs to insert the new Z
+        LOOP_LE_N(i, p) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_z_sum += z;
       #else
         UNUSED(z);
@@ -655,21 +655,21 @@ float Probe::run_z_probe(const bool sanity_check/*=true*/) {
       const float middle = probes[PHALF],
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
 
       // Remove values farthest from the median
       uint8_t min_avg_idx = 0, max_avg_idx = TOTAL_PROBING - 1;
       for (uint8_t i = EXTRA_PROBING; i--;)
         if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
           max_avg_idx--; else min_avg_idx++;
 
       // Return the average value of all remaining probes.
-      for (uint8_t i = min_avg_idx; i <= max_avg_idx; i++)
+      LOOP_S_LE_N(i, min_avg_idx, max_avg_idx)
         probes_z_sum += probes[i];
 
     #endif
 
     const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = current_position.z;
 

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 63008170bd..6376f92593 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -71,21 +71,21 @@
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
-  #include "../lcd/extensible_ui/ui_api.h"
+  #include "../lcd/extui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET

commit 7709261ea9f73d60006b5ab1ae488086908d0e79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 4 12:50:43 2020 -0600

    Move shared code to wait_for_bed_heating

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 67c1655374..63008170bd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -448,45 +448,35 @@ bool Probe::set_deployed(const bool deploy) {
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
-#if HAS_BED_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
-  const char Probe::msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
-#endif
-
 /**
  * @brief Move down until the probe triggers or the low limit is reached
  *
  * @details Used by run_z_probe to get each bed Z height measurement.
  *          Sets current_position.z to the height where the probe triggered
  *          (according to the Z stepper count). The float Z is propagated
  *          back to the planner.position to preempt any rounding error.
  *
  * @return TRUE if the probe failed to trigger.
  */
 bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::probe_down_to_z", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
-    // Wait for bed to heat back up between probing points
-    if (thermalManager.isHeatingBed()) {
-      serialprintPGM(msg_wait_for_bed_heating);
-      LCD_MESSAGEPGM(MSG_BED_HEATING);
-      thermalManager.wait_for_bed();
-      ui.reset_status();
-    }
+    thermalManager.wait_for_bed_heating();
   #endif
 
   #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 858dcae747..67c1655374 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -82,21 +82,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 Probe probe;
 
 xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
-  const xyz_pos_t &Probe::offset_xy = probe.offset;
+  const xyz_pos_t &Probe::offset_xy = Probe::offset;
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
@@ -720,21 +720,21 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
     DEBUG_POS("", current_position);
   }
 
   #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
     if (bltouch.triggered()) bltouch._reset();
   #endif
 
   // TODO: Adapt for SCARA, where the offset rotates
   xyz_pos_t npos = { rx, ry };
   if (probe_relative) {                                     // The given position is in terms of the probe
-    if (!position_is_reachable_by_probe(npos)) {
+    if (!can_reach(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
       return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   npos.z =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to

commit cf597e2bb1de6acab4753dde82221f5cfd8eb1c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 05:33:48 2020 -0600

    Allow weird probe values in G33

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index e22ee22d57..858dcae747 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -552,34 +552,34 @@ bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
-float Probe::run_z_probe() {
+float Probe::run_z_probe(const bool sanity_check/*=true*/) {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))         // No probe trigger?
-      || current_position.z > -offset.z + _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2  // Probe triggered too high?
+      || (sanity_check && current_position.z > -offset.z + _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2)  // Probe triggered too high?
     ) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
     const float first_probe_z = current_position.z;
 
@@ -610,21 +610,21 @@ float Probe::run_z_probe() {
       #if EXTRA_PROBING
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
       if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))      // No probe trigger?
-        || current_position.z > -offset.z + _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2  // Probe triggered too high?
+        || (sanity_check && current_position.z > -offset.z + _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2)  // Probe triggered too high?
       ) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
@@ -702,21 +702,21 @@ float Probe::run_z_probe() {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
+float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/, const bool sanity_check/*=true*/) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       ">>> Probe::probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
@@ -744,21 +744,21 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos);
 
   float measured_z = NAN;
-  if (!deploy()) measured_z = run_z_probe() + offset.z;
+  if (!deploy()) measured_z = run_z_probe(sanity_check) + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2) {
       SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
       SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cf74d464fe..e22ee22d57 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -385,21 +385,21 @@ bool Probe::set_deployed(const bool deploy) {
 
   if (deploy_stow_condition && unknown_condition)
     do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (axis_unhomed_error(
       #if ENABLED(Z_PROBE_SLED)
         _BV(X_AXIS)
       #endif
     )) {
-      SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
+      SERIAL_ERROR_MSG(STR_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
     #if HAS_CUSTOM_PROBE_PIN
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
@@ -764,21 +764,21 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
       SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
       SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
     }
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
-    SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
+    SERIAL_ERROR_MSG(STR_ERR_PROBING_FAILED);
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Probe::probe_at_point");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void Probe::servo_probe_init() {

commit 1d8d91afc66c10ebf007399b2c4e2dc57fef89d9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 12 14:57:00 2020 -0600

    No limit needed on this raise
    
    Remove an extraneous limit from #16811.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f01599cdc3..cf74d464fe 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -747,24 +747,22 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos);
 
   float measured_z = NAN;
   if (!deploy()) measured_z = run_z_probe() + offset.z;
   if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
-    if (big_raise || raise_after == PROBE_PT_RAISE) {
-      if (current_position.z < Z_PROBE_OFFSET_RANGE_MAX) // Only raise when in probing range (else error)
-        do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
-    }
+    if (big_raise || raise_after == PROBE_PT_RAISE)
+      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (stow()) measured_z = NAN;   // Error on stow?
 
     if (verbose_level > 2) {
       SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
       SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
       SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
     }
   }
 

commit 84b6e11bd53acbfde0ad82445e21d7bce1cc14f6
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Feb 9 08:46:38 2020 -0500

    Better probe fail handling (#16811)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 4bb434a922..f01599cdc3 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -564,21 +564,23 @@ float Probe::run_z_probe() {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
+    if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))         // No probe trigger?
+      || current_position.z > -offset.z + _MAX(Z_CLEARANCE_BETWEEN_PROBES, 4) / 2  // Probe triggered too high?
+    ) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
@@ -607,21 +609,23 @@ float Probe::run_z_probe() {
     for (
       #if EXTRA_PROBING
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
-      if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
+      if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))      // No probe trigger?
+        || current_position.z > -offset.z + _MAX(Z_CLEARANCE_MULTI_PROBE, 4) / 2  // Probe triggered too high?
+      ) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
@@ -709,20 +713,24 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       ">>> Probe::probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
+  #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
+    if (bltouch.triggered()) bltouch._reset();
+  #endif
+
   // TODO: Adapt for SCARA, where the offset rotates
   xyz_pos_t npos = { rx, ry };
   if (probe_relative) {                                     // The given position is in terms of the probe
     if (!position_is_reachable_by_probe(npos)) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
       return NAN;
     }
     npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
@@ -736,34 +744,35 @@ float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos);
 
   float measured_z = NAN;
-  if (!deploy()) {
-    measured_z = run_z_probe() + offset.z;
-
+  if (!deploy()) measured_z = run_z_probe() + offset.z;
+  if (!isnan(measured_z)) {
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
-    if (big_raise || raise_after == PROBE_PT_RAISE)
-      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    if (big_raise || raise_after == PROBE_PT_RAISE) {
+      if (current_position.z < Z_PROBE_OFFSET_RANGE_MAX) // Only raise when in probing range (else error)
+        do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    }
     else if (raise_after == PROBE_PT_STOW)
-      if (stow()) measured_z = NAN;
-  }
+      if (stow()) measured_z = NAN;   // Error on stow?
 
-  if (verbose_level > 2) {
-    SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
-    SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
-    SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
+    if (verbose_level > 2) {
+      SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
+      SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
+      SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
+    }
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 

commit 130e36d76659182f50565243ad331e8f7765165c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 8 17:47:54 2020 -0600

    Tweak ABL logging, document probing

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index c89c5eb087..4bb434a922 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -452,22 +452,32 @@ bool Probe::set_deployed(const bool deploy) {
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_BED_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char Probe::msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
-bool Probe::move_to_z(const float z, const feedRate_t fr_mm_s) {
-  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::move_to_z", current_position);
+/**
+ * @brief Move down until the probe triggers or the low limit is reached
+ *
+ * @details Used by run_z_probe to get each bed Z height measurement.
+ *          Sets current_position.z to the height where the probe triggered
+ *          (according to the Z stepper count). The float Z is propagated
+ *          back to the planner.position to preempt any rounding error.
+ *
+ * @return TRUE if the probe failed to trigger.
+ */
+bool Probe::probe_down_to_z(const float z, const feedRate_t fr_mm_s) {
+  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::probe_down_to_z", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
@@ -529,21 +539,21 @@ bool Probe::move_to_z(const float z, const feedRate_t fr_mm_s) {
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
-  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< Probe::move_to_z", current_position);
+  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< Probe::probe_down_to_z", current_position);
 
   return !probe_triggered;
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
@@ -554,21 +564,21 @@ float Probe::run_z_probe() {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (move_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
+    if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
@@ -576,42 +586,42 @@ float Probe::run_z_probe() {
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
-      if (!move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
+      if (!probe_down_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #ifdef EXTRA_PROBING
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_z_sum = 0;
     for (
       #if EXTRA_PROBING
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
-      if (move_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
+      if (probe_down_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 35aaf93f09..c89c5eb087 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 995a9238b37931ea41698abc90388bbb74c0ae5f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 07:51:50 2020 -0600

    Probe singleton patch
    
    Followup to #16751

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ef11a52122..35aaf93f09 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -448,22 +448,22 @@ bool Probe::set_deployed(const bool deploy) {
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
-#if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
-  PGM_P Probe::msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
+#if HAS_BED_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  const char Probe::msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
 bool Probe::move_to_z(const float z, const feedRate_t fr_mm_s) {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::move_to_z", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5710614e00..ef11a52122 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -14,21 +14,21 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
- * probe.cpp
+ * module/probe.cpp
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_BED_PROBE
 
 #include "probe.h"
 
 #include "../libs/buzzer.h"
 #include "motion.h"
@@ -77,55 +77,55 @@
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
+Probe probe;
 
-xyz_pos_t probe_offset; // Initialized by settings.load()
+xyz_pos_t Probe::offset; // Initialized by settings.load()
 
 #if HAS_PROBE_XY_OFFSET
-  xyz_pos_t &probe_offset_xy = probe_offset;
+  const xyz_pos_t &Probe::offset_xy = probe.offset;
 #endif
 
-
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
    *              If true, move to MAX_X and release the solenoid
    */
-  static void dock_sled(bool stow) {
+  static void dock_sled(const bool stow) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("dock_sled(", stow, ")");
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
-  void run_deploy_moves_script() {
+  inline void run_deploy_moves_script() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
       #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
@@ -146,30 +146,30 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
   }
 
   // Move down to the bed to stow the probe
-  void run_stow_moves_script() {
+  inline void run_stow_moves_script() {
     const xyz_pos_t oldpos = current_position;
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(oldpos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
-  void run_deploy_moves_script() {
+  inline void run_deploy_moves_script() {
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t deploy_1 = Z_PROBE_ALLEN_KEY_DEPLOY_1;
       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_2
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
@@ -193,21 +193,21 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_5
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t deploy_5 = Z_PROBE_ALLEN_KEY_DEPLOY_5;
       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
 
-  void run_stow_moves_script() {
+  inline void run_stow_moves_script() {
     #ifdef Z_PROBE_ALLEN_KEY_STOW_1
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t stow_1 = Z_PROBE_ALLEN_KEY_STOW_1;
       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_2
       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
@@ -234,51 +234,53 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
       constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if QUIET_PROBING
-  void probing_pause(const bool p) {
+
+  void Probe::set_probing_paused(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
       thermalManager.set_fans_paused(p);
     #endif
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
       #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
         DISABLE_AXIS_X(); DISABLE_AXIS_Y();
       #endif
     #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );
   }
+
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
-inline void do_probe_raise(const float z_raise) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
+void Probe::do_z_raise(const float z_raise) {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Probe::move_z(", z_raise, ")");
 
   float z_dest = z_raise;
-  if (probe_offset.z < 0) z_dest -= probe_offset.z;
+  if (offset.z < 0) z_dest -= offset.z;
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position.z)
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
@@ -344,25 +346,29 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif
 }
 
-// returns false for ok and true for failure
-bool set_probe_deployed(const bool deploy) {
+/**
+ * Attempt to deploy or stow the probe
+ *
+ * Return TRUE if the probe could not be deployed/stowed
+ */
+bool Probe::set_deployed(const bool deploy) {
 
   if (DEBUGGING(LEVELING)) {
-    DEBUG_POS("set_probe_deployed", current_position);
+    DEBUG_POS("Probe::set_deployed", current_position);
     DEBUG_ECHOLNPAIR("deploy: ", deploy);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
@@ -371,21 +377,21 @@ bool set_probe_deployed(const bool deploy) {
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
-    do_probe_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
+    do_z_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     if (axis_unhomed_error(
       #if ENABLED(Z_PROBE_SLED)
         _BV(X_AXIS)
       #endif
     )) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
@@ -426,42 +432,42 @@ bool set_probe_deployed(const bool deploy) {
 
   #endif
 
   do_blocking_move_to(old_xy);
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 #ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position
-  void move_z_after_probing() {
+  void Probe::move_z_after_probing() {
     if (current_position.z != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position.z = Z_AFTER_PROBING;
     }
   }
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
-  const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
+  PGM_P Probe::msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
-static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
-  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
+bool Probe::move_to_z(const float z, const feedRate_t fr_mm_s) {
+  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::move_to_z", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
@@ -475,21 +481,21 @@ static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
     sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
   #if QUIET_PROBING
-    probing_pause(true);
+    set_probing_paused(true);
   #endif
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if BOTH(DELTA, SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
@@ -497,21 +503,21 @@ static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
         #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           Z_MIN
         #else
           Z_MIN_PROBE
         #endif
       )
     #endif
   ;
 
   #if QUIET_PROBING
-    probing_pause(false);
+    set_probing_paused(false);
   #endif
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
@@ -523,89 +529,89 @@ static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
-  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
+  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< Probe::move_to_z", current_position);
 
   return !probe_triggered;
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
-static float run_z_probe() {
+float Probe::run_z_probe() {
 
-  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
+  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> Probe::run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -probe_offset.z + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
+    if (move_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
     const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (probe_offset.z < 0 ? -probe_offset.z : 0);
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (offset.z < 0 ? -offset.z : 0);
     if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
-      if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
+      if (!move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #ifdef EXTRA_PROBING
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
-    float probes_total = 0;
+    float probes_z_sum = 0;
     for (
       #if EXTRA_PROBING
         uint8_t p = 0; p < TOTAL_PROBING; p++
       #else
         uint8_t p = TOTAL_PROBING; p--;
       #endif
     )
   #endif
     {
       // Probe downward slowly to find the bed
-      if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
+      if (move_to_z(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
@@ -615,21 +621,21 @@ static float run_z_probe() {
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         for (uint8_t i = 0; i <= p; i++) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
-        probes_total += z;
+        probes_z_sum += z;
       #else
         UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING
             < TOTAL_PROBING - 1
           #endif
@@ -646,25 +652,25 @@ static float run_z_probe() {
                   median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
 
       // Remove values farthest from the median
       uint8_t min_avg_idx = 0, max_avg_idx = TOTAL_PROBING - 1;
       for (uint8_t i = EXTRA_PROBING; i--;)
         if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
           max_avg_idx--; else min_avg_idx++;
 
       // Return the average value of all remaining probes.
       for (uint8_t i = min_avg_idx; i <= max_avg_idx; i++)
-        probes_total += probes[i];
+        probes_z_sum += probes[i];
 
     #endif
 
-    const float measured_z = probes_total * RECIPROCAL(MULTIPLE_PROBING);
+    const float measured_z = probes_z_sum * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
@@ -682,87 +688,90 @@ static float run_z_probe() {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
+float Probe::probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
-      ">>> probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
+      ">>> Probe::probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
   xyz_pos_t npos = { rx, ry };
-  if (probe_relative) {
-    if (!position_is_reachable_by_probe(npos)) return NAN;  // The given position is in terms of the probe
-    npos -= probe_offset_xy;                                // Get the nozzle position
+  if (probe_relative) {                                     // The given position is in terms of the probe
+    if (!position_is_reachable_by_probe(npos)) {
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Position Not Reachable");
+      return NAN;
+    }
+    npos -= offset_xy;                                      // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   npos.z =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       _MIN(current_position.z, delta_clip_start_height)
     #else
       current_position.z
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(npos);
 
   float measured_z = NAN;
-  if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe() + probe_offset.z;
+  if (!deploy()) {
+    measured_z = run_z_probe() + offset.z;
 
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
-      if (STOW_PROBE()) measured_z = NAN;
+      if (stow()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
-    SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
-    SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
+    SERIAL_ECHOPAIR_F(   " Y: ", LOGICAL_Y_POSITION(ry), 3);
+    SERIAL_ECHOLNPAIR_F( " Z: ", measured_z, 3);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
-    STOW_PROBE();
+    stow();
     LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_at_point");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Probe::probe_at_point");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
-  void servo_probe_init() {
+  void Probe::servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      *
      */
     STOW_Z_SERVO();

commit 50889c0f94778c378357bcc4d4a966fa869bc5c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:23 2020 -0600

    Move L64XX index_to_axis to progmem (#16697)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 31c1128369..5710614e00 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -244,21 +244,21 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
       thermalManager.set_fans_paused(p);
     #endif
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
       #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
-        disable_X(); disable_Y();
+        DISABLE_AXIS_X(); DISABLE_AXIS_Y();
       #endif
     #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );
   }

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index efe8b8a2bd..31c1128369 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -49,22 +49,20 @@
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
-xyz_pos_t probe_offset; // Initialized by settings.load()
-
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
@@ -79,20 +77,28 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
+
+xyz_pos_t probe_offset; // Initialized by settings.load()
+
+#if HAS_PROBE_XY_OFFSET
+  xyz_pos_t &probe_offset_xy = probe_offset;
+#endif
+
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
@@ -691,21 +697,21 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
   xyz_pos_t npos = { rx, ry };
   if (probe_relative) {
     if (!position_is_reachable_by_probe(npos)) return NAN;  // The given position is in terms of the probe
-    npos -= probe_offset;                                   // Get the nozzle position
+    npos -= probe_offset_xy;                                // Get the nozzle position
   }
   else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
   npos.z =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       _MIN(current_position.z, delta_clip_start_height)
     #else
       current_position.z
     #endif

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 10e9dd5fff..efe8b8a2bd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,21 +31,21 @@
 #include "probe.h"
 
 #include "../libs/buzzer.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#include "../Marlin.h" // for stop(), disable_e_steppers, wait_for_user
+#include "../MarlinCore.h" // for stop(), disable_e_steppers, wait_for_user
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 1c9ccce5209cd1727bf80e632f4f781c651e0c35
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 24 01:03:08 2019 -0500

    Add NOZZLE_AS_PROBE (no probe offsets) (#15929)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 36789251fd..10e9dd5fff 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -351,21 +351,21 @@ bool set_probe_deployed(const bool deploy) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_POS("set_probe_deployed", current_position);
     DEBUG_ECHOLNPAIR("deploy: ", deploy);
   }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
-  #if ENABLED(FIX_MOUNTED_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
+  #if EITHER(FIX_MOUNTED_PROBE, NOZZLE_AS_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;

commit 509e1ab0530d9761c9077e259d9b598a494d79f8
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Sun Dec 15 11:21:39 2019 -0600

    TOUCH_MI_DEPLOY_XPOS fallback to X_MIN_POS (#16226)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index eaabd687f6..36789251fd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -106,21 +106,23 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
-    #if TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
+    #ifndef TOUCH_MI_DEPLOY_XPOS
+      #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
+    #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
     #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
       TemporaryGlobalEndstopsState unlock_y(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index cbe6035af7..eaabd687f6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -122,21 +122,21 @@ xyz_pos_t probe_offset; // Initialized by settings.load()
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true; // LCD click or M108 will clear this
       #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), PSTR("Continue"));
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), CONTINUE_STR);
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
     #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
@@ -283,21 +283,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
       PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), CONTINUE_STR);
       #endif
       #if ENABLED(EXTENSIBLE_UI)
         ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
 
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true

commit fe4c69b64abc74bc1ee1eb16d3d3771e3afbf25d
Author: Piotr <peter_k@tut.by>
Date:   Tue Oct 15 21:28:04 2019 +0300

    Poll *all* enabled endstop pins (#15525)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f183170a20..cbe6035af7 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -380,21 +380,21 @@ bool set_probe_deployed(const bool deploy) {
     )) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
-    #if USES_Z_MIN_PROBE_ENDSTOP
+    #if HAS_CUSTOM_PROBE_PIN
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif
   #endif
 
   #ifdef PROBE_STOWED
 
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0217a2fd59..f183170a20 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -274,33 +274,33 @@ inline void do_probe_raise(const float z_raise) {
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy == (READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING)) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
-      PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+      PGM_P const ds_str = deploy ? GET_TEXT(MSG_MANUAL_DEPLOY) : GET_TEXT(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
       #endif
       #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onUserConfirmRequired(PSTR("Stow Probe"));
+        ExtUI::onUserConfirmRequired_P(PSTR("Stow Probe"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
 
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true
       #else
         false
       #endif
@@ -399,21 +399,21 @@ bool set_probe_deployed(const bool deploy) {
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
     if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
       if (IsRunning()) {
         SERIAL_ERROR_MSG("Z-Probe failed");
-        LCD_ALERTMESSAGEPGM("Err: ZPROBE");
+        LCD_ALERTMESSAGEPGM_P(PSTR("Err: ZPROBE"));
       }
       stop();
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
@@ -729,21 +729,21 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
     SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
     SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     STOW_PROBE();
-    LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
+    LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_at_point");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ce0d84e41b..0217a2fd59 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -49,21 +49,21 @@
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
-float probe_offset[XYZ]; // Initialized by settings.load()
+xyz_pos_t probe_offset; // Initialized by settings.load()
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
@@ -139,100 +139,100 @@ float probe_offset[XYZ]; // Initialized by settings.load()
       do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
     #elif defined(TOUCH_MI_DEPLOY_YPOS)
       do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
   }
 
   // Move down to the bed to stow the probe
   void run_stow_moves_script() {
-    const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
+    const xyz_pos_t oldpos = current_position;
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
-    do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
+    do_blocking_move_to(oldpos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
   void run_deploy_moves_script() {
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
       #endif
-      constexpr float deploy_1[] = Z_PROBE_ALLEN_KEY_DEPLOY_1;
+      constexpr xyz_pos_t deploy_1 = Z_PROBE_ALLEN_KEY_DEPLOY_1;
       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_2
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
       #endif
-      constexpr float deploy_2[] = Z_PROBE_ALLEN_KEY_DEPLOY_2;
+      constexpr xyz_pos_t deploy_2 = Z_PROBE_ALLEN_KEY_DEPLOY_2;
       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
       #endif
-      constexpr float deploy_3[] = Z_PROBE_ALLEN_KEY_DEPLOY_3;
+      constexpr xyz_pos_t deploy_3 = Z_PROBE_ALLEN_KEY_DEPLOY_3;
       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_4
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
       #endif
-      constexpr float deploy_4[] = Z_PROBE_ALLEN_KEY_DEPLOY_4;
+      constexpr xyz_pos_t deploy_4 = Z_PROBE_ALLEN_KEY_DEPLOY_4;
       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_5
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
       #endif
-      constexpr float deploy_5[] = Z_PROBE_ALLEN_KEY_DEPLOY_5;
+      constexpr xyz_pos_t deploy_5 = Z_PROBE_ALLEN_KEY_DEPLOY_5;
       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
 
   void run_stow_moves_script() {
     #ifdef Z_PROBE_ALLEN_KEY_STOW_1
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
       #endif
-      constexpr float stow_1[] = Z_PROBE_ALLEN_KEY_STOW_1;
+      constexpr xyz_pos_t stow_1 = Z_PROBE_ALLEN_KEY_STOW_1;
       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_2
       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
       #endif
-      constexpr float stow_2[] = Z_PROBE_ALLEN_KEY_STOW_2;
+      constexpr xyz_pos_t stow_2 = Z_PROBE_ALLEN_KEY_STOW_2;
       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_3
       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
       #endif
-      constexpr float stow_3[] = Z_PROBE_ALLEN_KEY_STOW_3;
+      constexpr xyz_pos_t stow_3 = Z_PROBE_ALLEN_KEY_STOW_3;
       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_4
       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
       #endif
-      constexpr float stow_4[] = Z_PROBE_ALLEN_KEY_STOW_4;
+      constexpr xyz_pos_t stow_4 = Z_PROBE_ALLEN_KEY_STOW_4;
       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
     #endif
     #ifdef Z_PROBE_ALLEN_KEY_STOW_5
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
-      constexpr float stow_5[] = Z_PROBE_ALLEN_KEY_STOW_5;
+      constexpr xyz_pos_t stow_5 = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
@@ -256,25 +256,25 @@ float probe_offset[XYZ]; // Initialized by settings.load()
   }
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
 
   float z_dest = z_raise;
-  if (probe_offset[Z_AXIS] < 0) z_dest -= probe_offset[Z_AXIS];
+  if (probe_offset.z < 0) z_dest -= probe_offset.z;
 
   NOMORE(z_dest, Z_MAX_POS);
 
-  if (z_dest > current_position[Z_AXIS])
+  if (z_dest > current_position.z)
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         if (deploy == (READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING)) break;
       #endif
 
@@ -377,22 +377,21 @@ bool set_probe_deployed(const bool deploy) {
       #if ENABLED(Z_PROBE_SLED)
         _BV(X_AXIS)
       #endif
     )) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
-  const float oldXpos = current_position[X_AXIS],
-              oldYpos = current_position[Y_AXIS];
+  const xy_pos_t old_xy = current_position;
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif
   #endif
 
   #ifdef PROBE_STOWED
@@ -412,31 +411,31 @@ bool set_probe_deployed(const bool deploy) {
       stop();
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
   #endif
 
-  do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
+  do_blocking_move_to(old_xy);
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 #ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position
   void move_z_after_probing() {
-    if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
+    if (current_position.z != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
-      current_position[Z_AXIS] = Z_AFTER_PROBING;
+      current_position.z = Z_AFTER_PROBING;
     }
   }
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
@@ -525,60 +524,60 @@ static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
 
   return !probe_triggered;
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
  * @details Used by probe_at_point to get the bed Z height at the current XY.
- *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
+ *          Leaves current_position.z at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 static float run_z_probe() {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -probe_offset[Z_AXIS] + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -probe_offset.z + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
-    const float first_probe_z = current_position[Z_AXIS];
+    const float first_probe_z = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
-    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (probe_offset[Z_AXIS] < 0 ? -probe_offset[Z_AXIS] : 0);
-    if (current_position[Z_AXIS] > z) {
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (probe_offset.z < 0 ? -probe_offset.z : 0);
+    if (current_position.z > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
-        do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+        do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #ifdef EXTRA_PROBING
     float probes[TOTAL_PROBING];
   #endif
 
   #if TOTAL_PROBING > 2
     float probes_total = 0;
     for (
@@ -596,21 +595,21 @@ static float run_z_probe() {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
 
-      const float z = current_position[Z_AXIS];
+      const float z = current_position.z;
 
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         for (uint8_t i = 0; i <= p; i++) {                            // Iterate the saved Zs to insert the new Z
           if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
             probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
@@ -647,31 +646,31 @@ static float run_z_probe() {
       // Return the average value of all remaining probes.
       for (uint8_t i = min_avg_idx; i <= max_avg_idx; i++)
         probes_total += probes[i];
 
     #endif
 
     const float measured_z = probes_total * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
-    const float z2 = current_position[Z_AXIS];
+    const float z2 = current_position.z;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
-    const float measured_z = current_position[Z_AXIS];
+    const float measured_z = current_position.z;
 
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
 
   return measured_z;
 }
 
 /**
  * - Move to the given XY
@@ -687,50 +686,49 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
     DEBUG_ECHOLNPAIR(
       ">>> probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
-  float nx = rx, ny = ry;
+  xyz_pos_t npos = { rx, ry };
   if (probe_relative) {
-    if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
-    nx -= probe_offset[X_AXIS];                     // Get the nozzle position
-    ny -= probe_offset[Y_AXIS];
+    if (!position_is_reachable_by_probe(npos)) return NAN;  // The given position is in terms of the probe
+    npos -= probe_offset;                                   // Get the nozzle position
   }
-  else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
+  else if (!position_is_reachable(npos)) return NAN;        // The given position is in terms of the nozzle
 
-  const float nz =
+  npos.z =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
-      _MIN(current_position[Z_AXIS], delta_clip_start_height)
+      _MIN(current_position.z, delta_clip_start_height)
     #else
-      current_position[Z_AXIS]
+      current_position.z
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
-  do_blocking_move_to(nx, ny, nz);
+  do_blocking_move_to(npos);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe() + probe_offset[Z_AXIS];
+    measured_z = run_z_probe() + probe_offset.z;
 
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
-      do_blocking_move_to_z(current_position[Z_AXIS] + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      do_blocking_move_to_z(current_position.z + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
     SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
     SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
   }
 

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 830f6d4c0d..ce0d84e41b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -439,21 +439,21 @@ bool set_probe_deployed(const bool deploy) {
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
-static bool do_probe_move(const float z, const float fr_mm_s) {
+static bool do_probe_move(const float z, const feedRate_t fr_mm_s) {
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }

commit b2e1f77f58a67ac02503cbe36b22a21e5afaeac0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 21:01:29 2019 -0500

    Fix extraneous "Home XYZ First" message

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 13c920082c..830f6d4c0d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -366,26 +366,25 @@ bool set_probe_deployed(const bool deploy) {
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_probe_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
-    #if ENABLED(Z_PROBE_SLED)
-      #define _AUE_ARGS true, false, false
-    #else
-      #define _AUE_ARGS
-    #endif
-    if (axis_unhomed_error(_AUE_ARGS)) {
+    if (axis_unhomed_error(
+      #if ENABLED(Z_PROBE_SLED)
+        _BV(X_AXIS)
+      #endif
+    )) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)

commit 9c288a682dcdd3063d5cf3ccefbf6502ed0f65ff
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Sep 25 14:29:10 2019 +0700

    Followup to probe_at_point change (#15342)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 777c1c9ea1..13c920082c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -525,21 +525,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   sync_plan_position();
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
 
   return !probe_triggered;
 }
 
 /**
  * @brief Probe at the current XY (possibly more than once) to find the bed Z.
  *
- * @details Used by probe_pt to get the bed Z height at the current XY.
+ * @details Used by probe_at_point to get the bed Z height at the current XY.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 static float run_z_probe() {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
@@ -679,21 +679,21 @@ static float run_z_probe() {
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
-      ">>> probe_pt(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
+      ">>> probe_at_point(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
@@ -736,21 +736,21 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     STOW_PROBE();
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_pt");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_at_point");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *

commit 5288c399ce780cd3e91ee413d1f92ca9e4da53a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:34:07 2019 -0500

    Patch probe offset name, defines

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 37422bdb15..777c1c9ea1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -21,23 +21,23 @@
  */
 
 /**
  * probe.cpp
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_BED_PROBE
 
-#include "../libs/buzzer.h"
-
 #include "probe.h"
+
+#include "../libs/buzzer.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
 #include "../Marlin.h" // for stop(), disable_e_steppers, wait_for_user
 
 #if HAS_LEVELING
@@ -79,57 +79,20 @@ float probe_offset[XYZ]; // Initialized by settings.load()
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-float probe_min_x() {
-  return _MAX(
-    #if ENABLED(DELTA) || IS_SCARA
-      PROBE_X_MIN, MESH_MIN_X
-    #else
-      (X_MIN_BED) + (MIN_PROBE_EDGE), (X_MIN_POS) + probe_offset[X_AXIS]
-    #endif
-  );
-}
-float probe_max_x() {
-  return _MIN(
-    #if ENABLED(DELTA) || IS_SCARA
-      PROBE_X_MAX, MESH_MAX_X
-    #else
-      (X_MAX_BED) - (MIN_PROBE_EDGE), (X_MAX_POS) + probe_offset[X_AXIS]
-    #endif
-  );
-}
-float probe_min_y() {
-  return _MAX(
-    #if ENABLED(DELTA) || IS_SCARA
-      PROBE_Y_MIN, MESH_MIN_Y
-    #else
-      (Y_MIN_BED) + (MIN_PROBE_EDGE), (Y_MIN_POS) + probe_offset[Y_AXIS]
-    #endif
-  );
-}
-float probe_max_y() {
-  return _MIN(
-    #if ENABLED(DELTA) || IS_SCARA
-      PROBE_Y_MAX, MESH_MAX_Y
-    #else
-      (Y_MAX_BED) - (MIN_PROBE_EDGE), (Y_MAX_POS) + probe_offset[Y_AXIS]
-    #endif
-  );
-}
-
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f9cfd26f9a..37422bdb15 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -49,21 +49,21 @@
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
-float zprobe_offset[XYZ]; // Initialized by settings.load()
+float probe_offset[XYZ]; // Initialized by settings.load()
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
@@ -84,48 +84,48 @@ float zprobe_offset[XYZ]; // Initialized by settings.load()
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 float probe_min_x() {
   return _MAX(
     #if ENABLED(DELTA) || IS_SCARA
       PROBE_X_MIN, MESH_MIN_X
     #else
-      (X_MIN_BED) + (MIN_PROBE_EDGE), (X_MIN_POS) + zprobe_offset[X_AXIS]
+      (X_MIN_BED) + (MIN_PROBE_EDGE), (X_MIN_POS) + probe_offset[X_AXIS]
     #endif
   );
 }
 float probe_max_x() {
   return _MIN(
     #if ENABLED(DELTA) || IS_SCARA
       PROBE_X_MAX, MESH_MAX_X
     #else
-      (X_MAX_BED) - (MIN_PROBE_EDGE), (X_MAX_POS) + zprobe_offset[X_AXIS]
+      (X_MAX_BED) - (MIN_PROBE_EDGE), (X_MAX_POS) + probe_offset[X_AXIS]
     #endif
   );
 }
 float probe_min_y() {
   return _MAX(
     #if ENABLED(DELTA) || IS_SCARA
       PROBE_Y_MIN, MESH_MIN_Y
     #else
-      (Y_MIN_BED) + (MIN_PROBE_EDGE), (Y_MIN_POS) + zprobe_offset[Y_AXIS]
+      (Y_MIN_BED) + (MIN_PROBE_EDGE), (Y_MIN_POS) + probe_offset[Y_AXIS]
     #endif
   );
 }
 float probe_max_y() {
   return _MIN(
     #if ENABLED(DELTA) || IS_SCARA
       PROBE_Y_MAX, MESH_MAX_Y
     #else
-      (Y_MAX_BED) - (MIN_PROBE_EDGE), (Y_MAX_POS) + zprobe_offset[Y_AXIS]
+      (Y_MAX_BED) - (MIN_PROBE_EDGE), (Y_MAX_POS) + probe_offset[Y_AXIS]
     #endif
   );
 }
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
@@ -293,21 +293,21 @@ float probe_max_y() {
   }
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
 
   float z_dest = z_raise;
-  if (zprobe_offset[Z_AXIS] < 0) z_dest -= zprobe_offset[Z_AXIS];
+  if (probe_offset[Z_AXIS] < 0) z_dest -= probe_offset[Z_AXIS];
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
@@ -573,21 +573,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 static float run_z_probe() {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_offset[Z_AXIS] + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -probe_offset[Z_AXIS] + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
@@ -598,21 +598,21 @@ static float run_z_probe() {
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_offset[Z_AXIS] < 0 ? -zprobe_offset[Z_AXIS] : 0);
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (probe_offset[Z_AXIS] < 0 ? -probe_offset[Z_AXIS] : 0);
     if (current_position[Z_AXIS] > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #ifdef EXTRA_PROBING
     float probes[TOTAL_PROBING];
   #endif
@@ -728,43 +728,43 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
-    nx -= zprobe_offset[X_AXIS];                     // Get the nozzle position
-    ny -= zprobe_offset[Y_AXIS];
+    nx -= probe_offset[X_AXIS];                     // Get the nozzle position
+    ny -= probe_offset[Y_AXIS];
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       _MIN(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe() + zprobe_offset[Z_AXIS];
+    measured_z = run_z_probe() + probe_offset[Z_AXIS];
 
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f470822637..f9cfd26f9a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -49,21 +49,21 @@
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
-float zprobe_zoffset; // Initialized by settings.load()
+float zprobe_offset[XYZ]; // Initialized by settings.load()
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
 #endif
 
 #if HAS_Z_SERVO_PROBE
@@ -79,20 +79,57 @@ float zprobe_zoffset; // Initialized by settings.load()
   #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
+float probe_min_x() {
+  return _MAX(
+    #if ENABLED(DELTA) || IS_SCARA
+      PROBE_X_MIN, MESH_MIN_X
+    #else
+      (X_MIN_BED) + (MIN_PROBE_EDGE), (X_MIN_POS) + zprobe_offset[X_AXIS]
+    #endif
+  );
+}
+float probe_max_x() {
+  return _MIN(
+    #if ENABLED(DELTA) || IS_SCARA
+      PROBE_X_MAX, MESH_MAX_X
+    #else
+      (X_MAX_BED) - (MIN_PROBE_EDGE), (X_MAX_POS) + zprobe_offset[X_AXIS]
+    #endif
+  );
+}
+float probe_min_y() {
+  return _MAX(
+    #if ENABLED(DELTA) || IS_SCARA
+      PROBE_Y_MIN, MESH_MIN_Y
+    #else
+      (Y_MIN_BED) + (MIN_PROBE_EDGE), (Y_MIN_POS) + zprobe_offset[Y_AXIS]
+    #endif
+  );
+}
+float probe_max_y() {
+  return _MIN(
+    #if ENABLED(DELTA) || IS_SCARA
+      PROBE_Y_MAX, MESH_MAX_Y
+    #else
+      (Y_MAX_BED) - (MIN_PROBE_EDGE), (Y_MAX_POS) + zprobe_offset[Y_AXIS]
+    #endif
+  );
+}
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
@@ -256,21 +293,21 @@ float zprobe_zoffset; // Initialized by settings.load()
   }
 #endif // QUIET_PROBING
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
 
   float z_dest = z_raise;
-  if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
+  if (zprobe_offset[Z_AXIS] < 0) z_dest -= zprobe_offset[Z_AXIS];
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
@@ -536,21 +573,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The Z position of the bed at the current XY or NAN on error.
  */
 static float run_z_probe() {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_offset[Z_AXIS] + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
@@ -561,21 +598,21 @@ static float run_z_probe() {
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // Raise to give the probe clearance
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_zoffset < 0 ? -zprobe_zoffset : 0);
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_offset[Z_AXIS] < 0 ? -zprobe_offset[Z_AXIS] : 0);
     if (current_position[Z_AXIS] > z) {
       // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #ifdef EXTRA_PROBING
     float probes[TOTAL_PROBING];
   #endif
@@ -691,43 +728,43 @@ float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
-    nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
-    ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
+    nx -= zprobe_offset[X_AXIS];                     // Get the nozzle position
+    ny -= zprobe_offset[Y_AXIS];
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       _MIN(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe() + zprobe_zoffset;
+    measured_z = run_z_probe() + zprobe_offset[Z_AXIS];
 
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 34ca2871cc..f470822637 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -676,21 +676,21 @@ static float run_z_probe() {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
+float probe_at_point(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPAIR(
       ">>> probe_pt(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
       ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
       ", ", int(verbose_level),
       ", ", probe_relative ? "probe" : "nozzle", "_relative)"
     );
     DEBUG_POS("", current_position);
   }
 

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8535bf854b..34ca2871cc 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -148,181 +148,91 @@ float zprobe_zoffset; // Initialized by settings.load()
   void run_stow_moves_script() {
     const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
   void run_deploy_moves_script() {
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_1
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
       #endif
-      const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
+      constexpr float deploy_1[] = Z_PROBE_ALLEN_KEY_DEPLOY_1;
       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_2
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
       #endif
-      const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
+      constexpr float deploy_2[] = Z_PROBE_ALLEN_KEY_DEPLOY_2;
       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
       #endif
-      const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
+      constexpr float deploy_3[] = Z_PROBE_ALLEN_KEY_DEPLOY_3;
       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_4
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
       #endif
-      const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
+      constexpr float deploy_4[] = Z_PROBE_ALLEN_KEY_DEPLOY_4;
       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_5
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
       #endif
-      const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
+      constexpr float deploy_5[] = Z_PROBE_ALLEN_KEY_DEPLOY_5;
       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
     #endif
   }
 
   void run_stow_moves_script() {
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
-        #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_STOW_1
       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
       #endif
-      const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
+      constexpr float stow_1[] = Z_PROBE_ALLEN_KEY_STOW_1;
       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
-        #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_STOW_2
       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
       #endif
-      const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
+      constexpr float stow_2[] = Z_PROBE_ALLEN_KEY_STOW_2;
       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
-        #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_STOW_3
       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
       #endif
-      const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
+      constexpr float stow_3[] = Z_PROBE_ALLEN_KEY_STOW_3;
       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
-        #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_STOW_4
       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
       #endif
-      const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
+      constexpr float stow_4[] = Z_PROBE_ALLEN_KEY_STOW_4;
       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
     #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
-        #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
-      #endif
+    #ifdef Z_PROBE_ALLEN_KEY_STOW_5
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
-      const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
+      constexpr float stow_5[] = Z_PROBE_ALLEN_KEY_STOW_5;
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
@@ -734,21 +644,21 @@ static float run_z_probe() {
       for (uint8_t i = EXTRA_PROBING; i--;)
         if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
           max_avg_idx--; else min_avg_idx++;
 
       // Return the average value of all remaining probes.
       for (uint8_t i = min_avg_idx; i <= max_avg_idx; i++)
         probes_total += probes[i];
 
     #endif
 
-    const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
+    const float measured_z = probes_total * RECIPROCAL(MULTIPLE_PROBING);
 
   #elif TOTAL_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 

commit 6b1c4dec464110bee11284a31548b9faf5ca3ccd
Author: kakou-fr <kakou@kakou.org>
Date:   Thu Sep 5 01:09:12 2019 +0200

    Touch Mi: Add magnet Y position (#15166)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d20257fa32..8535bf854b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -109,40 +109,45 @@ float zprobe_zoffset; // Initialized by settings.load()
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
     #if TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
+    #if TOUCH_MI_DEPLOY_YPOS > Y_MAX_BED
+      TemporaryGlobalEndstopsState unlock_y(false);
+    #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
 
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true; // LCD click or M108 will clear this
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), PSTR("Continue"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
       ui.goto_screen(prev_screen);
 
+    #elif defined(TOUCH_MI_DEPLOY_XPOS) && defined(TOUCH_MI_DEPLOY_YPOS)
+      do_blocking_move_to_xy(TOUCH_MI_DEPLOY_XPOS, TOUCH_MI_DEPLOY_YPOS);
     #elif defined(TOUCH_MI_DEPLOY_XPOS)
-
       do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
-
+    #elif defined(TOUCH_MI_DEPLOY_YPOS)
+      do_blocking_move_to_y(TOUCH_MI_DEPLOY_YPOS);
     #endif
   }
 
   // Move down to the bed to stow the probe
   void run_stow_moves_script() {
     const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7e2a0deb5f..d20257fa32 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -69,21 +69,21 @@ float zprobe_zoffset; // Initialized by settings.load()
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
-  #include "stepper_indirection.h"
+  #include "stepper/indirection.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extensible_ui/ui_api.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(Z_PROBE_SLED)

commit f218405c36d03094f00d867fcebec07072ba7d44
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Aug 25 05:46:02 2019 -0400

    Fix ExtUI invalid speed, timer (#15031)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 4f63cdd453..7e2a0deb5f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -371,21 +371,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
       #endif
       #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onStatusChanged(PSTR("Stow Probe"));
+        ExtUI::onUserConfirmRequired(PSTR("Stow Probe"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
 
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true
       #else
         false
       #endif

commit 17cd1a4f2694cfb4ed5c7ed7cdd05c0a5351e4aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Aug 14 00:03:12 2019 -0500

    Tweak TOUCH_MI_DEPLOY_XPOS block

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 15c3915aee..4f63cdd453 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -111,36 +111,38 @@ float zprobe_zoffset; // Initialized by settings.load()
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
     #if TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
+
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true; // LCD click or M108 will clear this
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), PSTR("Continue"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
       ui.goto_screen(prev_screen);
-    #else
-      #ifdef TOUCH_MI_DEPLOY_XPOS
-        do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
-      #endif
+
+    #elif defined(TOUCH_MI_DEPLOY_XPOS)
+
+      do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+
     #endif
   }
 
   // Move down to the bed to stow the probe
   void run_stow_moves_script() {
     const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }

commit af5a7a2925e558847dd731a545dbd5b95b06ff53
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Aug 18 22:03:26 2019 -0400

    Add missing ExtUI user confirmation (#14992)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 91b699aa04..15c3915aee 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -72,20 +72,24 @@ float zprobe_zoffset; // Initialized by settings.load()
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
   #include "stepper_indirection.h"
 #endif
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extensible_ui/ui_api.h"
+#endif
+
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
@@ -364,20 +368,23 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
       #endif
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onStatusChanged(PSTR("Stow Probe"));
+      #endif
       while (wait_for_user) idle();
       ui.reset_status();
 
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true
       #else
         false
       #endif
     );

commit eb3a3d249ede779d6f468aeec0da70b4d8249670
Author: Fourmi <contact@hotends.fr>
Date:   Thu Aug 8 09:40:48 2019 +0200

    Fix TouchMI probe movement (left side) (#14875)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index af8fa51096..91b699aa04 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -102,41 +102,41 @@ float zprobe_zoffset; // Initialized by settings.load()
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
-    #ifndef TOUCH_MI_DEPLOY_XPOS
-      #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
-    #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
+    #if TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true; // LCD click or M108 will clear this
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), PSTR("Continue"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
       ui.goto_screen(prev_screen);
     #else
-      do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+      #ifdef TOUCH_MI_DEPLOY_XPOS
+        do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+      #endif
     #endif
   }
 
   // Move down to the bed to stow the probe
   void run_stow_moves_script() {
     const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }

commit 528c9885f204cf9cad8dd77df2c365cb2fab81ac
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Thu Aug 8 08:52:20 2019 +0200

    Fix wait_for_user + PAUSE_BEFORE_DEPLOY_STOW issue (#14831)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 4e7436a634..af8fa51096 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,23 +31,21 @@
 #include "../libs/buzzer.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#if ANY(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY, PROBE_TRIGGERED_WHEN_STOWED_TEST) || (QUIET_PROBING && ENABLED(PROBING_STEPPERS_OFF))
-  #include "../Marlin.h" // for stop(), disable_e_steppers
-#endif
+#include "../Marlin.h" // for stop(), disable_e_steppers, wait_for_user
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -57,20 +55,24 @@
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #include "../feature/backlash.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../feature/host_actions.h" // for PROMPT_USER_CONTINUE
+#endif
+
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING

commit d34364a086d1ff721ced93bff4fcf2d41f94abb6
Author: Fourmi <contact@hotends.fr>
Date:   Sat Jul 27 04:57:13 2019 +0200

    Default TOUCH_MI_DEPLOY_XPOS to min X (#14736)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 2d29084367..4e7436a634 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -101,21 +101,21 @@ float zprobe_zoffset; // Initialized by settings.load()
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
-      #define TOUCH_MI_DEPLOY_XPOS 0
+      #define TOUCH_MI_DEPLOY_XPOS X_MIN_POS
     #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
 
     #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
       const screenFunc_t prev_screen = ui.currentScreen;
       LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
       ui.return_to_status();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index dbd14ed5b5..2d29084367 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -533,21 +533,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
       ui.reset_status();
     }
   #endif
 
   #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
-    sensorless_t stealth_states { false, false, false, false, false, false, false };
+    sensorless_t stealth_states { false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);

commit fe0224104498a42a3921b97ef3902581fba6c309
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:20:15 2019 -0500

    NONE on combined options

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a816355489..dbd14ed5b5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -312,21 +312,21 @@ float zprobe_zoffset; // Initialized by settings.load()
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
       thermalManager.set_fans_paused(p);
     #endif
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
-      #if DISABLED(DELTA, HOME_AFTER_DEACTIVATE)
+      #if NONE(DELTA, HOME_AFTER_DEACTIVATE)
         disable_X(); disable_Y();
       #endif
     #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 810f20be70..a816355489 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -437,21 +437,21 @@ bool set_probe_deployed(const bool deploy) {
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
-    do_probe_raise(MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
+    do_probe_raise(_MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
@@ -773,21 +773,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
-      MIN(current_position[Z_AXIS], delta_clip_start_height)
+      _MIN(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);

commit 24655a6bf32163cda24fffc08b558ab6533e2dbc
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 1 06:55:27 2019 +0200

    Touch-MI Menu and Manual Deploy option (#14290)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8e1c41e3fc..810f20be70 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -102,24 +102,40 @@ float zprobe_zoffset; // Initialized by settings.load()
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(TOUCH_MI_PROBE)
 
   // Move to the magnet to unlock the probe
   void run_deploy_moves_script() {
     #ifndef TOUCH_MI_DEPLOY_XPOS
       #define TOUCH_MI_DEPLOY_XPOS 0
-    #elif X_HOME_DIR > 0 && TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
+    #elif TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
       TemporaryGlobalEndstopsState unlock_x(false);
     #endif
-    do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+
+    #if ENABLED(TOUCH_MI_MANUAL_DEPLOY)
+      const screenFunc_t prev_screen = ui.currentScreen;
+      LCD_MESSAGEPGM(MSG_MANUAL_DEPLOY_TOUCHMI);
+      ui.return_to_status();
+
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      wait_for_user = true; // LCD click or M108 will clear this
+      #if ENABLED(HOST_PROMPT_SUPPORT)
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Deploy TouchMI probe."), PSTR("Continue"));
+      #endif
+      while (wait_for_user) idle();
+      ui.reset_status();
+      ui.goto_screen(prev_screen);
+    #else
+      do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+    #endif
   }
 
   // Move down to the bed to stow the probe
   void run_stow_moves_script() {
     const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
     endstops.enable_z_probe(false);
     do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
     do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
   }
 

commit d16954dc885f75869b572549c5e90561b89a95bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 29 22:49:50 2019 -0500

    Make KEEPALIVE_STATE a scoped auto-restore (#14446)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 710b47aa8b..8e1c41e3fc 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -348,21 +348,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
       serialprintPGM(ds_str);
       SERIAL_EOL();
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
       #endif
       while (wait_for_user) idle();
       ui.reset_status();
-      KEEPALIVE_STATE(IN_HANDLER);
+
     } while(
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
         true
       #else
         false
       #endif
     );
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 93d057a175..710b47aa8b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 2580104c8befb7bb6a363b79776f4a8ba9436686
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 26 05:11:05 2019 -0500

    Revert recent probe changes
    
    - Revert "Fix FIX_MOUNTED_PROBE compile error (#14393)"
    - Revert "Fix G28 with non-BLTouch probes (#14381)"
    - Revert "Fix BLTOUCH deploy/stow in HS mode (#14352)"
    - Revert "Apply needed BLTouch patch (#14233)"
    
    Co-Authored-By: AnHardt <github@kitelab.de>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9f8d520246..93d057a175 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -369,27 +369,29 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
-  #elif ENABLED(BLTOUCH)
-
-    deploy ? bltouch.deploy() : bltouch.stow();
-
   #elif HAS_Z_SERVO_PROBE
 
-    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+    #if DISABLED(BLTOUCH)
+      MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+    #elif ENABLED(BLTOUCH_HS_MODE)
+      // In HIGH SPEED MODE, use the normal retractable probe logic in this code
+      // i.e. no intermediate STOWs and DEPLOYs in between individual probe actions
+      if (deploy) bltouch.deploy(); else bltouch.stow();
+    #endif
 
   #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
@@ -438,26 +440,28 @@ bool set_probe_deployed(const bool deploy) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
-
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif
+  #endif
+
+  #ifdef PROBE_STOWED
 
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
     if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
       if (IsRunning()) {

commit f5afaaef5b36428e721e8785e174e4d782048f0a
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Sun Jun 23 00:27:33 2019 +0200

    Fix probe.cpp warning (#14367)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 856715e2cb..9f8d520246 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -656,28 +656,30 @@ static float run_z_probe() {
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
 
       const float z = current_position[Z_AXIS];
 
       #if EXTRA_PROBING
         // Insert Z measurement into probes[]. Keep it sorted ascending.
         for (uint8_t i = 0; i <= p; i++) {                            // Iterate the saved Zs to insert the new Z
-          if (i == p || probes[i] > z) {       // Last index or new Z is smaller than this Z
+          if (i == p || probes[i] > z) {                              // Last index or new Z is smaller than this Z
             for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
-            probes[i] = z;                     // Insert the new Z measurement
+            probes[i] = z;                                            // Insert the new Z measurement
             break;                                                    // Only one to insert. Done!
           }
         }
       #elif TOTAL_PROBING > 2
         probes_total += z;
+      #else
+        UNUSED(z);
       #endif
 
       #if TOTAL_PROBING > 2
         // Small Z raise after all but the last probe
         if (p
           #if EXTRA_PROBING
             < TOTAL_PROBING - 1
           #endif
         ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
       #endif

commit c41b005f33ce14a3ee0de4af5c6004a0d52137b6
Author: MrMabulous <matthias.buehlmann@mabulous.com>
Date:   Sat Jun 22 02:02:26 2019 +0200

    Add Extra Probing option, discarding outliers (#14338)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a74200d71b..856715e2cb 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -577,94 +577,142 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
 
   // Tell the planner where we actually are
   sync_plan_position();
 
   if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
 
   return !probe_triggered;
 }
 
 /**
- * @details Used by probe_pt to do a single Z probe at the current position.
+ * @brief Probe at the current XY (possibly more than once) to find the bed Z.
+ *
+ * @details Used by probe_pt to get the bed Z height at the current XY.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
- * @return The raw Z position where the probe was triggered
+ * @return The Z position of the bed at the current XY or NAN on error.
  */
 static float run_z_probe() {
 
   if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
-  #if MULTIPLE_PROBING == 2
+  #if TOTAL_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("FAST Probe fail!");
         DEBUG_POS("<<< run_z_probe", current_position);
       }
       return NAN;
     }
 
-    float first_probe_z = current_position[Z_AXIS];
+    const float first_probe_z = current_position[Z_AXIS];
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
-    // move up to make clearance for the probe
+    // Raise to give the probe clearance
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_zoffset < 0 ? -zprobe_zoffset : 0);
     if (current_position[Z_AXIS] > z) {
-      // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
+      // Probe down fast. If the probe never triggered, raise for probe clearance
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
-  #if MULTIPLE_PROBING > 2
-    float probes_total = 0;
-    for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
+  #ifdef EXTRA_PROBING
+    float probes[TOTAL_PROBING];
   #endif
 
-      // move down slowly to find bed
+  #if TOTAL_PROBING > 2
+    float probes_total = 0;
+    for (
+      #if EXTRA_PROBING
+        uint8_t p = 0; p < TOTAL_PROBING; p++
+      #else
+        uint8_t p = TOTAL_PROBING; p--;
+      #endif
+    )
+  #endif
+    {
+      // Probe downward slowly to find the bed
       if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         backlash.measure_with_probe();
       #endif
 
-  #if MULTIPLE_PROBING > 2
-      probes_total += current_position[Z_AXIS];
-      if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      const float z = current_position[Z_AXIS];
+
+      #if EXTRA_PROBING
+        // Insert Z measurement into probes[]. Keep it sorted ascending.
+        for (uint8_t i = 0; i <= p; i++) {                            // Iterate the saved Zs to insert the new Z
+          if (i == p || probes[i] > z) {       // Last index or new Z is smaller than this Z
+            for (int8_t m = p; --m >= i;) probes[m + 1] = probes[m];  // Shift items down after the insertion point
+            probes[i] = z;                     // Insert the new Z measurement
+            break;                                                    // Only one to insert. Done!
+          }
+        }
+      #elif TOTAL_PROBING > 2
+        probes_total += z;
+      #endif
+
+      #if TOTAL_PROBING > 2
+        // Small Z raise after all but the last probe
+        if (p
+          #if EXTRA_PROBING
+            < TOTAL_PROBING - 1
+          #endif
+        ) do_blocking_move_to_z(z + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      #endif
     }
-  #endif
 
-  #if MULTIPLE_PROBING > 2
+  #if TOTAL_PROBING > 2
+
+    #if EXTRA_PROBING
+      // Take the center value (or average the two middle values) as the median
+      static constexpr int PHALF = (TOTAL_PROBING - 1) / 2;
+      const float middle = probes[PHALF],
+                  median = ((TOTAL_PROBING) & 1) ? middle : (middle + probes[PHALF + 1]) * 0.5f;
+
+      // Remove values farthest from the median
+      uint8_t min_avg_idx = 0, max_avg_idx = TOTAL_PROBING - 1;
+      for (uint8_t i = EXTRA_PROBING; i--;)
+        if (ABS(probes[max_avg_idx] - median) > ABS(probes[min_avg_idx] - median))
+          max_avg_idx--; else min_avg_idx++;
+
+      // Return the average value of all remaining probes.
+      for (uint8_t i = min_avg_idx; i <= max_avg_idx; i++)
+        probes_total += probes[i];
+
+    #endif
 
-    // Return the average value of all probes
     const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
 
-  #elif MULTIPLE_PROBING == 2
+  #elif TOTAL_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 

commit 8f99d45045c4f8844c3a07dbd81e6e6aedae1009
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Sat Jun 22 01:55:27 2019 +0200

    Fix BLTOUCH deploy/stow in HS mode (#14352)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5662c4c72c..a74200d71b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -369,29 +369,27 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
+  #elif ENABLED(BLTOUCH)
+
+    deploy ? bltouch.deploy() : bltouch.stow();
+
   #elif HAS_Z_SERVO_PROBE
 
-    #if DISABLED(BLTOUCH)
-      MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
-    #elif ENABLED(BLTOUCH_HS_MODE)
-      // In HIGH SPEED MODE, use the normal retractable probe logic in this code
-      // i.e. no intermediate STOWs and DEPLOYs in between individual probe actions
-      if (deploy) bltouch.deploy(); else bltouch.stow();
-    #endif
+    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
@@ -440,28 +438,26 @@ bool set_probe_deployed(const bool deploy) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
+
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif
-  #endif
-
-  #ifdef PROBE_STOWED
 
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
     if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
       if (IsRunning()) {
@@ -739,25 +735,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
     SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
     SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
-    #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
-      bltouch.stow();
-    #else
-      STOW_PROBE();
-    #endif
+    STOW_PROBE();
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_pt");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE

commit f2cfa408b74ad6d2d885c72e5fee9cde7973aa55
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Jun 15 05:19:48 2019 +0200

    Touch-MI probe by hotends.fr (#14101)
    
    A simple Z probe using a magnet to deploy a probe. See https://youtu.be/E7Ik9PbKPl0 for the sensor description...

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index df168f053d..5662c4c72c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -96,20 +96,40 @@ float zprobe_zoffset; // Initialized by settings.load()
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("dock_sled(", stow, ")");
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
+#elif ENABLED(TOUCH_MI_PROBE)
+
+  // Move to the magnet to unlock the probe
+  void run_deploy_moves_script() {
+    #ifndef TOUCH_MI_DEPLOY_XPOS
+      #define TOUCH_MI_DEPLOY_XPOS 0
+    #elif X_HOME_DIR > 0 && TOUCH_MI_DEPLOY_XPOS > X_MAX_BED
+      TemporaryGlobalEndstopsState unlock_x(false);
+    #endif
+    do_blocking_move_to_x(TOUCH_MI_DEPLOY_XPOS);
+  }
+
+  // Move down to the bed to stow the probe
+  void run_stow_moves_script() {
+    const float old_pos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
+    endstops.enable_z_probe(false);
+    do_blocking_move_to_z(TOUCH_MI_RETRACT_Z, MMM_TO_MMS(HOMING_FEEDRATE_Z));
+    do_blocking_move_to(old_pos, MMM_TO_MMS(HOMING_FEEDRATE_Z));
+  }
+
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
   void run_deploy_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
       #endif
@@ -359,21 +379,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #elif HAS_Z_SERVO_PROBE
 
     #if DISABLED(BLTOUCH)
       MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
     #elif ENABLED(BLTOUCH_HS_MODE)
       // In HIGH SPEED MODE, use the normal retractable probe logic in this code
       // i.e. no intermediate STOWs and DEPLOYs in between individual probe actions
       if (deploy) bltouch.deploy(); else bltouch.stow();
     #endif
 
-  #elif ENABLED(Z_PROBE_ALLEN_KEY)
+  #elif EITHER(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);

commit 293018f76c8c2b0398751f82cf93c3075c8ca4b3
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Sat Jun 8 04:43:20 2019 +0200

    Apply needed BLTouch patch (#14233)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 207490405d..df168f053d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -719,21 +719,25 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
 
   if (verbose_level > 2) {
     SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
     SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
     SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
-    STOW_PROBE();
+    #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+      bltouch.stow();
+    #else
+      STOW_PROBE();
+    #endif
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_pt");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 20afebefd1..207490405d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -349,23 +349,29 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)
 
     dock_sled(!deploy);
 
-  #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
-
-    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+  #elif HAS_Z_SERVO_PROBE
+
+    #if DISABLED(BLTOUCH)
+      MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+    #elif ENABLED(BLTOUCH_HS_MODE)
+      // In HIGH SPEED MODE, use the normal retractable probe logic in this code
+      // i.e. no intermediate STOWs and DEPLOYs in between individual probe actions
+      if (deploy) bltouch.deploy(); else bltouch.stow();
+    #endif
 
   #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
@@ -485,23 +491,22 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
 
-  // Deploy BLTouch at the start of any probe
-  #if ENABLED(BLTOUCH)
-    if (bltouch.deploy()) return true;
+  #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+    if (bltouch.deploy()) return true; // DEPLOY in LOW SPEED MODE on every probe action
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false, false, false, false, false, false, false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
@@ -537,23 +542,22 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif
 
-  // Retract BLTouch immediately after a probe if it was triggered
-  #if ENABLED(BLTOUCH)
-    if (probe_triggered && bltouch.stow()) return true;
+  #if ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+    if (probe_triggered && bltouch.stow()) return true; // STOW in LOW SPEED MODE on trigger on every probe action
   #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();

commit 6811e2921bcd272e7487e4f379b42a5a403a07c2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 22:25:54 2019 -0400

    BLTouch v3 / 3DTouch Interoperability & performance (#13814)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 39b6c8e8cf..20afebefd1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -276,21 +276,21 @@ float zprobe_zoffset; // Initialized by settings.load()
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
       thermalManager.set_fans_paused(p);
     #endif
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
-      #if DISABLED(DELTA)
+      #if DISABLED(DELTA, HOME_AFTER_DEACTIVATE)
         disable_X(); disable_Y();
       #endif
     #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    ‚Ä¶And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8988b15bea..39b6c8e8cf 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -47,20 +47,24 @@
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
+#if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
+  #include "../feature/backlash.h"
+#endif
+
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
@@ -456,44 +460,20 @@ bool set_probe_deployed(const bool deploy) {
 #ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position
   void move_z_after_probing() {
     if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position[Z_AXIS] = Z_AFTER_PROBING;
     }
   }
 #endif
 
-#if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-  #if USES_Z_MIN_PROBE_ENDSTOP
-    #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
-  #else
-    #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
-  #endif
-
-  extern float backlash_measured_mm[];
-  extern uint8_t backlash_measured_num[];
-
-  /* Measure Z backlash by raising nozzle in increments until probe deactivates */
-  static void measure_backlash_with_probe() {
-    if (backlash_measured_num[Z_AXIS] == 255) return;
-
-    float start_height = current_position[Z_AXIS];
-    while (current_position[Z_AXIS] < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
-      do_blocking_move_to_z(current_position[Z_AXIS] + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
-
-    // The backlash from all probe points is averaged, so count the number of measurements
-    backlash_measured_mm[Z_AXIS] += current_position[Z_AXIS] - start_height;
-    backlash_measured_num[Z_AXIS]++;
-  }
-#endif
-
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
@@ -636,21 +616,21 @@ static float run_z_probe() {
       // move down slowly to find bed
       if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
         if (DEBUGGING(LEVELING)) {
           DEBUG_ECHOLNPGM("SLOW Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);
         }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-        measure_backlash_with_probe();
+        backlash.measure_with_probe();
       #endif
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 

commit e8dc87a2b760b7ddc9e78db070e9afeef2a429e9
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Apr 17 00:35:58 2019 +0700

    Fix updated Allen Key pause probe logic (#13723)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 78e8ad8aec..8988b15bea 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -305,21 +305,21 @@ inline void do_probe_raise(const float z_raise) {
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
     do {
       #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
-        if (READ(Z_MIN_PROBE_PIN) == (deploy == bool(Z_MIN_PROBE_ENDSTOP_INVERTING))) break;
+        if (deploy == (READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING)) break;
       #endif
 
       BUZZ(100, 659);
       BUZZ(100, 698);
 
       PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
       ui.return_to_status();       // To display the new status message
       ui.set_status_P(ds_str, 99);
       serialprintPGM(ds_str);
       SERIAL_EOL();

commit 7ca1fea22b531710fa976bfaa527efbc15ebb83f
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Apr 16 13:32:43 2019 +0700

    Option to pause probe deployment only when triggered, for manually-deployed allen-key probe (#13698)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f32b5ae4d0..78e8ad8aec 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -303,38 +303,49 @@ inline void do_probe_raise(const float z_raise) {
   if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
+    do {
+      #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
+        if (READ(Z_MIN_PROBE_PIN) == (deploy == bool(Z_MIN_PROBE_ENDSTOP_INVERTING))) break;
+      #endif
 
-    BUZZ(100, 659);
-    BUZZ(100, 698);
+      BUZZ(100, 659);
+      BUZZ(100, 698);
 
-    PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-    ui.return_to_status();       // To display the new status message
-    ui.set_status_P(ds_str, 99);
-    serialprintPGM(ds_str);
-    SERIAL_EOL();
+      PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+      ui.return_to_status();       // To display the new status message
+      ui.set_status_P(ds_str, 99);
+      serialprintPGM(ds_str);
+      SERIAL_EOL();
 
-    KEEPALIVE_STATE(PAUSED_FOR_USER);
-    wait_for_user = true;
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
-    #endif
-    while (wait_for_user) idle();
-    ui.reset_status();
-    KEEPALIVE_STATE(IN_HANDLER);
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      wait_for_user = true;
+      #if ENABLED(HOST_PROMPT_SUPPORT)
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
+      #endif
+      while (wait_for_user) idle();
+      ui.reset_status();
+      KEEPALIVE_STATE(IN_HANDLER);
+    } while(
+      #if ENABLED(PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED)
+        true
+      #else
+        false
+      #endif
+    );
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
   #elif ENABLED(Z_PROBE_SLED)

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 37ee673a90..f32b5ae4d0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -49,20 +49,24 @@
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
 #if HAS_Z_SERVO_PROBE
   #include "servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
@@ -282,51 +286,20 @@ float zprobe_zoffset; // Initialized by settings.load()
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );
   }
 #endif // QUIET_PROBING
 
-#if ENABLED(BLTOUCH)
-
-  void bltouch_command(const int angle) {
-    MOVE_SERVO(Z_PROBE_SERVO_NR, angle);  // Give the BL-Touch the command and wait
-    safe_delay(BLTOUCH_DELAY);
-  }
-
-  bool set_bltouch_deployed(const bool deploy) {
-    if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
-      bltouch_command(BLTOUCH_RESET);    //  try to reset it.
-      bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
-      bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
-      safe_delay(1500);                  // Wait for internal self-test to complete.
-                                         //  (Measured completion time was 0.65 seconds
-                                         //   after reset, deploy, and stow sequence)
-      if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
-        SERIAL_ERROR_MSG(MSG_STOP_BLTOUCH);
-        stop();                          // punt!
-        return true;
-      }
-    }
-
-    bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
-
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("set_bltouch_deployed(", deploy, ")");
-
-    return false;
-  }
-
-#endif // BLTOUCH
-
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
 
   float z_dest = z_raise;
   if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
 
   NOMORE(z_dest, Z_MAX_POS);
@@ -523,21 +496,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
-    if (set_bltouch_deployed(true)) return true;
+    if (bltouch.deploy()) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     sensorless_t stealth_states { false, false, false, false, false, false, false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
@@ -575,21 +548,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
     endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
     tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif
 
   // Retract BLTouch immediately after a probe if it was triggered
   #if ENABLED(BLTOUCH)
-    if (probe_triggered && set_bltouch_deployed(false)) return true;
+    if (probe_triggered && bltouch.stow()) return true;
   #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index d7078bdc02..37ee673a90 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,21 +31,21 @@
 #include "../libs/buzzer.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#if ENABLED(BLTOUCH) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST) || (QUIET_PROBING && ENABLED(PROBING_STEPPERS_OFF))
+#if ANY(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY, PROBE_TRIGGERED_WHEN_STOWED_TEST) || (QUIET_PROBING && ENABLED(PROBING_STEPPERS_OFF))
   #include "../Marlin.h" // for stop(), disable_e_steppers
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
@@ -409,21 +409,21 @@ bool set_probe_deployed(const bool deploy) {
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_probe_raise(MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
-  #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+  #if EITHER(Z_PROBE_SLED, Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
@@ -546,21 +546,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
-    #if ENABLED(DELTA) && ENABLED(SENSORLESS_PROBING)
+    #if BOTH(DELTA, SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
       TEST(endstops.trigger_state(),
         #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           Z_MIN
         #else
           Z_MIN_PROBE
         #endif
       )
     #endif

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 87e5e795fe..d7078bdc02 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -62,36 +62,37 @@ float zprobe_zoffset; // Initialized by settings.load()
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
   #include "stepper_indirection.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../core/debug_out.h"
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
    *              If true, move to MAX_X and release the solenoid
    */
   static void dock_sled(bool stow) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("dock_sled(", stow, ")");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("dock_sled(", stow, ")");
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
@@ -305,36 +306,32 @@ float zprobe_zoffset; // Initialized by settings.load()
                                          //   after reset, deploy, and stow sequence)
       if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
         SERIAL_ERROR_MSG(MSG_STOP_BLTOUCH);
         stop();                          // punt!
         return true;
       }
     }
 
     bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("set_bltouch_deployed(", deploy, ")");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("set_bltouch_deployed(", deploy, ")");
 
     return false;
   }
 
 #endif // BLTOUCH
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
 
   float z_dest = z_raise;
   if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
@@ -386,26 +383,24 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
   #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     UNUSED(deploy);
 
   #endif
 }
 
 // returns false for ok and true for failure
 bool set_probe_deployed(const bool deploy) {
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_POS("set_probe_deployed", current_position);
-      SERIAL_ECHOLNPAIR("deploy: ", deploy);
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_POS("set_probe_deployed", current_position);
+    DEBUG_ECHOLNPAIR("deploy: ", deploy);
+  }
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
   #if ENABLED(FIX_MOUNTED_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
@@ -514,23 +509,21 @@ bool set_probe_deployed(const bool deploy) {
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
 static bool do_probe_move(const float z, const float fr_mm_s) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
@@ -594,62 +587,54 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe at the current position.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
 static float run_z_probe() {
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("FAST Probe fail!");
-          DEBUG_POS("<<< run_z_probe", current_position);
-        }
-      #endif
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOLNPGM("FAST Probe fail!");
+        DEBUG_POS("<<< run_z_probe", current_position);
+      }
       return NAN;
     }
 
     float first_probe_z = current_position[Z_AXIS];
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("1st Probe Z:", first_probe_z);
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_zoffset < 0 ? -zprobe_zoffset : 0);
     if (current_position[Z_AXIS] > z) {
@@ -659,26 +644,24 @@ static float run_z_probe() {
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif
 
       // move down slowly to find bed
       if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("SLOW Probe fail!");
-            DEBUG_POS("<<< run_z_probe", current_position);
-          }
-        #endif
+        if (DEBUGGING(LEVELING)) {
+          DEBUG_ECHOLNPGM("SLOW Probe fail!");
+          DEBUG_POS("<<< run_z_probe", current_position);
+        }
         return NAN;
       }
 
       #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
         measure_backlash_with_probe();
       #endif
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
@@ -687,64 +670,56 @@ static float run_z_probe() {
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
     const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
 
   #elif MULTIPLE_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position[Z_AXIS];
 
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
 
   return measured_z;
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPAIR(
-        ">>> probe_pt(", LOGICAL_X_POSITION(rx),
-        ", ", LOGICAL_Y_POSITION(ry),
-        ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
-        ", ", int(verbose_level),
-        ", ", probe_relative ? "probe" : "nozzle",
-        "_relative)"
-      );
-      DEBUG_POS("", current_position);
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_ECHOLNPAIR(
+      ">>> probe_pt(", LOGICAL_X_POSITION(rx), ", ", LOGICAL_Y_POSITION(ry),
+      ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
+      ", ", int(verbose_level),
+      ", ", probe_relative ? "probe" : "nozzle", "_relative)"
+    );
+    DEBUG_POS("", current_position);
+  }
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
@@ -781,23 +756,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     STOW_PROBE();
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< probe_pt");
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ee6bff24ca..87e5e795fe 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -76,25 +76,21 @@ float zprobe_zoffset; // Initialized by settings.load()
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
    *              If true, move to MAX_X and release the solenoid
    */
   static void dock_sled(bool stow) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("dock_sled(", stow);
-        SERIAL_CHAR(')');
-        SERIAL_EOL();
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("dock_sled(", stow, ")");
     #endif
 
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
@@ -310,42 +306,34 @@ float zprobe_zoffset; // Initialized by settings.load()
       if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
         SERIAL_ERROR_MSG(MSG_STOP_BLTOUCH);
         stop();                          // punt!
         return true;
       }
     }
 
     bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
-        SERIAL_CHAR(')');
-        SERIAL_EOL();
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("set_bltouch_deployed(", deploy, ")");
     #endif
 
     return false;
   }
 
 #endif // BLTOUCH
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("do_probe_raise(", z_raise, ")");
   #endif
 
   float z_dest = z_raise;
   if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
@@ -700,24 +688,21 @@ static float run_z_probe() {
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
     const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
 
   #elif MULTIPLE_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("2nd Probe Z:", z2);
-        SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
-      }
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("2nd Probe Z:", z2, " Discrepancy:", first_probe_z - z2);
     #endif
 
     // Return a weighted average of the fast and slow probes
     const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
     const float measured_z = current_position[Z_AXIS];
 
@@ -735,26 +720,28 @@ static float run_z_probe() {
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
 float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
-      SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
-      SERIAL_ECHOPAIR(", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none");
-      SERIAL_ECHOPAIR(", ", int(verbose_level));
-      SERIAL_ECHOPAIR(", ", probe_relative ? "probe" : "nozzle");
-      SERIAL_ECHOLNPGM("_relative)");
+      SERIAL_ECHOLNPAIR(
+        ">>> probe_pt(", LOGICAL_X_POSITION(rx),
+        ", ", LOGICAL_Y_POSITION(ry),
+        ", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none",
+        ", ", int(verbose_level),
+        ", ", probe_relative ? "probe" : "nozzle",
+        "_relative)"
+      );
       DEBUG_POS("", current_position);
     }
   #endif
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);

commit 99d0022fae0efd9164946062bf641f7294597675
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 1 00:27:45 2019 -0600

    Drop the Z_MIN_PROBE_ENDSTOP option (#13276)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 1eb8ac2b43..ee6bff24ca 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -443,21 +443,21 @@ bool set_probe_deployed(const bool deploy) {
       SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
-    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #if USES_Z_MIN_PROBE_ENDSTOP
       #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif
   #endif
 
   #ifdef PROBE_STOWED
 
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {
@@ -490,21 +490,21 @@ bool set_probe_deployed(const bool deploy) {
   // After probing move to a preferred Z position
   void move_z_after_probing() {
     if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position[Z_AXIS] = Z_AFTER_PROBING;
     }
   }
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   #else
     #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   #endif
 
   extern float backlash_measured_mm[];
   extern uint8_t backlash_measured_num[];
 
   /* Measure Z backlash by raising nozzle in increments until probe deactivates */
   static void measure_backlash_with_probe() {

commit 7f1b69b0c83ae914ed9ae35fdad9f79814069652
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Feb 12 16:55:47 2019 -0500

    Add HOST_PROMPT_SUPPORT (#13039)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3e3800ee84..1eb8ac2b43 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -357,20 +357,23 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     BUZZ(100, 698);
 
     PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
     ui.return_to_status();       // To display the new status message
     ui.set_status_P(ds_str, 99);
     serialprintPGM(ds_str);
     SERIAL_EOL();
 
     KEEPALIVE_STATE(PAUSED_FOR_USER);
     wait_for_user = true;
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_do(PROMPT_USER_CONTINUE, PSTR("Stow Probe"), PSTR("Continue"));
+    #endif
     while (wait_for_user) idle();
     ui.reset_status();
     KEEPALIVE_STATE(IN_HANDLER);
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0f1d2fdf9f..3e3800ee84 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index c3888f27f0..0f1d2fdf9f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -40,31 +40,31 @@
 
 #if ENABLED(BLTOUCH) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST) || (QUIET_PROBING && ENABLED(PROBING_STEPPERS_OFF))
   #include "../Marlin.h" // for stop(), disable_e_steppers
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
-  #include "../module/delta.h"
+  #include "delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_PROBE
-  #include "../module/servo.h"
+  #include "servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if QUIET_PROBING
   #include "stepper_indirection.h"
 #endif

commit c3cb449990e037ca02826596d4b54aafa51db55c
Author: mattfredwill <mattfredwill@gmail.com>
Date:   Sat Feb 2 08:09:01 2019 +0800

    TMC2130 dual-stepper Sensorless Homing (#13061)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a8b722feff..c3888f27f0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -544,21 +544,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
-    sensorless_t stealth_states { false, false, false };
+    sensorless_t stealth_states { false, false, false, false, false, false, false };
     #if ENABLED(DELTA)
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
     stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);

commit 0495fcd475876f1b03cbc83162aceee44a05bfed
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 19 21:50:33 2019 -0600

    Minor spacing fix

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9247aedf43..a8b722feff 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,22 +31,22 @@
 #include "../libs/buzzer.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#if ENABLED(BLTOUCH) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
-  #include "../Marlin.h" // for stop()
+#if ENABLED(BLTOUCH) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST) || (QUIET_PROBING && ENABLED(PROBING_STEPPERS_OFF))
+  #include "../Marlin.h" // for stop(), disable_e_steppers
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "../module/delta.h"
 #endif
 

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 76be571444..9247aedf43 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -261,45 +261,27 @@ float zprobe_zoffset; // Initialized by settings.load()
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
 #endif // Z_PROBE_ALLEN_KEY
 
-#if ENABLED(PROBING_FANS_OFF)
-
-  void fans_pause(const bool p) {
-    if (p != fans_paused) {
-      fans_paused = p;
-      if (p)
-        for (uint8_t x = 0; x < FAN_COUNT; x++) {
-          paused_fan_speed[x] = fan_speed[x];
-          fan_speed[x] = 0;
-        }
-      else
-        for (uint8_t x = 0; x < FAN_COUNT; x++)
-          fan_speed[x] = paused_fan_speed[x];
-    }
-  }
-
-#endif // PROBING_FANS_OFF
-
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
-      fans_pause(p);
+      thermalManager.set_fans_paused(p);
     #endif
     #if ENABLED(PROBING_STEPPERS_OFF)
       disable_e_steppers();
       #if DISABLED(DELTA)
         disable_X(); disable_Y();
       #endif
     #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING

commit b22716e938397d8beb64f5855b64f6fdb375b5d2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Dec 8 13:36:46 2018 -0700

    M425 Backlash Correction (#11061)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 943384140b..76be571444 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -504,20 +504,44 @@ bool set_probe_deployed(const bool deploy) {
 #ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position
   void move_z_after_probing() {
     if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position[Z_AXIS] = Z_AFTER_PROBING;
     }
   }
 #endif
 
+#if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
+  #else
+    #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+  #endif
+
+  extern float backlash_measured_mm[];
+  extern uint8_t backlash_measured_num[];
+
+  /* Measure Z backlash by raising nozzle in increments until probe deactivates */
+  static void measure_backlash_with_probe() {
+    if (backlash_measured_num[Z_AXIS] == 255) return;
+
+    float start_height = current_position[Z_AXIS];
+    while (current_position[Z_AXIS] < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
+      do_blocking_move_to_z(current_position[Z_AXIS] + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
+
+    // The backlash from all probe points is averaged, so count the number of measurements
+    backlash_measured_mm[Z_AXIS] += current_position[Z_AXIS] - start_height;
+    backlash_measured_num[Z_AXIS]++;
+  }
+#endif
+
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
@@ -671,20 +695,24 @@ static float run_z_probe() {
       if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOLNPGM("SLOW Probe fail!");
             DEBUG_POS("<<< run_z_probe", current_position);
           }
         #endif
         return NAN;
       }
 
+      #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
+        measure_backlash_with_probe();
+      #endif
+
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
     const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 596ebf0182..943384140b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -538,25 +538,26 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
+    sensorless_t stealth_states { false, false, false };
     #if ENABLED(DELTA)
-      tmc_stallguard(stepperX);
-      tmc_stallguard(stepperY);
+      stealth_states.x = tmc_enable_stallguard(stepperX);
+      stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
-    tmc_stallguard(stepperZ);
+    stealth_states.z = tmc_enable_stallguard(stepperZ);
     endstops.enable(true);
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
@@ -576,24 +577,24 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   ;
 
   #if QUIET_PROBING
     probing_pause(false);
   #endif
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     endstops.not_homing();
     #if ENABLED(DELTA)
-      tmc_stallguard(stepperX, false);
-      tmc_stallguard(stepperY, false);
+      tmc_disable_stallguard(stepperX, stealth_states.x);
+      tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
-    tmc_stallguard(stepperZ, false);
+    tmc_disable_stallguard(stepperZ, stealth_states.z);
   #endif
 
   // Retract BLTouch immediately after a probe if it was triggered
   #if ENABLED(BLTOUCH)
     if (probe_triggered && set_bltouch_deployed(false)) return true;
   #endif
 
   // Clear endstop flags
   endstops.hit_on_purpose();
 

commit 3c58b16c9fc80d995427de0e55fe934edad74500
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 30 12:48:46 2018 -0600

    Move stepper enable/disable to stepper_indirection.h (#12562)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 37c2624276..596ebf0182 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -31,21 +31,23 @@
 #include "../libs/buzzer.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
-#include "../Marlin.h"
+#if ENABLED(BLTOUCH) || ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
+  #include "../Marlin.h" // for stop()
+#endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "../module/delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -56,20 +58,24 @@ float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_PROBE
   #include "../module/servo.h"
 #endif
 
 #if ENABLED(SENSORLESS_PROBING)
   #include "stepper.h"
   #include "../feature/tmc_util.h"
 #endif
 
+#if QUIET_PROBING
+  #include "stepper_indirection.h"
+#endif
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 750d30894d..37c2624276 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -313,22 +313,21 @@ float zprobe_zoffset; // Initialized by settings.load()
 
   bool set_bltouch_deployed(const bool deploy) {
     if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
       bltouch_command(BLTOUCH_RESET);    //  try to reset it.
       bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
       bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
       safe_delay(1500);                  // Wait for internal self-test to complete.
                                          //  (Measured completion time was 0.65 seconds
                                          //   after reset, deploy, and stow sequence)
       if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
-        SERIAL_ERROR_START();
-        SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
+        SERIAL_ERROR_MSG(MSG_STOP_BLTOUCH);
         stop();                          // punt!
         return true;
       }
     }
 
     bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
@@ -443,22 +442,21 @@ bool set_probe_deployed(const bool deploy) {
   if (deploy_stow_condition && unknown_condition)
     do_probe_raise(MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
+      SERIAL_ERROR_MSG(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
   #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
@@ -472,22 +470,21 @@ bool set_probe_deployed(const bool deploy) {
 
     // Only deploy/stow if needed
     if (PROBE_STOWED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
       probe_specific_action(deploy);
     }
 
     if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
       if (IsRunning()) {
-        SERIAL_ERROR_START();
-        SERIAL_ERRORLNPGM("Z-Probe failed");
+        SERIAL_ERROR_MSG("Z-Probe failed");
         LCD_ALERTMESSAGEPGM("Err: ZPROBE");
       }
       stop();
       return true;
     }
 
   #else
 
     probe_specific_action(deploy);
 
@@ -764,36 +761,31 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
     measured_z = run_z_probe() + zprobe_zoffset;
 
     const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
     if (big_raise || raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
-    SERIAL_PROTOCOLPGM("Bed X: ");
-    SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
-    SERIAL_PROTOCOLPGM(" Y: ");
-    SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
-    SERIAL_PROTOCOLPGM(" Z: ");
-    SERIAL_PROTOCOL_F(measured_z, 3);
-    SERIAL_EOL();
+    SERIAL_ECHOPAIR_F("Bed X: ", LOGICAL_X_POSITION(rx), 3);
+    SERIAL_ECHOPAIR_F(" Y: ", LOGICAL_Y_POSITION(ry), 3);
+    SERIAL_ECHOLNPAIR_F(" Z: ", measured_z, 3);
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     STOW_PROBE();
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
+    SERIAL_ERROR_MSG(MSG_ERR_PROBING_FAILED);
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   #endif
 
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE

commit 29c53f2402c72dcd58d6cbe00290119663489c1d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 23 21:07:24 2018 -0600

    Hide some compile warnings

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 562914a858..750d30894d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -398,20 +398,24 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
     MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
 
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
+  #elif DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
+
+    UNUSED(deploy);
+
   #endif
 }
 
 // returns false for ok and true for failure
 bool set_probe_deployed(const bool deploy) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);

commit caca3c850324308645ff216efdd223b0c044a3c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 23 20:39:12 2018 -0600

    Use wait_for_bed with WAIT_FOR_BED_HEATER
    
    Addressing #12517

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6d535eeef0..562914a858 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -519,21 +519,21 @@ bool set_probe_deployed(const bool deploy) {
 static bool do_probe_move(const float z, const float fr_mm_s) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   #endif
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
-      while (thermalManager.isHeatingBed()) safe_delay(200);
+      thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5597714416..6d535eeef0 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -364,21 +364,21 @@ inline void do_probe_raise(const float z_raise) {
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     BUZZ(100, 659);
     BUZZ(100, 698);
 
     PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
     ui.return_to_status();       // To display the new status message
-    ui.setstatusPGM(ds_str, 99);
+    ui.set_status_P(ds_str, 99);
     serialprintPGM(ds_str);
     SERIAL_EOL();
 
     KEEPALIVE_STATE(PAUSED_FOR_USER);
     wait_for_user = true;
     while (wait_for_user) idle();
     ui.reset_status();
     KEEPALIVE_STATE(IN_HANDLER);
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index bec70918a6..5597714416 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -363,29 +363,29 @@ inline void do_probe_raise(const float z_raise) {
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     BUZZ(100, 659);
     BUZZ(100, 698);
 
     PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-    lcd_return_to_status();       // To display the new status message
-    lcd_setstatusPGM(ds_str, 99);
+    ui.return_to_status();       // To display the new status message
+    ui.setstatusPGM(ds_str, 99);
     serialprintPGM(ds_str);
     SERIAL_EOL();
 
     KEEPALIVE_STATE(PAUSED_FOR_USER);
     wait_for_user = true;
     while (wait_for_user) idle();
-    lcd_reset_status();
+    ui.reset_status();
     KEEPALIVE_STATE(IN_HANDLER);
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW
 
   #if ENABLED(SOLENOID_PROBE)
 
     #if HAS_SOLENOID_1
       WRITE(SOL1_PIN, deploy);
     #endif
 
@@ -520,21 +520,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   #endif
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
-      lcd_reset_status();
+      ui.reset_status();
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)

commit 5182eaf661d148b841e0034d4337241fdca2b36f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 20:51:54 2018 -0600

    Fix endstops enable behavior during probing
    
    Fix a bug introduced in #9582

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index fa9692d65c..bec70918a6 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -536,29 +536,28 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
     #if ENABLED(DELTA)
       tmc_stallguard(stepperX);
       tmc_stallguard(stepperY);
     #endif
     tmc_stallguard(stepperZ);
+    endstops.enable(true);
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
-  endstops.enable(true);
-
-  // Move down until probe triggered
+  // Move down until the probe is triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered =
     #if ENABLED(DELTA) && ENABLED(SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
       TEST(endstops.trigger_state(),
         #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           Z_MIN
@@ -568,20 +567,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
       )
     #endif
   ;
 
   #if QUIET_PROBING
     probing_pause(false);
   #endif
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_PROBING)
+    endstops.not_homing();
     #if ENABLED(DELTA)
       tmc_stallguard(stepperX, false);
       tmc_stallguard(stepperY, false);
     #endif
     tmc_stallguard(stepperZ, false);
   #endif
 
   // Retract BLTouch immediately after a probe if it was triggered
   #if ENABLED(BLTOUCH)
     if (probe_triggered && set_bltouch_deployed(false)) return true;

commit 67b22760d97990529be41ef93d23fe0a782a1180
Author: Hannes Brandst√§tter-M√ºller <hannes.mueller@gmail.com>
Date:   Sun Nov 4 11:51:26 2018 +0100

    Return to status to show manual deploy/stow messages (#12324)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 61d7372247..fa9692d65c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -363,21 +363,22 @@ inline void do_probe_raise(const float z_raise) {
     do_blocking_move_to_z(z_dest);
 }
 
 FORCE_INLINE void probe_specific_action(const bool deploy) {
   #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
     BUZZ(100, 659);
     BUZZ(100, 698);
 
     PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-    lcd_setstatusPGM(ds_str);
+    lcd_return_to_status();       // To display the new status message
+    lcd_setstatusPGM(ds_str, 99);
     serialprintPGM(ds_str);
     SERIAL_EOL();
 
     KEEPALIVE_STATE(PAUSED_FOR_USER);
     wait_for_user = true;
     while (wait_for_user) idle();
     lcd_reset_status();
     KEEPALIVE_STATE(IN_HANDLER);
 
   #endif // PAUSE_BEFORE_DEPLOY_STOW

commit 6fbc87301f628bf859933fc69064008fc9726806
Author: MasterPIC <armando_unina@yahoo.it>
Date:   Sun Oct 28 02:30:21 2018 +0100

    'G29 H' to set a centered square probe area (linear, bilinear) (#12242)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index e1e2b052d7..61d7372247 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -394,21 +394,21 @@ FORCE_INLINE void probe_specific_action(const bool deploy) {
 
   #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
     MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
   #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
     deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
   #elif ENABLED(RACK_AND_PINION_PROBE)
-    
+
     do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
 
   #endif
 }
 
 // returns false for ok and true for failure
 bool set_probe_deployed(const bool deploy) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {

commit ab8425f1b57eede22873ef91c504605da8d41037
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 26 19:18:20 2018 -0500

    Clean up PROBE_TRIGGERED_WHEN_STOWED_TEST (#12232)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 1f5bcbfd86..e1e2b052d7 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -356,31 +356,66 @@ inline void do_probe_raise(const float z_raise) {
 
   float z_dest = z_raise;
   if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
 
   NOMORE(z_dest, Z_MAX_POS);
 
   if (z_dest > current_position[Z_AXIS])
     do_blocking_move_to_z(z_dest);
 }
 
-// returns false for ok and true for failure
-bool set_probe_deployed(const bool deploy) {
+FORCE_INLINE void probe_specific_action(const bool deploy) {
+  #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
-  // Can be extended to servo probes, if needed.
-  #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
-    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
-    #else
-      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+    BUZZ(100, 659);
+    BUZZ(100, 698);
+
+    PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+    lcd_setstatusPGM(ds_str);
+    serialprintPGM(ds_str);
+    SERIAL_EOL();
+
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+    wait_for_user = true;
+    while (wait_for_user) idle();
+    lcd_reset_status();
+    KEEPALIVE_STATE(IN_HANDLER);
+
+  #endif // PAUSE_BEFORE_DEPLOY_STOW
+
+  #if ENABLED(SOLENOID_PROBE)
+
+    #if HAS_SOLENOID_1
+      WRITE(SOL1_PIN, deploy);
     #endif
+
+  #elif ENABLED(Z_PROBE_SLED)
+
+    dock_sled(!deploy);
+
+  #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
+
+    MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
+
+  #elif ENABLED(Z_PROBE_ALLEN_KEY)
+
+    deploy ? run_deploy_moves_script() : run_stow_moves_script();
+
+  #elif ENABLED(RACK_AND_PINION_PROBE)
+    
+    do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
+
   #endif
+}
+
+// returns false for ok and true for failure
+bool set_probe_deployed(const bool deploy) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
@@ -413,88 +448,50 @@ bool set_probe_deployed(const bool deploy) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
       stop();
       return true;
     }
   #endif
 
   const float oldXpos = current_position[X_AXIS],
               oldYpos = current_position[Y_AXIS];
 
-  #ifdef _TRIGGERED_WHEN_STOWED_TEST
+  #if ENABLED(PROBE_TRIGGERED_WHEN_STOWED_TEST)
+    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #define PROBE_STOWED() (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
+    #else
+      #define PROBE_STOWED() (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+    #endif
+  #endif
 
-    // If endstop is already false, the Z probe is deployed
-    if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
-                                                     // Would a goto be less ugly?
-      //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
-                                                     // for a triggered when stowed manual probe.
+  #ifdef PROBE_STOWED
 
+    // Only deploy/stow if needed
+    if (PROBE_STOWED() == deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
-  #endif
-
-      #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
-
-        BUZZ(100, 659);
-        BUZZ(100, 698);
-
-        PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-        lcd_setstatusPGM(ds_str);
-        serialprintPGM(ds_str);
-        SERIAL_EOL();
-
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        wait_for_user = true;
-        while (wait_for_user) idle();
-        lcd_reset_status();
-        KEEPALIVE_STATE(IN_HANDLER);
-
-      #endif // PAUSE_BEFORE_DEPLOY_STOW
-
-      #if ENABLED(SOLENOID_PROBE)
-
-        #if HAS_SOLENOID_1
-          WRITE(SOL1_PIN, deploy);
-        #endif
-
-      #elif ENABLED(Z_PROBE_SLED)
-
-        dock_sled(!deploy);
-
-      #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
-
-        MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
-
-      #elif ENABLED(Z_PROBE_ALLEN_KEY)
-
-        deploy ? run_deploy_moves_script() : run_stow_moves_script();
-
-      #elif ENABLED(RACK_AND_PINION_PROBE)
-        
-        do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
-
-      #endif
-
-  #ifdef _TRIGGERED_WHEN_STOWED_TEST
-    } // _TRIGGERED_WHEN_STOWED_TEST == deploy
-
-    if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
+      probe_specific_action(deploy);
+    }
 
+    if (PROBE_STOWED() == deploy) {                // Unchanged after deploy/stow action?
       if (IsRunning()) {
         SERIAL_ERROR_START();
         SERIAL_ERRORLNPGM("Z-Probe failed");
         LCD_ALERTMESSAGEPGM("Err: ZPROBE");
       }
       stop();
       return true;
+    }
+
+  #else
 
-    } // _TRIGGERED_WHEN_STOWED_TEST == deploy
+    probe_specific_action(deploy);
 
   #endif
 
   do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   endstops.enable_z_probe(deploy);
   return false;
 }
 
 #ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position

commit 3028a620af6d6e7bea05e1dee2cdd2eae47db3b0
Author: Chris Rigter <chris@rigter.com.au>
Date:   Sat Oct 27 08:47:38 2018 +1100

    Add RACK_AND_PINION_PROBE (#12218)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 68d97733f8..1f5bcbfd86 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -461,20 +461,24 @@ bool set_probe_deployed(const bool deploy) {
         dock_sled(!deploy);
 
       #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
         MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
+      #elif ENABLED(RACK_AND_PINION_PROBE)
+        
+        do_blocking_move_to_x(deploy ? Z_PROBE_DEPLOY_X : Z_PROBE_RETRACT_X);
+
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
     if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
 
       if (IsRunning()) {
         SERIAL_ERROR_START();
         SERIAL_ERRORLNPGM("Z-Probe failed");

commit 951b25163e8b9e09212594b47c26434f23dc1a1e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 13 23:08:20 2018 -0500

    Extend M217 with configurable park/raise (#12076)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b19433b10f..68d97733f8 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -87,24 +87,20 @@ float zprobe_zoffset; // Initialized by settings.load()
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
-  FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
-    do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
-  }
-
   void run_deploy_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 797ec5fb0a..b19433b10f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -266,26 +266,26 @@ float zprobe_zoffset; // Initialized by settings.load()
 
 #endif // Z_PROBE_ALLEN_KEY
 
 #if ENABLED(PROBING_FANS_OFF)
 
   void fans_pause(const bool p) {
     if (p != fans_paused) {
       fans_paused = p;
       if (p)
         for (uint8_t x = 0; x < FAN_COUNT; x++) {
-          paused_fanSpeeds[x] = fanSpeeds[x];
-          fanSpeeds[x] = 0;
+          paused_fan_speed[x] = fan_speed[x];
+          fan_speed[x] = 0;
         }
       else
         for (uint8_t x = 0; x < FAN_COUNT; x++)
-          fanSpeeds[x] = paused_fanSpeeds[x];
+          fan_speed[x] = paused_fan_speed[x];
     }
   }
 
 #endif // PROBING_FANS_OFF
 
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif

commit e3f7b6910574edf7b0f1ec2e1670bb2003bb990d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 2 05:13:58 2018 -0500

    Add PROBING_STEPPERS_OFF (#11984)
    
    Co-Authored-By: houseofbugs <houseofbugs@gmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 20f3c665d3..797ec5fb0a 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -285,20 +285,26 @@ float zprobe_zoffset; // Initialized by settings.load()
 #endif // PROBING_FANS_OFF
 
 #if QUIET_PROBING
   void probing_pause(const bool p) {
     #if ENABLED(PROBING_HEATERS_OFF)
       thermalManager.pause(p);
     #endif
     #if ENABLED(PROBING_FANS_OFF)
       fans_pause(p);
     #endif
+    #if ENABLED(PROBING_STEPPERS_OFF)
+      disable_e_steppers();
+      #if DISABLED(DELTA)
+        disable_X(); disable_Y();
+      #endif
+    #endif
     if (p) safe_delay(
       #if DELAY_BEFORE_PROBING > 25
         DELAY_BEFORE_PROBING
       #else
         25
       #endif
     );
   }
 #endif // QUIET_PROBING
 

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 97b2efeff9..20f3c665d3 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -428,21 +428,21 @@ bool set_probe_deployed(const bool deploy) {
 
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
   #endif
 
       #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
         BUZZ(100, 659);
         BUZZ(100, 698);
 
-        const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+        PGM_P const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
         lcd_setstatusPGM(ds_str);
         serialprintPGM(ds_str);
         SERIAL_EOL();
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         wait_for_user = true;
         while (wait_for_user) idle();
         lcd_reset_status();
         KEEPALIVE_STATE(IN_HANDLER);
 

commit 3c40933713c268dd057f850e3190f3c6f4c39751
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 30 20:42:47 2018 -0500

    Remove trailing spaces, old comment

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0ebeaaaed5..97b2efeff9 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -544,21 +544,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   endstops.enable(true);
 
   // Move down until probe triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
-  const bool probe_triggered = 
+  const bool probe_triggered =
     #if ENABLED(DELTA) && ENABLED(SENSORLESS_PROBING)
       endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
       TEST(endstops.trigger_state(),
         #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           Z_MIN
         #else
           Z_MIN_PROBE
         #endif
       )

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 251861fcfe..0ebeaaaed5 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -51,20 +51,25 @@
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_PROBE
   #include "../module/servo.h"
 #endif
 
+#if ENABLED(SENSORLESS_PROBING)
+  #include "stepper.h"
+  #include "../feature/tmc_util.h"
+#endif
+
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
@@ -520,45 +525,72 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();
     }
   #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
+  // Disable stealthChop if used. Enable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_PROBING)
+    #if ENABLED(DELTA)
+      tmc_stallguard(stepperX);
+      tmc_stallguard(stepperY);
+    #endif
+    tmc_stallguard(stepperZ);
+  #endif
+
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
+  endstops.enable(true);
+
   // Move down until probe triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
-  const bool probe_triggered = TEST(endstops.trigger_state(),
-    #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-      Z_MIN
+  const bool probe_triggered = 
+    #if ENABLED(DELTA) && ENABLED(SENSORLESS_PROBING)
+      endstops.trigger_state() & (_BV(X_MIN) | _BV(Y_MIN) | _BV(Z_MIN))
     #else
-      Z_MIN_PROBE
+      TEST(endstops.trigger_state(),
+        #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+          Z_MIN
+        #else
+          Z_MIN_PROBE
+        #endif
+      )
     #endif
-  );
+  ;
 
   #if QUIET_PROBING
     probing_pause(false);
   #endif
 
+  // Re-enable stealthChop if used. Disable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_PROBING)
+    #if ENABLED(DELTA)
+      tmc_stallguard(stepperX, false);
+      tmc_stallguard(stepperY, false);
+    #endif
+    tmc_stallguard(stepperZ, false);
+  #endif
+
   // Retract BLTouch immediately after a probe if it was triggered
   #if ENABLED(BLTOUCH)
     if (probe_triggered && set_bltouch_deployed(false)) return true;
   #endif
 
+  // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   sync_plan_position();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
@@ -599,27 +631,25 @@ static float run_z_probe() {
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
-  #else
+  #elif Z_PROBE_SPEED_FAST != Z_PROBE_SPEED_SLOW
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0;
-    if (zprobe_zoffset < 0) z -= zprobe_zoffset;
-
+    const float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0 + (zprobe_zoffset < 0 ? -zprobe_zoffset : 0);
     if (current_position[Z_AXIS] > z) {
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {

commit f2e630a05e84c3fe3837a4a3d88caf57100654c6
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Sep 27 13:26:14 2018 -0400

    Stow probe on probing failed (#11936)
    
    Prevents probe from being left down should probing fail and print job continue

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ede0f7a468..251861fcfe 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -738,20 +738,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");
     SERIAL_PROTOCOL_F(measured_z, 3);
     SERIAL_EOL();
   }
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
+    STOW_PROBE();
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_START();
     SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   #endif
 
   return measured_z;

commit 0b602ae101c3c518d34e227c9709fa86fae5fe45
Author: Hannes Brandst√§tter-M√ºller <hannes.mueller@gmail.com>
Date:   Thu Sep 27 19:23:53 2018 +0200

    [2.0.x] Fix Anycubic Kossel with Probe V1, stuck LCD message after stow (#11929)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 87f4b3b205..ede0f7a468 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -424,21 +424,21 @@ bool set_probe_deployed(const bool deploy) {
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
   #endif
 
       #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
 
         BUZZ(100, 659);
         BUZZ(100, 698);
 
         const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-        lcd_setalertstatusPGM(ds_str);
+        lcd_setstatusPGM(ds_str);
         serialprintPGM(ds_str);
         SERIAL_EOL();
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         wait_for_user = true;
         while (wait_for_user) idle();
         lcd_reset_status();
         KEEPALIVE_STATE(IN_HANDLER);
 
       #endif // PAUSE_BEFORE_DEPLOY_STOW

commit 217e0efd20292f5cab81af4f381af214a8bf06e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 24 00:43:43 2018 -0400

    General option PAUSE_BEFORE_DEPLOY_STOW (#11905)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 29330de230..87f4b3b205 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -372,22 +372,22 @@ bool set_probe_deployed(const bool deploy) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
-  // unless MANUAL_DEPLOY_STOW is enabled
-  #if ENABLED(FIX_MOUNTED_PROBE) && DISABLED(MANUAL_DEPLOY_STOW)
+  // unless PAUSE_BEFORE_DEPLOY_STOW is enabled
+  #if ENABLED(FIX_MOUNTED_PROBE) && DISABLED(PAUSE_BEFORE_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
@@ -418,56 +418,56 @@ bool set_probe_deployed(const bool deploy) {
     // If endstop is already false, the Z probe is deployed
     if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
                                                      // Would a goto be less ugly?
       //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
                                                      // for a triggered when stowed manual probe.
 
       if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
                                                    // otherwise an Allen-Key probe can't be stowed.
   #endif
 
+      #if ENABLED(PAUSE_BEFORE_DEPLOY_STOW)
+
+        BUZZ(100, 659);
+        BUZZ(100, 698);
+
+        const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+        lcd_setalertstatusPGM(ds_str);
+        serialprintPGM(ds_str);
+        SERIAL_EOL();
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        wait_for_user = true;
+        while (wait_for_user) idle();
+        lcd_reset_status();
+        KEEPALIVE_STATE(IN_HANDLER);
+
+      #endif // PAUSE_BEFORE_DEPLOY_STOW
+
       #if ENABLED(SOLENOID_PROBE)
 
         #if HAS_SOLENOID_1
           WRITE(SOL1_PIN, deploy);
         #endif
 
       #elif ENABLED(Z_PROBE_SLED)
 
         dock_sled(!deploy);
 
       #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
         MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
-      #elif ENABLED(MANUAL_DEPLOY_STOW)
-
-        do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE);
-
-        BUZZ(100, 659);
-        BUZZ(100, 698);
-
-        const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
-        lcd_setalertstatusPGM(ds_str);
-        serialprintPGM(ds_str);
-        SERIAL_EOL();
-
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        wait_for_user = true;
-        while (wait_for_user) idle();
-        lcd_reset_status();
-        KEEPALIVE_STATE(IN_HANDLER);
-
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
     if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
 
       if (IsRunning()) {
         SERIAL_ERROR_START();
         SERIAL_ERRORLNPGM("Z-Probe failed");

commit a2b0260f0f9544c87c276a7b23272bd9307dd1fa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 23 19:58:36 2018 -0400

    Update Sublime files

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 43357d621d..29330de230 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -440,24 +440,22 @@ bool set_probe_deployed(const bool deploy) {
         MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
       #elif ENABLED(MANUAL_DEPLOY_STOW)
 
         do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE);
 
-        #if PIN_EXISTS(BEEPER) || ENABLED(LCD_USE_I2C_BUZZER)
-          BUZZ(100, 659);
-          BUZZ(100, 698);
-        #endif
+        BUZZ(100, 659);
+        BUZZ(100, 698);
 
         const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
         lcd_setalertstatusPGM(ds_str);
         serialprintPGM(ds_str);
         SERIAL_EOL();
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         wait_for_user = true;
         while (wait_for_user) idle();
         lcd_reset_status();

commit a4cdffdd69112424a3d678713cc8ac4c38ad8bad
Author: Hannes Brandst√§tter-M√ºller <hannes.mueller@gmail.com>
Date:   Sun Sep 23 18:50:03 2018 +0200

    Support for manually deployed fixed probes (#11899)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index c4d4bc22d4..43357d621d 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -21,20 +21,22 @@
  */
 
 /**
  * probe.cpp
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_BED_PROBE
 
+#include "../libs/buzzer.h"
+
 #include "probe.h"
 #include "motion.h"
 #include "temperature.h"
 #include "endstops.h"
 
 #include "../gcode/gcode.h"
 #include "../lcd/ultralcd.h"
 
 #include "../Marlin.h"
 
@@ -370,21 +372,22 @@ bool set_probe_deployed(const bool deploy) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
-  #if ENABLED(FIX_MOUNTED_PROBE)
+  // unless MANUAL_DEPLOY_STOW is enabled
+  #if ENABLED(FIX_MOUNTED_PROBE) && DISABLED(MANUAL_DEPLOY_STOW)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
@@ -433,20 +436,40 @@ bool set_probe_deployed(const bool deploy) {
         dock_sled(!deploy);
 
       #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
         MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
+      #elif ENABLED(MANUAL_DEPLOY_STOW)
+
+        do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE);
+
+        #if PIN_EXISTS(BEEPER) || ENABLED(LCD_USE_I2C_BUZZER)
+          BUZZ(100, 659);
+          BUZZ(100, 698);
+        #endif
+
+        const char * const ds_str = deploy ? PSTR(MSG_MANUAL_DEPLOY) : PSTR(MSG_MANUAL_STOW);
+        lcd_setalertstatusPGM(ds_str);
+        serialprintPGM(ds_str);
+        SERIAL_EOL();
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        wait_for_user = true;
+        while (wait_for_user) idle();
+        lcd_reset_status();
+        KEEPALIVE_STATE(IN_HANDLER);
+
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
     if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
 
       if (IsRunning()) {
         SERIAL_ERROR_START();
         SERIAL_ERRORLNPGM("Z-Probe failed");

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ed2ff0b9aa..c4d4bc22d4 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -530,21 +530,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   #if ENABLED(BLTOUCH)
     if (probe_triggered && set_bltouch_deployed(false)) return true;
   #endif
 
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
-  SYNC_PLAN_POSITION_KINEMATIC();
+  sync_plan_position();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   #endif
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe at the current position.

commit 3e81745e81fea173599b06ac9db7ed776e986808
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:53:42 2018 -0500

    Fix issues, make optional

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 1170d52feb..ed2ff0b9aa 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -427,21 +427,21 @@ bool set_probe_deployed(const bool deploy) {
         #if HAS_SOLENOID_1
           WRITE(SOL1_PIN, deploy);
         #endif
 
       #elif ENABLED(Z_PROBE_SLED)
 
         dock_sled(!deploy);
 
       #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
-        MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][(deploy ? 0 : 1)]);
+        MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 

commit aa80e448e24a27ac0006de4e3d3e93b18c73e3e0
Author: Jan <janschon@uni-bremen.de>
Date:   Tue Aug 7 17:04:46 2018 +0200

    Store servo angles in EEPROM

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 1b9cd39cda..1170d52feb 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -47,21 +47,20 @@
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_PROBE
   #include "../module/servo.h"
-  const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
@@ -428,21 +427,21 @@ bool set_probe_deployed(const bool deploy) {
         #if HAS_SOLENOID_1
           WRITE(SOL1_PIN, deploy);
         #endif
 
       #elif ENABLED(Z_PROBE_SLED)
 
         dock_sled(!deploy);
 
       #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
-        MOVE_SERVO(Z_PROBE_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
+        MOVE_SERVO(Z_PROBE_SERVO_NR, servo_angles[Z_PROBE_SERVO_NR][(deploy ? 0 : 1)]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 

commit 25e2ca88964a0f8156ccc385393102feec5443d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 12 21:36:24 2018 -0500

    Add Z_CLEARANCE_MULTI_PROBE
    
    Co-Authored-By: nightgryphon <ngryph@gmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f9eb04c409..1b9cd39cda 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -577,21 +577,21 @@ static float run_z_probe() {
       return NAN;
     }
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
-    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #else
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0;
     if (zprobe_zoffset < 0) z -= zprobe_zoffset;
 
     if (current_position[Z_AXIS] > z) {
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
@@ -611,21 +611,21 @@ static float run_z_probe() {
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOLNPGM("SLOW Probe fail!");
             DEBUG_POS("<<< run_z_probe", current_position);
           }
         #endif
         return NAN;
       }
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
-      if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_MULTI_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
     const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
 
   #elif MULTIPLE_PROBING == 2
 

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3cf79708dd..f9eb04c409 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -618,21 +618,21 @@ static float run_z_probe() {
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
-    const float measured_z = probes_total * (1.0 / (MULTIPLE_PROBING));
+    const float measured_z = probes_total * (1.0f / (MULTIPLE_PROBING));
 
   #elif MULTIPLE_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("2nd Probe Z:", z2);
         SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
       }

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index f3503cfad1..3cf79708dd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -525,21 +525,20 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
 
   #if QUIET_PROBING
     probing_pause(false);
   #endif
 
   // Retract BLTouch immediately after a probe if it was triggered
   #if ENABLED(BLTOUCH)
     if (probe_triggered && set_bltouch_deployed(false)) return true;
   #endif
 
-  // Clear endstop flags
   endstops.hit_on_purpose();
 
   // Get Z where the steppers were interrupted
   set_current_from_steppers_for_axis(Z_AXIS);
 
   // Tell the planner where we actually are
   SYNC_PLAN_POSITION_KINEMATIC();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 65fbff8822..f3503cfad1 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -379,21 +379,21 @@ bool set_probe_deployed(const bool deploy) {
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
   #if ENABLED(FIX_MOUNTED_PROBE)
     const bool deploy_stow_condition = deploy;
   #else
     constexpr bool deploy_stow_condition = true;
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
-    const bool unknown_condition = axis_known_position[Z_AXIS];
+    const bool unknown_condition = TEST(axis_known_position, Z_AXIS);
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
     do_probe_raise(MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
@@ -555,21 +555,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
  * @return The raw Z position where the probe was triggered
  */
 static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
-  const float z_probe_low_point = axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
+  const float z_probe_low_point = TEST(axis_known_position, Z_AXIS) ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPGM("FAST Probe fail!");
           DEBUG_POS("<<< run_z_probe", current_position);

commit b90f54b0fc6b7ae42e1a45db7ea33f81fd9e7ca8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 29 21:54:13 2018 -0500

    Improve probe logging

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 206ab2c57c..65fbff8822 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -547,35 +547,43 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe at the current position.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
-  static float run_z_probe() {
+static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) return NAN;
+    if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOLNPGM("FAST Probe fail!");
+          DEBUG_POS("<<< run_z_probe", current_position);
+        }
+      #endif
+      return NAN;
+    }
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
@@ -591,58 +599,68 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
       if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif
 
-      // Move down slowly to find bed, not too far
-      if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) return NAN;
+      // move down slowly to find bed
+      if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOLNPGM("SLOW Probe fail!");
+            DEBUG_POS("<<< run_z_probe", current_position);
+          }
+        #endif
+        return NAN;
+      }
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
-    return probes_total * (1.0 / (MULTIPLE_PROBING));
+    const float measured_z = probes_total * (1.0 / (MULTIPLE_PROBING));
 
   #elif MULTIPLE_PROBING == 2
 
     const float z2 = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("2nd Probe Z:", z2);
         SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
       }
     #endif
 
     // Return a weighted average of the fast and slow probes
-    return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
+    const float measured_z = (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
 
   #else
 
     // Return the single probe result
-    return current_position[Z_AXIS];
+    const float measured_z = current_position[Z_AXIS];
 
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   #endif
+
+  return measured_z;
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
@@ -698,32 +716,32 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");
     SERIAL_PROTOCOL_F(measured_z, 3);
     SERIAL_EOL();
   }
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
-  #endif
-
   feedrate_mm_s = old_feedrate_mm_s;
 
   if (isnan(measured_z)) {
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_START();
     SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   }
 
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
+  #endif
+
   return measured_z;
 }
 
 #if HAS_Z_SERVO_PROBE
 
   void servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow

commit 4b2f6e3b2b0d6773cb15e55433bb243625ba71ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 21 15:51:38 2018 -0500

    [2.0.x] Add endstop noise filter (#10796)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3ffdb29e0b..206ab2c57c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -508,21 +508,21 @@ static bool do_probe_move(const float z, const float fr_mm_s) {
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   // Move down until probe triggered
   do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
-  const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
+  const bool probe_triggered = TEST(endstops.trigger_state(),
     #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       Z_MIN
     #else
       Z_MIN_PROBE
     #endif
   );
 
   #if QUIET_PROBING
     probing_pause(false);
   #endif

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7f95d7cb1e..3ffdb29e0b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -385,21 +385,21 @@ bool set_probe_deployed(const bool deploy) {
   #endif
 
   // For beds that fall when Z is powered off only raise for trusted Z
   #if ENABLED(UNKNOWN_Z_NO_RAISE)
     const bool unknown_condition = axis_known_position[Z_AXIS];
   #else
     constexpr float unknown_condition = true;
   #endif
 
   if (deploy_stow_condition && unknown_condition)
-    do_probe_raise(max(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
+    do_probe_raise(MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
@@ -665,21 +665,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
-      min(current_position[Z_AXIS], delta_clip_start_height)
+      MIN(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);

commit 1f92b9a4edaf6ea55b0a38155e34970248bb8993
Author: MagoKimbra <magokimbra@hotmail.com>
Date:   Mon Apr 30 23:28:20 2018 +0200

    Fix do_probe_move with fr_mm_s (#10576)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a0dd4d0bab..7f95d7cb1e 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -480,21 +480,21 @@ bool set_probe_deployed(const bool deploy) {
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
 #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
-static bool do_probe_move(const float z, const float fr_mm_m) {
+static bool do_probe_move(const float z, const float fr_mm_s) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   #endif
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
@@ -505,21 +505,21 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   // Move down until probe triggered
-  do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
+  do_blocking_move_to_z(z, fr_mm_s);
 
   // Check to see if the probe was triggered
   const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
     #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       Z_MIN
     #else
       Z_MIN_PROBE
     #endif
   );
 

commit 4dfc011d86b8a271fca23b42a8cb73902d622fb2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:35:07 2018 -0500

    Fix homing with probe feedrates

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a1256994a8..a0dd4d0bab 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -561,52 +561,52 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
   #endif
 
   // Stop the probe before it goes too low to prevent damage.
   // If Z isn't known then probe to -10mm.
   const float z_probe_low_point = axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (do_probe_move(z_probe_low_point, Z_PROBE_SPEED_FAST)) return NAN;
+    if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_FAST))) return NAN;
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #else
 
     // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
     float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0;
     if (zprobe_zoffset < 0) z -= zprobe_zoffset;
 
     if (current_position[Z_AXIS] > z) {
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
-      if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
+      if (!do_probe_move(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST)))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif
 
       // Move down slowly to find bed, not too far
-      if (do_probe_move(z_probe_low_point, Z_PROBE_SPEED_SLOW)) return NAN;
+      if (do_probe_move(z_probe_low_point, MMM_TO_MMS(Z_PROBE_SPEED_SLOW))) return NAN;
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes

commit 59fda986ea429c83b0e20cd8b1a172fd2a550852
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:25:47 2018 -0500

    Allow Z_AFTER_PROBING to be 0

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8100060267..a1256994a8 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -458,21 +458,21 @@ bool set_probe_deployed(const bool deploy) {
 
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
   #endif
 
   do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   endstops.enable_z_probe(deploy);
   return false;
 }
 
-#if Z_AFTER_PROBING
+#ifdef Z_AFTER_PROBING
   // After probing move to a preferred Z position
   void move_z_after_probing() {
     if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position[Z_AXIS] = Z_AFTER_PROBING;
     }
   }
 #endif
 
 /**

commit f423e54f77d82bc2d70e035ec4a6f8d50ce6f6f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 23 18:00:06 2018 -0500

    Strip trailing spaces

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b3169b5221..8100060267 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -493,21 +493,21 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
   #endif
 
   #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();
     }
-  #endif  
+  #endif
 
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 

commit cb46cb8480c33ffc9f6361b96ed200986a3bd9ac
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 23 17:13:01 2018 -0500

    Add HAS_HEATED_BED conditional (#10495)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 46b1e328da..b3169b5221 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -476,30 +476,30 @@ bool set_probe_deployed(const bool deploy) {
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 
-#if HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+#if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
   const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
 #endif
 
 static bool do_probe_move(const float z, const float fr_mm_m) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   #endif
 
-  #if HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  #if HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();
     }
   #endif  
 
   // Deploy BLTouch at the start of any probe

commit a90cbc633993dc236fdb5d2aa174b52c321533c4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 21 15:43:21 2018 -0500

    [2.0.x] Wait for bed heaters between probing (#10472)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3c1a27cb55..46b1e328da 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -475,25 +475,40 @@ bool set_probe_deployed(const bool deploy) {
   }
 #endif
 
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
+
+#if HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  const char msg_wait_for_bed_heating[25] PROGMEM = "Wait for bed heating...\n";
+#endif
+
 static bool do_probe_move(const float z, const float fr_mm_m) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   #endif
 
+  #if HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+    // Wait for bed to heat back up between probing points
+    if (thermalManager.isHeatingBed()) {
+      serialprintPGM(msg_wait_for_bed_heating);
+      LCD_MESSAGEPGM(MSG_BED_HEATING);
+      while (thermalManager.isHeatingBed()) safe_delay(200);
+      lcd_reset_status();
+    }
+  #endif  
+
   // Deploy BLTouch at the start of any probe
   #if ENABLED(BLTOUCH)
     if (set_bltouch_deployed(true)) return true;
   #endif
 
   #if QUIET_PROBING
     probing_pause(true);
   #endif
 
   // Move down until probe triggered

commit 646aa20b433cbde61a849a2b79ddf1c0a13714ef
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 04:14:48 2018 +0200

    Overhaul of G33 Delta Calibration (#8822)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 932bb3f4b2..3c1a27cb55 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -666,22 +666,23 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
     measured_z = run_z_probe() + zprobe_zoffset;
 
-    if (raise_after == PROBE_PT_RAISE)
-      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    const bool big_raise = raise_after == PROBE_PT_BIG_RAISE;
+    if (big_raise || raise_after == PROBE_PT_RAISE)
+      do_blocking_move_to_z(current_position[Z_AXIS] + (big_raise ? 25 : Z_CLEARANCE_BETWEEN_PROBES), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");

commit ac2e0afb62bd201608e27e5ef5e0d4ccc5ac9fe5
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 01:59:46 2018 +0200

    Low Point for delta calibration (#10363)

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index ed585299bf..932bb3f4b2 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -532,42 +532,29 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe at the current position.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
-#define HAS_CALIBRATION_PROBE (ENABLED(DELTA_AUTO_CALIBRATION) && Z_PROBE_LOW_POINT < 0)
-static float run_z_probe(
-  #if HAS_CALIBRATION_PROBE
-    const bool is_calibration
-  #endif
-) {
+  static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
-  #if Z_PROBE_LOW_POINT < 0
-    // Stop the probe before it goes too low to prevent damage.
-    // If Z isn't known or this is a "calibration probe" then probe to -10mm.
-    #if !HAS_CALIBRATION_PROBE
-      constexpr bool is_calibration = false;
-    #endif
-    const float z_probe_low_point = !is_calibration && axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
-  #else
-    // Assertively move down in all cases
-    constexpr float z_probe_low_point = -10.0;
-  #endif
+  // Stop the probe before it goes too low to prevent damage.
+  // If Z isn't known then probe to -10mm.
+  const float z_probe_low_point = axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(z_probe_low_point, Z_PROBE_SPEED_FAST)) return NAN;
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -638,36 +625,36 @@ static float run_z_probe(
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool is_calibration/*=false*/) {
+float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
       SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
       SERIAL_ECHOPAIR(", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none");
       SERIAL_ECHOPAIR(", ", int(verbose_level));
-      SERIAL_ECHOPAIR(", ", is_calibration ? "nozzle" : "probe");
+      SERIAL_ECHOPAIR(", ", probe_relative ? "probe" : "nozzle");
       SERIAL_ECHOLNPGM("_relative)");
       DEBUG_POS("", current_position);
     }
   #endif
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
-  if (!is_calibration) {
+  if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       min(current_position[Z_AXIS], delta_clip_start_height)
@@ -677,25 +664,21 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe(
-      #if HAS_CALIBRATION_PROBE
-        is_calibration
-      #endif
-    ) + zprobe_zoffset;
+    measured_z = run_z_probe() + zprobe_zoffset;
 
     if (raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);

commit 8b8ad14178374c06858444434988291993903fbb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 9 01:46:23 2018 -0500

    Add Z_PROBE_LOW_POINT to prevent damage

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9375ff247c..ed585299bf 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -532,31 +532,48 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe at the current position.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
-static float run_z_probe() {
+#define HAS_CALIBRATION_PROBE (ENABLED(DELTA_AUTO_CALIBRATION) && Z_PROBE_LOW_POINT < 0)
+static float run_z_probe(
+  #if HAS_CALIBRATION_PROBE
+    const bool is_calibration
+  #endif
+) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
+  #if Z_PROBE_LOW_POINT < 0
+    // Stop the probe before it goes too low to prevent damage.
+    // If Z isn't known or this is a "calibration probe" then probe to -10mm.
+    #if !HAS_CALIBRATION_PROBE
+      constexpr bool is_calibration = false;
+    #endif
+    const float z_probe_low_point = !is_calibration && axis_known_position[Z_AXIS] ? -zprobe_zoffset + Z_PROBE_LOW_POINT : -10.0;
+  #else
+    // Assertively move down in all cases
+    constexpr float z_probe_low_point = -10.0;
+  #endif
+
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
-    if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
+    if (do_probe_move(z_probe_low_point, Z_PROBE_SPEED_FAST)) return NAN;
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
@@ -573,21 +590,21 @@ static float run_z_probe() {
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif
 
       // Move down slowly to find bed, not too far
-      if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
+      if (do_probe_move(z_probe_low_point, Z_PROBE_SPEED_SLOW)) return NAN;
 
   #if MULTIPLE_PROBING > 2
       probes_total += current_position[Z_AXIS];
       if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
 
     // Return the average value of all probes
@@ -621,36 +638,36 @@ static float run_z_probe() {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
+float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool is_calibration/*=false*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
       SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
       SERIAL_ECHOPAIR(", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none");
       SERIAL_ECHOPAIR(", ", int(verbose_level));
-      SERIAL_ECHOPAIR(", ", probe_relative ? "probe" : "nozzle");
+      SERIAL_ECHOPAIR(", ", is_calibration ? "nozzle" : "probe");
       SERIAL_ECHOLNPGM("_relative)");
       DEBUG_POS("", current_position);
     }
   #endif
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
-  if (probe_relative) {
+  if (!is_calibration) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       min(current_position[Z_AXIS], delta_clip_start_height)
@@ -660,21 +677,25 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe() + zprobe_zoffset;
+    measured_z = run_z_probe(
+      #if HAS_CALIBRATION_PROBE
+        is_calibration
+      #endif
+    ) + zprobe_zoffset;
 
     if (raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);

commit adcb87f0db47672c28cfec9fda3354adac81fa99
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 1 23:54:12 2018 -0500

    Z Endstop Servo => Z Probe Servo

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 2f70a28667..9375ff247c 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -45,21 +45,21 @@
 #if ENABLED(DELTA)
   #include "../module/delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
-#if HAS_Z_SERVO_ENDSTOP
+#if HAS_Z_SERVO_PROBE
   #include "../module/servo.h"
   const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
@@ -292,21 +292,21 @@ float zprobe_zoffset; // Initialized by settings.load()
       #else
         25
       #endif
     );
   }
 #endif // QUIET_PROBING
 
 #if ENABLED(BLTOUCH)
 
   void bltouch_command(const int angle) {
-    MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
+    MOVE_SERVO(Z_PROBE_SERVO_NR, angle);  // Give the BL-Touch the command and wait
     safe_delay(BLTOUCH_DELAY);
   }
 
   bool set_bltouch_deployed(const bool deploy) {
     if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
       bltouch_command(BLTOUCH_RESET);    //  try to reset it.
       bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
       bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
       safe_delay(1500);                  // Wait for internal self-test to complete.
                                          //  (Measured completion time was 0.65 seconds
@@ -426,23 +426,23 @@ bool set_probe_deployed(const bool deploy) {
       #if ENABLED(SOLENOID_PROBE)
 
         #if HAS_SOLENOID_1
           WRITE(SOL1_PIN, deploy);
         #endif
 
       #elif ENABLED(Z_PROBE_SLED)
 
         dock_sled(!deploy);
 
-      #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
+      #elif HAS_Z_SERVO_PROBE && DISABLED(BLTOUCH)
 
-        MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
+        MOVE_SERVO(Z_PROBE_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
 
       #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
         deploy ? run_deploy_moves_script() : run_stow_moves_script();
 
       #endif
 
   #ifdef _TRIGGERED_WHEN_STOWED_TEST
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
@@ -693,28 +693,28 @@ float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/
 
   if (isnan(measured_z)) {
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_START();
     SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   }
 
   return measured_z;
 }
 
-#if HAS_Z_SERVO_ENDSTOP
+#if HAS_Z_SERVO_PROBE
 
   void servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!
      *
      */
     STOW_Z_SERVO();
   }
 
-#endif // HAS_Z_SERVO_ENDSTOP
+#endif // HAS_Z_SERVO_PROBE
 
 #endif // HAS_BED_PROBE

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 18e13fe318..2f70a28667 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -538,23 +538,20 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
 static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
-  // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
-  gcode.refresh_cmd_timeout();
-
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
 
     float first_probe_z = current_position[Z_AXIS];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);

commit bc45fb6b131598403c8fdc5089697d98dc878299
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:08:44 2018 -0500

    Tweak use of move_z_after_probing

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0f3defbb22..18e13fe318 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -458,21 +458,21 @@ bool set_probe_deployed(const bool deploy) {
 
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
   #endif
 
   do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   endstops.enable_z_probe(deploy);
   return false;
 }
 
-#ifdef Z_AFTER_PROBING
+#if Z_AFTER_PROBING
   // After probing move to a preferred Z position
   void move_z_after_probing() {
     if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
       do_blocking_move_to_z(Z_AFTER_PROBING);
       current_position[Z_AXIS] = Z_AFTER_PROBING;
     }
   }
 #endif
 
 /**

commit c352954882bc931377ece338b3f5fa459c55ea07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:01:43 2018 -0500

    Allow no raise after run_z_probe in probe_pt

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 7ed4d0e6af..0f3defbb22 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -624,27 +624,29 @@ static float run_z_probe() {
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative/*=true*/) {
+float probe_pt(const float &rx, const float &ry, const ProbePtRaise raise_after/*=PROBE_PT_NONE*/, const uint8_t verbose_level/*=0*/, const bool probe_relative/*=true*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
       SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
-      SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
-      SERIAL_ECHOLNPGM("stow)");
+      SERIAL_ECHOPAIR(", ", raise_after == PROBE_PT_RAISE ? "raise" : raise_after == PROBE_PT_STOW ? "stow" : "none");
+      SERIAL_ECHOPAIR(", ", int(verbose_level));
+      SERIAL_ECHOPAIR(", ", probe_relative ? "probe" : "nozzle");
+      SERIAL_ECHOLNPGM("_relative)");
       DEBUG_POS("", current_position);
     }
   #endif
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
@@ -663,23 +665,23 @@ float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
     measured_z = run_z_probe() + zprobe_zoffset;
 
-    if (!stow)
+    if (raise_after == PROBE_PT_RAISE)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
-    else
+    else if (raise_after == PROBE_PT_STOW)
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");
     SERIAL_PROTOCOL_F(measured_z, 3);

commit 28f1276286da94f4a1b3a7bffa103a35a3ee8352
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 11 13:07:55 2018 -0500

    [2.0.x] Add Z_AFTER_PROBING option (#10058)
    
    Some "fix-mounted" probes need manual stowing. And after probing some may prefer to raise or lower the nozzle. This restores an old option but tailors it to allow raise or lower as preferred.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 6bda510d27..7ed4d0e6af 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -458,20 +458,30 @@ bool set_probe_deployed(const bool deploy) {
 
     } // _TRIGGERED_WHEN_STOWED_TEST == deploy
 
   #endif
 
   do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   endstops.enable_z_probe(deploy);
   return false;
 }
 
+#ifdef Z_AFTER_PROBING
+  // After probing move to a preferred Z position
+  void move_z_after_probing() {
+    if (current_position[Z_AXIS] != Z_AFTER_PROBING) {
+      do_blocking_move_to_z(Z_AFTER_PROBING);
+      current_position[Z_AXIS] = Z_AFTER_PROBING;
+    }
+  }
+#endif
+
 /**
  * @brief Used by run_z_probe to do a single Z probe move.
  *
  * @param  z        Z destination
  * @param  fr_mm_s  Feedrate in mm/s
  * @return true to indicate an error
  */
 static bool do_probe_move(const float z, const float fr_mm_m) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);

commit 419d12ca1be19d1792db05062b4fa2808b05d165
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 23:18:47 2018 -0600

    Add UNKNOWN_Z_NO_RAISE option
    
    With this option enabled, Z won't ever be raised until after `G28` has been completed, and it won't raise if Z becomes unknown. This is good for machines whose beds fall when Z is powered off.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9d54d5c5ab..6bda510d27 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -371,27 +371,35 @@ bool set_probe_deployed(const bool deploy) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
   // Make room for probe to deploy (or stow)
   // Fix-mounted probe should only raise for deploy
-  if (
-    #if ENABLED(FIX_MOUNTED_PROBE)
-      deploy
-    #else
-      true
-    #endif
-  ) do_probe_raise(max(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
+  #if ENABLED(FIX_MOUNTED_PROBE)
+    const bool deploy_stow_condition = deploy;
+  #else
+    constexpr bool deploy_stow_condition = true;
+  #endif
+
+  // For beds that fall when Z is powered off only raise for trusted Z
+  #if ENABLED(UNKNOWN_Z_NO_RAISE)
+    const bool unknown_condition = axis_known_position[Z_AXIS];
+  #else
+    constexpr float unknown_condition = true;
+  #endif
+
+  if (deploy_stow_condition && unknown_condition)
+    do_probe_raise(max(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);

commit 3b4c89e4b580792caa47d8eb2bcae0d971f152bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 23:18:08 2018 -0600

    Move do_probe_raise closer to set_probe_deployed
    
    ‚Ä¶and limit the raise to Z_MAX_POS

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 0a4692a347..9d54d5c5ab 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -50,39 +50,20 @@
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_ENDSTOP
   #include "../module/servo.h"
   const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
-/**
- * Raise Z to a minimum height to make room for a probe to move
- */
-inline void do_probe_raise(const float z_raise) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-
-  float z_dest = z_raise;
-  if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
-
-  if (z_dest > current_position[Z_AXIS])
-    do_blocking_move_to_z(z_dest);
-}
-
 #if ENABLED(Z_PROBE_SLED)
 
   #ifndef SLED_DOCKING_OFFSET
     #define SLED_DOCKING_OFFSET 0
   #endif
 
   /**
    * Method to dock/undock a sled designed by Charles Bell.
    *
    * stow[in]     If false, move to MAX_X and engage the solenoid
@@ -346,20 +327,41 @@ inline void do_probe_raise(const float z_raise) {
         SERIAL_CHAR(')');
         SERIAL_EOL();
       }
     #endif
 
     return false;
   }
 
 #endif // BLTOUCH
 
+/**
+ * Raise Z to a minimum height to make room for a probe to move
+ */
+inline void do_probe_raise(const float z_raise) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  float z_dest = z_raise;
+  if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
+
+  NOMORE(z_dest, Z_MAX_POS);
+
+  if (z_dest > current_position[Z_AXIS])
+    do_blocking_move_to_z(z_dest);
+}
+
 // returns false for ok and true for failure
 bool set_probe_deployed(const bool deploy) {
 
   // Can be extended to servo probes, if needed.
   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
     #else
       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
     #endif

commit 3f89bbeab546f15fb1a3eb99964b194b862fb9c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 24 16:35:31 2018 -0600

    Drop a conditional only used once

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 5d90734974..0a4692a347 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -367,29 +367,29 @@ bool set_probe_deployed(const bool deploy) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
-  // Fix-mounted probe should only raise for deploy
-  #if ENABLED(FIX_MOUNTED_PROBE)
-    #define RAISE_COND deploy
-  #else
-    #define RAISE_COND true
-  #endif
-
   // Make room for probe to deploy (or stow)
-  if (RAISE_COND) do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
+  // Fix-mounted probe should only raise for deploy
+  if (
+    #if ENABLED(FIX_MOUNTED_PROBE)
+      deploy
+    #else
+      true
+    #endif
+  ) do_probe_raise(max(Z_CLEARANCE_BETWEEN_PROBES, Z_CLEARANCE_DEPLOY_PROBE));
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);

commit b3deadd89888735c0ee91f730d268dc0b6fba4d6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 08:36:43 2018 -0600

    Don't raise FIX_MOUNTED_PROBE on stow
    
    Reference #9336

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 3bfd0cb902..5d90734974 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -367,22 +367,29 @@ bool set_probe_deployed(const bool deploy) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       DEBUG_POS("set_probe_deployed", current_position);
       SERIAL_ECHOLNPAIR("deploy: ", deploy);
     }
   #endif
 
   if (endstops.z_probe_enabled == deploy) return false;
 
-  // Make room for probe
-  do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
+  // Fix-mounted probe should only raise for deploy
+  #if ENABLED(FIX_MOUNTED_PROBE)
+    #define RAISE_COND deploy
+  #else
+    #define RAISE_COND true
+  #endif
+
+  // Make room for probe to deploy (or stow)
+  if (RAISE_COND) do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
 
   #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
     #if ENABLED(Z_PROBE_SLED)
       #define _AUE_ARGS true, false, false
     #else
       #define _AUE_ARGS
     #endif
     if (axis_unhomed_error(_AUE_ARGS)) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);

commit 9b9350e0104835be54ccda89f0bae9e0659281d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 2 02:32:11 2018 -0600

    Fix jerky Z motion between probes
    
    Suggested by #9375

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 8b42b1c99f..3bfd0cb902 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -531,27 +531,26 @@ static float run_z_probe() {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #else
 
-    // If the nozzle is above the travel height then
+    // If the nozzle is well over the travel height then
     // move down quickly before doing the slow probe
-    float z = Z_CLEARANCE_DEPLOY_PROBE;
+    float z = Z_CLEARANCE_DEPLOY_PROBE + 5.0;
     if (zprobe_zoffset < 0) z -= zprobe_zoffset;
 
-    if (z < current_position[Z_AXIS]) {
-
+    if (current_position[Z_AXIS] > z) {
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
       if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
   #if MULTIPLE_PROBING > 2
     float probes_total = 0;
     for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a8c6e32d17..8b42b1c99f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -100,21 +100,21 @@ inline void do_probe_raise(const float z_raise) {
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
-  FORCE_INLINE void do_blocking_move_to(const float raw[XYZ], const float &fr_mm_s) {
+  FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
   }
 
   void run_deploy_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]

commit 728acf521ca3f5d9cae36e0ac7cd57e052f51021
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 03:49:33 2017 -0600

    Followup to #8706

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b483ff022f..a8c6e32d17 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -520,22 +520,23 @@ static float run_z_probe() {
 
   // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   gcode.refresh_cmd_timeout();
 
   // Double-probing does a fast probe followed by a slow probe
   #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
 
+    float first_probe_z = current_position[Z_AXIS];
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      float first_probe_z = current_position[Z_AXIS];
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
     do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
   #else
 
     // If the nozzle is above the travel height then
     // move down quickly before doing the slow probe

commit ae663a4198512796319934a0dbd64832040fd0a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 7 16:33:51 2017 -0600

    PROBE_DOUBLE_TOUCH => MULTIPLE_PROBING

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index b509adec6b..b483ff022f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -500,35 +500,36 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
   SYNC_PLAN_POSITION_KINEMATIC();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   #endif
 
   return !probe_triggered;
 }
 
 /**
- * @details Used by probe_pt to do a single Z probe.
+ * @details Used by probe_pt to do a single Z probe at the current position.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
  * @return The raw Z position where the probe was triggered
  */
 static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
   // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   gcode.refresh_cmd_timeout();
 
-  #if ENABLED(PROBE_DOUBLE_TOUCH)
+  // Double-probing does a fast probe followed by a slow probe
+  #if MULTIPLE_PROBING == 2
 
     // Do a first probe at the fast speed
     if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       float first_probe_z = current_position[Z_AXIS];
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
     #endif
 
     // move up to make clearance for the probe
@@ -542,36 +543,63 @@ static float run_z_probe() {
     if (zprobe_zoffset < 0) z -= zprobe_zoffset;
 
     if (z < current_position[Z_AXIS]) {
 
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
       if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
-  // Move down slowly to find bed, not too far
-  if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
+  #if MULTIPLE_PROBING > 2
+    float probes_total = 0;
+    for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   #endif
 
-  // Debug: compare probe heights
-  #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
-      SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
+      // Move down slowly to find bed, not too far
+      if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
+
+  #if MULTIPLE_PROBING > 2
+      probes_total += current_position[Z_AXIS];
+      if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
-  return current_position[Z_AXIS];
+  #if MULTIPLE_PROBING > 2
+
+    // Return the average value of all probes
+    return probes_total * (1.0 / (MULTIPLE_PROBING));
+
+  #elif MULTIPLE_PROBING == 2
+
+    const float z2 = current_position[Z_AXIS];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("2nd Probe Z:", z2);
+        SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
+      }
+    #endif
+
+    // Return a weighted average of the fast and slow probes
+    return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
+
+  #else
+
+    // Return the single probe result
+    return current_position[Z_AXIS];
+
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
+  #endif
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position

commit a67cf78c6be7816d83a300d5fc539cfa1fd7fca8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 26 20:18:52 2017 -0600

    Clean up whitespace, spacing

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index fd53a671dd..b509adec6b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -589,21 +589,21 @@ float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t
 
   // TODO: Adapt for SCARA, where the offset rotates
   float nx = rx, ny = ry;
   if (probe_relative) {
     if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
     nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
     ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
   else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
-  const float nz = 
+  const float nz =
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       min(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;

commit 65f365333ff15b93ddbe16db18b119c717a6f7bc
Author: LVD-AC <lvd@sound-silence.com>
Date:   Sat Nov 25 10:59:46 2017 +0100

    [2.0.x] G33 probe error handling

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a6591db583..fd53a671dd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -557,68 +557,70 @@ static float run_z_probe() {
   #endif
 
   // Debug: compare probe heights
   #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
       SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
     }
   #endif
 
-  return current_position[Z_AXIS] + zprobe_zoffset;
+  return current_position[Z_AXIS];
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool printable/*=true*/) {
+float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative/*=true*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
       SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
       SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
       SERIAL_ECHOLNPGM("stow)");
       DEBUG_POS("", current_position);
     }
   #endif
 
-  const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
-
-  if (!printable
-    ? !position_is_reachable(nx, ny)
-    : !position_is_reachable_by_probe(rx, ry)
-  ) return NAN;
+  // TODO: Adapt for SCARA, where the offset rotates
+  float nx = rx, ny = ry;
+  if (probe_relative) {
+    if (!position_is_reachable_by_probe(rx, ry)) return NAN;  // The given position is in terms of the probe
+    nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
+    ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
+  }
+  else if (!position_is_reachable(nx, ny)) return NAN;        // The given position is in terms of the nozzle
 
   const float nz = 
     #if ENABLED(DELTA)
       // Move below clip height or xy move will be aborted by do_blocking_move_to
       min(current_position[Z_AXIS], delta_clip_start_height)
     #else
       current_position[Z_AXIS]
     #endif
   ;
 
   const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the starting XYZ
   do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe();
+    measured_z = run_z_probe() + zprobe_zoffset;
 
     if (!stow)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);

commit 80ada588181f6062ada9741aa8bdc28a581c50d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 24 17:10:27 2017 -0600

    One fewer function call in probe_pt

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 127c6b0035..a6591db583 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -587,31 +587,34 @@ float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t
     }
   #endif
 
   const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
 
   if (!printable
     ? !position_is_reachable(nx, ny)
     : !position_is_reachable_by_probe(rx, ry)
   ) return NAN;
 
-  const float old_feedrate_mm_s = feedrate_mm_s;
-
-  #if ENABLED(DELTA)
-    if (current_position[Z_AXIS] > delta_clip_start_height)
-      do_blocking_move_to_z(delta_clip_start_height);
-  #endif
+  const float nz = 
+    #if ENABLED(DELTA)
+      // Move below clip height or xy move will be aborted by do_blocking_move_to
+      min(current_position[Z_AXIS], delta_clip_start_height)
+    #else
+      current_position[Z_AXIS]
+    #endif
+  ;
 
+  const float old_feedrate_mm_s = feedrate_mm_s;
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
-  // Move the probe to the given XY
-  do_blocking_move_to_xy(nx, ny);
+  // Move the probe to the starting XYZ
+  do_blocking_move_to(nx, ny, nz);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
     measured_z = run_z_probe();
 
     if (!stow)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else
       if (STOW_PROBE()) measured_z = NAN;
   }

commit c0000a0cdc68dc2c9b49e5fcb1a04275fadd49dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 19 13:39:46 2017 -0600

    Move servo code to modules/servo.*

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 43ab0f9d98..127c6b0035 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -46,20 +46,21 @@
   #include "../module/delta.h"
 #endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "planner.h"
 #endif
 
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_ENDSTOP
+  #include "../module/servo.h"
   const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("do_probe_raise(", z_raise);

commit 3bba7d60f352c7da638bc1fb65b279cd972d9b79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 16:53:55 2017 -0600

    No retroactive changes with M851 Z
    
    If using babystep to adjust the Z probe offset, the axis will move and the mesh will be updated at the same time, causing a doubling of the Z offset over the rest of the print.
    
    To correct for this, the current Z position would need to be modified in the opposite direction, canceling out the additional Z offset added to the mesh. This would be confusing to users, and moreover it would not be accurate without also taking the current Z fade level and current Z height into account.
    
    It might make sense to change the mesh in the case where no babystepping is taking place, but this could be considered an undesirable side-effect of changing the `zprobe_zoffset`.
    
    One way to remedy this would be to return to storing the mesh with `zprobe_zoffset` included, then subtracting `zprobe_zoffset` from the returned Z value. Thus, a babystep moving the Z axis up 1mm would subtract 1 from `zprobe_zoffset` while adding 1 to all mesh Z values.
    
    Without including the `zprobe_zoffset` in the `z_values` there is no safe way to alter the mesh in conjunction with babystepping, although it's fine without it.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 046ae0bcbd..43ab0f9d98 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -633,56 +633,20 @@ float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t
 
   if (isnan(measured_z)) {
     LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
     SERIAL_ERROR_START();
     SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   }
 
   return measured_z;
 }
 
-void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
-  static float last_zoffset = NAN;
-
-  if (!isnan(last_zoffset)) {
-
-    #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
-      const float diff = zprobe_zoffset - last_zoffset;
-    #endif
-
-    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      // Correct bilinear grid for new probe offset
-      if (diff) {
-        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-          for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-            z_values[x][y] -= diff;
-      }
-      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-        bed_level_virt_interpolate();
-      #endif
-    #endif
-
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      if (!no_babystep && planner.leveling_active)
-        thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
-    #else
-      UNUSED(no_babystep);
-    #endif
-
-    #if ENABLED(DELTA) // correct the delta_height
-      delta_height -= diff;
-    #endif
-  }
-
-  last_zoffset = zprobe_zoffset;
-}
-
 #if HAS_Z_SERVO_ENDSTOP
 
   void servo_probe_init() {
     /**
      * Set position of Z Servo Endstop
      *
      * The servo might be deployed and positioned too low to stow
      * when starting up the machine or rebooting the board.
      * There's no way to know where the nozzle is positioned until
      * homing has been done - no homing with z-probe without init!

commit e334efb2a7914b6a39fb3c060790319664d98b2d
Author: LVD-AC <lvd@sound-silence.com>
Date:   Wed Nov 8 10:07:17 2017 +0100

    PROBE_MANUALLY etc.

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 918e89e904..046ae0bcbd 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -502,24 +502,23 @@ static bool do_probe_move(const float z, const float fr_mm_m) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   #endif
 
   return !probe_triggered;
 }
 
 /**
  * @details Used by probe_pt to do a single Z probe.
  *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
  *
- * @param  short_move Flag for a shorter probe move towards the bed
  * @return The raw Z position where the probe was triggered
  */
-static float run_z_probe(const bool short_move=true) {
+static float run_z_probe() {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   #endif
 
   // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   gcode.refresh_cmd_timeout();
 
   #if ENABLED(PROBE_DOUBLE_TOUCH)
 
@@ -542,22 +541,22 @@ static float run_z_probe(const bool short_move=true) {
     if (zprobe_zoffset < 0) z -= zprobe_zoffset;
 
     if (z < current_position[Z_AXIS]) {
 
       // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
       if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     }
   #endif
 
-  // move down slowly to find bed
-  if (do_probe_move(-10 + (short_move ? 0 : -(Z_MAX_LENGTH)), Z_PROBE_SPEED_SLOW)) return NAN;
+  // Move down slowly to find bed, not too far
+  if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   #endif
 
   // Debug: compare probe heights
   #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
       SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
@@ -582,59 +581,47 @@ float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t
       SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
       SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
       SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
       SERIAL_ECHOLNPGM("stow)");
       DEBUG_POS("", current_position);
     }
   #endif
 
   const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
 
-  if (printable
+  if (!printable
     ? !position_is_reachable(nx, ny)
     : !position_is_reachable_by_probe(rx, ry)
   ) return NAN;
 
-
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DELTA)
     if (current_position[Z_AXIS] > delta_clip_start_height)
       do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  #if HAS_SOFTWARE_ENDSTOPS
-    // Store the status of the soft endstops and disable if we're probing a non-printable location
-    static bool enable_soft_endstops = soft_endstops_enabled;
-    if (!printable) soft_endstops_enabled = false;
-  #endif
-
   feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
 
   // Move the probe to the given XY
   do_blocking_move_to_xy(nx, ny);
 
   float measured_z = NAN;
   if (!DEPLOY_PROBE()) {
-    measured_z = run_z_probe(printable);
+    measured_z = run_z_probe();
 
     if (!stow)
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
     else
       if (STOW_PROBE()) measured_z = NAN;
   }
 
-  #if HAS_SOFTWARE_ENDSTOPS
-    // Restore the soft endstop status
-    soft_endstops_enabled = enable_soft_endstops;
-  #endif
-
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");
     SERIAL_PROTOCOL_F(measured_z, 3);
     SERIAL_EOL();
   }
 

commit f34c3597dcaef54624c82f732f13151215bbe650
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Wed Nov 8 22:10:08 2017 -0600

    Add delta_height variable in lieu of using home_offset

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index a75f1ef706..918e89e904 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -557,25 +557,21 @@ static float run_z_probe(const bool short_move=true) {
   #endif
 
   // Debug: compare probe heights
   #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
       SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
     }
   #endif
 
-  return current_position[Z_AXIS] + zprobe_zoffset
-    #if ENABLED(DELTA)
-      + home_offset[Z_AXIS] // Account for delta height adjustment
-    #endif
-  ;
+  return current_position[Z_AXIS] + zprobe_zoffset;
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
@@ -679,21 +675,21 @@ void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       if (!no_babystep && planner.leveling_active)
         thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
     #else
       UNUSED(no_babystep);
     #endif
 
     #if ENABLED(DELTA) // correct the delta_height
-      home_offset[Z_AXIS] -= diff;
+      delta_height -= diff;
     #endif
   }
 
   last_zoffset = zprobe_zoffset;
 }
 
 #if HAS_Z_SERVO_ENDSTOP
 
   void servo_probe_init() {
     /**

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9c7cc3371f..a75f1ef706 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -99,22 +99,22 @@ inline void do_probe_raise(const float z_raise) {
     // Dock sled a bit closer to ensure proper capturing
     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
 
     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
       WRITE(SOL1_PIN, !stow); // switch solenoid
     #endif
   }
 
 #elif ENABLED(Z_PROBE_ALLEN_KEY)
 
-  FORCE_INLINE void do_blocking_move_to(const float logical[XYZ], const float &fr_mm_s) {
-    do_blocking_move_to(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS], fr_mm_s);
+  FORCE_INLINE void do_blocking_move_to(const float raw[XYZ], const float &fr_mm_s) {
+    do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
   }
 
   void run_deploy_moves_script() {
     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
       #endif
@@ -557,52 +557,52 @@ static float run_z_probe(const bool short_move=true) {
   #endif
 
   // Debug: compare probe heights
   #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
       SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
     }
   #endif
 
-  return RAW_CURRENT_POSITION(Z) + zprobe_zoffset
+  return current_position[Z_AXIS] + zprobe_zoffset
     #if ENABLED(DELTA)
       + home_offset[Z_AXIS] // Account for delta height adjustment
     #endif
   ;
 }
 
 /**
  * - Move to the given XY
  * - Deploy the probe, if not already deployed
  * - Probe the bed, get the Z position
  * - Depending on the 'stow' flag
  *   - Stow the probe, or
  *   - Raise to the BETWEEN height
  * - Return the probed Z position
  */
-float probe_pt(const float &lx, const float &ly, const bool stow, const uint8_t verbose_level, const bool printable/*=true*/) {
+float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool printable/*=true*/) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> probe_pt(", lx);
-      SERIAL_ECHOPAIR(", ", ly);
+      SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
+      SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
       SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
       SERIAL_ECHOLNPGM("stow)");
       DEBUG_POS("", current_position);
     }
   #endif
 
-  const float nx = lx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ly - (Y_PROBE_OFFSET_FROM_EXTRUDER);
+  const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
 
   if (printable
-    ? !position_is_reachable_xy(nx, ny)
-    : !position_is_reachable_by_probe_xy(lx, ly)
+    ? !position_is_reachable(nx, ny)
+    : !position_is_reachable_by_probe(rx, ry)
   ) return NAN;
 
 
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DELTA)
     if (current_position[Z_AXIS] > delta_clip_start_height)
       do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
@@ -627,23 +627,23 @@ float probe_pt(const float &lx, const float &ly, const bool stow, const uint8_t
       if (STOW_PROBE()) measured_z = NAN;
   }
 
   #if HAS_SOFTWARE_ENDSTOPS
     // Restore the soft endstop status
     soft_endstops_enabled = enable_soft_endstops;
   #endif
 
   if (verbose_level > 2) {
     SERIAL_PROTOCOLPGM("Bed X: ");
-    SERIAL_PROTOCOL_F(lx, 3);
+    SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
     SERIAL_PROTOCOLPGM(" Y: ");
-    SERIAL_PROTOCOL_F(ly, 3);
+    SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
     SERIAL_PROTOCOLPGM(" Z: ");
     SERIAL_PROTOCOL_F(measured_z, 3);
     SERIAL_EOL();
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   #endif
 
   feedrate_mm_s = old_feedrate_mm_s;

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 743cefb0de..9c7cc3371f 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -672,21 +672,21 @@ void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
           for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
             z_values[x][y] -= diff;
       }
       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
         bed_level_virt_interpolate();
       #endif
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      if (!no_babystep && LEVELING_IS_ACTIVE())
+      if (!no_babystep && planner.leveling_active)
         thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
     #else
       UNUSED(no_babystep);
     #endif
 
     #if ENABLED(DELTA) // correct the delta_height
       home_offset[Z_AXIS] -= diff;
     #endif
   }
 

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 98185f6a5b..743cefb0de 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -672,21 +672,21 @@ void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
           for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
             z_values[x][y] -= diff;
       }
       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
         bed_level_virt_interpolate();
       #endif
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      if (!no_babystep && leveling_is_active())
+      if (!no_babystep && LEVELING_IS_ACTIVE())
         thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
     #else
       UNUSED(no_babystep);
     #endif
 
     #if ENABLED(DELTA) // correct the delta_height
       home_offset[Z_AXIS] -= diff;
     #endif
   }
 

commit 965b0ab53e834e7e272d2d698560f70b17c86a90
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:33:52 2017 -0500

    Spacing adjustments

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9c044b0d37..98185f6a5b 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -269,21 +269,21 @@ inline void do_probe_raise(const float z_raise) {
         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
       #endif
       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
       #endif
       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
     #endif
   }
 
-#endif
+#endif // Z_PROBE_ALLEN_KEY
 
 #if ENABLED(PROBING_FANS_OFF)
 
   void fans_pause(const bool p) {
     if (p != fans_paused) {
       fans_paused = p;
       if (p)
         for (uint8_t x = 0; x < FAN_COUNT; x++) {
           paused_fanSpeeds[x] = fanSpeeds[x];
           fanSpeeds[x] = 0;

commit ddbd4b73e081e1c47383cffdd8a9425369d9a1c8
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Tue Sep 19 19:25:59 2017 -0500

    Move LPC1768 framework out of Marlin source folder

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
index 9689a90755..9c044b0d37 100644
--- a/Marlin/src/module/probe.cpp
+++ b/Marlin/src/module/probe.cpp
@@ -39,20 +39,24 @@
 #include "../Marlin.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(DELTA)
   #include "../module/delta.h"
 #endif
 
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "planner.h"
+#endif
+
 float zprobe_zoffset; // Initialized by settings.load()
 
 #if HAS_Z_SERVO_ENDSTOP
   const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
 /**
  * Raise Z to a minimum height to make room for a probe to move
  */
 inline void do_probe_raise(const float z_raise) {

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/probe.cpp b/Marlin/src/module/probe.cpp
new file mode 100644
index 0000000000..9689a90755
--- /dev/null
+++ b/Marlin/src/module/probe.cpp
@@ -0,0 +1,709 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * probe.cpp
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#if HAS_BED_PROBE
+
+#include "probe.h"
+#include "motion.h"
+#include "temperature.h"
+#include "endstops.h"
+
+#include "../gcode/gcode.h"
+#include "../lcd/ultralcd.h"
+
+#include "../Marlin.h"
+
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
+#if ENABLED(DELTA)
+  #include "../module/delta.h"
+#endif
+
+float zprobe_zoffset; // Initialized by settings.load()
+
+#if HAS_Z_SERVO_ENDSTOP
+  const int z_servo_angle[2] = Z_SERVO_ANGLES;
+#endif
+
+/**
+ * Raise Z to a minimum height to make room for a probe to move
+ */
+inline void do_probe_raise(const float z_raise) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  float z_dest = z_raise;
+  if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
+
+  if (z_dest > current_position[Z_AXIS])
+    do_blocking_move_to_z(z_dest);
+}
+
+#if ENABLED(Z_PROBE_SLED)
+
+  #ifndef SLED_DOCKING_OFFSET
+    #define SLED_DOCKING_OFFSET 0
+  #endif
+
+  /**
+   * Method to dock/undock a sled designed by Charles Bell.
+   *
+   * stow[in]     If false, move to MAX_X and engage the solenoid
+   *              If true, move to MAX_X and release the solenoid
+   */
+  static void dock_sled(bool stow) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("dock_sled(", stow);
+        SERIAL_CHAR(')');
+        SERIAL_EOL();
+      }
+    #endif
+
+    // Dock sled a bit closer to ensure proper capturing
+    do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
+
+    #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
+      WRITE(SOL1_PIN, !stow); // switch solenoid
+    #endif
+  }
+
+#elif ENABLED(Z_PROBE_ALLEN_KEY)
+
+  FORCE_INLINE void do_blocking_move_to(const float logical[XYZ], const float &fr_mm_s) {
+    do_blocking_move_to(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS], fr_mm_s);
+  }
+
+  void run_deploy_moves_script() {
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
+      #endif
+      const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
+      do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
+      #endif
+      const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
+      do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
+      #endif
+      const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
+      do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
+      #endif
+      const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
+      do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
+      #endif
+      const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
+      do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
+    #endif
+  }
+
+  void run_stow_moves_script() {
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
+        #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
+      #endif
+      const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
+      do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
+        #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
+      #endif
+      const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
+      do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
+        #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
+      #endif
+      const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
+      do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
+        #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
+      #endif
+      const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
+      do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
+        #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
+      #endif
+      const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
+      do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
+    #endif
+  }
+
+#endif
+
+#if ENABLED(PROBING_FANS_OFF)
+
+  void fans_pause(const bool p) {
+    if (p != fans_paused) {
+      fans_paused = p;
+      if (p)
+        for (uint8_t x = 0; x < FAN_COUNT; x++) {
+          paused_fanSpeeds[x] = fanSpeeds[x];
+          fanSpeeds[x] = 0;
+        }
+      else
+        for (uint8_t x = 0; x < FAN_COUNT; x++)
+          fanSpeeds[x] = paused_fanSpeeds[x];
+    }
+  }
+
+#endif // PROBING_FANS_OFF
+
+#if QUIET_PROBING
+  void probing_pause(const bool p) {
+    #if ENABLED(PROBING_HEATERS_OFF)
+      thermalManager.pause(p);
+    #endif
+    #if ENABLED(PROBING_FANS_OFF)
+      fans_pause(p);
+    #endif
+    if (p) safe_delay(
+      #if DELAY_BEFORE_PROBING > 25
+        DELAY_BEFORE_PROBING
+      #else
+        25
+      #endif
+    );
+  }
+#endif // QUIET_PROBING
+
+#if ENABLED(BLTOUCH)
+
+  void bltouch_command(const int angle) {
+    MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
+    safe_delay(BLTOUCH_DELAY);
+  }
+
+  bool set_bltouch_deployed(const bool deploy) {
+    if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
+      bltouch_command(BLTOUCH_RESET);    //  try to reset it.
+      bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
+      bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
+      safe_delay(1500);                  // Wait for internal self-test to complete.
+                                         //  (Measured completion time was 0.65 seconds
+                                         //   after reset, deploy, and stow sequence)
+      if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
+        SERIAL_ERROR_START();
+        SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
+        stop();                          // punt!
+        return true;
+      }
+    }
+
+    bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
+        SERIAL_CHAR(')');
+        SERIAL_EOL();
+      }
+    #endif
+
+    return false;
+  }
+
+#endif // BLTOUCH
+
+// returns false for ok and true for failure
+bool set_probe_deployed(const bool deploy) {
+
+  // Can be extended to servo probes, if needed.
+  #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
+    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
+    #else
+      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+    #endif
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_POS("set_probe_deployed", current_position);
+      SERIAL_ECHOLNPAIR("deploy: ", deploy);
+    }
+  #endif
+
+  if (endstops.z_probe_enabled == deploy) return false;
+
+  // Make room for probe
+  do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
+
+  #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+    #if ENABLED(Z_PROBE_SLED)
+      #define _AUE_ARGS true, false, false
+    #else
+      #define _AUE_ARGS
+    #endif
+    if (axis_unhomed_error(_AUE_ARGS)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
+      stop();
+      return true;
+    }
+  #endif
+
+  const float oldXpos = current_position[X_AXIS],
+              oldYpos = current_position[Y_AXIS];
+
+  #ifdef _TRIGGERED_WHEN_STOWED_TEST
+
+    // If endstop is already false, the Z probe is deployed
+    if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
+                                                     // Would a goto be less ugly?
+      //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
+                                                     // for a triggered when stowed manual probe.
+
+      if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
+                                                   // otherwise an Allen-Key probe can't be stowed.
+  #endif
+
+      #if ENABLED(SOLENOID_PROBE)
+
+        #if HAS_SOLENOID_1
+          WRITE(SOL1_PIN, deploy);
+        #endif
+
+      #elif ENABLED(Z_PROBE_SLED)
+
+        dock_sled(!deploy);
+
+      #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
+
+        MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
+
+      #elif ENABLED(Z_PROBE_ALLEN_KEY)
+
+        deploy ? run_deploy_moves_script() : run_stow_moves_script();
+
+      #endif
+
+  #ifdef _TRIGGERED_WHEN_STOWED_TEST
+    } // _TRIGGERED_WHEN_STOWED_TEST == deploy
+
+    if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
+
+      if (IsRunning()) {
+        SERIAL_ERROR_START();
+        SERIAL_ERRORLNPGM("Z-Probe failed");
+        LCD_ALERTMESSAGEPGM("Err: ZPROBE");
+      }
+      stop();
+      return true;
+
+    } // _TRIGGERED_WHEN_STOWED_TEST == deploy
+
+  #endif
+
+  do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
+  endstops.enable_z_probe(deploy);
+  return false;
+}
+
+/**
+ * @brief Used by run_z_probe to do a single Z probe move.
+ *
+ * @param  z        Z destination
+ * @param  fr_mm_s  Feedrate in mm/s
+ * @return true to indicate an error
+ */
+static bool do_probe_move(const float z, const float fr_mm_m) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
+  #endif
+
+  // Deploy BLTouch at the start of any probe
+  #if ENABLED(BLTOUCH)
+    if (set_bltouch_deployed(true)) return true;
+  #endif
+
+  #if QUIET_PROBING
+    probing_pause(true);
+  #endif
+
+  // Move down until probe triggered
+  do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
+
+  // Check to see if the probe was triggered
+  const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
+    #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+      Z_MIN
+    #else
+      Z_MIN_PROBE
+    #endif
+  );
+
+  #if QUIET_PROBING
+    probing_pause(false);
+  #endif
+
+  // Retract BLTouch immediately after a probe if it was triggered
+  #if ENABLED(BLTOUCH)
+    if (probe_triggered && set_bltouch_deployed(false)) return true;
+  #endif
+
+  // Clear endstop flags
+  endstops.hit_on_purpose();
+
+  // Get Z where the steppers were interrupted
+  set_current_from_steppers_for_axis(Z_AXIS);
+
+  // Tell the planner where we actually are
+  SYNC_PLAN_POSITION_KINEMATIC();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
+  #endif
+
+  return !probe_triggered;
+}
+
+/**
+ * @details Used by probe_pt to do a single Z probe.
+ *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
+ *
+ * @param  short_move Flag for a shorter probe move towards the bed
+ * @return The raw Z position where the probe was triggered
+ */
+static float run_z_probe(const bool short_move=true) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
+  #endif
+
+  // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
+  gcode.refresh_cmd_timeout();
+
+  #if ENABLED(PROBE_DOUBLE_TOUCH)
+
+    // Do a first probe at the fast speed
+    if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      float first_probe_z = current_position[Z_AXIS];
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
+    #endif
+
+    // move up to make clearance for the probe
+    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+
+  #else
+
+    // If the nozzle is above the travel height then
+    // move down quickly before doing the slow probe
+    float z = Z_CLEARANCE_DEPLOY_PROBE;
+    if (zprobe_zoffset < 0) z -= zprobe_zoffset;
+
+    if (z < current_position[Z_AXIS]) {
+
+      // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
+      if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
+        do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    }
+  #endif
+
+  // move down slowly to find bed
+  if (do_probe_move(-10 + (short_move ? 0 : -(Z_MAX_LENGTH)), Z_PROBE_SPEED_SLOW)) return NAN;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
+  #endif
+
+  // Debug: compare probe heights
+  #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
+      SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
+    }
+  #endif
+
+  return RAW_CURRENT_POSITION(Z) + zprobe_zoffset
+    #if ENABLED(DELTA)
+      + home_offset[Z_AXIS] // Account for delta height adjustment
+    #endif
+  ;
+}
+
+/**
+ * - Move to the given XY
+ * - Deploy the probe, if not already deployed
+ * - Probe the bed, get the Z position
+ * - Depending on the 'stow' flag
+ *   - Stow the probe, or
+ *   - Raise to the BETWEEN height
+ * - Return the probed Z position
+ */
+float probe_pt(const float &lx, const float &ly, const bool stow, const uint8_t verbose_level, const bool printable/*=true*/) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> probe_pt(", lx);
+      SERIAL_ECHOPAIR(", ", ly);
+      SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
+      SERIAL_ECHOLNPGM("stow)");
+      DEBUG_POS("", current_position);
+    }
+  #endif
+
+  const float nx = lx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ly - (Y_PROBE_OFFSET_FROM_EXTRUDER);
+
+  if (printable
+    ? !position_is_reachable_xy(nx, ny)
+    : !position_is_reachable_by_probe_xy(lx, ly)
+  ) return NAN;
+
+
+  const float old_feedrate_mm_s = feedrate_mm_s;
+
+  #if ENABLED(DELTA)
+    if (current_position[Z_AXIS] > delta_clip_start_height)
+      do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+
+  #if HAS_SOFTWARE_ENDSTOPS
+    // Store the status of the soft endstops and disable if we're probing a non-printable location
+    static bool enable_soft_endstops = soft_endstops_enabled;
+    if (!printable) soft_endstops_enabled = false;
+  #endif
+
+  feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
+
+  // Move the probe to the given XY
+  do_blocking_move_to_xy(nx, ny);
+
+  float measured_z = NAN;
+  if (!DEPLOY_PROBE()) {
+    measured_z = run_z_probe(printable);
+
+    if (!stow)
+      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+    else
+      if (STOW_PROBE()) measured_z = NAN;
+  }
+
+  #if HAS_SOFTWARE_ENDSTOPS
+    // Restore the soft endstop status
+    soft_endstops_enabled = enable_soft_endstops;
+  #endif
+
+  if (verbose_level > 2) {
+    SERIAL_PROTOCOLPGM("Bed X: ");
+    SERIAL_PROTOCOL_F(lx, 3);
+    SERIAL_PROTOCOLPGM(" Y: ");
+    SERIAL_PROTOCOL_F(ly, 3);
+    SERIAL_PROTOCOLPGM(" Z: ");
+    SERIAL_PROTOCOL_F(measured_z, 3);
+    SERIAL_EOL();
+  }
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
+  #endif
+
+  feedrate_mm_s = old_feedrate_mm_s;
+
+  if (isnan(measured_z)) {
+    LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
+  }
+
+  return measured_z;
+}
+
+void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
+  static float last_zoffset = NAN;
+
+  if (!isnan(last_zoffset)) {
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
+      const float diff = zprobe_zoffset - last_zoffset;
+    #endif
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      // Correct bilinear grid for new probe offset
+      if (diff) {
+        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+          for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+            z_values[x][y] -= diff;
+      }
+      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+        bed_level_virt_interpolate();
+      #endif
+    #endif
+
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      if (!no_babystep && leveling_is_active())
+        thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
+    #else
+      UNUSED(no_babystep);
+    #endif
+
+    #if ENABLED(DELTA) // correct the delta_height
+      home_offset[Z_AXIS] -= diff;
+    #endif
+  }
+
+  last_zoffset = zprobe_zoffset;
+}
+
+#if HAS_Z_SERVO_ENDSTOP
+
+  void servo_probe_init() {
+    /**
+     * Set position of Z Servo Endstop
+     *
+     * The servo might be deployed and positioned too low to stow
+     * when starting up the machine or rebooting the board.
+     * There's no way to know where the nozzle is positioned until
+     * homing has been done - no homing with z-probe without init!
+     *
+     */
+    STOW_Z_SERVO();
+  }
+
+#endif // HAS_Z_SERVO_ENDSTOP
+
+#endif // HAS_BED_PROBE
