commit 4aff10785ee96a35eb4777c08b81722a59cecf68
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 18:46:38 2024 -0500

    üßë‚Äçüíª Use "enum class"

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 473d54cc38..4bbb182bc3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -250,21 +250,21 @@ void report_current_position() {
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
 #if ENABLED(AUTO_REPORT_POSITION)
   AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
-#if ANY(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+#if ENABLED(REALTIME_REPORTING_COMMANDS)
 
   M_StateEnum M_State_grbl = M_INIT;
 
   /**
    * Output the current grbl compatible state to serial while moving
    */
   void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
@@ -292,32 +292,32 @@ void report_current_position_projected() {
 
     report_more_positions();
     report_current_grblstate_moving();
   }
 
   /**
    * Set a Grbl-compatible state from the current marlin_state
    */
   M_StateEnum grbl_state_for_marlin_state() {
     switch (marlin_state) {
-      case MF_INITIALIZING: return M_INIT;
-      case MF_SD_COMPLETE:  return M_ALARM;
-      case MF_WAITING:      return M_IDLE;
-      case MF_STOPPED:      return M_END;
-      case MF_RUNNING:      return M_RUNNING;
-      case MF_PAUSED:       return M_HOLD;
-      case MF_KILLED:       return M_ERROR;
-      default:              return M_IDLE;
+      case MarlinState::MF_INITIALIZING: return M_INIT;
+      case MarlinState::MF_SD_COMPLETE:  return M_ALARM;
+      case MarlinState::MF_WAITING:      return M_IDLE;
+      case MarlinState::MF_STOPPED:      return M_END;
+      case MarlinState::MF_RUNNING:      return M_RUNNING;
+      case MarlinState::MF_PAUSED:       return M_HOLD;
+      case MarlinState::MF_KILLED:       return M_ERROR;
+      default:                           return M_IDLE;
     }
   }
 
-#endif
+#endif // REALTIME_REPORTING_COMMANDS
 
 #if IS_KINEMATIC
 
   bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset/*=0*/) {
 
     bool can_reach;
 
     #if ENABLED(DELTA)
 
       can_reach = HYPOT2(rx, ry) <= sq(PRINTABLE_RADIUS - inset + fslop);

commit eec1aec071df9ef2a78d577d0f6b4ed76cb6c6ff
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 19 18:43:04 2024 -0500

    üêõ Fix multi-byte menu string buffer overrun (#27100)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 26181d8396..473d54cc38 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1630,22 +1630,21 @@ void prepare_line_to_destination() {
     char all_axes[] = STR_AXES_MAIN, need[NUM_AXES + 1];
     uint8_t n = 0;
     LOOP_NUM_AXES(i) if (TEST(axis_bits, i)) need[n++] = all_axes[i];
     need[n] = '\0';
 
     SString<30> msg;
     msg.setf(GET_EN_TEXT_F(MSG_HOME_FIRST), need);
     SERIAL_ECHO_START();
     msg.echoln();
 
-    msg.setf(GET_TEXT_F(MSG_HOME_FIRST), need);
-    ui.set_status(msg);
+    ui.status_printf(0, GET_TEXT_F(MSG_HOME_FIRST), need);
     return true;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #if HOMING_Z_WITH_PROBE
       if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW);
     #endif

commit bdc14ddbd7860586af25a71abfd134f793b1954f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Thu May 16 18:18:41 2024 -0700

    ‚è™Ô∏è Revert DELTA Z endstop homing patch (#27088)
    
    Reverts #26297 f7a3172c20

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cb0c1bf5d8..26181d8396 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -885,21 +885,21 @@ void restore_feedrate_and_scaling() {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop.min[axis] = base_min_pos(axis);
-      soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(USE_PROBE_FOR_Z_HOMING, delta_height, probe.offset.z) : base_home_pos(axis);
+      soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_max_pos(axis);
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
           refresh_delta_clip_start_height();
@@ -2460,21 +2460,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = SUM_TERN(HAS_HOME_OFFSET, x_home_pos(active_extruder), home_offset.x);
       return;
     }
   #endif
 
   #if ANY(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(USE_PROBE_FOR_Z_HOMING, delta_height, probe.offset.z) : base_home_pos(axis);
+    current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = SUM_TERN(HAS_HOME_OFFSET, base_home_pos(axis), home_offset[axis]);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE

commit 3dc437add4d142b71ea0684848fc1b73e4245a4c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu May 16 08:42:19 2024 +1200

    üé® Apply TERN0/1 for some contexts (#27036)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dddcd81d6c..cb0c1bf5d8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2179,21 +2179,21 @@ void prepare_line_to_destination() {
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     // If a second homing move is configured...
     if (bump) {
       #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
       #endif
 
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
-      do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
+      do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0)), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
 
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           #define _ESCASE(A) case A##_AXIS: es = A##_ENDSTOP; break;
           MAIN_AXIS_MAP(_ESCASE)
           default: break;
         }

commit 5f96dffb9b50baf1e730c21405a573ad45b45e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 15 15:21:39 2024 -0500

    üßë‚Äçüíª FLOAT_SQ macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3d93e1e9d9..dddcd81d6c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -321,31 +321,31 @@ void report_current_position_projected() {
     #if ENABLED(DELTA)
 
       can_reach = HYPOT2(rx, ry) <= sq(PRINTABLE_RADIUS - inset + fslop);
 
     #elif ENABLED(AXEL_TPARA)
 
       const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
       can_reach = (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
-          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+          && R2 >= FLOAT_SQ(MIDDLE_DEAD_ZONE_R)
         #endif
       );
 
     #elif IS_SCARA
 
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       can_reach = (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
-          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+          && R2 >= FLOAT_SQ(MIDDLE_DEAD_ZONE_R)
         #endif
       );
 
     #elif ENABLED(POLARGRAPH)
 
       const float d1 = rx - (draw_area_min.x),
                   d2 = (draw_area_max.x) - rx,
                    y = ry - (draw_area_max.y),
                    a = HYPOT(d1, y),
                    b = HYPOT(d2, y);

commit f5f6c37c17edd6e710bc48578aa325f317d47d51
Author: Alexander Thomas Julian <ajulian@hawk.iit.edu>
Date:   Sun May 12 13:25:14 2024 -0500

    üêõ LCD Bed Tramming fixes (#26962)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e4e419dd76..3d93e1e9d9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -707,36 +707,48 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_z(", rz, ", ", fr_mm_s, ")");
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w)
       fr_mm_s
     );
   }
+  /**
+   * Move Z to a particular height so the nozzle or deployed probe clears the bed.
+   * (Use do_z_clearance_by for clearance over the current position.)
+   *  - For a probe, add clearance for the probe distance
+   *  - Constrain to the Z max physical position
+   *  - If lowering is not allowed then skip a downward move
+   *  - Execute the move at the probing (or homing) feedrate
+   */
   void do_z_clearance(const_float_t zclear, const bool with_probe/*=true*/, const bool lower_allowed/*=false*/) {
     UNUSED(with_probe);
     float zdest = zclear;
     TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
     NOMORE(zdest, Z_MAX_POS);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
     if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
     do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
   void do_z_clearance_by(const_float_t zclear) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
     do_z_clearance(current_position.z + zclear, false);
   }
+  /**
+   * Move Z to Z_POST_CLEARANCE,
+   * The axis is allowed to move down.
+   */
   void do_move_after_z_homing() {
     DEBUG_SECTION(mzah, "do_move_after_z_homing", DEBUGGING(LEVELING));
-    #if defined(Z_AFTER_HOMING) || ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+    #ifdef Z_POST_CLEARANCE
       do_z_clearance(Z_POST_CLEARANCE, true, true);
     #elif ENABLED(USE_PROBE_FOR_Z_HOMING)
       probe.move_z_after_probing();
     #endif
   }
 #endif
 
 #if HAS_I_AXIS
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(

commit 7b6b6e1c3e294f5d8785f7e14fe05b4fedb6ea08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 1 21:44:18 2024 -0500

    ü©π Revert motion change

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c5e45899a1..e4e419dd76 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -722,28 +722,25 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
     if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
     do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
   void do_z_clearance_by(const_float_t zclear) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
     do_z_clearance(current_position.z + zclear, false);
   }
   void do_move_after_z_homing() {
     DEBUG_SECTION(mzah, "do_move_after_z_homing", DEBUGGING(LEVELING));
-    float zpos = 0;
-    #ifdef Z_POST_CLEARANCE // (is always defined)
-      NOLESS(zpos, Z_POST_CLEARANCE);
+    #if defined(Z_AFTER_HOMING) || ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+      do_z_clearance(Z_POST_CLEARANCE, true, true);
+    #elif ENABLED(USE_PROBE_FOR_Z_HOMING)
+      probe.move_z_after_probing();
     #endif
-    #if ENABLED(USE_PROBE_FOR_Z_HOMING)
-      NOLESS(zpos, Z_AFTER_PROBING);
-    #endif
-    if (zpos) do_z_clearance(zpos, true, true);
   }
 #endif
 
 #if HAS_I_AXIS
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, i, raw.j, raw.k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c86c382ddc..c5e45899a1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -682,143 +682,140 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_y(", ry, ", ", fr_mm_s, ")");
     do_blocking_move_to(
       NUM_AXIS_LIST_(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_xy(", rx, ", ", ry, ", ", fr_mm_s, ")");
+    do_blocking_move_to(
+      NUM_AXIS_LIST_(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w)
+      fr_mm_s
+    );
+  }
+  void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
+  }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_z(", rz, ", ", fr_mm_s, ")");
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
+  void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(
+      NUM_AXIS_LIST_(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w)
+      fr_mm_s
+    );
+  }
+  void do_z_clearance(const_float_t zclear, const bool with_probe/*=true*/, const bool lower_allowed/*=false*/) {
+    UNUSED(with_probe);
+    float zdest = zclear;
+    TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
+    NOMORE(zdest, Z_MAX_POS);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
+    if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
+    do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
+  }
+  void do_z_clearance_by(const_float_t zclear) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
+    do_z_clearance(current_position.z + zclear, false);
+  }
+  void do_move_after_z_homing() {
+    DEBUG_SECTION(mzah, "do_move_after_z_homing", DEBUGGING(LEVELING));
+    float zpos = 0;
+    #ifdef Z_POST_CLEARANCE // (is always defined)
+      NOLESS(zpos, Z_POST_CLEARANCE);
+    #endif
+    #if ENABLED(USE_PROBE_FOR_Z_HOMING)
+      NOLESS(zpos, Z_AFTER_PROBING);
+    #endif
+    if (zpos) do_z_clearance(zpos, true, true);
+  }
 #endif
 
 #if HAS_I_AXIS
-  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
-  }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, i, raw.j, raw.k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
+  }
 #endif
 
 #if HAS_J_AXIS
-  void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
-  }
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, j, raw.k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
+  }
 #endif
 
 #if HAS_K_AXIS
-  void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
-  }
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
+  }
 #endif
 
 #if HAS_U_AXIS
-  void do_blocking_move_to_u(const_float_t ru, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyzijk_u(current_position, ru, fr_mm_s);
-  }
   void do_blocking_move_to_xyzijk_u(const xyze_pos_t &raw, const_float_t u, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, u, raw.v, raw.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_u(const_float_t ru, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijk_u(current_position, ru, fr_mm_s);
+  }
 #endif
 
 #if HAS_V_AXIS
-  void do_blocking_move_to_v(const_float_t rv, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyzijku_v(current_position, rv, fr_mm_s);
-  }
   void do_blocking_move_to_xyzijku_v(const xyze_pos_t &raw, const_float_t v, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, v, raw.w)
       fr_mm_s
     );
   }
+  void do_blocking_move_to_v(const_float_t rv, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijku_v(current_position, rv, fr_mm_s);
+  }
 #endif
 
 #if HAS_W_AXIS
-  void do_blocking_move_to_w(const_float_t rw, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyzijkuv_w(current_position, rw, fr_mm_s);
-  }
   void do_blocking_move_to_xyzijkuv_w(const xyze_pos_t &raw, const_float_t w, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, raw.v, w)
       fr_mm_s
     );
   }
-#endif
-
-#if HAS_Y_AXIS
-  void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_xy(", rx, ", ", ry, ", ", fr_mm_s, ")");
-    do_blocking_move_to(
-      NUM_AXIS_LIST_(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
-                    current_position.u, current_position.v, current_position.w)
-      fr_mm_s
-    );
-  }
-  void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-    do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
-  }
-#endif
-
-#if HAS_Z_AXIS
-  void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
-    do_blocking_move_to(
-      NUM_AXIS_LIST_(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
-                    current_position.u, current_position.v, current_position.w)
-      fr_mm_s
-    );
-  }
-  void do_z_clearance(const_float_t zclear, const bool with_probe/*=true*/, const bool lower_allowed/*=false*/) {
-    UNUSED(with_probe);
-    float zdest = zclear;
-    TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
-    NOMORE(zdest, Z_MAX_POS);
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
-    if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
-    do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
-  }
-  void do_z_clearance_by(const_float_t zclear) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
-    do_z_clearance(current_position.z + zclear, false);
-  }
-  void do_move_after_z_homing() {
-    DEBUG_SECTION(mzah, "do_move_after_z_homing", DEBUGGING(LEVELING));
-    #if defined(Z_AFTER_HOMING) || ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-      do_z_clearance(Z_POST_CLEARANCE, true, true);
-    #elif ENABLED(USE_PROBE_FOR_Z_HOMING)
-      probe.move_z_after_probing();
-    #endif
+  void do_blocking_move_to_w(const_float_t rw, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijkuv_w(current_position, rw, fr_mm_s);
   }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_scaling_off() {

commit c0264ae7871ca53de4ea8a24925d5f4f676115ec
Author: janenen <janenen@users.noreply.github.com>
Date:   Sat Mar 16 20:52:14 2024 +0100

    üêõ Fix DETECT_BROKEN_ENDSTOP on IDEX (#26790)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 862f0c5754..c86c382ddc 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2176,32 +2176,42 @@ void prepare_line_to_destination() {
     if (bump) {
       #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
       #endif
 
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
+
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           #define _ESCASE(A) case A##_AXIS: es = A##_ENDSTOP; break;
           MAIN_AXIS_MAP(_ESCASE)
           default: break;
         }
+
+        #if ENABLED(DUAL_X_CARRIAGE)
+          if (axis == X_AXIS && axis_home_dir > 0) {
+            es = X_MAX;
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("DUAL_X_CARRIAGE: Homing to X_MAX");
+          }
+        #endif
+
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", C(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
-      #endif
+
+      #endif // DETECT_BROKEN_ENDSTOP
 
       #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
       do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);

commit c8d51c27234bcb2b1419d238e8751593d855dadb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Mar 2 04:16:39 2024 +0100

    üö∏ Enable G92.9 with rotational axes (#26174)
    
    - Supporting axes that can rotate forever.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c6b0936447..862f0c5754 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1146,24 +1146,27 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
               IF_DISABLED(AXIS7_ROTATES, + sq(diff.u)),
               IF_DISABLED(AXIS8_ROTATES, + sq(diff.v)),
               IF_DISABLED(AXIS9_ROTATES, + sq(diff.w))
             )
           );
         }
       #endif
 
       #if HAS_ROTATIONAL_AXES
         if (UNEAR_ZERO(distance_sqr)) {
-          // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
-          is_cartesian_move = false;
+          // Move involves no linear axes. Calculate angular distance in accordance with LinuxCNC
           distance_sqr = ROTATIONAL_AXIS_GANG(sq(diff.i), + sq(diff.j), + sq(diff.k), + sq(diff.u), + sq(diff.v), + sq(diff.w));
         }
+        if (!UNEAR_ZERO(distance_sqr)) {
+          // Move involves rotational axes, not just the extruder
+          is_cartesian_move = false;
+        }
       #endif
 
     #endif
 
     return SQRT(distance_sqr);
 
   #else
 
     return 0;
 

commit 5639237e2b174715413f9ffc6f6421db9150d9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 29 20:38:03 2024 -0600

    üé® Misc. cleanup 29-01

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b76f11b984..c6b0936447 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -373,21 +373,20 @@ void report_current_position_projected() {
       else
         return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
       if (TERN0(HAS_X_AXIS, !COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop))) return false;
       return true;
     #endif
   }
 
 #endif // CARTESIAN
 
-
 void home_if_needed(const bool keeplev/*=false*/) {
   if (!all_axes_trusted()) gcode.home_all_axes(keeplev);
 }
 
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();

commit 3ef192e7c7b18804ec7e3964a1366bd08355dc93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 23 16:05:41 2024 -0600

    üé® Cosmetic cleanup 23-01

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5fe1b3b741..b76f11b984 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1311,22 +1311,23 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
         return;
       }
 
       // Get the linear distance in XYZ
       #if HAS_ROTATIONAL_AXES
         bool cartes_move = true;
       #endif
       float cartesian_mm = get_move_distance(diff OPTARG(HAS_ROTATIONAL_AXES, cartes_move));
 
       // If the move is very short, check the E move distance
-      // No E move either? Game over.
       TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
+
+      // No E move either? Game over.
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments);
       const xyze_float_t segment_distance = diff * inv_segments;

commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8908c2fa73..5fe1b3b741 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -66,21 +66,20 @@
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-
 #if ENABLED(BD_SENSOR)
   #include "../feature/bedlevel/bdl/bdl.h"
 #endif
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    üßë‚Äçüíª AS_CHAR => C (#26569)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2259eedf41..8908c2fa73 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -920,21 +920,21 @@ void restore_feedrate_and_scaling() {
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
     if (DEBUGGING(LEVELING))
-      SERIAL_ECHOLNPGM("Axis ", AS_CHAR(AXIS_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+      SERIAL_ECHOLNPGM("Axis ", C(AXIS_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
   }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
@@ -1844,21 +1844,21 @@ void prepare_line_to_destination() {
 
   /**
    * Home an individual linear axis
    */
   void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
     DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
     const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPGM("...(", AS_CHAR(AXIS_CHAR(axis)), ", ", distance, ", ");
+      DEBUG_ECHOPGM("...(", C(AXIS_CHAR(axis)), ", ", distance, ", ");
       if (fr_mm_s)
         DEBUG_ECHO(fr_mm_s);
       else
         DEBUG_ECHOPGM("[", home_fr_mm_s, "]");
       DEBUG_ECHOLNPGM(")");
     }
 
     // Only do some things when moving towards an endstop
     const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                   ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
@@ -1934,26 +1934,26 @@ void prepare_line_to_destination() {
       #endif
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_never_homed(", C(AXIS_CHAR(axis)), ")");
 
     set_axis_untrusted(axis);
     set_axis_unhomed(axis);
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< set_axis_never_homed(", C(AXIS_CHAR(axis)), ")");
 
     TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
   }
 
   #ifdef TMC_HOME_PHASE
     /**
      * Move the axis back to its home_phase if set and driver is capable (TMC)
      *
      * Improves homing repeatability by homing to stepper coil's nearest absolute
      * phase position. Trinamic drivers use a stepper phase table with 1024 values
@@ -2048,32 +2048,32 @@ void prepare_line_to_destination() {
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.mm_per_step[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPGM("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
-                         ". Pick a different phase for ", AS_CHAR(AXIS_CHAR(axis)));
+                         ". Pick a different phase for ", C(AXIS_CHAR(axis)));
 
       // Skip to next if target position is behind current. So it only moves away from endstop.
       if (phaseDelta < 0) phaseDelta += 1024;
 
       // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
       const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.mm_per_step[axis];
 
       // Optional debug messages
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM(
-          "Endstop ", AS_CHAR(AXIS_CHAR(axis)), " hit at Phase:", phaseCurrent,
+          "Endstop ", C(AXIS_CHAR(axis)), " hit at Phase:", phaseCurrent,
           " Delta:", phaseDelta, " Distance:", mmDelta
         );
       }
 
       if (mmDelta != 0) {
         // Retrace by the amount computed in mmDelta.
         do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
       }
     }
   #endif
@@ -2093,21 +2093,21 @@ void prepare_line_to_destination() {
 
     #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_STATE) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", C(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
       return;
 
@@ -2182,21 +2182,21 @@ void prepare_line_to_destination() {
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           #define _ESCASE(A) case A##_AXIS: es = A##_ENDSTOP; break;
           MAIN_AXIS_MAP(_ESCASE)
           default: break;
         }
         if (TEST(endstops.state(), es)) {
-          SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
+          SERIAL_ECHO_MSG("Bad ", C(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
@@ -2402,21 +2402,21 @@ void prepare_line_to_destination() {
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< homeaxis(", C(AXIS_CHAR(axis)), ")");
 
   } // homeaxis()
 
 #endif // HAS_ENDSTOPS
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
@@ -2427,21 +2427,21 @@ void prepare_line_to_destination() {
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_is_at_home(", C(AXIS_CHAR(axis)), ")");
 
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = SUM_TERN(HAS_HOME_OFFSET, x_home_pos(active_extruder), home_offset.x);
       return;
     }
   #endif
@@ -2474,24 +2474,24 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   TERN_(HAS_WORKSPACE_OFFSET, workspace_offset[axis] = 0);
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
-      DEBUG_ECHOLNPGM("> home_offset[", AS_CHAR(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
+      DEBUG_ECHOLNPGM("> home_offset[", C(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
-    DEBUG_ECHOLNPGM("<<< set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    DEBUG_ECHOLNPGM("<<< set_axis_is_at_home(", C(AXIS_CHAR(axis)), ")");
   }
 }
 
 #if HAS_HOME_OFFSET
   /**
    * Set the home offset for an axis.
    */
   void set_home_offset(const AxisEnum axis, const_float_t v) {
     home_offset[axis] = v;
   }

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    üêõ‚ö°Ô∏è FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 74ba41ccf6..2259eedf41 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -26,24 +26,20 @@
 
 #include "motion.h"
 #include "endstops.h"
 #include "stepper.h"
 #include "planner.h"
 #include "temperature.h"
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(FT_MOTION)
-  #include "ft_motion.h"
-#endif
-
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 #if HAS_BED_PROBE
@@ -2088,35 +2084,20 @@ void prepare_line_to_destination() {
    * to the individual ABC steppers on DELTA and SCARA.
    *
    * At the end of the procedure the axis is marked as
    * homed and the current position of that axis is updated.
    * Kinematic robots should wait till all axes are homed
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
-    #if ENABLED(FT_MOTION)
-      // Disable ft-motion for homing
-      struct OnExit {
-        ftMotionMode_t oldmm;
-        OnExit() {
-          oldmm = ftMotion.cfg.mode;
-          ftMotion.cfg.mode = ftMotionMode_DISABLED;
-        }
-        ~OnExit() {
-          ftMotion.cfg.mode = oldmm;
-          ftMotion.init();
-        }
-      } on_exit;
-    #endif
-
     #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_STATE) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d091e67e04..74ba41ccf6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2093,26 +2093,26 @@ void prepare_line_to_destination() {
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
     #if ENABLED(FT_MOTION)
       // Disable ft-motion for homing
       struct OnExit {
         ftMotionMode_t oldmm;
         OnExit() {
-          oldmm = fxdTiCtrl.cfg.mode;
-          fxdTiCtrl.cfg.mode = ftMotionMode_DISABLED;
+          oldmm = ftMotion.cfg.mode;
+          ftMotion.cfg.mode = ftMotionMode_DISABLED;
         }
         ~OnExit() {
-          fxdTiCtrl.cfg.mode = oldmm;
-          fxdTiCtrl.init();
+          ftMotion.cfg.mode = oldmm;
+          ftMotion.init();
         }
       } on_exit;
     #endif
 
     #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_STATE) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)

commit f7a3172c20cfed3178ab9ab099ff386f61560ad9
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Fri Oct 6 23:53:52 2023 -0500

    üêõ Fix DELTA Z when not using probe for homing (#26297)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 272b16c9ac..d091e67e04 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -885,21 +885,21 @@ void restore_feedrate_and_scaling() {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop.min[axis] = base_min_pos(axis);
-      soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_max_pos(axis);
+      soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(USE_PROBE_FOR_Z_HOMING, delta_height, probe.offset.z) : base_home_pos(axis);
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
           refresh_delta_clip_start_height();
@@ -2461,21 +2461,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = SUM_TERN(HAS_HOME_OFFSET, x_home_pos(active_extruder), home_offset.x);
       return;
     }
   #endif
 
   #if ANY(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
+    current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(USE_PROBE_FOR_Z_HOMING, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = SUM_TERN(HAS_HOME_OFFSET, base_home_pos(axis), home_offset[axis]);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE

commit ffef8f1b297e83aa37eeb5ffcc5369e5c9c42a09
Author: Mark <niujl123@sina.com>
Date:   Mon Aug 7 12:33:20 2023 +0800

    üö∏ BD Sensor Z axis stop height (#26015)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 80729df759..272b16c9ac 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2472,21 +2472,26 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #else
     current_position[axis] = SUM_TERN(HAS_HOME_OFFSET, base_home_pos(axis), home_offset[axis]);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
-        current_position.z -= probe.offset.z;
+        #if ENABLED(BD_SENSOR)
+          safe_delay(100);
+          current_position.z = bdl.read();
+        #else
+          current_position.z -= probe.offset.z;
+        #endif
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed with PROBE" TERN_(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, " (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)") " ***\n> (M851 Z", probe.offset.z, ")");
       #else
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed to ENDSTOP ***");
       #endif
     }
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    üîß More endstops refactoring (#25758)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cd768d9e40..80729df759 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1711,52 +1711,50 @@ void prepare_line_to_destination() {
           case U_AXIS: stealth_states.u = tmc_enable_stallguard(stepperU); break;
         #endif
         #if V_SENSORLESS
           case V_AXIS: stealth_states.v = tmc_enable_stallguard(stepperV); break;
         #endif
         #if W_SENSORLESS
           case W_AXIS: stealth_states.w = tmc_enable_stallguard(stepperW); break;
         #endif
       }
 
-      #if ENABLED(SPI_ENDSTOPS)
-        switch (axis) {
-          #if HAS_X_AXIS
-            case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
-          #endif
-          #if HAS_Y_AXIS
-            case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
-          #endif
-          #if HAS_Z_AXIS
-            case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
-          #endif
-          #if HAS_I_AXIS
-            case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = true; break;
-          #endif
-          #if HAS_J_AXIS
-            case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = true; break;
-          #endif
-          #if HAS_K_AXIS
-            case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = true; break;
-          #endif
-          #if HAS_U_AXIS
-            case U_AXIS: if (ENABLED(U_SPI_SENSORLESS)) endstops.tmc_spi_homing.u = true; break;
-          #endif
-          #if HAS_V_AXIS
-            case V_AXIS: if (ENABLED(V_SPI_SENSORLESS)) endstops.tmc_spi_homing.v = true; break;
-          #endif
-          #if HAS_W_AXIS
-            case W_AXIS: if (ENABLED(W_SPI_SENSORLESS)) endstops.tmc_spi_homing.w = true; break;
-          #endif
-          default: break;
-        }
-      #endif
+      switch (axis) {
+        #if X_SPI_SENSORLESS
+          case X_AXIS: endstops.tmc_spi_homing.x = true; break;
+        #endif
+        #if Y_SPI_SENSORLESS
+          case Y_AXIS: endstops.tmc_spi_homing.y = true; break;
+        #endif
+        #if Z_SPI_SENSORLESS
+          case Z_AXIS: endstops.tmc_spi_homing.z = true; break;
+        #endif
+        #if I_SPI_SENSORLESS
+          case I_AXIS: endstops.tmc_spi_homing.i = true; break;
+        #endif
+        #if J_SPI_SENSORLESS
+          case J_AXIS: endstops.tmc_spi_homing.j = true; break;
+        #endif
+        #if K_SPI_SENSORLESS
+          case K_AXIS: endstops.tmc_spi_homing.k = true; break;
+        #endif
+        #if U_SPI_SENSORLESS
+          case U_AXIS: endstops.tmc_spi_homing.u = true; break;
+        #endif
+        #if V_SPI_SENSORLESS
+          case V_AXIS: endstops.tmc_spi_homing.v = true; break;
+        #endif
+        #if W_SPI_SENSORLESS
+          case W_AXIS: endstops.tmc_spi_homing.w = true; break;
+        #endif
+        default: break;
+      }
 
       TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
       return stealth_states;
     }
 
     void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
       switch (axis) {
         default: break;
         #if X_SENSORLESS
@@ -1807,52 +1805,50 @@ void prepare_line_to_destination() {
           case U_AXIS: tmc_disable_stallguard(stepperU, enable_stealth.u); break;
         #endif
         #if V_SENSORLESS
           case V_AXIS: tmc_disable_stallguard(stepperV, enable_stealth.v); break;
         #endif
         #if W_SENSORLESS
           case W_AXIS: tmc_disable_stallguard(stepperW, enable_stealth.w); break;
         #endif
       }
 
-      #if ENABLED(SPI_ENDSTOPS)
-        switch (axis) {
-          #if HAS_X_AXIS
-            case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
-          #endif
-          #if HAS_Y_AXIS
-            case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
-          #endif
-          #if HAS_Z_AXIS
-            case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
-          #endif
-          #if HAS_I_AXIS
-            case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
-          #endif
-          #if HAS_J_AXIS
-            case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
-          #endif
-          #if HAS_K_AXIS
-            case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
-          #endif
-          #if HAS_U_AXIS
-            case U_AXIS: if (ENABLED(U_SPI_SENSORLESS)) endstops.tmc_spi_homing.u = false; break;
-          #endif
-          #if HAS_V_AXIS
-            case V_AXIS: if (ENABLED(V_SPI_SENSORLESS)) endstops.tmc_spi_homing.v = false; break;
-          #endif
-          #if HAS_W_AXIS
-            case W_AXIS: if (ENABLED(W_SPI_SENSORLESS)) endstops.tmc_spi_homing.w = false; break;
-          #endif
-          default: break;
-        }
-      #endif
+      switch (axis) {
+        #if X_SPI_SENSORLESS
+          case X_AXIS: endstops.tmc_spi_homing.x = false; break;
+        #endif
+        #if Y_SPI_SENSORLESS
+          case Y_AXIS: endstops.tmc_spi_homing.y = false; break;
+        #endif
+        #if Z_SPI_SENSORLESS
+          case Z_AXIS: endstops.tmc_spi_homing.z = false; break;
+        #endif
+        #if I_SPI_SENSORLESS
+          case I_AXIS: endstops.tmc_spi_homing.i = false; break;
+        #endif
+        #if J_SPI_SENSORLESS
+          case J_AXIS: endstops.tmc_spi_homing.j = false; break;
+        #endif
+        #if K_SPI_SENSORLESS
+          case K_AXIS: endstops.tmc_spi_homing.k = false; break;
+        #endif
+        #if U_SPI_SENSORLESS
+          case U_AXIS: endstops.tmc_spi_homing.u = false; break;
+        #endif
+        #if V_SPI_SENSORLESS
+          case V_AXIS: endstops.tmc_spi_homing.v = false; break;
+        #endif
+        #if W_SPI_SENSORLESS
+          case W_AXIS: endstops.tmc_spi_homing.w = false; break;
+        #endif
+        default: break;
+      }
     }
 
   #endif // SENSORLESS_HOMING
 
   /**
    * Home an individual linear axis
    */
   void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
     DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
@@ -2111,21 +2107,21 @@ void prepare_line_to_destination() {
           fxdTiCtrl.cfg.mode = oldmm;
           fxdTiCtrl.init();
         }
       } on_exit;
     #endif
 
     #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
-      #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_ENDSTOP) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
+      #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_STATE) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //

commit 9135e3f7d3fd0d634656f1c54c70a0ba1f878bfd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 21:10:03 2023 -0500

    üö∏ Revert M206 Home Offset behavior (#25996)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c97523cbd3..cd768d9e40 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -170,30 +170,26 @@ xyz_pos_t cartes;
     constexpr float delta_max_radius = PRINTABLE_RADIUS,
                     delta_max_radius_2 = sq(PRINTABLE_RADIUS);
   #endif
 
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
-#if HAS_POSITION_SHIFT
-  // The distance that XYZ has been offset by G92. Reset by G28.
-  xyz_pos_t position_shift{0};
-#endif
 #if HAS_HOME_OFFSET
   // This offset is added to the configured home position.
   // Set by M206, M428, or menu item. Saved to EEPROM.
   xyz_pos_t home_offset{0};
 #endif
-#if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+#if HAS_WORKSPACE_OFFSET
   // The above two are combined to save on computes
   xyz_pos_t workspace_offset{0};
 #endif
 
 #if HAS_ABL_NOT_UBL
   feedRate_t xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_FEEDRATE);
 #endif
 
 /**
  * Output the current position to serial
@@ -2461,72 +2457,60 @@ void prepare_line_to_destination() {
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
-      current_position.x = x_home_pos(active_extruder);
+      current_position.x = SUM_TERN(HAS_HOME_OFFSET, x_home_pos(active_extruder), home_offset.x);
       return;
     }
   #endif
 
   #if ANY(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
-    current_position[axis] = base_home_pos(axis);
+    current_position[axis] = SUM_TERN(HAS_HOME_OFFSET, base_home_pos(axis), home_offset[axis]);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
         current_position.z -= probe.offset.z;
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed with PROBE" TERN_(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, " (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)") " ***\n> (M851 Z", probe.offset.z, ")");
       #else
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed to ENDSTOP ***");
       #endif
     }
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
-  #if HAS_POSITION_SHIFT
-    position_shift[axis] = 0;
-    update_workspace_offset(axis);
-  #endif
+  TERN_(HAS_WORKSPACE_OFFSET, workspace_offset[axis] = 0);
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPGM("> home_offset[", AS_CHAR(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPGM("<<< set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
   }
 }
 
-#if HAS_WORKSPACE_OFFSET
-  void update_workspace_offset(const AxisEnum axis) {
-    workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
-  }
-#endif
-
-#if HAS_M206_COMMAND
+#if HAS_HOME_OFFSET
   /**
-   * Change the home offset for an axis.
-   * Also refreshes the workspace offset.
+   * Set the home offset for an axis.
    */
   void set_home_offset(const AxisEnum axis, const_float_t v) {
     home_offset[axis] = v;
-    update_workspace_offset(axis);
   }
 #endif

commit ed4e22b548a3ffb348e9d20f995f67a9aa7d2dd6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 4 18:31:20 2023 -0500

    üßë‚Äçüíª print_pos => print_xyz

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3970273af0..c97523cbd3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -570,21 +570,23 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(NUM_AXIS_ARGS_(const_float_t) const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
-  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
+  #if NUM_AXES
+    if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
+  #endif
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
 
   #if IS_KINEMATIC && DISABLED(POLARGRAPH)
     // kinematic machines are expected to home to a point 1.5x their range? never reachable.
     if (!position_is_reachable(x, y)) return;

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d11842e758..3970273af0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1616,36 +1616,35 @@ void prepare_line_to_destination() {
     // Clear test bits that are trusted
     NUM_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
       set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(main_axes_bits_t axis_bits/*=main_axes_mask*/) {
-    if ((axis_bits &= axes_should_home(axis_bits))) {
-      char all_axes[] = STR_AXES_MAIN, need[NUM_AXES + 1];
-      uint8_t n = 0;
-      LOOP_NUM_AXES(i) if (TEST(axis_bits, i)) need[n++] = all_axes[i];
-      need[n] = '\0';
-
-      char msg[30];
-      sprintf_P(msg, GET_EN_TEXT(MSG_HOME_FIRST), need);
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLN(msg);
-
-      sprintf_P(msg, GET_TEXT(MSG_HOME_FIRST), need);
-      ui.set_status(msg);
-      return true;
-    }
-    return false;
+    if (!(axis_bits &= axes_should_home(axis_bits))) return false;
+
+    char all_axes[] = STR_AXES_MAIN, need[NUM_AXES + 1];
+    uint8_t n = 0;
+    LOOP_NUM_AXES(i) if (TEST(axis_bits, i)) need[n++] = all_axes[i];
+    need[n] = '\0';
+
+    SString<30> msg;
+    msg.setf(GET_EN_TEXT_F(MSG_HOME_FIRST), need);
+    SERIAL_ECHO_START();
+    msg.echoln();
+
+    msg.setf(GET_TEXT_F(MSG_HOME_FIRST), need);
+    ui.set_status(msg);
+    return true;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #if HOMING_Z_WITH_PROBE
       if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW);
     #endif
     static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;

commit 8c9172cf5d21fd57aed16edbe825a872ae064ad0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 22 02:54:21 2023 -0500

    üçª Fixed-Time Motion integration (#25719)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dd761a56bb..d11842e758 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -26,20 +26,24 @@
 
 #include "motion.h"
 #include "endstops.h"
 #include "stepper.h"
 #include "planner.h"
 #include "temperature.h"
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
+#if ENABLED(FT_MOTION)
+  #include "ft_motion.h"
+#endif
+
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 #if HAS_BED_PROBE
@@ -2091,20 +2095,35 @@ void prepare_line_to_destination() {
    * to the individual ABC steppers on DELTA and SCARA.
    *
    * At the end of the procedure the axis is marked as
    * homed and the current position of that axis is updated.
    * Kinematic robots should wait till all axes are homed
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
+    #if ENABLED(FT_MOTION)
+      // Disable ft-motion for homing
+      struct OnExit {
+        ftMotionMode_t oldmm;
+        OnExit() {
+          oldmm = fxdTiCtrl.cfg.mode;
+          fxdTiCtrl.cfg.mode = ftMotionMode_DISABLED;
+        }
+        ~OnExit() {
+          fxdTiCtrl.cfg.mode = oldmm;
+          fxdTiCtrl.init();
+        }
+      } on_exit;
+    #endif
+
     #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_ENDSTOP) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");

commit 441416728cd7f0e9b6ebf94f895d1d27fe59d25a
Author: Mark <niujl123@sina.com>
Date:   Sun Jun 18 17:18:08 2023 +0800

    üö∏ Bed distance sensor improvements (#25847)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d7b6d76fae..dd761a56bb 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -66,20 +66,25 @@
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
+
+#if ENABLED(BD_SENSOR)
+  #include "../feature/bedlevel/bdl/bdl.h"
+#endif
+
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 #ifdef Z_IDLE_HEIGHT
@@ -2124,20 +2129,21 @@ void prepare_line_to_destination() {
       }
     #endif
 
     //
     // Deploy BLTouch or tare the probe just before probing
     //
     #if HOMING_Z_WITH_PROBE
       if (axis == Z_AXIS) {
         if (TERN0(BLTOUCH, bltouch.deploy())) return;   // BLTouch was deployed above, but get the alarm state.
         if (TERN0(PROBE_TARE, probe.tare())) return;
+        TERN_(BD_SENSOR, bdl.config_state = BDS_HOMING_Z);
       }
     #endif
 
     //
     // Back away to prevent an early sensorless trigger
     //
     #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
       const xyz_float_t backoff = SENSORLESS_BACKOFF_MM;
       if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS) || TERN0(Z_SENSORLESS, axis == Z_AXIS) || TERN0(I_SENSORLESS, axis == I_AXIS) || TERN0(J_SENSORLESS, axis == J_AXIS) || TERN0(K_SENSORLESS, axis == K_AXIS)) && backoff[axis]) {
         const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
@@ -2374,20 +2380,24 @@ void prepare_line_to_destination() {
 
       set_axis_is_at_home(axis);
       sync_plan_position();
 
       destination[axis] = current_position[axis];
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
     #endif
 
+    #if ALL(BD_SENSOR, HOMING_Z_WITH_PROBE)
+      if (axis == Z_AXIS) bdl.config_state = BDS_IDLE;
+    #endif
+
     // Put away the Z probe
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.stow())) return;
 
     #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
       const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
       if (endstop_backoff[axis]) {
         current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
         line_to_current_position(TERN_(HOMING_Z_WITH_PROBE, (axis == Z_AXIS) ? z_probe_fast_mm_s :) homing_feedrate(axis));
 
         #if ENABLED(SENSORLESS_HOMING)

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e6df20a998..d7b6d76fae 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -250,21 +250,21 @@ void report_current_position() {
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
 #if ENABLED(AUTO_REPORT_POSITION)
   AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
-#if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+#if ANY(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
 
   M_StateEnum M_State_grbl = M_INIT;
 
   /**
    * Output the current grbl compatible state to serial while moving
    */
   void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
@@ -934,21 +934,21 @@ void restore_feedrate_and_scaling() {
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
     if (!soft_endstop._enabled) return;
 
     #if IS_KINEMATIC
 
       if (TERN0(DELTA, !all_axes_homed())) return;
 
-      #if BOTH(HAS_HOTEND_OFFSET, DELTA)
+      #if ALL(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #elif ENABLED(POLARGRAPH)
         // POLARGRAPH uses draw_area_* below...
       #elif ENABLED(POLAR)
         // For now, we don't limit POLAR
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
@@ -1225,21 +1225,21 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
     float cartesian_mm = get_move_distance(diff OPTARG(HAS_ROTATIONAL_AXES, cartes_move));
 
     // If the move is very short, check the E move distance
     TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / (
-      #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+      #if ALL(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
         cartes_move ? scaled_fr_mm_s : LINEAR_UNIT(scaled_fr_mm_s)
       #else
         scaled_fr_mm_s
       #endif
     );
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = segments_per_second * seconds;
 
@@ -1535,21 +1535,21 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position.e and destination.e are good
  * before calling or cold/lengthy extrusion may get missed.
  *
  * Before exit, current_position is set to destination.
  */
 void prepare_line_to_destination() {
   apply_motion_limits(destination);
 
-  #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
+  #if ANY(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN) && destination.e != current_position.e) {
       bool ignore_e = thermalManager.tooColdToExtrude(active_extruder);
       if (ignore_e) SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
 
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
         if (e_delta > (EXTRUDE_MAXLENGTH)) {
           #if ENABLED(MIXING_EXTRUDER)
             float collector[MIXING_STEPPERS];
@@ -1866,43 +1866,43 @@ void prepare_line_to_destination() {
                   ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
     const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states;
     #endif
 
     if (is_home_dir) {
 
       if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
-        #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
+        #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
           // Wait for bed to heat back up between probing points
           thermalManager.wait_for_bed_heating();
         #endif
 
-        #if BOTH(HAS_HOTEND, WAIT_FOR_HOTEND)
+        #if ALL(HAS_HOTEND, WAIT_FOR_HOTEND)
           // Wait for the hotend to heat back up between probing points
           thermalManager.wait_for_hotend_heating(active_extruder);
         #endif
 
         TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
       }
 
       // Disable stealthChop if used. Enable diag1 pin on driver.
       #if ENABLED(SENSORLESS_HOMING)
         stealth_states = start_sensorless_homing_per_axis(axis);
         #if SENSORLESS_STALLGUARD_DELAY
           safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
         #endif
       #endif
     }
 
-    #if EITHER(MORGAN_SCARA, MP_SCARA)
+    #if ANY(MORGAN_SCARA, MP_SCARA)
       // Tell the planner the axis is at 0
       current_position[axis] = 0;
       sync_plan_position();
       current_position[axis] = distance;
       line_to_current_position(home_fr_mm_s);
     #else
       // Get the ABC or XYZ positions in mm
       abce_pos_t target = planner.get_axis_positions_mm();
 
       target[axis] = 0;                         // Set the single homing axis to 0
@@ -2086,25 +2086,25 @@ void prepare_line_to_destination() {
    * to the individual ABC steppers on DELTA and SCARA.
    *
    * At the end of the procedure the axis is marked as
    * homed and the current position of that axis is updated.
    * Kinematic robots should wait till all axes are homed
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
-    #if EITHER(MORGAN_SCARA, MP_SCARA)
+    #if ANY(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
-      #define _CAN_HOME(A) (axis == _AXIS(A) && (EITHER(A##_SPI_SENSORLESS, HAS_##A##_ENDSTOP) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
+      #define _CAN_HOME(A) (axis == _AXIS(A) && (ANY(A##_SPI_SENSORLESS, HAS_##A##_ENDSTOP) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
@@ -2166,21 +2166,21 @@ void prepare_line_to_destination() {
 
     //
     // Fast move towards endstop until triggered
     //
     const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home Fast: ", move_length, "mm");
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     // If a second homing move is configured...
     if (bump) {
-      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+      #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
       #endif
 
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
@@ -2188,32 +2188,32 @@ void prepare_line_to_destination() {
           #define _ESCASE(A) case A##_AXIS: es = A##_ENDSTOP; break;
           MAIN_AXIS_MAP(_ESCASE)
           default: break;
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
-      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+      #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
       do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
     }
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+    #if ALL(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
 
     #if HAS_EXTRA_ENDSTOPS
       const bool pos_dir = axis_home_dir > 0;
       #if ENABLED(X_DUAL_ENDSTOPS)
         if (axis == X_AXIS) {
           const float adj = ABS(endstops.x2_endstop_adj);
           if (adj) {
             if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
@@ -2436,21 +2436,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
-  #if EITHER(MORGAN_SCARA, AXEL_TPARA)
+  #if ANY(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */

commit d22ce55cd5b88d50dd67818c5e44db91575e4d60
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Sun May 21 18:34:19 2023 -0400

    ü©π Fix ProUI Manual Mesh / UBL Viewer (#25858)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a15cfe0796..e6df20a998 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -31,24 +31,20 @@
 #include "temperature.h"
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
-#if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-  #include "../lcd/e3v2/proui/dwin.h"
-#endif
-
 #if ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index de512e11fe..a15cfe0796 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -196,36 +196,38 @@ xyz_pos_t cartes;
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
   TERN_(POLAR, polar_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
-  SERIAL_ECHOPGM_P(
-    LIST_N(DOUBLE(NUM_AXES),
-         X_LBL, lpos.x,
-      SP_Y_LBL, lpos.y,
-      SP_Z_LBL, lpos.z,
-      SP_I_LBL, lpos.i,
-      SP_J_LBL, lpos.j,
-      SP_K_LBL, lpos.k,
-      SP_U_LBL, lpos.u,
-      SP_V_LBL, lpos.v,
-      SP_W_LBL, lpos.w
-    )
-    #if HAS_EXTRUDERS
-      , SP_E_LBL, lpos.e
-    #endif
-  );
+  #if NUM_AXES
+    SERIAL_ECHOPGM_P(
+      LIST_N(DOUBLE(NUM_AXES),
+           X_LBL, lpos.x,
+        SP_Y_LBL, lpos.y,
+        SP_Z_LBL, lpos.z,
+        SP_I_LBL, lpos.i,
+        SP_J_LBL, lpos.j,
+        SP_K_LBL, lpos.k,
+        SP_U_LBL, lpos.u,
+        SP_V_LBL, lpos.v,
+        SP_W_LBL, lpos.w
+      )
+    );
+  #endif
+  #if HAS_EXTRUDERS
+    SERIAL_ECHOPGM_P(SP_E_LBL, lpos.e);
+  #endif
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = LOGICAL_AXIS_ARRAY(
     planner.get_axis_position_mm(E_AXIS),
     cartes.x, cartes.y, cartes.z,
     cartes.i, cartes.j, cartes.k,
@@ -360,29 +362,30 @@ void report_current_position_projected() {
     #elif ENABLED(POLAR)
       can_reach = HYPOT(rx, ry) <= PRINTABLE_RADIUS;
     #endif
 
     return can_reach;
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
-  bool position_is_reachable(const_float_t rx, const_float_t ry) {
+  bool position_is_reachable(TERN_(HAS_X_AXIS, const_float_t rx) OPTARG(HAS_Y_AXIS, const_float_t ry)) {
     if (TERN0(HAS_Y_AXIS, !COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop))) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
       else
         return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
-      return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
+      if (TERN0(HAS_X_AXIS, !COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop))) return false;
+      return true;
     #endif
   }
 
 #endif // CARTESIAN
 
 
 void home_if_needed(const bool keeplev/*=false*/) {
   if (!all_axes_trusted()) gcode.home_all_axes(keeplev);
 }
 
@@ -560,21 +563,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 
 /**
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
-void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(NUM_AXIS_ARGS_(const_float_t) const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
 
   #if IS_KINEMATIC && DISABLED(POLARGRAPH)
@@ -635,164 +638,167 @@ void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s/
 
     // If Z needs to lower, do it after moving XY
     if (destination.z > z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
   #else
 
     #if HAS_Z_AXIS  // If Z needs to raise, do it before moving XY
       if (current_position.z < z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
-    current_position.set(x OPTARG(HAS_Y_AXIS, y)); line_to_current_position(xy_feedrate);
+    current_position.set(TERN_(HAS_X_AXIS, x) OPTARG(HAS_Y_AXIS, y)); line_to_current_position(xy_feedrate);
 
     #if SECONDARY_AXES
       secondary_axis_moves(SECONDARY_AXIS_LIST(i, j, k, u, v, w), fr_mm_s);
     #endif
 
     #if HAS_Z_AXIS
       // If Z needs to lower, do it after moving XY
       if (current_position.z > z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
   #endif
 
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(NUM_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k,
-                                    current_position.u, current_position.v, current_position.w), fr_mm_s);
+  do_blocking_move_to(NUM_AXIS_LIST_(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k,
+                                    current_position.u, current_position.v, current_position.w) fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
+  do_blocking_move_to(NUM_AXIS_ELEM_(raw) fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
-}
-void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_x(", rx, ", ", fr_mm_s, ")");
-  do_blocking_move_to(
-    NUM_AXIS_LIST(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k,
-                  current_position.u, current_position.v, current_position.w),
-    fr_mm_s
-  );
+  do_blocking_move_to(NUM_AXIS_ELEM_(raw) fr_mm_s);
 }
 
+#if HAS_X_AXIS
+  void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_x(", rx, ", ", fr_mm_s, ")");
+    do_blocking_move_to(
+      NUM_AXIS_LIST_(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k,
+                     current_position.u, current_position.v, current_position.w)
+      fr_mm_s
+    );
+  }
+#endif
+
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_y(", ry, ", ", fr_mm_s, ")");
     do_blocking_move_to(
-      NUM_AXIS_LIST(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k,
-                    current_position.u, current_position.v, current_position.w),
+      NUM_AXIS_LIST_(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_z(", rz, ", ", fr_mm_s, ")");
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
 #endif
 
 #if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
   }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, i, raw.j, raw.k, raw.u, raw.v, raw.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, i, raw.j, raw.k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_J_AXIS
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
   }
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, j, raw.k, raw.u, raw.v, raw.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, j, raw.k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_K_AXIS
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
   }
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, k, raw.u, raw.v, raw.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, k, raw.u, raw.v, raw.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_U_AXIS
   void do_blocking_move_to_u(const_float_t ru, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzijk_u(current_position, ru, fr_mm_s);
   }
   void do_blocking_move_to_xyzijk_u(const xyze_pos_t &raw, const_float_t u, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, u, raw.v, raw.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, u, raw.v, raw.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_V_AXIS
   void do_blocking_move_to_v(const_float_t rv, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzijku_v(current_position, rv, fr_mm_s);
   }
   void do_blocking_move_to_xyzijku_v(const xyze_pos_t &raw, const_float_t v, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, v, raw.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, v, raw.w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_W_AXIS
   void do_blocking_move_to_w(const_float_t rw, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzijkuv_w(current_position, rw, fr_mm_s);
   }
   void do_blocking_move_to_xyzijkuv_w(const xyze_pos_t &raw, const_float_t w, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, raw.v, w),
+      NUM_AXIS_LIST_(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, raw.v, w)
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_xy(", rx, ", ", ry, ", ", fr_mm_s, ")");
     do_blocking_move_to(
-      NUM_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
-                    current_position.u, current_position.v, current_position.w),
+      NUM_AXIS_LIST_(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w)
       fr_mm_s
     );
   }
   void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      NUM_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
-                    current_position.u, current_position.v, current_position.w),
+      NUM_AXIS_LIST_(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w)
       fr_mm_s
     );
   }
   void do_z_clearance(const_float_t zclear, const bool with_probe/*=true*/, const bool lower_allowed/*=false*/) {
     UNUSED(with_probe);
     float zdest = zclear;
     TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
     NOMORE(zdest, Z_MAX_POS);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
     if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
@@ -959,28 +965,30 @@ void restore_feedrate_and_scaling() {
       #else
         if (TERN1(IS_SCARA, axis_was_homed(X_AXIS) && axis_was_homed(Y_AXIS))) {
           const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
           if (dist_2 > delta_max_radius_2)
             target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
         }
       #endif
 
     #else
 
-      if (axis_was_homed(X_AXIS)) {
-        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-          NOLESS(target.x, soft_endstop.min.x);
-        #endif
-        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-          NOMORE(target.x, soft_endstop.max.x);
-        #endif
-      }
+      #if HAS_X_AXIS
+        if (axis_was_homed(X_AXIS)) {
+          #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+            NOLESS(target.x, soft_endstop.min.x);
+          #endif
+          #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+            NOMORE(target.x, soft_endstop.max.x);
+          #endif
+        }
+      #endif
 
       #if HAS_Y_AXIS
         if (axis_was_homed(Y_AXIS)) {
           #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
             NOLESS(target.y, soft_endstop.min.y);
           #endif
           #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
             NOMORE(target.y, soft_endstop.max.y);
           #endif
         }
@@ -1072,96 +1080,104 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     next_idle_ms = ms + 200UL;
     return idle();
   }
   thermalManager.task();  // Returns immediately on most calls
 }
 
 /**
  * Get distance from displacements along axes and, if required, update move type.
  */
 float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool &is_cartesian_move)) {
-  if (!(NUM_AXIS_GANG(diff.x, || diff.y, /* skip z */, || diff.i, || diff.j, || diff.k, || diff.u, || diff.v, || diff.w)))
-    return TERN0(HAS_Z_AXIS, ABS(diff.z));
+  #if NUM_AXES
 
-  #if ENABLED(ARTICULATED_ROBOT_ARM)
+    if (!(NUM_AXIS_GANG(diff.x, || diff.y, /* skip z */, || diff.i, || diff.j, || diff.k, || diff.u, || diff.v, || diff.w)))
+      return TERN0(HAS_Z_AXIS, ABS(diff.z));
 
-    // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
-    // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
-    const float distance_sqr = NUM_AXIS_GANG(
-        sq(diff.x), + sq(diff.y), + sq(diff.z),
-      + sq(diff.i), + sq(diff.j), + sq(diff.k),
-      + sq(diff.u), + sq(diff.v), + sq(diff.w)
-    );
+    #if ENABLED(ARTICULATED_ROBOT_ARM)
+
+      // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
+      // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
+      const float distance_sqr = NUM_AXIS_GANG(
+          sq(diff.x), + sq(diff.y), + sq(diff.z),
+        + sq(diff.i), + sq(diff.j), + sq(diff.k),
+        + sq(diff.u), + sq(diff.v), + sq(diff.w)
+      );
 
-  #elif ENABLED(FOAMCUTTER_XYUV)
+    #elif ENABLED(FOAMCUTTER_XYUV)
 
-    const float distance_sqr = (
-      #if HAS_J_AXIS
-        _MAX(sq(diff.x) + sq(diff.y), sq(diff.i) + sq(diff.j)) // Special 5 axis kinematics. Return the larger of plane X/Y or I/J
-      #else
-        sq(diff.x) + sq(diff.y) // Foamcutter with only two axes (XY)
+      const float distance_sqr = (
+        #if HAS_J_AXIS
+          _MAX(sq(diff.x) + sq(diff.y), sq(diff.i) + sq(diff.j)) // Special 5 axis kinematics. Return the larger of plane X/Y or I/J
+        #else
+          sq(diff.x) + sq(diff.y) // Foamcutter with only two axes (XY)
+        #endif
+      );
+
+    #else
+
+      /**
+       * Calculate distance for feedrate interpretation in accordance with NIST RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+       * Assume:
+       *   - X, Y, Z are the primary linear axes;
+       *   - U, V, W are secondary linear axes;
+       *   - A, B, C are rotational axes.
+       *
+       * Then:
+       *   - dX, dY, dZ are the displacements of the primary linear axes;
+       *   - dU, dV, dW are the displacements of linear axes;
+       *   - dA, dB, dC are the displacements of rotational axes.
+       *
+       * The time it takes to execute a move command with feedrate F is t = D/F,
+       * plus any time for acceleration and deceleration.
+       * Here, D is the total distance, calculated as follows:
+       *
+       *   D^2 = dX^2 + dY^2 + dZ^2
+       *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
+       *     D^2 = dU^2 + dV^2 + dW^2
+       *   if D^2 == 0 (only rotational axes are moved):
+       *     D^2 = dA^2 + dB^2 + dC^2
+       */
+      float distance_sqr = XYZ_GANG(sq(diff.x), + sq(diff.y), + sq(diff.z));
+
+      #if SECONDARY_LINEAR_AXES
+        if (UNEAR_ZERO(distance_sqr)) {
+          // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
+          distance_sqr = (
+            SECONDARY_AXIS_GANG(
+              IF_DISABLED(AXIS4_ROTATES, + sq(diff.i)),
+              IF_DISABLED(AXIS5_ROTATES, + sq(diff.j)),
+              IF_DISABLED(AXIS6_ROTATES, + sq(diff.k)),
+              IF_DISABLED(AXIS7_ROTATES, + sq(diff.u)),
+              IF_DISABLED(AXIS8_ROTATES, + sq(diff.v)),
+              IF_DISABLED(AXIS9_ROTATES, + sq(diff.w))
+            )
+          );
+        }
       #endif
-    );
 
-  #else
+      #if HAS_ROTATIONAL_AXES
+        if (UNEAR_ZERO(distance_sqr)) {
+          // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
+          is_cartesian_move = false;
+          distance_sqr = ROTATIONAL_AXIS_GANG(sq(diff.i), + sq(diff.j), + sq(diff.k), + sq(diff.u), + sq(diff.v), + sq(diff.w));
+        }
+      #endif
 
-    /**
-     * Calculate distance for feedrate interpretation in accordance with NIST RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
-     * Assume:
-     *   - X, Y, Z are the primary linear axes;
-     *   - U, V, W are secondary linear axes;
-     *   - A, B, C are rotational axes.
-     *
-     * Then:
-     *   - dX, dY, dZ are the displacements of the primary linear axes;
-     *   - dU, dV, dW are the displacements of linear axes;
-     *   - dA, dB, dC are the displacements of rotational axes.
-     *
-     * The time it takes to execute a move command with feedrate F is t = D/F,
-     * plus any time for acceleration and deceleration.
-     * Here, D is the total distance, calculated as follows:
-     *
-     *   D^2 = dX^2 + dY^2 + dZ^2
-     *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
-     *     D^2 = dU^2 + dV^2 + dW^2
-     *   if D^2 == 0 (only rotational axes are moved):
-     *     D^2 = dA^2 + dB^2 + dC^2
-     */
-    float distance_sqr = XYZ_GANG(sq(diff.x), + sq(diff.y), + sq(diff.z));
-
-    #if SECONDARY_LINEAR_AXES
-      if (UNEAR_ZERO(distance_sqr)) {
-        // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
-        distance_sqr = (
-          SECONDARY_AXIS_GANG(
-            IF_DISABLED(AXIS4_ROTATES, + sq(diff.i)),
-            IF_DISABLED(AXIS5_ROTATES, + sq(diff.j)),
-            IF_DISABLED(AXIS6_ROTATES, + sq(diff.k)),
-            IF_DISABLED(AXIS7_ROTATES, + sq(diff.u)),
-            IF_DISABLED(AXIS8_ROTATES, + sq(diff.v)),
-            IF_DISABLED(AXIS9_ROTATES, + sq(diff.w))
-          )
-        );
-      }
     #endif
 
-    #if HAS_ROTATIONAL_AXES
-      if (UNEAR_ZERO(distance_sqr)) {
-        // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
-        is_cartesian_move = false;
-        distance_sqr = ROTATIONAL_AXIS_GANG(sq(diff.i), + sq(diff.j), + sq(diff.k), + sq(diff.u), + sq(diff.v), + sq(diff.w));
-      }
-    #endif
+    return SQRT(distance_sqr);
 
-  #endif
+  #else
 
-  return SQRT(distance_sqr);
+    return 0;
+
+  #endif
 }
 
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
@@ -1695,21 +1711,23 @@ void prepare_line_to_destination() {
         #if V_SENSORLESS
           case V_AXIS: stealth_states.v = tmc_enable_stallguard(stepperV); break;
         #endif
         #if W_SENSORLESS
           case W_AXIS: stealth_states.w = tmc_enable_stallguard(stepperW); break;
         #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
-          case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
+          #if HAS_X_AXIS
+            case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
+          #endif
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
           #endif
           #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = true; break;
           #endif
           #if HAS_J_AXIS
@@ -1789,21 +1807,23 @@ void prepare_line_to_destination() {
         #if V_SENSORLESS
           case V_AXIS: tmc_disable_stallguard(stepperV, enable_stealth.v); break;
         #endif
         #if W_SENSORLESS
           case W_AXIS: tmc_disable_stallguard(stepperW, enable_stealth.w); break;
         #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
-          case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
+          #if HAS_X_AXIS
+            case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
+          #endif
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
           #endif
           #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
           #endif
           #if HAS_J_AXIS

commit 12d8108fc6b77bd6c277c49deb4ac99879d551ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 17:37:47 2023 -0500

    üö∏ Faster default Marlin feedrate

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9c59195a8c..de512e11fe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -129,21 +129,24 @@ xyze_pos_t destination; // {0}
     // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]
     HOTEND_LOOP() LOOP_ABC(a) hotend_offset[e][a] = tmp[a][e];
     TERN_(DUAL_X_CARRIAGE, hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS));
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
-feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
+#ifndef DEFAULT_FEEDRATE_MM_M
+  #define DEFAULT_FEEDRATE_MM_M 4000
+#endif
+feedRate_t feedrate_mm_s = MMM_TO_MMS(DEFAULT_FEEDRATE_MM_M);
 int16_t feedrate_percentage = 100;
 
 // Cartesian conversion result goes here:
 xyz_pos_t cartes;
 
 #if IS_KINEMATIC
 
   abce_pos_t delta;
 
   #if HAS_SCARA_OFFSET

commit 61f0dd227177419ade6b2454afaec422f41fcc03
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 1 20:23:41 2023 -0500

    ü©π Fix _CAN_HOME for new endstop flags

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ccbf73e243..9c59195a8c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2071,26 +2071,21 @@ void prepare_line_to_destination() {
    * Kinematic robots should wait till all axes are homed
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
-      #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
-           ENABLED(A##_SPI_SENSORLESS) \
-        || TERN0(HAS_Z_AXIS, TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)) \
-        || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
-        || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
-      ))
+      #define _CAN_HOME(A) (axis == _AXIS(A) && (EITHER(A##_SPI_SENSORLESS, HAS_##A##_ENDSTOP) || TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)))
       #define _ANDCANT(N) && !_CAN_HOME(N)
       if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //

commit 4c033c3e47b80a9d2497b47a7d3f1ef5034ff4d0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 12:34:56 2023 -0500

    üßë‚Äçüíª Tweak homing debug

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 418bee559f..ccbf73e243 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2437,23 +2437,23 @@ void set_axis_is_at_home(const AxisEnum axis) {
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
         current_position.z -= probe.offset.z;
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed with PROBE" TERN_(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, " (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)") " ***\n> (M851 Z", probe.offset.z, ")");
       #else
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z homed to ENDSTOP ***");
       #endif
     }
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;

commit 68f74784a3a41c643984ee62a507b25903430591
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 13:50:45 2023 -0500

    üé® Misc. fixes, cleanup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f7671e3135..418bee559f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -533,46 +533,53 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   REMEMBER(pct, feedrate_percentage, 100);
   TERN_(HAS_EXTRUDERS, REMEMBER(fac, planner.e_factor[active_extruder], 1.0f));
 
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
   if (TERN0(IS_KINEMATIC, is_fast))
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 }
 
+#if SECONDARY_AXES
+
+  void secondary_axis_moves(SECONDARY_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s) {
+    auto move_one = [&](const AxisEnum a, const_float_t p) {
+      const feedRate_t fr = fr_mm_s ?: homing_feedrate(a);
+      current_position[a] = p; line_to_current_position(fr);
+    };
+    SECONDARY_AXIS_CODE(
+      move_one(I_AXIS, i), move_one(J_AXIS, j), move_one(K_AXIS, k),
+      move_one(U_AXIS, u), move_one(V_AXIS, v), move_one(W_AXIS, w)
+    );
+  }
+
+#endif
+
 /**
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
-  SECONDARY_AXIS_CODE(
-    const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS),
-    const feedRate_t j_feedrate = fr_mm_s ?: homing_feedrate(J_AXIS),
-    const feedRate_t k_feedrate = fr_mm_s ?: homing_feedrate(K_AXIS),
-    const feedRate_t u_feedrate = fr_mm_s ?: homing_feedrate(U_AXIS),
-    const feedRate_t v_feedrate = fr_mm_s ?: homing_feedrate(V_AXIS),
-    const feedRate_t w_feedrate = fr_mm_s ?: homing_feedrate(W_AXIS)
-  );
 
   #if IS_KINEMATIC && DISABLED(POLARGRAPH)
     // kinematic machines are expected to home to a point 1.5x their range? never reachable.
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
@@ -601,55 +608,48 @@ void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s/
     destination.set(x, y);
     prepare_internal_move_to_destination();                   // set current_position from destination
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
     if (z < current_position.z) {                             // lowering?
       destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
+    #if SECONDARY_AXES
+      secondary_axis_moves(SECONDARY_AXIS_LIST(i, j, k, u, v, w), fr_mm_s);
+    #endif
+
   #elif IS_SCARA
 
     // If Z needs to raise, do it before moving XY
     if (destination.z < z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
     destination.set(x, y); prepare_internal_fast_move_to_destination(xy_feedrate);
 
+    #if SECONDARY_AXES
+      secondary_axis_moves(SECONDARY_AXIS_LIST(i, j, k, u, v, w), fr_mm_s);
+    #endif
+
     // If Z needs to lower, do it after moving XY
     if (destination.z > z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
   #else
 
     #if HAS_Z_AXIS  // If Z needs to raise, do it before moving XY
       if (current_position.z < z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
     current_position.set(x OPTARG(HAS_Y_AXIS, y)); line_to_current_position(xy_feedrate);
 
-    #if HAS_I_AXIS
-      current_position.i = i; line_to_current_position(i_feedrate);
-    #endif
-    #if HAS_J_AXIS
-      current_position.j = j; line_to_current_position(j_feedrate);
-    #endif
-    #if HAS_K_AXIS
-      current_position.k = k; line_to_current_position(k_feedrate);
-    #endif
-    #if HAS_U_AXIS
-      current_position.u = u; line_to_current_position(u_feedrate);
-    #endif
-    #if HAS_V_AXIS
-      current_position.v = v; line_to_current_position(v_feedrate);
-    #endif
-    #if HAS_W_AXIS
-      current_position.w = w; line_to_current_position(w_feedrate);
+    #if SECONDARY_AXES
+      secondary_axis_moves(SECONDARY_AXIS_LIST(i, j, k, u, v, w), fr_mm_s);
     #endif
 
     #if HAS_Z_AXIS
       // If Z needs to lower, do it after moving XY
       if (current_position.z > z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
   #endif
 
   planner.synchronize();

commit f0f7ec88823318c7d778e42b4dc7604120943032
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 00:47:44 2023 -0500

    üßë‚Äçüíª Stepper::set_directions() => apply_directions()

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 589299f2f1..f7671e3135 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1412,27 +1412,27 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
      * In dual carriage mode the extruder offset provides an override of the
      * second X-carriage position when homed - otherwise X2_HOME_POS is used.
      * This allows soft recalibration of the second extruder home position
      * (with M218 T1 Xn) without firmware reflash.
      */
     return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
   }
 
   void idex_set_mirrored_mode(const bool mirr) {
     idex_mirrored_mode = mirr;
-    stepper.set_directions();
+    stepper.apply_directions();
   }
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index/*=-1*/) {
     extruder_duplication_enabled = dupe;
     if (tool_index >= 0) active_extruder = tool_index;
-    stepper.set_directions();
+    stepper.apply_directions();
   }
 
   void idex_set_parked(const bool park/*=true*/) {
     delayed_move_time = 0;
     active_extruder_parked = park;
     if (park) raised_parked_position = current_position;  // Remember current raised toolhead position for use by unpark
   }
 
   /**
    * Prepare a linear move in a dual X axis setup
@@ -1464,21 +1464,21 @@ float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool
           //  1. Move to the raised parked XYZ. Presumably the tool is already at XY.
           xyze_pos_t raised = raised_parked_position; raised.e = current_position.e;
           if (planner.buffer_line(raised, fr_zfast)) {
             //  2. Move to the current native XY and raised Z. Presumably this is a null move.
             xyze_pos_t curpos = current_position; curpos.z = raised_parked_position.z;
             if (planner.buffer_line(curpos, PLANNER_XY_FEEDRATE())) {
               //  3. Lower Z back down
               line_to_current_position(fr_zfast);
             }
           }
-          stepper.set_directions();
+          stepper.apply_directions();
 
           idex_set_parked(false);
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
         } break;
 
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             set_duplication_enabled(false); // Clear stale duplication state
             // Restore planner to parked head (T1) X position

commit 4233e4864f0c621612ce35a9b6ca882312e3aa4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 01:56:10 2023 -0500

    üö∏ MarlinUI Endstop Test Screen, and more (#25667)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6917bbc42a..589299f2f1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2164,46 +2164,23 @@ void prepare_line_to_destination() {
       #endif
 
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
-          default:
-          case X_AXIS: es = X_ENDSTOP; break;
-          #if HAS_Y_AXIS
-            case Y_AXIS: es = Y_ENDSTOP; break;
-          #endif
-          #if HAS_Z_AXIS
-            case Z_AXIS: es = Z_ENDSTOP; break;
-          #endif
-          #if HAS_I_AXIS
-            case I_AXIS: es = I_ENDSTOP; break;
-          #endif
-          #if HAS_J_AXIS
-            case J_AXIS: es = J_ENDSTOP; break;
-          #endif
-          #if HAS_K_AXIS
-            case K_AXIS: es = K_ENDSTOP; break;
-          #endif
-          #if HAS_U_AXIS
-            case U_AXIS: es = U_ENDSTOP; break;
-          #endif
-          #if HAS_V_AXIS
-            case V_AXIS: es = V_ENDSTOP; break;
-          #endif
-          #if HAS_W_AXIS
-            case W_AXIS: es = W_ENDSTOP; break;
-          #endif
+          #define _ESCASE(A) case A##_AXIS: es = A##_ENDSTOP; break;
+          MAIN_AXIS_MAP(_ESCASE)
+          default: break;
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)

commit c8c5ab22ce242b93632a7e2b9f855bbaf38b557f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 19:29:53 2023 -0500

    üßë‚Äçüíª Gather Z clearances (#25701)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 219f219e59..6917bbc42a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -31,20 +31,24 @@
 #include "temperature.h"
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
+#if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+  #include "../lcd/e3v2/proui/dwin.h"
+#endif
+
 #if ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
@@ -788,35 +792,40 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
     TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
     NOMORE(zdest, Z_MAX_POS);
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
     if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
     do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
   void do_z_clearance_by(const_float_t zclear) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
     do_z_clearance(current_position.z + zclear, false);
   }
+  void do_move_after_z_homing() {
+    DEBUG_SECTION(mzah, "do_move_after_z_homing", DEBUGGING(LEVELING));
+    #if defined(Z_AFTER_HOMING) || ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+      do_z_clearance(Z_POST_CLEARANCE, true, true);
+    #elif ENABLED(USE_PROBE_FOR_Z_HOMING)
+      probe.move_z_after_probing();
+    #endif
+  }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
-void remember_feedrate_and_scaling() {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("remember_feedrate_and_scaling: fr=", feedrate_mm_s, " ", feedrate_percentage, "%");
+void remember_feedrate_scaling_off() {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("remember_feedrate_scaling_off: fr=", feedrate_mm_s, " ", feedrate_percentage, "%");
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
-}
-void remember_feedrate_scaling_off() {
-  remember_feedrate_and_scaling();
   feedrate_percentage = 100;
 }
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("restore_feedrate_and_scaling: fr=", feedrate_mm_s, " ", feedrate_percentage, "%");
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 

commit 161b99cb54f5d6d183877902581d3d77e8a1fa78
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 01:08:51 2023 -0500

    üêõ Fix some bad feedrates (#25672)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d5d9ca8d34..219f219e59 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -518,39 +518,29 @@ void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
 #endif // IS_KINEMATIC
 
 /**
  * Do a fast or normal move to 'destination' with an optional FR.
  *  - Move at normal speed regardless of feedrate percentage.
  *  - Extrude the specified length regardless of flow percentage.
  */
 void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   OPTARG(IS_KINEMATIC, const bool is_fast/*=false*/)
 ) {
-  const feedRate_t old_feedrate = feedrate_mm_s;
-  if (fr_mm_s) feedrate_mm_s = fr_mm_s;
-
-  const uint16_t old_pct = feedrate_percentage;
-  feedrate_percentage = 100;
-
-  #if HAS_EXTRUDERS
-    const float old_fac = planner.e_factor[active_extruder];
-    planner.e_factor[active_extruder] = 1.0f;
-  #endif
+  REMEMBER(fr, feedrate_mm_s);
+  REMEMBER(pct, feedrate_percentage, 100);
+  TERN_(HAS_EXTRUDERS, REMEMBER(fac, planner.e_factor[active_extruder], 1.0f));
 
+  if (fr_mm_s) feedrate_mm_s = fr_mm_s;
   if (TERN0(IS_KINEMATIC, is_fast))
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
-
-  feedrate_mm_s = old_feedrate;
-  feedrate_percentage = old_pct;
-  TERN_(HAS_EXTRUDERS, planner.e_factor[active_extruder] = old_fac);
 }
 
 /**
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.

commit f53217b2c5bf7d61d21ee6784ec251bc7a670eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:01 2023 -0500

    üßë‚Äçüíª Probe flag in do_z_clearance

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ad5be12187..d5d9ca8d34 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -785,29 +785,32 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
-  void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, ", ", lower_allowed, ")");
-    const float zdest = _MIN(zclear, Z_MAX_POS);
-    if (zdest == current_position.z || (!lower_allowed && zdest < current_position.z)) return;
+  void do_z_clearance(const_float_t zclear, const bool with_probe/*=true*/, const bool lower_allowed/*=false*/) {
+    UNUSED(with_probe);
+    float zdest = zclear;
+    TERN_(HAS_BED_PROBE, if (with_probe && probe.offset.z < 0) zdest -= probe.offset.z);
+    NOMORE(zdest, Z_MAX_POS);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, " [", current_position.z, " to ", zdest, "], ", lower_allowed, ")");
+    if ((!lower_allowed && zdest < current_position.z) || zdest == current_position.z) return;
     do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
   void do_z_clearance_by(const_float_t zclear) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
-    do_z_clearance(current_position.z + zclear);
+    do_z_clearance(current_position.z + zclear, false);
   }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {

commit 185961f898f8c9d2cf5e3d78dcd060e7c576cf7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 17:55:58 2023 -0500

    üßë‚Äçüíª More debug in motion.*

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 785cbb09a6..ad5be12187 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -804,30 +804,32 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
   }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("remember_feedrate_and_scaling: fr=", feedrate_mm_s, " ", feedrate_percentage, "%");
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
 }
 void remember_feedrate_scaling_off() {
   remember_feedrate_and_scaling();
   feedrate_percentage = 100;
 }
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("restore_feedrate_and_scaling: fr=", feedrate_mm_s, " ", feedrate_percentage, "%");
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   #define _AMIN(A) A##_MIN_POS
   #define _AMAX(A) A##_MAX_POS
   soft_endstops_t soft_endstop = {
     true, false,
     { MAPLIST(_AMIN, MAIN_AXIS_NAMES) },

commit c4aa39dc863091cbf0b4590ec4bd3a117a9f92d3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 10 20:54:55 2023 -0500

    ü©π Fix BLTouch stow in homeaxis(Z)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 152b5f70e3..785cbb09a6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2146,26 +2146,26 @@ void prepare_line_to_destination() {
       use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(axis)) : home_bump_mm(axis)
     );
 
     //
     // Fast move towards endstop until triggered
     //
     const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home Fast: ", move_length, "mm");
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
-      if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
-    #endif
-
     // If a second homing move is configured...
     if (bump) {
+      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+        if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
+      #endif
+
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
@@ -2202,26 +2202,26 @@ void prepare_line_to_destination() {
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
       do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
-
-      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
-        if (axis == Z_AXIS) bltouch.stow(); // The final STOW
-      #endif
     }
 
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+      if (axis == Z_AXIS) bltouch.stow(); // The final STOW
+    #endif
+
     #if HAS_EXTRA_ENDSTOPS
       const bool pos_dir = axis_home_dir > 0;
       #if ENABLED(X_DUAL_ENDSTOPS)
         if (axis == X_AXIS) {
           const float adj = ABS(endstops.x2_endstop_adj);
           if (adj) {
             if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
             do_homing_move(axis, pos_dir ? -adj : adj);
             stepper.set_x_lock(false);
             stepper.set_x2_lock(false);

commit 266786406c3e90654e94b91cd74e646d145cc4ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 30 15:12:56 2023 -0500

    üé® Misc. probe-related cleanup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4e4c174bd8..152b5f70e3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -791,20 +791,24 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
                     current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
   void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, ", ", lower_allowed, ")");
     const float zdest = _MIN(zclear, Z_MAX_POS);
     if (zdest == current_position.z || (!lower_allowed && zdest < current_position.z)) return;
     do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
+  void do_z_clearance_by(const_float_t zclear) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance_by(", zclear, ")");
+    do_z_clearance(current_position.z + zclear);
+  }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
@@ -2451,29 +2455,24 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
-
         current_position.z -= probe.offset.z;
-
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
-
       #else
-
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
-
       #endif
     }
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;

commit 4aec74f2465a14b2660a2c28e1da39f1013cb521
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 5 11:58:24 2023 -0500

    üêõ INVERT_*_DIR for FT_MOTION (#25637)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 61cbef068e..4e4c174bd8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1945,86 +1945,86 @@ void prepare_line_to_destination() {
               effectorBackoutDir, // Direction in which the effector mm coordinates move away from endstop.
               stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
 
       #define PHASE_PER_MICROSTEP(N) (256 / _MAX(1, N##_MICROSTEPS))
 
       switch (axis) {
         #ifdef X_MICROSTEPS
           case X_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(X);
             phaseCurrent = stepperX.get_microstep_counter();
-            effectorBackoutDir = -X_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_X_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(X_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_X_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef Y_MICROSTEPS
           case Y_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(Y);
             phaseCurrent = stepperY.get_microstep_counter();
-            effectorBackoutDir = -Y_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_Y_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(Y_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_Y_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef Z_MICROSTEPS
           case Z_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(Z);
             phaseCurrent = stepperZ.get_microstep_counter();
-            effectorBackoutDir = -Z_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_Z_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(Z_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_Z_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef I_MICROSTEPS
           case I_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(I);
             phaseCurrent = stepperI.get_microstep_counter();
-            effectorBackoutDir = -I_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_I_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(I_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_I_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef J_MICROSTEPS
           case J_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(J);
             phaseCurrent = stepperJ.get_microstep_counter();
-            effectorBackoutDir = -J_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_J_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(J_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_J_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef K_MICROSTEPS
           case K_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(K);
             phaseCurrent = stepperK.get_microstep_counter();
-            effectorBackoutDir = -K_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_K_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(K_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_K_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef U_MICROSTEPS
           case U_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(U);
             phaseCurrent = stepperU.get_microstep_counter();
-            effectorBackoutDir = -U_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_U_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(U_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_U_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef V_MICROSTEPS
           case V_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(V);
             phaseCurrent = stepperV.get_microstep_counter();
-            effectorBackoutDir = -V_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_V_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(V_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_V_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         #ifdef W_MICROSTEPS
           case W_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(W);
             phaseCurrent = stepperW.get_microstep_counter();
-            effectorBackoutDir = -W_HOME_DIR;
-            stepperBackoutDir = IF_DISABLED(INVERT_W_DIR, -)effectorBackoutDir;
+            effectorBackoutDir = -(W_HOME_DIR);
+            stepperBackoutDir = TERN_(INVERT_W_DIR, -)(-effectorBackoutDir);
             break;
         #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.mm_per_step[axis] / phasePerUStep < 0.05f)

commit 49f1cc8efe0fcb8df79581c0b71eedef250e83f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 29 22:55:36 2023 -0500

    üé® Refine probe, more debug

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9d43db48c7..61cbef068e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -665,39 +665,42 @@ void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/)
   do_blocking_move_to(NUM_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k,
                                     current_position.u, current_position.v, current_position.w), fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
 }
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_x(", rx, ", ", fr_mm_s, ")");
   do_blocking_move_to(
     NUM_AXIS_LIST(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k,
                   current_position.u, current_position.v, current_position.w),
     fr_mm_s
   );
 }
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_y(", ry, ", ", fr_mm_s, ")");
     do_blocking_move_to(
       NUM_AXIS_LIST(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_z(", rz, ", ", fr_mm_s, ")");
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
 #endif
 
 #if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
   }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
@@ -762,43 +765,45 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
   void do_blocking_move_to_xyzijkuv_w(const xyze_pos_t &raw, const_float_t w, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, raw.v, w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_blocking_move_to_xy(", rx, ", ", ry, ", ", fr_mm_s, ")");
     do_blocking_move_to(
       NUM_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
   void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       NUM_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
                     current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
   void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
-    float zdest = zclear;
-    if (!lower_allowed) NOLESS(zdest, current_position.z);
-    do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("do_z_clearance(", zclear, ", ", lower_allowed, ")");
+    const float zdest = _MIN(zclear, Z_MAX_POS);
+    if (zdest == current_position.z || (!lower_allowed && zdest < current_position.z)) return;
+    do_blocking_move_to_z(zdest, TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
 #endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {

commit babd3b0037d660f52cccbb295b8839b8dd744036
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Feb 21 19:26:10 2023 +0100

    üßë‚Äçüíª Add get_move_distance for rotation/kinematics (#25370)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b32368ca92..9d43db48c7 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1052,20 +1052,102 @@ void restore_feedrate_and_scaling() {
 
 FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   const millis_t ms = millis();
   if (ELAPSED(ms, next_idle_ms)) {
     next_idle_ms = ms + 200UL;
     return idle();
   }
   thermalManager.task();  // Returns immediately on most calls
 }
 
+/**
+ * Get distance from displacements along axes and, if required, update move type.
+ */
+float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool &is_cartesian_move)) {
+  if (!(NUM_AXIS_GANG(diff.x, || diff.y, /* skip z */, || diff.i, || diff.j, || diff.k, || diff.u, || diff.v, || diff.w)))
+    return TERN0(HAS_Z_AXIS, ABS(diff.z));
+
+  #if ENABLED(ARTICULATED_ROBOT_ARM)
+
+    // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
+    // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
+    const float distance_sqr = NUM_AXIS_GANG(
+        sq(diff.x), + sq(diff.y), + sq(diff.z),
+      + sq(diff.i), + sq(diff.j), + sq(diff.k),
+      + sq(diff.u), + sq(diff.v), + sq(diff.w)
+    );
+
+  #elif ENABLED(FOAMCUTTER_XYUV)
+
+    const float distance_sqr = (
+      #if HAS_J_AXIS
+        _MAX(sq(diff.x) + sq(diff.y), sq(diff.i) + sq(diff.j)) // Special 5 axis kinematics. Return the larger of plane X/Y or I/J
+      #else
+        sq(diff.x) + sq(diff.y) // Foamcutter with only two axes (XY)
+      #endif
+    );
+
+  #else
+
+    /**
+     * Calculate distance for feedrate interpretation in accordance with NIST RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+     * Assume:
+     *   - X, Y, Z are the primary linear axes;
+     *   - U, V, W are secondary linear axes;
+     *   - A, B, C are rotational axes.
+     *
+     * Then:
+     *   - dX, dY, dZ are the displacements of the primary linear axes;
+     *   - dU, dV, dW are the displacements of linear axes;
+     *   - dA, dB, dC are the displacements of rotational axes.
+     *
+     * The time it takes to execute a move command with feedrate F is t = D/F,
+     * plus any time for acceleration and deceleration.
+     * Here, D is the total distance, calculated as follows:
+     *
+     *   D^2 = dX^2 + dY^2 + dZ^2
+     *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
+     *     D^2 = dU^2 + dV^2 + dW^2
+     *   if D^2 == 0 (only rotational axes are moved):
+     *     D^2 = dA^2 + dB^2 + dC^2
+     */
+    float distance_sqr = XYZ_GANG(sq(diff.x), + sq(diff.y), + sq(diff.z));
+
+    #if SECONDARY_LINEAR_AXES
+      if (UNEAR_ZERO(distance_sqr)) {
+        // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
+        distance_sqr = (
+          SECONDARY_AXIS_GANG(
+            IF_DISABLED(AXIS4_ROTATES, + sq(diff.i)),
+            IF_DISABLED(AXIS5_ROTATES, + sq(diff.j)),
+            IF_DISABLED(AXIS6_ROTATES, + sq(diff.k)),
+            IF_DISABLED(AXIS7_ROTATES, + sq(diff.u)),
+            IF_DISABLED(AXIS8_ROTATES, + sq(diff.v)),
+            IF_DISABLED(AXIS9_ROTATES, + sq(diff.w))
+          )
+        );
+      }
+    #endif
+
+    #if HAS_ROTATIONAL_AXES
+      if (UNEAR_ZERO(distance_sqr)) {
+        // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
+        is_cartesian_move = false;
+        distance_sqr = ROTATIONAL_AXIS_GANG(sq(diff.i), + sq(diff.j), + sq(diff.k), + sq(diff.u), + sq(diff.v), + sq(diff.w));
+      }
+    #endif
+
+  #endif
+
+  return SQRT(distance_sqr);
+}
+
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
      *
      * Longer segments result in less kinematic overhead
@@ -1102,30 +1184,39 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     // If the move is only in Z/E don't split up the move
     if (!diff.x && !diff.y) {
       planner.buffer_line(destination, scaled_fr_mm_s);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(destination)) return true;
 
     // Get the linear distance in XYZ
-    float cartesian_mm = xyz_float_t(diff).magnitude();
+    #if HAS_ROTATIONAL_AXES
+      bool cartes_move = true;
+    #endif
+    float cartesian_mm = get_move_distance(diff OPTARG(HAS_ROTATIONAL_AXES, cartes_move));
 
     // If the move is very short, check the E move distance
     TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
-    const float seconds = cartesian_mm / scaled_fr_mm_s;
+    const float seconds = cartesian_mm / (
+      #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+        cartes_move ? scaled_fr_mm_s : LINEAR_UNIT(scaled_fr_mm_s)
+      #else
+        scaled_fr_mm_s
+      #endif
+    );
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #elif ENABLED(POLAR)
       NOMORE(segments, cartesian_mm * RECIPROCAL(POLAR_MIN_SEGMENT_LENGTH));
@@ -1133,20 +1224,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments);
     const xyze_float_t segment_distance = diff * inv_segments;
 
     // Add hints to help optimize the move
     PlannerHints hints(cartesian_mm * inv_segments);
+    TERN_(HAS_ROTATIONAL_AXES, hints.cartesian_move = cartes_move);
     TERN_(FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
     /*
     SERIAL_ECHOPGM("mm=", cartesian_mm);
     SERIAL_ECHOPGM(" seconds=", seconds);
     SERIAL_ECHOPGM(" segments=", segments);
     SERIAL_ECHOPGM(" segment_mm=", hints.millimeters);
     SERIAL_EOL();
     //*/
 
@@ -1183,37 +1275,42 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
       const xyze_float_t diff = destination - current_position;
 
       // If the move is only in Z/E don't split up the move
       if (!diff.x && !diff.y) {
         planner.buffer_line(destination, fr_mm_s);
         return;
       }
 
       // Get the linear distance in XYZ
+      #if HAS_ROTATIONAL_AXES
+        bool cartes_move = true;
+      #endif
+      float cartesian_mm = get_move_distance(diff OPTARG(HAS_ROTATIONAL_AXES, cartes_move));
+
       // If the move is very short, check the E move distance
       // No E move either? Game over.
-      float cartesian_mm = diff.magnitude();
       TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments);
       const xyze_float_t segment_distance = diff * inv_segments;
 
       // Add hints to help optimize the move
       PlannerHints hints(cartesian_mm * inv_segments);
+      TERN_(HAS_ROTATIONAL_AXES, hints.cartesian_move = cartes_move);
       TERN_(FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
       //SERIAL_ECHOPGM("mm=", cartesian_mm);
       //SERIAL_ECHOLNPGM(" segments=", segments);
       //SERIAL_ECHOLNPGM(" segment_mm=", hints.millimeters);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7c90ae7159..b32368ca92 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -548,21 +548,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 
 /**
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
-void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
   SECONDARY_AXIS_CODE(
     const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS),
@@ -2274,39 +2274,32 @@ void prepare_line_to_destination() {
       set_axis_is_at_home(axis);
       sync_plan_position();
 
       destination[axis] = current_position[axis];
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
     #endif
 
     // Put away the Z probe
-    #if HOMING_Z_WITH_PROBE
-      if (axis == Z_AXIS && probe.stow()) return;
-    #endif
+    if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.stow())) return;
 
     #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
       const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
       if (endstop_backoff[axis]) {
         current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
-        line_to_current_position(
-          #if HOMING_Z_WITH_PROBE
-            (axis == Z_AXIS) ? z_probe_fast_mm_s :
-          #endif
-          homing_feedrate(axis)
-        );
+        line_to_current_position(TERN_(HOMING_Z_WITH_PROBE, (axis == Z_AXIS) ? z_probe_fast_mm_s :) homing_feedrate(axis));
 
         #if ENABLED(SENSORLESS_HOMING)
           planner.synchronize();
           if (false
-            #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
+            #ifdef NORMAL_AXIS
               || axis != NORMAL_AXIS
             #endif
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;
@@ -2399,15 +2392,15 @@ void set_axis_is_at_home(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
-  void set_home_offset(const AxisEnum axis, const float v) {
+  void set_home_offset(const AxisEnum axis, const_float_t v) {
     home_offset[axis] = v;
     update_workspace_offset(axis);
   }
 #endif

commit 738f0a10f532881204d567a6c07240ec8c3c3052
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Jan 30 22:12:03 2023 -0800

    ‚ú® POLARGRAPH / PEN_UP_DOWN_MENU (#25303)
    
    Co-authored-by: Dan Royer <1464454+i-make-robots@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a76bd967c0..7c90ae7159 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -919,20 +919,22 @@ void restore_feedrate_and_scaling() {
 
     if (!soft_endstop._enabled) return;
 
     #if IS_KINEMATIC
 
       if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
+      #elif ENABLED(POLARGRAPH)
+        // POLARGRAPH uses draw_area_* below...
       #elif ENABLED(POLAR)
         // For now, we don't limit POLAR
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
       #if ENABLED(POLARGRAPH)
         LIMIT(target.x, draw_area_min.x, draw_area_max.x);
         LIMIT(target.y, draw_area_min.y, draw_area_max.y);

commit 087e19a0ed4b769224d42cca83c8caccefce63c9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 30 22:11:50 2023 -0600

    üîß Fix build with no Y axis (#25311)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d440093b16..a76bd967c0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -354,21 +354,21 @@ void report_current_position_projected() {
       can_reach = HYPOT(rx, ry) <= PRINTABLE_RADIUS;
     #endif
 
     return can_reach;
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   bool position_is_reachable(const_float_t rx, const_float_t ry) {
-    if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
+    if (TERN0(HAS_Y_AXIS, !COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop))) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
       else
         return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
       return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
     #endif
   }
 
@@ -623,21 +623,21 @@ void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=
 
     // If Z needs to lower, do it after moving XY
     if (destination.z > z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
   #else
 
     #if HAS_Z_AXIS  // If Z needs to raise, do it before moving XY
       if (current_position.z < z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
-    current_position.set(x, y); line_to_current_position(xy_feedrate);
+    current_position.set(x OPTARG(HAS_Y_AXIS, y)); line_to_current_position(xy_feedrate);
 
     #if HAS_I_AXIS
       current_position.i = i; line_to_current_position(i_feedrate);
     #endif
     #if HAS_J_AXIS
       current_position.j = j; line_to_current_position(j_feedrate);
     #endif
     #if HAS_K_AXIS
       current_position.k = k; line_to_current_position(k_feedrate);
     #endif

commit fffc96661f53735691b6287c8bb90d0229dbfaae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 23 01:22:03 2023 -0600

    üêõ Fix homing_needed_error bits

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8b1a8b6e50..d440093b16 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1480,22 +1480,22 @@ void prepare_line_to_destination() {
     // Clear test bits that are trusted
     NUM_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
       set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(main_axes_bits_t axis_bits/*=main_axes_mask*/) {
-    if ((axis_bits = axes_should_home(axis_bits))) {
-      char all_axes[] = STR_AXES_MAIN, need[NUM_AXES];
+    if ((axis_bits &= axes_should_home(axis_bits))) {
+      char all_axes[] = STR_AXES_MAIN, need[NUM_AXES + 1];
       uint8_t n = 0;
       LOOP_NUM_AXES(i) if (TEST(axis_bits, i)) need[n++] = all_axes[i];
       need[n] = '\0';
 
       char msg[30];
       sprintf_P(msg, GET_EN_TEXT(MSG_HOME_FIRST), need);
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
 
       sprintf_P(msg, GET_TEXT(MSG_HOME_FIRST), need);

commit 7e72981b8cbaa7a6276f6833527e97cb10e060e7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 21 22:57:56 2023 -0600

    üö∏ Fix homing_needed_error language

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 39506e21d6..8b1a8b6e50 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1481,26 +1481,31 @@ void prepare_line_to_destination() {
     NUM_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
       set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(main_axes_bits_t axis_bits/*=main_axes_mask*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
-      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
+      char all_axes[] = STR_AXES_MAIN, need[NUM_AXES];
+      uint8_t n = 0;
+      LOOP_NUM_AXES(i) if (TEST(axis_bits, i)) need[n++] = all_axes[i];
+      need[n] = '\0';
+
       char msg[30];
-      #define _AXIS_CHAR(N) TEST(axis_bits, _AXIS(N)) ? STR_##N : ""
-      sprintf_P(msg, home_first, MAPLIST(_AXIS_CHAR, MAIN_AXIS_NAMES));
+      sprintf_P(msg, GET_EN_TEXT(MSG_HOME_FIRST), need);
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
+
+      sprintf_P(msg, GET_TEXT(MSG_HOME_FIRST), need);
       ui.set_status(msg);
       return true;
     }
     return false;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 17c607da08..39506e21d6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1411,26 +1411,22 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
  * before calling or cold/lengthy extrusion may get missed.
  *
  * Before exit, current_position is set to destination.
  */
 void prepare_line_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN) && destination.e != current_position.e) {
-      bool ignore_e = false;
-
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        ignore_e = thermalManager.tooColdToExtrude(active_extruder);
-        if (ignore_e) SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
-      #endif
+      bool ignore_e = thermalManager.tooColdToExtrude(active_extruder);
+      if (ignore_e) SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
 
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
         if (e_delta > (EXTRUDE_MAXLENGTH)) {
           #if ENABLED(MIXING_EXTRUDER)
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e) {
               if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) {
                 ignore_e = true;

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dadbfab297..17c607da08 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -31,20 +31,24 @@
 #include "temperature.h"
 #include "../gcode/gcode.h"
 #include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
+#if ENABLED(POLAR)
+  #include "polar.h"
+#endif
+
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
@@ -138,25 +142,28 @@ xyz_pos_t cartes;
 
   abce_pos_t delta;
 
   #if HAS_SCARA_OFFSET
     abc_pos_t scara_home_offset;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS
     float delta_max_radius, delta_max_radius_2;
   #elif IS_SCARA
-    constexpr float delta_max_radius = SCARA_PRINTABLE_RADIUS,
-                    delta_max_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
+    constexpr float delta_max_radius = PRINTABLE_RADIUS,
+                    delta_max_radius_2 = sq(PRINTABLE_RADIUS);
+  #elif ENABLED(POLAR)
+    constexpr float delta_max_radius = PRINTABLE_RADIUS,
+                    delta_max_radius_2 = sq(PRINTABLE_RADIUS);
   #else // DELTA
-    constexpr float delta_max_radius = DELTA_PRINTABLE_RADIUS,
-                    delta_max_radius_2 = sq(DELTA_PRINTABLE_RADIUS);
+    constexpr float delta_max_radius = PRINTABLE_RADIUS,
+                    delta_max_radius_2 = sq(PRINTABLE_RADIUS);
   #endif
 
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
 #if HAS_POSITION_SHIFT
   // The distance that XYZ has been offset by G92. Reset by G28.
@@ -176,20 +183,21 @@ xyz_pos_t cartes;
   feedRate_t xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_FEEDRATE);
 #endif
 
 /**
  * Output the current position to serial
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
+  TERN_(POLAR, polar_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPGM_P(
     LIST_N(DOUBLE(NUM_AXES),
          X_LBL, lpos.x,
       SP_Y_LBL, lpos.y,
       SP_Z_LBL, lpos.z,
@@ -270,22 +278,21 @@ void report_current_position_projected() {
         SP_K_LBL, lpos.k,
         SP_U_LBL, lpos.u,
         SP_V_LBL, lpos.v,
         SP_W_LBL, lpos.w
       )
       #if HAS_EXTRUDERS
         , SP_E_LBL, current_position.e
       #endif
     );
 
-    stepper.report_positions();
-    TERN_(IS_SCARA, scara_report_positions());
+    report_more_positions();
     report_current_grblstate_moving();
   }
 
   /**
    * Set a Grbl-compatible state from the current marlin_state
    */
   M_StateEnum grbl_state_for_marlin_state() {
     switch (marlin_state) {
       case MF_INITIALIZING: return M_INIT;
       case MF_SD_COMPLETE:  return M_ALARM;
@@ -301,21 +308,21 @@ void report_current_position_projected() {
 #endif
 
 #if IS_KINEMATIC
 
   bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset/*=0*/) {
 
     bool can_reach;
 
     #if ENABLED(DELTA)
 
-      can_reach = HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
+      can_reach = HYPOT2(rx, ry) <= sq(PRINTABLE_RADIUS - inset + fslop);
 
     #elif ENABLED(AXEL_TPARA)
 
       const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
       can_reach = (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
@@ -336,20 +343,22 @@ void report_current_position_projected() {
                   d2 = (draw_area_max.x) - rx,
                    y = ry - (draw_area_max.y),
                    a = HYPOT(d1, y),
                    b = HYPOT(d2, y);
 
       can_reach = (
            a < polargraph_max_belt_len + 1
         && b < polargraph_max_belt_len + 1
       );
 
+    #elif ENABLED(POLAR)
+      can_reach = HYPOT(rx, ry) <= PRINTABLE_RADIUS;
     #endif
 
     return can_reach;
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   bool position_is_reachable(const_float_t rx, const_float_t ry) {
     if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
@@ -419,20 +428,23 @@ void sync_plan_position() {
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics(planner.get_axis_positions_mm());
   #elif IS_SCARA
     forward_kinematics(
       planner.get_axis_position_degrees(A_AXIS), planner.get_axis_position_degrees(B_AXIS)
       OPTARG(AXEL_TPARA, planner.get_axis_position_degrees(C_AXIS))
     );
     cartes.z = planner.get_axis_position_mm(Z_AXIS);
+  #elif ENABLED(POLAR)
+    forward_kinematics(planner.get_axis_position_mm(X_AXIS), planner.get_axis_position_degrees(B_AXIS));
+    cartes.z = planner.get_axis_position_mm(Z_AXIS);
   #else
     NUM_AXIS_CODE(
       cartes.x = planner.get_axis_position_mm(X_AXIS),
       cartes.y = planner.get_axis_position_mm(Y_AXIS),
       cartes.z = planner.get_axis_position_mm(Z_AXIS),
       cartes.i = planner.get_axis_position_mm(I_AXIS),
       cartes.j = planner.get_axis_position_mm(J_AXIS),
       cartes.k = planner.get_axis_position_mm(K_AXIS),
       cartes.u = planner.get_axis_position_mm(U_AXIS),
       cartes.v = planner.get_axis_position_mm(V_AXIS),
@@ -907,28 +919,32 @@ void restore_feedrate_and_scaling() {
 
     if (!soft_endstop._enabled) return;
 
     #if IS_KINEMATIC
 
       if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
+      #elif ENABLED(POLAR)
+        // For now, we don't limit POLAR
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
       #if ENABLED(POLARGRAPH)
         LIMIT(target.x, draw_area_min.x, draw_area_max.x);
         LIMIT(target.y, draw_area_min.y, draw_area_max.y);
+      #elif ENABLED(POLAR)
+        // Motion limits are as same as cartesian limits.
       #else
         if (TERN1(IS_SCARA, axis_was_homed(X_AXIS) && axis_was_homed(Y_AXIS))) {
           const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
           if (dist_2 > delta_max_radius_2)
             target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
         }
       #endif
 
     #else
 
@@ -1048,20 +1064,22 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
      *
      * Longer segments result in less kinematic overhead
      * but may produce jagged lines. Try 0.5mm, 1.0mm, and 2.0mm
      * and compare the difference.
      */
     #define SCARA_MIN_SEGMENT_LENGTH 0.5f
+  #elif ENABLED(POLAR)
+    #define POLAR_MIN_SEGMENT_LENGTH 0.5f
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * Called from prepare_line_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
@@ -1100,32 +1118,34 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / scaled_fr_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
+    #elif ENABLED(POLAR)
+      NOMORE(segments, cartesian_mm * RECIPROCAL(POLAR_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments);
     const xyze_float_t segment_distance = diff * inv_segments;
 
     // Add hints to help optimize the move
     PlannerHints hints(cartesian_mm * inv_segments);
-    TERN_(SCARA_FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
+    TERN_(FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
     /*
     SERIAL_ECHOPGM("mm=", cartesian_mm);
     SERIAL_ECHOPGM(" seconds=", seconds);
     SERIAL_ECHOPGM(" segments=", segments);
     SERIAL_ECHOPGM(" segment_mm=", hints.millimeters);
     SERIAL_EOL();
     //*/
 
     // Get the current position as starting point
@@ -1178,21 +1198,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments);
       const xyze_float_t segment_distance = diff * inv_segments;
 
       // Add hints to help optimize the move
       PlannerHints hints(cartesian_mm * inv_segments);
-      TERN_(SCARA_FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
+      TERN_(FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
       //SERIAL_ECHOPGM("mm=", cartesian_mm);
       //SERIAL_ECHOLNPGM(" segments=", segments);
       //SERIAL_ECHOLNPGM(" segment_mm=", hints.millimeters);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;

commit 5a80fc261736f6e88ec87b5544228383e2937894
Author: Dan Royer <dan@marginallyclever.com>
Date:   Sat Oct 15 22:03:42 2022 -0700

    üêõ Fix and improve Polargraph (#24847)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c0503c621d..dadbfab297 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -334,21 +334,20 @@ void report_current_position_projected() {
 
       const float d1 = rx - (draw_area_min.x),
                   d2 = (draw_area_max.x) - rx,
                    y = ry - (draw_area_max.y),
                    a = HYPOT(d1, y),
                    b = HYPOT(d2, y);
 
       can_reach = (
            a < polargraph_max_belt_len + 1
         && b < polargraph_max_belt_len + 1
-        && (a + b) > _MIN(draw_area_size.x, draw_area_size.y)
       );
 
     #endif
 
     return can_reach;
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
@@ -555,21 +554,22 @@ void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=
   #endif
   SECONDARY_AXIS_CODE(
     const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS),
     const feedRate_t j_feedrate = fr_mm_s ?: homing_feedrate(J_AXIS),
     const feedRate_t k_feedrate = fr_mm_s ?: homing_feedrate(K_AXIS),
     const feedRate_t u_feedrate = fr_mm_s ?: homing_feedrate(U_AXIS),
     const feedRate_t v_feedrate = fr_mm_s ?: homing_feedrate(V_AXIS),
     const feedRate_t w_feedrate = fr_mm_s ?: homing_feedrate(W_AXIS)
   );
 
-  #if IS_KINEMATIC
+  #if IS_KINEMATIC && DISABLED(POLARGRAPH)
+    // kinematic machines are expected to home to a point 1.5x their range? never reachable.
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 
@@ -912,25 +912,30 @@ void restore_feedrate_and_scaling() {
       if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
-      if (TERN1(IS_SCARA, axis_was_homed(X_AXIS) && axis_was_homed(Y_AXIS))) {
-        const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
-        if (dist_2 > delta_max_radius_2)
-          target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
-      }
+      #if ENABLED(POLARGRAPH)
+        LIMIT(target.x, draw_area_min.x, draw_area_max.x);
+        LIMIT(target.y, draw_area_min.y, draw_area_max.y);
+      #else
+        if (TERN1(IS_SCARA, axis_was_homed(X_AXIS) && axis_was_homed(Y_AXIS))) {
+          const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
+          if (dist_2 > delta_max_radius_2)
+            target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
+        }
+      #endif
 
     #else
 
       if (axis_was_homed(X_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
           NOLESS(target.x, soft_endstop.min.x);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
           NOMORE(target.x, soft_endstop.max.x);
         #endif

commit 458e1aea41db013a979019c32ca2b3c2c3806bc6
Author: studiodyne <diabolomix@hotmail.fr>
Date:   Sun Aug 28 00:43:32 2022 +0200

    ‚ú® XY_COUNTERPART_BACKOFF_MM

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6101022fd4..c0503c621d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1987,20 +1987,31 @@ void prepare_line_to_destination() {
     //
     #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
       const xyz_float_t backoff = SENSORLESS_BACKOFF_MM;
       if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS) || TERN0(Z_SENSORLESS, axis == Z_AXIS) || TERN0(I_SENSORLESS, axis == I_AXIS) || TERN0(J_SENSORLESS, axis == J_AXIS) || TERN0(K_SENSORLESS, axis == K_AXIS)) && backoff[axis]) {
         const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Sensorless backoff: ", backoff_length, "mm");
         do_homing_move(axis, backoff_length, homing_feedrate(axis));
       }
     #endif
 
+    //
+    // Back away to prevent opposite endstop damage
+    //
+    #if !defined(SENSORLESS_BACKOFF_MM) && XY_COUNTERPART_BACKOFF_MM
+      if (!(axis_was_homed(X_AXIS) || axis_was_homed(Y_AXIS)) && (axis == X_AXIS || axis == Y_AXIS)) {
+        const AxisEnum opposite_axis = axis == X_AXIS ? Y_AXIS : X_AXIS;
+        const float backoff_length = -ABS(XY_COUNTERPART_BACKOFF_MM) * home_dir(opposite_axis);
+        do_homing_move(opposite_axis, backoff_length, homing_feedrate(opposite_axis));
+      }
+    #endif
+
     // Determine if a homing bump will be done and the bumps distance
     // When homing Z with probe respect probe clearance
     const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(axis));
     const float bump = axis_home_dir * (
       use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(axis)) : home_bump_mm(axis)
     );
 
     //
     // Fast move towards endstop until triggered
     //

commit d8df9ffd61b112a21a1946a9b120e806886aa54e
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jul 31 03:49:15 2022 +0200

    üêõ Fix kinematic feedrate (#24568)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 0bf6dfb7d9..6101022fd4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1077,21 +1077,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     // If the move is only in Z/E don't split up the move
     if (!diff.x && !diff.y) {
       planner.buffer_line(destination, scaled_fr_mm_s);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(destination)) return true;
 
     // Get the linear distance in XYZ
-    float cartesian_mm = diff.magnitude();
+    float cartesian_mm = xyz_float_t(diff).magnitude();
 
     // If the move is very short, check the E move distance
     TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / scaled_fr_mm_s;
 

commit 9706cd0d7dc9e09faec2ed2b5ec106dbd22e5c61
Author: Arthur Masson <arthur.sw@gmail.com>
Date:   Sat Jul 16 23:58:18 2022 +0200

    ‚ú® Polargraph M665 settings (#24401)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index eaf3ab5409..0bf6dfb7d9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -293,20 +293,87 @@ void report_current_position_projected() {
       case MF_STOPPED:      return M_END;
       case MF_RUNNING:      return M_RUNNING;
       case MF_PAUSED:       return M_HOLD;
       case MF_KILLED:       return M_ERROR;
       default:              return M_IDLE;
     }
   }
 
 #endif
 
+#if IS_KINEMATIC
+
+  bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset/*=0*/) {
+
+    bool can_reach;
+
+    #if ENABLED(DELTA)
+
+      can_reach = HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
+
+    #elif ENABLED(AXEL_TPARA)
+
+      const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
+      can_reach = (
+        R2 <= sq(L1 + L2) - inset
+        #if MIDDLE_DEAD_ZONE_R > 0
+          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+        #endif
+      );
+
+    #elif IS_SCARA
+
+      const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
+      can_reach = (
+        R2 <= sq(L1 + L2) - inset
+        #if MIDDLE_DEAD_ZONE_R > 0
+          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+        #endif
+      );
+
+    #elif ENABLED(POLARGRAPH)
+
+      const float d1 = rx - (draw_area_min.x),
+                  d2 = (draw_area_max.x) - rx,
+                   y = ry - (draw_area_max.y),
+                   a = HYPOT(d1, y),
+                   b = HYPOT(d2, y);
+
+      can_reach = (
+           a < polargraph_max_belt_len + 1
+        && b < polargraph_max_belt_len + 1
+        && (a + b) > _MIN(draw_area_size.x, draw_area_size.y)
+      );
+
+    #endif
+
+    return can_reach;
+  }
+
+#else // CARTESIAN
+
+  // Return true if the given position is within the machine bounds.
+  bool position_is_reachable(const_float_t rx, const_float_t ry) {
+    if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (active_extruder)
+        return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
+      else
+        return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
+    #else
+      return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
+    #endif
+  }
+
+#endif // CARTESIAN
+
+
 void home_if_needed(const bool keeplev/*=false*/) {
   if (!all_axes_trusted()) gcode.home_all_axes(keeplev);
 }
 
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b3b607e677..eaf3ab5409 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1034,49 +1034,49 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
-    const float inv_segments = 1.0f / float(segments),
-                cartesian_segment_mm = cartesian_mm * inv_segments;
+    const float inv_segments = 1.0f / float(segments);
     const xyze_float_t segment_distance = diff * inv_segments;
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
-    #endif
+    // Add hints to help optimize the move
+    PlannerHints hints(cartesian_mm * inv_segments);
+    TERN_(SCARA_FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
     /*
     SERIAL_ECHOPGM("mm=", cartesian_mm);
     SERIAL_ECHOPGM(" seconds=", seconds);
     SERIAL_ECHOPGM(" segments=", segments);
-    SERIAL_ECHOPGM(" segment_mm=", cartesian_segment_mm);
+    SERIAL_ECHOPGM(" segment_mm=", hints.millimeters);
     SERIAL_EOL();
     //*/
 
     // Get the current position as starting point
     xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
     millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
       segment_idle(next_idle_ms);
       raw += segment_distance;
-      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
+      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints))
+        break;
     }
 
     // Ensure last segment arrives at target location.
-    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
+    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, hints);
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES) && DISABLED(AUTO_BED_LEVELING_UBL)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
@@ -1101,46 +1101,46 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
       float cartesian_mm = diff.magnitude();
       TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
-      const float inv_segments = 1.0f / float(segments),
-                  cartesian_segment_mm = cartesian_mm * inv_segments;
+      const float inv_segments = 1.0f / float(segments);
       const xyze_float_t segment_distance = diff * inv_segments;
 
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
-      #endif
+      // Add hints to help optimize the move
+      PlannerHints hints(cartesian_mm * inv_segments);
+      TERN_(SCARA_FEEDRATE_SCALING, hints.inv_duration = scaled_fr_mm_s / hints.millimeters);
 
       //SERIAL_ECHOPGM("mm=", cartesian_mm);
       //SERIAL_ECHOLNPGM(" segments=", segments);
-      //SERIAL_ECHOLNPGM(" segment_mm=", cartesian_segment_mm);
+      //SERIAL_ECHOLNPGM(" segment_mm=", hints.millimeters);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
-        if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
+        if (!planner.buffer_line(raw, fr_mm_s, active_extruder, hints))
+          break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
-      planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
+      planner.buffer_line(destination, fr_mm_s, active_extruder, hints);
     }
 
   #endif // SEGMENT_LEVELED_MOVES && !AUTO_BED_LEVELING_UBL
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 36afdb2e48..b3b607e677 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -959,21 +959,21 @@ void restore_feedrate_and_scaling() {
   soft_endstops_t soft_endstop;
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   const millis_t ms = millis();
   if (ELAPSED(ms, next_idle_ms)) {
     next_idle_ms = ms + 200UL;
     return idle();
   }
-  thermalManager.manage_heater();  // Returns immediately on most calls
+  thermalManager.task();  // Returns immediately on most calls
 }
 
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.

commit 3522d5376cbf03658b71ddaf8c341e35f59b369b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 20:55:15 2022 -0500

    ü©π Wrap SENSORLESS_STALLGUARD_DELAY

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b5061f637b..36afdb2e48 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1658,21 +1658,23 @@ void prepare_line_to_destination() {
           // Wait for the hotend to heat back up between probing points
           thermalManager.wait_for_hotend_heating(active_extruder);
         #endif
 
         TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
       }
 
       // Disable stealthChop if used. Enable diag1 pin on driver.
       #if ENABLED(SENSORLESS_HOMING)
         stealth_states = start_sensorless_homing_per_axis(axis);
-        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+        #if SENSORLESS_STALLGUARD_DELAY
+          safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+        #endif
       #endif
     }
 
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Tell the planner the axis is at 0
       current_position[axis] = 0;
       sync_plan_position();
       current_position[axis] = distance;
       line_to_current_position(home_fr_mm_s);
     #else
@@ -1697,21 +1699,23 @@ void prepare_line_to_destination() {
 
       #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
         if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
       #endif
 
       endstops.validate_homing_move();
 
       // Re-enable stealthChop if used. Disable diag1 pin on driver.
       #if ENABLED(SENSORLESS_HOMING)
         end_sensorless_homing_per_axis(axis, stealth_states);
-        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+        #if SENSORLESS_STALLGUARD_DELAY
+          safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+        #endif
       #endif
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b7c48783d1..b5061f637b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1656,21 +1656,24 @@ void prepare_line_to_destination() {
 
         #if BOTH(HAS_HOTEND, WAIT_FOR_HOTEND)
           // Wait for the hotend to heat back up between probing points
           thermalManager.wait_for_hotend_heating(active_extruder);
         #endif
 
         TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
       }
 
       // Disable stealthChop if used. Enable diag1 pin on driver.
-      TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
+      #if ENABLED(SENSORLESS_HOMING)
+        stealth_states = start_sensorless_homing_per_axis(axis);
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
     }
 
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Tell the planner the axis is at 0
       current_position[axis] = 0;
       sync_plan_position();
       current_position[axis] = distance;
       line_to_current_position(home_fr_mm_s);
     #else
       // Get the ABC or XYZ positions in mm
@@ -1692,21 +1695,24 @@ void prepare_line_to_destination() {
 
     if (is_home_dir) {
 
       #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
         if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
       #endif
 
       endstops.validate_homing_move();
 
       // Re-enable stealthChop if used. Disable diag1 pin on driver.
-      TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
+      #if ENABLED(SENSORLESS_HOMING)
+        end_sensorless_homing_per_axis(axis, stealth_states);
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");

commit 1f322b565f409ab5068e225a4d9a929907c966f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 26 18:31:05 2022 -0500

    ‚ôªÔ∏è More updates for multi-axis

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5d78df4859..b7c48783d1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1375,53 +1375,42 @@ void prepare_line_to_destination() {
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
 #if HAS_ENDSTOPS
 
-  linear_axis_bits_t axis_homed, axis_trusted; // = 0
+  main_axes_bits_t axes_homed, axes_trusted; // = 0
 
-  linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits/*=linear_bits*/) {
-    auto set_should = [](linear_axis_bits_t &b, AxisEnum a) {
+  main_axes_bits_t axes_should_home(main_axes_bits_t axis_bits/*=main_axes_mask*/) {
+    auto set_should = [](main_axes_bits_t &b, AxisEnum a) {
       if (TEST(b, a) && TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(a))
         CBI(b, a);
     };
     // Clear test bits that are trusted
     NUM_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
       set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
-  bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
+  bool homing_needed_error(main_axes_bits_t axis_bits/*=main_axes_mask*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[30];
-      sprintf_P(msg, home_first,
-        NUM_AXIS_LIST(
-          TEST(axis_bits, X_AXIS) ? STR_A : "",
-          TEST(axis_bits, Y_AXIS) ? STR_B : "",
-          TEST(axis_bits, Z_AXIS) ? STR_C : "",
-          TEST(axis_bits, I_AXIS) ? STR_I : "",
-          TEST(axis_bits, J_AXIS) ? STR_J : "",
-          TEST(axis_bits, K_AXIS) ? STR_K : "",
-          TEST(axis_bits, U_AXIS) ? STR_U : "",
-          TEST(axis_bits, V_AXIS) ? STR_V : "",
-          TEST(axis_bits, W_AXIS) ? STR_W : ""
-        )
-      );
+      #define _AXIS_CHAR(N) TEST(axis_bits, _AXIS(N)) ? STR_##N : ""
+      sprintf_P(msg, home_first, MAPLIST(_AXIS_CHAR, MAIN_AXIS_NAMES));
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
       ui.set_status(msg);
       return true;
     }
     return false;
   }
 
   /**
    * Homing bump feedrate (mm/s)

commit a93146b71d723e6cd0520fc0b0c75752d59d190f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 22 16:53:12 2022 -0500

    üêõ Fix SEGMENT_LEVELED_MOVES with UBL

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a824f56d93..5d78df4859 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -953,22 +953,20 @@ void restore_feedrate_and_scaling() {
       }
     #endif
   }
 
 #else // !HAS_SOFTWARE_ENDSTOPS
 
   soft_endstops_t soft_endstop;
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
-#if !UBL_SEGMENTED
-
 FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   const millis_t ms = millis();
   if (ELAPSED(ms, next_idle_ms)) {
     next_idle_ms = ms + 200UL;
     return idle();
   }
   thermalManager.manage_heater();  // Returns immediately on most calls
 }
 
 #if IS_KINEMATIC
@@ -1071,21 +1069,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     }
 
     // Ensure last segment arrives at target location.
     planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
-  #if ENABLED(SEGMENT_LEVELED_MOVES)
+  #if ENABLED(SEGMENT_LEVELED_MOVES) && DISABLED(AUTO_BED_LEVELING_UBL)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
      *
      * This calls planner.buffer_line several times, adding
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
     inline void segmented_line_to_destination(const_feedRate_t fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
@@ -1131,37 +1129,41 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
       planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
     }
 
-  #endif // SEGMENT_LEVELED_MOVES
+  #endif // SEGMENT_LEVELED_MOVES && !AUTO_BED_LEVELING_UBL
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
    * Return true if 'current_position' was set to 'destination'
    */
   inline bool line_to_destination_cartesian() {
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
     #if HAS_MESH
       if (planner.leveling_active && planner.leveling_active_at_z(destination.z)) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          bedlevel.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
-          return true;                                                        // all moves, including Z-only moves.
+          #if UBL_SEGMENTED
+            return bedlevel.line_to_destination_segmented(scaled_fr_mm_s);
+          #else
+            bedlevel.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
+            return true;                                                             // all moves, including Z-only moves.
+          #endif
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(scaled_fr_mm_s);
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (xy_pos_t(current_position) != xy_pos_t(destination)) {
             #if ENABLED(MESH_BED_LEVELING)
@@ -1173,21 +1175,20 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
           }
         #endif
       }
     #endif // HAS_MESH
 
     planner.buffer_line(destination, scaled_fr_mm_s);
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
-#endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
   bool extruder_duplication_enabled;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     uint8_t duplication_e_mask; // = 0
   #endif
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 

commit c5126de559719ebdaf4475b0db4ab21c26b90a1a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 16:08:29 2022 -0500

    üßë‚Äçüíª MAP macro for axis lists, etc. (#24191)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e231a41005..a824f56d93 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -731,24 +731,26 @@ void remember_feedrate_scaling_off() {
   feedrate_percentage = 100;
 }
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
+  #define _AMIN(A) A##_MIN_POS
+  #define _AMAX(A) A##_MAX_POS
   soft_endstops_t soft_endstop = {
     true, false,
-    NUM_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS, I_MIN_POS, J_MIN_POS, K_MIN_POS, U_MIN_POS, V_MIN_POS, W_MIN_POS),
-    NUM_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS, I_MAX_POS, J_MAX_POS, K_MAX_POS, U_MAX_POS, V_MAX_POS, W_MAX_POS)
+    { MAPLIST(_AMIN, MAIN_AXIS_NAMES) },
+    { MAPLIST(_AMAX, MAIN_AXIS_NAMES) },
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -1870,31 +1872,22 @@ void prepare_line_to_destination() {
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || TERN0(HAS_Z_AXIS, TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)) \
         || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
         || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
       ))
-      if (NUM_AXIS_GANG(
-           !_CAN_HOME(X),
-        && !_CAN_HOME(Y),
-        && !_CAN_HOME(Z),
-        && !_CAN_HOME(I),
-        && !_CAN_HOME(J),
-        && !_CAN_HOME(K),
-        && !_CAN_HOME(U),
-        && !_CAN_HOME(V),
-        && !_CAN_HOME(W))
-      ) return;
+      #define _ANDCANT(N) && !_CAN_HOME(N)
+      if (true MAIN_AXIS_MAP(_ANDCANT)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a07d8e22b4..e231a41005 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -420,21 +420,21 @@ void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
 #if IS_KINEMATIC
 
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
    */
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // UBL segmented line will do Z-only moves in single segment
-      ubl.line_to_destination_segmented(scaled_fr_mm_s);
+      bedlevel.line_to_destination_segmented(scaled_fr_mm_s);
     #else
       if (current_position == destination) return;
 
       planner.buffer_line(destination, scaled_fr_mm_s);
     #endif
 
     current_position = destination;
   }
 
 #endif // IS_KINEMATIC
@@ -988,21 +988,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * Called from prepare_line_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    *
    * For Unified Bed Leveling (Delta or Segmented Cartesian)
-   * the ubl.line_to_destination_segmented method replaces this.
+   * the bedlevel.line_to_destination_segmented method replaces this.
    *
    * For Auto Bed Leveling (Bilinear) with SEGMENT_LEVELED_MOVES
    * this is replaced by segmented_line_to_destination below.
    */
   inline bool line_to_destination_kinematic() {
 
     // Get the top feedrate of the move in the XY plane
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
     const xyze_float_t diff = destination - current_position;
@@ -1144,35 +1144,35 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
    * Return true if 'current_position' was set to 'destination'
    */
   inline bool line_to_destination_cartesian() {
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
     #if HAS_MESH
       if (planner.leveling_active && planner.leveling_active_at_z(destination.z)) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
+          bedlevel.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
           return true;                                                        // all moves, including Z-only moves.
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(scaled_fr_mm_s);
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (xy_pos_t(current_position) != xy_pos_t(destination)) {
             #if ENABLED(MESH_BED_LEVELING)
-              mbl.line_to_destination(scaled_fr_mm_s);
+              bedlevel.line_to_destination(scaled_fr_mm_s);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-              bbl.line_to_destination(scaled_fr_mm_s);
+              bedlevel.line_to_destination(scaled_fr_mm_s);
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
     planner.buffer_line(destination, scaled_fr_mm_s);
     return false; // caller will update current_position
   }
@@ -1356,21 +1356,21 @@ void prepare_line_to_destination() {
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   if (TERN0(DUAL_X_CARRIAGE, dual_x_carriage_unpark())) return;
 
   if (
     #if UBL_SEGMENTED
       #if IS_KINEMATIC // UBL using Kinematic / Cartesian cases as a workaround for now.
-        ubl.line_to_destination_segmented(MMS_SCALED(feedrate_mm_s))
+        bedlevel.line_to_destination_segmented(MMS_SCALED(feedrate_mm_s))
       #else
         line_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8bdf97c0e1..a07d8e22b4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -2031,64 +2031,64 @@ void prepare_line_to_destination() {
             do_homing_move(axis, pos_dir ? -adj : adj);
             stepper.set_y_lock(false);
             stepper.set_y2_lock(false);
           }
         }
       #endif
 
       #if ENABLED(Z_MULTI_ENDSTOPS)
         if (axis == Z_AXIS) {
 
-          #if NUM_Z_STEPPER_DRIVERS == 2
+          #if NUM_Z_STEPPERS == 2
 
             const float adj = ABS(endstops.z2_endstop_adj);
             if (adj) {
               if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z1_lock(true); else stepper.set_z2_lock(true);
               do_homing_move(axis, pos_dir ? -adj : adj);
               stepper.set_z1_lock(false);
               stepper.set_z2_lock(false);
             }
 
           #else
 
             // Handy arrays of stepper lock function pointers
 
             typedef void (*adjustFunc_t)(const bool);
 
             adjustFunc_t lock[] = {
               stepper.set_z1_lock, stepper.set_z2_lock, stepper.set_z3_lock
-              #if NUM_Z_STEPPER_DRIVERS >= 4
+              #if NUM_Z_STEPPERS >= 4
                 , stepper.set_z4_lock
               #endif
             };
             float adj[] = {
               0, endstops.z2_endstop_adj, endstops.z3_endstop_adj
-              #if NUM_Z_STEPPER_DRIVERS >= 4
+              #if NUM_Z_STEPPERS >= 4
                 , endstops.z4_endstop_adj
               #endif
             };
 
             adjustFunc_t tempLock;
             float tempAdj;
 
             // Manual bubble sort by adjust value
             if (adj[1] < adj[0]) {
               tempLock = lock[0], tempAdj = adj[0];
               lock[0] = lock[1], adj[0] = adj[1];
               lock[1] = tempLock, adj[1] = tempAdj;
             }
             if (adj[2] < adj[1]) {
               tempLock = lock[1], tempAdj = adj[1];
               lock[1] = lock[2], adj[1] = adj[2];
               lock[2] = tempLock, adj[2] = tempAdj;
             }
-            #if NUM_Z_STEPPER_DRIVERS >= 4
+            #if NUM_Z_STEPPERS >= 4
               if (adj[3] < adj[2]) {
                 tempLock = lock[2], tempAdj = adj[2];
                 lock[2] = lock[3], adj[2] = adj[3];
                 lock[3] = tempLock, adj[3] = tempAdj;
               }
               if (adj[2] < adj[1]) {
                 tempLock = lock[1], tempAdj = adj[1];
                 lock[1] = lock[2], adj[1] = adj[2];
                 lock[2] = tempLock, adj[2] = tempAdj;
               }
@@ -2099,41 +2099,41 @@ void prepare_line_to_destination() {
               lock[1] = tempLock, adj[1] = tempAdj;
             }
 
             if (pos_dir) {
               // normalize adj to smallest value and do the first move
               (*lock[0])(true);
               do_homing_move(axis, adj[1] - adj[0]);
               // lock the second stepper for the final correction
               (*lock[1])(true);
               do_homing_move(axis, adj[2] - adj[1]);
-              #if NUM_Z_STEPPER_DRIVERS >= 4
+              #if NUM_Z_STEPPERS >= 4
                 // lock the third stepper for the final correction
                 (*lock[2])(true);
                 do_homing_move(axis, adj[3] - adj[2]);
               #endif
             }
             else {
-              #if NUM_Z_STEPPER_DRIVERS >= 4
+              #if NUM_Z_STEPPERS >= 4
                 (*lock[3])(true);
                 do_homing_move(axis, adj[2] - adj[3]);
               #endif
               (*lock[2])(true);
               do_homing_move(axis, adj[1] - adj[2]);
               (*lock[1])(true);
               do_homing_move(axis, adj[0] - adj[1]);
             }
 
             stepper.set_z1_lock(false);
             stepper.set_z2_lock(false);
             stepper.set_z3_lock(false);
-            #if NUM_Z_STEPPER_DRIVERS >= 4
+            #if NUM_Z_STEPPERS >= 4
               stepper.set_z4_lock(false);
             #endif
 
           #endif
         }
       #endif
 
       // Reset flags for X, Y, Z motor locking
       switch (axis) {
         default: break;

commit b37d13af7278c241064b61279e7e8538a03206a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 29 15:21:15 2022 -0500

    üîß Base NUM_AXES on defined DRIVER_TYPEs (#24106)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5195ad400f..8bdf97c0e1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1747,85 +1747,85 @@ void prepare_line_to_destination() {
               stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
 
       #define PHASE_PER_MICROSTEP(N) (256 / _MAX(1, N##_MICROSTEPS))
 
       switch (axis) {
         #ifdef X_MICROSTEPS
           case X_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(X);
             phaseCurrent = stepperX.get_microstep_counter();
             effectorBackoutDir = -X_HOME_DIR;
-            stepperBackoutDir = INVERT_X_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_X_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef Y_MICROSTEPS
           case Y_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(Y);
             phaseCurrent = stepperY.get_microstep_counter();
             effectorBackoutDir = -Y_HOME_DIR;
-            stepperBackoutDir = INVERT_Y_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_Y_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef Z_MICROSTEPS
           case Z_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(Z);
             phaseCurrent = stepperZ.get_microstep_counter();
             effectorBackoutDir = -Z_HOME_DIR;
-            stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_Z_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef I_MICROSTEPS
           case I_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(I);
             phaseCurrent = stepperI.get_microstep_counter();
             effectorBackoutDir = -I_HOME_DIR;
-            stepperBackoutDir = INVERT_I_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_I_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef J_MICROSTEPS
           case J_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(J);
             phaseCurrent = stepperJ.get_microstep_counter();
             effectorBackoutDir = -J_HOME_DIR;
-            stepperBackoutDir = INVERT_J_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_J_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef K_MICROSTEPS
           case K_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(K);
             phaseCurrent = stepperK.get_microstep_counter();
             effectorBackoutDir = -K_HOME_DIR;
-            stepperBackoutDir = INVERT_K_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_K_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef U_MICROSTEPS
           case U_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(U);
             phaseCurrent = stepperU.get_microstep_counter();
             effectorBackoutDir = -U_HOME_DIR;
-            stepperBackoutDir = INVERT_U_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_U_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef V_MICROSTEPS
           case V_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(V);
             phaseCurrent = stepperV.get_microstep_counter();
             effectorBackoutDir = -V_HOME_DIR;
-            stepperBackoutDir = INVERT_V_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_V_DIR, -)effectorBackoutDir;
             break;
         #endif
         #ifdef W_MICROSTEPS
           case W_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(W);
             phaseCurrent = stepperW.get_microstep_counter();
             effectorBackoutDir = -W_HOME_DIR;
-            stepperBackoutDir = INVERT_W_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            stepperBackoutDir = IF_DISABLED(INVERT_W_DIR, -)effectorBackoutDir;
             break;
         #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.mm_per_step[axis] / phasePerUStep < 0.05f)

commit 2dcfa140e9bcce81fd383b6401965aeaa04fdaf9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 21 07:08:26 2022 -0500

    üé®  misc. cleanup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f3ca075c80..5195ad400f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -234,21 +234,20 @@ void report_current_position() {
  * The planner.position always corresponds to the last G-code too. This makes M114
  * suitable for debugging kinematics and leveling while avoiding planner sync that
  * definitively interrupts the printing flow.
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
 #if ENABLED(AUTO_REPORT_POSITION)
-  //struct PositionReport { void report() { report_current_position_projected(); } };
   AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
 #if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
 
   M_StateEnum M_State_grbl = M_INIT;
 
   /**
    * Output the current grbl compatible state to serial while moving
    */

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f0c7281a41..f3ca075c80 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1392,21 +1392,21 @@ void prepare_line_to_destination() {
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
       set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
-      char msg[strlen_P(home_first)+1];
+      char msg[30];
       sprintf_P(msg, home_first,
         NUM_AXIS_LIST(
           TEST(axis_bits, X_AXIS) ? STR_A : "",
           TEST(axis_bits, Y_AXIS) ? STR_B : "",
           TEST(axis_bits, Z_AXIS) ? STR_C : "",
           TEST(axis_bits, I_AXIS) ? STR_I : "",
           TEST(axis_bits, J_AXIS) ? STR_J : "",
           TEST(axis_bits, K_AXIS) ? STR_K : "",
           TEST(axis_bits, U_AXIS) ? STR_U : "",
           TEST(axis_bits, V_AXIS) ? STR_V : "",

commit b19f745659b4799deb2252c933b039b892b187bd
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Apr 10 07:39:04 2022 +0700

    ‚ôªÔ∏è Bilinear refactor followup (#24009)
    
    Followup to #23868

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3037c38bb0..f0c7281a41 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1159,21 +1159,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (xy_pos_t(current_position) != xy_pos_t(destination)) {
             #if ENABLED(MESH_BED_LEVELING)
               mbl.line_to_destination(scaled_fr_mm_s);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-              bilinear_line_to_destination(scaled_fr_mm_s);
+              bbl.line_to_destination(scaled_fr_mm_s);
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
     planner.buffer_line(destination, scaled_fr_mm_s);
     return false; // caller will update current_position
   }

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d8df8e12e1..3037c38bb0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -77,21 +77,21 @@ bool relative_mode; // = false;
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 #ifdef Z_IDLE_HEIGHT
   #define Z_INIT_POS Z_IDLE_HEIGHT
 #else
   #define Z_INIT_POS Z_HOME_POS
 #endif
 
-xyze_pos_t current_position = LOGICAL_AXIS_ARRAY(0, X_HOME_POS, Y_HOME_POS, Z_INIT_POS, I_HOME_POS, J_HOME_POS, K_HOME_POS);
+xyze_pos_t current_position = LOGICAL_AXIS_ARRAY(0, X_HOME_POS, Y_HOME_POS, Z_INIT_POS, I_HOME_POS, J_HOME_POS, K_HOME_POS, U_HOME_POS, V_HOME_POS, W_HOME_POS);
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
@@ -182,42 +182,46 @@ xyz_pos_t cartes;
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPGM_P(
-    LIST_N(DOUBLE(LINEAR_AXES),
+    LIST_N(DOUBLE(NUM_AXES),
          X_LBL, lpos.x,
       SP_Y_LBL, lpos.y,
       SP_Z_LBL, lpos.z,
       SP_I_LBL, lpos.i,
       SP_J_LBL, lpos.j,
-      SP_K_LBL, lpos.k
+      SP_K_LBL, lpos.k,
+      SP_U_LBL, lpos.u,
+      SP_V_LBL, lpos.v,
+      SP_W_LBL, lpos.w
     )
     #if HAS_EXTRUDERS
       , SP_E_LBL, lpos.e
     #endif
   );
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = LOGICAL_AXIS_ARRAY(
     planner.get_axis_position_mm(E_AXIS),
     cartes.x, cartes.y, cartes.z,
-    cartes.i, cartes.j, cartes.k
+    cartes.i, cartes.j, cartes.k,
+    cartes.u, cartes.v, cartes.w
   );
 
   TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(npos, true));
 
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
@@ -251,27 +255,30 @@ void report_current_position_projected() {
   void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
    */
   void report_current_position_moving() {
     get_cartesian_from_steppers();
     const xyz_pos_t lpos = cartes.asLogical();
 
     SERIAL_ECHOPGM_P(
-      LIST_N(DOUBLE(LINEAR_AXES),
+      LIST_N(DOUBLE(NUM_AXES),
            X_LBL, lpos.x,
         SP_Y_LBL, lpos.y,
         SP_Z_LBL, lpos.z,
         SP_I_LBL, lpos.i,
         SP_J_LBL, lpos.j,
-        SP_K_LBL, lpos.k
+        SP_K_LBL, lpos.k,
+        SP_U_LBL, lpos.u,
+        SP_V_LBL, lpos.v,
+        SP_W_LBL, lpos.w
       )
       #if HAS_EXTRUDERS
         , SP_E_LBL, current_position.e
       #endif
     );
 
     stepper.report_positions();
     TERN_(IS_SCARA, scara_report_positions());
     report_current_grblstate_moving();
   }
@@ -348,27 +355,30 @@ void sync_plan_position() {
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics(planner.get_axis_positions_mm());
   #elif IS_SCARA
     forward_kinematics(
       planner.get_axis_position_degrees(A_AXIS), planner.get_axis_position_degrees(B_AXIS)
       OPTARG(AXEL_TPARA, planner.get_axis_position_degrees(C_AXIS))
     );
     cartes.z = planner.get_axis_position_mm(Z_AXIS);
   #else
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
       cartes.x = planner.get_axis_position_mm(X_AXIS),
       cartes.y = planner.get_axis_position_mm(Y_AXIS),
       cartes.z = planner.get_axis_position_mm(Z_AXIS),
       cartes.i = planner.get_axis_position_mm(I_AXIS),
       cartes.j = planner.get_axis_position_mm(J_AXIS),
-      cartes.k = planner.get_axis_position_mm(K_AXIS)
+      cartes.k = planner.get_axis_position_mm(K_AXIS),
+      cartes.u = planner.get_axis_position_mm(U_AXIS),
+      cartes.v = planner.get_axis_position_mm(V_AXIS),
+      cartes.w = planner.get_axis_position_mm(W_AXIS)
     );
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
@@ -461,38 +471,37 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 
 /**
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
  * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
-void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
-  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
+  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", NUM_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
-  #if HAS_I_AXIS
-    const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS);
-  #endif
-  #if HAS_J_AXIS
-    const feedRate_t j_feedrate = fr_mm_s ?: homing_feedrate(J_AXIS);
-  #endif
-  #if HAS_K_AXIS
-    const feedRate_t k_feedrate = fr_mm_s ?: homing_feedrate(K_AXIS);
-  #endif
+  SECONDARY_AXIS_CODE(
+    const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS),
+    const feedRate_t j_feedrate = fr_mm_s ?: homing_feedrate(J_AXIS),
+    const feedRate_t k_feedrate = fr_mm_s ?: homing_feedrate(K_AXIS),
+    const feedRate_t u_feedrate = fr_mm_s ?: homing_feedrate(U_AXIS),
+    const feedRate_t v_feedrate = fr_mm_s ?: homing_feedrate(V_AXIS),
+    const feedRate_t w_feedrate = fr_mm_s ?: homing_feedrate(W_AXIS)
+  );
 
   #if IS_KINEMATIC
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
@@ -547,112 +556,164 @@ void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s
 
     #if HAS_I_AXIS
       current_position.i = i; line_to_current_position(i_feedrate);
     #endif
     #if HAS_J_AXIS
       current_position.j = j; line_to_current_position(j_feedrate);
     #endif
     #if HAS_K_AXIS
       current_position.k = k; line_to_current_position(k_feedrate);
     #endif
-    #if HAS_Z_AXIS  // If Z needs to lower, do it after moving XY...
+    #if HAS_U_AXIS
+      current_position.u = u; line_to_current_position(u_feedrate);
+    #endif
+    #if HAS_V_AXIS
+      current_position.v = v; line_to_current_position(v_feedrate);
+    #endif
+    #if HAS_W_AXIS
+      current_position.w = w; line_to_current_position(w_feedrate);
+    #endif
+
+    #if HAS_Z_AXIS
+      // If Z needs to lower, do it after moving XY
       if (current_position.z > z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
   #endif
 
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k), fr_mm_s);
+  do_blocking_move_to(NUM_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k,
+                                    current_position.u, current_position.v, current_position.w), fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_ELEM(raw), fr_mm_s);
+  do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_ELEM(raw), fr_mm_s);
+  do_blocking_move_to(NUM_AXIS_ELEM(raw), fr_mm_s);
 }
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to(
-    LINEAR_AXIS_LIST(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k),
+    NUM_AXIS_LIST(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k,
+                  current_position.u, current_position.v, current_position.w),
     fr_mm_s
   );
 }
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k),
+      NUM_AXIS_LIST(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
 #endif
 
 #if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
   }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, i, raw.j, raw.k),
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, i, raw.j, raw.k, raw.u, raw.v, raw.w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_J_AXIS
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
   }
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, j, raw.k),
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, j, raw.k, raw.u, raw.v, raw.w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_K_AXIS
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
   }
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, k),
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, k, raw.u, raw.v, raw.w),
+      fr_mm_s
+    );
+  }
+#endif
+
+#if HAS_U_AXIS
+  void do_blocking_move_to_u(const_float_t ru, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijk_u(current_position, ru, fr_mm_s);
+  }
+  void do_blocking_move_to_xyzijk_u(const xyze_pos_t &raw, const_float_t u, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, u, raw.v, raw.w),
+      fr_mm_s
+    );
+  }
+#endif
+
+#if HAS_V_AXIS
+  void do_blocking_move_to_v(const_float_t rv, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijku_v(current_position, rv, fr_mm_s);
+  }
+  void do_blocking_move_to_xyzijku_v(const xyze_pos_t &raw, const_float_t v, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, v, raw.w),
+      fr_mm_s
+    );
+  }
+#endif
+
+#if HAS_W_AXIS
+  void do_blocking_move_to_w(const_float_t rw, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzijkuv_w(current_position, rw, fr_mm_s);
+  }
+  void do_blocking_move_to_xyzijkuv_w(const xyze_pos_t &raw, const_float_t w, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(
+      NUM_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, raw.k, raw.u, raw.v, w),
       fr_mm_s
     );
   }
 #endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k),
+      NUM_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
   void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
-      LINEAR_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k),
+      NUM_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k,
+                    current_position.u, current_position.v, current_position.w),
       fr_mm_s
     );
   }
   void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
     float zdest = zclear;
     if (!lower_allowed) NOLESS(zdest, current_position.z);
     do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
   }
 #endif
 
@@ -673,22 +734,22 @@ void remember_feedrate_scaling_off() {
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   soft_endstops_t soft_endstop = {
     true, false,
-    LINEAR_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS, I_MIN_POS, J_MIN_POS, K_MIN_POS),
-    LINEAR_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS, I_MAX_POS, J_MAX_POS, K_MAX_POS)
+    NUM_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS, I_MIN_POS, J_MIN_POS, K_MIN_POS, U_MIN_POS, V_MIN_POS, W_MIN_POS),
+    NUM_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS, I_MAX_POS, J_MAX_POS, K_MAX_POS, U_MAX_POS, V_MAX_POS, W_MAX_POS)
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -853,20 +914,50 @@ void restore_feedrate_and_scaling() {
     #if HAS_K_AXIS
       if (axis_was_homed(K_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_K)
           NOLESS(target.k, soft_endstop.min.k);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_K)
           NOMORE(target.k, soft_endstop.max.k);
         #endif
       }
     #endif
+    #if HAS_U_AXIS
+      if (axis_was_homed(U_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_U)
+          NOLESS(target.u, soft_endstop.min.u);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_U)
+          NOMORE(target.u, soft_endstop.max.u);
+        #endif
+      }
+    #endif
+    #if HAS_V_AXIS
+      if (axis_was_homed(V_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_V)
+          NOLESS(target.v, soft_endstop.min.v);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_V)
+          NOMORE(target.v, soft_endstop.max.v);
+        #endif
+      }
+    #endif
+    #if HAS_W_AXIS
+      if (axis_was_homed(W_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_W)
+          NOLESS(target.w, soft_endstop.min.w);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_W)
+          NOMORE(target.w, soft_endstop.max.w);
+        #endif
+      }
+    #endif
   }
 
 #else // !HAS_SOFTWARE_ENDSTOPS
 
   soft_endstops_t soft_endstop;
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 
@@ -1290,39 +1381,43 @@ void prepare_line_to_destination() {
 #if HAS_ENDSTOPS
 
   linear_axis_bits_t axis_homed, axis_trusted; // = 0
 
   linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     auto set_should = [](linear_axis_bits_t &b, AxisEnum a) {
       if (TEST(b, a) && TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(a))
         CBI(b, a);
     };
     // Clear test bits that are trusted
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
-      set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS)
+      set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS),
+      set_should(axis_bits, U_AXIS), set_should(axis_bits, V_AXIS), set_should(axis_bits, W_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
-        LINEAR_AXIS_LIST(
-          TEST(axis_bits, X_AXIS) ? "X" : "",
-          TEST(axis_bits, Y_AXIS) ? "Y" : "",
-          TEST(axis_bits, Z_AXIS) ? "Z" : "",
+        NUM_AXIS_LIST(
+          TEST(axis_bits, X_AXIS) ? STR_A : "",
+          TEST(axis_bits, Y_AXIS) ? STR_B : "",
+          TEST(axis_bits, Z_AXIS) ? STR_C : "",
           TEST(axis_bits, I_AXIS) ? STR_I : "",
           TEST(axis_bits, J_AXIS) ? STR_J : "",
-          TEST(axis_bits, K_AXIS) ? STR_K : ""
+          TEST(axis_bits, K_AXIS) ? STR_K : "",
+          TEST(axis_bits, U_AXIS) ? STR_U : "",
+          TEST(axis_bits, V_AXIS) ? STR_V : "",
+          TEST(axis_bits, W_AXIS) ? STR_W : ""
         )
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
       ui.set_status(msg);
       return true;
     }
     return false;
   }
 
@@ -1388,40 +1483,58 @@ void prepare_line_to_destination() {
         #endif
         #if I_SENSORLESS
           case I_AXIS: stealth_states.i = tmc_enable_stallguard(stepperI); break;
         #endif
         #if J_SENSORLESS
           case J_AXIS: stealth_states.j = tmc_enable_stallguard(stepperJ); break;
         #endif
         #if K_SENSORLESS
           case K_AXIS: stealth_states.k = tmc_enable_stallguard(stepperK); break;
         #endif
+        #if U_SENSORLESS
+          case U_AXIS: stealth_states.u = tmc_enable_stallguard(stepperU); break;
+        #endif
+        #if V_SENSORLESS
+          case V_AXIS: stealth_states.v = tmc_enable_stallguard(stepperV); break;
+        #endif
+        #if W_SENSORLESS
+          case W_AXIS: stealth_states.w = tmc_enable_stallguard(stepperW); break;
+        #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
           #endif
           #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = true; break;
           #endif
           #if HAS_J_AXIS
             case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = true; break;
           #endif
           #if HAS_K_AXIS
             case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = true; break;
           #endif
+          #if HAS_U_AXIS
+            case U_AXIS: if (ENABLED(U_SPI_SENSORLESS)) endstops.tmc_spi_homing.u = true; break;
+          #endif
+          #if HAS_V_AXIS
+            case V_AXIS: if (ENABLED(V_SPI_SENSORLESS)) endstops.tmc_spi_homing.v = true; break;
+          #endif
+          #if HAS_W_AXIS
+            case W_AXIS: if (ENABLED(W_SPI_SENSORLESS)) endstops.tmc_spi_homing.w = true; break;
+          #endif
           default: break;
         }
       #endif
 
       TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
       return stealth_states;
     }
 
     void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
@@ -1464,40 +1577,58 @@ void prepare_line_to_destination() {
         #endif
         #if I_SENSORLESS
           case I_AXIS: tmc_disable_stallguard(stepperI, enable_stealth.i); break;
         #endif
         #if J_SENSORLESS
           case J_AXIS: tmc_disable_stallguard(stepperJ, enable_stealth.j); break;
         #endif
         #if K_SENSORLESS
           case K_AXIS: tmc_disable_stallguard(stepperK, enable_stealth.k); break;
         #endif
+        #if U_SENSORLESS
+          case U_AXIS: tmc_disable_stallguard(stepperU, enable_stealth.u); break;
+        #endif
+        #if V_SENSORLESS
+          case V_AXIS: tmc_disable_stallguard(stepperV, enable_stealth.v); break;
+        #endif
+        #if W_SENSORLESS
+          case W_AXIS: tmc_disable_stallguard(stepperW, enable_stealth.w); break;
+        #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
           #endif
           #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
           #endif
           #if HAS_J_AXIS
             case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
           #endif
           #if HAS_K_AXIS
             case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
           #endif
+          #if HAS_U_AXIS
+            case U_AXIS: if (ENABLED(U_SPI_SENSORLESS)) endstops.tmc_spi_homing.u = false; break;
+          #endif
+          #if HAS_V_AXIS
+            case V_AXIS: if (ENABLED(V_SPI_SENSORLESS)) endstops.tmc_spi_homing.v = false; break;
+          #endif
+          #if HAS_W_AXIS
+            case W_AXIS: if (ENABLED(W_SPI_SENSORLESS)) endstops.tmc_spi_homing.w = false; break;
+          #endif
           default: break;
         }
       #endif
     }
 
   #endif // SENSORLESS_HOMING
 
   /**
    * Home an individual linear axis
    */
@@ -1660,20 +1791,44 @@ void prepare_line_to_destination() {
             break;
         #endif
         #ifdef K_MICROSTEPS
           case K_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(K);
             phaseCurrent = stepperK.get_microstep_counter();
             effectorBackoutDir = -K_HOME_DIR;
             stepperBackoutDir = INVERT_K_DIR ? effectorBackoutDir : -effectorBackoutDir;
             break;
         #endif
+        #ifdef U_MICROSTEPS
+          case U_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(U);
+            phaseCurrent = stepperU.get_microstep_counter();
+            effectorBackoutDir = -U_HOME_DIR;
+            stepperBackoutDir = INVERT_U_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef V_MICROSTEPS
+          case V_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(V);
+            phaseCurrent = stepperV.get_microstep_counter();
+            effectorBackoutDir = -V_HOME_DIR;
+            stepperBackoutDir = INVERT_V_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef W_MICROSTEPS
+          case W_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(W);
+            phaseCurrent = stepperW.get_microstep_counter();
+            effectorBackoutDir = -W_HOME_DIR;
+            stepperBackoutDir = INVERT_W_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.mm_per_step[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPGM("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
@@ -1716,27 +1871,30 @@ void prepare_line_to_destination() {
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || TERN0(HAS_Z_AXIS, TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)) \
         || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
         || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
       ))
-      if (LINEAR_AXIS_GANG(
+      if (NUM_AXIS_GANG(
            !_CAN_HOME(X),
         && !_CAN_HOME(Y),
         && !_CAN_HOME(Z),
         && !_CAN_HOME(I),
         && !_CAN_HOME(J),
-        && !_CAN_HOME(K))
+        && !_CAN_HOME(K),
+        && !_CAN_HOME(U),
+        && !_CAN_HOME(V),
+        && !_CAN_HOME(W))
       ) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
@@ -1815,20 +1973,29 @@ void prepare_line_to_destination() {
           #endif
           #if HAS_I_AXIS
             case I_AXIS: es = I_ENDSTOP; break;
           #endif
           #if HAS_J_AXIS
             case J_AXIS: es = J_ENDSTOP; break;
           #endif
           #if HAS_K_AXIS
             case K_AXIS: es = K_ENDSTOP; break;
           #endif
+          #if HAS_U_AXIS
+            case U_AXIS: es = U_ENDSTOP; break;
+          #endif
+          #if HAS_V_AXIS
+            case V_AXIS: es = V_ENDSTOP; break;
+          #endif
+          #if HAS_W_AXIS
+            case W_AXIS: es = W_ENDSTOP; break;
+          #endif
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
           return; // Intermediate DEPLOY (in LOW SPEED MODE)

commit 8dfdf51678a4a3975df8250bedf3489fd4835796
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:55 2022 -0500

    üé® Format, use status macros

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7b1e0a3fb9..d8df8e12e1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -22,46 +22,41 @@
 
 /**
  * motion.cpp
  */
 
 #include "motion.h"
 #include "endstops.h"
 #include "stepper.h"
 #include "planner.h"
 #include "temperature.h"
-
 #include "../gcode/gcode.h"
-
+#include "../lcd/marlinui.h"
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/marlinui.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
-#if HAS_STATUS_MESSAGE
-  #include "../lcd/marlinui.h"
-#endif
-
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
@@ -1318,21 +1313,21 @@ void prepare_line_to_destination() {
           TEST(axis_bits, X_AXIS) ? "X" : "",
           TEST(axis_bits, Y_AXIS) ? "Y" : "",
           TEST(axis_bits, Z_AXIS) ? "Z" : "",
           TEST(axis_bits, I_AXIS) ? STR_I : "",
           TEST(axis_bits, J_AXIS) ? STR_J : "",
           TEST(axis_bits, K_AXIS) ? STR_K : ""
         )
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
-      TERN_(HAS_STATUS_MESSAGE, ui.set_status(msg));
+      ui.set_status(msg);
       return true;
     }
     return false;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #if HOMING_Z_WITH_PROBE

commit 258a2ed112da097969d36187b53805df7f98a3ec
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 19:17:12 2022 -0500

    üé® Apply _TERN where possible

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 0f8e02db9e..7b1e0a3fb9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1352,55 +1352,45 @@ void prepare_line_to_destination() {
      * Set sensorless homing if the axis has it, accounting for Core Kinematics.
      */
     sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
       sensorless_t stealth_states { false };
 
       switch (axis) {
         default: break;
         #if X_SENSORLESS
           case X_AXIS:
             stealth_states.x = tmc_enable_stallguard(stepperX);
-            #if AXIS_HAS_STALLGUARD(X2)
-              stealth_states.x2 = tmc_enable_stallguard(stepperX2);
-            #endif
+            TERN_(X2_SENSORLESS, stealth_states.x2 = tmc_enable_stallguard(stepperX2));
             #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SENSORLESS
               stealth_states.y = tmc_enable_stallguard(stepperY);
             #elif CORE_IS_XZ && Z_SENSORLESS
               stealth_states.z = tmc_enable_stallguard(stepperZ);
             #endif
             break;
         #endif
         #if Y_SENSORLESS
           case Y_AXIS:
             stealth_states.y = tmc_enable_stallguard(stepperY);
-            #if AXIS_HAS_STALLGUARD(Y2)
-              stealth_states.y2 = tmc_enable_stallguard(stepperY2);
-            #endif
+            TERN_(Y2_SENSORLESS, stealth_states.y2 = tmc_enable_stallguard(stepperY2));
             #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SENSORLESS
               stealth_states.x = tmc_enable_stallguard(stepperX);
             #elif CORE_IS_YZ && Z_SENSORLESS
               stealth_states.z = tmc_enable_stallguard(stepperZ);
             #endif
             break;
         #endif
         #if Z_SENSORLESS
           case Z_AXIS:
             stealth_states.z = tmc_enable_stallguard(stepperZ);
-            #if AXIS_HAS_STALLGUARD(Z2)
-              stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
-            #endif
-            #if AXIS_HAS_STALLGUARD(Z3)
-              stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
-            #endif
-            #if AXIS_HAS_STALLGUARD(Z4)
-              stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
-            #endif
+            TERN_(Z2_SENSORLESS, stealth_states.z2 = tmc_enable_stallguard(stepperZ2));
+            TERN_(Z3_SENSORLESS, stealth_states.z3 = tmc_enable_stallguard(stepperZ3));
+            TERN_(Z4_SENSORLESS, stealth_states.z4 = tmc_enable_stallguard(stepperZ4));
             #if CORE_IS_XZ && X_SENSORLESS
               stealth_states.x = tmc_enable_stallguard(stepperX);
             #elif CORE_IS_YZ && Y_SENSORLESS
               stealth_states.y = tmc_enable_stallguard(stepperY);
             #endif
             break;
         #endif
         #if I_SENSORLESS
           case I_AXIS: stealth_states.i = tmc_enable_stallguard(stepperI); break;
         #endif
@@ -1438,55 +1428,45 @@ void prepare_line_to_destination() {
 
       return stealth_states;
     }
 
     void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
       switch (axis) {
         default: break;
         #if X_SENSORLESS
           case X_AXIS:
             tmc_disable_stallguard(stepperX, enable_stealth.x);
-            #if AXIS_HAS_STALLGUARD(X2)
-              tmc_disable_stallguard(stepperX2, enable_stealth.x2);
-            #endif
+            TERN_(X2_SENSORLESS, tmc_disable_stallguard(stepperX2, enable_stealth.x2));
             #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SENSORLESS
               tmc_disable_stallguard(stepperY, enable_stealth.y);
             #elif CORE_IS_XZ && Z_SENSORLESS
               tmc_disable_stallguard(stepperZ, enable_stealth.z);
             #endif
             break;
         #endif
         #if Y_SENSORLESS
           case Y_AXIS:
             tmc_disable_stallguard(stepperY, enable_stealth.y);
-            #if AXIS_HAS_STALLGUARD(Y2)
-              tmc_disable_stallguard(stepperY2, enable_stealth.y2);
-            #endif
+            TERN_(Y2_SENSORLESS, tmc_disable_stallguard(stepperY2, enable_stealth.y2));
             #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SENSORLESS
               tmc_disable_stallguard(stepperX, enable_stealth.x);
             #elif CORE_IS_YZ && Z_SENSORLESS
               tmc_disable_stallguard(stepperZ, enable_stealth.z);
             #endif
             break;
         #endif
         #if Z_SENSORLESS
           case Z_AXIS:
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
-            #if AXIS_HAS_STALLGUARD(Z2)
-              tmc_disable_stallguard(stepperZ2, enable_stealth.z2);
-            #endif
-            #if AXIS_HAS_STALLGUARD(Z3)
-              tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
-            #endif
-            #if AXIS_HAS_STALLGUARD(Z4)
-              tmc_disable_stallguard(stepperZ4, enable_stealth.z4);
-            #endif
+            TERN_(Z2_SENSORLESS, tmc_disable_stallguard(stepperZ2, enable_stealth.z2));
+            TERN_(Z3_SENSORLESS, tmc_disable_stallguard(stepperZ3, enable_stealth.z3));
+            TERN_(Z4_SENSORLESS, tmc_disable_stallguard(stepperZ4, enable_stealth.z4));
             #if CORE_IS_XZ && X_SENSORLESS
               tmc_disable_stallguard(stepperX, enable_stealth.x);
             #elif CORE_IS_YZ && Y_SENSORLESS
               tmc_disable_stallguard(stepperY, enable_stealth.y);
             #endif
             break;
         #endif
         #if I_SENSORLESS
           case I_AXIS: tmc_disable_stallguard(stepperI, enable_stealth.i); break;
         #endif

commit a9c30cb9c18142733c78cc820f21f83648beb5eb
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 13 18:00:35 2022 -0400

    üìù Fix X2_MAX_POS comment (#23873)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4b0c6aba7d..0f8e02db9e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -118,23 +118,21 @@ xyze_pos_t destination; // {0}
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       !tmp[X_AXIS][0] && !tmp[Y_AXIS][0] && !tmp[Z_AXIS][0],
       "Offsets for the first hotend must be 0.0."
     );
     // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]
     HOTEND_LOOP() LOOP_ABC(a) hotend_offset[e][a] = tmp[a][e];
-    #if ENABLED(DUAL_X_CARRIAGE)
-      hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS);
-    #endif
+    TERN_(DUAL_X_CARRIAGE, hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS));
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
 int16_t feedrate_percentage = 100;
 
@@ -1109,30 +1107,29 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x              = X2_MAX_POS,                    // Used in mode 0 & 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // Used in mode 2 & 3
   xyz_pos_t raised_parked_position;                                       // Used in mode 1
   bool active_extruder_parked            = false;                         // Used in mode 1, 2 & 3
   millis_t delayed_move_time             = 0;                             // Used in mode 1
   celsius_t duplicate_extruder_temp_offset = 0;                           // Used in mode 2 & 3
   bool idex_mirrored_mode                = false;                         // Used in mode 3
 
   float x_home_pos(const uint8_t extruder) {
-    if (extruder == 0)
-      return X_HOME_POS;
-    else
-      /**
-       * In dual carriage mode the extruder offset provides an override of the
-       * second X-carriage position when homed - otherwise X2_HOME_POS is used.
-       * This allows soft recalibration of the second extruder home position
-       * without firmware reflash (through the M218 command).
-       */
-      return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
+    if (extruder == 0) return X_HOME_POS;
+
+    /**
+     * In dual carriage mode the extruder offset provides an override of the
+     * second X-carriage position when homed - otherwise X2_HOME_POS is used.
+     * This allows soft recalibration of the second extruder home position
+     * (with M218 T1 Xn) without firmware reflash.
+     */
+    return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
   }
 
   void idex_set_mirrored_mode(const bool mirr) {
     idex_mirrored_mode = mirr;
     stepper.set_directions();
   }
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index/*=-1*/) {
     extruder_duplication_enabled = dupe;
     if (tool_index >= 0) active_extruder = tool_index;

commit d987e23d5b47dc21e2c235969a6719c8f6673530
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Feb 6 08:35:18 2022 -0600

    üêõ Fix init of delta safe height (for G29, G33, etc.) (#23622)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 51f0681a15..4b0c6aba7d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -736,21 +736,21 @@ void restore_feedrate_and_scaling() {
       soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_max_pos(axis);
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
-          delta_clip_start_height = soft_endstop.max[axis] - delta_safe_distance_from_top();
+          refresh_delta_clip_start_height();
         default: break;
       }
 
     #elif HAS_HOTEND_OFFSET
 
       // Software endstops are relative to the tool 0 workspace, so
       // the movement limits must be shifted by the tool offset to
       // retain the same physical limit when other tools are selected.
 
       if (new_tool_index == old_tool_index || axis == Z_AXIS) { // The Z axis is "special" and shouldn't be modified

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a9c2ad6a7a..51f0681a15 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -460,114 +460,116 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   TERN_(HAS_EXTRUDERS, planner.e_factor[active_extruder] = old_fac);
 }
 
 /**
- * Plan a move to (X, Y, Z, [I, [J, [K]]]) and set the current_position
- * Plan a move to (X, Y, Z) with separation of Z from other components.
+ * Plan a move to (X, Y, Z, [I, [J, [K...]]]) and set the current_position
+ * Plan a move to (X, Y, Z, [I, [J, [K...]]]) with separation of Z from other components.
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
+  #if HAS_I_AXIS
+    const feedRate_t i_feedrate = fr_mm_s ?: homing_feedrate(I_AXIS);
+  #endif
+  #if HAS_J_AXIS
+    const feedRate_t j_feedrate = fr_mm_s ?: homing_feedrate(J_AXIS);
+  #endif
+  #if HAS_K_AXIS
+    const feedRate_t k_feedrate = fr_mm_s ?: homing_feedrate(K_AXIS);
+  #endif
 
   #if IS_KINEMATIC
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 
     // when in the danger zone
     if (current_position.z > delta_clip_start_height) {
-      if (z > delta_clip_start_height) {                     // staying in the danger zone
-        destination.set(x, y, z);                          // move directly (uninterpolated)
+      if (z > delta_clip_start_height) {                      // staying in the danger zone
+        destination.set(x, y, z);                             // move directly (uninterpolated)
         prepare_internal_fast_move_to_destination();          // set current_position from destination
         if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
       destination.z = delta_clip_start_height;
       prepare_internal_fast_move_to_destination();            // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
-    if (z > current_position.z) {                            // raising?
+    if (z > current_position.z) {                             // raising?
       destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
     }
 
     destination.set(x, y);
     prepare_internal_move_to_destination();                   // set current_position from destination
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
-    if (z < current_position.z) {                            // lowering?
+    if (z < current_position.z) {                             // lowering?
       destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
     // If Z needs to raise, do it before moving XY
-    if (destination.z < z) {
-      destination.z = z;
-      prepare_internal_fast_move_to_destination(z_feedrate);
-    }
+    if (destination.z < z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
-    destination.set(x, y);
-    prepare_internal_fast_move_to_destination(xy_feedrate);
+    destination.set(x, y); prepare_internal_fast_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
-    if (destination.z > z) {
-      destination.z = z;
-      prepare_internal_fast_move_to_destination(z_feedrate);
-    }
+    if (destination.z > z) { destination.z = z; prepare_internal_fast_move_to_destination(z_feedrate); }
 
   #else
 
-    #if HAS_Z_AXIS
-      // If Z needs to raise, do it before moving XY
-      if (current_position.z < z) {
-        current_position.z = z;
-        line_to_current_position(z_feedrate);
-      }
+    #if HAS_Z_AXIS  // If Z needs to raise, do it before moving XY
+      if (current_position.z < z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
-    current_position.set(x, y);
-    line_to_current_position(xy_feedrate);
+    current_position.set(x, y); line_to_current_position(xy_feedrate);
 
-    #if HAS_Z_AXIS
-      // If Z needs to lower, do it after moving XY
-      if (current_position.z > z) {
-        current_position.z = z;
-        line_to_current_position(z_feedrate);
-      }
+    #if HAS_I_AXIS
+      current_position.i = i; line_to_current_position(i_feedrate);
+    #endif
+    #if HAS_J_AXIS
+      current_position.j = j; line_to_current_position(j_feedrate);
+    #endif
+    #if HAS_K_AXIS
+      current_position.k = k; line_to_current_position(k_feedrate);
+    #endif
+    #if HAS_Z_AXIS  // If Z needs to lower, do it after moving XY...
+      if (current_position.z > z) { current_position.z = z; line_to_current_position(z_feedrate); }
     #endif
 
   #endif
 
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k), fr_mm_s);
 }
@@ -1395,20 +1397,29 @@ void prepare_line_to_destination() {
             #if AXIS_HAS_STALLGUARD(Z4)
               stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
             #endif
             #if CORE_IS_XZ && X_SENSORLESS
               stealth_states.x = tmc_enable_stallguard(stepperX);
             #elif CORE_IS_YZ && Y_SENSORLESS
               stealth_states.y = tmc_enable_stallguard(stepperY);
             #endif
             break;
         #endif
+        #if I_SENSORLESS
+          case I_AXIS: stealth_states.i = tmc_enable_stallguard(stepperI); break;
+        #endif
+        #if J_SENSORLESS
+          case J_AXIS: stealth_states.j = tmc_enable_stallguard(stepperJ); break;
+        #endif
+        #if K_SENSORLESS
+          case K_AXIS: stealth_states.k = tmc_enable_stallguard(stepperK); break;
+        #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
@@ -1472,20 +1483,29 @@ void prepare_line_to_destination() {
             #if AXIS_HAS_STALLGUARD(Z4)
               tmc_disable_stallguard(stepperZ4, enable_stealth.z4);
             #endif
             #if CORE_IS_XZ && X_SENSORLESS
               tmc_disable_stallguard(stepperX, enable_stealth.x);
             #elif CORE_IS_YZ && Y_SENSORLESS
               tmc_disable_stallguard(stepperY, enable_stealth.y);
             #endif
             break;
         #endif
+        #if I_SENSORLESS
+          case I_AXIS: tmc_disable_stallguard(stepperI, enable_stealth.i); break;
+        #endif
+        #if J_SENSORLESS
+          case J_AXIS: tmc_disable_stallguard(stepperJ, enable_stealth.j); break;
+        #endif
+        #if K_SENSORLESS
+          case K_AXIS: tmc_disable_stallguard(stepperK, enable_stealth.k); break;
+        #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
@@ -1808,22 +1828,26 @@ void prepare_line_to_destination() {
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
-          case Y_AXIS: es = Y_ENDSTOP; break;
-          case Z_AXIS: es = Z_ENDSTOP; break;
+          #if HAS_Y_AXIS
+            case Y_AXIS: es = Y_ENDSTOP; break;
+          #endif
+          #if HAS_Z_AXIS
+            case Z_AXIS: es = Z_ENDSTOP; break;
+          #endif
           #if HAS_I_AXIS
             case I_AXIS: es = I_ENDSTOP; break;
           #endif
           #if HAS_J_AXIS
             case J_AXIS: es = J_ENDSTOP; break;
           #endif
           #if HAS_K_AXIS
             case K_AXIS: es = K_ENDSTOP; break;
           #endif
         }

commit 224b6e5af9250e92671ad3ee35bb10cd79b819ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 05:34:16 2022 -0600

    ü©π Fix some logical axis usage

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index be08ba6ef0..a9c2ad6a7a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -258,29 +258,31 @@ void report_current_position_projected() {
   void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
    */
   void report_current_position_moving() {
     get_cartesian_from_steppers();
     const xyz_pos_t lpos = cartes.asLogical();
 
     SERIAL_ECHOPGM_P(
-      LIST_N(DOUBLE(LOGICAL_AXES),
-        SP_E_LBL, current_position.e,
+      LIST_N(DOUBLE(LINEAR_AXES),
            X_LBL, lpos.x,
         SP_Y_LBL, lpos.y,
         SP_Z_LBL, lpos.z,
         SP_I_LBL, lpos.i,
         SP_J_LBL, lpos.j,
         SP_K_LBL, lpos.k
       )
+      #if HAS_EXTRUDERS
+        , SP_E_LBL, current_position.e
+      #endif
     );
 
     stepper.report_positions();
     TERN_(IS_SCARA, scara_report_positions());
     report_current_grblstate_moving();
   }
 
   /**
    * Set a Grbl-compatible state from the current marlin_state
    */

commit 9665a4434cee0386fa2a63a058b6f2598943ee98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 02:51:34 2022 -0600

    üßë‚Äçüíª Fewer string macros

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 23084c48fb..be08ba6ef0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1310,23 +1310,23 @@ void prepare_line_to_destination() {
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
         LINEAR_AXIS_LIST(
           TEST(axis_bits, X_AXIS) ? "X" : "",
           TEST(axis_bits, Y_AXIS) ? "Y" : "",
           TEST(axis_bits, Z_AXIS) ? "Z" : "",
-          TEST(axis_bits, I_AXIS) ? AXIS4_STR : "",
-          TEST(axis_bits, J_AXIS) ? AXIS5_STR : "",
-          TEST(axis_bits, K_AXIS) ? AXIS6_STR : ""
+          TEST(axis_bits, I_AXIS) ? STR_I : "",
+          TEST(axis_bits, J_AXIS) ? STR_J : "",
+          TEST(axis_bits, K_AXIS) ? STR_K : ""
         )
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
       TERN_(HAS_STATUS_MESSAGE, ui.set_status(msg));
       return true;
     }
     return false;
   }
 

commit a719020348e121245ba2ec6c5e60149c661241a0
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Jan 10 09:44:16 2022 +0100

    üö∏ Include extra axes in position report (#23490)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a77f395fb4..23084c48fb 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -210,23 +210,21 @@ inline void report_logical_position(const xyze_pos_t &rpos) {
   );
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = LOGICAL_AXIS_ARRAY(
     planner.get_axis_position_mm(E_AXIS),
     cartes.x, cartes.y, cartes.z,
-    planner.get_axis_position_mm(I_AXIS),
-    planner.get_axis_position_mm(J_AXIS),
-    planner.get_axis_position_mm(K_AXIS)
+    cartes.i, cartes.j, cartes.k
   );
 
   TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(npos, true));
 
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
@@ -256,41 +254,37 @@ void report_current_position_projected() {
 
   /**
    * Output the current grbl compatible state to serial while moving
    */
   void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
    */
   void report_current_position_moving() {
-
     get_cartesian_from_steppers();
     const xyz_pos_t lpos = cartes.asLogical();
-    SERIAL_ECHOPGM(
-      "X:", lpos.x
-      #if HAS_Y_AXIS
-        , " Y:", lpos.y
-      #endif
-      #if HAS_Z_AXIS
-        , " Z:", lpos.z
-      #endif
-      #if HAS_EXTRUDERS
-        , " E:", current_position.e
-      #endif
+
+    SERIAL_ECHOPGM_P(
+      LIST_N(DOUBLE(LOGICAL_AXES),
+        SP_E_LBL, current_position.e,
+           X_LBL, lpos.x,
+        SP_Y_LBL, lpos.y,
+        SP_Z_LBL, lpos.z,
+        SP_I_LBL, lpos.i,
+        SP_J_LBL, lpos.j,
+        SP_K_LBL, lpos.k
+      )
     );
 
     stepper.report_positions();
-    #if IS_SCARA
-      scara_report_positions();
-    #endif
-
+    TERN_(IS_SCARA, scara_report_positions());
     report_current_grblstate_moving();
   }
 
   /**
    * Set a Grbl-compatible state from the current marlin_state
    */
   M_StateEnum grbl_state_for_marlin_state() {
     switch (marlin_state) {
       case MF_INITIALIZING: return M_INIT;
       case MF_SD_COMPLETE:  return M_ALARM;

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2248c52d85..a77f395fb4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -596,45 +596,45 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
     );
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
 #endif
 
-#if LINEAR_AXES >= 4
+#if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
   }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, i, raw.j, raw.k),
       fr_mm_s
     );
   }
 #endif
 
-#if LINEAR_AXES >= 5
+#if HAS_J_AXIS
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
   }
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, j, raw.k),
       fr_mm_s
     );
   }
 #endif
 
-#if LINEAR_AXES >= 6
+#if HAS_K_AXIS
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
   }
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
     do_blocking_move_to(
       LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, k),
       fr_mm_s
     );
   }
 #endif
@@ -832,41 +832,41 @@ void restore_feedrate_and_scaling() {
     #if HAS_Z_AXIS
       if (axis_was_homed(Z_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
           NOLESS(target.z, soft_endstop.min.z);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
           NOMORE(target.z, soft_endstop.max.z);
         #endif
       }
     #endif
-    #if LINEAR_AXES >= 4
+    #if HAS_I_AXIS
       if (axis_was_homed(I_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_I)
           NOLESS(target.i, soft_endstop.min.i);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_I)
           NOMORE(target.i, soft_endstop.max.i);
         #endif
       }
     #endif
-    #if LINEAR_AXES >= 5
+    #if HAS_J_AXIS
       if (axis_was_homed(J_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_J)
           NOLESS(target.j, soft_endstop.min.j);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_J)
           NOMORE(target.j, soft_endstop.max.j);
         #endif
       }
     #endif
-    #if LINEAR_AXES >= 6
+    #if HAS_K_AXIS
       if (axis_was_homed(K_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_K)
           NOLESS(target.k, soft_endstop.min.k);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_K)
           NOMORE(target.k, soft_endstop.max.k);
         #endif
       }
     #endif
   }
@@ -1410,27 +1410,27 @@ void prepare_line_to_destination() {
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
           #endif
-          #if LINEAR_AXES >= 4
+          #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = true; break;
           #endif
-          #if LINEAR_AXES >= 5
+          #if HAS_J_AXIS
             case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = true; break;
           #endif
-          #if LINEAR_AXES >= 6
+          #if HAS_K_AXIS
             case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = true; break;
           #endif
           default: break;
         }
       #endif
 
       TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
       return stealth_states;
     }
@@ -1487,27 +1487,27 @@ void prepare_line_to_destination() {
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
           #if HAS_Y_AXIS
             case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
           #endif
-          #if LINEAR_AXES >= 4
+          #if HAS_I_AXIS
             case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
           #endif
-          #if LINEAR_AXES >= 5
+          #if HAS_J_AXIS
             case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
           #endif
-          #if LINEAR_AXES >= 6
+          #if HAS_K_AXIS
             case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
           #endif
           default: break;
         }
       #endif
     }
 
   #endif // SENSORLESS_HOMING
 
   /**
@@ -1814,27 +1814,27 @@ void prepare_line_to_destination() {
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
-          #if LINEAR_AXES >= 4
+          #if HAS_I_AXIS
             case I_AXIS: es = I_ENDSTOP; break;
           #endif
-          #if LINEAR_AXES >= 5
+          #if HAS_J_AXIS
             case J_AXIS: es = J_ENDSTOP; break;
           #endif
-          #if LINEAR_AXES >= 6
+          #if HAS_K_AXIS
             case K_AXIS: es = K_ENDSTOP; break;
           #endif
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)

commit 2893048e2955963bb307a4ca67ec26bb336de2f5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 21 23:09:55 2021 -0500

    ‚ú® BLTouch High Speed mode runtime configuration (#22916)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9ff668bf30..2248c52d85 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1796,22 +1796,22 @@ void prepare_line_to_destination() {
       use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(axis)) : home_bump_mm(axis)
     );
 
     //
     // Fast move towards endstop until triggered
     //
     const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home Fast: ", move_length, "mm");
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
-      if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+      if (axis == Z_AXIS && !bltouch.high_speed_mode) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
     #endif
 
     // If a second homing move is configured...
     if (bump) {
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
@@ -1830,22 +1830,23 @@ void prepare_line_to_destination() {
           #if LINEAR_AXES >= 6
             case K_AXIS: es = K_ENDSTOP; break;
           #endif
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
-      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
-        if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
+      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+        if (axis == Z_AXIS && !bltouch.high_speed_mode && bltouch.deploy())
+          return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
       do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS) bltouch.stow(); // The final STOW
       #endif

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ‚ú® MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 71239501fd..9ff668bf30 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1360,34 +1360,34 @@ void prepare_line_to_destination() {
       sensorless_t stealth_states { false };
 
       switch (axis) {
         default: break;
         #if X_SENSORLESS
           case X_AXIS:
             stealth_states.x = tmc_enable_stallguard(stepperX);
             #if AXIS_HAS_STALLGUARD(X2)
               stealth_states.x2 = tmc_enable_stallguard(stepperX2);
             #endif
-            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
+            #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SENSORLESS
               stealth_states.y = tmc_enable_stallguard(stepperY);
             #elif CORE_IS_XZ && Z_SENSORLESS
               stealth_states.z = tmc_enable_stallguard(stepperZ);
             #endif
             break;
         #endif
         #if Y_SENSORLESS
           case Y_AXIS:
             stealth_states.y = tmc_enable_stallguard(stepperY);
             #if AXIS_HAS_STALLGUARD(Y2)
               stealth_states.y2 = tmc_enable_stallguard(stepperY2);
             #endif
-            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
+            #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SENSORLESS
               stealth_states.x = tmc_enable_stallguard(stepperX);
             #elif CORE_IS_YZ && Z_SENSORLESS
               stealth_states.z = tmc_enable_stallguard(stepperZ);
             #endif
             break;
         #endif
         #if Z_SENSORLESS
           case Z_AXIS:
             stealth_states.z = tmc_enable_stallguard(stepperZ);
             #if AXIS_HAS_STALLGUARD(Z2)
@@ -1437,34 +1437,34 @@ void prepare_line_to_destination() {
 
     void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
       switch (axis) {
         default: break;
         #if X_SENSORLESS
           case X_AXIS:
             tmc_disable_stallguard(stepperX, enable_stealth.x);
             #if AXIS_HAS_STALLGUARD(X2)
               tmc_disable_stallguard(stepperX2, enable_stealth.x2);
             #endif
-            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
+            #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SENSORLESS
               tmc_disable_stallguard(stepperY, enable_stealth.y);
             #elif CORE_IS_XZ && Z_SENSORLESS
               tmc_disable_stallguard(stepperZ, enable_stealth.z);
             #endif
             break;
         #endif
         #if Y_SENSORLESS
           case Y_AXIS:
             tmc_disable_stallguard(stepperY, enable_stealth.y);
             #if AXIS_HAS_STALLGUARD(Y2)
               tmc_disable_stallguard(stepperY2, enable_stealth.y2);
             #endif
-            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
+            #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SENSORLESS
               tmc_disable_stallguard(stepperX, enable_stealth.x);
             #elif CORE_IS_YZ && Z_SENSORLESS
               tmc_disable_stallguard(stepperZ, enable_stealth.z);
             #endif
             break;
         #endif
         #if Z_SENSORLESS
           case Z_AXIS:
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
             #if AXIS_HAS_STALLGUARD(Z2)
@@ -2004,21 +2004,21 @@ void prepare_line_to_destination() {
 
       const float adjDistance = delta_endstop_adj[axis],
                   minDistance = (MIN_STEPS_PER_SEGMENT) * planner.mm_per_step[axis];
 
       // Retrace by the amount specified in delta_endstop_adj if more than min steps.
       if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("adjDistance:", adjDistance);
         do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
       }
 
-    #else // CARTESIAN / CORE / MARKFORGED_XY
+    #else // CARTESIAN / CORE / MARKFORGED_XY / MARKFORGED_YX
 
       set_axis_is_at_home(axis);
       sync_plan_position();
 
       destination[axis] = current_position[axis];
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
     #endif
 
@@ -2034,21 +2034,21 @@ void prepare_line_to_destination() {
         line_to_current_position(
           #if HOMING_Z_WITH_PROBE
             (axis == Z_AXIS) ? z_probe_fast_mm_s :
           #endif
           homing_feedrate(axis)
         );
 
         #if ENABLED(SENSORLESS_HOMING)
           planner.synchronize();
           if (false
-            #if EITHER(IS_CORE, MARKFORGED_XY)
+            #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
               || axis != NORMAL_AXIS
             #endif
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;

commit 15ebe45f36f34bce4a07f6348c85ffb1ab904087
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 12 19:40:56 2021 -0400

    üêõ Fix IDEX + DISABLE_INACTIVE_EXTRUDER (#22925)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f5dd5d34c9..71239501fd 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1186,20 +1186,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
           }
           stepper.set_directions();
 
           idex_set_parked(false);
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
         } break;
 
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
+            set_duplication_enabled(false); // Clear stale duplication state
             // Restore planner to parked head (T1) X position
             float x0_pos = current_position.x;
             xyze_pos_t pos_now = current_position;
             pos_now.x = inactive_extruder_x;
             planner.set_position_mm(pos_now);
 
             // Keep the same X or add the duplication X offset
             xyze_pos_t new_pos = pos_now;
             if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
               new_pos.x = x0_pos + duplicate_extruder_x_offset;

commit b3fd0a50505455bbd4d0487b202ab75797a79421
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Oct 9 19:13:19 2021 -0400

    üêõ Fix IDEX Duplication Mode Positioning (#22914)
    
    Fixing #22538

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1f13bd22ee..f5dd5d34c9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1187,28 +1187,31 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
           stepper.set_directions();
 
           idex_set_parked(false);
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
         } break;
 
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             // Restore planner to parked head (T1) X position
+            float x0_pos = current_position.x;
             xyze_pos_t pos_now = current_position;
             pos_now.x = inactive_extruder_x;
             planner.set_position_mm(pos_now);
 
             // Keep the same X or add the duplication X offset
             xyze_pos_t new_pos = pos_now;
             if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
-              new_pos.x += duplicate_extruder_x_offset;
+              new_pos.x = x0_pos + duplicate_extruder_x_offset;
+            else
+              new_pos.x = _MIN(X_BED_SIZE - x0_pos, X_MAX_POS);
 
             // Move duplicate extruder into the correct position
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set planner X", inactive_extruder_x, " ... Line to X", new_pos.x);
             if (!planner.buffer_line(new_pos, planner.settings.max_feedrate_mm_s[X_AXIS], 1)) break;
             planner.synchronize();
 
             sync_plan_position();             // Extra sync for good measure
             set_duplication_enabled(true);    // Enable Duplication
             idex_set_parked(false);           // No longer parked
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("set_duplication_enabled(true)\nidex_set_parked(false)");

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a56831c214..1f13bd22ee 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1822,21 +1822,21 @@ void prepare_line_to_destination() {
           #endif
           #if LINEAR_AXES >= 5
             case J_AXIS: es = J_ENDSTOP; break;
           #endif
           #if LINEAR_AXES >= 6
             case K_AXIS: es = K_ENDSTOP; break;
           #endif
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
-          kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
+          kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
         if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8ad7455aaf..a56831c214 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1675,30 +1675,30 @@ void prepare_line_to_destination() {
             stepperBackoutDir = INVERT_K_DIR ? effectorBackoutDir : -effectorBackoutDir;
             break;
         #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
-      if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
+      if (ABS(phaseDelta) * planner.mm_per_step[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPGM("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
                          ". Pick a different phase for ", AS_CHAR(AXIS_CHAR(axis)));
 
       // Skip to next if target position is behind current. So it only moves away from endstop.
       if (phaseDelta < 0) phaseDelta += 1024;
 
       // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
-      const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
+      const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.mm_per_step[axis];
 
       // Optional debug messages
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM(
           "Endstop ", AS_CHAR(AXIS_CHAR(axis)), " hit at Phase:", phaseCurrent,
           " Delta:", phaseDelta, " Distance:", mmDelta
         );
       }
 
       if (mmDelta != 0) {
@@ -1992,21 +1992,21 @@ void prepare_line_to_destination() {
       set_axis_is_at_home(axis);
       sync_plan_position();
 
     #elif ENABLED(DELTA)
 
       // Delta has already moved all three towers up in G28
       // so here it re-homes each tower in turn.
       // Delta homing treats the axes as normal linear axes.
 
       const float adjDistance = delta_endstop_adj[axis],
-                  minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
+                  minDistance = (MIN_STEPS_PER_SEGMENT) * planner.mm_per_step[axis];
 
       // Retrace by the amount specified in delta_endstop_adj if more than min steps.
       if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("adjDistance:", adjDistance);
         do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
       }
 
     #else // CARTESIAN / CORE / MARKFORGED_XY
 
       set_axis_is_at_home(axis);

commit 35ad3b0d3b1a8bbf6b220f30f63fd0e32be8fe34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 23 11:09:43 2021 -0500

    üêõ Fix reset_hotend_offsets

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 397c2ac1d0..8ad7455aaf 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -117,21 +117,21 @@ xyze_pos_t destination; // {0}
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       !tmp[X_AXIS][0] && !tmp[Y_AXIS][0] && !tmp[Z_AXIS][0],
       "Offsets for the first hotend must be 0.0."
     );
     // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]
-    HOTEND_LOOP() LOOP_LINEAR_AXES(a) hotend_offset[e][a] = tmp[a][e];
+    HOTEND_LOOP() LOOP_ABC(a) hotend_offset[e][a] = tmp[a][e];
     #if ENABLED(DUAL_X_CARRIAGE)
       hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS);
     #endif
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cdd425c472..397c2ac1d0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -482,21 +482,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
 
   const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
 
-  #if EITHER(DELTA, IS_SCARA)
+  #if IS_KINEMATIC
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index eb6dc6597c..cdd425c472 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -188,21 +188,21 @@ xyz_pos_t cartes;
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
-  SERIAL_ECHOPAIR_P(
+  SERIAL_ECHOPGM_P(
     LIST_N(DOUBLE(LINEAR_AXES),
          X_LBL, lpos.x,
       SP_Y_LBL, lpos.y,
       SP_Z_LBL, lpos.z,
       SP_I_LBL, lpos.i,
       SP_J_LBL, lpos.j,
       SP_K_LBL, lpos.k
     )
     #if HAS_EXTRUDERS
       , SP_E_LBL, lpos.e
@@ -250,30 +250,30 @@ void report_current_position_projected() {
   AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
 #if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
 
   M_StateEnum M_State_grbl = M_INIT;
 
   /**
    * Output the current grbl compatible state to serial while moving
    */
-  void report_current_grblstate_moving() { SERIAL_ECHOLNPAIR("S_XYZ:", int(M_State_grbl)); }
+  void report_current_grblstate_moving() { SERIAL_ECHOLNPGM("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
    */
   void report_current_position_moving() {
 
     get_cartesian_from_steppers();
     const xyz_pos_t lpos = cartes.asLogical();
-    SERIAL_ECHOPAIR(
+    SERIAL_ECHOPGM(
       "X:", lpos.x
       #if HAS_Y_AXIS
         , " Y:", lpos.y
       #endif
       #if HAS_Z_AXIS
         , " Z:", lpos.z
       #endif
       #if HAS_EXTRUDERS
         , " E:", current_position.e
       #endif
@@ -767,21 +767,21 @@ void restore_feedrate_and_scaling() {
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
     if (DEBUGGING(LEVELING))
-      SERIAL_ECHOLNPAIR("Axis ", AS_CHAR(AXIS_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+      SERIAL_ECHOLNPGM("Axis ", AS_CHAR(AXIS_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
   }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
@@ -962,24 +962,24 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments),
                 cartesian_segment_mm = cartesian_mm * inv_segments;
     const xyze_float_t segment_distance = diff * inv_segments;
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
     #endif
 
     /*
-    SERIAL_ECHOPAIR("mm=", cartesian_mm);
-    SERIAL_ECHOPAIR(" seconds=", seconds);
-    SERIAL_ECHOPAIR(" segments=", segments);
-    SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
+    SERIAL_ECHOPGM("mm=", cartesian_mm);
+    SERIAL_ECHOPGM(" seconds=", seconds);
+    SERIAL_ECHOPGM(" segments=", segments);
+    SERIAL_ECHOPGM(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();
     //*/
 
     // Get the current position as starting point
     xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
     millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
       segment_idle(next_idle_ms);
@@ -1028,23 +1028,23 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments;
       const xyze_float_t segment_distance = diff * inv_segments;
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
       #endif
 
-      // SERIAL_ECHOPAIR("mm=", cartesian_mm);
-      // SERIAL_ECHOLNPAIR(" segments=", segments);
-      // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
+      //SERIAL_ECHOPGM("mm=", cartesian_mm);
+      //SERIAL_ECHOLNPGM(" segments=", segments);
+      //SERIAL_ECHOLNPGM(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
@@ -1197,21 +1197,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
             xyze_pos_t pos_now = current_position;
             pos_now.x = inactive_extruder_x;
             planner.set_position_mm(pos_now);
 
             // Keep the same X or add the duplication X offset
             xyze_pos_t new_pos = pos_now;
             if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
               new_pos.x += duplicate_extruder_x_offset;
 
             // Move duplicate extruder into the correct position
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x, " ... Line to X", new_pos.x);
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set planner X", inactive_extruder_x, " ... Line to X", new_pos.x);
             if (!planner.buffer_line(new_pos, planner.settings.max_feedrate_mm_s[X_AXIS], 1)) break;
             planner.synchronize();
 
             sync_plan_position();             // Extra sync for good measure
             set_duplication_enabled(true);    // Enable Duplication
             idex_set_parked(false);           // No longer parked
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("set_duplication_enabled(true)\nidex_set_parked(false)");
           }
           else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Active extruder not 0");
           break;
@@ -1508,25 +1508,25 @@ void prepare_line_to_destination() {
 
   /**
    * Home an individual linear axis
    */
   void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
     DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
     const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("...(", AS_CHAR(AXIS_CHAR(axis)), ", ", distance, ", ");
+      DEBUG_ECHOPGM("...(", AS_CHAR(AXIS_CHAR(axis)), ", ", distance, ", ");
       if (fr_mm_s)
         DEBUG_ECHO(fr_mm_s);
       else
-        DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
+        DEBUG_ECHOPGM("[", home_fr_mm_s, "]");
       DEBUG_ECHOLNPGM(")");
     }
 
     // Only do some things when moving towards an endstop
     const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                   ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
     const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states;
@@ -1588,26 +1588,26 @@ void prepare_line_to_destination() {
       TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     set_axis_untrusted(axis);
     set_axis_unhomed(axis);
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
   }
 
   #ifdef TMC_HOME_PHASE
     /**
      * Move the axis back to its home_phase if set and driver is capable (TMC)
      *
      * Improves homing repeatability by homing to stepper coil's nearest absolute
      * phase position. Trinamic drivers use a stepper phase table with 1024 values
@@ -1676,33 +1676,33 @@ void prepare_line_to_destination() {
             break;
         #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
-        SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
+        SERIAL_ECHOLNPGM("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
                          ". Pick a different phase for ", AS_CHAR(AXIS_CHAR(axis)));
 
       // Skip to next if target position is behind current. So it only moves away from endstop.
       if (phaseDelta < 0) phaseDelta += 1024;
 
       // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
       const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
       // Optional debug messages
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLNPAIR(
+        DEBUG_ECHOLNPGM(
           "Endstop ", AS_CHAR(AXIS_CHAR(axis)), " hit at Phase:", phaseCurrent,
           " Delta:", phaseDelta, " Distance:", mmDelta
         );
       }
 
       if (mmDelta != 0) {
         // Retrace by the amount computed in mmDelta.
         do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
       }
     }
@@ -1734,21 +1734,21 @@ void prepare_line_to_destination() {
       if (LINEAR_AXIS_GANG(
            !_CAN_HOME(X),
         && !_CAN_HOME(Y),
         && !_CAN_HOME(Z),
         && !_CAN_HOME(I),
         && !_CAN_HOME(J),
         && !_CAN_HOME(K))
       ) return;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
       return;
 
@@ -1773,47 +1773,47 @@ void prepare_line_to_destination() {
       }
     #endif
 
     //
     // Back away to prevent an early sensorless trigger
     //
     #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
       const xyz_float_t backoff = SENSORLESS_BACKOFF_MM;
       if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS) || TERN0(Z_SENSORLESS, axis == Z_AXIS) || TERN0(I_SENSORLESS, axis == I_AXIS) || TERN0(J_SENSORLESS, axis == J_AXIS) || TERN0(K_SENSORLESS, axis == K_AXIS)) && backoff[axis]) {
         const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Sensorless backoff: ", backoff_length, "mm");
         do_homing_move(axis, backoff_length, homing_feedrate(axis));
       }
     #endif
 
     // Determine if a homing bump will be done and the bumps distance
     // When homing Z with probe respect probe clearance
     const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(axis));
     const float bump = axis_home_dir * (
       use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(axis)) : home_bump_mm(axis)
     );
 
     //
     // Fast move towards endstop until triggered
     //
     const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home Fast: ", move_length, "mm");
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
     #endif
 
     // If a second homing move is configured...
     if (bump) {
       // Move away from the endstop by the axis HOMING_BUMP_MM
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away: ", -bump, "mm");
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
@@ -1832,21 +1832,21 @@ void prepare_line_to_destination() {
           kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
         if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Re-bump: ", rebump, "mm");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
       do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
         if (axis == Z_AXIS) bltouch.stow(); // The final STOW
       #endif
     }
 
     #if HAS_EXTRA_ENDSTOPS
       const bool pos_dir = axis_home_dir > 0;
       #if ENABLED(X_DUAL_ENDSTOPS)
@@ -1996,21 +1996,21 @@ void prepare_line_to_destination() {
 
       // Delta has already moved all three towers up in G28
       // so here it re-homes each tower in turn.
       // Delta homing treats the axes as normal linear axes.
 
       const float adjDistance = delta_endstop_adj[axis],
                   minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
 
       // Retrace by the amount specified in delta_endstop_adj if more than min steps.
       if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("adjDistance:", adjDistance);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("adjDistance:", adjDistance);
         do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
       }
 
     #else // CARTESIAN / CORE / MARKFORGED_XY
 
       set_axis_is_at_home(axis);
       sync_plan_position();
 
       destination[axis] = current_position[axis];
 
@@ -2043,21 +2043,21 @@ void prepare_line_to_destination() {
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
   } // homeaxis()
 
 #endif // HAS_ENDSTOPS
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
@@ -2068,21 +2068,21 @@ void prepare_line_to_destination() {
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM(">>> set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
@@ -2097,52 +2097,52 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
         current_position.z -= probe.offset.z;
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
-      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
+      DEBUG_ECHOLNPGM("> home_offset[", AS_CHAR(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
-    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
+    DEBUG_ECHOLNPGM("<<< set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
   }
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;

commit 6464601411346c1da7bf15016b07c0fa9558a28c
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Aug 17 20:27:21 2021 -0700

    ‚è™Ô∏è Revert ABL G29 feedrate (#22574)
    
    Reverts 9130f58

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 838605cd54..eb6dc6597c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -476,21 +476,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
 
-  const feedRate_t xy_feedrate = fr_mm_s ?: PLANNER_XY_FEEDRATE();
+  const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
 
   #if EITHER(DELTA, IS_SCARA)
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 

commit 9130f58f3f553584278ec716c617005b9e03cb49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Aug 4 16:37:02 2021 -0500

    üêõ Prevent ABL G29 setting a funky feedrate
    
    See #22472

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index eb6dc6597c..838605cd54 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -476,21 +476,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
  *
  * - If Z is moving up, the Z move is done before XY, etc.
  * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
 
-  const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
+  const feedRate_t xy_feedrate = fr_mm_s ?: PLANNER_XY_FEEDRATE();
 
   #if HAS_Z_AXIS
     const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
   #endif
 
   #if EITHER(DELTA, IS_SCARA)
     if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 

commit b2f0913083d83bd3fd9af1c603d1f4cc1afb64eb
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Tue Jul 6 17:36:41 2021 -0700

    üêõ Redundant Temp Sensor followup (#22196)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 63fdd5afc3..eb6dc6597c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -696,22 +696,21 @@ void restore_feedrate_and_scaling() {
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
   void update_software_endstops(const AxisEnum axis
-    OPTARG(HAS_HOTEND_OFFSET, const uint8_t old_tool_index/*=0*/)
-    OPTARG(HAS_HOTEND_OFFSET, const uint8_t new_tool_index/*=0*/)
+    OPTARG(HAS_HOTEND_OFFSET, const uint8_t old_tool_index/*=0*/, const uint8_t new_tool_index/*=0*/)
   ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = _MAX(hotend_offset[1].x, X2_MAX_POS);
 
         if (new_tool_index != 0) {

commit de4b3498c71c5666477b15544d1561fabee3d499
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Mon Jun 21 13:36:06 2021 -0700

    üêõ Fix IJK axis references, E stepper indices (#22176)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b540c9a938..63fdd5afc3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -259,21 +259,32 @@ void report_current_position_projected() {
    */
   void report_current_grblstate_moving() { SERIAL_ECHOLNPAIR("S_XYZ:", int(M_State_grbl)); }
 
   /**
    * Output the current position (processed) to serial while moving
    */
   void report_current_position_moving() {
 
     get_cartesian_from_steppers();
     const xyz_pos_t lpos = cartes.asLogical();
-    SERIAL_ECHOPAIR("X:", lpos.x, " Y:", lpos.y, " Z:", lpos.z, " E:", current_position.e);
+    SERIAL_ECHOPAIR(
+      "X:", lpos.x
+      #if HAS_Y_AXIS
+        , " Y:", lpos.y
+      #endif
+      #if HAS_Z_AXIS
+        , " Z:", lpos.z
+      #endif
+      #if HAS_EXTRUDERS
+        , " E:", current_position.e
+      #endif
+    );
 
     stepper.report_positions();
     #if IS_SCARA
       scara_report_positions();
     #endif
 
     report_current_grblstate_moving();
   }
 
   /**
@@ -922,21 +933,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(destination)) return true;
 
     // Get the linear distance in XYZ
     float cartesian_mm = diff.magnitude();
 
     // If the move is very short, check the E move distance
-    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
+    TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / scaled_fr_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = segments_per_second * seconds;
@@ -1001,21 +1012,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
       // If the move is only in Z/E don't split up the move
       if (!diff.x && !diff.y) {
         planner.buffer_line(destination, fr_mm_s);
         return;
       }
 
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
       float cartesian_mm = diff.magnitude();
-      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
+      TERN_(HAS_EXTRUDERS, if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e));
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments;

commit 6bdd0fcda183068dcd8fe797a9a835765c3efe9e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Jun 14 23:52:42 2021 +0200

    ‚ö°Ô∏è Home Z (and maybe XY) at the start of G35 (#22060)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d465a00356..b540c9a938 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -287,20 +287,24 @@ void report_current_position_projected() {
       case MF_STOPPED:      return M_END;
       case MF_RUNNING:      return M_RUNNING;
       case MF_PAUSED:       return M_HOLD;
       case MF_KILLED:       return M_ERROR;
       default:              return M_IDLE;
     }
   }
 
 #endif
 
+void home_if_needed(const bool keeplev/*=false*/) {
+  if (!all_axes_trusted()) gcode.home_all_axes(keeplev);
+}
+
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES_ENUM);
   sync_plan_position();
 }

commit ba4fa4983411d03eae791b70d8ec3e26f0781785
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jun 6 08:30:39 2021 +0200

    ‚úèÔ∏è Followup to Six Linear Axes (#22056)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1d40d3a253..d465a00356 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -581,50 +581,53 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
     );
   }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
   }
 #endif
 
-#if LINEAR_AXES == 4
+#if LINEAR_AXES >= 4
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
   }
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
-	  do_blocking_move_to(raw.x, raw.y, raw.z, i, fr_mm_s);
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, i, raw.j, raw.k),
+      fr_mm_s
+    );
   }
 #endif
 
 #if LINEAR_AXES >= 5
-  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
-    do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
-  }
-  void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
-	  do_blocking_move_to(raw.x, raw.y, raw.z, i, raw.j, fr_mm_s);
-  }
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
   }
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
-    do_blocking_move_to(raw.x, raw.y, raw.z, raw.i, j, fr_mm_s);
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, j, raw.k),
+      fr_mm_s
+    );
   }
 #endif
 
 #if LINEAR_AXES >= 6
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
   }
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
-    do_blocking_move_to(raw.x, raw.y, raw.z, raw.i, raw.j, k, fr_mm_s);
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(raw.x, raw.y, raw.z, raw.i, raw.j, k),
+      fr_mm_s
+    );
   }
 #endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
     do_blocking_move_to(
       LINEAR_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k),
       fr_mm_s
     );
   }
@@ -815,21 +818,21 @@ void restore_feedrate_and_scaling() {
     #if HAS_Z_AXIS
       if (axis_was_homed(Z_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
           NOLESS(target.z, soft_endstop.min.z);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
           NOMORE(target.z, soft_endstop.max.z);
         #endif
       }
     #endif
-    #if LINEAR_AXES >= 4  // TODO (DerAndere): Find out why this was missing / removed
+    #if LINEAR_AXES >= 4
       if (axis_was_homed(I_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_I)
           NOLESS(target.i, soft_endstop.min.i);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_I)
           NOMORE(target.i, soft_endstop.max.i);
         #endif
       }
     #endif
     #if LINEAR_AXES >= 5
@@ -1288,21 +1291,21 @@ void prepare_line_to_destination() {
     // Clear test bits that are trusted
     LINEAR_AXIS_CODE(
       set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
       set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
-      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);  // TODO: (DerAndere) Set this up for extra axes
+      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
         LINEAR_AXIS_LIST(
           TEST(axis_bits, X_AXIS) ? "X" : "",
           TEST(axis_bits, Y_AXIS) ? "Y" : "",
           TEST(axis_bits, Z_AXIS) ? "Z" : "",
           TEST(axis_bits, I_AXIS) ? AXIS4_STR : "",
           TEST(axis_bits, J_AXIS) ? AXIS5_STR : "",
           TEST(axis_bits, K_AXIS) ? AXIS6_STR : ""
         )
@@ -1383,22 +1386,35 @@ void prepare_line_to_destination() {
             #elif CORE_IS_YZ && Y_SENSORLESS
               stealth_states.y = tmc_enable_stallguard(stepperY);
             #endif
             break;
         #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
-          case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
-          case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
+          #if HAS_Y_AXIS
+            case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
+          #endif
+          #if HAS_Z_AXIS
+            case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
+          #endif
+          #if LINEAR_AXES >= 4
+            case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = true; break;
+          #endif
+          #if LINEAR_AXES >= 5
+            case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = true; break;
+          #endif
+          #if LINEAR_AXES >= 6
+            case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = true; break;
+          #endif
           default: break;
         }
       #endif
 
       TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
       return stealth_states;
     }
 
     void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
@@ -1447,25 +1463,35 @@ void prepare_line_to_destination() {
             #elif CORE_IS_YZ && Y_SENSORLESS
               tmc_disable_stallguard(stepperY, enable_stealth.y);
             #endif
             break;
         #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
-          case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
-          case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
-          case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
-          case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
-          case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
+          #if HAS_Y_AXIS
+            case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
+          #endif
+          #if HAS_Z_AXIS
+            case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
+          #endif
+          #if LINEAR_AXES >= 4
+            case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
+          #endif
+          #if LINEAR_AXES >= 5
+            case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
+          #endif
+          #if LINEAR_AXES >= 6
+            case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
+          #endif
           default: break;
         }
       #endif
     }
 
   #endif // SENSORLESS_HOMING
 
   /**
    * Home an individual linear axis
    */
@@ -1727,25 +1753,25 @@ void prepare_line_to_destination() {
     // Deploy BLTouch or tare the probe just before probing
     //
     #if HOMING_Z_WITH_PROBE
       if (axis == Z_AXIS) {
         if (TERN0(BLTOUCH, bltouch.deploy())) return;   // BLTouch was deployed above, but get the alarm state.
         if (TERN0(PROBE_TARE, probe.tare())) return;
       }
     #endif
 
     //
-    // Back away to prevent an early X/Y sensorless trigger
+    // Back away to prevent an early sensorless trigger
     //
     #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
-      const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
-      if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
+      const xyz_float_t backoff = SENSORLESS_BACKOFF_MM;
+      if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS) || TERN0(Z_SENSORLESS, axis == Z_AXIS) || TERN0(I_SENSORLESS, axis == I_AXIS) || TERN0(J_SENSORLESS, axis == J_AXIS) || TERN0(K_SENSORLESS, axis == K_AXIS)) && backoff[axis]) {
         const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
         do_homing_move(axis, backoff_length, homing_feedrate(axis));
       }
     #endif
 
     // Determine if a homing bump will be done and the bumps distance
     // When homing Z with probe respect probe clearance
     const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(axis));
     const float bump = axis_home_dir * (
@@ -1770,20 +1796,29 @@ void prepare_line_to_destination() {
       do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
+          #if LINEAR_AXES >= 4
+            case I_AXIS: es = I_ENDSTOP; break;
+          #endif
+          #if LINEAR_AXES >= 5
+            case J_AXIS: es = J_ENDSTOP; break;
+          #endif
+          #if LINEAR_AXES >= 6
+            case K_AXIS: es = K_ENDSTOP; break;
+          #endif
         }
         if (TEST(endstops.state(), es)) {
           SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
         if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ad0537b5cf..1d40d3a253 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -82,21 +82,21 @@ bool relative_mode; // = false;
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 #ifdef Z_IDLE_HEIGHT
   #define Z_INIT_POS Z_IDLE_HEIGHT
 #else
   #define Z_INIT_POS Z_HOME_POS
 #endif
 
-xyze_pos_t current_position = LOGICAL_AXIS_ARRAY(0, X_HOME_POS, Y_HOME_POS, Z_INIT_POS);
+xyze_pos_t current_position = LOGICAL_AXIS_ARRAY(0, X_HOME_POS, Y_HOME_POS, Z_INIT_POS, I_HOME_POS, J_HOME_POS, K_HOME_POS);
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
@@ -136,21 +136,21 @@ xyze_pos_t destination; // {0}
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
 int16_t feedrate_percentage = 100;
 
 // Cartesian conversion result goes here:
 xyz_pos_t cartes;
 
 #if IS_KINEMATIC
 
-  abc_pos_t delta;
+  abce_pos_t delta;
 
   #if HAS_SCARA_OFFSET
     abc_pos_t scara_home_offset;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS
     float delta_max_radius, delta_max_radius_2;
   #elif IS_SCARA
     constexpr float delta_max_radius = SCARA_PRINTABLE_RADIUS,
                     delta_max_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
@@ -189,34 +189,44 @@ xyz_pos_t cartes;
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPAIR_P(
-    LIST_N(DOUBLE(LINEAR_AXES), X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z)
+    LIST_N(DOUBLE(LINEAR_AXES),
+         X_LBL, lpos.x,
+      SP_Y_LBL, lpos.y,
+      SP_Z_LBL, lpos.z,
+      SP_I_LBL, lpos.i,
+      SP_J_LBL, lpos.j,
+      SP_K_LBL, lpos.k
+    )
     #if HAS_EXTRUDERS
       , SP_E_LBL, lpos.e
     #endif
   );
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = LOGICAL_AXIS_ARRAY(
     planner.get_axis_position_mm(E_AXIS),
-    cartes.x, cartes.y, cartes.z
+    cartes.x, cartes.y, cartes.z,
+    planner.get_axis_position_mm(I_AXIS),
+    planner.get_axis_position_mm(J_AXIS),
+    planner.get_axis_position_mm(K_AXIS)
   );
 
   TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(npos, true));
 
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
@@ -327,72 +337,69 @@ void sync_plan_position() {
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics(planner.get_axis_positions_mm());
-  #else
-    #if IS_SCARA
-      forward_kinematics(
-          planner.get_axis_position_degrees(A_AXIS)
-        , planner.get_axis_position_degrees(B_AXIS)
-        #if ENABLED(AXEL_TPARA)
-          , planner.get_axis_position_degrees(C_AXIS)
-        #endif
-      );
-    #else
-      cartes.x = planner.get_axis_position_mm(X_AXIS);
-      cartes.y = planner.get_axis_position_mm(Y_AXIS);
-    #endif
+  #elif IS_SCARA
+    forward_kinematics(
+      planner.get_axis_position_degrees(A_AXIS), planner.get_axis_position_degrees(B_AXIS)
+      OPTARG(AXEL_TPARA, planner.get_axis_position_degrees(C_AXIS))
+    );
     cartes.z = planner.get_axis_position_mm(Z_AXIS);
+  #else
+    LINEAR_AXIS_CODE(
+      cartes.x = planner.get_axis_position_mm(X_AXIS),
+      cartes.y = planner.get_axis_position_mm(Y_AXIS),
+      cartes.z = planner.get_axis_position_mm(Z_AXIS),
+      cartes.i = planner.get_axis_position_mm(I_AXIS),
+      cartes.j = planner.get_axis_position_mm(J_AXIS),
+      cartes.k = planner.get_axis_position_mm(K_AXIS)
+    );
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
  * sync_plan_position after updating axes with this.
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   xyze_pos_t pos = cartes;
 
-  #if HAS_EXTRUDERS
-    pos.e = planner.get_axis_position_mm(E_AXIS);
-  #endif
+  TERN_(HAS_EXTRUDERS, pos.e = planner.get_axis_position_mm(E_AXIS));
 
-  #if HAS_POSITION_MODIFIERS
-    planner.unapply_modifiers(pos, true);
-  #endif
+  TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(pos, true));
 
   if (axis == ALL_AXES_ENUM)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
-  planner.buffer_line(current_position, fr_mm_s, active_extruder);
+  planner.buffer_line(current_position, fr_mm_s);
 }
 
 #if HAS_EXTRUDERS
   void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s) {
     TERN_(HAS_FILAMENT_SENSOR, runout.reset());
     current_position.e += length / planner.e_factor[active_extruder];
     line_to_current_position(fr_mm_s);
     planner.synchronize();
   }
 #endif
@@ -404,21 +411,21 @@ void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
    */
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // UBL segmented line will do Z-only moves in single segment
       ubl.line_to_destination_segmented(scaled_fr_mm_s);
     #else
       if (current_position == destination) return;
 
-      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
+      planner.buffer_line(destination, scaled_fr_mm_s);
     #endif
 
     current_position = destination;
   }
 
 #endif // IS_KINEMATIC
 
 /**
  * Do a fast or normal move to 'destination' with an optional FR.
  *  - Move at normal speed regardless of feedrate percentage.
@@ -442,164 +449,210 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   TERN_(HAS_EXTRUDERS, planner.e_factor[active_extruder] = old_fac);
 }
 
 /**
- * Plan a move to (X, Y, Z) with separation of the XY and Z components.
+ * Plan a move to (X, Y, Z, [I, [J, [K]]]) and set the current_position
+ * Plan a move to (X, Y, Z) with separation of Z from other components.
  *
- * - If Z is moving up, the Z move is done before XY.
- * - If Z is moving down, the Z move is done after XY.
+ * - If Z is moving up, the Z move is done before XY, etc.
+ * - If Z is moving down, the Z move is done after XY, etc.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
-void do_blocking_move_to(
-  LINEAR_AXIS_LIST(const float rx, const float ry, const float rz),
-  const_feedRate_t fr_mm_s/*=0.0f*/
-) {
+void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s/*=0.0f*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
-  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_LIST(rx, ry, rz));
+  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_ARGS());
+
+  const feedRate_t xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
-  const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
-                  xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
+  #if HAS_Z_AXIS
+    const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS);
+  #endif
 
   #if EITHER(DELTA, IS_SCARA)
-    if (!position_is_reachable(rx, ry)) return;
+    if (!position_is_reachable(x, y)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 
     // when in the danger zone
     if (current_position.z > delta_clip_start_height) {
-      if (rz > delta_clip_start_height) {                     // staying in the danger zone
-        destination.set(rx, ry, rz);                          // move directly (uninterpolated)
+      if (z > delta_clip_start_height) {                     // staying in the danger zone
+        destination.set(x, y, z);                          // move directly (uninterpolated)
         prepare_internal_fast_move_to_destination();          // set current_position from destination
         if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
       destination.z = delta_clip_start_height;
       prepare_internal_fast_move_to_destination();            // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
-    if (rz > current_position.z) {                            // raising?
-      destination.z = rz;
+    if (z > current_position.z) {                            // raising?
+      destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
     }
 
-    destination.set(rx, ry);
+    destination.set(x, y);
     prepare_internal_move_to_destination();                   // set current_position from destination
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
-    if (rz < current_position.z) {                            // lowering?
-      destination.z = rz;
+    if (z < current_position.z) {                            // lowering?
+      destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
     // If Z needs to raise, do it before moving XY
-    if (destination.z < rz) {
-      destination.z = rz;
+    if (destination.z < z) {
+      destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
-    destination.set(rx, ry);
+    destination.set(x, y);
     prepare_internal_fast_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
-    if (destination.z > rz) {
-      destination.z = rz;
+    if (destination.z > z) {
+      destination.z = z;
       prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
   #else
 
-    // If Z needs to raise, do it before moving XY
-    if (current_position.z < rz) {
-      current_position.z = rz;
-      line_to_current_position(z_feedrate);
-    }
+    #if HAS_Z_AXIS
+      // If Z needs to raise, do it before moving XY
+      if (current_position.z < z) {
+        current_position.z = z;
+        line_to_current_position(z_feedrate);
+      }
+    #endif
 
-    current_position.set(rx, ry);
+    current_position.set(x, y);
     line_to_current_position(xy_feedrate);
 
-    // If Z needs to lower, do it after moving XY
-    if (current_position.z > rz) {
-      current_position.z = rz;
-      line_to_current_position(z_feedrate);
-    }
+    #if HAS_Z_AXIS
+      // If Z needs to lower, do it after moving XY
+      if (current_position.z > z) {
+        current_position.z = z;
+        line_to_current_position(z_feedrate);
+      }
+    #endif
 
   #endif
 
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i), fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i, current_position.j, current_position.k), fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, raw.z), fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_ELEM(raw), fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, raw.z), fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_ELEM(raw), fr_mm_s);
 }
-
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to(
-    LINEAR_AXIS_LIST(rx, current_position.y, current_position.z),
-    fr_mm_s
-  );
-}
-void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(
-    LINEAR_AXIS_LIST(current_position.x, ry, current_position.z),
+    LINEAR_AXIS_LIST(rx, current_position.y, current_position.z, current_position.i, current_position.j, current_position.k),
     fr_mm_s
   );
 }
-void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
-}
 
-void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(
-    LINEAR_AXIS_LIST(rx, ry, current_position.z),
-    fr_mm_s
-  );
-}
-void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
-}
+#if HAS_Y_AXIS
+  void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(current_position.x, ry, current_position.z, current_position.i, current_position.j, current_position.k),
+      fr_mm_s
+    );
+  }
+#endif
 
-void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(
-    LINEAR_AXIS_LIST(raw.x, raw.y, z),
-    fr_mm_s
-  );
-}
+#if HAS_Z_AXIS
+  void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
+  }
+#endif
 
-void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
-  float zdest = zclear;
-  if (!lower_allowed) NOLESS(zdest, current_position.z);
-  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
-}
+#if LINEAR_AXES == 4
+  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
+  }
+  void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
+	  do_blocking_move_to(raw.x, raw.y, raw.z, i, fr_mm_s);
+  }
+#endif
+
+#if LINEAR_AXES >= 5
+  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyz_i(current_position, ri, fr_mm_s);
+  }
+  void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s/*=0.0f*/) {
+	  do_blocking_move_to(raw.x, raw.y, raw.z, i, raw.j, fr_mm_s);
+  }
+  void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzi_j(current_position, rj, fr_mm_s);
+  }
+  void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(raw.x, raw.y, raw.z, raw.i, j, fr_mm_s);
+  }
+#endif
+
+#if LINEAR_AXES >= 6
+  void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to_xyzij_k(current_position, rk, fr_mm_s);
+  }
+  void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(raw.x, raw.y, raw.z, raw.i, raw.j, k, fr_mm_s);
+  }
+#endif
+
+#if HAS_Y_AXIS
+  void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(rx, ry, current_position.z, current_position.i, current_position.j, current_position.k),
+      fr_mm_s
+    );
+  }
+  void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
+  }
+#endif
+
+#if HAS_Z_AXIS
+  void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
+    do_blocking_move_to(
+      LINEAR_AXIS_LIST(raw.x, raw.y, z, current_position.i, current_position.j, current_position.k),
+      fr_mm_s
+    );
+  }
+  void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
+    float zdest = zclear;
+    if (!lower_allowed) NOLESS(zdest, current_position.z);
+    do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
+  }
+#endif
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
@@ -611,22 +664,22 @@ void remember_feedrate_scaling_off() {
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   soft_endstops_t soft_endstop = {
     true, false,
-    LINEAR_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS),
-    LINEAR_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS)
+    LINEAR_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS, I_MIN_POS, J_MIN_POS, K_MIN_POS),
+    LINEAR_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS, I_MAX_POS, J_MAX_POS, K_MAX_POS)
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -739,39 +792,73 @@ void restore_feedrate_and_scaling() {
 
       if (axis_was_homed(X_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
           NOLESS(target.x, soft_endstop.min.x);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
           NOMORE(target.x, soft_endstop.max.x);
         #endif
       }
 
-      if (axis_was_homed(Y_AXIS)) {
-        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-          NOLESS(target.y, soft_endstop.min.y);
+      #if HAS_Y_AXIS
+        if (axis_was_homed(Y_AXIS)) {
+          #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+            NOLESS(target.y, soft_endstop.min.y);
+          #endif
+          #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+            NOMORE(target.y, soft_endstop.max.y);
+          #endif
+        }
+      #endif
+
+    #endif
+
+    #if HAS_Z_AXIS
+      if (axis_was_homed(Z_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+          NOLESS(target.z, soft_endstop.min.z);
         #endif
-        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-          NOMORE(target.y, soft_endstop.max.y);
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+          NOMORE(target.z, soft_endstop.max.z);
+        #endif
+      }
+    #endif
+    #if LINEAR_AXES >= 4  // TODO (DerAndere): Find out why this was missing / removed
+      if (axis_was_homed(I_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_I)
+          NOLESS(target.i, soft_endstop.min.i);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_I)
+          NOMORE(target.i, soft_endstop.max.i);
+        #endif
+      }
+    #endif
+    #if LINEAR_AXES >= 5
+      if (axis_was_homed(J_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_J)
+          NOLESS(target.j, soft_endstop.min.j);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_J)
+          NOMORE(target.j, soft_endstop.max.j);
+        #endif
+      }
+    #endif
+    #if LINEAR_AXES >= 6
+      if (axis_was_homed(K_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_K)
+          NOLESS(target.k, soft_endstop.min.k);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_K)
+          NOMORE(target.k, soft_endstop.max.k);
         #endif
       }
-
     #endif
-
-    if (axis_was_homed(Z_AXIS)) {
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-        NOLESS(target.z, soft_endstop.min.z);
-      #endif
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-        NOMORE(target.z, soft_endstop.max.z);
-      #endif
-    }
   }
 
 #else // !HAS_SOFTWARE_ENDSTOPS
 
   soft_endstops_t soft_endstop;
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 
@@ -817,21 +904,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
    */
   inline bool line_to_destination_kinematic() {
 
     // Get the top feedrate of the move in the XY plane
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
     const xyze_float_t diff = destination - current_position;
 
     // If the move is only in Z/E don't split up the move
     if (!diff.x && !diff.y) {
-      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
+      planner.buffer_line(destination, scaled_fr_mm_s);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(destination)) return true;
 
     // Get the linear distance in XYZ
     float cartesian_mm = diff.magnitude();
 
     // If the move is very short, check the E move distance
@@ -873,29 +960,25 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     //*/
 
     // Get the current position as starting point
     xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
     millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
       segment_idle(next_idle_ms);
       raw += segment_distance;
-      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
-        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-      )) break;
+      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
     }
 
     // Ensure last segment arrives at target location.
-    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
-      OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-    );
+    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
@@ -903,21 +986,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
      * This calls planner.buffer_line several times, adding
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
     inline void segmented_line_to_destination(const_feedRate_t fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
       const xyze_float_t diff = destination - current_position;
 
       // If the move is only in Z/E don't split up the move
       if (!diff.x && !diff.y) {
-        planner.buffer_line(destination, fr_mm_s, active_extruder);
+        planner.buffer_line(destination, fr_mm_s);
         return;
       }
 
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
       float cartesian_mm = diff.magnitude();
       if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
@@ -940,32 +1023,26 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
       // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
-        if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
-          OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-        )) break;
+        if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration))) break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
-      planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm
-        #if ENABLED(SCARA_FEEDRATE_SCALING)
-          , inv_duration
-        #endif
-      );
+      planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
     }
 
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
@@ -991,21 +1068,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
               mbl.line_to_destination(scaled_fr_mm_s);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(scaled_fr_mm_s);
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
-    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
+    planner.buffer_line(destination, scaled_fr_mm_s);
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
   bool extruder_duplication_enabled;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     uint8_t duplication_e_mask; // = 0
@@ -1073,54 +1150,57 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
               current_position = destination;
               NOLESS(raised_parked_position.z, destination.z);
               delayed_move_time = millis() + 1000UL;
               return true;
             }
           }
           //
           // Un-park the active extruder
           //
           const feedRate_t fr_zfast = planner.settings.max_feedrate_mm_s[Z_AXIS];
-          #define CURPOS current_position
-          #define RAISED raised_parked_position
           //  1. Move to the raised parked XYZ. Presumably the tool is already at XY.
-          if (planner.buffer_line(RAISED.x, RAISED.y, RAISED.z, CURPOS.e, fr_zfast, active_extruder)) {
+          xyze_pos_t raised = raised_parked_position; raised.e = current_position.e;
+          if (planner.buffer_line(raised, fr_zfast)) {
             //  2. Move to the current native XY and raised Z. Presumably this is a null move.
-            if (planner.buffer_line(CURPOS.x, CURPOS.y, RAISED.z, CURPOS.e, PLANNER_XY_FEEDRATE(), active_extruder)) {
+            xyze_pos_t curpos = current_position; curpos.z = raised_parked_position.z;
+            if (planner.buffer_line(curpos, PLANNER_XY_FEEDRATE())) {
               //  3. Lower Z back down
               line_to_current_position(fr_zfast);
             }
           }
           stepper.set_directions();
 
           idex_set_parked(false);
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
         } break;
 
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
-            xyze_pos_t new_pos = current_position;
+            // Restore planner to parked head (T1) X position
+            xyze_pos_t pos_now = current_position;
+            pos_now.x = inactive_extruder_x;
+            planner.set_position_mm(pos_now);
+
+            // Keep the same X or add the duplication X offset
+            xyze_pos_t new_pos = pos_now;
             if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
               new_pos.x += duplicate_extruder_x_offset;
-            else
-              new_pos.x = inactive_extruder_x;
-            // Move duplicate extruder into correct duplication position.
+
+            // Move duplicate extruder into the correct position
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x, " ... Line to X", new_pos.x);
-            planner.set_position_mm(inactive_extruder_x, current_position.y, current_position.z, current_position.e);
             if (!planner.buffer_line(new_pos, planner.settings.max_feedrate_mm_s[X_AXIS], 1)) break;
-
             planner.synchronize();
-            sync_plan_position();
 
-            set_duplication_enabled(true);
-            idex_set_parked(false);
+            sync_plan_position();             // Extra sync for good measure
+            set_duplication_enabled(true);    // Enable Duplication
+            idex_set_parked(false);           // No longer parked
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("set_duplication_enabled(true)\nidex_set_parked(false)");
           }
           else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Active extruder not 0");
           break;
       }
     }
     return false;
   }
 
 #endif // DUAL_X_CARRIAGE
@@ -1200,36 +1280,38 @@ void prepare_line_to_destination() {
 
   linear_axis_bits_t axis_homed, axis_trusted; // = 0
 
   linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     auto set_should = [](linear_axis_bits_t &b, AxisEnum a) {
       if (TEST(b, a) && TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(a))
         CBI(b, a);
     };
     // Clear test bits that are trusted
     LINEAR_AXIS_CODE(
-      set_should(axis_bits, X_AXIS),
-      set_should(axis_bits, Y_AXIS),
-      set_should(axis_bits, Z_AXIS)
+      set_should(axis_bits, X_AXIS), set_should(axis_bits, Y_AXIS), set_should(axis_bits, Z_AXIS),
+      set_should(axis_bits, I_AXIS), set_should(axis_bits, J_AXIS), set_should(axis_bits, K_AXIS)
     );
     return axis_bits;
   }
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
-      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
+      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);  // TODO: (DerAndere) Set this up for extra axes
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
         LINEAR_AXIS_LIST(
           TEST(axis_bits, X_AXIS) ? "X" : "",
           TEST(axis_bits, Y_AXIS) ? "Y" : "",
-          TEST(axis_bits, Z_AXIS) ? "Z" : ""
+          TEST(axis_bits, Z_AXIS) ? "Z" : "",
+          TEST(axis_bits, I_AXIS) ? AXIS4_STR : "",
+          TEST(axis_bits, J_AXIS) ? AXIS5_STR : "",
+          TEST(axis_bits, K_AXIS) ? AXIS6_STR : ""
         )
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
       TERN_(HAS_STATUS_MESSAGE, ui.set_status(msg));
       return true;
     }
     return false;
   }
 
@@ -1367,20 +1449,23 @@ void prepare_line_to_destination() {
             #endif
             break;
         #endif
       }
 
       #if ENABLED(SPI_ENDSTOPS)
         switch (axis) {
           case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
           case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
           case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
+          case I_AXIS: if (ENABLED(I_SPI_SENSORLESS)) endstops.tmc_spi_homing.i = false; break;
+          case J_AXIS: if (ENABLED(J_SPI_SENSORLESS)) endstops.tmc_spi_homing.j = false; break;
+          case K_AXIS: if (ENABLED(K_SPI_SENSORLESS)) endstops.tmc_spi_homing.k = false; break;
           default: break;
         }
       #endif
     }
 
   #endif // SENSORLESS_HOMING
 
   /**
    * Home an individual linear axis
    */
@@ -1439,26 +1524,21 @@ void prepare_line_to_destination() {
 
       target[axis] = 0;                         // Set the single homing axis to 0
       planner.set_machine_position_mm(target);  // Update the machine position
 
       #if HAS_DIST_MM_ARG
         const xyze_float_t cart_dist_mm{0};
       #endif
 
       // Set delta/cartesian axes directly
       target[axis] = distance;                  // The move will be towards the endstop
-      planner.buffer_segment(target
-        #if HAS_DIST_MM_ARG
-          , cart_dist_mm
-        #endif
-        , home_fr_mm_s, active_extruder
-      );
+      planner.buffer_segment(target OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), home_fr_mm_s, active_extruder);
     #endif
 
     planner.synchronize();
 
     if (is_home_dir) {
 
       #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
         if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
       #endif
 
@@ -1524,20 +1604,44 @@ void prepare_line_to_destination() {
             break;
         #endif
         #ifdef Z_MICROSTEPS
           case Z_AXIS:
             phasePerUStep = PHASE_PER_MICROSTEP(Z);
             phaseCurrent = stepperZ.get_microstep_counter();
             effectorBackoutDir = -Z_HOME_DIR;
             stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
             break;
         #endif
+        #ifdef I_MICROSTEPS
+          case I_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(I);
+            phaseCurrent = stepperI.get_microstep_counter();
+            effectorBackoutDir = -I_HOME_DIR;
+            stepperBackoutDir = INVERT_I_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef J_MICROSTEPS
+          case J_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(J);
+            phaseCurrent = stepperJ.get_microstep_counter();
+            effectorBackoutDir = -J_HOME_DIR;
+            stepperBackoutDir = INVERT_J_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef K_MICROSTEPS
+          case K_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(K);
+            phaseCurrent = stepperK.get_microstep_counter();
+            effectorBackoutDir = -K_HOME_DIR;
+            stepperBackoutDir = INVERT_K_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
@@ -1576,25 +1680,32 @@ void prepare_line_to_destination() {
    */
 
   void homeaxis(const AxisEnum axis) {
 
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
-        || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
+        || TERN0(HAS_Z_AXIS, TERN0(HOMING_Z_WITH_PROBE, _AXIS(A) == Z_AXIS)) \
         || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
         || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
       ))
-      if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
+      if (LINEAR_AXIS_GANG(
+           !_CAN_HOME(X),
+        && !_CAN_HOME(Y),
+        && !_CAN_HOME(Z),
+        && !_CAN_HOME(I),
+        && !_CAN_HOME(J),
+        && !_CAN_HOME(K))
+      ) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
@@ -1629,23 +1740,23 @@ void prepare_line_to_destination() {
       const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
       if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
         const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
         do_homing_move(axis, backoff_length, homing_feedrate(axis));
       }
     #endif
 
     // Determine if a homing bump will be done and the bumps distance
     // When homing Z with probe respect probe clearance
-    const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
+    const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(axis));
     const float bump = axis_home_dir * (
-      use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
+      use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(axis)) : home_bump_mm(axis)
     );
 
     //
     // Fast move towards endstop until triggered
     //
     const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6801b210af..ad0537b5cf 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -82,21 +82,21 @@ bool relative_mode; // = false;
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 #ifdef Z_IDLE_HEIGHT
   #define Z_INIT_POS Z_IDLE_HEIGHT
 #else
   #define Z_INIT_POS Z_HOME_POS
 #endif
 
-xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_INIT_POS };
+xyze_pos_t current_position = LOGICAL_AXIS_ARRAY(0, X_HOME_POS, Y_HOME_POS, Z_INIT_POS);
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
@@ -188,30 +188,39 @@ xyz_pos_t cartes;
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
-  SERIAL_ECHOPAIR_P(X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z, SP_E_LBL, lpos.e);
+  SERIAL_ECHOPAIR_P(
+    LIST_N(DOUBLE(LINEAR_AXES), X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z)
+    #if HAS_EXTRUDERS
+      , SP_E_LBL, lpos.e
+    #endif
+  );
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
-  xyze_pos_t npos = cartes;
-  npos.e = planner.get_axis_position_mm(E_AXIS);
+  xyze_pos_t npos = LOGICAL_AXIS_ARRAY(
+    planner.get_axis_position_mm(E_AXIS),
+    cartes.x, cartes.y, cartes.z
+  );
+
   TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(npos, true));
+
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
   report_logical_position(current_position);
   report_more_positions();
 }
 
@@ -302,21 +311,23 @@ void quickstop_stepper() {
 
 /**
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   planner.set_position_mm(current_position);
 }
 
-void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
+#if HAS_EXTRUDERS
+  void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
+#endif
 
 /**
  * Get the stepper positions in the cartes[] array.
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
@@ -347,21 +358,24 @@ void get_cartesian_from_steppers() {
  *
  * To prevent small shifts in axis position always call
  * sync_plan_position after updating axes with this.
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   xyze_pos_t pos = cartes;
-  pos.e = planner.get_axis_position_mm(E_AXIS);
+
+  #if HAS_EXTRUDERS
+    pos.e = planner.get_axis_position_mm(E_AXIS);
+  #endif
 
   #if HAS_POSITION_MODIFIERS
     planner.unapply_modifiers(pos, true);
   #endif
 
   if (axis == ALL_AXES_ENUM)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
@@ -435,23 +449,26 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 }
 
 /**
  * Plan a move to (X, Y, Z) with separation of the XY and Z components.
  *
  * - If Z is moving up, the Z move is done before XY.
  * - If Z is moving down, the Z move is done after XY.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const_feedRate_t fr_mm_s/*=0.0*/) {
+void do_blocking_move_to(
+  LINEAR_AXIS_LIST(const float rx, const float ry, const float rz),
+  const_feedRate_t fr_mm_s/*=0.0f*/
+) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
-  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", rx, ry, rz);
+  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", LINEAR_AXIS_LIST(rx, ry, rz));
 
   const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if EITHER(DELTA, IS_SCARA)
     if (!position_is_reachable(rx, ry)) return;
     destination = current_position;          // sync destination at the start
   #endif
 
   #if ENABLED(DELTA)
@@ -522,48 +539,60 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const_f
       current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, current_position.z, current_position.i), fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, raw.z), fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+  do_blocking_move_to(LINEAR_AXIS_LIST(raw.x, raw.y, raw.z), fr_mm_s);
 }
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(rx, current_position.y, current_position.z, fr_mm_s);
+  do_blocking_move_to(
+    LINEAR_AXIS_LIST(rx, current_position.y, current_position.z),
+    fr_mm_s
+  );
 }
 void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position.x, ry, current_position.z, fr_mm_s);
+  do_blocking_move_to(
+    LINEAR_AXIS_LIST(current_position.x, ry, current_position.z),
+    fr_mm_s
+  );
 }
 void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
 }
 
 void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
+  do_blocking_move_to(
+    LINEAR_AXIS_LIST(rx, ry, current_position.z),
+    fr_mm_s
+  );
 }
 void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
-  do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
+  do_blocking_move_to(
+    LINEAR_AXIS_LIST(raw.x, raw.y, z),
+    fr_mm_s
+  );
 }
 
 void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
   float zdest = zclear;
   if (!lower_allowed) NOLESS(zdest, current_position.z);
   do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
@@ -582,22 +611,22 @@ void remember_feedrate_scaling_off() {
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   soft_endstops_t soft_endstop = {
     true, false,
-    { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
-    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS }
+    LINEAR_AXIS_ARRAY(X_MIN_POS, Y_MIN_POS, Z_MIN_POS),
+    LINEAR_AXIS_ARRAY(X_MAX_BED, Y_MAX_BED, Z_MAX_POS)
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -1169,34 +1198,39 @@ void prepare_line_to_destination() {
 
 #if HAS_ENDSTOPS
 
   linear_axis_bits_t axis_homed, axis_trusted; // = 0
 
   linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     auto set_should = [](linear_axis_bits_t &b, AxisEnum a) {
       if (TEST(b, a) && TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(a))
         CBI(b, a);
     };
-    set_should(axis_bits, X_AXIS);  // Clear test bits that are trusted
-    set_should(axis_bits, Y_AXIS);
-    set_should(axis_bits, Z_AXIS);
+    // Clear test bits that are trusted
+    LINEAR_AXIS_CODE(
+      set_should(axis_bits, X_AXIS),
+      set_should(axis_bits, Y_AXIS),
+      set_should(axis_bits, Z_AXIS)
+    );
     return axis_bits;
   }
 
   bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
-        TEST(axis_bits, X_AXIS) ? "X" : "",
-        TEST(axis_bits, Y_AXIS) ? "Y" : "",
-        TEST(axis_bits, Z_AXIS) ? "Z" : ""
+        LINEAR_AXIS_LIST(
+          TEST(axis_bits, X_AXIS) ? "X" : "",
+          TEST(axis_bits, Y_AXIS) ? "Y" : "",
+          TEST(axis_bits, Z_AXIS) ? "Z" : ""
+        )
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
       TERN_(HAS_STATUS_MESSAGE, ui.set_status(msg));
       return true;
     }
     return false;
   }
 
   /**
@@ -1349,21 +1383,21 @@ void prepare_line_to_destination() {
 
   /**
    * Home an individual linear axis
    */
   void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
     DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
     const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("...(", AS_CHAR(axis_codes[axis]), ", ", distance, ", ");
+      DEBUG_ECHOPAIR("...(", AS_CHAR(AXIS_CHAR(axis)), ", ", distance, ", ");
       if (fr_mm_s)
         DEBUG_ECHO(fr_mm_s);
       else
         DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
       DEBUG_ECHOLNPGM(")");
     }
 
     // Only do some things when moving towards an endstop
     const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                   ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
@@ -1434,26 +1468,26 @@ void prepare_line_to_destination() {
       TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", AS_CHAR(axis_codes[axis]), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     set_axis_untrusted(axis);
     set_axis_unhomed(axis);
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", AS_CHAR(axis_codes[axis]), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
   }
 
   #ifdef TMC_HOME_PHASE
     /**
      * Move the axis back to its home_phase if set and driver is capable (TMC)
      *
      * Improves homing repeatability by homing to stepper coil's nearest absolute
      * phase position. Trinamic drivers use a stepper phase table with 1024 values
@@ -1500,32 +1534,32 @@ void prepare_line_to_destination() {
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
-                         ". Pick a different phase for ", AS_CHAR(axis_codes[axis]));
+                         ". Pick a different phase for ", AS_CHAR(AXIS_CHAR(axis)));
 
       // Skip to next if target position is behind current. So it only moves away from endstop.
       if (phaseDelta < 0) phaseDelta += 1024;
 
       // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
       const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
       // Optional debug messages
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPAIR(
-          "Endstop ", AS_CHAR(axis_codes[axis]), " hit at Phase:", phaseCurrent,
+          "Endstop ", AS_CHAR(AXIS_CHAR(axis)), " hit at Phase:", phaseCurrent,
           " Delta:", phaseDelta, " Distance:", mmDelta
         );
       }
 
       if (mmDelta != 0) {
         // Retrace by the amount computed in mmDelta.
         do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
       }
     }
   #endif
@@ -1549,21 +1583,21 @@ void prepare_line_to_destination() {
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
         || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
         || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
       ))
       if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(axis_codes[axis]), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
       return;
 
@@ -1627,21 +1661,21 @@ void prepare_line_to_destination() {
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
         }
         if (TEST(endstops.state(), es)) {
-          SERIAL_ECHO_MSG("Bad ", AS_CHAR(axis_codes[axis]), " Endstop?");
+          SERIAL_ECHO_MSG("Bad ", AS_CHAR(AXIS_CHAR(axis)), " Endstop?");
           kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
         if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
@@ -1849,21 +1883,21 @@ void prepare_line_to_destination() {
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", AS_CHAR(axis_codes[axis]), ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
   } // homeaxis()
 
 #endif // HAS_ENDSTOPS
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
@@ -1874,21 +1908,21 @@ void prepare_line_to_destination() {
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
 
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
@@ -1924,24 +1958,24 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
-      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
+      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(AXIS_CHAR(axis)), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
-    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
+    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", AS_CHAR(AXIS_CHAR(axis)), ")");
   }
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 235a969f66..6801b210af 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -404,45 +404,41 @@ void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
   }
 
 #endif // IS_KINEMATIC
 
 /**
  * Do a fast or normal move to 'destination' with an optional FR.
  *  - Move at normal speed regardless of feedrate percentage.
  *  - Extrude the specified length regardless of flow percentage.
  */
 void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
-  #if IS_KINEMATIC
-    , const bool is_fast/*=false*/
-  #endif
+  OPTARG(IS_KINEMATIC, const bool is_fast/*=false*/)
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
   #if HAS_EXTRUDERS
     const float old_fac = planner.e_factor[active_extruder];
     planner.e_factor[active_extruder] = 1.0f;
   #endif
 
   if (TERN0(IS_KINEMATIC, is_fast))
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
-  #if HAS_EXTRUDERS
-    planner.e_factor[active_extruder] = old_fac;
-  #endif
+  TERN_(HAS_EXTRUDERS, planner.e_factor[active_extruder] = old_fac);
 }
 
 /**
  * Plan a move to (X, Y, Z) with separation of the XY and Z components.
  *
  * - If Z is moving up, the Z move is done before XY.
  * - If Z is moving down, the Z move is done after XY.
  * - Delta may lower Z first to get into the free motion zone.
  * - Before returning, wait for the planner buffer to empty.
  */
@@ -600,24 +596,22 @@ void restore_feedrate_and_scaling() {
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
   void update_software_endstops(const AxisEnum axis
-    #if HAS_HOTEND_OFFSET
-      , const uint8_t old_tool_index/*=0*/
-      , const uint8_t new_tool_index/*=0*/
-    #endif
+    OPTARG(HAS_HOTEND_OFFSET, const uint8_t old_tool_index/*=0*/)
+    OPTARG(HAS_HOTEND_OFFSET, const uint8_t new_tool_index/*=0*/)
   ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = _MAX(hotend_offset[1].x, X2_MAX_POS);
 
         if (new_tool_index != 0) {
@@ -851,31 +845,27 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
     // Get the current position as starting point
     xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
     millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
       segment_idle(next_idle_ms);
       raw += segment_distance;
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
-        #if ENABLED(SCARA_FEEDRATE_SCALING)
-          , inv_duration
-        #endif
+        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
       )) break;
     }
 
     // Ensure last segment arrives at target location.
     planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , inv_duration
-      #endif
+      OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
     );
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
@@ -922,23 +912,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
-          #if ENABLED(SCARA_FEEDRATE_SCALING)
-            , inv_duration
-          #endif
+          OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
         )) break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
       planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ec57b37a71..235a969f66 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -367,21 +367,21 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
-#if EXTRUDERS
+#if HAS_EXTRUDERS
   void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s) {
     TERN_(HAS_FILAMENT_SENSOR, runout.reset());
     current_position.e += length / planner.e_factor[active_extruder];
     line_to_current_position(fr_mm_s);
     planner.synchronize();
   }
 #endif
 
 #if IS_KINEMATIC
 
@@ -414,33 +414,33 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   #if IS_KINEMATIC
     , const bool is_fast/*=false*/
   #endif
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     const float old_fac = planner.e_factor[active_extruder];
     planner.e_factor[active_extruder] = 1.0f;
   #endif
 
   if (TERN0(IS_KINEMATIC, is_fast))
     TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) with separation of the XY and Z components.
  *
  * - If Z is moving up, the Z move is done before XY.
  * - If Z is moving down, the Z move is done after XY.
  * - Delta may lower Z first to get into the free motion zone.

commit f4951ed56b3fe7b2f85c039677dc9a499d537e8f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:25:54 2021 -0500

    üé® Rename all/no axis enums

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 69aed1e192..ec57b37a71 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -275,21 +275,21 @@ void report_current_position_projected() {
 
 #endif
 
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
-  set_current_from_steppers_for_axis(ALL_AXES_MASK);
+  set_current_from_steppers_for_axis(ALL_AXES_ENUM);
   sync_plan_position();
 }
 
 #if ENABLED(REALTIME_REPORTING_COMMANDS)
 
   void quickpause_stepper() {
     planner.quick_pause();
     //planner.synchronize();
   }
 
@@ -353,21 +353,21 @@ void get_cartesian_from_steppers() {
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   xyze_pos_t pos = cartes;
   pos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
     planner.unapply_modifiers(pos, true);
   #endif
 
-  if (axis == ALL_AXES_MASK)
+  if (axis == ALL_AXES_ENUM)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    üé® Flags for homing directions

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 52d9dec904..69aed1e192 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1371,21 +1371,21 @@ void prepare_line_to_destination() {
       DEBUG_ECHOPAIR("...(", AS_CHAR(axis_codes[axis]), ", ", distance, ", ");
       if (fr_mm_s)
         DEBUG_ECHO(fr_mm_s);
       else
         DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
       DEBUG_ECHOLNPGM(")");
     }
 
     // Only do some things when moving towards an endstop
     const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
-                  ? x_home_dir(active_extruder) : home_dir(axis);
+                  ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
     const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states;
     #endif
 
     if (is_home_dir) {
 
       if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
         #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
@@ -1555,30 +1555,30 @@ void prepare_line_to_destination() {
 
   void homeaxis(const AxisEnum axis) {
 
     #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
-        || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
-        || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
+        || TERN0(A##_HOME_TO_MIN, A##_MIN_PIN > -1) \
+        || TERN0(A##_HOME_TO_MAX, A##_MAX_PIN > -1) \
       ))
       if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
     #endif
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(axis_codes[axis]), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
-                ? x_home_dir(active_extruder) : home_dir(axis);
+                ? TOOL_X_HOME_DIR(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
       return;
 
     // Set flags for X, Y, Z motor locking
     #if HAS_EXTRA_ENDSTOPS
       switch (axis) {
@@ -1909,21 +1909,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
-  #if HAS_BED_PROBE && Z_HOME_DIR < 0
+  #if HAS_BED_PROBE && Z_HOME_TO_MIN
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
         current_position.z -= probe.offset.z;
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");

commit 458677c63a3f9ae32c988e2ab10d8f3a0935bf50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:56:05 2021 -0500

    ‚ôªÔ∏è Refactor axis homing/trusted state bits

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 427aea80b1..52d9dec904 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1174,32 +1174,34 @@ void prepare_line_to_destination() {
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
 #if HAS_ENDSTOPS
 
-  uint8_t axis_homed, axis_trusted; // = 0
-
-  uint8_t axes_should_home(uint8_t axis_bits/*=0x07*/) {
-    #define SHOULD_HOME(A) TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(A)
-    // Clear test bits that are trusted
-    if (TEST(axis_bits, X_AXIS) && SHOULD_HOME(X_AXIS)) CBI(axis_bits, X_AXIS);
-    if (TEST(axis_bits, Y_AXIS) && SHOULD_HOME(Y_AXIS)) CBI(axis_bits, Y_AXIS);
-    if (TEST(axis_bits, Z_AXIS) && SHOULD_HOME(Z_AXIS)) CBI(axis_bits, Z_AXIS);
+  linear_axis_bits_t axis_homed, axis_trusted; // = 0
+
+  linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits/*=linear_bits*/) {
+    auto set_should = [](linear_axis_bits_t &b, AxisEnum a) {
+      if (TEST(b, a) && TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(a))
+        CBI(b, a);
+    };
+    set_should(axis_bits, X_AXIS);  // Clear test bits that are trusted
+    set_should(axis_bits, Y_AXIS);
+    set_should(axis_bits, Z_AXIS);
     return axis_bits;
   }
 
-  bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
+  bool homing_needed_error(linear_axis_bits_t axis_bits/*=linear_bits*/) {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
         TEST(axis_bits, X_AXIS) ? "X" : "",
         TEST(axis_bits, Y_AXIS) ? "Y" : "",
         TEST(axis_bits, Z_AXIS) ? "Z" : ""
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 97be6226ba..427aea80b1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -117,21 +117,21 @@ xyze_pos_t destination; // {0}
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       !tmp[X_AXIS][0] && !tmp[Y_AXIS][0] && !tmp[Z_AXIS][0],
       "Offsets for the first hotend must be 0.0."
     );
     // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]
-    HOTEND_LOOP() LOOP_XYZ(a) hotend_offset[e][a] = tmp[a][e];
+    HOTEND_LOOP() LOOP_LINEAR_AXES(a) hotend_offset[e][a] = tmp[a][e];
     #if ENABLED(DUAL_X_CARRIAGE)
       hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS);
     #endif
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
@@ -275,21 +275,21 @@ void report_current_position_projected() {
 
 #endif
 
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
-  set_current_from_steppers_for_axis(ALL_AXES);
+  set_current_from_steppers_for_axis(ALL_AXES_MASK);
   sync_plan_position();
 }
 
 #if ENABLED(REALTIME_REPORTING_COMMANDS)
 
   void quickpause_stepper() {
     planner.quick_pause();
     //planner.synchronize();
   }
 
@@ -353,21 +353,21 @@ void get_cartesian_from_steppers() {
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   xyze_pos_t pos = cartes;
   pos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
     planner.unapply_modifiers(pos, true);
   #endif
 
-  if (axis == ALL_AXES)
+  if (axis == ALL_AXES_MASK)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
@@ -674,21 +674,21 @@ void restore_feedrate_and_scaling() {
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
     if (DEBUGGING(LEVELING))
-      SERIAL_ECHOLNPAIR("Axis ", AS_CHAR(XYZ_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+      SERIAL_ECHOLNPAIR("Axis ", AS_CHAR(AXIS_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
   }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
@@ -1944,21 +1944,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
       DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
   }
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", AS_CHAR(XYZ_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", AS_CHAR(AXIS_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 171d9520cb..97be6226ba 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -76,27 +76,27 @@
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
-xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS,
-  #ifdef Z_IDLE_HEIGHT
-    Z_IDLE_HEIGHT
-  #else
-    Z_HOME_POS
-  #endif
-};
+#ifdef Z_IDLE_HEIGHT
+  #define Z_INIT_POS Z_IDLE_HEIGHT
+#else
+  #define Z_INIT_POS Z_HOME_POS
+#endif
+
+xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_INIT_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
@@ -197,25 +197,21 @@ inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPAIR_P(X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z, SP_E_LBL, lpos.e);
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = cartes;
   npos.e = planner.get_axis_position_mm(E_AXIS);
-
-  #if HAS_POSITION_MODIFIERS
-    planner.unapply_modifiers(npos, true);
-  #endif
-
+  TERN_(HAS_POSITION_MODIFIERS, planner.unapply_modifiers(npos, true));
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
   report_logical_position(current_position);
   report_more_positions();
 }
 

commit 7f774cab9005dd56667bf4db09c23370bd2c873f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Sat May 15 15:02:20 2021 -0500

    M154 Position Auto-Report (#18427)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6ca8dc054c..171d9520cb 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -223,20 +223,25 @@ void report_current_position() {
  * Report the logical current position according to the most recent G-code command.
  * The planner.position always corresponds to the last G-code too. This makes M114
  * suitable for debugging kinematics and leveling while avoiding planner sync that
  * definitively interrupts the printing flow.
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
+#if ENABLED(AUTO_REPORT_POSITION)
+  //struct PositionReport { void report() { report_current_position_projected(); } };
+  AutoReporter<PositionReport> position_auto_reporter;
+#endif
+
 #if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
 
   M_StateEnum M_State_grbl = M_INIT;
 
   /**
    * Output the current grbl compatible state to serial while moving
    */
   void report_current_grblstate_moving() { SERIAL_ECHOLNPAIR("S_XYZ:", int(M_State_grbl)); }
 
   /**

commit 0d629c80c7e218cbe07a85ba0d9bfeb49feb65c6
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Wed May 12 10:17:06 2021 +0300

    ü©π G60-G61 Save E position (#21810)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7c0f8f404a..6ca8dc054c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -95,21 +95,21 @@ xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS,
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
   uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
-  xyz_pos_t stored_position[SAVED_POSITIONS];
+  xyze_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // The active extruder (tool). Set with T<extruder> command.
 #if HAS_MULTI_EXTRUDER
   uint8_t active_extruder = 0; // = 0
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   float e_move_accumulator; // = 0
 #endif

commit fb2bfe1cef1daeec13760c29d055b4323e65c25c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun May 2 19:05:15 2021 -0300

    Fix bad DELTA probe move (#21781)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 584e894ae6..7c0f8f404a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -419,21 +419,21 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
   #if EXTRUDERS
     const float old_fac = planner.e_factor[active_extruder];
     planner.e_factor[active_extruder] = 1.0f;
   #endif
 
   if (TERN0(IS_KINEMATIC, is_fast))
-    TERN(IS_KINEMATIC, NOOP, prepare_line_to_destination());
+    TERN(IS_KINEMATIC, prepare_fast_move_to_destination(), NOOP);
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6058db37b3..584e894ae6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -223,31 +223,89 @@ void report_current_position() {
  * Report the logical current position according to the most recent G-code command.
  * The planner.position always corresponds to the last G-code too. This makes M114
  * suitable for debugging kinematics and leveling while avoiding planner sync that
  * definitively interrupts the printing flow.
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
+#if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+
+  M_StateEnum M_State_grbl = M_INIT;
+
+  /**
+   * Output the current grbl compatible state to serial while moving
+   */
+  void report_current_grblstate_moving() { SERIAL_ECHOLNPAIR("S_XYZ:", int(M_State_grbl)); }
+
+  /**
+   * Output the current position (processed) to serial while moving
+   */
+  void report_current_position_moving() {
+
+    get_cartesian_from_steppers();
+    const xyz_pos_t lpos = cartes.asLogical();
+    SERIAL_ECHOPAIR("X:", lpos.x, " Y:", lpos.y, " Z:", lpos.z, " E:", current_position.e);
+
+    stepper.report_positions();
+    #if IS_SCARA
+      scara_report_positions();
+    #endif
+
+    report_current_grblstate_moving();
+  }
+
+  /**
+   * Set a Grbl-compatible state from the current marlin_state
+   */
+  M_StateEnum grbl_state_for_marlin_state() {
+    switch (marlin_state) {
+      case MF_INITIALIZING: return M_INIT;
+      case MF_SD_COMPLETE:  return M_ALARM;
+      case MF_WAITING:      return M_IDLE;
+      case MF_STOPPED:      return M_END;
+      case MF_RUNNING:      return M_RUNNING;
+      case MF_PAUSED:       return M_HOLD;
+      case MF_KILLED:       return M_ERROR;
+      default:              return M_IDLE;
+    }
+  }
+
+#endif
+
 /**
  * Run out the planner buffer and re-sync the current
  * position from the last-updated stepper positions.
  */
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   sync_plan_position();
 }
 
+#if ENABLED(REALTIME_REPORTING_COMMANDS)
+
+  void quickpause_stepper() {
+    planner.quick_pause();
+    //planner.synchronize();
+  }
+
+  void quickresume_stepper() {
+    planner.quick_resume();
+    //planner.synchronize();
+  }
+
+#endif
+
 /**
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   planner.set_position_mm(current_position);
 }
 
 void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }

commit 3517fbdcbdbb3ba790b0aac55e3ffb03e94f3307
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 12 20:58:34 2021 -0500

    Blocking move followup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9c1f8cd4ad..6058db37b3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -360,25 +360,22 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
   #if EXTRUDERS
     const float old_fac = planner.e_factor[active_extruder];
     planner.e_factor[active_extruder] = 1.0f;
   #endif
 
-  #if !IS_KINEMATIC
-    constexpr bool is_fast = false;
-  #endif
-  if (is_fast)
-    prepare_fast_move_to_destination();
+  if (TERN0(IS_KINEMATIC, is_fast))
+    TERN(IS_KINEMATIC, NOOP, prepare_line_to_destination());
   else
     prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 

commit 4044ed8783c71dd66d64737173ca31c8a0ea0f5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 12 20:15:41 2021 -0500

    Add 'blocking move' comments

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index afd30a44e0..9c1f8cd4ad 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -360,58 +360,65 @@ void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
   #if EXTRUDERS
     const float old_fac = planner.e_factor[active_extruder];
     planner.e_factor[active_extruder] = 1.0f;
   #endif
 
-  #if IS_KINEMATIC
-    if (is_fast)
-      prepare_fast_move_to_destination();
-    else
+  #if !IS_KINEMATIC
+    constexpr bool is_fast = false;
   #endif
-      prepare_line_to_destination();
+  if (is_fast)
+    prepare_fast_move_to_destination();
+  else
+    prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
- * Plan a move to (X, Y, Z) and set the current_position
+ * Plan a move to (X, Y, Z) with separation of the XY and Z components.
+ *
+ * - If Z is moving up, the Z move is done before XY.
+ * - If Z is moving down, the Z move is done after XY.
+ * - Delta may lower Z first to get into the free motion zone.
+ * - Before returning, wait for the planner buffer to empty.
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const_feedRate_t fr_mm_s/*=0.0*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", rx, ry, rz);
 
   const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
-  #if ENABLED(DELTA)
-
+  #if EITHER(DELTA, IS_SCARA)
     if (!position_is_reachable(rx, ry)) return;
+    destination = current_position;          // sync destination at the start
+  #endif
 
-    REMEMBER(fr, feedrate_mm_s, xy_feedrate);
+  #if ENABLED(DELTA)
 
-    destination = current_position;          // sync destination at the start
+    REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 
     // when in the danger zone
     if (current_position.z > delta_clip_start_height) {
-      if (rz > delta_clip_start_height) {   // staying in the danger zone
-        destination.set(rx, ry, rz);        // move directly (uninterpolated)
+      if (rz > delta_clip_start_height) {                     // staying in the danger zone
+        destination.set(rx, ry, rz);                          // move directly (uninterpolated)
         prepare_internal_fast_move_to_destination();          // set current_position from destination
         if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
       destination.z = delta_clip_start_height;
       prepare_internal_fast_move_to_destination();            // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
     if (rz > current_position.z) {                            // raising?
@@ -425,24 +432,20 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const_f
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
     if (rz < current_position.z) {                            // lowering?
       destination.z = rz;
       prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
-    if (!position_is_reachable(rx, ry)) return;
-
-    destination = current_position;
-
     // If Z needs to raise, do it before moving XY
     if (destination.z < rz) {
       destination.z = rz;
       prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
     destination.set(rx, ry);
     prepare_internal_fast_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY

commit 1a2cbe100c279b0dd12a70f5e9179a6f9b555e32
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Fri Apr 9 04:03:34 2021 +0200

    Macros to eliminate 'f + 0.0' (#21568)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 48535b63d6..afd30a44e0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -576,21 +576,21 @@ void restore_feedrate_and_scaling() {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop.min[axis] = base_min_pos(axis);
-      soft_endstop.max[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_max_pos(axis);
+      soft_endstop.max[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_max_pos(axis);
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
           delta_clip_start_height = soft_endstop.max[axis] - delta_safe_distance_from_top();
@@ -1840,21 +1840,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if EITHER(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_home_pos(axis);
+    current_position[axis] = (axis == Z_AXIS) ? DIFF_TERN(HAS_BED_PROBE, delta_height, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE

commit 1879eede0d2910cac58f2a90b95989ff4531fa6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 7 15:43:07 2021 -0500

    Fix axis char printing

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 81c3a81fbe..48535b63d6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -615,21 +615,21 @@ void restore_feedrate_and_scaling() {
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
     if (DEBUGGING(LEVELING))
-      SERIAL_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+      SERIAL_ECHOLNPAIR("Axis ", AS_CHAR(XYZ_CHAR(axis)), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
   }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
@@ -1385,26 +1385,26 @@ void prepare_line_to_destination() {
       TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
     }
   }
 
   /**
    * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
    * that has no endstops. Such machines should always be considered to be in a "known" and
    * "trusted" position).
    */
   void set_axis_never_homed(const AxisEnum axis) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", AS_CHAR(axis_codes[axis]), ")");
 
     set_axis_untrusted(axis);
     set_axis_unhomed(axis);
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", AS_CHAR(axis_codes[axis]), ")");
 
     TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
   }
 
   #ifdef TMC_HOME_PHASE
     /**
      * Move the axis back to its home_phase if set and driver is capable (TMC)
      *
      * Improves homing repeatability by homing to stepper coil's nearest absolute
      * phase position. Trinamic drivers use a stepper phase table with 1024 values
@@ -1451,32 +1451,32 @@ void prepare_line_to_destination() {
         default: return;
       }
 
       // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
       int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
       // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
       if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
         SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
                          " too close to endstop trigger phase ", phaseCurrent,
-                         ". Pick a different phase for ", axis_codes[axis]);
+                         ". Pick a different phase for ", AS_CHAR(axis_codes[axis]));
 
       // Skip to next if target position is behind current. So it only moves away from endstop.
       if (phaseDelta < 0) phaseDelta += 1024;
 
       // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
       const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
       // Optional debug messages
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPAIR(
-          "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
+          "Endstop ", AS_CHAR(axis_codes[axis]), " hit at Phase:", phaseCurrent,
           " Delta:", phaseDelta, " Distance:", mmDelta
         );
       }
 
       if (mmDelta != 0) {
         // Retrace by the amount computed in mmDelta.
         do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
       }
     }
   #endif
@@ -1500,21 +1500,21 @@ void prepare_line_to_destination() {
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
         || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
         || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
       ))
       if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", AS_CHAR(axis_codes[axis]), ")");
 
     const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? x_home_dir(active_extruder) : home_dir(axis);
 
     //
     // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
     //
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
       return;
 
@@ -1578,21 +1578,21 @@ void prepare_line_to_destination() {
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
         }
         if (TEST(endstops.state(), es)) {
-          SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
+          SERIAL_ECHO_MSG("Bad ", AS_CHAR(axis_codes[axis]), " Endstop?");
           kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
         }
       #endif
 
       #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
         if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
       #endif
 
       // Slow move towards endstop until triggered
       const float rebump = bump * 2;
@@ -1800,21 +1800,21 @@ void prepare_line_to_destination() {
           ) safe_delay(200);  // Short delay to allow belts to spring back
         #endif
       }
     #endif
 
     // Clear retracted status if homing the Z axis
     #if ENABLED(FWRETRACT)
       if (axis == Z_AXIS) fwretract.current_hop = 0.0;
     #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", AS_CHAR(axis_codes[axis]), ")");
 
   } // homeaxis()
 
 #endif // HAS_ENDSTOPS
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
@@ -1878,28 +1878,28 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
-    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
+    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
   }
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", AS_CHAR(XYZ_CHAR(axis)), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 28ad9cf761..81c3a81fbe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -304,39 +304,39 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
   if (axis == ALL_AXES)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
+void line_to_current_position(const_feedRate_t fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
 #if EXTRUDERS
-  void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s) {
+  void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s) {
     TERN_(HAS_FILAMENT_SENSOR, runout.reset());
     current_position.e += length / planner.e_factor[active_extruder];
     line_to_current_position(fr_mm_s);
     planner.synchronize();
   }
 #endif
 
 #if IS_KINEMATIC
 
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
    */
-  void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
+  void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // UBL segmented line will do Z-only moves in single segment
       ubl.line_to_destination_segmented(scaled_fr_mm_s);
     #else
       if (current_position == destination) return;
 
       planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     #endif
@@ -344,21 +344,21 @@ void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
     current_position = destination;
   }
 
 #endif // IS_KINEMATIC
 
 /**
  * Do a fast or normal move to 'destination' with an optional FR.
  *  - Move at normal speed regardless of feedrate percentage.
  *  - Extrude the specified length regardless of flow percentage.
  */
-void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
+void _internal_move_to_destination(const_feedRate_t fr_mm_s/*=0.0f*/
   #if IS_KINEMATIC
     , const bool is_fast/*=false*/
   #endif
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
@@ -377,21 +377,21 @@ void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to(const float rx, const float ry, const float rz, const_feedRate_t fr_mm_s/*=0.0*/) {
   DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", rx, ry, rz);
 
   const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
@@ -466,52 +466,52 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
     if (current_position.z > rz) {
       current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
   planner.synchronize();
 }
 
-void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
 }
-void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
 }
-void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
 }
 
-void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position.y, current_position.z, fr_mm_s);
 }
-void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position.x, ry, current_position.z, fr_mm_s);
 }
-void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
 }
 
-void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
-void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
-void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
+void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
-void do_z_clearance(const float &zclear, const bool lower_allowed/*=false*/) {
+void do_z_clearance(const_float_t zclear, const bool lower_allowed/*=false*/) {
   float zdest = zclear;
   if (!lower_allowed) NOLESS(zdest, current_position.z);
   do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
@@ -819,21 +819,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
      *
      * This calls planner.buffer_line several times, adding
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
-    inline void segmented_line_to_destination(const feedRate_t &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
+    inline void segmented_line_to_destination(const_feedRate_t fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
       const xyze_float_t diff = destination - current_position;
 
       // If the move is only in Z/E don't split up the move
       if (!diff.x && !diff.y) {
         planner.buffer_line(destination, fr_mm_s, active_extruder);
         return;
       }
 
       // Get the linear distance in XYZ

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b0a4890e07..28ad9cf761 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -44,21 +44,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
-#if HAS_DISPLAY
+#if HAS_STATUS_MESSAGE
   #include "../lcd/marlinui.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
@@ -1137,21 +1137,21 @@ void prepare_line_to_destination() {
     if ((axis_bits = axes_should_home(axis_bits))) {
       PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
       char msg[strlen_P(home_first)+1];
       sprintf_P(msg, home_first,
         TEST(axis_bits, X_AXIS) ? "X" : "",
         TEST(axis_bits, Y_AXIS) ? "Y" : "",
         TEST(axis_bits, Z_AXIS) ? "Z" : ""
       );
       SERIAL_ECHO_START();
       SERIAL_ECHOLN(msg);
-      TERN_(HAS_DISPLAY, ui.set_status(msg));
+      TERN_(HAS_STATUS_MESSAGE, ui.set_status(msg));
       return true;
     }
     return false;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #if HOMING_Z_WITH_PROBE

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2f4f5e283a..b0a4890e07 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -933,25 +933,25 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   bool extruder_duplication_enabled;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     uint8_t duplication_e_mask; // = 0
   #endif
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x              = X2_MAX_POS,                    // Used in mode 0 & 1
-        duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // Used in mode 2
+        duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // Used in mode 2 & 3
   xyz_pos_t raised_parked_position;                                       // Used in mode 1
-  bool active_extruder_parked            = false;                         // Used in mode 1 & 2
+  bool active_extruder_parked            = false;                         // Used in mode 1, 2 & 3
   millis_t delayed_move_time             = 0;                             // Used in mode 1
-  int16_t duplicate_extruder_temp_offset = 0;                             // Used in mode 2
+  celsius_t duplicate_extruder_temp_offset = 0;                           // Used in mode 2 & 3
   bool idex_mirrored_mode                = false;                         // Used in mode 3
 
   float x_home_pos(const uint8_t extruder) {
     if (extruder == 0)
       return X_HOME_POS;
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position

commit a0d312396adb089d31b1d4c1379d86dcd5b734ee
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Mar 5 00:34:38 2021 +0100

    Followup to MP_SCARA/TPARA patches (#21248)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 024f28dc9f..2f4f5e283a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -756,21 +756,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / scaled_fr_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
-    uint16_t segments = delta_segments_per_second * seconds;
+    uint16_t segments = segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment

commit dd388aedfda25796c86b532605b26b1e598ce410
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 3 17:57:24 2021 -0600

    TPARA followup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7b4d1e36b3..024f28dc9f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -256,24 +256,24 @@ void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
  * Get the stepper positions in the cartes[] array.
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
-    forward_kinematics_DELTA(planner.get_axis_positions_mm());
+    forward_kinematics(planner.get_axis_positions_mm());
   #else
     #if IS_SCARA
-      forward_kinematics_SCARA(
+      forward_kinematics(
           planner.get_axis_position_degrees(A_AXIS)
         , planner.get_axis_position_degrees(B_AXIS)
         #if ENABLED(AXEL_TPARA)
           , planner.get_axis_position_degrees(C_AXIS)
         #endif
       );
     #else
       cartes.x = planner.get_axis_position_mm(X_AXIS);
       cartes.y = planner.get_axis_position_mm(Y_AXIS);
     #endif
@@ -942,21 +942,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   float inactive_extruder_x              = X2_MAX_POS,                    // Used in mode 0 & 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // Used in mode 2
   xyz_pos_t raised_parked_position;                                       // Used in mode 1
   bool active_extruder_parked            = false;                         // Used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // Used in mode 1
   int16_t duplicate_extruder_temp_offset = 0;                             // Used in mode 2
   bool idex_mirrored_mode                = false;                         // Used in mode 3
 
   float x_home_pos(const uint8_t extruder) {
     if (extruder == 0)
-      return base_home_pos(X_AXIS);
+      return X_HOME_POS;
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
       return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
   }
 

commit a46e0257252bcd50f4c7acb04215f3ad2a92047c
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Mar 3 20:46:32 2021 -0300

    TPARA - 3DOF robot arm IK (#21005)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6fff80ff74..7b4d1e36b3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -260,25 +260,29 @@ void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics_DELTA(planner.get_axis_positions_mm());
   #else
     #if IS_SCARA
       forward_kinematics_SCARA(
-        planner.get_axis_position_degrees(A_AXIS),
-        planner.get_axis_position_degrees(B_AXIS)
+          planner.get_axis_position_degrees(A_AXIS)
+        , planner.get_axis_position_degrees(B_AXIS)
+        #if ENABLED(AXEL_TPARA)
+          , planner.get_axis_position_degrees(C_AXIS)
+        #endif
       );
     #else
-      cartes.set(planner.get_axis_position_mm(X_AXIS), planner.get_axis_position_mm(Y_AXIS));
+      cartes.x = planner.get_axis_position_mm(X_AXIS);
+      cartes.y = planner.get_axis_position_mm(Y_AXIS);
     #endif
     cartes.z = planner.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
@@ -1333,21 +1337,21 @@ void prepare_line_to_destination() {
           thermalManager.wait_for_hotend_heating(active_extruder);
         #endif
 
         TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
       }
 
       // Disable stealthChop if used. Enable diag1 pin on driver.
       TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
     }
 
-    #if IS_SCARA
+    #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Tell the planner the axis is at 0
       current_position[axis] = 0;
       sync_plan_position();
       current_position[axis] = distance;
       line_to_current_position(home_fr_mm_s);
     #else
       // Get the ABC or XYZ positions in mm
       abce_pos_t target = planner.get_axis_positions_mm();
 
       target[axis] = 0;                         // Set the single homing axis to 0
@@ -1483,21 +1487,21 @@ void prepare_line_to_destination() {
    * to the individual ABC steppers on DELTA and SCARA.
    *
    * At the end of the procedure the axis is marked as
    * homed and the current position of that axis is updated.
    * Kinematic robots should wait till all axes are homed
    * before updating the current position.
    */
 
   void homeaxis(const AxisEnum axis) {
 
-    #if IS_SCARA
+    #if EITHER(MORGAN_SCARA, MP_SCARA)
       // Only Z homing (with probe) is permitted
       if (axis != Z_AXIS) { BUZZ(100, 880); return; }
     #else
       #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
            ENABLED(A##_SPI_SENSORLESS) \
         || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
         || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
         || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
       ))
       if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
@@ -1725,21 +1729,22 @@ void prepare_line_to_destination() {
       #endif
 
       // Reset flags for X, Y, Z motor locking
       switch (axis) {
         default: break;
         TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
         TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
         TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
           stepper.set_separate_multi_axis(false);
       }
-    #endif
+
+    #endif // HAS_EXTRA_ENDSTOPS
 
     #ifdef TMC_HOME_PHASE
       // move back to homing phase if configured and capable
       backout_to_tmc_homing_phase(axis);
     #endif
 
     #if IS_SCARA
 
       set_axis_is_at_home(axis);
       sync_plan_position();
@@ -1832,21 +1837,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
-  #if ENABLED(MORGAN_SCARA)
+  #if EITHER(MORGAN_SCARA, AXEL_TPARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */

commit dfa33082bbe7cdf2888349a301cfd6636430cd0a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 1 07:10:00 2021 -0600

    Fix some config builds

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 580700bfe2..6fff80ff74 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1562,21 +1562,21 @@ void prepare_line_to_destination() {
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
     #endif
 
     // If a second homing move is configured...
     if (bump) {
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
-      do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST) : 0, false);
+      do_homing_move(axis, -bump, TERN(HOMING_Z_WITH_PROBE, (axis == Z_AXIS ? z_probe_fast_mm_s : 0), 0), false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
         }

commit ee7701c15bc91f7a05f973e03624fb14815f5027
Author: jbuck2005 <59450931+jbuck2005@users.noreply.github.com>
Date:   Sat Feb 27 16:54:43 2021 -0500

    SPEED => FEEDRATE (#21217)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3e79e7dabf..580700bfe2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -173,21 +173,21 @@ xyz_pos_t cartes;
   // This offset is added to the configured home position.
   // Set by M206, M428, or menu item. Saved to EEPROM.
   xyz_pos_t home_offset{0};
 #endif
 #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   // The above two are combined to save on computes
   xyz_pos_t workspace_offset{0};
 #endif
 
 #if HAS_ABL_NOT_UBL
-  feedRate_t xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
+  feedRate_t xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_FEEDRATE);
 #endif
 
 /**
  * Output the current position to serial
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
@@ -1144,21 +1144,21 @@ void prepare_line_to_destination() {
       return true;
     }
     return false;
   }
 
   /**
    * Homing bump feedrate (mm/s)
    */
   feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #if HOMING_Z_WITH_PROBE
-      if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
+      if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_FEEDRATE_SLOW);
     #endif
     static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
     uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
     if (hbd < 1) {
       hbd = 10;
       SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
     }
     return homing_feedrate(axis) / float(hbd);
   }
 
@@ -1562,21 +1562,21 @@ void prepare_line_to_destination() {
     do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
     #endif
 
     // If a second homing move is configured...
     if (bump) {
       // Move away from the endstop by the axis HOMING_BUMP_MM
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
-      do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0, false);
+      do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST) : 0, false);
 
       #if ENABLED(DETECT_BROKEN_ENDSTOP)
         // Check for a broken endstop
         EndstopEnum es;
         switch (axis) {
           default:
           case X_AXIS: es = X_ENDSTOP; break;
           case Y_AXIS: es = Y_ENDSTOP; break;
           case Z_AXIS: es = Z_ENDSTOP; break;
         }

commit bcda46e3f3435a1f87d224be2f81778c1855deb7
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Feb 25 17:09:00 2021 +0100

    Combine Z_AFTER_DEACTIVATE with UNKNOWN_Z_NO_RAISE (#20444)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e2613b0185..3e79e7dabf 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -76,21 +76,27 @@
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
-xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
+xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS,
+  #ifdef Z_IDLE_HEIGHT
+    Z_IDLE_HEIGHT
+  #else
+    Z_HOME_POS
+  #endif
+};
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
@@ -487,23 +493,22 @@ void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &
   do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
-void do_z_clearance(const float &zclear, const bool z_trusted/*=true*/, const bool raise_on_untrusted/*=true*/, const bool lower_allowed/*=false*/) {
-  const bool rel = raise_on_untrusted && !z_trusted;
-  float zdest = zclear + (rel ? current_position.z : 0.0f);
+void do_z_clearance(const float &zclear, const bool lower_allowed/*=false*/) {
+  float zdest = zclear;
   if (!lower_allowed) NOLESS(zdest, current_position.z);
   do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;

commit 7fc75fc48263690cd8dd64686213d6a42d0795e6
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Feb 25 12:23:30 2021 -0300

    Zero Endstops followup (#21188)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 55973185ee..e2613b0185 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1386,21 +1386,21 @@ void prepare_line_to_destination() {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
 
     set_axis_untrusted(axis);
     set_axis_unhomed(axis);
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
 
     TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
   }
 
-  #if ENABLED(TMC_HOME_PHASE)
+  #ifdef TMC_HOME_PHASE
     /**
      * Move the axis back to its home_phase if set and driver is capable (TMC)
      *
      * Improves homing repeatability by homing to stepper coil's nearest absolute
      * phase position. Trinamic drivers use a stepper phase table with 1024 values
      * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
      */
     void backout_to_tmc_homing_phase(const AxisEnum axis) {
       const xyz_long_t home_phase = TMC_HOME_PHASE;
 

commit 735c1b6183739152eeddade4c06c17e3b0de38bc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Feb 25 06:28:27 2021 -0800

    PROBING_HEATERS_OFF sub-option WAIT_FOR_HOTEND (#20835)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 10d3585a73..55973185ee 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1311,25 +1311,30 @@ void prepare_line_to_destination() {
                   ? x_home_dir(active_extruder) : home_dir(axis);
     const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states;
     #endif
 
     if (is_home_dir) {
 
       if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
-        #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
+        #if BOTH(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
           // Wait for bed to heat back up between probing points
           thermalManager.wait_for_bed_heating();
         #endif
 
+        #if BOTH(HAS_HOTEND, WAIT_FOR_HOTEND)
+          // Wait for the hotend to heat back up between probing points
+          thermalManager.wait_for_hotend_heating(active_extruder);
+        #endif
+
         TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
       }
 
       // Disable stealthChop if used. Enable diag1 pin on driver.
       TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
     }
 
     #if IS_SCARA
       // Tell the planner the axis is at 0
       current_position[axis] = 0;

commit 468e437390afdb1de7059e7f9049d0b30c312024
Author: deirdreobyrne <deirdre.dub@gmail.com>
Date:   Thu Feb 25 10:49:34 2021 +0000

    Allow Zero Endstops (e.g., for CNC) (#21120)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8dc84c33d6..10d3585a73 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -67,31 +67,20 @@
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-/**
- * axis_homed
- *   Flags that each linear axis was homed.
- *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
- *
- * axis_trusted
- *   Flags that the position is trusted in each linear axis. Set when homed.
- *   Cleared whenever a stepper powers off, potentially losing its position.
- */
-uint8_t axis_homed, axis_trusted; // = 0
-
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
@@ -1115,782 +1104,790 @@ void prepare_line_to_destination() {
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
-uint8_t axes_should_home(uint8_t axis_bits/*=0x07*/) {
-  #define SHOULD_HOME(A) TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(A)
-  // Clear test bits that are trusted
-  if (TEST(axis_bits, X_AXIS) && SHOULD_HOME(X_AXIS)) CBI(axis_bits, X_AXIS);
-  if (TEST(axis_bits, Y_AXIS) && SHOULD_HOME(Y_AXIS)) CBI(axis_bits, Y_AXIS);
-  if (TEST(axis_bits, Z_AXIS) && SHOULD_HOME(Z_AXIS)) CBI(axis_bits, Z_AXIS);
-  return axis_bits;
-}
+#if HAS_ENDSTOPS
 
-bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
-  if ((axis_bits = axes_should_home(axis_bits))) {
-    PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
-    char msg[strlen_P(home_first)+1];
-    sprintf_P(msg, home_first,
-      TEST(axis_bits, X_AXIS) ? "X" : "",
-      TEST(axis_bits, Y_AXIS) ? "Y" : "",
-      TEST(axis_bits, Z_AXIS) ? "Z" : ""
-    );
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLN(msg);
-    TERN_(HAS_DISPLAY, ui.set_status(msg));
-    return true;
+  uint8_t axis_homed, axis_trusted; // = 0
+
+  uint8_t axes_should_home(uint8_t axis_bits/*=0x07*/) {
+    #define SHOULD_HOME(A) TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(A)
+    // Clear test bits that are trusted
+    if (TEST(axis_bits, X_AXIS) && SHOULD_HOME(X_AXIS)) CBI(axis_bits, X_AXIS);
+    if (TEST(axis_bits, Y_AXIS) && SHOULD_HOME(Y_AXIS)) CBI(axis_bits, Y_AXIS);
+    if (TEST(axis_bits, Z_AXIS) && SHOULD_HOME(Z_AXIS)) CBI(axis_bits, Z_AXIS);
+    return axis_bits;
   }
-  return false;
-}
 
-/**
- * Homing bump feedrate (mm/s)
- */
-feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
-  #endif
-  static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
-  uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
-  if (hbd < 1) {
-    hbd = 10;
-    SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
+  bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
+    if ((axis_bits = axes_should_home(axis_bits))) {
+      PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
+      char msg[strlen_P(home_first)+1];
+      sprintf_P(msg, home_first,
+        TEST(axis_bits, X_AXIS) ? "X" : "",
+        TEST(axis_bits, Y_AXIS) ? "Y" : "",
+        TEST(axis_bits, Z_AXIS) ? "Z" : ""
+      );
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLN(msg);
+      TERN_(HAS_DISPLAY, ui.set_status(msg));
+      return true;
+    }
+    return false;
   }
-  return homing_feedrate(axis) / float(hbd);
-}
 
-#if ENABLED(SENSORLESS_HOMING)
   /**
-   * Set sensorless homing if the axis has it, accounting for Core Kinematics.
+   * Homing bump feedrate (mm/s)
    */
-  sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
-    sensorless_t stealth_states { false };
-
-    switch (axis) {
-      default: break;
-      #if X_SENSORLESS
-        case X_AXIS:
-          stealth_states.x = tmc_enable_stallguard(stepperX);
-          #if AXIS_HAS_STALLGUARD(X2)
-            stealth_states.x2 = tmc_enable_stallguard(stepperX2);
-          #endif
-          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
-            stealth_states.y = tmc_enable_stallguard(stepperY);
-          #elif CORE_IS_XZ && Z_SENSORLESS
-            stealth_states.z = tmc_enable_stallguard(stepperZ);
-          #endif
-          break;
-      #endif
-      #if Y_SENSORLESS
-        case Y_AXIS:
-          stealth_states.y = tmc_enable_stallguard(stepperY);
-          #if AXIS_HAS_STALLGUARD(Y2)
-            stealth_states.y2 = tmc_enable_stallguard(stepperY2);
-          #endif
-          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
-            stealth_states.x = tmc_enable_stallguard(stepperX);
-          #elif CORE_IS_YZ && Z_SENSORLESS
-            stealth_states.z = tmc_enable_stallguard(stepperZ);
-          #endif
-          break;
-      #endif
-      #if Z_SENSORLESS
-        case Z_AXIS:
-          stealth_states.z = tmc_enable_stallguard(stepperZ);
-          #if AXIS_HAS_STALLGUARD(Z2)
-            stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
-          #endif
-          #if AXIS_HAS_STALLGUARD(Z3)
-            stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
-          #endif
-          #if AXIS_HAS_STALLGUARD(Z4)
-            stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
-          #endif
-          #if CORE_IS_XZ && X_SENSORLESS
-            stealth_states.x = tmc_enable_stallguard(stepperX);
-          #elif CORE_IS_YZ && Y_SENSORLESS
-            stealth_states.y = tmc_enable_stallguard(stepperY);
-          #endif
-          break;
-      #endif
+  feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
+    #if HOMING_Z_WITH_PROBE
+      if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
+    #endif
+    static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
+    uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
+    if (hbd < 1) {
+      hbd = 10;
+      SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
     }
+    return homing_feedrate(axis) / float(hbd);
+  }
+
+  #if ENABLED(SENSORLESS_HOMING)
+    /**
+     * Set sensorless homing if the axis has it, accounting for Core Kinematics.
+     */
+    sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
+      sensorless_t stealth_states { false };
 
-    #if ENABLED(SPI_ENDSTOPS)
       switch (axis) {
-        case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
-        case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
-        case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
         default: break;
+        #if X_SENSORLESS
+          case X_AXIS:
+            stealth_states.x = tmc_enable_stallguard(stepperX);
+            #if AXIS_HAS_STALLGUARD(X2)
+              stealth_states.x2 = tmc_enable_stallguard(stepperX2);
+            #endif
+            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
+              stealth_states.y = tmc_enable_stallguard(stepperY);
+            #elif CORE_IS_XZ && Z_SENSORLESS
+              stealth_states.z = tmc_enable_stallguard(stepperZ);
+            #endif
+            break;
+        #endif
+        #if Y_SENSORLESS
+          case Y_AXIS:
+            stealth_states.y = tmc_enable_stallguard(stepperY);
+            #if AXIS_HAS_STALLGUARD(Y2)
+              stealth_states.y2 = tmc_enable_stallguard(stepperY2);
+            #endif
+            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
+              stealth_states.x = tmc_enable_stallguard(stepperX);
+            #elif CORE_IS_YZ && Z_SENSORLESS
+              stealth_states.z = tmc_enable_stallguard(stepperZ);
+            #endif
+            break;
+        #endif
+        #if Z_SENSORLESS
+          case Z_AXIS:
+            stealth_states.z = tmc_enable_stallguard(stepperZ);
+            #if AXIS_HAS_STALLGUARD(Z2)
+              stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
+            #endif
+            #if AXIS_HAS_STALLGUARD(Z3)
+              stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
+            #endif
+            #if AXIS_HAS_STALLGUARD(Z4)
+              stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
+            #endif
+            #if CORE_IS_XZ && X_SENSORLESS
+              stealth_states.x = tmc_enable_stallguard(stepperX);
+            #elif CORE_IS_YZ && Y_SENSORLESS
+              stealth_states.y = tmc_enable_stallguard(stepperY);
+            #endif
+            break;
+        #endif
       }
-    #endif
 
-    TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
+      #if ENABLED(SPI_ENDSTOPS)
+        switch (axis) {
+          case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
+          case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
+          case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
+          default: break;
+        }
+      #endif
 
-    return stealth_states;
-  }
+      TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
-  void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
-    switch (axis) {
-      default: break;
-      #if X_SENSORLESS
-        case X_AXIS:
-          tmc_disable_stallguard(stepperX, enable_stealth.x);
-          #if AXIS_HAS_STALLGUARD(X2)
-            tmc_disable_stallguard(stepperX2, enable_stealth.x2);
-          #endif
-          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
-            tmc_disable_stallguard(stepperY, enable_stealth.y);
-          #elif CORE_IS_XZ && Z_SENSORLESS
-            tmc_disable_stallguard(stepperZ, enable_stealth.z);
-          #endif
-          break;
-      #endif
-      #if Y_SENSORLESS
-        case Y_AXIS:
-          tmc_disable_stallguard(stepperY, enable_stealth.y);
-          #if AXIS_HAS_STALLGUARD(Y2)
-            tmc_disable_stallguard(stepperY2, enable_stealth.y2);
-          #endif
-          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
-            tmc_disable_stallguard(stepperX, enable_stealth.x);
-          #elif CORE_IS_YZ && Z_SENSORLESS
-            tmc_disable_stallguard(stepperZ, enable_stealth.z);
-          #endif
-          break;
-      #endif
-      #if Z_SENSORLESS
-        case Z_AXIS:
-          tmc_disable_stallguard(stepperZ, enable_stealth.z);
-          #if AXIS_HAS_STALLGUARD(Z2)
-            tmc_disable_stallguard(stepperZ2, enable_stealth.z2);
-          #endif
-          #if AXIS_HAS_STALLGUARD(Z3)
-            tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
-          #endif
-          #if AXIS_HAS_STALLGUARD(Z4)
-            tmc_disable_stallguard(stepperZ4, enable_stealth.z4);
-          #endif
-          #if CORE_IS_XZ && X_SENSORLESS
-            tmc_disable_stallguard(stepperX, enable_stealth.x);
-          #elif CORE_IS_YZ && Y_SENSORLESS
-            tmc_disable_stallguard(stepperY, enable_stealth.y);
-          #endif
-          break;
-      #endif
+      return stealth_states;
     }
 
-    #if ENABLED(SPI_ENDSTOPS)
+    void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
       switch (axis) {
-        case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
-        case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
-        case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
         default: break;
+        #if X_SENSORLESS
+          case X_AXIS:
+            tmc_disable_stallguard(stepperX, enable_stealth.x);
+            #if AXIS_HAS_STALLGUARD(X2)
+              tmc_disable_stallguard(stepperX2, enable_stealth.x2);
+            #endif
+            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
+              tmc_disable_stallguard(stepperY, enable_stealth.y);
+            #elif CORE_IS_XZ && Z_SENSORLESS
+              tmc_disable_stallguard(stepperZ, enable_stealth.z);
+            #endif
+            break;
+        #endif
+        #if Y_SENSORLESS
+          case Y_AXIS:
+            tmc_disable_stallguard(stepperY, enable_stealth.y);
+            #if AXIS_HAS_STALLGUARD(Y2)
+              tmc_disable_stallguard(stepperY2, enable_stealth.y2);
+            #endif
+            #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
+              tmc_disable_stallguard(stepperX, enable_stealth.x);
+            #elif CORE_IS_YZ && Z_SENSORLESS
+              tmc_disable_stallguard(stepperZ, enable_stealth.z);
+            #endif
+            break;
+        #endif
+        #if Z_SENSORLESS
+          case Z_AXIS:
+            tmc_disable_stallguard(stepperZ, enable_stealth.z);
+            #if AXIS_HAS_STALLGUARD(Z2)
+              tmc_disable_stallguard(stepperZ2, enable_stealth.z2);
+            #endif
+            #if AXIS_HAS_STALLGUARD(Z3)
+              tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
+            #endif
+            #if AXIS_HAS_STALLGUARD(Z4)
+              tmc_disable_stallguard(stepperZ4, enable_stealth.z4);
+            #endif
+            #if CORE_IS_XZ && X_SENSORLESS
+              tmc_disable_stallguard(stepperX, enable_stealth.x);
+            #elif CORE_IS_YZ && Y_SENSORLESS
+              tmc_disable_stallguard(stepperY, enable_stealth.y);
+            #endif
+            break;
+        #endif
       }
-    #endif
-  }
 
-#endif // SENSORLESS_HOMING
-
-/**
- * Home an individual linear axis
- */
-void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
-  DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
-
-  const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
-
-  if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOPAIR("...(", AS_CHAR(axis_codes[axis]), ", ", distance, ", ");
-    if (fr_mm_s)
-      DEBUG_ECHO(fr_mm_s);
-    else
-      DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
-    DEBUG_ECHOLNPGM(")");
-  }
-
-  // Only do some things when moving towards an endstop
-  const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
-                ? x_home_dir(active_extruder) : home_dir(axis);
-  const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
-
-  #if ENABLED(SENSORLESS_HOMING)
-    sensorless_t stealth_states;
-  #endif
-
-  if (is_home_dir) {
-
-    if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
-      #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
-        // Wait for bed to heat back up between probing points
-        thermalManager.wait_for_bed_heating();
+      #if ENABLED(SPI_ENDSTOPS)
+        switch (axis) {
+          case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
+          case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
+          case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
+          default: break;
+        }
       #endif
-
-      TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
     }
 
-    // Disable stealthChop if used. Enable diag1 pin on driver.
-    TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
-  }
-
-  #if IS_SCARA
-    // Tell the planner the axis is at 0
-    current_position[axis] = 0;
-    sync_plan_position();
-    current_position[axis] = distance;
-    line_to_current_position(home_fr_mm_s);
-  #else
-    // Get the ABC or XYZ positions in mm
-    abce_pos_t target = planner.get_axis_positions_mm();
+  #endif // SENSORLESS_HOMING
 
-    target[axis] = 0;                         // Set the single homing axis to 0
-    planner.set_machine_position_mm(target);  // Update the machine position
-
-    #if HAS_DIST_MM_ARG
-      const xyze_float_t cart_dist_mm{0};
-    #endif
+  /**
+   * Home an individual linear axis
+   */
+  void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
+    DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
-    // Set delta/cartesian axes directly
-    target[axis] = distance;                  // The move will be towards the endstop
-    planner.buffer_segment(target
-      #if HAS_DIST_MM_ARG
-        , cart_dist_mm
-      #endif
-      , home_fr_mm_s, active_extruder
-    );
-  #endif
+    const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
-  planner.synchronize();
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("...(", AS_CHAR(axis_codes[axis]), ", ", distance, ", ");
+      if (fr_mm_s)
+        DEBUG_ECHO(fr_mm_s);
+      else
+        DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
+      DEBUG_ECHOLNPGM(")");
+    }
 
-  if (is_home_dir) {
+    // Only do some things when moving towards an endstop
+    const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
+                  ? x_home_dir(active_extruder) : home_dir(axis);
+    const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
-    #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
-      if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
+    #if ENABLED(SENSORLESS_HOMING)
+      sensorless_t stealth_states;
     #endif
 
-    endstops.validate_homing_move();
+    if (is_home_dir) {
 
-    // Re-enable stealthChop if used. Disable diag1 pin on driver.
-    TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
-  }
-}
-
-/**
- * Set an axis' current position to its home position (after homing).
- *
- * For Core and Cartesian robots this applies one-to-one when an
- * individual axis has been homed.
- *
- * DELTA should wait until all homing is done before setting the XYZ
- * current_position to home, because homing is a single operation.
- * In the case where the axis positions are trusted and previously
- * homed, DELTA could home to X or Y individually by moving either one
- * to the center. However, homing Z always homes XY and Z.
- *
- * SCARA should wait until all XY homing is done before setting the XY
- * current_position to home, because neither X nor Y is at home until
- * both are at home. Z can however be homed individually.
- *
- * Callers must sync the planner position after calling this!
- */
-void set_axis_is_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
+      if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
+        #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
+          // Wait for bed to heat back up between probing points
+          thermalManager.wait_for_bed_heating();
+        #endif
 
-  set_axis_trusted(axis);
-  set_axis_homed(axis);
+        TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
+      }
 
-  #if ENABLED(DUAL_X_CARRIAGE)
-    if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
-      current_position.x = x_home_pos(active_extruder);
-      return;
+      // Disable stealthChop if used. Enable diag1 pin on driver.
+      TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
     }
-  #endif
 
-  #if ENABLED(MORGAN_SCARA)
-    scara_set_axis_is_at_home(axis);
-  #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_home_pos(axis);
-  #else
-    current_position[axis] = base_home_pos(axis);
-  #endif
+    #if IS_SCARA
+      // Tell the planner the axis is at 0
+      current_position[axis] = 0;
+      sync_plan_position();
+      current_position[axis] = distance;
+      line_to_current_position(home_fr_mm_s);
+    #else
+      // Get the ABC or XYZ positions in mm
+      abce_pos_t target = planner.get_axis_positions_mm();
 
-  /**
-   * Z Probe Z Homing? Account for the probe's Z offset.
-   */
-  #if HAS_BED_PROBE && Z_HOME_DIR < 0
-    if (axis == Z_AXIS) {
-      #if HOMING_Z_WITH_PROBE
+      target[axis] = 0;                         // Set the single homing axis to 0
+      planner.set_machine_position_mm(target);  // Update the machine position
 
-        current_position.z -= probe.offset.z;
+      #if HAS_DIST_MM_ARG
+        const xyze_float_t cart_dist_mm{0};
+      #endif
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
+      // Set delta/cartesian axes directly
+      target[axis] = distance;                  // The move will be towards the endstop
+      planner.buffer_segment(target
+        #if HAS_DIST_MM_ARG
+          , cart_dist_mm
+        #endif
+        , home_fr_mm_s, active_extruder
+      );
+    #endif
 
-      #else
+    planner.synchronize();
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
+    if (is_home_dir) {
 
+      #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
+        if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
       #endif
-    }
-  #endif
-
-  TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
-
-  TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
-  #if HAS_POSITION_SHIFT
-    position_shift[axis] = 0;
-    update_workspace_offset(axis);
-  #endif
+      endstops.validate_homing_move();
 
-  if (DEBUGGING(LEVELING)) {
-    #if HAS_HOME_OFFSET
-      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
-    #endif
-    DEBUG_POS("", current_position);
-    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
+      // Re-enable stealthChop if used. Disable diag1 pin on driver.
+      TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
+    }
   }
-}
 
-/**
- * Set an axis to be unhomed.
- */
-void set_axis_never_homed(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
-
-  set_axis_untrusted(axis);
-  set_axis_unhomed(axis);
-
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
-
-  TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
-}
-
-#ifdef TMC_HOME_PHASE
   /**
-   * Move the axis back to its home_phase if set and driver is capable (TMC)
-   *
-   * Improves homing repeatability by homing to stepper coil's nearest absolute
-   * phase position. Trinamic drivers use a stepper phase table with 1024 values
-   * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
+   * Set an axis to be unhomed. (Unless we are on a machine - e.g. a cheap Chinese CNC machine -
+   * that has no endstops. Such machines should always be considered to be in a "known" and
+   * "trusted" position).
    */
-  void backout_to_tmc_homing_phase(const AxisEnum axis) {
-    const xyz_long_t home_phase = TMC_HOME_PHASE;
+  void set_axis_never_homed(const AxisEnum axis) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
 
-    // check if home phase is disabled for this axis.
-    if (home_phase[axis] < 0) return;
+    set_axis_untrusted(axis);
+    set_axis_unhomed(axis);
 
-    int16_t phasePerUStep,      // TMC ¬µsteps(phase) per Marlin ¬µsteps
-            phaseCurrent,       // The TMC ¬µsteps(phase) count of the current position
-            effectorBackoutDir, // Direction in which the effector mm coordinates move away from endstop.
-            stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
 
-    #define PHASE_PER_MICROSTEP(N) (256 / _MAX(1, N##_MICROSTEPS))
+    TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
+  }
 
-    switch (axis) {
-      #ifdef X_MICROSTEPS
-        case X_AXIS:
-          phasePerUStep = PHASE_PER_MICROSTEP(X);
-          phaseCurrent = stepperX.get_microstep_counter();
-          effectorBackoutDir = -X_HOME_DIR;
-          stepperBackoutDir = INVERT_X_DIR ? effectorBackoutDir : -effectorBackoutDir;
-          break;
-      #endif
-      #ifdef Y_MICROSTEPS
-        case Y_AXIS:
-          phasePerUStep = PHASE_PER_MICROSTEP(Y);
-          phaseCurrent = stepperY.get_microstep_counter();
-          effectorBackoutDir = -Y_HOME_DIR;
-          stepperBackoutDir = INVERT_Y_DIR ? effectorBackoutDir : -effectorBackoutDir;
-          break;
-      #endif
-      #ifdef Z_MICROSTEPS
-        case Z_AXIS:
-          phasePerUStep = PHASE_PER_MICROSTEP(Z);
-          phaseCurrent = stepperZ.get_microstep_counter();
-          effectorBackoutDir = -Z_HOME_DIR;
-          stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
-          break;
-      #endif
-      default: return;
-    }
+  #if ENABLED(TMC_HOME_PHASE)
+    /**
+     * Move the axis back to its home_phase if set and driver is capable (TMC)
+     *
+     * Improves homing repeatability by homing to stepper coil's nearest absolute
+     * phase position. Trinamic drivers use a stepper phase table with 1024 values
+     * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
+     */
+    void backout_to_tmc_homing_phase(const AxisEnum axis) {
+      const xyz_long_t home_phase = TMC_HOME_PHASE;
 
-    // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
-    int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
+      // check if home phase is disabled for this axis.
+      if (home_phase[axis] < 0) return;
 
-    // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
-    if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
-      SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
-                       " too close to endstop trigger phase ", phaseCurrent,
-                       ". Pick a different phase for ", axis_codes[axis]);
+      int16_t phasePerUStep,      // TMC ¬µsteps(phase) per Marlin ¬µsteps
+              phaseCurrent,       // The TMC ¬µsteps(phase) count of the current position
+              effectorBackoutDir, // Direction in which the effector mm coordinates move away from endstop.
+              stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
 
-    // Skip to next if target position is behind current. So it only moves away from endstop.
-    if (phaseDelta < 0) phaseDelta += 1024;
+      #define PHASE_PER_MICROSTEP(N) (256 / _MAX(1, N##_MICROSTEPS))
 
-    // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
-    const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
+      switch (axis) {
+        #ifdef X_MICROSTEPS
+          case X_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(X);
+            phaseCurrent = stepperX.get_microstep_counter();
+            effectorBackoutDir = -X_HOME_DIR;
+            stepperBackoutDir = INVERT_X_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef Y_MICROSTEPS
+          case Y_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(Y);
+            phaseCurrent = stepperY.get_microstep_counter();
+            effectorBackoutDir = -Y_HOME_DIR;
+            stepperBackoutDir = INVERT_Y_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        #ifdef Z_MICROSTEPS
+          case Z_AXIS:
+            phasePerUStep = PHASE_PER_MICROSTEP(Z);
+            phaseCurrent = stepperZ.get_microstep_counter();
+            effectorBackoutDir = -Z_HOME_DIR;
+            stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
+            break;
+        #endif
+        default: return;
+      }
 
-    // Optional debug messages
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOLNPAIR(
-        "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
-        " Delta:", phaseDelta, " Distance:", mmDelta
-      );
-    }
+      // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
+      int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
-    if (mmDelta != 0) {
-      // Retrace by the amount computed in mmDelta.
-      do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
-    }
-  }
-#endif
+      // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
+      if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
+        SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
+                         " too close to endstop trigger phase ", phaseCurrent,
+                         ". Pick a different phase for ", axis_codes[axis]);
 
-/**
- * Home an individual "raw axis" to its endstop.
- * This applies to XYZ on Cartesian and Core robots, and
- * to the individual ABC steppers on DELTA and SCARA.
- *
- * At the end of the procedure the axis is marked as
- * homed and the current position of that axis is updated.
- * Kinematic robots should wait till all axes are homed
- * before updating the current position.
- */
+      // Skip to next if target position is behind current. So it only moves away from endstop.
+      if (phaseDelta < 0) phaseDelta += 1024;
 
-void homeaxis(const AxisEnum axis) {
+      // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
+      const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
-  #if IS_SCARA
-    // Only Z homing (with probe) is permitted
-    if (axis != Z_AXIS) { BUZZ(100, 880); return; }
-  #else
-    #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
-         ENABLED(A##_SPI_SENSORLESS) \
-      || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
-      || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
-      || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
-    ))
-    if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
-  #endif
+      // Optional debug messages
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOLNPAIR(
+          "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
+          " Delta:", phaseDelta, " Distance:", mmDelta
+        );
+      }
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
-
-  const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
-              ? x_home_dir(active_extruder) : home_dir(axis);
-
-  //
-  // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
-  //
-  if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
-    return;
-
-  // Set flags for X, Y, Z motor locking
-  #if HAS_EXTRA_ENDSTOPS
-    switch (axis) {
-      TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
-      TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
-      TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
-        stepper.set_separate_multi_axis(true);
-      default: break;
+      if (mmDelta != 0) {
+        // Retrace by the amount computed in mmDelta.
+        do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
+      }
     }
   #endif
 
-  //
-  // Deploy BLTouch or tare the probe just before probing
-  //
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) {
-      if (TERN0(BLTOUCH, bltouch.deploy())) return;   // BLTouch was deployed above, but get the alarm state.
-      if (TERN0(PROBE_TARE, probe.tare())) return;
-    }
-  #endif
+  /**
+   * Home an individual "raw axis" to its endstop.
+   * This applies to XYZ on Cartesian and Core robots, and
+   * to the individual ABC steppers on DELTA and SCARA.
+   *
+   * At the end of the procedure the axis is marked as
+   * homed and the current position of that axis is updated.
+   * Kinematic robots should wait till all axes are homed
+   * before updating the current position.
+   */
 
-  //
-  // Back away to prevent an early X/Y sensorless trigger
-  //
-  #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
-    const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
-    if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
-      const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
-      do_homing_move(axis, backoff_length, homing_feedrate(axis));
-    }
-  #endif
+  void homeaxis(const AxisEnum axis) {
 
-  // Determine if a homing bump will be done and the bumps distance
-  // When homing Z with probe respect probe clearance
-  const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
-  const float bump = axis_home_dir * (
-    use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
-  );
-
-  //
-  // Fast move towards endstop until triggered
-  //
-  const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
-  do_homing_move(axis, move_length, 0.0, !use_probe_bump);
-
-  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
-    if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
-  #endif
+    #if IS_SCARA
+      // Only Z homing (with probe) is permitted
+      if (axis != Z_AXIS) { BUZZ(100, 880); return; }
+    #else
+      #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
+           ENABLED(A##_SPI_SENSORLESS) \
+        || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
+        || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
+        || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
+      ))
+      if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
+    #endif
 
-  // If a second homing move is configured...
-  if (bump) {
-    // Move away from the endstop by the axis HOMING_BUMP_MM
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
-    do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0, false);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
-    #if ENABLED(DETECT_BROKEN_ENDSTOP)
-      // Check for a broken endstop
-      EndstopEnum es;
+    const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
+                ? x_home_dir(active_extruder) : home_dir(axis);
+
+    //
+    // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
+    //
+    if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
+      return;
+
+    // Set flags for X, Y, Z motor locking
+    #if HAS_EXTRA_ENDSTOPS
       switch (axis) {
-        default:
-        case X_AXIS: es = X_ENDSTOP; break;
-        case Y_AXIS: es = Y_ENDSTOP; break;
-        case Z_AXIS: es = Z_ENDSTOP; break;
+        TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
+        TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
+        TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
+          stepper.set_separate_multi_axis(true);
+        default: break;
       }
-      if (TEST(endstops.state(), es)) {
-        SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
-        kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
+    #endif
+
+    //
+    // Deploy BLTouch or tare the probe just before probing
+    //
+    #if HOMING_Z_WITH_PROBE
+      if (axis == Z_AXIS) {
+        if (TERN0(BLTOUCH, bltouch.deploy())) return;   // BLTouch was deployed above, but get the alarm state.
+        if (TERN0(PROBE_TARE, probe.tare())) return;
       }
     #endif
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
-      if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
+    //
+    // Back away to prevent an early X/Y sensorless trigger
+    //
+    #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
+      const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
+      if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
+        const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
+        do_homing_move(axis, backoff_length, homing_feedrate(axis));
+      }
     #endif
 
-    // Slow move towards endstop until triggered
-    const float rebump = bump * 2;
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Re-bump: ", rebump, "mm");
-    do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
+    // Determine if a homing bump will be done and the bumps distance
+    // When homing Z with probe respect probe clearance
+    const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
+    const float bump = axis_home_dir * (
+      use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
+    );
+
+    //
+    // Fast move towards endstop until triggered
+    //
+    const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
+    do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
-      if (axis == Z_AXIS) bltouch.stow(); // The final STOW
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
+      if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
     #endif
-  }
 
-  #if HAS_EXTRA_ENDSTOPS
-    const bool pos_dir = axis_home_dir > 0;
-    #if ENABLED(X_DUAL_ENDSTOPS)
-      if (axis == X_AXIS) {
-        const float adj = ABS(endstops.x2_endstop_adj);
-        if (adj) {
-          if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
-          do_homing_move(axis, pos_dir ? -adj : adj);
-          stepper.set_x_lock(false);
-          stepper.set_x2_lock(false);
+    // If a second homing move is configured...
+    if (bump) {
+      // Move away from the endstop by the axis HOMING_BUMP_MM
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
+      do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0, false);
+
+      #if ENABLED(DETECT_BROKEN_ENDSTOP)
+        // Check for a broken endstop
+        EndstopEnum es;
+        switch (axis) {
+          default:
+          case X_AXIS: es = X_ENDSTOP; break;
+          case Y_AXIS: es = Y_ENDSTOP; break;
+          case Z_AXIS: es = Z_ENDSTOP; break;
         }
-      }
-    #endif
-    #if ENABLED(Y_DUAL_ENDSTOPS)
-      if (axis == Y_AXIS) {
-        const float adj = ABS(endstops.y2_endstop_adj);
-        if (adj) {
-          if (pos_dir ? (endstops.y2_endstop_adj > 0) : (endstops.y2_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
-          do_homing_move(axis, pos_dir ? -adj : adj);
-          stepper.set_y_lock(false);
-          stepper.set_y2_lock(false);
+        if (TEST(endstops.state(), es)) {
+          SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
+          kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
         }
-      }
-    #endif
+      #endif
 
-    #if ENABLED(Z_MULTI_ENDSTOPS)
-      if (axis == Z_AXIS) {
+      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
+        if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
+      #endif
+
+      // Slow move towards endstop until triggered
+      const float rebump = bump * 2;
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Re-bump: ", rebump, "mm");
+      do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
 
-        #if NUM_Z_STEPPER_DRIVERS == 2
+      #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
+        if (axis == Z_AXIS) bltouch.stow(); // The final STOW
+      #endif
+    }
 
-          const float adj = ABS(endstops.z2_endstop_adj);
+    #if HAS_EXTRA_ENDSTOPS
+      const bool pos_dir = axis_home_dir > 0;
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        if (axis == X_AXIS) {
+          const float adj = ABS(endstops.x2_endstop_adj);
           if (adj) {
-            if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z1_lock(true); else stepper.set_z2_lock(true);
+            if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
             do_homing_move(axis, pos_dir ? -adj : adj);
-            stepper.set_z1_lock(false);
-            stepper.set_z2_lock(false);
+            stepper.set_x_lock(false);
+            stepper.set_x2_lock(false);
           }
+        }
+      #endif
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        if (axis == Y_AXIS) {
+          const float adj = ABS(endstops.y2_endstop_adj);
+          if (adj) {
+            if (pos_dir ? (endstops.y2_endstop_adj > 0) : (endstops.y2_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
+            do_homing_move(axis, pos_dir ? -adj : adj);
+            stepper.set_y_lock(false);
+            stepper.set_y2_lock(false);
+          }
+        }
+      #endif
 
-        #else
-
-          // Handy arrays of stepper lock function pointers
+      #if ENABLED(Z_MULTI_ENDSTOPS)
+        if (axis == Z_AXIS) {
 
-          typedef void (*adjustFunc_t)(const bool);
+          #if NUM_Z_STEPPER_DRIVERS == 2
 
-          adjustFunc_t lock[] = {
-            stepper.set_z1_lock, stepper.set_z2_lock, stepper.set_z3_lock
-            #if NUM_Z_STEPPER_DRIVERS >= 4
-              , stepper.set_z4_lock
-            #endif
-          };
-          float adj[] = {
-            0, endstops.z2_endstop_adj, endstops.z3_endstop_adj
-            #if NUM_Z_STEPPER_DRIVERS >= 4
-              , endstops.z4_endstop_adj
-            #endif
-          };
+            const float adj = ABS(endstops.z2_endstop_adj);
+            if (adj) {
+              if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z1_lock(true); else stepper.set_z2_lock(true);
+              do_homing_move(axis, pos_dir ? -adj : adj);
+              stepper.set_z1_lock(false);
+              stepper.set_z2_lock(false);
+            }
 
-          adjustFunc_t tempLock;
-          float tempAdj;
+          #else
 
-          // Manual bubble sort by adjust value
-          if (adj[1] < adj[0]) {
-            tempLock = lock[0], tempAdj = adj[0];
-            lock[0] = lock[1], adj[0] = adj[1];
-            lock[1] = tempLock, adj[1] = tempAdj;
-          }
-          if (adj[2] < adj[1]) {
-            tempLock = lock[1], tempAdj = adj[1];
-            lock[1] = lock[2], adj[1] = adj[2];
-            lock[2] = tempLock, adj[2] = tempAdj;
-          }
-          #if NUM_Z_STEPPER_DRIVERS >= 4
-            if (adj[3] < adj[2]) {
-              tempLock = lock[2], tempAdj = adj[2];
-              lock[2] = lock[3], adj[2] = adj[3];
-              lock[3] = tempLock, adj[3] = tempAdj;
+            // Handy arrays of stepper lock function pointers
+
+            typedef void (*adjustFunc_t)(const bool);
+
+            adjustFunc_t lock[] = {
+              stepper.set_z1_lock, stepper.set_z2_lock, stepper.set_z3_lock
+              #if NUM_Z_STEPPER_DRIVERS >= 4
+                , stepper.set_z4_lock
+              #endif
+            };
+            float adj[] = {
+              0, endstops.z2_endstop_adj, endstops.z3_endstop_adj
+              #if NUM_Z_STEPPER_DRIVERS >= 4
+                , endstops.z4_endstop_adj
+              #endif
+            };
+
+            adjustFunc_t tempLock;
+            float tempAdj;
+
+            // Manual bubble sort by adjust value
+            if (adj[1] < adj[0]) {
+              tempLock = lock[0], tempAdj = adj[0];
+              lock[0] = lock[1], adj[0] = adj[1];
+              lock[1] = tempLock, adj[1] = tempAdj;
             }
             if (adj[2] < adj[1]) {
               tempLock = lock[1], tempAdj = adj[1];
               lock[1] = lock[2], adj[1] = adj[2];
               lock[2] = tempLock, adj[2] = tempAdj;
             }
-          #endif
-          if (adj[1] < adj[0]) {
-            tempLock = lock[0], tempAdj = adj[0];
-            lock[0] = lock[1], adj[0] = adj[1];
-            lock[1] = tempLock, adj[1] = tempAdj;
-          }
-
-          if (pos_dir) {
-            // normalize adj to smallest value and do the first move
-            (*lock[0])(true);
-            do_homing_move(axis, adj[1] - adj[0]);
-            // lock the second stepper for the final correction
-            (*lock[1])(true);
-            do_homing_move(axis, adj[2] - adj[1]);
             #if NUM_Z_STEPPER_DRIVERS >= 4
-              // lock the third stepper for the final correction
-              (*lock[2])(true);
-              do_homing_move(axis, adj[3] - adj[2]);
+              if (adj[3] < adj[2]) {
+                tempLock = lock[2], tempAdj = adj[2];
+                lock[2] = lock[3], adj[2] = adj[3];
+                lock[3] = tempLock, adj[3] = tempAdj;
+              }
+              if (adj[2] < adj[1]) {
+                tempLock = lock[1], tempAdj = adj[1];
+                lock[1] = lock[2], adj[1] = adj[2];
+                lock[2] = tempLock, adj[2] = tempAdj;
+              }
             #endif
-          }
-          else {
+            if (adj[1] < adj[0]) {
+              tempLock = lock[0], tempAdj = adj[0];
+              lock[0] = lock[1], adj[0] = adj[1];
+              lock[1] = tempLock, adj[1] = tempAdj;
+            }
+
+            if (pos_dir) {
+              // normalize adj to smallest value and do the first move
+              (*lock[0])(true);
+              do_homing_move(axis, adj[1] - adj[0]);
+              // lock the second stepper for the final correction
+              (*lock[1])(true);
+              do_homing_move(axis, adj[2] - adj[1]);
+              #if NUM_Z_STEPPER_DRIVERS >= 4
+                // lock the third stepper for the final correction
+                (*lock[2])(true);
+                do_homing_move(axis, adj[3] - adj[2]);
+              #endif
+            }
+            else {
+              #if NUM_Z_STEPPER_DRIVERS >= 4
+                (*lock[3])(true);
+                do_homing_move(axis, adj[2] - adj[3]);
+              #endif
+              (*lock[2])(true);
+              do_homing_move(axis, adj[1] - adj[2]);
+              (*lock[1])(true);
+              do_homing_move(axis, adj[0] - adj[1]);
+            }
+
+            stepper.set_z1_lock(false);
+            stepper.set_z2_lock(false);
+            stepper.set_z3_lock(false);
             #if NUM_Z_STEPPER_DRIVERS >= 4
-              (*lock[3])(true);
-              do_homing_move(axis, adj[2] - adj[3]);
+              stepper.set_z4_lock(false);
             #endif
-            (*lock[2])(true);
-            do_homing_move(axis, adj[1] - adj[2]);
-            (*lock[1])(true);
-            do_homing_move(axis, adj[0] - adj[1]);
-          }
 
-          stepper.set_z1_lock(false);
-          stepper.set_z2_lock(false);
-          stepper.set_z3_lock(false);
-          #if NUM_Z_STEPPER_DRIVERS >= 4
-            stepper.set_z4_lock(false);
           #endif
+        }
+      #endif
 
-        #endif
+      // Reset flags for X, Y, Z motor locking
+      switch (axis) {
+        default: break;
+        TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
+        TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
+        TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
+          stepper.set_separate_multi_axis(false);
       }
     #endif
 
-    // Reset flags for X, Y, Z motor locking
-    switch (axis) {
-      default: break;
-      TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
-      TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
-      TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
-        stepper.set_separate_multi_axis(false);
-    }
-  #endif
+    #ifdef TMC_HOME_PHASE
+      // move back to homing phase if configured and capable
+      backout_to_tmc_homing_phase(axis);
+    #endif
 
-  #ifdef TMC_HOME_PHASE
-    // move back to homing phase if configured and capable
-    backout_to_tmc_homing_phase(axis);
-  #endif
+    #if IS_SCARA
 
-  #if IS_SCARA
+      set_axis_is_at_home(axis);
+      sync_plan_position();
 
-    set_axis_is_at_home(axis);
-    sync_plan_position();
+    #elif ENABLED(DELTA)
 
-  #elif ENABLED(DELTA)
+      // Delta has already moved all three towers up in G28
+      // so here it re-homes each tower in turn.
+      // Delta homing treats the axes as normal linear axes.
 
-    // Delta has already moved all three towers up in G28
-    // so here it re-homes each tower in turn.
-    // Delta homing treats the axes as normal linear axes.
+      const float adjDistance = delta_endstop_adj[axis],
+                  minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
 
-    const float adjDistance = delta_endstop_adj[axis],
-                minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
+      // Retrace by the amount specified in delta_endstop_adj if more than min steps.
+      if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("adjDistance:", adjDistance);
+        do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
+      }
 
-    // Retrace by the amount specified in delta_endstop_adj if more than min steps.
-    if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("adjDistance:", adjDistance);
-      do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
-    }
+    #else // CARTESIAN / CORE / MARKFORGED_XY
+
+      set_axis_is_at_home(axis);
+      sync_plan_position();
 
-  #else // CARTESIAN / CORE / MARKFORGED_XY
+      destination[axis] = current_position[axis];
 
-    set_axis_is_at_home(axis);
-    sync_plan_position();
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
-    destination[axis] = current_position[axis];
+    #endif
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
+    // Put away the Z probe
+    #if HOMING_Z_WITH_PROBE
+      if (axis == Z_AXIS && probe.stow()) return;
+    #endif
 
+    #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
+      const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
+      if (endstop_backoff[axis]) {
+        current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
+        line_to_current_position(
+          #if HOMING_Z_WITH_PROBE
+            (axis == Z_AXIS) ? z_probe_fast_mm_s :
+          #endif
+          homing_feedrate(axis)
+        );
+
+        #if ENABLED(SENSORLESS_HOMING)
+          planner.synchronize();
+          if (false
+            #if EITHER(IS_CORE, MARKFORGED_XY)
+              || axis != NORMAL_AXIS
+            #endif
+          ) safe_delay(200);  // Short delay to allow belts to spring back
+        #endif
+      }
+    #endif
+
+    // Clear retracted status if homing the Z axis
+    #if ENABLED(FWRETRACT)
+      if (axis == Z_AXIS) fwretract.current_hop = 0.0;
+    #endif
+
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
+
+  } // homeaxis()
+
+#endif // HAS_ENDSTOPS
+
+/**
+ * Set an axis' current position to its home position (after homing).
+ *
+ * For Core and Cartesian robots this applies one-to-one when an
+ * individual axis has been homed.
+ *
+ * DELTA should wait until all homing is done before setting the XYZ
+ * current_position to home, because homing is a single operation.
+ * In the case where the axis positions are trusted and previously
+ * homed, DELTA could home to X or Y individually by moving either one
+ * to the center. However, homing Z always homes XY and Z.
+ *
+ * SCARA should wait until all XY homing is done before setting the XY
+ * current_position to home, because neither X nor Y is at home until
+ * both are at home. Z can however be homed individually.
+ *
+ * Callers must sync the planner position after calling this!
+ */
+void set_axis_is_at_home(const AxisEnum axis) {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
+
+  set_axis_trusted(axis);
+  set_axis_homed(axis);
+
+  #if ENABLED(DUAL_X_CARRIAGE)
+    if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
+      current_position.x = x_home_pos(active_extruder);
+      return;
+    }
   #endif
 
-  // Put away the Z probe
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && probe.stow()) return;
+  #if ENABLED(MORGAN_SCARA)
+    scara_set_axis_is_at_home(axis);
+  #elif ENABLED(DELTA)
+    current_position[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_home_pos(axis);
+  #else
+    current_position[axis] = base_home_pos(axis);
   #endif
 
-  #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
-    const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
-    if (endstop_backoff[axis]) {
-      current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
-      line_to_current_position(
-        #if HOMING_Z_WITH_PROBE
-          (axis == Z_AXIS) ? z_probe_fast_mm_s :
-        #endif
-        homing_feedrate(axis)
-      );
+  /**
+   * Z Probe Z Homing? Account for the probe's Z offset.
+   */
+  #if HAS_BED_PROBE && Z_HOME_DIR < 0
+    if (axis == Z_AXIS) {
+      #if HOMING_Z_WITH_PROBE
+
+        current_position.z -= probe.offset.z;
+
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
+
+      #else
+
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
-      #if ENABLED(SENSORLESS_HOMING)
-        planner.synchronize();
-        if (false
-          #if EITHER(IS_CORE, MARKFORGED_XY)
-            || axis != NORMAL_AXIS
-          #endif
-        ) safe_delay(200);  // Short delay to allow belts to spring back
       #endif
     }
   #endif
 
-  // Clear retracted status if homing the Z axis
-  #if ENABLED(FWRETRACT)
-    if (axis == Z_AXIS) fwretract.current_hop = 0.0;
-  #endif
+  TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
+
+  TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
+  #if HAS_POSITION_SHIFT
+    position_shift[axis] = 0;
+    update_workspace_offset(axis);
+  #endif
 
-} // homeaxis()
+  if (DEBUGGING(LEVELING)) {
+    #if HAS_HOME_OFFSET
+      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
+    #endif
+    DEBUG_POS("", current_position);
+    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
+  }
+}
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;
     update_workspace_offset(axis);
   }
-#endif // HAS_M206_COMMAND
+#endif

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f7fc66b27a..8dc84c33d6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1298,21 +1298,21 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
   DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
   const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
   if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOPAIR("...(", axis_codes[axis], ", ", distance, ", ");
+    DEBUG_ECHOPAIR("...(", AS_CHAR(axis_codes[axis]), ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? x_home_dir(active_extruder) : home_dir(axis);
@@ -1391,21 +1391,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", axis_codes[axis], ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", AS_CHAR(axis_codes[axis]), ")");
 
   set_axis_trusted(axis);
   set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
@@ -1441,21 +1441,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
   TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
-      DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
+      DEBUG_ECHOLNPAIR("> home_offset[", AS_CHAR(axis_codes[axis]), "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
 }
 
 /**
  * Set an axis to be unhomed.
  */
 void set_axis_never_homed(const AxisEnum axis) {

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 99853f24df..f7fc66b27a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -229,22 +229,31 @@ void report_current_position() {
  * The planner.position always corresponds to the last G-code too. This makes M114
  * suitable for debugging kinematics and leveling while avoiding planner sync that
  * definitively interrupts the printing flow.
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);
 }
 
 /**
- * sync_plan_position
- *
+ * Run out the planner buffer and re-sync the current
+ * position from the last-updated stepper positions.
+ */
+void quickstop_stepper() {
+  planner.quick_stop();
+  planner.synchronize();
+  set_current_from_steppers_for_axis(ALL_AXES);
+  sync_plan_position();
+}
+
+/**
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   planner.set_position_mm(current_position);
 }
 
 void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
 

commit 2f17f2207a056bef5449869161fa56e50011da31
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Tue Jan 5 07:48:42 2021 +0200

    Don't apply hotend_offset.z to Z soft endstops (#20675)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6a6d7bf9eb..99853f24df 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -588,30 +588,31 @@ void restore_feedrate_and_scaling() {
         case Z_AXIS:
           delta_clip_start_height = soft_endstop.max[axis] - delta_safe_distance_from_top();
         default: break;
       }
 
     #elif HAS_HOTEND_OFFSET
 
       // Software endstops are relative to the tool 0 workspace, so
       // the movement limits must be shifted by the tool offset to
       // retain the same physical limit when other tools are selected.
-      if (old_tool_index != new_tool_index) {
-        const float offs = hotend_offset[new_tool_index][axis] - hotend_offset[old_tool_index][axis];
-        soft_endstop.min[axis] += offs;
-        soft_endstop.max[axis] += offs;
-      }
-      else {
-        const float offs = hotend_offset[active_extruder][axis];
+
+      if (new_tool_index == old_tool_index || axis == Z_AXIS) { // The Z axis is "special" and shouldn't be modified
+        const float offs = (axis == Z_AXIS) ? 0 : hotend_offset[active_extruder][axis];
         soft_endstop.min[axis] = base_min_pos(axis) + offs;
         soft_endstop.max[axis] = base_max_pos(axis) + offs;
       }
+      else {
+        const float diff = hotend_offset[new_tool_index][axis] - hotend_offset[old_tool_index][axis];
+        soft_endstop.min[axis] += diff;
+        soft_endstop.max[axis] += diff;
+      }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
     if (DEBUGGING(LEVELING))
       SERIAL_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);

commit 55d1938977e310648602e1b23e9e22e8fd6838b5
Author: FanDjango <51046875+FanDjango@users.noreply.github.com>
Date:   Tue Jan 5 03:32:52 2021 +0100

    Defer "quiet probing" till the last Z bump (#20610)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6ffb0576c4..6a6d7bf9eb 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1282,21 +1282,21 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
         default: break;
       }
     #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
-void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0) {
+void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0, const bool final_approach=true) {
   DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
   const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOPAIR("...(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
@@ -1313,21 +1313,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
   #endif
 
   if (is_home_dir) {
 
     if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
       #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
         // Wait for bed to heat back up between probing points
         thermalManager.wait_for_bed_heating();
       #endif
 
-      TERN_(HAS_QUIET_PROBING, probe.set_probing_paused(true));
+      TERN_(HAS_QUIET_PROBING, if (final_approach) probe.set_probing_paused(true));
     }
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
@@ -1352,21 +1352,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
       #endif
       , home_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
-      if (axis == Z_AXIS) probe.set_probing_paused(false);
+      if (axis == Z_AXIS && final_approach) probe.set_probing_paused(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
   }
 }
 
 /**
@@ -1601,46 +1601,43 @@ void homeaxis(const AxisEnum axis) {
   //
   #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
     const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
     if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
       const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
       do_homing_move(axis, backoff_length, homing_feedrate(axis));
     }
   #endif
 
+  // Determine if a homing bump will be done and the bumps distance
+  // When homing Z with probe respect probe clearance
+  const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
+  const float bump = axis_home_dir * (
+    use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
+  );
+
   //
   // Fast move towards endstop until triggered
   //
   const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
-  do_homing_move(axis, move_length);
+  do_homing_move(axis, move_length, 0.0, !use_probe_bump);
 
   #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
-  // When homing Z with probe respect probe clearance
-  const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
-  const float bump = axis_home_dir * (
-    use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
-  );
-
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOMING_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
-    do_homing_move(axis, -bump
-      #if HOMING_Z_WITH_PROBE
-        , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
-      #endif
-    );
+    do_homing_move(axis, -bump, TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0, false);
 
     #if ENABLED(DETECT_BROKEN_ENDSTOP)
       // Check for a broken endstop
       EndstopEnum es;
       switch (axis) {
         default:
         case X_AXIS: es = X_ENDSTOP; break;
         case Y_AXIS: es = Y_ENDSTOP; break;
         case Z_AXIS: es = Z_ENDSTOP; break;
       }
@@ -1650,21 +1647,21 @@ void homeaxis(const AxisEnum axis) {
       }
     #endif
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     // Slow move towards endstop until triggered
     const float rebump = bump * 2;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Re-bump: ", rebump, "mm");
-    do_homing_move(axis, rebump, get_homing_bump_feedrate(axis));
+    do_homing_move(axis, rebump, get_homing_bump_feedrate(axis), true);
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {

commit ca47dffa35eb5b47ea96a872d1208ec5ebf8e130
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 3 22:22:21 2021 -0600

    Fix delayed_move_time elapsed test

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 29ccf619a5..6ffb0576c4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -981,21 +981,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
         case DXC_FULL_CONTROL_MODE: break;
 
         case DXC_AUTO_PARK_MODE: {
           if (current_position.e == destination.e) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
               current_position = destination;
               NOLESS(raised_parked_position.z, destination.z);
-              delayed_move_time = millis();
+              delayed_move_time = millis() + 1000UL;
               return true;
             }
           }
           //
           // Un-park the active extruder
           //
           const feedRate_t fr_zfast = planner.settings.max_feedrate_mm_s[Z_AXIS];
           #define CURPOS current_position
           #define RAISED raised_parked_position
           //  1. Move to the raised parked XYZ. Presumably the tool is already at XY.

commit 548d5603eabb95715c204940dd27e027812e9088
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jan 3 23:07:29 2021 -0500

    Fix IDEX reboot on travel after G28 X (#20654)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ace583b6c0..29ccf619a5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -999,21 +999,20 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
           #define CURPOS current_position
           #define RAISED raised_parked_position
           //  1. Move to the raised parked XYZ. Presumably the tool is already at XY.
           if (planner.buffer_line(RAISED.x, RAISED.y, RAISED.z, CURPOS.e, fr_zfast, active_extruder)) {
             //  2. Move to the current native XY and raised Z. Presumably this is a null move.
             if (planner.buffer_line(CURPOS.x, CURPOS.y, RAISED.z, CURPOS.e, PLANNER_XY_FEEDRATE(), active_extruder)) {
               //  3. Lower Z back down
               line_to_current_position(fr_zfast);
             }
           }
-          planner.synchronize(); // paranoia
           stepper.set_directions();
 
           idex_set_parked(false);
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
         } break;
 
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             xyze_pos_t new_pos = current_position;

commit 56a5d0b2872cbe2e5a3b09ca3b668eeeec8e25b9
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jan 3 13:37:47 2021 +1300

    Homing code followup (#20632)
    
    Patching a87e5197cfb2f302c3eea9271b4c25c49df3ab6b

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f2fdd7934d..ace583b6c0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1650,21 +1650,21 @@ void homeaxis(const AxisEnum axis) {
         kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
       }
     #endif
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     // Slow move towards endstop until triggered
     const float rebump = bump * 2;
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Re-bump: ", rebump, "mm");
     do_homing_move(axis, rebump, get_homing_bump_feedrate(axis));
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)

commit a87e5197cfb2f302c3eea9271b4c25c49df3ab6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 30 19:13:47 2020 -0600

    Document, adjust some homing code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9b6a0d913b..f2fdd7934d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1286,80 +1286,79 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0) {
   DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
-  const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
+  const feedRate_t home_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOPAIR("...(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
-      DEBUG_ECHOPAIR("[", real_fr_mm_s, "]");
+      DEBUG_ECHOPAIR("[", home_fr_mm_s, "]");
     DEBUG_ECHOLNPGM(")");
   }
 
-  #if ALL(HOMING_Z_WITH_PROBE, HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
-    // Wait for bed to heat back up between probing points
-    if (axis == Z_AXIS && distance < 0)
-      thermalManager.wait_for_bed_heating();
-  #endif
-
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? x_home_dir(active_extruder) : home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   #if ENABLED(SENSORLESS_HOMING)
     sensorless_t stealth_states;
   #endif
 
   if (is_home_dir) {
 
-    #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
-      if (axis == Z_AXIS) probe.set_probing_paused(true);
-    #endif
+    if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS)) {
+      #if ALL(HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
+        // Wait for bed to heat back up between probing points
+        thermalManager.wait_for_bed_heating();
+      #endif
+
+      TERN_(HAS_QUIET_PROBING, probe.set_probing_paused(true));
+    }
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
-    line_to_current_position(real_fr_mm_s);
+    line_to_current_position(home_fr_mm_s);
   #else
     // Get the ABC or XYZ positions in mm
     abce_pos_t target = planner.get_axis_positions_mm();
 
     target[axis] = 0;                         // Set the single homing axis to 0
     planner.set_machine_position_mm(target);  // Update the machine position
 
     #if HAS_DIST_MM_ARG
       const xyze_float_t cart_dist_mm{0};
     #endif
 
     // Set delta/cartesian axes directly
     target[axis] = distance;                  // The move will be towards the endstop
     planner.buffer_segment(target
       #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
-      , real_fr_mm_s, active_extruder
+      , home_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(false);
     #endif
@@ -1564,67 +1563,80 @@ void homeaxis(const AxisEnum axis) {
       || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
     ))
     if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
   const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
               ? x_home_dir(active_extruder) : home_dir(axis);
 
-  // Homing Z towards the bed? Deploy the Z probe or endstop.
+  //
+  // Homing Z with a probe? Raise Z (maybe) and deploy the Z probe.
+  //
   if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
     return;
 
   // Set flags for X, Y, Z motor locking
   #if HAS_EXTRA_ENDSTOPS
     switch (axis) {
       TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
       TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
       TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
         stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
-  // Fast move towards endstop until triggered
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
-
+  //
+  // Deploy BLTouch or tare the probe just before probing
+  //
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS) {
-      if (TERN0(BLTOUCH, bltouch.deploy())) return;
+      if (TERN0(BLTOUCH, bltouch.deploy())) return;   // BLTouch was deployed above, but get the alarm state.
       if (TERN0(PROBE_TARE, probe.tare())) return;
     }
   #endif
 
+  //
+  // Back away to prevent an early X/Y sensorless trigger
+  //
   #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
     const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
-    if (((ENABLED(X_SENSORLESS) && axis == X_AXIS) || (ENABLED(Y_SENSORLESS) && axis == Y_AXIS)) && backoff[axis])
-      do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
+    if ((TERN0(X_SENSORLESS, axis == X_AXIS) || TERN0(Y_SENSORLESS, axis == Y_AXIS)) && backoff[axis]) {
+      const float backoff_length = -ABS(backoff[axis]) * axis_home_dir;
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Sensorless backoff: ", backoff_length, "mm");
+      do_homing_move(axis, backoff_length, homing_feedrate(axis));
+    }
   #endif
 
-  do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
+  //
+  // Fast move towards endstop until triggered
+  //
+  const float move_length = 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir;
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Home Fast: ", move_length, "mm");
+  do_homing_move(axis, move_length);
 
   #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
   const float bump = axis_home_dir * (
     use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOMING_BUMP_MM
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Move Away: ", -bump, "mm");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
     );
 
     #if ENABLED(DETECT_BROKEN_ENDSTOP)
       // Check for a broken endstop
       EndstopEnum es;
       switch (axis) {
@@ -1632,28 +1644,28 @@ void homeaxis(const AxisEnum axis) {
         case X_AXIS: es = X_ENDSTOP; break;
         case Y_AXIS: es = Y_ENDSTOP; break;
         case Z_AXIS: es = Z_ENDSTOP; break;
       }
       if (TEST(endstops.state(), es)) {
         SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
         kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
       }
     #endif
 
-    // Slow move towards endstop until triggered
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
-
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
-    do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
+    // Slow move towards endstop until triggered
+    const float rebump = bump * 2;
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Re-bump: ", rebump, "mm");
+    do_homing_move(axis, rebump, get_homing_bump_feedrate(axis));
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {

commit c87c354403342ea12fce220116665e22efbe8194
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Wed Dec 23 03:10:56 2020 -0300

    Refactor 'Level Corners with Probe' (#20460)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3800bc6b0a..9b6a0d913b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1597,21 +1597,21 @@ void homeaxis(const AxisEnum axis) {
   #endif
 
   #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
     const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
     if (((ENABLED(X_SENSORLESS) && axis == X_AXIS) || (ENABLED(Y_SENSORLESS) && axis == Y_AXIS)) && backoff[axis])
       do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
   #endif
 
   do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 
-  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
   const float bump = axis_home_dir * (
     use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
@@ -1635,21 +1635,21 @@ void homeaxis(const AxisEnum axis) {
       }
       if (TEST(endstops.state(), es)) {
         SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
         kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
       }
     #endif
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
-    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH_SLOW_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 

commit 2963229dfa6648246951de90e4a86bf537cc876a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:11:43 2020 -0500

    Probe Tare, Probe Activation Switch (#20379)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>
    Co-authored-by: Victor Mateus Oliveira <rhapsodyv@gmail.com>
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 45ec513149..3800bc6b0a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1582,22 +1582,25 @@ void homeaxis(const AxisEnum axis) {
       TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
       TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
         stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
-  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
-    if (axis == Z_AXIS && bltouch.deploy()) return; // The initial DEPLOY
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS) {
+      if (TERN0(BLTOUCH, bltouch.deploy())) return;
+      if (TERN0(PROBE_TARE, probe.tare())) return;
+    }
   #endif
 
   #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
     const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
     if (((ENABLED(X_SENSORLESS) && axis == X_AXIS) || (ENABLED(Y_SENSORLESS) && axis == Y_AXIS)) && backoff[axis])
       do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
   #endif
 
   do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 

commit e5d0b27aafa9c33931e2abf668e498a3532b3dc2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 18 21:13:37 2020 -0600

    Rename QUIET_PROBING

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 127ba80788..45ec513149 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1314,21 +1314,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
   const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? x_home_dir(active_extruder) : home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   #if ENABLED(SENSORLESS_HOMING)
     sensorless_t stealth_states;
   #endif
 
   if (is_home_dir) {
 
-    #if HOMING_Z_WITH_PROBE && QUIET_PROBING
+    #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
@@ -1353,21 +1353,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
         , cart_dist_mm
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
-    #if HOMING_Z_WITH_PROBE && QUIET_PROBING
+    #if HOMING_Z_WITH_PROBE && HAS_QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
   }
 }
 

commit fbcc07261d944222cca30ef8590fb387f53fcc70
Author: rafaljot <rafal@jastrzebscy.org>
Date:   Thu Dec 17 13:02:05 2020 +0100

    Homing feedrates as XYZ array (#20426)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 28bf16a310..127ba80788 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -136,30 +136,20 @@ xyze_pos_t destination; // {0}
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
 int16_t feedrate_percentage = 100;
 
-// Homing feedrate is const progmem - compare to constexpr in the header
-const feedRate_t homing_feedrate_mm_s[XYZ] PROGMEM = {
-  #if ENABLED(DELTA)
-    MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
-  #else
-    MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
-  #endif
-  MMM_TO_MMS(HOMING_FEEDRATE_Z)
-};
-
 // Cartesian conversion result goes here:
 xyz_pos_t cartes;
 
 #if IS_KINEMATIC
 
   abc_pos_t delta;
 
   #if HAS_SCARA_OFFSET
     abc_pos_t scara_home_offset;
   #endif
@@ -188,21 +178,21 @@ xyz_pos_t cartes;
   // This offset is added to the configured home position.
   // Set by M206, M428, or menu item. Saved to EEPROM.
   xyz_pos_t home_offset{0};
 #endif
 #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   // The above two are combined to save on computes
   xyz_pos_t workspace_offset{0};
 #endif
 
 #if HAS_ABL_NOT_UBL
-  float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
+  feedRate_t xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
   TERN_(IS_SCARA, scara_report_positions());
 }
@@ -503,21 +493,21 @@ void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
 void do_z_clearance(const float &zclear, const bool z_trusted/*=true*/, const bool raise_on_untrusted/*=true*/, const bool lower_allowed/*=false*/) {
   const bool rel = raise_on_untrusted && !z_trusted;
   float zdest = zclear + (rel ? current_position.z : 0.0f);
   if (!lower_allowed) NOLESS(zdest, current_position.z);
-  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST), homing_feedrate(Z_AXIS)));
+  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, z_probe_fast_mm_s, homing_feedrate(Z_AXIS)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
@@ -1834,21 +1824,21 @@ void homeaxis(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && probe.stow()) return;
   #endif
 
   #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
     const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
     if (endstop_backoff[axis]) {
       current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
-          (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
+          (axis == Z_AXIS) ? z_probe_fast_mm_s :
         #endif
         homing_feedrate(axis)
       );
 
       #if ENABLED(SENSORLESS_HOMING)
         planner.synchronize();
         if (false
           #if EITHER(IS_CORE, MARKFORGED_XY)
             || axis != NORMAL_AXIS
           #endif

commit 20b3af1cc2c4a5e8505d1aae3419ab9418ed88ab
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 16 22:18:40 2020 -0600

    Use homing_feedrate function

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7b4c89e759..28bf16a310 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -503,21 +503,21 @@ void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
 void do_z_clearance(const float &zclear, const bool z_trusted/*=true*/, const bool raise_on_untrusted/*=true*/, const bool lower_allowed/*=false*/) {
   const bool rel = raise_on_untrusted && !z_trusted;
   float zdest = zclear + (rel ? current_position.z : 0.0f);
   if (!lower_allowed) NOLESS(zdest, current_position.z);
-  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), MMM_TO_MMS(TERN(HAS_BED_PROBE, Z_PROBE_SPEED_FAST, HOMING_FEEDRATE_Z)));
+  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), TERN(HAS_BED_PROBE, MMM_TO_MMS(Z_PROBE_SPEED_FAST), homing_feedrate(Z_AXIS)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;

commit 21ee7b1c862230e58d68bd8a9a81e561fc5df1e2
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Dec 4 21:58:39 2020 -0800

    Fix TMC_HOME_PHASE divide by zero (#20368)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3a01cda5c1..7b4c89e759 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1483,40 +1483,42 @@ void set_axis_never_homed(const AxisEnum axis) {
     const xyz_long_t home_phase = TMC_HOME_PHASE;
 
     // check if home phase is disabled for this axis.
     if (home_phase[axis] < 0) return;
 
     int16_t phasePerUStep,      // TMC ¬µsteps(phase) per Marlin ¬µsteps
             phaseCurrent,       // The TMC ¬µsteps(phase) count of the current position
             effectorBackoutDir, // Direction in which the effector mm coordinates move away from endstop.
             stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
 
+    #define PHASE_PER_MICROSTEP(N) (256 / _MAX(1, N##_MICROSTEPS))
+
     switch (axis) {
       #ifdef X_MICROSTEPS
         case X_AXIS:
-          phasePerUStep = 256 / (X_MICROSTEPS);
+          phasePerUStep = PHASE_PER_MICROSTEP(X);
           phaseCurrent = stepperX.get_microstep_counter();
           effectorBackoutDir = -X_HOME_DIR;
           stepperBackoutDir = INVERT_X_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       #ifdef Y_MICROSTEPS
         case Y_AXIS:
-          phasePerUStep = 256 / (Y_MICROSTEPS);
+          phasePerUStep = PHASE_PER_MICROSTEP(Y);
           phaseCurrent = stepperY.get_microstep_counter();
           effectorBackoutDir = -Y_HOME_DIR;
           stepperBackoutDir = INVERT_Y_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       #ifdef Z_MICROSTEPS
         case Z_AXIS:
-          phasePerUStep = 256 / (Z_MICROSTEPS);
+          phasePerUStep = PHASE_PER_MICROSTEP(Z);
           phaseCurrent = stepperZ.get_microstep_counter();
           effectorBackoutDir = -Z_HOME_DIR;
           stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       default: return;
     }
 
     // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
     int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 03c8ddc462..3a01cda5c1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -72,25 +72,25 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
- * axis_known_position
- *   Flags that the position is known in each linear axis. Set when homed.
+ * axis_trusted
+ *   Flags that the position is trusted in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
-uint8_t axis_homed, axis_known_position; // = 0
+uint8_t axis_homed, axis_trusted; // = 0
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
@@ -499,22 +499,22 @@ void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &
   do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
-void do_z_clearance(const float &zclear, const bool z_known/*=true*/, const bool raise_on_unknown/*=true*/, const bool lower_allowed/*=false*/) {
-  const bool rel = raise_on_unknown && !z_known;
+void do_z_clearance(const float &zclear, const bool z_trusted/*=true*/, const bool raise_on_untrusted/*=true*/, const bool lower_allowed/*=false*/) {
+  const bool rel = raise_on_untrusted && !z_trusted;
   float zdest = zclear + (rel ? current_position.z : 0.0f);
   if (!lower_allowed) NOLESS(zdest, current_position.z);
   do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), MMM_TO_MMS(TERN(HAS_BED_PROBE, Z_PROBE_SPEED_FAST, HOMING_FEEDRATE_Z)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
@@ -642,49 +642,49 @@ void restore_feedrate_and_scaling() {
       if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
-      if (TERN1(IS_SCARA, TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS))) {
+      if (TERN1(IS_SCARA, axis_was_homed(X_AXIS) && axis_was_homed(Y_AXIS))) {
         const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
         if (dist_2 > delta_max_radius_2)
           target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
       }
 
     #else
 
-      if (TEST(axis_homed, X_AXIS)) {
+      if (axis_was_homed(X_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
           NOLESS(target.x, soft_endstop.min.x);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
           NOMORE(target.x, soft_endstop.max.x);
         #endif
       }
 
-      if (TEST(axis_homed, Y_AXIS)) {
+      if (axis_was_homed(Y_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
           NOLESS(target.y, soft_endstop.min.y);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
           NOMORE(target.y, soft_endstop.max.y);
         #endif
       }
 
     #endif
 
-    if (TEST(axis_homed, Z_AXIS)) {
+    if (axis_was_homed(Z_AXIS)) {
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
         NOLESS(target.z, soft_endstop.min.z);
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
         NOMORE(target.z, soft_endstop.max.z);
       #endif
     }
   }
 
 #else // !HAS_SOFTWARE_ENDSTOPS
@@ -1117,24 +1117,25 @@ void prepare_line_to_destination() {
       line_to_destination_kinematic()
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
 uint8_t axes_should_home(uint8_t axis_bits/*=0x07*/) {
+  #define SHOULD_HOME(A) TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(A)
   // Clear test bits that are trusted
-  if (TEST(axis_bits, X_AXIS) && TEST(axis_homed, X_AXIS)) CBI(axis_bits, X_AXIS);
-  if (TEST(axis_bits, Y_AXIS) && TEST(axis_homed, Y_AXIS)) CBI(axis_bits, Y_AXIS);
-  if (TEST(axis_bits, Z_AXIS) && TEST(axis_homed, Z_AXIS)) CBI(axis_bits, Z_AXIS);
+  if (TEST(axis_bits, X_AXIS) && SHOULD_HOME(X_AXIS)) CBI(axis_bits, X_AXIS);
+  if (TEST(axis_bits, Y_AXIS) && SHOULD_HOME(Y_AXIS)) CBI(axis_bits, Y_AXIS);
+  if (TEST(axis_bits, Z_AXIS) && SHOULD_HOME(Z_AXIS)) CBI(axis_bits, Z_AXIS);
   return axis_bits;
 }
 
 bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
   if ((axis_bits = axes_should_home(axis_bits))) {
     PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
     char msg[strlen_P(home_first)+1];
     sprintf_P(msg, home_first,
       TEST(axis_bits, X_AXIS) ? "X" : "",
       TEST(axis_bits, Y_AXIS) ? "Y" : "",
@@ -1381,35 +1382,35 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
 }
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
  *
  * DELTA should wait until all homing is done before setting the XYZ
  * current_position to home, because homing is a single operation.
- * In the case where the axis positions are already known and previously
+ * In the case where the axis positions are trusted and previously
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", axis_codes[axis], ")");
 
-  SBI(axis_known_position, axis);
-  SBI(axis_homed, axis);
+  set_axis_trusted(axis);
+  set_axis_homed(axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
@@ -1455,22 +1456,22 @@ void set_axis_is_at_home(const AxisEnum axis) {
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
 }
 
 /**
  * Set an axis to be unhomed.
  */
 void set_axis_never_homed(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
 
-  CBI(axis_known_position, axis);
-  CBI(axis_homed, axis);
+  set_axis_untrusted(axis);
+  set_axis_unhomed(axis);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
 }
 
 #ifdef TMC_HOME_PHASE
   /**
    * Move the axis back to its home_phase if set and driver is capable (TMC)
    *

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 75a7944c3f..03c8ddc462 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -29,37 +29,37 @@
 #include "stepper.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../gcode/gcode.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
-  #include "../lcd/ultralcd.h"
+  #include "../lcd/marlinui.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if HAS_DISPLAY
-  #include "../lcd/ultralcd.h"
+  #include "../lcd/marlinui.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5b3fab10b1..75a7944c3f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -562,21 +562,21 @@ void restore_feedrate_and_scaling() {
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = _MAX(hotend_offset[1].x, X2_MAX_POS);
 
         if (new_tool_index != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop.min.x = X2_MIN_POS;
           soft_endstop.max.x = dual_max_x;
         }
-        else if (dxc_is_duplicating()) {
+        else if (idex_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = _MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = X1_MAX_POS;
         }
@@ -925,112 +925,135 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
     #endif // HAS_MESH
 
     planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
-  bool extruder_duplication_enabled,
-       mirrored_duplication_mode;
+  bool extruder_duplication_enabled;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     uint8_t duplication_e_mask; // = 0
   #endif
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
-  float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
-        duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
-  xyz_pos_t raised_parked_position;                                       // used in mode 1
-  bool active_extruder_parked            = false;                         // used in mode 1 & 2
-  millis_t delayed_move_time             = 0;                             // used in mode 1
-  int16_t duplicate_extruder_temp_offset = 0;                             // used in mode 2
+  float inactive_extruder_x              = X2_MAX_POS,                    // Used in mode 0 & 1
+        duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // Used in mode 2
+  xyz_pos_t raised_parked_position;                                       // Used in mode 1
+  bool active_extruder_parked            = false;                         // Used in mode 1 & 2
+  millis_t delayed_move_time             = 0;                             // Used in mode 1
+  int16_t duplicate_extruder_temp_offset = 0;                             // Used in mode 2
+  bool idex_mirrored_mode                = false;                         // Used in mode 3
 
   float x_home_pos(const uint8_t extruder) {
     if (extruder == 0)
       return base_home_pos(X_AXIS);
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
       return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
   }
 
+  void idex_set_mirrored_mode(const bool mirr) {
+    idex_mirrored_mode = mirr;
+    stepper.set_directions();
+  }
+
+  void set_duplication_enabled(const bool dupe, const int8_t tool_index/*=-1*/) {
+    extruder_duplication_enabled = dupe;
+    if (tool_index >= 0) active_extruder = tool_index;
+    stepper.set_directions();
+  }
+
+  void idex_set_parked(const bool park/*=true*/) {
+    delayed_move_time = 0;
+    active_extruder_parked = park;
+    if (park) raised_parked_position = current_position;  // Remember current raised toolhead position for use by unpark
+  }
+
   /**
    * Prepare a linear move in a dual X axis setup
    *
    * Return true if current_position[] was set to destination[]
    */
   inline bool dual_x_carriage_unpark() {
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE:
-          break;
-        case DXC_AUTO_PARK_MODE:
+
+        case DXC_FULL_CONTROL_MODE: break;
+
+        case DXC_AUTO_PARK_MODE: {
           if (current_position.e == destination.e) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
               current_position = destination;
               NOLESS(raised_parked_position.z, destination.z);
               delayed_move_time = millis();
               return true;
             }
           }
-          // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
-
-            #define CUR_X    current_position.x
-            #define CUR_Y    current_position.y
-            #define CUR_Z    current_position.z
-            #define CUR_E    current_position.e
-            #define RAISED_X raised_parked_position.x
-            #define RAISED_Y raised_parked_position.y
-            #define RAISED_Z raised_parked_position.z
-
-            if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder))
-              if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
-                  line_to_current_position(planner.settings.max_feedrate_mm_s[Z_AXIS]);
-          delayed_move_time = 0;
-          active_extruder_parked = false;
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Clear active_extruder_parked");
-          break;
+          //
+          // Un-park the active extruder
+          //
+          const feedRate_t fr_zfast = planner.settings.max_feedrate_mm_s[Z_AXIS];
+          #define CURPOS current_position
+          #define RAISED raised_parked_position
+          //  1. Move to the raised parked XYZ. Presumably the tool is already at XY.
+          if (planner.buffer_line(RAISED.x, RAISED.y, RAISED.z, CURPOS.e, fr_zfast, active_extruder)) {
+            //  2. Move to the current native XY and raised Z. Presumably this is a null move.
+            if (planner.buffer_line(CURPOS.x, CURPOS.y, RAISED.z, CURPOS.e, PLANNER_XY_FEEDRATE(), active_extruder)) {
+              //  3. Lower Z back down
+              line_to_current_position(fr_zfast);
+            }
+          }
+          planner.synchronize(); // paranoia
+          stepper.set_directions();
+
+          idex_set_parked(false);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("idex_set_parked(false)");
+        } break;
+
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             xyze_pos_t new_pos = current_position;
             if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
               new_pos.x += duplicate_extruder_x_offset;
             else
-              new_pos.x = inactive_extruder_x_pos;
-            // move duplicate extruder into correct duplication position.
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x_pos, " ... Line to X", new_pos.x);
-            planner.set_position_mm(inactive_extruder_x_pos, current_position.y, current_position.z, current_position.e);
+              new_pos.x = inactive_extruder_x;
+            // Move duplicate extruder into correct duplication position.
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x, " ... Line to X", new_pos.x);
+            planner.set_position_mm(inactive_extruder_x, current_position.y, current_position.z, current_position.e);
             if (!planner.buffer_line(new_pos, planner.settings.max_feedrate_mm_s[X_AXIS], 1)) break;
+
             planner.synchronize();
             sync_plan_position();
-            extruder_duplication_enabled = true;
-            active_extruder_parked = false;
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
+
+            set_duplication_enabled(true);
+            idex_set_parked(false);
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("set_duplication_enabled(true)\nidex_set_parked(false)");
           }
           else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Active extruder not 0");
           break;
       }
     }
-    stepper.set_directions();
     return false;
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.

commit 733eb127e9abb6910f4cc0f1adabb4c696eeb571
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 13 14:54:56 2020 -0500

    Simple bool in soft_endstops_t

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 92712b0c22..5b3fab10b1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -529,23 +529,23 @@ void remember_feedrate_scaling_off() {
 }
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   soft_endstops_t soft_endstop = {
+    true, false,
     { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
-    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS },
-    { true, false }
+    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS }
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index da1cb173e5..92712b0c22 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -527,26 +527,25 @@ void remember_feedrate_scaling_off() {
   remember_feedrate_and_scaling();
   feedrate_percentage = 100;
 }
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
-  bool soft_endstops_enabled = true;
-
   // Software Endstops are based on the configured limits.
-  axis_limits_t soft_endstop = {
+  soft_endstops_t soft_endstop = {
     { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
-    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS }
+    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS },
+    { true, false }
   };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -617,33 +616,33 @@ void restore_feedrate_and_scaling() {
         soft_endstop.max[axis] = base_max_pos(axis) + offs;
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
-  if (DEBUGGING(LEVELING))
-    SERIAL_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
-}
+    if (DEBUGGING(LEVELING))
+      SERIAL_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+  }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
-    if (!soft_endstops_enabled) return;
+    if (!soft_endstop._enabled) return;
 
     #if IS_KINEMATIC
 
       if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
@@ -681,21 +680,25 @@ void restore_feedrate_and_scaling() {
     if (TEST(axis_homed, Z_AXIS)) {
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
         NOLESS(target.z, soft_endstop.min.z);
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
         NOMORE(target.z, soft_endstop.max.z);
       #endif
     }
   }
 
-#endif // HAS_SOFTWARE_ENDSTOPS
+#else // !HAS_SOFTWARE_ENDSTOPS
+
+  soft_endstops_t soft_endstop;
+
+#endif // !HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 
 FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   const millis_t ms = millis();
   if (ELAPSED(ms, next_idle_ms)) {
     next_idle_ms = ms + 200UL;
     return idle();
   }
   thermalManager.manage_heater();  // Returns immediately on most calls

commit edda32e6b4b7ca004eb49f76fe2f7bd72b0293aa
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Oct 11 17:42:50 2020 -0700

    Fix motion compile w/out probe-oriented settings (#19684)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b904309018..da1cb173e5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -503,21 +503,21 @@ void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
 void do_z_clearance(const float &zclear, const bool z_known/*=true*/, const bool raise_on_unknown/*=true*/, const bool lower_allowed/*=false*/) {
   const bool rel = raise_on_unknown && !z_known;
   float zdest = zclear + (rel ? current_position.z : 0.0f);
   if (!lower_allowed) NOLESS(zdest, current_position.z);
-  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), MMM_TO_MMS(TERN(HAS_BED_PROBE, Z_PROBE_SPEED_FAST, HOMING_FEEDRATE_Z)));
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
@@ -1119,22 +1119,23 @@ bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
     TERN_(HAS_DISPLAY, ui.set_status(msg));
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
-  if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS))
-    return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
+  #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / float(hbd);
 }
 
 #if ENABLED(SENSORLESS_HOMING)
@@ -1581,21 +1582,21 @@ void homeaxis(const AxisEnum axis) {
 
   do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 
   #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
   const float bump = axis_home_dir * (
-    use_probe_bump ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
+    use_probe_bump ? _MAX(TERN0(HOMING_Z_WITH_PROBE, Z_CLEARANCE_BETWEEN_PROBES), home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOMING_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2f12302e59..b904309018 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -104,21 +104,21 @@ xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
   uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
   xyz_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // The active extruder (tool). Set with T<extruder> command.
-#if EXTRUDERS > 1
+#if HAS_MULTI_EXTRUDER
   uint8_t active_extruder = 0; // = 0
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   float e_move_accumulator; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()

commit e97e6865c3e587a04ae2878e72a8dfb137534b7e
Author: Victor Sokolov <gzigzigzeo@gmail.com>
Date:   Fri Sep 4 05:12:53 2020 +0400

    MarkForged kinematics (#19235)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 401721140b..2f12302e59 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1145,34 +1145,34 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     sensorless_t stealth_states { false };
 
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           stealth_states.x = tmc_enable_stallguard(stepperX);
           #if AXIS_HAS_STALLGUARD(X2)
             stealth_states.x2 = tmc_enable_stallguard(stepperX2);
           #endif
-          #if CORE_IS_XY && Y_SENSORLESS
+          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #elif CORE_IS_XZ && Z_SENSORLESS
             stealth_states.z = tmc_enable_stallguard(stepperZ);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
           stealth_states.y = tmc_enable_stallguard(stepperY);
           #if AXIS_HAS_STALLGUARD(Y2)
             stealth_states.y2 = tmc_enable_stallguard(stepperY2);
           #endif
-          #if CORE_IS_XY && X_SENSORLESS
+          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Z_SENSORLESS
             stealth_states.z = tmc_enable_stallguard(stepperZ);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           stealth_states.z = tmc_enable_stallguard(stepperZ);
           #if AXIS_HAS_STALLGUARD(Z2)
@@ -1209,34 +1209,34 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
 
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           tmc_disable_stallguard(stepperX, enable_stealth.x);
           #if AXIS_HAS_STALLGUARD(X2)
             tmc_disable_stallguard(stepperX2, enable_stealth.x2);
           #endif
-          #if CORE_IS_XY && Y_SENSORLESS
+          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #elif CORE_IS_XZ && Z_SENSORLESS
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
           tmc_disable_stallguard(stepperY, enable_stealth.y);
           #if AXIS_HAS_STALLGUARD(Y2)
             tmc_disable_stallguard(stepperY2, enable_stealth.y2);
           #endif
-          #if CORE_IS_XY && X_SENSORLESS
+          #if EITHER(CORE_IS_XY, MARKFORGED_XY) && X_SENSORLESS
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Z_SENSORLESS
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #if AXIS_HAS_STALLGUARD(Z2)
@@ -1782,21 +1782,21 @@ void homeaxis(const AxisEnum axis) {
 
     const float adjDistance = delta_endstop_adj[axis],
                 minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
 
     // Retrace by the amount specified in delta_endstop_adj if more than min steps.
     if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("adjDistance:", adjDistance);
       do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
     }
 
-  #else // CARTESIAN / CORE
+  #else // CARTESIAN / CORE / MARKFORGED_XY
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
@@ -1811,22 +1811,25 @@ void homeaxis(const AxisEnum axis) {
       current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
 
       #if ENABLED(SENSORLESS_HOMING)
         planner.synchronize();
-        if (TERN0(IS_CORE, axis != NORMAL_AXIS))
-          safe_delay(200);  // Short delay to allow belts to spring back
+        if (false
+          #if EITHER(IS_CORE, MARKFORGED_XY)
+            || axis != NORMAL_AXIS
+          #endif
+        ) safe_delay(200);  // Short delay to allow belts to spring back
       #endif
     }
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c6378d67fc..401721140b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1090,31 +1090,30 @@ void prepare_line_to_destination() {
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
-uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
-  #define HOMED_FLAGS TERN(HOME_AFTER_DEACTIVATE, axis_known_position, axis_homed)
-  // Clear test bits that are homed
-  if (TEST(axis_bits, X_AXIS) && TEST(HOMED_FLAGS, X_AXIS)) CBI(axis_bits, X_AXIS);
-  if (TEST(axis_bits, Y_AXIS) && TEST(HOMED_FLAGS, Y_AXIS)) CBI(axis_bits, Y_AXIS);
-  if (TEST(axis_bits, Z_AXIS) && TEST(HOMED_FLAGS, Z_AXIS)) CBI(axis_bits, Z_AXIS);
+uint8_t axes_should_home(uint8_t axis_bits/*=0x07*/) {
+  // Clear test bits that are trusted
+  if (TEST(axis_bits, X_AXIS) && TEST(axis_homed, X_AXIS)) CBI(axis_bits, X_AXIS);
+  if (TEST(axis_bits, Y_AXIS) && TEST(axis_homed, Y_AXIS)) CBI(axis_bits, Y_AXIS);
+  if (TEST(axis_bits, Z_AXIS) && TEST(axis_homed, Z_AXIS)) CBI(axis_bits, Z_AXIS);
   return axis_bits;
 }
 
-bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
-  if ((axis_bits = axes_need_homing(axis_bits))) {
+bool homing_needed_error(uint8_t axis_bits/*=0x07*/) {
+  if ((axis_bits = axes_should_home(axis_bits))) {
     PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
     char msg[strlen_P(home_first)+1];
     sprintf_P(msg, home_first,
       TEST(axis_bits, X_AXIS) ? "X" : "",
       TEST(axis_bits, Y_AXIS) ? "Y" : "",
       TEST(axis_bits, Z_AXIS) ? "Z" : ""
     );
     SERIAL_ECHO_START();
     SERIAL_ECHOLN(msg);
     TERN_(HAS_DISPLAY, ui.set_status(msg));

commit 462d3eeab15d173ade700faf961931050aed9d70
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 27 14:48:42 2020 -0500

    set_axis_not_trusted => set_axis_never_homed

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9b8c1c60ff..c6378d67fc 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1424,29 +1424,29 @@ void set_axis_is_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
 }
 
 /**
- * Set an axis' to be unhomed.
+ * Set an axis to be unhomed.
  */
-void set_axis_not_trusted(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_not_trusted(", axis_codes[axis], ")");
+void set_axis_never_homed(const AxisEnum axis) {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_never_homed(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_not_trusted(", axis_codes[axis], ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_never_homed(", axis_codes[axis], ")");
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
 }
 
 #ifdef TMC_HOME_PHASE
   /**
    * Move the axis back to its home_phase if set and driver is capable (TMC)
    *
    * Improves homing repeatability by homing to stepper coil's nearest absolute
    * phase position. Trinamic drivers use a stepper phase table with 1024 values

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 24ce57a764..9b8c1c60ff 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1091,25 +1091,21 @@ void prepare_line_to_destination() {
       line_to_destination_kinematic()
     #else
       line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
 uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
-  #if ENABLED(HOME_AFTER_DEACTIVATE)
-    #define HOMED_FLAGS axis_known_position
-  #else
-    #define HOMED_FLAGS axis_homed
-  #endif
+  #define HOMED_FLAGS TERN(HOME_AFTER_DEACTIVATE, axis_known_position, axis_homed)
   // Clear test bits that are homed
   if (TEST(axis_bits, X_AXIS) && TEST(HOMED_FLAGS, X_AXIS)) CBI(axis_bits, X_AXIS);
   if (TEST(axis_bits, Y_AXIS) && TEST(HOMED_FLAGS, Y_AXIS)) CBI(axis_bits, Y_AXIS);
   if (TEST(axis_bits, Z_AXIS) && TEST(HOMED_FLAGS, Z_AXIS)) CBI(axis_bits, Z_AXIS);
   return axis_bits;
 }
 
 bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
   if ((axis_bits = axes_need_homing(axis_bits))) {
     PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 346042437d..24ce57a764 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * motion.cpp
  */
 
 #include "motion.h"
 #include "endstops.h"
 #include "stepper.h"

commit b40440cf3846bca4a0a10bb43d6d60f725a26cfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 17:58:37 2020 -0500

    Tool-change debug option

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 539ceac787..346042437d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -939,21 +939,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   xyz_pos_t raised_parked_position;                                       // used in mode 1
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
   int16_t duplicate_extruder_temp_offset = 0;                             // used in mode 2
 
-  float x_home_pos(const int extruder) {
+  float x_home_pos(const uint8_t extruder) {
     if (extruder == 0)
       return base_home_pos(X_AXIS);
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
       return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;

commit 2c238e4fc2f18da08d7cb171bb7236beccdd6f83
Author: Speaka <48431623+Speaka@users.noreply.github.com>
Date:   Sun Jul 12 20:16:56 2020 +0200

    Option for extra endstop check (#18424)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5b7845e45b..539ceac787 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1599,20 +1599,35 @@ void homeaxis(const AxisEnum axis) {
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOMING_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
     );
 
+    #if ENABLED(DETECT_BROKEN_ENDSTOP)
+      // Check for a broken endstop
+      EndstopEnum es;
+      switch (axis) {
+        default:
+        case X_AXIS: es = X_ENDSTOP; break;
+        case Y_AXIS: es = Y_ENDSTOP; break;
+        case Z_AXIS: es = Z_ENDSTOP; break;
+      }
+      if (TEST(endstops.state(), es)) {
+        SERIAL_ECHO_MSG("Bad ", axis_codes[axis], " Endstop?");
+        kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
+      }
+    #endif
+
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cbf52bae22..5b7845e45b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -380,21 +380,22 @@ void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s/*=0.0*/) {
-  if (DEBUGGING(LEVELING)) DEBUG_XYZ(">>> do_blocking_move_to", rx, ry, rz);
+  DEBUG_SECTION(log_move, "do_blocking_move_to", DEBUGGING(LEVELING));
+  if (DEBUGGING(LEVELING)) DEBUG_XYZ("> ", rx, ry, rz);
 
   const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
@@ -464,22 +465,20 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
     line_to_current_position(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
     if (current_position.z > rz) {
       current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
-
   planner.synchronize();
 }
 
 void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
 }
 void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
@@ -500,20 +499,27 @@ void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &
   do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
   do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
 }
 
+void do_z_clearance(const float &zclear, const bool z_known/*=true*/, const bool raise_on_unknown/*=true*/, const bool lower_allowed/*=false*/) {
+  const bool rel = raise_on_unknown && !z_known;
+  float zdest = zclear + (rel ? current_position.z : 0.0f);
+  if (!lower_allowed) NOLESS(zdest, current_position.z);
+  do_blocking_move_to_z(_MIN(zdest, Z_MAX_POS), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+}
+
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
 }
@@ -1265,25 +1271,26 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
       }
     #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0) {
+  DEBUG_SECTION(log_move, "do_homing_move", DEBUGGING(LEVELING));
 
   const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
 
   if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
+    DEBUG_ECHOPAIR("...(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", real_fr_mm_s, "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   #if ALL(HOMING_Z_WITH_PROBE, HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0)
@@ -1342,22 +1349,20 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
   }
-
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< do_homing_move(", axis_codes[axis], ")");
 }
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
  *
  * DELTA should wait until all homing is done before setting the XYZ
  * current_position to home, because homing is a single operation.

commit d6682c860924ca96ee51c15906beffc8e4b4f37b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 7 01:57:05 2020 -0500

    Whitespace cleanup

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f7732f577f..cbf52bae22 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1495,21 +1495,21 @@ void set_axis_not_trusted(const AxisEnum axis) {
 
     // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
     if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
       SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
                        " too close to endstop trigger phase ", phaseCurrent,
                        ". Pick a different phase for ", axis_codes[axis]);
 
     // Skip to next if target position is behind current. So it only moves away from endstop.
     if (phaseDelta < 0) phaseDelta += 1024;
 
-    // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm 
+    // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm
     const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
     // Optional debug messages
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR(
         "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
         " Delta:", phaseDelta, " Distance:", mmDelta
       );
     }
 

commit 9ee891c4a602b8cbdf1f477e28b4e1bc9003fd99
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Jul 7 00:32:33 2020 +0200

    Fix TMC homing phase coils alignment (#18528)
    
    Co-authored-by: Fabio Santos <fabiosan@live.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1994280a2c..f7732f577f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1436,95 +1436,96 @@ void set_axis_not_trusted(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_not_trusted(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_not_trusted(", axis_codes[axis], ")");
 
   TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
 }
 
-/**
- * Move the axis back to its home_phase if set and driver is capable (TMC)
- *
- * Improves homing repeatability by homing to stepper coil's nearest absolute
- * phase position. Trinamic drivers use a stepper phase table with 1024 values
- * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
- */
-void backout_to_tmc_homing_phase(const AxisEnum axis) {
-  #ifdef TMC_HOME_PHASE
-    const abc_long_t home_phase = TMC_HOME_PHASE;
+#ifdef TMC_HOME_PHASE
+  /**
+   * Move the axis back to its home_phase if set and driver is capable (TMC)
+   *
+   * Improves homing repeatability by homing to stepper coil's nearest absolute
+   * phase position. Trinamic drivers use a stepper phase table with 1024 values
+   * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
+   */
+  void backout_to_tmc_homing_phase(const AxisEnum axis) {
+    const xyz_long_t home_phase = TMC_HOME_PHASE;
 
     // check if home phase is disabled for this axis.
     if (home_phase[axis] < 0) return;
 
-    int16_t axisMicrostepSize;
-    int16_t phaseCurrent;
-    bool invertDir;
+    int16_t phasePerUStep,      // TMC ¬µsteps(phase) per Marlin ¬µsteps
+            phaseCurrent,       // The TMC ¬µsteps(phase) count of the current position
+            effectorBackoutDir, // Direction in which the effector mm coordinates move away from endstop.
+            stepperBackoutDir;  // Direction in which the TMC ¬µstep count(phase) move away from endstop.
 
     switch (axis) {
       #ifdef X_MICROSTEPS
         case X_AXIS:
-          axisMicrostepSize = 256 / (X_MICROSTEPS);
+          phasePerUStep = 256 / (X_MICROSTEPS);
           phaseCurrent = stepperX.get_microstep_counter();
-          invertDir = INVERT_X_DIR;
+          effectorBackoutDir = -X_HOME_DIR;
+          stepperBackoutDir = INVERT_X_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       #ifdef Y_MICROSTEPS
         case Y_AXIS:
-          axisMicrostepSize = 256 / (Y_MICROSTEPS);
+          phasePerUStep = 256 / (Y_MICROSTEPS);
           phaseCurrent = stepperY.get_microstep_counter();
-          invertDir = INVERT_Y_DIR;
+          effectorBackoutDir = -Y_HOME_DIR;
+          stepperBackoutDir = INVERT_Y_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       #ifdef Z_MICROSTEPS
         case Z_AXIS:
-          axisMicrostepSize = 256 / (Z_MICROSTEPS);
+          phasePerUStep = 256 / (Z_MICROSTEPS);
           phaseCurrent = stepperZ.get_microstep_counter();
-          invertDir = INVERT_Z_DIR;
+          effectorBackoutDir = -Z_HOME_DIR;
+          stepperBackoutDir = INVERT_Z_DIR ? effectorBackoutDir : -effectorBackoutDir;
           break;
       #endif
       default: return;
     }
 
-    // Depending on invert dir measure the distance to nearest home phase.
-    int16_t phaseDelta = (invertDir ? -1 : 1) * (home_phase[axis] - phaseCurrent);
+    // Phase distance to nearest home phase position when moving in the backout direction from endstop(may be negative).
+    int16_t phaseDelta = (home_phase[axis] - phaseCurrent) * stepperBackoutDir;
 
     // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
-    if (ABS(phaseDelta) * planner.steps_to_mm[axis] / axisMicrostepSize < 0.05f)
-      DEBUG_ECHOLNPAIR("Selected home phase ", home_phase[axis],
+    if (ABS(phaseDelta) * planner.steps_to_mm[axis] / phasePerUStep < 0.05f)
+      SERIAL_ECHOLNPAIR("Selected home phase ", home_phase[axis],
                        " too close to endstop trigger phase ", phaseCurrent,
                        ". Pick a different phase for ", axis_codes[axis]);
 
     // Skip to next if target position is behind current. So it only moves away from endstop.
     if (phaseDelta < 0) phaseDelta += 1024;
 
-    // Get the integer ¬µsteps to target. Unreachable phase? Consistently stop at the ¬µstep before / after based on invertDir.
-    const float mmDelta = -(int16_t(phaseDelta / axisMicrostepSize) * planner.steps_to_mm[axis] * (Z_HOME_DIR));
+    // Convert TMC ¬µsteps(phase) to whole Marlin ¬µsteps to effector backout direction to mm 
+    const float mmDelta = int16_t(phaseDelta / phasePerUStep) * effectorBackoutDir * planner.steps_to_mm[axis];
 
-    // optional debug messages.
+    // Optional debug messages
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR(
         "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
         " Delta:", phaseDelta, " Distance:", mmDelta
       );
     }
 
     if (mmDelta != 0) {
-      // retrace by the amount computed in mmDelta.
+      // Retrace by the amount computed in mmDelta.
       do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
     }
-  #else
-    UNUSED(axis);
-  #endif
-}
-
+  }
+#endif
 
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.
  *
  * At the end of the procedure the axis is marked as
  * homed and the current position of that axis is updated.
  * Kinematic robots should wait till all axes are homed
  * before updating the current position.
@@ -1741,22 +1742,24 @@ void homeaxis(const AxisEnum axis) {
     // Reset flags for X, Y, Z motor locking
     switch (axis) {
       default: break;
       TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
       TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
       TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
         stepper.set_separate_multi_axis(false);
     }
   #endif
 
-  // move back to homing phase if configured and capable
-  backout_to_tmc_homing_phase(axis);
+  #ifdef TMC_HOME_PHASE
+    // move back to homing phase if configured and capable
+    backout_to_tmc_homing_phase(axis);
+  #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7fba6f8ea3..1994280a2c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1309,30 +1309,32 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
+    // Get the ABC or XYZ positions in mm
     abce_pos_t target = planner.get_axis_positions_mm();
-    target[axis] = 0;
-    planner.set_machine_position_mm(target);
-    target[axis] = distance;
+
+    target[axis] = 0;                         // Set the single homing axis to 0
+    planner.set_machine_position_mm(target);  // Update the machine position
 
     #if HAS_DIST_MM_ARG
       const xyze_float_t cart_dist_mm{0};
     #endif
 
     // Set delta/cartesian axes directly
+    target[axis] = distance;                  // The move will be towards the endstop
     planner.buffer_segment(target
       #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 

commit bc9e5e2abc6a4c6b87d6c2f98af75cb0d5e58be3
Author: brian park <gouache95@gmail.com>
Date:   Sat Jun 20 08:19:29 2020 +0900

    Fix _CAN_HOME (Y homing) bug (#18356)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 727bb15271..7fba6f8ea3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1530,22 +1530,22 @@ void backout_to_tmc_homing_phase(const AxisEnum axis) {
 
 void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   #else
     #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
          ENABLED(A##_SPI_SENSORLESS) \
       || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
-      || (A##_MIN_PIN > 0 && A##_HOME_DIR < 0) \
-      || (A##_MAX_PIN > 0 && A##_HOME_DIR > 0) \
+      || (A##_MIN_PIN > -1 && A##_HOME_DIR < 0) \
+      || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0) \
     ))
     if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
   const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
               ? x_home_dir(active_extruder) : home_dir(axis);
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.

commit a1f3d2f3cd9bf8bb4da16da0e55cdb5ff264a15d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 31 01:03:28 2020 -0500

    Move set_all_z_lock to Stepper

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 09f0f390c5..727bb15271 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1637,34 +1637,34 @@ void homeaxis(const AxisEnum axis) {
       }
     #endif
 
     #if ENABLED(Z_MULTI_ENDSTOPS)
       if (axis == Z_AXIS) {
 
         #if NUM_Z_STEPPER_DRIVERS == 2
 
           const float adj = ABS(endstops.z2_endstop_adj);
           if (adj) {
-            if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+            if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z1_lock(true); else stepper.set_z2_lock(true);
             do_homing_move(axis, pos_dir ? -adj : adj);
-            stepper.set_z_lock(false);
+            stepper.set_z1_lock(false);
             stepper.set_z2_lock(false);
           }
 
         #else
 
           // Handy arrays of stepper lock function pointers
 
           typedef void (*adjustFunc_t)(const bool);
 
           adjustFunc_t lock[] = {
-            stepper.set_z_lock, stepper.set_z2_lock, stepper.set_z3_lock
+            stepper.set_z1_lock, stepper.set_z2_lock, stepper.set_z3_lock
             #if NUM_Z_STEPPER_DRIVERS >= 4
               , stepper.set_z4_lock
             #endif
           };
           float adj[] = {
             0, endstops.z2_endstop_adj, endstops.z3_endstop_adj
             #if NUM_Z_STEPPER_DRIVERS >= 4
               , endstops.z4_endstop_adj
             #endif
           };
@@ -1718,21 +1718,21 @@ void homeaxis(const AxisEnum axis) {
             #if NUM_Z_STEPPER_DRIVERS >= 4
               (*lock[3])(true);
               do_homing_move(axis, adj[2] - adj[3]);
             #endif
             (*lock[2])(true);
             do_homing_move(axis, adj[1] - adj[2]);
             (*lock[1])(true);
             do_homing_move(axis, adj[0] - adj[1]);
           }
 
-          stepper.set_z_lock(false);
+          stepper.set_z1_lock(false);
           stepper.set_z2_lock(false);
           stepper.set_z3_lock(false);
           #if NUM_Z_STEPPER_DRIVERS >= 4
             stepper.set_z4_lock(false);
           #endif
 
         #endif
       }
     #endif
 

commit e380498512a325fe1e70b20d4c60a81f606eddbf
Author: Jonathan Gilbert <JonathanG@iQmetrix.com>
Date:   Mon Jun 1 00:19:36 2020 -0500

    Fix Z homing with custom probe pins (#18150)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 673eee3a92..09f0f390c5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1527,38 +1527,27 @@ void backout_to_tmc_homing_phase(const AxisEnum axis) {
  * Kinematic robots should wait till all axes are homed
  * before updating the current position.
  */
 
 void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   #else
-    #define _CAN_HOME(A) \
-      (axis == _AXIS(A) && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
-    #if X_SPI_SENSORLESS
-      #define CAN_HOME_X true
-    #else
-      #define CAN_HOME_X _CAN_HOME(X)
-    #endif
-    #if Y_SPI_SENSORLESS
-      #define CAN_HOME_Y true
-    #else
-      #define CAN_HOME_Y _CAN_HOME(Y)
-    #endif
-    #if Z_SPI_SENSORLESS
-      #define CAN_HOME_Z true
-    #else
-      #define CAN_HOME_Z _CAN_HOME(Z)
-    #endif
-    if (!CAN_HOME_X && !CAN_HOME_Y && !CAN_HOME_Z) return;
+    #define _CAN_HOME(A) (axis == _AXIS(A) && ( \
+         ENABLED(A##_SPI_SENSORLESS) \
+      || (_AXIS(A) == Z_AXIS && ENABLED(HOMING_Z_WITH_PROBE)) \
+      || (A##_MIN_PIN > 0 && A##_HOME_DIR < 0) \
+      || (A##_MAX_PIN > 0 && A##_HOME_DIR > 0) \
+    ))
+    if (!_CAN_HOME(X) && !_CAN_HOME(Y) && !_CAN_HOME(Z)) return;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
   const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
               ? x_home_dir(active_extruder) : home_dir(axis);
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
     return;

commit daa5bbc5ebd4127db10eef99dd450313de64c457
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 17 18:45:30 2020 -0500

    Comment a motion function

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 021405b4a9..673eee3a92 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -341,34 +341,39 @@ void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
       if (current_position == destination) return;
 
       planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     #endif
 
     current_position = destination;
   }
 
 #endif // IS_KINEMATIC
 
+/**
+ * Do a fast or normal move to 'destination' with an optional FR.
+ *  - Move at normal speed regardless of feedrate percentage.
+ *  - Extrude the specified length regardless of flow percentage.
+ */
 void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   #if IS_KINEMATIC
     , const bool is_fast/*=false*/
   #endif
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
   #if EXTRUDERS
-     const float old_fac = planner.e_factor[active_extruder];
-     planner.e_factor[active_extruder] = 1.0f;
+    const float old_fac = planner.e_factor[active_extruder];
+    planner.e_factor[active_extruder] = 1.0f;
   #endif
 
   #if IS_KINEMATIC
     if (is_fast)
       prepare_fast_move_to_destination();
     else
   #endif
       prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;

commit 7a2cc782b406f7e89a0a61d168cc7a5d90835c06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 03:09:40 2020 -0500

    Clean up planner modifier methods

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 27e3fa125d..021405b4a9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -214,25 +214,21 @@ inline void report_logical_position(const xyze_pos_t &rpos) {
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = cartes;
   npos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
-    planner.unapply_modifiers(npos
-      #if HAS_LEVELING
-        , true
-      #endif
-    );
+    planner.unapply_modifiers(npos, true);
   #endif
 
   report_logical_position(npos);
   report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
 void report_current_position() {
   report_logical_position(current_position);
   report_more_positions();
@@ -297,25 +293,21 @@ void get_cartesian_from_steppers() {
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   xyze_pos_t pos = cartes;
   pos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
-    planner.unapply_modifiers(pos
-      #if HAS_LEVELING
-        , true
-      #endif
-    );
+    planner.unapply_modifiers(pos, true);
   #endif
 
   if (axis == ALL_AXES)
     current_position = pos;
   else
     current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved

commit 2a959cde6fdd5edea5c9ff20d613db024eb96749
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon May 4 12:57:12 2020 -0600

    Fix undefined/unused, Touch UI (#17874)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 04f8507031..27e3fa125d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1507,20 +1507,22 @@ void backout_to_tmc_homing_phase(const AxisEnum axis) {
       DEBUG_ECHOLNPAIR(
         "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
         " Delta:", phaseDelta, " Distance:", mmDelta
       );
     }
 
     if (mmDelta != 0) {
       // retrace by the amount computed in mmDelta.
       do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
     }
+  #else
+    UNUSED(axis);
   #endif
 }
 
 
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.
  *
  * At the end of the procedure the axis is marked as

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 94b4316fa5..04f8507031 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -632,21 +632,21 @@ void restore_feedrate_and_scaling() {
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
     if (!soft_endstops_enabled) return;
 
     #if IS_KINEMATIC
 
       if (TERN0(DELTA, !all_axes_homed())) return;
 
-      #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
+      #if BOTH(HAS_HOTEND_OFFSET, DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
       if (TERN1(IS_SCARA, TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS))) {
         const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
         if (dist_2 > delta_max_radius_2)
@@ -1280,21 +1280,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", real_fr_mm_s, "]");
     DEBUG_ECHOLNPGM(")");
   }
 
-  #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  #if ALL(HOMING_Z_WITH_PROBE, HAS_HEATED_BED, WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0)
       thermalManager.wait_for_bed_heating();
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
                 ? x_home_dir(active_extruder) : home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
@@ -1571,33 +1571,33 @@ void homeaxis(const AxisEnum axis) {
       TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
       TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
         stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
     if (axis == Z_AXIS && bltouch.deploy()) return; // The initial DEPLOY
   #endif
 
   #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
     const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
     if (((ENABLED(X_SENSORLESS) && axis == X_AXIS) || (ENABLED(Y_SENSORLESS) && axis == Y_AXIS)) && backoff[axis])
       do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
   #endif
 
   do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+  #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
   const float bump = axis_home_dir * (
     use_probe_bump ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
@@ -1606,27 +1606,27 @@ void homeaxis(const AxisEnum axis) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
     );
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
-    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
-    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    #if BOTH(HOMING_Z_WITH_PROBE, BLTOUCH)
       if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x2_endstop_adj);
         if (adj) {

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c2301aa343..94b4316fa5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -197,23 +197,21 @@ xyz_pos_t cartes;
 #if HAS_ABL_NOT_UBL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 
 inline void report_more_positions() {
   stepper.report_positions();
-  #if IS_SCARA
-    scara_report_positions();
-  #endif
+  TERN_(IS_SCARA, scara_report_positions());
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPAIR_P(X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z, SP_E_LBL, lpos.e);
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
@@ -322,23 +320,21 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
 #if EXTRUDERS
   void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s) {
-    #if HAS_FILAMENT_SENSOR
-      runout.reset();
-    #endif
+    TERN_(HAS_FILAMENT_SENSOR, runout.reset());
     current_position.e += length / planner.e_factor[active_extruder];
     line_to_current_position(fr_mm_s);
     planner.synchronize();
   }
 #endif
 
 #if IS_KINEMATIC
 
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
@@ -547,21 +543,22 @@ void restore_feedrate_and_scaling() {
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
-      , const uint8_t old_tool_index/*=0*/, const uint8_t new_tool_index/*=0*/
+      , const uint8_t old_tool_index/*=0*/
+      , const uint8_t new_tool_index/*=0*/
     #endif
   ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = _MAX(hotend_offset[1].x, X2_MAX_POS);
 
@@ -580,25 +577,21 @@ void restore_feedrate_and_scaling() {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop.min.x = X1_MIN_POS;
           soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop.min[axis] = base_min_pos(axis);
-      soft_endstop.max[axis] = (axis == Z_AXIS ? delta_height
-      #if HAS_BED_PROBE
-        - probe.offset.z
-      #endif
-      : base_max_pos(axis));
+      soft_endstop.max[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_max_pos(axis);
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
           delta_clip_start_height = soft_endstop.max[axis] - delta_safe_distance_from_top();
@@ -637,37 +630,31 @@ void restore_feedrate_and_scaling() {
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
     if (!soft_endstops_enabled) return;
 
     #if IS_KINEMATIC
 
-      #if ENABLED(DELTA)
-        if (!all_axes_homed()) return;
-      #endif
+      if (TERN0(DELTA, !all_axes_homed())) return;
 
       #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
-      if (true
-        #if IS_SCARA
-          && TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS)
-        #endif
-      ) {
+      if (TERN1(IS_SCARA, TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS))) {
         const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
         if (dist_2 > delta_max_radius_2)
           target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
       }
 
     #else
 
       if (TEST(axis_homed, X_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
           NOLESS(target.x, soft_endstop.min.x);
@@ -804,22 +791,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
     // Calculate and execute the segments
     millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
       segment_idle(next_idle_ms);
       raw += segment_distance;
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
-      ))
-        break;
+      )) break;
     }
 
     // Ensure last segment arrives at target location.
     planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     );
 
     return false; // caller will update current_position
@@ -876,22 +862,21 @@ FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
 
       // Calculate and execute the segments
       millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
         segment_idle(next_idle_ms);
         raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif
-        ))
-          break;
+        )) break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
       planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }
@@ -1083,23 +1068,21 @@ void prepare_line_to_destination() {
       #endif
 
       if (ignore_e) {
         current_position.e = destination.e;       // Behave as if the E move really took place
         planner.set_e_position_mm(destination.e); // Prevent the planner from complaining too
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
-  #if ENABLED(DUAL_X_CARRIAGE)
-    if (dual_x_carriage_unpark()) return;
-  #endif
+  if (TERN0(DUAL_X_CARRIAGE, dual_x_carriage_unpark())) return;
 
   if (
     #if UBL_SEGMENTED
       #if IS_KINEMATIC // UBL using Kinematic / Cartesian cases as a workaround for now.
         ubl.line_to_destination_segmented(MMS_SCALED(feedrate_mm_s))
       #else
         line_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
@@ -1128,35 +1111,32 @@ bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
   if ((axis_bits = axes_need_homing(axis_bits))) {
     PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
     char msg[strlen_P(home_first)+1];
     sprintf_P(msg, home_first,
       TEST(axis_bits, X_AXIS) ? "X" : "",
       TEST(axis_bits, Y_AXIS) ? "Y" : "",
       TEST(axis_bits, Z_AXIS) ? "Z" : ""
     );
     SERIAL_ECHO_START();
     SERIAL_ECHOLN(msg);
-    #if HAS_DISPLAY
-      ui.set_status(msg);
-    #endif
+    TERN_(HAS_DISPLAY, ui.set_status(msg));
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
-  #endif
+  if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS))
+    return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / float(hbd);
 }
 
 #if ENABLED(SENSORLESS_HOMING)
@@ -1217,23 +1197,21 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
 
     #if ENABLED(SPI_ENDSTOPS)
       switch (axis) {
         case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
         case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
         case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
         default: break;
       }
     #endif
 
-    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-      sg_guard_period = millis() + default_sg_guard_duration;
-    #endif
+    TERN_(IMPROVE_HOMING_RELIABILITY, sg_guard_period = millis() + default_sg_guard_duration);
 
     return stealth_states;
   }
 
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           tmc_disable_stallguard(stepperX, enable_stealth.x);
@@ -1309,41 +1287,36 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     DEBUG_ECHOLNPGM(")");
   }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0)
       thermalManager.wait_for_bed_heating();
   #endif
 
   // Only do some things when moving towards an endstop
-  const int8_t axis_home_dir =
-    #if ENABLED(DUAL_X_CARRIAGE)
-      (axis == X_AXIS) ? x_home_dir(active_extruder) :
-    #endif
-    home_dir(axis);
+  const int8_t axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
+                ? x_home_dir(active_extruder) : home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   #if ENABLED(SENSORLESS_HOMING)
     sensorless_t stealth_states;
   #endif
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
-    #if ENABLED(SENSORLESS_HOMING)
-      stealth_states = start_sensorless_homing_per_axis(axis);
-    #endif
+    TERN_(SENSORLESS_HOMING, stealth_states = start_sensorless_homing_per_axis(axis));
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
     abce_pos_t target = planner.get_axis_positions_mm();
@@ -1368,23 +1341,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
-    #if ENABLED(SENSORLESS_HOMING)
-      end_sensorless_homing_per_axis(axis, stealth_states);
-    #endif
+    TERN_(SENSORLESS_HOMING, end_sensorless_homing_per_axis(axis, stealth_states));
   }
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< do_homing_move(", axis_codes[axis], ")");
 }
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
@@ -1410,25 +1381,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS ? delta_height
-    #if HAS_BED_PROBE
-      - probe.offset.z
-    #endif
-    : base_home_pos(axis));
+    current_position[axis] = (axis == Z_AXIS) ? delta_height - TERN0(HAS_BED_PROBE, probe.offset.z) : base_home_pos(axis);
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
@@ -1438,27 +1405,23 @@ void set_axis_is_at_home(const AxisEnum axis) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    I2CPEM.homed(axis);
-  #endif
+  TERN_(I2C_POSITION_ENCODERS, I2CPEM.homed(axis));
 
-  #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
-    babystep.reset_total(axis);
-  #endif
+  TERN_(BABYSTEP_DISPLAY_TOTAL, babystep.reset_total(axis));
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
     #endif
@@ -1471,23 +1434,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
  * Set an axis' to be unhomed.
  */
 void set_axis_not_trusted(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_not_trusted(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_not_trusted(", axis_codes[axis], ")");
 
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    I2CPEM.unhomed(axis);
-  #endif
+  TERN_(I2C_POSITION_ENCODERS, I2CPEM.unhomed(axis));
 }
 
 /**
  * Move the axis back to its home_phase if set and driver is capable (TMC)
  *
  * Improves homing repeatability by homing to stepper coil's nearest absolute
  * phase position. Trinamic drivers use a stepper phase table with 1024 values
  * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
  */
 void backout_to_tmc_homing_phase(const AxisEnum axis) {
@@ -1589,45 +1550,34 @@ void homeaxis(const AxisEnum axis) {
     #if Z_SPI_SENSORLESS
       #define CAN_HOME_Z true
     #else
       #define CAN_HOME_Z _CAN_HOME(Z)
     #endif
     if (!CAN_HOME_X && !CAN_HOME_Y && !CAN_HOME_Z) return;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
-  const int axis_home_dir = (
-    #if ENABLED(DUAL_X_CARRIAGE)
-      axis == X_AXIS ? x_home_dir(active_extruder) :
-    #endif
-    home_dir(axis)
-  );
+  const int axis_home_dir = TERN0(DUAL_X_CARRIAGE, axis == X_AXIS)
+              ? x_home_dir(active_extruder) : home_dir(axis);
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && probe.deploy()) return;
-  #endif
+  if (TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && probe.deploy()))
+    return;
 
   // Set flags for X, Y, Z motor locking
   #if HAS_EXTRA_ENDSTOPS
     switch (axis) {
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        case X_AXIS:
-      #endif
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        case Y_AXIS:
-      #endif
-      #if ENABLED(Z_MULTI_ENDSTOPS)
-        case Z_AXIS:
-      #endif
-      stepper.set_separate_multi_axis(true);
+      TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
+      TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
+      TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
+        stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     if (axis == Z_AXIS && bltouch.deploy()) return; // The initial DEPLOY
   #endif
@@ -1638,25 +1588,23 @@ void homeaxis(const AxisEnum axis) {
       do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
   #endif
 
   do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
+  const bool use_probe_bump = TERN0(HOMING_Z_WITH_PROBE, axis == Z_AXIS && home_bump_mm(Z_AXIS));
   const float bump = axis_home_dir * (
-    #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS && home_bump_mm(Z_AXIS)) ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
-    #endif
-    home_bump_mm(axis)
+    use_probe_bump ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) : home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOMING_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
@@ -1796,30 +1744,24 @@ void homeaxis(const AxisEnum axis) {
             stepper.set_z4_lock(false);
           #endif
 
         #endif
       }
     #endif
 
     // Reset flags for X, Y, Z motor locking
     switch (axis) {
       default: break;
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        case X_AXIS:
-      #endif
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        case Y_AXIS:
-      #endif
-      #if ENABLED(Z_MULTI_ENDSTOPS)
-        case Z_AXIS:
-      #endif
-          stepper.set_separate_multi_axis(false);
+      TERN_(X_DUAL_ENDSTOPS, case X_AXIS:)
+      TERN_(Y_DUAL_ENDSTOPS, case Y_AXIS:)
+      TERN_(Z_MULTI_ENDSTOPS, case Z_AXIS:)
+        stepper.set_separate_multi_axis(false);
     }
   #endif
 
   // move back to homing phase if configured and capable
   backout_to_tmc_homing_phase(axis);
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     sync_plan_position();
@@ -1861,23 +1803,22 @@ void homeaxis(const AxisEnum axis) {
       current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
 
       #if ENABLED(SENSORLESS_HOMING)
         planner.synchronize();
-        #if IS_CORE
-          if (axis != NORMAL_AXIS) safe_delay(200);  // Short delay to allow belts to spring back
-        #endif
+        if (TERN0(IS_CORE, axis != NORMAL_AXIS))
+          safe_delay(200);  // Short delay to allow belts to spring back
       #endif
     }
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");

commit ccfd5c1010270493f0c7ddc7a5ab62dc5e09def3
Author: Fabio Santos <fabiosan@live.com>
Date:   Mon Apr 20 06:08:00 2020 -0700

    Trinamic steppers Homing Phase (#17299)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3c89b933d8..c2301aa343 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1476,20 +1476,94 @@ void set_axis_not_trusted(const AxisEnum axis) {
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_not_trusted(", axis_codes[axis], ")");
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.unhomed(axis);
   #endif
 }
 
+/**
+ * Move the axis back to its home_phase if set and driver is capable (TMC)
+ *
+ * Improves homing repeatability by homing to stepper coil's nearest absolute
+ * phase position. Trinamic drivers use a stepper phase table with 1024 values
+ * spanning 4 full steps with 256 positions each (ergo, 1024 positions).
+ */
+void backout_to_tmc_homing_phase(const AxisEnum axis) {
+  #ifdef TMC_HOME_PHASE
+    const abc_long_t home_phase = TMC_HOME_PHASE;
+
+    // check if home phase is disabled for this axis.
+    if (home_phase[axis] < 0) return;
+
+    int16_t axisMicrostepSize;
+    int16_t phaseCurrent;
+    bool invertDir;
+
+    switch (axis) {
+      #ifdef X_MICROSTEPS
+        case X_AXIS:
+          axisMicrostepSize = 256 / (X_MICROSTEPS);
+          phaseCurrent = stepperX.get_microstep_counter();
+          invertDir = INVERT_X_DIR;
+          break;
+      #endif
+      #ifdef Y_MICROSTEPS
+        case Y_AXIS:
+          axisMicrostepSize = 256 / (Y_MICROSTEPS);
+          phaseCurrent = stepperY.get_microstep_counter();
+          invertDir = INVERT_Y_DIR;
+          break;
+      #endif
+      #ifdef Z_MICROSTEPS
+        case Z_AXIS:
+          axisMicrostepSize = 256 / (Z_MICROSTEPS);
+          phaseCurrent = stepperZ.get_microstep_counter();
+          invertDir = INVERT_Z_DIR;
+          break;
+      #endif
+      default: return;
+    }
+
+    // Depending on invert dir measure the distance to nearest home phase.
+    int16_t phaseDelta = (invertDir ? -1 : 1) * (home_phase[axis] - phaseCurrent);
+
+    // Check if home distance within endstop assumed repeatability noise of .05mm and warn.
+    if (ABS(phaseDelta) * planner.steps_to_mm[axis] / axisMicrostepSize < 0.05f)
+      DEBUG_ECHOLNPAIR("Selected home phase ", home_phase[axis],
+                       " too close to endstop trigger phase ", phaseCurrent,
+                       ". Pick a different phase for ", axis_codes[axis]);
+
+    // Skip to next if target position is behind current. So it only moves away from endstop.
+    if (phaseDelta < 0) phaseDelta += 1024;
+
+    // Get the integer ¬µsteps to target. Unreachable phase? Consistently stop at the ¬µstep before / after based on invertDir.
+    const float mmDelta = -(int16_t(phaseDelta / axisMicrostepSize) * planner.steps_to_mm[axis] * (Z_HOME_DIR));
+
+    // optional debug messages.
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOLNPAIR(
+        "Endstop ", axis_codes[axis], " hit at Phase:", phaseCurrent,
+        " Delta:", phaseDelta, " Distance:", mmDelta
+      );
+    }
+
+    if (mmDelta != 0) {
+      // retrace by the amount computed in mmDelta.
+      do_homing_move(axis, mmDelta, get_homing_bump_feedrate(axis));
+    }
+  #endif
+}
+
+
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.
  *
  * At the end of the procedure the axis is marked as
  * homed and the current position of that axis is updated.
  * Kinematic robots should wait till all axes are homed
  * before updating the current position.
  */
@@ -1735,35 +1809,41 @@ void homeaxis(const AxisEnum axis) {
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
       #if ENABLED(Z_MULTI_ENDSTOPS)
         case Z_AXIS:
       #endif
           stepper.set_separate_multi_axis(false);
     }
   #endif
 
+  // move back to homing phase if configured and capable
+  backout_to_tmc_homing_phase(axis);
+
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
-    // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
-    if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("delta_endstop_adj:");
-      do_homing_move(axis, delta_endstop_adj[axis] - (MIN_STEPS_PER_SEGMENT + 1) * planner.steps_to_mm[axis] * Z_HOME_DIR);
+    const float adjDistance = delta_endstop_adj[axis],
+                minDistance = (MIN_STEPS_PER_SEGMENT) * planner.steps_to_mm[axis];
+
+    // Retrace by the amount specified in delta_endstop_adj if more than min steps.
+    if (adjDistance * (Z_HOME_DIR) < 0 && ABS(adjDistance) > minDistance) { // away from endstop, more than min distance
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("adjDistance:", adjDistance);
+      do_homing_move(axis, adjDistance, get_homing_bump_feedrate(axis));
     }
 
   #else // CARTESIAN / CORE
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);

commit a794538c5417a38288c1af912f305755aec46894
Author: George Fu <nailao_5918@163.com>
Date:   Wed Mar 25 16:18:48 2020 +0800

    Homing backoff enhancements
    
    - Define homing bump as an array
    - Add pre and post homing backoff options
    - Consolidate homing config options

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1cc0a04712..3c89b933d8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -67,29 +67,20 @@
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-#define XYZ_CONSTS(T, NAME, OPT) const PROGMEM XYZval<T> NAME##_P = { X_##OPT, Y_##OPT, Z_##OPT }
-
-XYZ_CONSTS(float, base_min_pos,   MIN_POS);
-XYZ_CONSTS(float, base_max_pos,   MAX_POS);
-XYZ_CONSTS(float, base_home_pos,  HOME_POS);
-XYZ_CONSTS(float, max_length,     MAX_LENGTH);
-XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
-XYZ_CONSTS(signed char, home_dir, HOME_DIR);
-
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 uint8_t axis_homed, axis_known_position; // = 0
@@ -1560,44 +1551,43 @@ void homeaxis(const AxisEnum axis) {
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     if (axis == Z_AXIS && bltouch.deploy()) return; // The initial DEPLOY
   #endif
 
-  do_homing_move(axis, 1.5f * max_length(
-    #if ENABLED(DELTA)
-      Z_AXIS
-    #else
-      axis
-    #endif
-    ) * axis_home_dir
-  );
+  #if DISABLED(DELTA) && defined(SENSORLESS_BACKOFF_MM)
+    const xy_float_t backoff = SENSORLESS_BACKOFF_MM;
+    if (((ENABLED(X_SENSORLESS) && axis == X_AXIS) || (ENABLED(Y_SENSORLESS) && axis == Y_AXIS)) && backoff[axis])
+      do_homing_move(axis, -ABS(backoff[axis]) * axis_home_dir, homing_feedrate(axis));
+  #endif
+
+  do_homing_move(axis, 1.5f * max_length(TERN(DELTA, Z_AXIS, axis)) * axis_home_dir);
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
+      (axis == Z_AXIS && home_bump_mm(Z_AXIS)) ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
-    // Move away from the endstop by the axis HOME_BUMP_MM
+    // Move away from the endstop by the axis HOMING_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
     );
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
@@ -1778,22 +1768,22 @@ void homeaxis(const AxisEnum axis) {
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && probe.stow()) return;
   #endif
 
-  #if DISABLED(DELTA) && defined(HOMING_BACKOFF_MM)
-    const xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
+  #if DISABLED(DELTA) && defined(HOMING_BACKOFF_POST_MM)
+    const xyz_float_t endstop_backoff = HOMING_BACKOFF_POST_MM;
     if (endstop_backoff[axis]) {
       current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
 
       #if ENABLED(SENSORLESS_HOMING)

commit 223aa5cc4efdab1ad987e490abe2e3020a7b211e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 17:20:01 2020 -0500

    No unscaled_e_move for CNC

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 834da3ad35..1cc0a04712 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -329,28 +329,30 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
-void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s) {
-  #if HAS_FILAMENT_SENSOR
-    runout.reset();
-  #endif
-  current_position.e += length / planner.e_factor[active_extruder];
-  line_to_current_position(fr_mm_s);
-  planner.synchronize();
-}
+#if EXTRUDERS
+  void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s) {
+    #if HAS_FILAMENT_SENSOR
+      runout.reset();
+    #endif
+    current_position.e += length / planner.e_factor[active_extruder];
+    line_to_current_position(fr_mm_s);
+    planner.synchronize();
+  }
+#endif
 
 #if IS_KINEMATIC
 
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
    */
   void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED

commit 765a9f3471b8a6b67c23f79cc6965e2f795f284a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 16:26:55 2020 -0500

    do_pause_e_move => unscaled_e_move

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e47727b3ec..834da3ad35 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -48,20 +48,24 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if HAS_DISPLAY
   #include "../lcd/ultralcd.h"
 #endif
 
+#if HAS_FILAMENT_SENSOR
+  #include "../feature/runout.h"
+#endif
+
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
@@ -325,20 +329,29 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
+void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s) {
+  #if HAS_FILAMENT_SENSOR
+    runout.reset();
+  #endif
+  current_position.e += length / planner.e_factor[active_extruder];
+  line_to_current_position(fr_mm_s);
+  planner.synchronize();
+}
+
 #if IS_KINEMATIC
 
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
    */
   void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // UBL segmented line will do Z-only moves in single segment

commit dd6781217a1571c31124cc5c331a0c39de1ce4fe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 19:21:48 2020 -0500

    motion.cpp: HAS_DIST_MM_ARG

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8ab96b9b08..e47727b3ec 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1338,27 +1338,27 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
     abce_pos_t target = planner.get_axis_positions_mm();
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
-    #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
+    #if HAS_DIST_MM_ARG
       const xyze_float_t cart_dist_mm{0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
+      #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 

commit adb6334ba031166e33f256344fc2b01e909cd99f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 17:55:36 2020 -0500

    Use "dist" instead of "delta" for clarity

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 14da9b47e0..8ab96b9b08 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1285,26 +1285,28 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
     #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0) {
 
+  const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
+
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
-      DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
+      DEBUG_ECHOPAIR("[", real_fr_mm_s, "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0)
       thermalManager.wait_for_bed_heating();
   #endif
 
   // Only do some things when moving towards an endstop
@@ -1324,41 +1326,40 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probe.set_probing_paused(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       stealth_states = start_sensorless_homing_per_axis(axis);
     #endif
   }
 
-  const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
     abce_pos_t target = planner.get_axis_positions_mm();
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
     #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-      const xyze_float_t delta_mm_cart{0};
+      const xyze_float_t cart_dist_mm{0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target
       #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , delta_mm_cart
+        , cart_dist_mm
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING

commit bef9b9b07e90b5e81e900cb9d740145e8b494e6d
Author: rado79 <51396577+rado79@users.noreply.github.com>
Date:   Tue Mar 24 02:32:36 2020 +0100

    Delay after homing_backoff for CoreXY sensorless homing (#17273)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a0b59284fe..14da9b47e0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1772,20 +1772,27 @@ void homeaxis(const AxisEnum axis) {
   #if DISABLED(DELTA) && defined(HOMING_BACKOFF_MM)
     const xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
     if (endstop_backoff[axis]) {
       current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
+
+      #if ENABLED(SENSORLESS_HOMING)
+        planner.synchronize();
+        #if IS_CORE
+          if (axis != NORMAL_AXIS) safe_delay(200);  // Short delay to allow belts to spring back
+        #endif
+      #endif
     }
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
 

commit c87d73045b7bb6f05c6e7c149ac07751e7ff963f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 23 18:31:04 2020 -0500

    Fix extra M114 output line
    
    Fixes #17255

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c1d8fceaa0..a0b59284fe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -211,43 +211,46 @@ inline void report_more_positions() {
   stepper.report_positions();
   #if IS_SCARA
     scara_report_positions();
   #endif
 }
 
 // Report the logical position for a given machine position
 inline void report_logical_position(const xyze_pos_t &rpos) {
   const xyze_pos_t lpos = rpos.asLogical();
   SERIAL_ECHOPAIR_P(X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z, SP_E_LBL, lpos.e);
-  report_more_positions();
 }
 
 // Report the real current position according to the steppers.
 // Forward kinematics and un-leveling are applied.
 void report_real_position() {
   get_cartesian_from_steppers();
   xyze_pos_t npos = cartes;
   npos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
     planner.unapply_modifiers(npos
       #if HAS_LEVELING
         , true
       #endif
     );
   #endif
 
   report_logical_position(npos);
+  report_more_positions();
 }
 
 // Report the logical current position according to the most recent G-code command
-void report_current_position() { report_logical_position(current_position); }
+void report_current_position() {
+  report_logical_position(current_position);
+  report_more_positions();
+}
 
 /**
  * Report the logical current position according to the most recent G-code command.
  * The planner.position always corresponds to the last G-code too. This makes M114
  * suitable for debugging kinematics and leveling while avoiding planner sync that
  * definitively interrupts the printing flow.
  */
 void report_current_position_projected() {
   report_logical_position(current_position);
   stepper.report_a_position(planner.position);

commit 627aa8db2dcb59584a815095e4a382a556323a9c
Author: jufimu12 <jufimu12@gmail.com>
Date:   Wed Mar 11 02:00:26 2020 +0100

    Fix G34, add HOME_AFTER_G34 option (#17108)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b1c0f37909..c1d8fceaa0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1453,27 +1453,27 @@ void set_axis_is_at_home(const AxisEnum axis) {
       DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
 }
 
 /**
  * Set an axis' to be unhomed.
  */
-void set_axis_is_not_at_home(const AxisEnum axis) {
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_not_at_home(", axis_codes[axis], ")");
+void set_axis_not_trusted(const AxisEnum axis) {
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_not_trusted(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_is_not_at_home(", axis_codes[axis], ")");
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_not_trusted(", axis_codes[axis], ")");
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.unhomed(axis);
   #endif
 }
 
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.

commit 64d092935b27ff89955f0430eef5815b15e5a92d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 7 22:20:41 2020 -0600

    More useful ENABLED / DISABLED macros (#17054)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2e7a574b39..b1c0f37909 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1201,29 +1201,23 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #endif
           break;
       #endif
     }
 
     #if ENABLED(SPI_ENDSTOPS)
       switch (axis) {
-        #if X_SPI_SENSORLESS
-          case X_AXIS: endstops.tmc_spi_homing.x = true; break;
-        #endif
-        #if Y_SPI_SENSORLESS
-          case Y_AXIS: endstops.tmc_spi_homing.y = true; break;
-        #endif
-        #if Z_SPI_SENSORLESS
-          case Z_AXIS: endstops.tmc_spi_homing.z = true; break;
-        #endif
+        case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = true; break;
+        case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = true; break;
+        case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = true; break;
         default: break;
       }
     #endif
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       sg_guard_period = millis() + default_sg_guard_duration;
     #endif
 
     return stealth_states;
   }
@@ -1273,29 +1267,23 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #endif
           break;
       #endif
     }
 
     #if ENABLED(SPI_ENDSTOPS)
       switch (axis) {
-        #if X_SPI_SENSORLESS
-          case X_AXIS: endstops.tmc_spi_homing.x = false; break;
-        #endif
-        #if Y_SPI_SENSORLESS
-          case Y_AXIS: endstops.tmc_spi_homing.y = false; break;
-        #endif
-        #if Z_SPI_SENSORLESS
-          case Z_AXIS: endstops.tmc_spi_homing.z = false; break;
-        #endif
+        case X_AXIS: if (ENABLED(X_SPI_SENSORLESS)) endstops.tmc_spi_homing.x = false; break;
+        case Y_AXIS: if (ENABLED(Y_SPI_SENSORLESS)) endstops.tmc_spi_homing.y = false; break;
+        case Z_AXIS: if (ENABLED(Z_SPI_SENSORLESS)) endstops.tmc_spi_homing.z = false; break;
         default: break;
       }
     #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */

commit 7709261ea9f73d60006b5ab1ae488086908d0e79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 4 12:50:43 2020 -0600

    Move shared code to wait_for_bed_heating

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1ce225cae5..2e7a574b39 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1305,30 +1305,22 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
-    if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
-      serialprintPGM(probe.msg_wait_for_bed_heating);
-      #if HAS_DISPLAY
-        LCD_MESSAGEPGM(MSG_BED_HEATING);
-      #endif
-      thermalManager.wait_for_bed();
-      #if HAS_DISPLAY
-        ui.reset_status();
-      #endif
-    }
+    if (axis == Z_AXIS && distance < 0)
+      thermalManager.wait_for_bed_heating();
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 

commit 3a07b4412d24a6afd430f6d7e1b8c7f3c442a3c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 2 21:52:53 2020 -0600

    Asynchronous M114 and (R)ealtime position option (#17032)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ac0909fcc1..1ce225cae5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -199,31 +199,67 @@ xyz_pos_t cartes;
   xyz_pos_t workspace_offset{0};
 #endif
 
 #if HAS_ABL_NOT_UBL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
-void report_current_position() {
-  const xyz_pos_t lpos = current_position.asLogical();
-  SERIAL_ECHOPAIR("X:", lpos.x, " Y:", lpos.y, " Z:", lpos.z, " E:", current_position.e);
 
+inline void report_more_positions() {
   stepper.report_positions();
-
   #if IS_SCARA
     scara_report_positions();
   #endif
 }
 
+// Report the logical position for a given machine position
+inline void report_logical_position(const xyze_pos_t &rpos) {
+  const xyze_pos_t lpos = rpos.asLogical();
+  SERIAL_ECHOPAIR_P(X_LBL, lpos.x, SP_Y_LBL, lpos.y, SP_Z_LBL, lpos.z, SP_E_LBL, lpos.e);
+  report_more_positions();
+}
+
+// Report the real current position according to the steppers.
+// Forward kinematics and un-leveling are applied.
+void report_real_position() {
+  get_cartesian_from_steppers();
+  xyze_pos_t npos = cartes;
+  npos.e = planner.get_axis_position_mm(E_AXIS);
+
+  #if HAS_POSITION_MODIFIERS
+    planner.unapply_modifiers(npos
+      #if HAS_LEVELING
+        , true
+      #endif
+    );
+  #endif
+
+  report_logical_position(npos);
+}
+
+// Report the logical current position according to the most recent G-code command
+void report_current_position() { report_logical_position(current_position); }
+
+/**
+ * Report the logical current position according to the most recent G-code command.
+ * The planner.position always corresponds to the last G-code too. This makes M114
+ * suitable for debugging kinematics and leveling while avoiding planner sync that
+ * definitively interrupts the printing flow.
+ */
+void report_current_position_projected() {
+  report_logical_position(current_position);
+  stepper.report_a_position(planner.position);
+}
+
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   planner.set_position_mm(current_position);
 }
@@ -234,25 +270,21 @@ void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
  * Get the stepper positions in the cartes[] array.
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
-    forward_kinematics_DELTA(
-      planner.get_axis_position_mm(A_AXIS),
-      planner.get_axis_position_mm(B_AXIS),
-      planner.get_axis_position_mm(C_AXIS)
-    );
+    forward_kinematics_DELTA(planner.get_axis_positions_mm());
   #else
     #if IS_SCARA
       forward_kinematics_SCARA(
         planner.get_axis_position_degrees(A_AXIS),
         planner.get_axis_position_degrees(B_AXIS)
       );
     #else
       cartes.set(planner.get_axis_position_mm(X_AXIS), planner.get_axis_position_mm(Y_AXIS));
     #endif
     cartes.z = planner.get_axis_position_mm(Z_AXIS);
@@ -656,25 +688,25 @@ void restore_feedrate_and_scaling() {
       #endif
     }
   }
 
 #endif // HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 
 FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
   const millis_t ms = millis();
-  thermalManager.manage_heater();  // This returns immediately if not really needed.
   if (ELAPSED(ms, next_idle_ms)) {
     next_idle_ms = ms + 200UL;
-    idle();
+    return idle();
   }
+  thermalManager.manage_heater();  // Returns immediately on most calls
 }
 
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
@@ -1317,21 +1349,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
   }
 
   const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
-    abce_pos_t target = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
+    abce_pos_t target = planner.get_axis_positions_mm();
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
     #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
       const xyze_float_t delta_mm_cart{0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target

commit 5aa528781fee639183e02be2ff893f7193d87635
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 13:22:48 2020 -0600

    Fix ambiguous type
    
    Co-Authored-By: Andrew Kroll <xxxajk@gmail.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ecfb5233d2..ac0909fcc1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -615,21 +615,21 @@ void restore_feedrate_and_scaling() {
         constexpr xy_pos_t offs{0};
       #endif
 
       if (true
         #if IS_SCARA
           && TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS)
         #endif
       ) {
         const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
         if (dist_2 > delta_max_radius_2)
-          target *= delta_max_radius / SQRT(dist_2); // 200 / 300 = 0.66
+          target *= float(delta_max_radius / SQRT(dist_2)); // 200 / 300 = 0.66
       }
 
     #else
 
       if (TEST(axis_homed, X_AXIS)) {
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
           NOLESS(target.x, soft_endstop.min.x);
         #endif
         #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
           NOMORE(target.x, soft_endstop.max.x);

commit 49c5f614c6ac9326275a2daf8f771df41041f142
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 16:59:04 2020 -0600

    Minor motion style changes

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e15e955367..ecfb5233d2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -97,21 +97,21 @@ bool relative_mode; // = false;
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
- *   and expected by functions like 'prepare_move_to_destination'.
+ *   and expected by functions like 'prepare_line_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
   uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
   xyz_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
@@ -333,21 +333,21 @@ void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   #if EXTRUDERS
      const float old_fac = planner.e_factor[active_extruder];
      planner.e_factor[active_extruder] = 1.0f;
   #endif
 
   #if IS_KINEMATIC
     if (is_fast)
       prepare_fast_move_to_destination();
     else
   #endif
-      prepare_move_to_destination();
+      prepare_line_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
   #if EXTRUDERS
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
@@ -653,40 +653,50 @@ void restore_feedrate_and_scaling() {
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
         NOMORE(target.z, soft_endstop.max.z);
       #endif
     }
   }
 
 #endif // HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
+
+FORCE_INLINE void segment_idle(millis_t &next_idle_ms) {
+  const millis_t ms = millis();
+  thermalManager.manage_heater();  // This returns immediately if not really needed.
+  if (ELAPSED(ms, next_idle_ms)) {
+    next_idle_ms = ms + 200UL;
+    idle();
+  }
+}
+
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
      *
      * Longer segments result in less kinematic overhead
      * but may produce jagged lines. Try 0.5mm, 1.0mm, and 2.0mm
      * and compare the difference.
      */
     #define SCARA_MIN_SEGMENT_LENGTH 0.5f
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
-   * Called from prepare_move_to_destination as the
+   * Called from prepare_line_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    *
    * For Unified Bed Leveling (Delta or Segmented Cartesian)
    * the ubl.line_to_destination_segmented method replaces this.
    *
    * For Auto Bed Leveling (Bilinear) with SEGMENT_LEVELED_MOVES
    * this is replaced by segmented_line_to_destination below.
@@ -745,31 +755,24 @@ void restore_feedrate_and_scaling() {
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
     SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();
     //*/
 
     // Get the current position as starting point
     xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
+    millis_t next_idle_ms = millis() + 200UL;
     while (--segments) {
-
-      static millis_t next_idle_ms = millis() + 200UL;
-      thermalManager.manage_heater();  // This returns immediately if not really needed.
-      if (ELAPSED(millis(), next_idle_ms)) {
-        next_idle_ms = millis() + 200UL;
-        idle();
-      }
-
+      segment_idle(next_idle_ms);
       raw += segment_distance;
-
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       ))
         break;
     }
 
     // Ensure last segment arrives at target location.
     planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
@@ -824,27 +827,23 @@ void restore_feedrate_and_scaling() {
       #endif
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
       // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
+      millis_t next_idle_ms = millis() + 200UL;
       while (--segments) {
-        static millis_t next_idle_ms = millis() + 200UL;
-        thermalManager.manage_heater();  // This returns immediately if not really needed.
-        if (ELAPSED(millis(), next_idle_ms)) {
-          next_idle_ms = millis() + 200UL;
-          idle();
-        }
+        segment_idle(next_idle_ms);
         raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif
         ))
           break;
       }
 
       // Since segment_distance is only approximate,
@@ -859,21 +858,21 @@ void restore_feedrate_and_scaling() {
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
    * Return true if 'current_position' was set to 'destination'
    */
-  inline bool prepare_move_to_destination_cartesian() {
+  inline bool line_to_destination_cartesian() {
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
     #if HAS_MESH
       if (planner.leveling_active && planner.leveling_active_at_z(destination.z)) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
           return true;                                                        // all moves, including Z-only moves.
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(scaled_fr_mm_s);
           return false; // caller will update current_position
         #else
@@ -1002,21 +1001,21 @@ void restore_feedrate_and_scaling() {
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position.e and destination.e are good
  * before calling or cold/lengthy extrusion may get missed.
  *
  * Before exit, current_position is set to destination.
  */
-void prepare_move_to_destination() {
+void prepare_line_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN) && destination.e != current_position.e) {
       bool ignore_e = false;
 
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         ignore_e = thermalManager.tooColdToExtrude(active_extruder);
         if (ignore_e) SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
@@ -1052,26 +1051,26 @@ void prepare_move_to_destination() {
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
 
   if (
     #if UBL_SEGMENTED
       #if IS_KINEMATIC // UBL using Kinematic / Cartesian cases as a workaround for now.
         ubl.line_to_destination_segmented(MMS_SCALED(feedrate_mm_s))
       #else
-        prepare_move_to_destination_cartesian()
+        line_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
     #else
-      prepare_move_to_destination_cartesian()
+      line_to_destination_cartesian()
     #endif
   ) return;
 
   current_position = destination;
 }
 
 uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
   #if ENABLED(HOME_AFTER_DEACTIVATE)
     #define HOMED_FLAGS axis_known_position
   #else

commit edd1b76a9a4467204c3ca1bb95da3db55d062e2c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 10:41:14 2020 -0600

    Fix set_current_from_steppers_for_axis(E_AXIS) bug

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8bad4473c5..e15e955367 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -265,34 +265,35 @@ void get_cartesian_from_steppers() {
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
  * sync_plan_position after updating axes with this.
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
+  xyze_pos_t pos = cartes;
+  pos.e = planner.get_axis_position_mm(E_AXIS);
 
   #if HAS_POSITION_MODIFIERS
-    xyze_pos_t pos = { cartes.x, cartes.y, cartes.z, current_position.e };
     planner.unapply_modifiers(pos
       #if HAS_LEVELING
         , true
       #endif
     );
-    const xyze_pos_t &cartes = pos;
   #endif
+
   if (axis == ALL_AXES)
-    current_position = cartes;
+    current_position = pos;
   else
-    current_position[axis] = cartes[axis];
+    current_position[axis] = pos[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 

commit c4db8e49a7429a696431c0d3419b545d13eead31
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 10:36:15 2020 -0600

    XYZ_CHAR macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9f6cbf1b38..8bad4473c5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -580,21 +580,21 @@ void restore_feedrate_and_scaling() {
       }
 
     #else
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
   if (DEBUGGING(LEVELING))
-    SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
+    SERIAL_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
 }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
@@ -1772,21 +1772,21 @@ void homeaxis(const AxisEnum axis) {
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
 
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", axis_codes[axis], " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", XYZ_CHAR(axis), " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 84ab09b767..9f6cbf1b38 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1011,39 +1011,39 @@ void restore_feedrate_and_scaling() {
 void prepare_move_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN) && destination.e != current_position.e) {
       bool ignore_e = false;
 
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         ignore_e = thermalManager.tooColdToExtrude(active_extruder);
-        if (ignore_e) SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
+        if (ignore_e) SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
       #endif
 
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
         if (e_delta > (EXTRUDE_MAXLENGTH)) {
           #if ENABLED(MIXING_EXTRUDER)
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e) {
               if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) {
                 ignore_e = true;
-                SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+                SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
                 break;
               }
             }
           #else
             ignore_e = true;
-            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+            SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           #endif
         }
       #endif
 
       if (ignore_e) {
         current_position.e = destination.e;       // Behave as if the E move really took place
         planner.set_e_position_mm(destination.e); // Prevent the planner from complaining too
       }
     }
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4cb4d0a958..84ab09b767 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 72b4d91d2e4d645c7b77eb7eb2aec2f5461f9728
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 2 00:02:30 2020 -0600

    Add Z_AFTER_HOMING to raise Z more in G28 (#16755)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f63555d28c..4cb4d0a958 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1748,24 +1748,23 @@ void homeaxis(const AxisEnum axis) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && probe.stow()) return;
   #endif
 
   #if DISABLED(DELTA) && defined(HOMING_BACKOFF_MM)
-    constexpr xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
-    const float backoff_mm = endstop_backoff[axis];
-    if (backoff_mm) {
-      current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
+    const xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
+    if (endstop_backoff[axis]) {
+      current_position[axis] -= ABS(endstop_backoff[axis]) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
     }
   #endif
 
   // Clear retracted status if homing the Z axis

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 50092406c5..f63555d28c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -273,21 +273,21 @@ void get_cartesian_from_steppers() {
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
 
   #if HAS_POSITION_MODIFIERS
     xyze_pos_t pos = { cartes.x, cartes.y, cartes.z, current_position.e };
     planner.unapply_modifiers(pos
       #if HAS_LEVELING
         , true
       #endif
     );
-    xyze_pos_t &cartes = pos;
+    const xyze_pos_t &cartes = pos;
   #endif
   if (axis == ALL_AXES)
     current_position = cartes;
   else
     current_position[axis] = cartes[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
@@ -540,21 +540,21 @@ void restore_feedrate_and_scaling() {
           soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop.min[axis] = base_min_pos(axis);
       soft_endstop.max[axis] = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
-        - probe_offset.z
+        - probe.offset.z
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
@@ -1274,21 +1274,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
-      serialprintPGM(msg_wait_for_bed_heating);
+      serialprintPGM(probe.msg_wait_for_bed_heating);
       #if HAS_DISPLAY
         LCD_MESSAGEPGM(MSG_BED_HEATING);
       #endif
       thermalManager.wait_for_bed();
       #if HAS_DISPLAY
         ui.reset_status();
       #endif
     }
   #endif
 
@@ -1300,21 +1300,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   #if ENABLED(SENSORLESS_HOMING)
     sensorless_t stealth_states;
   #endif
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
-      if (axis == Z_AXIS) probing_pause(true);
+      if (axis == Z_AXIS) probe.set_probing_paused(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       stealth_states = start_sensorless_homing_per_axis(axis);
     #endif
   }
 
   const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
   #if IS_SCARA
@@ -1340,21 +1340,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
-      if (axis == Z_AXIS) probing_pause(false);
+      if (axis == Z_AXIS) probe.set_probing_paused(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       end_sensorless_homing_per_axis(axis, stealth_states);
     #endif
   }
 
@@ -1390,37 +1390,37 @@ void set_axis_is_at_home(const AxisEnum axis) {
       current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - probe_offset.z
+      - probe.offset.z
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
-        current_position.z -= probe_offset.z;
+        current_position.z -= probe.offset.z;
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe_offset.z = ", probe_offset.z);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe.offset.z = ", probe.offset.z);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
@@ -1502,21 +1502,21 @@ void homeaxis(const AxisEnum axis) {
 
   const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
       axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
+    if (axis == Z_AXIS && probe.deploy()) return;
   #endif
 
   // Set flags for X, Y, Z motor locking
   #if HAS_EXTRA_ENDSTOPS
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
@@ -1744,21 +1744,21 @@ void homeaxis(const AxisEnum axis) {
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && STOW_PROBE()) return;
+    if (axis == Z_AXIS && probe.stow()) return;
   #endif
 
   #if DISABLED(DELTA) && defined(HOMING_BACKOFF_MM)
     constexpr xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
     const float backoff_mm = endstop_backoff[axis];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :

commit 99b6a132bcf5ccf54215ef6962eea3e199ea4c0d
Author: chgi <chgi@users.noreply.github.com>
Date:   Thu Jan 30 18:18:45 2020 +0900

    Fix G60/G61 slots > 8 and compile error (#16715)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 6dbf940add..50092406c5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -104,21 +104,21 @@ xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
-  uint8_t saved_slots;
+  uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
   xyz_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder = 0; // = 0
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   float e_move_accumulator; // = 0

commit e2eef1256a6feaceb8f4c7f02188e8d6d6d43519
Author: Hans007a <32525735+Hans007a@users.noreply.github.com>
Date:   Tue Jan 7 20:52:19 2020 +0100

    G60/G61 Position Save/Restore (#16557)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9d0422c4a6..6dbf940add 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -102,23 +102,29 @@ bool relative_mode; // = false;
 xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
+// G60/G61 Position Save and Return
+#if SAVED_POSITIONS
+  uint8_t saved_slots;
+  xyz_pos_t stored_position[SAVED_POSITIONS];
+#endif
+
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
-  uint8_t active_extruder; // = 0
+  uint8_t active_extruder = 0; // = 0
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   float e_move_accumulator; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {

commit 44d400db83e2efe9d4544aa49f4ab8f0042ba00c
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Jan 26 01:16:03 2020 -0800

    Fix HOMING_BACKOFF_MM for DELTA (#16657)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4c1b5340df..9d0422c4a6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1741,29 +1741,23 @@ void homeaxis(const AxisEnum axis) {
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
-  #ifdef HOMING_BACKOFF_MM
+  #if DISABLED(DELTA) && defined(HOMING_BACKOFF_MM)
     constexpr xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
-    const float backoff_mm = endstop_backoff[
-      #if ENABLED(DELTA)
-        Z_AXIS
-      #else
-        axis
-      #endif
-    ];
+    const float backoff_mm = endstop_backoff[axis];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
       line_to_current_position(
         #if HOMING_Z_WITH_PROBE
           (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
         #endif
         homing_feedrate(axis)
       );
     }
   #endif

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a59e22ec8c..4c1b5340df 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1149,20 +1149,23 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           stealth_states.z = tmc_enable_stallguard(stepperZ);
           #if AXIS_HAS_STALLGUARD(Z2)
             stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
           #endif
           #if AXIS_HAS_STALLGUARD(Z3)
             stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
           #endif
+          #if AXIS_HAS_STALLGUARD(Z4)
+            stealth_states.z4 = tmc_enable_stallguard(stepperZ4);
+          #endif
           #if CORE_IS_XZ && X_SENSORLESS
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #endif
           break;
       #endif
     }
 
     #if ENABLED(SPI_ENDSTOPS)
@@ -1218,20 +1221,23 @@ feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #if AXIS_HAS_STALLGUARD(Z2)
             tmc_disable_stallguard(stepperZ2, enable_stealth.z2);
           #endif
           #if AXIS_HAS_STALLGUARD(Z3)
             tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
           #endif
+          #if AXIS_HAS_STALLGUARD(Z4)
+            tmc_disable_stallguard(stepperZ4, enable_stealth.z4);
+          #endif
           #if CORE_IS_XZ && X_SENSORLESS
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #endif
           break;
       #endif
     }
 
     #if ENABLED(SPI_ENDSTOPS)
@@ -1502,21 +1508,21 @@ void homeaxis(const AxisEnum axis) {
 
   // Set flags for X, Y, Z motor locking
   #if HAS_EXTRA_ENDSTOPS
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
-      #if Z_MULTI_ENDSTOPS
+      #if ENABLED(Z_MULTI_ENDSTOPS)
         case Z_AXIS:
       #endif
       stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
@@ -1586,91 +1592,133 @@ void homeaxis(const AxisEnum axis) {
       if (axis == Y_AXIS) {
         const float adj = ABS(endstops.y2_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.y2_endstop_adj > 0) : (endstops.y2_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_y_lock(false);
           stepper.set_y2_lock(false);
         }
       }
     #endif
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+
+    #if ENABLED(Z_MULTI_ENDSTOPS)
       if (axis == Z_AXIS) {
-        const float adj = ABS(endstops.z2_endstop_adj);
-        if (adj) {
-          if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-          do_homing_move(axis, pos_dir ? -adj : adj);
+
+        #if NUM_Z_STEPPER_DRIVERS == 2
+
+          const float adj = ABS(endstops.z2_endstop_adj);
+          if (adj) {
+            if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+            do_homing_move(axis, pos_dir ? -adj : adj);
+            stepper.set_z_lock(false);
+            stepper.set_z2_lock(false);
+          }
+
+        #else
+
+          // Handy arrays of stepper lock function pointers
+
+          typedef void (*adjustFunc_t)(const bool);
+
+          adjustFunc_t lock[] = {
+            stepper.set_z_lock, stepper.set_z2_lock, stepper.set_z3_lock
+            #if NUM_Z_STEPPER_DRIVERS >= 4
+              , stepper.set_z4_lock
+            #endif
+          };
+          float adj[] = {
+            0, endstops.z2_endstop_adj, endstops.z3_endstop_adj
+            #if NUM_Z_STEPPER_DRIVERS >= 4
+              , endstops.z4_endstop_adj
+            #endif
+          };
+
+          adjustFunc_t tempLock;
+          float tempAdj;
+
+          // Manual bubble sort by adjust value
+          if (adj[1] < adj[0]) {
+            tempLock = lock[0], tempAdj = adj[0];
+            lock[0] = lock[1], adj[0] = adj[1];
+            lock[1] = tempLock, adj[1] = tempAdj;
+          }
+          if (adj[2] < adj[1]) {
+            tempLock = lock[1], tempAdj = adj[1];
+            lock[1] = lock[2], adj[1] = adj[2];
+            lock[2] = tempLock, adj[2] = tempAdj;
+          }
+          #if NUM_Z_STEPPER_DRIVERS >= 4
+            if (adj[3] < adj[2]) {
+              tempLock = lock[2], tempAdj = adj[2];
+              lock[2] = lock[3], adj[2] = adj[3];
+              lock[3] = tempLock, adj[3] = tempAdj;
+            }
+            if (adj[2] < adj[1]) {
+              tempLock = lock[1], tempAdj = adj[1];
+              lock[1] = lock[2], adj[1] = adj[2];
+              lock[2] = tempLock, adj[2] = tempAdj;
+            }
+          #endif
+          if (adj[1] < adj[0]) {
+            tempLock = lock[0], tempAdj = adj[0];
+            lock[0] = lock[1], adj[0] = adj[1];
+            lock[1] = tempLock, adj[1] = tempAdj;
+          }
+
+          if (pos_dir) {
+            // normalize adj to smallest value and do the first move
+            (*lock[0])(true);
+            do_homing_move(axis, adj[1] - adj[0]);
+            // lock the second stepper for the final correction
+            (*lock[1])(true);
+            do_homing_move(axis, adj[2] - adj[1]);
+            #if NUM_Z_STEPPER_DRIVERS >= 4
+              // lock the third stepper for the final correction
+              (*lock[2])(true);
+              do_homing_move(axis, adj[3] - adj[2]);
+            #endif
+          }
+          else {
+            #if NUM_Z_STEPPER_DRIVERS >= 4
+              (*lock[3])(true);
+              do_homing_move(axis, adj[2] - adj[3]);
+            #endif
+            (*lock[2])(true);
+            do_homing_move(axis, adj[1] - adj[2]);
+            (*lock[1])(true);
+            do_homing_move(axis, adj[0] - adj[1]);
+          }
+
           stepper.set_z_lock(false);
           stepper.set_z2_lock(false);
-        }
-      }
-    #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS)
-      if (axis == Z_AXIS) {
-        // we push the function pointers for the stepper lock function into an array
-        void (*lock[3]) (bool)= {&stepper.set_z_lock, &stepper.set_z2_lock, &stepper.set_z3_lock};
-        float adj[3] = {0, endstops.z2_endstop_adj, endstops.z3_endstop_adj};
-
-        void (*tempLock) (bool);
-        float tempAdj;
-
-        // manual bubble sort by adjust value
-        if (adj[1] < adj[0]) {
-          tempLock = lock[0], tempAdj = adj[0];
-          lock[0] = lock[1], adj[0] = adj[1];
-          lock[1] = tempLock, adj[1] = tempAdj;
-        }
-        if (adj[2] < adj[1]) {
-          tempLock = lock[1], tempAdj = adj[1];
-          lock[1] = lock[2], adj[1] = adj[2];
-          lock[2] = tempLock, adj[2] = tempAdj;
-        }
-        if (adj[1] < adj[0]) {
-          tempLock = lock[0], tempAdj = adj[0];
-          lock[0] = lock[1], adj[0] = adj[1];
-          lock[1] = tempLock, adj[1] = tempAdj;
-        }
-
-        if (pos_dir) {
-          // normalize adj to smallest value and do the first move
-          (*lock[0])(true);
-          do_homing_move(axis, adj[1] - adj[0]);
-          // lock the second stepper for the final correction
-          (*lock[1])(true);
-          do_homing_move(axis, adj[2] - adj[1]);
-        }
-        else {
-          (*lock[2])(true);
-          do_homing_move(axis, adj[1] - adj[2]);
-          (*lock[1])(true);
-          do_homing_move(axis, adj[0] - adj[1]);
-        }
+          stepper.set_z3_lock(false);
+          #if NUM_Z_STEPPER_DRIVERS >= 4
+            stepper.set_z4_lock(false);
+          #endif
 
-        stepper.set_z_lock(false);
-        stepper.set_z2_lock(false);
-        stepper.set_z3_lock(false);
+        #endif
       }
     #endif
 
     // Reset flags for X, Y, Z motor locking
     switch (axis) {
+      default: break;
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
-      #if Z_MULTI_ENDSTOPS
+      #if ENABLED(Z_MULTI_ENDSTOPS)
         case Z_AXIS:
       #endif
-      stepper.set_separate_multi_axis(false);
-      default: break;
+          stepper.set_separate_multi_axis(false);
     }
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
   #elif ENABLED(DELTA)
 

commit fbf2f36cae1a562c6f9417fb2bb0046d2e3c18f1
Author: FlyingSamson <59110786+FlyingSamson@users.noreply.github.com>
Date:   Sun Jan 12 00:06:52 2020 +0100

    Only constrain motion on homed axes (#16533)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 395d7e9b34..a59e22ec8c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -585,59 +585,76 @@ void restore_feedrate_and_scaling() {
 }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(xyz_pos_t &target) {
 
-    if (!soft_endstops_enabled || !all_axes_homed()) return;
+    if (!soft_endstops_enabled) return;
 
     #if IS_KINEMATIC
 
+      #if ENABLED(DELTA)
+        if (!all_axes_homed()) return;
+      #endif
+
       #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
         // The effector center position will be the target minus the hotend offset.
         const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr xy_pos_t offs{0};
       #endif
 
-      const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
-      if (dist_2 > delta_max_radius_2)
-        target *= delta_max_radius / SQRT(dist_2); // 200 / 300 = 0.66
+      if (true
+        #if IS_SCARA
+          && TEST(axis_homed, X_AXIS) && TEST(axis_homed, Y_AXIS)
+        #endif
+      ) {
+        const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
+        if (dist_2 > delta_max_radius_2)
+          target *= delta_max_radius / SQRT(dist_2); // 200 / 300 = 0.66
+      }
 
     #else
 
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-        NOLESS(target.x, soft_endstop.min.x);
-      #endif
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-        NOMORE(target.x, soft_endstop.max.x);
-      #endif
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-        NOLESS(target.y, soft_endstop.min.y);
-      #endif
-      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-        NOMORE(target.y, soft_endstop.max.y);
-      #endif
+      if (TEST(axis_homed, X_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+          NOLESS(target.x, soft_endstop.min.x);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+          NOMORE(target.x, soft_endstop.max.x);
+        #endif
+      }
 
-    #endif
+      if (TEST(axis_homed, Y_AXIS)) {
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+          NOLESS(target.y, soft_endstop.min.y);
+        #endif
+        #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+          NOMORE(target.y, soft_endstop.max.y);
+        #endif
+      }
 
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-      NOLESS(target.z, soft_endstop.min.z);
-    #endif
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-      NOMORE(target.z, soft_endstop.max.z);
     #endif
+
+    if (TEST(axis_homed, Z_AXIS)) {
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+        NOLESS(target.z, soft_endstop.min.z);
+      #endif
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+        NOMORE(target.z, soft_endstop.max.z);
+      #endif
+    }
   }
 
 #endif // HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease

commit 669fe74096458c344eed83b9c4457009fef56a83
Author: ellensp <ellensp@hotmail.com>
Date:   Thu Jan 9 23:51:41 2020 +1300

    Fix compile error w/out LCD (#16502)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 484d6a077a..395d7e9b34 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1246,23 +1246,27 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
     DEBUG_ECHOLNPGM(")");
   }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
-      LCD_MESSAGEPGM(MSG_BED_HEATING);
+      #if HAS_DISPLAY
+        LCD_MESSAGEPGM(MSG_BED_HEATING);
+      #endif
       thermalManager.wait_for_bed();
-      ui.reset_status();
+      #if HAS_DISPLAY
+        ui.reset_status();
+      #endif
     }
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4230dba055..484d6a077a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -107,20 +107,24 @@ xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
  *   and expected by functions like 'prepare_move_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
 xyze_pos_t destination; // {0}
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder; // = 0
 #endif
 
+#if ENABLED(LCD_SHOW_E_TOTAL)
+  float e_move_accumulator; // = 0
+#endif
+
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       !tmp[X_AXIS][0] && !tmp[Y_AXIS][0] && !tmp[Z_AXIS][0],
       "Offsets for the first hotend must be 0.0."
     );
     // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]

commit 0f8c3ed29afd000316c1a822eaba6a0ffa242d5b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 27 17:36:33 2019 -0500

    Prevent extra "too long/cold" errors

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 74a225c909..4230dba055 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -979,46 +979,51 @@ void restore_feedrate_and_scaling() {
  * Make sure current_position.e and destination.e are good
  * before calling or cold/lengthy extrusion may get missed.
  *
  * Before exit, current_position is set to destination.
  */
 void prepare_move_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
-    if (!DEBUGGING(DRYRUN)) {
-      if (destination.e != current_position.e) {
-        #if ENABLED(PREVENT_COLD_EXTRUSION)
-          if (thermalManager.tooColdToExtrude(active_extruder)) {
-            current_position.e = destination.e; // Behave as if the move really took place, but ignore E part
-            SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
-          }
-        #endif // PREVENT_COLD_EXTRUSION
-        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
-          if (e_delta > (EXTRUDE_MAXLENGTH)) {
-            #if ENABLED(MIXING_EXTRUDER)
-              bool ignore_e = false;
-              float collector[MIXING_STEPPERS];
-              mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
-              MIXER_STEPPER_LOOP(e)
-                if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) { ignore_e = true; break; }
-            #else
-              constexpr bool ignore_e = true;
-            #endif
-            if (ignore_e) {
-              current_position.e = destination.e; // Behave as if the move really took place, but ignore E part
-              SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+    if (!DEBUGGING(DRYRUN) && destination.e != current_position.e) {
+      bool ignore_e = false;
+
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        ignore_e = thermalManager.tooColdToExtrude(active_extruder);
+        if (ignore_e) SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
+      #endif
+
+      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+        const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
+        if (e_delta > (EXTRUDE_MAXLENGTH)) {
+          #if ENABLED(MIXING_EXTRUDER)
+            float collector[MIXING_STEPPERS];
+            mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
+            MIXER_STEPPER_LOOP(e) {
+              if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) {
+                ignore_e = true;
+                SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+                break;
+              }
             }
-          }
-        #endif // PREVENT_LENGTHY_EXTRUDE
+          #else
+            ignore_e = true;
+            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+          #endif
+        }
+      #endif
+
+      if (ignore_e) {
+        current_position.e = destination.e;       // Behave as if the E move really took place
+        planner.set_e_position_mm(destination.e); // Prevent the planner from complaining too
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
 
   if (

commit 475041656c873614839d898e532d5fadf07343b0
Author: Daniel Callander <Knifa@users.noreply.github.com>
Date:   Thu Oct 24 18:20:09 2019 +0100

    Reset position_shift on G28 (#15653)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8182f23ae0..74a225c909 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1382,20 +1382,25 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.homed(axis);
   #endif
 
   #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
     babystep.reset_total(axis);
   #endif
 
+  #if HAS_POSITION_SHIFT
+    position_shift[axis] = 0;
+    update_workspace_offset(axis);
+  #endif
+
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
 }
 
 /**

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fa80565eb4..8182f23ae0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1046,22 +1046,22 @@ uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
   #endif
   // Clear test bits that are homed
   if (TEST(axis_bits, X_AXIS) && TEST(HOMED_FLAGS, X_AXIS)) CBI(axis_bits, X_AXIS);
   if (TEST(axis_bits, Y_AXIS) && TEST(HOMED_FLAGS, Y_AXIS)) CBI(axis_bits, Y_AXIS);
   if (TEST(axis_bits, Z_AXIS) && TEST(HOMED_FLAGS, Z_AXIS)) CBI(axis_bits, Z_AXIS);
   return axis_bits;
 }
 
 bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
   if ((axis_bits = axes_need_homing(axis_bits))) {
-    static const char home_first[] PROGMEM = MSG_HOME_FIRST;
-    char msg[sizeof(home_first)];
+    PGM_P home_first = GET_TEXT(MSG_HOME_FIRST);
+    char msg[strlen_P(home_first)+1];
     sprintf_P(msg, home_first,
       TEST(axis_bits, X_AXIS) ? "X" : "",
       TEST(axis_bits, Y_AXIS) ? "Y" : "",
       TEST(axis_bits, Z_AXIS) ? "Z" : ""
     );
     SERIAL_ECHO_START();
     SERIAL_ECHOLN(msg);
     #if HAS_DISPLAY
       ui.set_status(msg);
     #endif

commit c0005e939cf9c1d9db16f20e605c3228bc41a758
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 8 19:42:18 2019 -0500

    Enable junction deviation by default (#15481)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7d9e2fcda7..fa80565eb4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1280,27 +1280,27 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
     abce_pos_t target = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
-    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+    #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
       const xyze_float_t delta_mm_cart{0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , delta_mm_cart
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 

commit 211ff674405d1291a177d071fb40f3da8c13c93c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 6 23:58:19 2019 -0500

    Patch blocking and manual moves

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1abc5692c6..7d9e2fcda7 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -423,32 +423,51 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
       current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
+
+void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+  do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
+}
+void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+}
+void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+}
+
 void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position.y, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position.x, ry, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position.x, current_position.y, rz, fr_mm_s);
+  do_blocking_move_to_xy_z(current_position, rz, fr_mm_s);
 }
+
 void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
+void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s/*=0.0f*/) {
+  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
+}
+
+void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s/*=0.0f*/) {
+  do_blocking_move_to(raw.x, raw.y, z, fr_mm_s);
+}
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 95b99d8d3b..1abc5692c6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -337,22 +337,22 @@ void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
     planner.e_factor[active_extruder] = old_fac;
   #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s/*=0.0*/) {
   if (DEBUGGING(LEVELING)) DEBUG_XYZ(">>> do_blocking_move_to", rx, ry, rz);
 
-  const feedRate_t z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
-                  xy_feedrate = fr_mm_s ? fr_mm_s : feedRate_t(XY_PROBE_FEEDRATE_MM_S);
+  const feedRate_t z_feedrate = fr_mm_s ?: homing_feedrate(Z_AXIS),
+                  xy_feedrate = fr_mm_s ?: feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     destination = current_position;          // sync destination at the start
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
@@ -1248,21 +1248,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       stealth_states = start_sensorless_homing_per_axis(axis);
     #endif
   }
 
-  const feedRate_t real_fr_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(axis);
+  const feedRate_t real_fr_mm_s = fr_mm_s ?: homing_feedrate(axis);
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
     abce_pos_t target = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
     target[axis] = 0;
     planner.set_machine_position_mm(target);

commit 4564ad292048e3aae530d693304b589dd2905e6e
Author: Frederik Kemner <stuff+github@fredo.org>
Date:   Sun Sep 29 11:32:24 2019 +0200

    Fix build if EXTRUDERS = 0 (#15417)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e93f4f5281..95b99d8d3b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -312,33 +312,37 @@ void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   #if IS_KINEMATIC
     , const bool is_fast/*=false*/
   #endif
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
   if (fr_mm_s) feedrate_mm_s = fr_mm_s;
 
   const uint16_t old_pct = feedrate_percentage;
   feedrate_percentage = 100;
 
-  const float old_fac = planner.e_factor[active_extruder];
-  planner.e_factor[active_extruder] = 1.0f;
+  #if EXTRUDERS
+     const float old_fac = planner.e_factor[active_extruder];
+     planner.e_factor[active_extruder] = 1.0f;
+  #endif
 
   #if IS_KINEMATIC
     if (is_fast)
       prepare_fast_move_to_destination();
     else
   #endif
       prepare_move_to_destination();
 
   feedrate_mm_s = old_feedrate;
   feedrate_percentage = old_pct;
-  planner.e_factor[active_extruder] = old_fac;
+  #if EXTRUDERS
+    planner.e_factor[active_extruder] = old_fac;
+  #endif
 }
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s/*=0.0*/) {
   if (DEBUGGING(LEVELING)) DEBUG_XYZ(">>> do_blocking_move_to", rx, ry, rz);
 
   const feedRate_t z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ? fr_mm_s : feedRate_t(XY_PROBE_FEEDRATE_MM_S);

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e2351150b1..e93f4f5281 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -63,21 +63,21 @@
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
   #include "../feature/babystep.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-#define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
+#define XYZ_CONSTS(T, NAME, OPT) const PROGMEM XYZval<T> NAME##_P = { X_##OPT, Y_##OPT, Z_##OPT }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 /**
  * axis_homed
@@ -92,47 +92,48 @@ uint8_t axis_homed, axis_known_position; // = 0
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
-float current_position[XYZE] = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
+xyze_pos_t current_position = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   G-codes can set destination using 'get_destination_from_command'
  */
-float destination[XYZE]; // = { 0 }
+xyze_pos_t destination; // {0}
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
-  float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
+  xyz_pos_t hotend_offset[HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
-      tmp[X_AXIS][0] == 0 && tmp[Y_AXIS][0] == 0 && tmp[Z_AXIS][0] == 0,
+      !tmp[X_AXIS][0] && !tmp[Y_AXIS][0] && !tmp[Z_AXIS][0],
       "Offsets for the first hotend must be 0.0."
     );
-    LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp[i][e];
+    // Transpose from [XYZ][HOTENDS] to [HOTENDS][XYZ]
+    HOTEND_LOOP() LOOP_XYZ(a) hotend_offset[e][a] = tmp[a][e];
     #if ENABLED(DUAL_X_CARRIAGE)
-      hotend_offset[X_AXIS][1] = _MAX(X2_HOME_POS, X2_MAX_POS);
+      hotend_offset[1].x = _MAX(X2_HOME_POS, X2_MAX_POS);
     #endif
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
 int16_t feedrate_percentage = 100;
@@ -141,92 +142,90 @@ int16_t feedrate_percentage = 100;
 const feedRate_t homing_feedrate_mm_s[XYZ] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z)
 };
 
 // Cartesian conversion result goes here:
-float cartes[XYZ];
+xyz_pos_t cartes;
 
 #if IS_KINEMATIC
 
-  float delta[ABC];
+  abc_pos_t delta;
 
   #if HAS_SCARA_OFFSET
-    float scara_home_offset[ABC];
+    abc_pos_t scara_home_offset;
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS
     float delta_max_radius, delta_max_radius_2;
   #elif IS_SCARA
     constexpr float delta_max_radius = SCARA_PRINTABLE_RADIUS,
                     delta_max_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
   #else // DELTA
     constexpr float delta_max_radius = DELTA_PRINTABLE_RADIUS,
                     delta_max_radius_2 = sq(DELTA_PRINTABLE_RADIUS);
   #endif
 
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
 #if HAS_POSITION_SHIFT
   // The distance that XYZ has been offset by G92. Reset by G28.
-  float position_shift[XYZ] = { 0 };
+  xyz_pos_t position_shift{0};
 #endif
 #if HAS_HOME_OFFSET
   // This offset is added to the configured home position.
   // Set by M206, M428, or menu item. Saved to EEPROM.
-  float home_offset[XYZ] = { 0 };
+  xyz_pos_t home_offset{0};
 #endif
 #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   // The above two are combined to save on computes
-  float workspace_offset[XYZ] = { 0 };
+  xyz_pos_t workspace_offset{0};
 #endif
 
 #if HAS_ABL_NOT_UBL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
-  SERIAL_ECHOPAIR("X:", LOGICAL_X_POSITION(current_position[X_AXIS]));
-  SERIAL_ECHOPAIR(" Y:", LOGICAL_Y_POSITION(current_position[Y_AXIS]));
-  SERIAL_ECHOPAIR(" Z:", LOGICAL_Z_POSITION(current_position[Z_AXIS]));
-  SERIAL_ECHOPAIR(" E:", current_position[E_AXIS]);
+  const xyz_pos_t lpos = current_position.asLogical();
+  SERIAL_ECHOPAIR("X:", lpos.x, " Y:", lpos.y, " Z:", lpos.z, " E:", current_position.e);
 
   stepper.report_positions();
 
   #if IS_SCARA
     scara_report_positions();
   #endif
 }
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
-  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+  planner.set_position_mm(current_position);
 }
 
-void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
+void sync_plan_position_e() { planner.set_e_position_mm(current_position.e); }
 
 /**
  * Get the stepper positions in the cartes[] array.
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
@@ -237,52 +236,51 @@ void get_cartesian_from_steppers() {
       planner.get_axis_position_mm(B_AXIS),
       planner.get_axis_position_mm(C_AXIS)
     );
   #else
     #if IS_SCARA
       forward_kinematics_SCARA(
         planner.get_axis_position_degrees(A_AXIS),
         planner.get_axis_position_degrees(B_AXIS)
       );
     #else
-      cartes[X_AXIS] = planner.get_axis_position_mm(X_AXIS);
-      cartes[Y_AXIS] = planner.get_axis_position_mm(Y_AXIS);
+      cartes.set(planner.get_axis_position_mm(X_AXIS), planner.get_axis_position_mm(Y_AXIS));
     #endif
-    cartes[Z_AXIS] = planner.get_axis_position_mm(Z_AXIS);
+    cartes.z = planner.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
  * sync_plan_position after updating axes with this.
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
 
   #if HAS_POSITION_MODIFIERS
-    float pos[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], current_position[E_AXIS] };
+    xyze_pos_t pos = { cartes.x, cartes.y, cartes.z, current_position.e };
     planner.unapply_modifiers(pos
       #if HAS_LEVELING
         , true
       #endif
     );
-    const float (&cartes)[XYZE] = pos;
+    xyze_pos_t &cartes = pos;
   #endif
   if (axis == ALL_AXES)
-    COPY(current_position, cartes);
+    current_position = cartes;
   else
     current_position[axis] = cartes[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   planner.buffer_line(current_position, fr_mm_s, active_extruder);
@@ -293,30 +291,26 @@ void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
   /**
    * Buffer a fast move without interpolation. Set current_position to destination
    */
   void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // UBL segmented line will do Z-only moves in single segment
       ubl.line_to_destination_segmented(scaled_fr_mm_s);
     #else
-      if ( current_position[X_AXIS] == destination[X_AXIS]
-        && current_position[Y_AXIS] == destination[Y_AXIS]
-        && current_position[Z_AXIS] == destination[Z_AXIS]
-        && current_position[E_AXIS] == destination[E_AXIS]
-      ) return;
+      if (current_position == destination) return;
 
       planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     #endif
 
-    set_current_from_destination();
+    current_position = destination;
   }
 
 #endif // IS_KINEMATIC
 
 void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
   #if IS_KINEMATIC
     , const bool is_fast/*=false*/
   #endif
 ) {
   const feedRate_t old_feedrate = feedrate_mm_s;
@@ -348,113 +342,108 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
 
   const feedRate_t z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
                   xy_feedrate = fr_mm_s ? fr_mm_s : feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
-    set_destination_from_current();          // sync destination at the start
+    destination = current_position;          // sync destination at the start
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
+    if (DEBUGGING(LEVELING)) DEBUG_POS("destination = current_position", destination);
 
     // when in the danger zone
-    if (current_position[Z_AXIS] > delta_clip_start_height) {
-      if (rz > delta_clip_start_height) {                     // staying in the danger zone
-        destination[X_AXIS] = rx;                             // move directly (uninterpolated)
-        destination[Y_AXIS] = ry;
-        destination[Z_AXIS] = rz;
-        prepare_internal_fast_move_to_destination();          // set_current_from_destination()
+    if (current_position.z > delta_clip_start_height) {
+      if (rz > delta_clip_start_height) {   // staying in the danger zone
+        destination.set(rx, ry, rz);        // move directly (uninterpolated)
+        prepare_internal_fast_move_to_destination();          // set current_position from destination
         if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
-      destination[Z_AXIS] = delta_clip_start_height;
-      prepare_internal_fast_move_to_destination();            // set_current_from_destination()
+      destination.z = delta_clip_start_height;
+      prepare_internal_fast_move_to_destination();            // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
-    if (rz > current_position[Z_AXIS]) {                      // raising?
-      destination[Z_AXIS] = rz;
-      prepare_internal_fast_move_to_destination(z_feedrate);  // set_current_from_destination()
+    if (rz > current_position.z) {                            // raising?
+      destination.z = rz;
+      prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
     }
 
-    destination[X_AXIS] = rx;
-    destination[Y_AXIS] = ry;
-    prepare_internal_move_to_destination();                   // set_current_from_destination()
+    destination.set(rx, ry);
+    prepare_internal_move_to_destination();                   // set current_position from destination
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
-    if (rz < current_position[Z_AXIS]) {                      // lowering?
-      destination[Z_AXIS] = rz;
-      prepare_fast_move_to_destination(z_feedrate);           // set_current_from_destination()
+    if (rz < current_position.z) {                            // lowering?
+      destination.z = rz;
+      prepare_internal_fast_move_to_destination(z_feedrate);  // set current_position from destination
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
     if (!position_is_reachable(rx, ry)) return;
 
-    set_destination_from_current();
+    destination = current_position;
 
     // If Z needs to raise, do it before moving XY
-    if (destination[Z_AXIS] < rz) {
-      destination[Z_AXIS] = rz;
+    if (destination.z < rz) {
+      destination.z = rz;
       prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
-    destination[X_AXIS] = rx;
-    destination[Y_AXIS] = ry;
+    destination.set(rx, ry);
     prepare_internal_fast_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
-    if (destination[Z_AXIS] > rz) {
-      destination[Z_AXIS] = rz;
+    if (destination.z > rz) {
+      destination.z = rz;
       prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
   #else
 
     // If Z needs to raise, do it before moving XY
-    if (current_position[Z_AXIS] < rz) {
-      current_position[Z_AXIS] = rz;
+    if (current_position.z < rz) {
+      current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
-    current_position[X_AXIS] = rx;
-    current_position[Y_AXIS] = ry;
+    current_position.set(rx, ry);
     line_to_current_position(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
-    if (current_position[Z_AXIS] > rz) {
-      current_position[Z_AXIS] = rz;
+    if (current_position.z > rz) {
+      current_position.z = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
+  do_blocking_move_to(rx, current_position.y, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position[X_AXIS], ry, current_position[Z_AXIS], fr_mm_s);
+  do_blocking_move_to(current_position.x, ry, current_position.z, fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
+  do_blocking_move_to(current_position.x, current_position.y, rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
+  do_blocking_move_to(rx, ry, current_position.z, fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
@@ -467,21 +456,24 @@ void remember_feedrate_scaling_off() {
 void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   bool soft_endstops_enabled = true;
 
   // Software Endstops are based on the configured limits.
-  axis_limits_t soft_endstop[XYZ] = { { X_MIN_BED, X_MAX_BED }, { Y_MIN_BED, Y_MAX_BED }, { Z_MIN_POS, Z_MAX_POS } };
+  axis_limits_t soft_endstop = {
+    { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
+    { X_MAX_POS, Y_MAX_POS, Z_MAX_POS }
+  };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
@@ -489,138 +481,135 @@ void restore_feedrate_and_scaling() {
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index/*=0*/, const uint8_t new_tool_index/*=0*/
     #endif
   ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
-        const float dual_max_x = _MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
+        const float dual_max_x = _MAX(hotend_offset[1].x, X2_MAX_POS);
 
         if (new_tool_index != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
-          soft_endstop[X_AXIS].min = X2_MIN_POS;
-          soft_endstop[X_AXIS].max = dual_max_x;
+          soft_endstop.min.x = X2_MIN_POS;
+          soft_endstop.max.x = dual_max_x;
         }
         else if (dxc_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
-          soft_endstop[X_AXIS].min = X1_MIN_POS;
-          soft_endstop[X_AXIS].max = _MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
+          soft_endstop.min.x = X1_MIN_POS;
+          soft_endstop.max.x = _MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
-          soft_endstop[X_AXIS].min = X1_MIN_POS;
-          soft_endstop[X_AXIS].max = X1_MAX_POS;
+          soft_endstop.min.x = X1_MIN_POS;
+          soft_endstop.max.x = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
-      soft_endstop[axis].min = base_min_pos(axis);
-      soft_endstop[axis].max = (axis == Z_AXIS ? delta_height
+      soft_endstop.min[axis] = base_min_pos(axis);
+      soft_endstop.max[axis] = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
-        - probe_offset[Z_AXIS]
+        - probe_offset.z
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
-          delta_max_radius = _MIN(ABS(_MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
+          delta_max_radius = _MIN(ABS(_MAX(soft_endstop.min.x, soft_endstop.min.y)), soft_endstop.max.x, soft_endstop.max.y);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
-          delta_clip_start_height = soft_endstop[axis].max - delta_safe_distance_from_top();
+          delta_clip_start_height = soft_endstop.max[axis] - delta_safe_distance_from_top();
         default: break;
       }
 
     #elif HAS_HOTEND_OFFSET
 
       // Software endstops are relative to the tool 0 workspace, so
       // the movement limits must be shifted by the tool offset to
       // retain the same physical limit when other tools are selected.
       if (old_tool_index != new_tool_index) {
-        const float offs = hotend_offset[axis][new_tool_index] - hotend_offset[axis][old_tool_index];
-        soft_endstop[axis].min += offs;
-        soft_endstop[axis].max += offs;
+        const float offs = hotend_offset[new_tool_index][axis] - hotend_offset[old_tool_index][axis];
+        soft_endstop.min[axis] += offs;
+        soft_endstop.max[axis] += offs;
       }
       else {
-        const float offs = hotend_offset[axis][active_extruder];
-        soft_endstop[axis].min = base_min_pos(axis) + offs;
-        soft_endstop[axis].max = base_max_pos(axis) + offs;
+        const float offs = hotend_offset[active_extruder][axis];
+        soft_endstop.min[axis] = base_min_pos(axis) + offs;
+        soft_endstop.max[axis] = base_max_pos(axis) + offs;
       }
 
     #else
 
-      soft_endstop[axis].min = base_min_pos(axis);
-      soft_endstop[axis].max = base_max_pos(axis);
+      soft_endstop.min[axis] = base_min_pos(axis);
+      soft_endstop.max[axis] = base_max_pos(axis);
 
     #endif
 
   if (DEBUGGING(LEVELING))
-    SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop[axis].min, " max:", soft_endstop[axis].max);
+    SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop.min[axis], " max:", soft_endstop.max[axis]);
 }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
-  void apply_motion_limits(float target[XYZ]) {
+  void apply_motion_limits(xyz_pos_t &target) {
 
     if (!soft_endstops_enabled || !all_axes_homed()) return;
 
     #if IS_KINEMATIC
 
       #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
         // The effector center position will be the target minus the hotend offset.
-        const float offx = hotend_offset[X_AXIS][active_extruder], offy = hotend_offset[Y_AXIS][active_extruder];
+        const xy_pos_t offs = hotend_offset[active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
-        constexpr float offx = 0, offy = 0;
+        constexpr xy_pos_t offs{0};
       #endif
 
-      const float dist_2 = HYPOT2(target[X_AXIS] - offx, target[Y_AXIS] - offy);
-      if (dist_2 > delta_max_radius_2) {
-        const float ratio = (delta_max_radius) / SQRT(dist_2); // 200 / 300 = 0.66
-        target[X_AXIS] *= ratio;
-        target[Y_AXIS] *= ratio;
-      }
+      const float dist_2 = HYPOT2(target.x - offs.x, target.y - offs.y);
+      if (dist_2 > delta_max_radius_2)
+        target *= delta_max_radius / SQRT(dist_2); // 200 / 300 = 0.66
 
     #else
 
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-        NOLESS(target[X_AXIS], soft_endstop[X_AXIS].min);
+        NOLESS(target.x, soft_endstop.min.x);
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-        NOMORE(target[X_AXIS], soft_endstop[X_AXIS].max);
+        NOMORE(target.x, soft_endstop.max.x);
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-        NOLESS(target[Y_AXIS], soft_endstop[Y_AXIS].min);
+        NOLESS(target.y, soft_endstop.min.y);
       #endif
       #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-        NOMORE(target[Y_AXIS], soft_endstop[Y_AXIS].max);
+        NOMORE(target.y, soft_endstop.max.y);
       #endif
 
     #endif
 
     #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-      NOLESS(target[Z_AXIS], soft_endstop[Z_AXIS].min);
+      NOLESS(target.z, soft_endstop.min.z);
     #endif
     #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-      NOMORE(target[Z_AXIS], soft_endstop[Z_AXIS].max);
+      NOMORE(target.z, soft_endstop.max.z);
     #endif
   }
 
 #endif // HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
@@ -649,41 +638,36 @@ void restore_feedrate_and_scaling() {
    * the ubl.line_to_destination_segmented method replaces this.
    *
    * For Auto Bed Leveling (Bilinear) with SEGMENT_LEVELED_MOVES
    * this is replaced by segmented_line_to_destination below.
    */
   inline bool line_to_destination_kinematic() {
 
     // Get the top feedrate of the move in the XY plane
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-    const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
-                ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
+    const xyze_float_t diff = destination - current_position;
 
     // If the move is only in Z/E don't split up the move
-    if (!xdiff && !ydiff) {
+    if (!diff.x && !diff.y) {
       planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
-    if (!position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) return true;
-
-    // Remaining cartesian distances
-    const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
-                ediff = destination[E_AXIS] - current_position[E_AXIS];
+    if (!position_is_reachable(destination)) return true;
 
     // Get the linear distance in XYZ
-    float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
+    float cartesian_mm = diff.magnitude();
 
     // If the move is very short, check the E move distance
-    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
+    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / scaled_fr_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
@@ -691,55 +675,49 @@ void restore_feedrate_and_scaling() {
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments),
-                segment_distance[XYZE] = {
-                  xdiff * inv_segments,
-                  ydiff * inv_segments,
-                  zdiff * inv_segments,
-                  ediff * inv_segments
-                },
                 cartesian_segment_mm = cartesian_mm * inv_segments;
+    const xyze_float_t segment_distance = diff * inv_segments;
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
     #endif
 
     /*
     SERIAL_ECHOPAIR("mm=", cartesian_mm);
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
     SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();
     //*/
 
     // Get the current position as starting point
-    float raw[XYZE];
-    COPY(raw, current_position);
+    xyze_pos_t raw = current_position;
 
     // Calculate and execute the segments
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
-      LOOP_XYZE(i) raw[i] += segment_distance[i];
+      raw += segment_distance;
 
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       ))
         break;
     }
 
     // Ensure last segment arrives at target location.
@@ -758,76 +736,65 @@ void restore_feedrate_and_scaling() {
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
      *
      * This calls planner.buffer_line several times, adding
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
     inline void segmented_line_to_destination(const feedRate_t &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
-      const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
-                  ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
+      const xyze_float_t diff = destination - current_position;
 
       // If the move is only in Z/E don't split up the move
-      if (!xdiff && !ydiff) {
+      if (!diff.x && !diff.y) {
         planner.buffer_line(destination, fr_mm_s, active_extruder);
         return;
       }
 
-      // Remaining cartesian distances
-      const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
-                  ediff = destination[E_AXIS] - current_position[E_AXIS];
-
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
-      float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
-      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
+      float cartesian_mm = diff.magnitude();
+      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(diff.e);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments),
-                  cartesian_segment_mm = cartesian_mm * inv_segments,
-                  segment_distance[XYZE] = {
-                    xdiff * inv_segments,
-                    ydiff * inv_segments,
-                    zdiff * inv_segments,
-                    ediff * inv_segments
-                  };
+                  cartesian_segment_mm = cartesian_mm * inv_segments;
+      const xyze_float_t segment_distance = diff * inv_segments;
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
       #endif
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
       // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
-      float raw[XYZE];
-      COPY(raw, current_position);
+      xyze_pos_t raw = current_position;
 
       // Calculate and execute the segments
       while (--segments) {
         static millis_t next_idle_ms = millis() + 200UL;
         thermalManager.manage_heater();  // This returns immediately if not really needed.
         if (ELAPSED(millis(), next_idle_ms)) {
           next_idle_ms = millis() + 200UL;
           idle();
         }
-        LOOP_XYZE(i) raw[i] += segment_distance[i];
+        raw += segment_distance;
         if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif
         ))
           break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
@@ -839,38 +806,38 @@ void restore_feedrate_and_scaling() {
     }
 
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
-   * Returns true if current_position[] was set to destination[]
+   * Return true if 'current_position' was set to 'destination'
    */
   inline bool prepare_move_to_destination_cartesian() {
     const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
     #if HAS_MESH
-      if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
+      if (planner.leveling_active && planner.leveling_active_at_z(destination.z)) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
           return true;                                                        // all moves, including Z-only moves.
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(scaled_fr_mm_s);
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
-          if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
+          if (xy_pos_t(current_position) != xy_pos_t(destination)) {
             #if ENABLED(MESH_BED_LEVELING)
               mbl.line_to_destination(scaled_fr_mm_s);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(scaled_fr_mm_s);
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
@@ -887,91 +854,90 @@ void restore_feedrate_and_scaling() {
        mirrored_duplication_mode;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     uint8_t duplication_e_mask; // = 0
   #endif
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
-        raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
+  xyz_pos_t raised_parked_position;                                       // used in mode 1
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
   int16_t duplicate_extruder_temp_offset = 0;                             // used in mode 2
 
   float x_home_pos(const int extruder) {
     if (extruder == 0)
       return base_home_pos(X_AXIS);
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
-      return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
+      return hotend_offset[1].x > 0 ? hotend_offset[1].x : X2_HOME_POS;
   }
 
   /**
    * Prepare a linear move in a dual X axis setup
    *
    * Return true if current_position[] was set to destination[]
    */
   inline bool dual_x_carriage_unpark() {
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
           break;
         case DXC_AUTO_PARK_MODE:
-          if (current_position[E_AXIS] == destination[E_AXIS]) {
+          if (current_position.e == destination.e) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
-              set_current_from_destination();
-              NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
+              current_position = destination;
+              NOLESS(raised_parked_position.z, destination.z);
               delayed_move_time = millis();
               return true;
             }
           }
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
 
-            #define CUR_X    current_position[X_AXIS]
-            #define CUR_Y    current_position[Y_AXIS]
-            #define CUR_Z    current_position[Z_AXIS]
-            #define CUR_E    current_position[E_AXIS]
-            #define RAISED_X raised_parked_position[X_AXIS]
-            #define RAISED_Y raised_parked_position[Y_AXIS]
-            #define RAISED_Z raised_parked_position[Z_AXIS]
+            #define CUR_X    current_position.x
+            #define CUR_Y    current_position.y
+            #define CUR_Z    current_position.z
+            #define CUR_E    current_position.e
+            #define RAISED_X raised_parked_position.x
+            #define RAISED_Y raised_parked_position.y
+            #define RAISED_Z raised_parked_position.z
 
             if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder))
               if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
-                  planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+                  line_to_current_position(planner.settings.max_feedrate_mm_s[Z_AXIS]);
           delayed_move_time = 0;
           active_extruder_parked = false;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Clear active_extruder_parked");
           break;
         case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x_pos, " ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
+            xyze_pos_t new_pos = current_position;
+            if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
+              new_pos.x += duplicate_extruder_x_offset;
+            else
+              new_pos.x = inactive_extruder_x_pos;
             // move duplicate extruder into correct duplication position.
-            planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-
-            if (!planner.buffer_line(
-                dual_x_carriage_mode == DXC_DUPLICATION_MODE ? duplicate_extruder_x_offset + current_position[X_AXIS] : inactive_extruder_x_pos,
-                current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
-                planner.settings.max_feedrate_mm_s[X_AXIS], 1
-              )
-            ) break;
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x_pos, " ... Line to X", new_pos.x);
+            planner.set_position_mm(inactive_extruder_x_pos, current_position.y, current_position.z, current_position.e);
+            if (!planner.buffer_line(new_pos, planner.settings.max_feedrate_mm_s[X_AXIS], 1)) break;
             planner.synchronize();
             sync_plan_position();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
           }
           else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Active extruder not 0");
           break;
       }
     }
@@ -980,52 +946,52 @@ void restore_feedrate_and_scaling() {
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
- * Make sure current_position[E] and destination[E] are good
+ * Make sure current_position.e and destination.e are good
  * before calling or cold/lengthy extrusion may get missed.
  *
  * Before exit, current_position is set to destination.
  */
 void prepare_move_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
-      if (destination[E_AXIS] != current_position[E_AXIS]) {
+      if (destination.e != current_position.e) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
-            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            current_position.e = destination.e; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          const float e_delta = ABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder];
+          const float e_delta = ABS(destination.e - current_position.e) * planner.e_factor[active_extruder];
           if (e_delta > (EXTRUDE_MAXLENGTH)) {
             #if ENABLED(MIXING_EXTRUDER)
               bool ignore_e = false;
               float collector[MIXING_STEPPERS];
               mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
               MIXER_STEPPER_LOOP(e)
                 if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) { ignore_e = true; break; }
             #else
               constexpr bool ignore_e = true;
             #endif
             if (ignore_e) {
-              current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+              current_position.e = destination.e; // Behave as if the move really took place, but ignore E part
               SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
             }
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
@@ -1039,21 +1005,21 @@ void prepare_move_to_destination() {
       #else
         prepare_move_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
       line_to_destination_kinematic()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
-  set_current_from_destination();
+  current_position = destination;
 }
 
 uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
   #if ENABLED(HOME_AFTER_DEACTIVATE)
     #define HOMED_FLAGS axis_known_position
   #else
     #define HOMED_FLAGS axis_homed
   #endif
   // Clear test bits that are homed
   if (TEST(axis_bits, X_AXIS) && TEST(HOMED_FLAGS, X_AXIS)) CBI(axis_bits, X_AXIS);
@@ -1286,27 +1252,27 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
   }
 
   const feedRate_t real_fr_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(axis);
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     line_to_current_position(real_fr_mm_s);
   #else
-    float target[ABCE] = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
+    abce_pos_t target = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
     #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-      const float delta_mm_cart[XYZE] = {0, 0, 0, 0};
+      const xyze_float_t delta_mm_cart{0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
       , real_fr_mm_s, active_extruder
     );
   #endif
@@ -1349,47 +1315,47 @@ void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", axis_codes[axis], ")");
 
   SBI(axis_known_position, axis);
   SBI(axis_homed, axis);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
-      current_position[X_AXIS] = x_home_pos(active_extruder);
+      current_position.x = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - probe_offset[Z_AXIS]
+      - probe_offset.z
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
-        current_position[Z_AXIS] -= probe_offset[Z_AXIS];
+        current_position.z -= probe_offset.z;
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe_offset[Z_AXIS] = ", probe_offset[Z_AXIS]);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe_offset.z = ", probe_offset.z);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
@@ -1670,21 +1636,21 @@ void homeaxis(const AxisEnum axis) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   #ifdef HOMING_BACKOFF_MM
-    constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
+    constexpr xyz_float_t endstop_backoff = HOMING_BACKOFF_MM;
     const float backoff_mm = endstop_backoff[
       #if ENABLED(DELTA)
         Z_AXIS
       #else
         axis
       #endif
     ];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
       line_to_current_position(

commit 81b9c7c6eeebbeb2c78df7b7b7bc635f0a7bc118
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 28 21:35:42 2019 -0500

    No motion constraint before homing
    
    Sensible approach to soft endstops before the machine is homed.
    
    Ref: https://github.com/MarlinFirmware/Marlin/pull/15027#issuecomment-533301094
    Co-Authored-By: comps <comps@nomail.dom>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 928bb65ac0..e2351150b1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -566,21 +566,21 @@ void restore_feedrate_and_scaling() {
 }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(float target[XYZ]) {
 
-    if (!soft_endstops_enabled) return;
+    if (!soft_endstops_enabled || !all_axes_homed()) return;
 
     #if IS_KINEMATIC
 
       #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
         // The effector center position will be the target minus the hotend offset.
         const float offx = hotend_offset[X_AXIS][active_extruder], offy = hotend_offset[Y_AXIS][active_extruder];
       #else
         // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
         constexpr float offx = 0, offy = 0;
       #endif

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c27d87424e..928bb65ac0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -127,26 +127,25 @@ float destination[XYZE]; // = { 0 }
     #if ENABLED(DUAL_X_CARRIAGE)
       hotend_offset[X_AXIS][1] = _MAX(X2_HOME_POS, X2_MAX_POS);
     #endif
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
-float feedrate_mm_s = MMM_TO_MMS(1500.0f);
-
+feedRate_t feedrate_mm_s = MMM_TO_MMS(1500);
 int16_t feedrate_percentage = 100;
 
 // Homing feedrate is const progmem - compare to constexpr in the header
-const float homing_feedrate_mm_s[XYZ] PROGMEM = {
+const feedRate_t homing_feedrate_mm_s[XYZ] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z)
 };
 
 // Cartesian conversion result goes here:
 float cartes[XYZ];
@@ -278,129 +277,147 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
   if (axis == ALL_AXES)
     COPY(current_position, cartes);
   else
     current_position[axis] = cartes[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position(const float &fr_mm_s/*=feedrate_mm_s*/) {
-  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s, active_extruder);
-}
-
-/**
- * Move the planner to the position stored in the destination array, which is
- * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
- */
-void buffer_line_to_destination(const float fr_mm_s) {
-  planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
+void line_to_current_position(const feedRate_t &fr_mm_s/*=feedrate_mm_s*/) {
+  planner.buffer_line(current_position, fr_mm_s, active_extruder);
 }
 
 #if IS_KINEMATIC
 
   /**
-   * Calculate delta, start a line, and set current_position to destination
+   * Buffer a fast move without interpolation. Set current_position to destination
    */
-  void prepare_uninterpolated_move_to_destination(const float &fr_mm_s/*=0.0*/) {
-    if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
+  void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s/*=MMS_SCALED(feedrate_mm_s)*/) {
+    if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_fast_move_to_destination", destination);
 
     #if UBL_SEGMENTED
-      // ubl segmented line will do z-only moves in single segment
-      ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
+      // UBL segmented line will do Z-only moves in single segment
+      ubl.line_to_destination_segmented(scaled_fr_mm_s);
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
 
-      planner.buffer_line(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
+      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     #endif
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
+void _internal_move_to_destination(const feedRate_t &fr_mm_s/*=0.0f*/
+  #if IS_KINEMATIC
+    , const bool is_fast/*=false*/
+  #endif
+) {
+  const feedRate_t old_feedrate = feedrate_mm_s;
+  if (fr_mm_s) feedrate_mm_s = fr_mm_s;
+
+  const uint16_t old_pct = feedrate_percentage;
+  feedrate_percentage = 100;
+
+  const float old_fac = planner.e_factor[active_extruder];
+  planner.e_factor[active_extruder] = 1.0f;
+
+  #if IS_KINEMATIC
+    if (is_fast)
+      prepare_fast_move_to_destination();
+    else
+  #endif
+      prepare_move_to_destination();
+
+  feedrate_mm_s = old_feedrate;
+  feedrate_percentage = old_pct;
+  planner.e_factor[active_extruder] = old_fac;
+}
+
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s/*=0.0*/) {
   if (DEBUGGING(LEVELING)) DEBUG_XYZ(">>> do_blocking_move_to", rx, ry, rz);
 
-  const float z_feedrate  = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
-              xy_feedrate = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+  const feedRate_t z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
+                  xy_feedrate = fr_mm_s ? fr_mm_s : feedRate_t(XY_PROBE_FEEDRATE_MM_S);
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     set_destination_from_current();          // sync destination at the start
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
 
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
-      if (rz > delta_clip_start_height) {   // staying in the danger zone
-        destination[X_AXIS] = rx;           // move directly (uninterpolated)
+      if (rz > delta_clip_start_height) {                     // staying in the danger zone
+        destination[X_AXIS] = rx;                             // move directly (uninterpolated)
         destination[Y_AXIS] = ry;
         destination[Z_AXIS] = rz;
-        prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
+        prepare_internal_fast_move_to_destination();          // set_current_from_destination()
         if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
       destination[Z_AXIS] = delta_clip_start_height;
-      prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
+      prepare_internal_fast_move_to_destination();            // set_current_from_destination()
       if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
-    if (rz > current_position[Z_AXIS]) {    // raising?
+    if (rz > current_position[Z_AXIS]) {                      // raising?
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
+      prepare_internal_fast_move_to_destination(z_feedrate);  // set_current_from_destination()
       if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
-    prepare_move_to_destination();         // set_current_from_destination()
+    prepare_internal_move_to_destination();                   // set_current_from_destination()
     if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
-    if (rz < current_position[Z_AXIS]) {    // lowering?
+    if (rz < current_position[Z_AXIS]) {                      // lowering?
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
+      prepare_fast_move_to_destination(z_feedrate);           // set_current_from_destination()
       if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
     if (!position_is_reachable(rx, ry)) return;
 
     set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
     if (destination[Z_AXIS] < rz) {
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(z_feedrate);
+      prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
-    prepare_uninterpolated_move_to_destination(xy_feedrate);
+    prepare_internal_fast_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
     if (destination[Z_AXIS] > rz) {
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(z_feedrate);
+      prepare_internal_fast_move_to_destination(z_feedrate);
     }
 
   #else
 
     // If Z needs to raise, do it before moving XY
     if (current_position[Z_AXIS] < rz) {
       current_position[Z_AXIS] = rz;
       line_to_current_position(z_feedrate);
     }
 
@@ -413,30 +430,30 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
       current_position[Z_AXIS] = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
-void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
-void do_blocking_move_to_y(const float &ry, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], ry, current_position[Z_AXIS], fr_mm_s);
 }
-void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
-void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
 void remember_feedrate_and_scaling() {
@@ -622,57 +639,57 @@ void restore_feedrate_and_scaling() {
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * Called from prepare_move_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    *
    * For Unified Bed Leveling (Delta or Segmented Cartesian)
-   * the ubl.prepare_segmented_line_to method replaces this.
+   * the ubl.line_to_destination_segmented method replaces this.
    *
    * For Auto Bed Leveling (Bilinear) with SEGMENT_LEVELED_MOVES
    * this is replaced by segmented_line_to_destination below.
    */
-  inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
+  inline bool line_to_destination_kinematic() {
 
     // Get the top feedrate of the move in the XY plane
-    const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
+    const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-    const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
-                ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
+    const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
+                ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
 
     // If the move is only in Z/E don't split up the move
     if (!xdiff && !ydiff) {
-      planner.buffer_line(rtarget, _feedrate_mm_s, active_extruder);
+      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
-    if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
+    if (!position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) return true;
 
     // Remaining cartesian distances
-    const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
-                ediff = rtarget[E_AXIS] - current_position[E_AXIS];
+    const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
+                ediff = destination[E_AXIS] - current_position[E_AXIS];
 
     // Get the linear distance in XYZ
     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
 
     // If the move is very short, check the E move distance
     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
-    const float seconds = cartesian_mm / _feedrate_mm_s;
+    const float seconds = cartesian_mm / scaled_fr_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
@@ -683,21 +700,21 @@ void restore_feedrate_and_scaling() {
     const float inv_segments = 1.0f / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 },
                 cartesian_segment_mm = cartesian_mm * inv_segments;
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
-      const float inv_duration = _feedrate_mm_s / cartesian_segment_mm;
+      const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
     #endif
 
     /*
     SERIAL_ECHOPAIR("mm=", cartesian_mm);
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
     SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();
     //*/
 
@@ -710,50 +727,50 @@ void restore_feedrate_and_scaling() {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
-      if (!planner.buffer_line(raw, _feedrate_mm_s, active_extruder, cartesian_segment_mm
+      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       ))
         break;
     }
 
     // Ensure last segment arrives at target location.
-    planner.buffer_line(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm
+    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, cartesian_segment_mm
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     );
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
      *
      * This calls planner.buffer_line several times, adding
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
-    inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
+    inline void segmented_line_to_destination(const feedRate_t &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
       const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
                   ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
 
       // If the move is only in Z/E don't split up the move
       if (!xdiff && !ydiff) {
         planner.buffer_line(destination, fr_mm_s, active_extruder);
         return;
       }
 
@@ -777,21 +794,21 @@ void restore_feedrate_and_scaling() {
       const float inv_segments = 1.0f / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments,
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
-        const float inv_duration = _feedrate_mm_s / cartesian_segment_mm;
+        const float inv_duration = scaled_fr_mm_s / cartesian_segment_mm;
       #endif
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
       // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       float raw[XYZE];
       COPY(raw, current_position);
 
@@ -825,46 +842,47 @@ void restore_feedrate_and_scaling() {
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
    * Returns true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_cartesian() {
+    const float scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
     #if HAS_MESH
       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
-          return true;                                                                    // all moves, including Z-only moves.
+          ubl.line_to_destination_cartesian(scaled_fr_mm_s, active_extruder); // UBL's motion routine needs to know about
+          return true;                                                        // all moves, including Z-only moves.
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
-          segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
+          segmented_line_to_destination(scaled_fr_mm_s);
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
-              mbl.line_to_destination(MMS_SCALED(feedrate_mm_s));
+              mbl.line_to_destination(scaled_fr_mm_s);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-              bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
+              bilinear_line_to_destination(scaled_fr_mm_s);
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
-    buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
+    planner.buffer_line(destination, scaled_fr_mm_s, active_extruder);
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
   bool extruder_duplication_enabled,
        mirrored_duplication_mode;
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
@@ -964,20 +982,22 @@ void restore_feedrate_and_scaling() {
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position[E] and destination[E] are good
  * before calling or cold/lengthy extrusion may get missed.
+ *
+ * Before exit, current_position is set to destination.
  */
 void prepare_move_to_destination() {
   apply_motion_limits(destination);
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
@@ -1007,28 +1027,27 @@ void prepare_move_to_destination() {
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
 
   if (
     #if UBL_SEGMENTED
-      //ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))   // This doesn't seem to work correctly on UBL.
-      #if IS_KINEMATIC                                                          // Use Kinematic / Cartesian cases as a workaround for now.
-        ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
+      #if IS_KINEMATIC // UBL using Kinematic / Cartesian cases as a workaround for now.
+        ubl.line_to_destination_segmented(MMS_SCALED(feedrate_mm_s))
       #else
         prepare_move_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
-      prepare_kinematic_move_to(destination)
+      line_to_destination_kinematic()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_from_destination();
 }
 
 uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
   #if ENABLED(HOME_AFTER_DEACTIVATE)
@@ -1058,31 +1077,31 @@ bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
       ui.set_status(msg);
     #endif
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */
-float get_homing_bump_feedrate(const AxisEnum axis) {
+feedRate_t get_homing_bump_feedrate(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
-  return homing_feedrate(axis) / hbd;
+  return homing_feedrate(axis) / float(hbd);
 }
 
 #if ENABLED(SENSORLESS_HOMING)
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
     sensorless_t stealth_states { false };
 
     switch (axis) {
@@ -1214,21 +1233,21 @@ float get_homing_bump_feedrate(const AxisEnum axis) {
         default: break;
       }
     #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
-void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
+void do_homing_move(const AxisEnum axis, const float distance, const feedRate_t fr_mm_s=0.0) {
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
     if (fr_mm_s)
       DEBUG_ECHO(fr_mm_s);
     else
       DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
     DEBUG_ECHOLNPGM(")");
   }
 
@@ -1259,42 +1278,43 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       stealth_states = start_sensorless_homing_per_axis(axis);
     #endif
   }
 
+  const feedRate_t real_fr_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(axis);
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
-    planner.buffer_line(current_position, fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+    line_to_current_position(real_fr_mm_s);
   #else
     float target[ABCE] = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
     target[axis] = 0;
     planner.set_machine_position_mm(target);
     target[axis] = distance;
 
     #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
       const float delta_mm_cart[XYZE] = {0, 0, 0, 0};
     #endif
 
     // Set delta/cartesian axes directly
     planner.buffer_segment(target
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
-      , fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder
+      , real_fr_mm_s, active_extruder
     );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(false);
     #endif
@@ -1500,21 +1520,21 @@ void homeaxis(const AxisEnum axis) {
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
-        , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
+        , MMM_TO_MMS(axis == Z_AXIS ? Z_PROBE_SPEED_FAST : 0)
       #endif
     );
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
       if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 

commit d49d40f7b014caec19f431fa2f40e78129321524
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 22:26:08 2019 -0500

    Home XYZ newline

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9d31653e58..c27d87424e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1046,21 +1046,21 @@ uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
 bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
   if ((axis_bits = axes_need_homing(axis_bits))) {
     static const char home_first[] PROGMEM = MSG_HOME_FIRST;
     char msg[sizeof(home_first)];
     sprintf_P(msg, home_first,
       TEST(axis_bits, X_AXIS) ? "X" : "",
       TEST(axis_bits, Y_AXIS) ? "Y" : "",
       TEST(axis_bits, Z_AXIS) ? "Z" : ""
     );
     SERIAL_ECHO_START();
-    SERIAL_ECHO(msg);
+    SERIAL_ECHOLN(msg);
     #if HAS_DISPLAY
       ui.set_status(msg);
     #endif
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)

commit b2e1f77f58a67ac02503cbe36b22a21e5afaeac0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 21:01:29 2019 -0500

    Fix extraneous "Home XYZ First" message

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d5bc121d9b..9d31653e58 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1023,40 +1023,46 @@ void prepare_move_to_destination() {
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_from_destination();
 }
 
-bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
+uint8_t axes_need_homing(uint8_t axis_bits/*=0x07*/) {
   #if ENABLED(HOME_AFTER_DEACTIVATE)
-    const bool xx = x && !TEST(axis_known_position, X_AXIS),
-               yy = y && !TEST(axis_known_position, Y_AXIS),
-               zz = z && !TEST(axis_known_position, Z_AXIS);
+    #define HOMED_FLAGS axis_known_position
   #else
-    const bool xx = x && !TEST(axis_homed, X_AXIS),
-               yy = y && !TEST(axis_homed, Y_AXIS),
-               zz = z && !TEST(axis_homed, Z_AXIS);
+    #define HOMED_FLAGS axis_homed
   #endif
-  if (xx || yy || zz) {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_HOME " ");
-    if (xx) SERIAL_CHAR('X');
-    if (yy) SERIAL_CHAR('Y');
-    if (zz) SERIAL_CHAR('Z');
-    SERIAL_ECHOLNPGM(" " MSG_FIRST);
+  // Clear test bits that are homed
+  if (TEST(axis_bits, X_AXIS) && TEST(HOMED_FLAGS, X_AXIS)) CBI(axis_bits, X_AXIS);
+  if (TEST(axis_bits, Y_AXIS) && TEST(HOMED_FLAGS, Y_AXIS)) CBI(axis_bits, Y_AXIS);
+  if (TEST(axis_bits, Z_AXIS) && TEST(HOMED_FLAGS, Z_AXIS)) CBI(axis_bits, Z_AXIS);
+  return axis_bits;
+}
 
+bool axis_unhomed_error(uint8_t axis_bits/*=0x07*/) {
+  if ((axis_bits = axes_need_homing(axis_bits))) {
+    static const char home_first[] PROGMEM = MSG_HOME_FIRST;
+    char msg[sizeof(home_first)];
+    sprintf_P(msg, home_first,
+      TEST(axis_bits, X_AXIS) ? "X" : "",
+      TEST(axis_bits, Y_AXIS) ? "Y" : "",
+      TEST(axis_bits, Z_AXIS) ? "Z" : ""
+    );
+    SERIAL_ECHO_START();
+    SERIAL_ECHO(msg);
     #if HAS_DISPLAY
-      ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
+      ui.set_status(msg);
     #endif
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */
 float get_homing_bump_feedrate(const AxisEnum axis) {

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3867fb9c74..d5bc121d9b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -498,21 +498,21 @@ void restore_feedrate_and_scaling() {
           soft_endstop[X_AXIS].max = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop[axis].min = base_min_pos(axis);
       soft_endstop[axis].max = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
-        - zprobe_offset[Z_AXIS]
+        - probe_offset[Z_AXIS]
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
@@ -1333,37 +1333,37 @@ void set_axis_is_at_home(const AxisEnum axis) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - zprobe_offset[Z_AXIS]
+      - probe_offset[Z_AXIS]
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
-        current_position[Z_AXIS] -= zprobe_offset[Z_AXIS];
+        current_position[Z_AXIS] -= probe_offset[Z_AXIS];
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> zprobe_offset[Z_AXIS] = ", zprobe_offset[Z_AXIS]);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> probe_offset[Z_AXIS] = ", probe_offset[Z_AXIS]);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2031944117..3867fb9c74 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -498,21 +498,21 @@ void restore_feedrate_and_scaling() {
           soft_endstop[X_AXIS].max = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop[axis].min = base_min_pos(axis);
       soft_endstop[axis].max = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
-        - zprobe_zoffset
+        - zprobe_offset[Z_AXIS]
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           delta_max_radius = _MIN(ABS(_MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
@@ -1333,37 +1333,37 @@ void set_axis_is_at_home(const AxisEnum axis) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - zprobe_zoffset
+      - zprobe_offset[Z_AXIS]
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
-        current_position[Z_AXIS] -= zprobe_zoffset;
+        current_position[Z_AXIS] -= zprobe_offset[Z_AXIS];
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> zprobe_zoffset = ", zprobe_zoffset);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> zprobe_offset[Z_AXIS] = ", zprobe_offset[Z_AXIS]);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 930584889c..2031944117 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -432,26 +432,29 @@ void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
 //
 static float saved_feedrate_mm_s;
 static int16_t saved_feedrate_percentage;
-void setup_for_endstop_or_probe_move() {
+void remember_feedrate_and_scaling() {
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
+}
+void remember_feedrate_scaling_off() {
+  remember_feedrate_and_scaling();
   feedrate_percentage = 100;
 }
-void clean_up_after_endstop_or_probe_move() {
+void restore_feedrate_and_scaling() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   bool soft_endstops_enabled = true;
 
   // Software Endstops are based on the configured limits.
   axis_limits_t soft_endstop[XYZ] = { { X_MIN_BED, X_MAX_BED }, { Y_MIN_BED, Y_MAX_BED }, { Z_MIN_POS, Z_MAX_POS } };

commit 252f31b6f15fd9a012e64925d86d435fc59e3d35
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Sep 18 15:04:13 2019 -0700

    Fix/improve backoff feedrates (#15300)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a1f0cbf150..930584889c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1651,21 +1651,26 @@ void homeaxis(const AxisEnum axis) {
     constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
     const float backoff_mm = endstop_backoff[
       #if ENABLED(DELTA)
         Z_AXIS
       #else
         axis
       #endif
     ];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
-      line_to_current_position(Z_PROBE_SPEED_FAST);
+      line_to_current_position(
+        #if HOMING_Z_WITH_PROBE
+          (axis == Z_AXIS) ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) :
+        #endif
+        homing_feedrate(axis)
+      );
     }
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
 

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 552dabb74e..a1f0cbf150 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -98,21 +98,21 @@ bool relative_mode; // = false;
  *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 float current_position[XYZE] = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
- *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
+ *   G-codes can set destination using 'get_destination_from_command'
  */
 float destination[XYZE]; // = { 0 }
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
@@ -663,21 +663,21 @@ void clean_up_after_endstop_or_probe_move() {
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / _feedrate_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
-      NOMORE(segments, cartesian_mm * (1.0f / float(SCARA_MIN_SEGMENT_LENGTH)));
+      NOMORE(segments, cartesian_mm * RECIPROCAL(SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,

commit 6b1c4dec464110bee11284a31548b9faf5ca3ccd
Author: kakou-fr <kakou@kakou.org>
Date:   Thu Sep 5 01:09:12 2019 +0200

    Touch Mi: Add magnet Y position (#15166)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c5854d1f15..552dabb74e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -417,21 +417,21 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_y(const float &ry, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position[Y_AXIS], ry, current_position[Z_AXIS], fr_mm_s);
+  do_blocking_move_to(current_position[X_AXIS], ry, current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.

commit 081e4506ca5356501415bfaf066d982947449623
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Wed Aug 28 04:20:28 2019 -0500

    Fix G53 as prefix, G28 with CNC_COORDINATE_SYSTEMS (#15069)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a31f1c08e5..c5854d1f15 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1318,25 +1318,20 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", axis_codes[axis], ")");
 
   SBI(axis_known_position, axis);
   SBI(axis_homed, axis);
 
-  #if HAS_POSITION_SHIFT
-    position_shift[axis] = 0;
-    update_workspace_offset(axis);
-  #endif
-
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)

commit 33f6d77281ac6d647ed39fcae60c65be0140ac84
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Aug 20 04:44:52 2019 -0400

    Adjust homing backoff feedrate (#14972)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 85d9362ef8..a31f1c08e5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1656,21 +1656,21 @@ void homeaxis(const AxisEnum axis) {
     constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
     const float backoff_mm = endstop_backoff[
       #if ENABLED(DELTA)
         Z_AXIS
       #else
         axis
       #endif
     ];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
-      line_to_current_position();
+      line_to_current_position(Z_PROBE_SPEED_FAST);
     }
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
 

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 0216a658c5..85d9362ef8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1114,20 +1114,40 @@ float get_homing_bump_feedrate(const AxisEnum axis) {
             stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
           #endif
           #if CORE_IS_XZ && X_SENSORLESS
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #endif
           break;
       #endif
     }
+
+    #if ENABLED(SPI_ENDSTOPS)
+      switch (axis) {
+        #if X_SPI_SENSORLESS
+          case X_AXIS: endstops.tmc_spi_homing.x = true; break;
+        #endif
+        #if Y_SPI_SENSORLESS
+          case Y_AXIS: endstops.tmc_spi_homing.y = true; break;
+        #endif
+        #if Z_SPI_SENSORLESS
+          case Z_AXIS: endstops.tmc_spi_homing.z = true; break;
+        #endif
+        default: break;
+      }
+    #endif
+
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      sg_guard_period = millis() + default_sg_guard_duration;
+    #endif
+
     return stealth_states;
   }
 
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           tmc_disable_stallguard(stepperX, enable_stealth.x);
           #if AXIS_HAS_STALLGUARD(X2)
@@ -1163,20 +1183,35 @@ float get_homing_bump_feedrate(const AxisEnum axis) {
             tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
           #endif
           #if CORE_IS_XZ && X_SENSORLESS
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #endif
           break;
       #endif
     }
+
+    #if ENABLED(SPI_ENDSTOPS)
+      switch (axis) {
+        #if X_SPI_SENSORLESS
+          case X_AXIS: endstops.tmc_spi_homing.x = false; break;
+        #endif
+        #if Y_SPI_SENSORLESS
+          case Y_AXIS: endstops.tmc_spi_homing.y = false; break;
+        #endif
+        #if Z_SPI_SENSORLESS
+          case Z_AXIS: endstops.tmc_spi_homing.z = false; break;
+        #endif
+        default: break;
+      }
+    #endif
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
   if (DEBUGGING(LEVELING)) {
@@ -1376,23 +1411,38 @@ void set_axis_is_not_at_home(const AxisEnum axis) {
  * Kinematic robots should wait till all axes are homed
  * before updating the current position.
  */
 
 void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   #else
-    #define CAN_HOME(A) \
+    #define _CAN_HOME(A) \
       (axis == _AXIS(A) && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
-    if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
+    #if X_SPI_SENSORLESS
+      #define CAN_HOME_X true
+    #else
+      #define CAN_HOME_X _CAN_HOME(X)
+    #endif
+    #if Y_SPI_SENSORLESS
+      #define CAN_HOME_Y true
+    #else
+      #define CAN_HOME_Y _CAN_HOME(Y)
+    #endif
+    #if Z_SPI_SENSORLESS
+      #define CAN_HOME_Z true
+    #else
+      #define CAN_HOME_Z _CAN_HOME(Z)
+    #endif
+    if (!CAN_HOME_X && !CAN_HOME_Y && !CAN_HOME_Z) return;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
   const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
       axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis)
   );

commit 7682751646d6190b5f23a2853caf8d0646f639df
Author: mekius <mekius@gmail.com>
Date:   Thu Aug 1 20:32:45 2019 -0500

    Fix HOME_BACKOFF_MM type (#14805)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fd67b887e6..0216a658c5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1597,21 +1597,21 @@ void homeaxis(const AxisEnum axis) {
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   #ifdef HOMING_BACKOFF_MM
     constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
-    const AxisEnum backoff_mm = endstop_backoff[
+    const float backoff_mm = endstop_backoff[
       #if ENABLED(DELTA)
         Z_AXIS
       #else
         axis
       #endif
     ];
     if (backoff_mm) {
       current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
       line_to_current_position();
     }

commit 6f8b8c394db5f5037e85d3b16dc63bfeb11f6891
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jul 31 21:50:23 2019 -0400

    Homing backoff per-axis / delta Z (#14789)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 69b5905b20..fd67b887e6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -416,20 +416,23 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
 
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
+void do_blocking_move_to_y(const float &ry, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(current_position[Y_AXIS], ry, current_position[Z_AXIS], fr_mm_s);
+}
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves with custom feedrates.
 //  - Save / restore current feedrate and multiplier
@@ -1592,20 +1595,35 @@ void homeaxis(const AxisEnum axis) {
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
+  #ifdef HOMING_BACKOFF_MM
+    constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
+    const AxisEnum backoff_mm = endstop_backoff[
+      #if ENABLED(DELTA)
+        Z_AXIS
+      #else
+        axis
+      #endif
+    ];
+    if (backoff_mm) {
+      current_position[axis] -= ABS(backoff_mm) * axis_home_dir;
+      line_to_current_position();
+    }
+  #endif
+
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
 
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ee46fc3f99..69b5905b20 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1064,21 +1064,21 @@ float get_homing_bump_feedrate(const AxisEnum axis) {
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
 #if ENABLED(SENSORLESS_HOMING)
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
-    sensorless_t stealth_states { false, false, false, false, false, false, false };
+    sensorless_t stealth_states { false };
 
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           stealth_states.x = tmc_enable_stallguard(stepperX);
           #if AXIS_HAS_STALLGUARD(X2)
             stealth_states.x2 = tmc_enable_stallguard(stepperX2);
           #endif
           #if CORE_IS_XY && Y_SENSORLESS

commit 42b5ccafc951bdb0e5c2e23ea12704f43563b0d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 17 20:24:25 2019 -0500

    Toss obsolete DEBUG_LEVELING_FEATURE tests

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8f5da0b22a..ee46fc3f99 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -531,24 +531,22 @@ void clean_up_after_endstop_or_probe_move() {
         soft_endstop[axis].max = base_max_pos(axis) + offs;
       }
 
     #else
 
       soft_endstop[axis].min = base_min_pos(axis);
       soft_endstop[axis].max = base_max_pos(axis);
 
     #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING))
-      SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop[axis].min, " max:", soft_endstop[axis].max);
-  #endif
+  if (DEBUGGING(LEVELING))
+    SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop[axis].min, " max:", soft_endstop[axis].max);
 }
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
   void apply_motion_limits(float target[XYZ]) {
 

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5ba992eea5..8f5da0b22a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -44,21 +44,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
-#if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
+#if HAS_DISPLAY
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
@@ -1037,21 +1037,21 @@ bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool
                zz = z && !TEST(axis_homed, Z_AXIS);
   #endif
   if (xx || yy || zz) {
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_HOME " ");
     if (xx) SERIAL_CHAR('X');
     if (yy) SERIAL_CHAR('Y');
     if (zz) SERIAL_CHAR('Z');
     SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
-    #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
+    #if HAS_DISPLAY
       ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
     #endif
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e2b61194f8..5ba992eea5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -118,21 +118,21 @@ float destination[XYZE]; // = { 0 }
 #if HAS_HOTEND_OFFSET
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
   void reset_hotend_offsets() {
     constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
     static_assert(
       tmp[X_AXIS][0] == 0 && tmp[Y_AXIS][0] == 0 && tmp[Z_AXIS][0] == 0,
       "Offsets for the first hotend must be 0.0."
     );
     LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp[i][e];
     #if ENABLED(DUAL_X_CARRIAGE)
-      hotend_offset[X_AXIS][1] = MAX(X2_HOME_POS, X2_MAX_POS);
+      hotend_offset[X_AXIS][1] = _MAX(X2_HOME_POS, X2_MAX_POS);
     #endif
   }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 float feedrate_mm_s = MMM_TO_MMS(1500.0f);
 
@@ -466,32 +466,32 @@ void clean_up_after_endstop_or_probe_move() {
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index/*=0*/, const uint8_t new_tool_index/*=0*/
     #endif
   ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
-        const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
+        const float dual_max_x = _MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (new_tool_index != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop[X_AXIS].min = X2_MIN_POS;
           soft_endstop[X_AXIS].max = dual_max_x;
         }
         else if (dxc_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop[X_AXIS].min = X1_MIN_POS;
-          soft_endstop[X_AXIS].max = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
+          soft_endstop[X_AXIS].max = _MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop[X_AXIS].min = X1_MIN_POS;
           soft_endstop[X_AXIS].max = X1_MAX_POS;
         }
 
       }
 
     #elif ENABLED(DELTA)
@@ -500,21 +500,21 @@ void clean_up_after_endstop_or_probe_move() {
       soft_endstop[axis].max = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
         - zprobe_zoffset
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
-          delta_max_radius = MIN(ABS(MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
+          delta_max_radius = _MIN(ABS(_MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
           delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
           delta_clip_start_height = soft_endstop[axis].max - delta_safe_distance_from_top();
         default: break;
       }
 
     #elif HAS_HOTEND_OFFSET
 
       // Software endstops are relative to the tool 0 workspace, so
@@ -1434,21 +1434,21 @@ void homeaxis(const AxisEnum axis) {
     ) * axis_home_dir
   );
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
     if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
+      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? _MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5469b4d691..e2b61194f8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7f1f9172c9..5469b4d691 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1415,36 +1415,34 @@ void homeaxis(const AxisEnum axis) {
       #endif
       stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    // BLTOUCH needs to be deployed every time
-    if (axis == Z_AXIS && bltouch.deploy()) return;
+    if (axis == Z_AXIS && bltouch.deploy()) return; // The initial DEPLOY
   #endif
 
   do_homing_move(axis, 1.5f * max_length(
     #if ENABLED(DELTA)
       Z_AXIS
     #else
       axis
     #endif
     ) * axis_home_dir
   );
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    // BLTOUCH needs to be stowed after trigger to rearm itself
-    if (axis == Z_AXIS) bltouch.stow();
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+    if (axis == Z_AXIS) bltouch.stow(); // Intermediate STOW (in LOW SPEED MODE)
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
@@ -1454,30 +1452,28 @@ void homeaxis(const AxisEnum axis) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
-    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-      // BLTOUCH needs to be deployed every time
-      if (axis == Z_AXIS && bltouch.deploy()) return;
+    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH) && DISABLED(BLTOUCH_HS_MODE)
+      if (axis == Z_AXIS && bltouch.deploy()) return; // Intermediate DEPLOY (in LOW SPEED MODE)
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-      // BLTOUCH needs to be stowed after trigger to rearm itself
-      if (axis == Z_AXIS) bltouch.stow();
+      if (axis == Z_AXIS) bltouch.stow(); // The final STOW
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x2_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);

commit ee243e4edfe45fa855d4ff71abf8a9a118b66369
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Wed May 1 22:55:58 2019 -0400

    Fix mixing extruder filament change (#13803)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 30f63ebed5..7f1f9172c9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -975,23 +975,35 @@ void prepare_move_to_destination() {
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          if (ABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
-            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+          const float e_delta = ABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder];
+          if (e_delta > (EXTRUDE_MAXLENGTH)) {
+            #if ENABLED(MIXING_EXTRUDER)
+              bool ignore_e = false;
+              float collector[MIXING_STEPPERS];
+              mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
+              MIXER_STEPPER_LOOP(e)
+                if (e_delta * collector[e] > (EXTRUDE_MAXLENGTH)) { ignore_e = true; break; }
+            #else
+              constexpr bool ignore_e = true;
+            #endif
+            if (ignore_e) {
+              current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+              SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+            }
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c226c180aa..30f63ebed5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -56,20 +56,24 @@
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
+#if ENABLED(BABYSTEP_DISPLAY_TOTAL)
+  #include "../feature/babystep.h"
+#endif
+
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
@@ -1309,31 +1313,35 @@ void set_axis_is_at_home(const AxisEnum axis) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> zprobe_zoffset = ", zprobe_zoffset);
 
       #else
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    I2CPEM.homed(axis);
+  #endif
+
+  #if ENABLED(BABYSTEP_DISPLAY_TOTAL)
+    babystep.reset_total(axis);
+  #endif
+
   if (DEBUGGING(LEVELING)) {
     #if HAS_HOME_OFFSET
       DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
     #endif
     DEBUG_POS("", current_position);
     DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
   }
-
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    I2CPEM.homed(axis);
-  #endif
 }
 
 /**
  * Set an axis' to be unhomed.
  */
 void set_axis_is_not_at_home(const AxisEnum axis) {
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_not_at_home(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);

commit d44e5b1fdeb4f5d6196ed0f3afe3076eef90a3da
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Apr 4 03:44:07 2019 -0400

    Fix stepper direction macros, multi-nozzle scope (#13569)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2e1ed63fa9..c226c180aa 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -852,24 +852,23 @@ void clean_up_after_endstop_or_probe_move() {
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
   bool extruder_duplication_enabled,
        mirrored_duplication_mode;
-#endif
-
-#if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
-  uint8_t duplication_e_mask; // = 0
+  #if ENABLED(MULTI_NOZZLE_DUPLICATION)
+    uint8_t duplication_e_mask; // = 0
+  #endif
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4eb675ddbc..2e1ed63fa9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -40,20 +40,24 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
 #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
@@ -1393,35 +1397,35 @@ void homeaxis(const AxisEnum axis) {
       stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be deployed every time
-    if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
+    if (axis == Z_AXIS && bltouch.deploy()) return;
   #endif
 
   do_homing_move(axis, 1.5f * max_length(
     #if ENABLED(DELTA)
       Z_AXIS
     #else
       axis
     #endif
     ) * axis_home_dir
   );
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be stowed after trigger to rearm itself
-    if (axis == Z_AXIS) set_bltouch_deployed(false);
+    if (axis == Z_AXIS) bltouch.stow();
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
@@ -1433,28 +1437,28 @@ void homeaxis(const AxisEnum axis) {
       #if HOMING_Z_WITH_PROBE
         , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be deployed every time
-      if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
+      if (axis == Z_AXIS && bltouch.deploy()) return;
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be stowed after trigger to rearm itself
-      if (axis == Z_AXIS) set_bltouch_deployed(false);
+      if (axis == Z_AXIS) bltouch.stow();
     #endif
   }
 
   #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x2_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ce780b153b..4eb675ddbc 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -40,21 +40,21 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+#if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
@@ -957,21 +957,21 @@ void clean_up_after_endstop_or_probe_move() {
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position[E] and destination[E] are good
  * before calling or cold/lengthy extrusion may get missed.
  */
 void prepare_move_to_destination() {
   apply_motion_limits(destination);
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
+  #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
@@ -1018,21 +1018,21 @@ bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool
                zz = z && !TEST(axis_homed, Z_AXIS);
   #endif
   if (xx || yy || zz) {
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_HOME " ");
     if (xx) SERIAL_CHAR('X');
     if (yy) SERIAL_CHAR('Y');
     if (zz) SERIAL_CHAR('Z');
     SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
-    #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+    #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
       ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
     #endif
     return true;
   }
   return false;
 }
 
 /**
  * Homing bump feedrate (mm/s)
  */

commit 09eb30dc05a727e3816ab5a407f02ada18700e23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Mar 15 23:46:27 2019 -0400

    IDEX Mirror mode based on Formbot / Vivedino Symmetric mode (#13404)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ec072ade6a..ce780b153b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -846,22 +846,22 @@ void clean_up_after_endstop_or_probe_move() {
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if HAS_DUPLICATION_MODE
-  bool extruder_duplication_enabled;
-       //scaled_duplication_mode;
+  bool extruder_duplication_enabled,
+       mirrored_duplication_mode;
 #endif
 
 #if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
   uint8_t duplication_e_mask; // = 0
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
@@ -916,21 +916,21 @@ void clean_up_after_endstop_or_probe_move() {
             #define RAISED_Y raised_parked_position[Y_AXIS]
             #define RAISED_Z raised_parked_position[Z_AXIS]
 
             if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder))
               if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
                   planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Clear active_extruder_parked");
           break;
-        case DXC_SCALED_DUPLICATION_MODE:
+        case DXC_MIRRORED_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x_pos, " ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 
             if (!planner.buffer_line(
                 dual_x_carriage_mode == DXC_DUPLICATION_MODE ? duplicate_extruder_x_offset + current_position[X_AXIS] : inactive_extruder_x_pos,
                 current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
                 planner.settings.max_feedrate_mm_s[X_AXIS], 1

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7a615eb417..ec072ade6a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -52,20 +52,23 @@
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../core/debug_out.h"
+
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 /**
@@ -198,23 +201,21 @@ void report_current_position() {
   #endif
 }
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 }
 
 void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
 
 /**
  * Get the stepper positions in the cartes[] array.
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
@@ -287,23 +288,21 @@ void line_to_current_position(const float &fr_mm_s/*=feedrate_mm_s*/) {
 void buffer_line_to_destination(const float fr_mm_s) {
   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
 }
 
 #if IS_KINEMATIC
 
   /**
    * Calculate delta, start a line, and set current_position to destination
    */
   void prepare_uninterpolated_move_to_destination(const float &fr_mm_s/*=0.0*/) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
 
     #if UBL_SEGMENTED
       // ubl segmented line will do z-only moves in single segment
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
@@ -313,79 +312,65 @@ void buffer_line_to_destination(const float fr_mm_s) {
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_XYZ(">>> do_blocking_move_to", rx, ry, rz);
 
   const float z_feedrate  = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
               xy_feedrate = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     set_destination_from_current();          // sync destination at the start
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
 
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
       if (rz > delta_clip_start_height) {   // staying in the danger zone
         destination[X_AXIS] = rx;           // move directly (uninterpolated)
         destination[Y_AXIS] = ry;
         destination[Z_AXIS] = rz;
         prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         return;
       }
       destination[Z_AXIS] = delta_clip_start_height;
       prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
     }
 
     if (rz > current_position[Z_AXIS]) {    // raising?
       destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
     prepare_move_to_destination();         // set_current_from_destination()
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
 
     if (rz < current_position[Z_AXIS]) {    // lowering?
       destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
     }
 
   #elif IS_SCARA
 
     if (!position_is_reachable(rx, ry)) return;
 
     set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
     if (destination[Z_AXIS] < rz) {
@@ -416,23 +401,21 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
     line_to_current_position(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
     if (current_position[Z_AXIS] > rz) {
       current_position[Z_AXIS] = rz;
       line_to_current_position(z_feedrate);
     }
 
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< do_blocking_move_to");
 
   planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
@@ -931,55 +914,42 @@ void clean_up_after_endstop_or_probe_move() {
             #define CUR_E    current_position[E_AXIS]
             #define RAISED_X raised_parked_position[X_AXIS]
             #define RAISED_Y raised_parked_position[Y_AXIS]
             #define RAISED_Z raised_parked_position[Z_AXIS]
 
             if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder))
               if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
                   planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
-          #endif
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Clear active_extruder_parked");
           break;
         case DXC_SCALED_DUPLICATION_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
-                SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
-              }
-            #endif
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Set planner X", inactive_extruder_x_pos, " ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 
             if (!planner.buffer_line(
                 dual_x_carriage_mode == DXC_DUPLICATION_MODE ? duplicate_extruder_x_offset + current_position[X_AXIS] : inactive_extruder_x_pos,
                 current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
                 planner.settings.max_feedrate_mm_s[X_AXIS], 1
               )
             ) break;
             planner.synchronize();
             sync_plan_position();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
-            #endif
-          }
-          else {
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
-            #endif
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
           }
+          else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Active extruder not 0");
           break;
       }
     }
     stepper.set_directions();
     return false;
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
@@ -1182,34 +1152,28 @@ float get_homing_bump_feedrate(const AxisEnum axis) {
     }
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
 void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
-      SERIAL_ECHOPAIR(", ", distance);
-      SERIAL_ECHOPGM(", ");
-      if (fr_mm_s)
-        SERIAL_ECHO(fr_mm_s);
-      else {
-        SERIAL_ECHOPAIR("[", homing_feedrate(axis));
-        SERIAL_CHAR(']');
-      }
-      SERIAL_ECHOLNPGM(")");
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_ECHOPAIR(">>> do_homing_move(", axis_codes[axis], ", ", distance, ", ");
+    if (fr_mm_s)
+      DEBUG_ECHO(fr_mm_s);
+    else
+      DEBUG_ECHOPAIR("[", homing_feedrate(axis), "]");
+    DEBUG_ECHOLNPGM(")");
+  }
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
@@ -1272,27 +1236,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       end_sensorless_homing_per_axis(axis, stealth_states);
     #endif
   }
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< do_homing_move(", axis_codes[axis], ")");
 }
 
 /**
  * Set an axis' current position to its home position (after homing).
  *
  * For Core and Cartesian robots this applies one-to-one when an
  * individual axis has been homed.
  *
  * DELTA should wait until all homing is done before setting the XYZ
  * current_position to home, because homing is a single operation.
@@ -1300,27 +1258,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
  * homed, DELTA could home to X or Y individually by moving either one
  * to the center. However, homing Z always homes XY and Z.
  *
  * SCARA should wait until all XY homing is done before setting the XY
  * current_position to home, because neither X nor Y is at home until
  * both are at home. Z can however be homed individually.
  *
  * Callers must sync the planner position after calling this!
  */
 void set_axis_is_at_home(const AxisEnum axis) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_at_home(", axis_codes[axis], ")");
 
   SBI(axis_known_position, axis);
   SBI(axis_homed, axis);
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_workspace_offset(axis);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
@@ -1344,75 +1296,53 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
         current_position[Z_AXIS] -= zprobe_zoffset;
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
-            SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
-          }
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***\n> zprobe_zoffset = ", zprobe_zoffset);
 
-      #elif ENABLED(DEBUG_LEVELING_FEATURE)
+      #else
 
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      #if HAS_HOME_OFFSET
-        SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
-        SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
-      #endif
-      DEBUG_POS("", current_position);
-      SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    #if HAS_HOME_OFFSET
+      DEBUG_ECHOLNPAIR("> home_offset[", axis_codes[axis], "] = ", home_offset[axis]);
+    #endif
+    DEBUG_POS("", current_position);
+    DEBUG_ECHOLNPAIR("<<< set_axis_is_at_home(", axis_codes[axis], ")");
+  }
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.homed(axis);
   #endif
 }
 
 /**
  * Set an axis' to be unhomed.
  */
 void set_axis_is_not_at_home(const AxisEnum axis) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> set_axis_is_not_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> set_axis_is_not_at_home(", axis_codes[axis], ")");
 
   CBI(axis_known_position, axis);
   CBI(axis_homed, axis);
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("<<< set_axis_is_not_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< set_axis_is_not_at_home(", axis_codes[axis], ")");
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.unhomed(axis);
   #endif
 }
 
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.
@@ -1427,27 +1357,21 @@ void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   #else
     #define CAN_HOME(A) \
       (axis == _AXIS(A) && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR(">>> homeaxis(", axis_codes[axis], ")");
 
   const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
       axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
@@ -1465,23 +1389,21 @@ void homeaxis(const AxisEnum axis) {
       #endif
       #if Z_MULTI_ENDSTOPS
         case Z_AXIS:
       #endif
       stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 1 Fast:");
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be deployed every time
     if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
   #endif
 
   do_homing_move(axis, 1.5f * max_length(
     #if ENABLED(DELTA)
       Z_AXIS
     #else
@@ -1499,33 +1421,29 @@ void homeaxis(const AxisEnum axis) {
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move Away:");
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Home 2 Slow:");
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be deployed every time
       if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be stowed after trigger to rearm itself
@@ -1637,68 +1555,53 @@ void homeaxis(const AxisEnum axis) {
     sync_plan_position();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
     // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("delta_endstop_adj:");
       do_homing_move(axis, delta_endstop_adj[axis] - (MIN_STEPS_PER_SEGMENT + 1) * planner.steps_to_mm[axis] * Z_HOME_DIR);
     }
 
   #else // CARTESIAN / CORE
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("<<< homeaxis(", axis_codes[axis], ")");
+
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis) {
     workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
-        SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
-        SERIAL_ECHOLNPAIR("\n position_shift = ", position_shift[axis]);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Axis ", axis_codes[axis], " home_offset = ", home_offset[axis], " position_shift = ", position_shift[axis]);
   }
 #endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 362cb7c4f6..7a615eb417 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -142,27 +142,27 @@ float cartes[XYZ];
 
 #if IS_KINEMATIC
 
   float delta[ABC];
 
   #if HAS_SCARA_OFFSET
     float scara_home_offset[ABC];
   #endif
 
   #if HAS_SOFTWARE_ENDSTOPS
-    float soft_endstop_radius, soft_endstop_radius_2;
+    float delta_max_radius, delta_max_radius_2;
   #elif IS_SCARA
-    constexpr float soft_endstop_radius = SCARA_PRINTABLE_RADIUS,
-                    soft_endstop_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
+    constexpr float delta_max_radius = SCARA_PRINTABLE_RADIUS,
+                    delta_max_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
   #else // DELTA
-    constexpr float soft_endstop_radius = DELTA_PRINTABLE_RADIUS,
-                    soft_endstop_radius_2 = sq(DELTA_PRINTABLE_RADIUS);
+    constexpr float delta_max_radius = DELTA_PRINTABLE_RADIUS,
+                    delta_max_radius_2 = sq(DELTA_PRINTABLE_RADIUS);
   #endif
 
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
 #if HAS_POSITION_SHIFT
   // The distance that XYZ has been offset by G92. Reset by G28.
@@ -453,22 +453,21 @@ void setup_for_endstop_or_probe_move() {
 void clean_up_after_endstop_or_probe_move() {
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   bool soft_endstops_enabled = true;
 
   // Software Endstops are based on the configured limits.
-  float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
-        soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
+  axis_limits_t soft_endstop[XYZ] = { { X_MIN_BED, X_MAX_BED }, { Y_MIN_BED, Y_MAX_BED }, { Z_MIN_POS, Z_MAX_POS } };
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
@@ -480,142 +479,140 @@ void clean_up_after_endstop_or_probe_move() {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (new_tool_index != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
-          soft_endstop_min[X_AXIS] = X2_MIN_POS;
-          soft_endstop_max[X_AXIS] = dual_max_x;
+          soft_endstop[X_AXIS].min = X2_MIN_POS;
+          soft_endstop[X_AXIS].max = dual_max_x;
         }
         else if (dxc_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
-          soft_endstop_min[X_AXIS] = X1_MIN_POS;
-          soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
+          soft_endstop[X_AXIS].min = X1_MIN_POS;
+          soft_endstop[X_AXIS].max = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
-          soft_endstop_min[X_AXIS] = X1_MIN_POS;
-          soft_endstop_max[X_AXIS] = X1_MAX_POS;
+          soft_endstop[X_AXIS].min = X1_MIN_POS;
+          soft_endstop[X_AXIS].max = X1_MAX_POS;
         }
+
       }
 
     #elif ENABLED(DELTA)
 
-      soft_endstop_min[axis] = base_min_pos(axis);
-      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height
+      soft_endstop[axis].min = base_min_pos(axis);
+      soft_endstop[axis].max = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
         - zprobe_zoffset
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
-          soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
-          soft_endstop_radius_2 = sq(soft_endstop_radius);
+          delta_max_radius = MIN(ABS(MAX(soft_endstop[X_AXIS].min, soft_endstop[Y_AXIS].min)), soft_endstop[X_AXIS].max, soft_endstop[Y_AXIS].max);
+          delta_max_radius_2 = sq(delta_max_radius);
           break;
         case Z_AXIS:
-          delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+          delta_clip_start_height = soft_endstop[axis].max - delta_safe_distance_from_top();
         default: break;
       }
 
     #elif HAS_HOTEND_OFFSET
 
       // Software endstops are relative to the tool 0 workspace, so
       // the movement limits must be shifted by the tool offset to
       // retain the same physical limit when other tools are selected.
       if (old_tool_index != new_tool_index) {
         const float offs = hotend_offset[axis][new_tool_index] - hotend_offset[axis][old_tool_index];
-        soft_endstop_min[axis] += offs;
-        soft_endstop_max[axis] += offs;
+        soft_endstop[axis].min += offs;
+        soft_endstop[axis].max += offs;
       }
       else {
         const float offs = hotend_offset[axis][active_extruder];
-        soft_endstop_min[axis] = base_min_pos(axis) + offs;
-        soft_endstop_max[axis] = base_max_pos(axis) + offs;
+        soft_endstop[axis].min = base_min_pos(axis) + offs;
+        soft_endstop[axis].max = base_max_pos(axis) + offs;
       }
 
     #else
 
-      soft_endstop_min[axis] = base_min_pos(axis);
-      soft_endstop_max[axis] = base_max_pos(axis);
+      soft_endstop[axis].min = base_min_pos(axis);
+      soft_endstop[axis].max = base_max_pos(axis);
 
     #endif
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
-        SERIAL_ECHOPAIR(" axis:\n soft_endstop_min = ", soft_endstop_min[axis]);
-        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
-      }
-    #endif
-  }
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING))
+      SERIAL_ECHOLNPAIR("Axis ", axis_codes[axis], " min:", soft_endstop[axis].min, " max:", soft_endstop[axis].max);
+  #endif
+}
 
-#endif // HAS_SOFTWARE_ENDSTOPS
+  /**
+   * Constrain the given coordinates to the software endstops.
+   *
+   * For DELTA/SCARA the XY constraint is based on the smallest
+   * radius within the set software endstops.
+   */
+  void apply_motion_limits(float target[XYZ]) {
 
-/**
- * Constrain the given coordinates to the software endstops.
- *
- * For DELTA/SCARA the XY constraint is based on the smallest
- * radius within the set software endstops.
- */
-void clamp_to_software_endstops(float target[XYZ]) {
+    if (!soft_endstops_enabled) return;
 
-  if (!soft_endstops_enabled) return;
+    #if IS_KINEMATIC
+
+      #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
+        // The effector center position will be the target minus the hotend offset.
+        const float offx = hotend_offset[X_AXIS][active_extruder], offy = hotend_offset[Y_AXIS][active_extruder];
+      #else
+        // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
+        constexpr float offx = 0, offy = 0;
+      #endif
 
-  #if IS_KINEMATIC
+      const float dist_2 = HYPOT2(target[X_AXIS] - offx, target[Y_AXIS] - offy);
+      if (dist_2 > delta_max_radius_2) {
+        const float ratio = (delta_max_radius) / SQRT(dist_2); // 200 / 300 = 0.66
+        target[X_AXIS] *= ratio;
+        target[Y_AXIS] *= ratio;
+      }
 
-    #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
-      // The effector center position will be the target minus the hotend offset.
-      const float offx = hotend_offset[X_AXIS][active_extruder], offy = hotend_offset[Y_AXIS][active_extruder];
     #else
-      // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
-      constexpr float offx = 0, offy = 0;
-    #endif
-
-    const float dist_2 = HYPOT2(target[X_AXIS] - offx, target[Y_AXIS] - offy);
-    if (dist_2 > soft_endstop_radius_2) {
-      const float ratio = (soft_endstop_radius) / SQRT(dist_2); // 200 / 300 = 0.66
-      target[X_AXIS] *= ratio;
-      target[Y_AXIS] *= ratio;
-    }
 
-  #else
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+        NOLESS(target[X_AXIS], soft_endstop[X_AXIS].min);
+      #endif
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+        NOMORE(target[X_AXIS], soft_endstop[X_AXIS].max);
+      #endif
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+        NOLESS(target[Y_AXIS], soft_endstop[Y_AXIS].min);
+      #endif
+      #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+        NOMORE(target[Y_AXIS], soft_endstop[Y_AXIS].max);
+      #endif
 
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-      NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
     #endif
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-      NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
-    #endif
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-      NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+      NOLESS(target[Z_AXIS], soft_endstop[Z_AXIS].min);
     #endif
-    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-      NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+      NOMORE(target[Z_AXIS], soft_endstop[Z_AXIS].max);
     #endif
+  }
 
-  #endif
-
-  #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-    NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
-  #endif
-  #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-    NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
-  #endif
-}
+#endif // HAS_SOFTWARE_ENDSTOPS
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
@@ -988,21 +985,21 @@ void clamp_to_software_endstops(float target[XYZ]) {
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position[E] and destination[E] are good
  * before calling or cold/lengthy extrusion may get missed.
  */
 void prepare_move_to_destination() {
-  clamp_to_software_endstops(destination);
+  apply_motion_limits(destination);
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
           }

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 057286c4c6..362cb7c4f6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -865,23 +865,27 @@ void clamp_to_software_endstops(float target[XYZ]) {
       }
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
-#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  bool extruder_duplication_enabled = false,                              // Used in Dual X mode 2 & 3
-       scaled_duplication_mode      = false;                              // Used in Dual X mode 2 & 3
+#if HAS_DUPLICATION_MODE
+  bool extruder_duplication_enabled;
+       //scaled_duplication_mode;
+#endif
+
+#if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
+  uint8_t duplication_e_mask; // = 0
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1

commit 11d6a939df86cd40a989d0ece33505927d4f93dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 20:57:54 2019 -0500

    Always define axis_unhomed_err

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 44266e24b1..057286c4c6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -40,21 +40,21 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if HAS_AXIS_UNHOMED_ERR && (ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI))
+#if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
@@ -1029,49 +1029,45 @@ void prepare_move_to_destination() {
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_from_destination();
 }
 
-#if HAS_AXIS_UNHOMED_ERR
-
-  bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
-    #if ENABLED(HOME_AFTER_DEACTIVATE)
-      const bool xx = x && !TEST(axis_known_position, X_AXIS),
-                 yy = y && !TEST(axis_known_position, Y_AXIS),
-                 zz = z && !TEST(axis_known_position, Z_AXIS);
-    #else
-      const bool xx = x && !TEST(axis_homed, X_AXIS),
-                 yy = y && !TEST(axis_homed, Y_AXIS),
-                 zz = z && !TEST(axis_homed, Z_AXIS);
+bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
+  #if ENABLED(HOME_AFTER_DEACTIVATE)
+    const bool xx = x && !TEST(axis_known_position, X_AXIS),
+               yy = y && !TEST(axis_known_position, Y_AXIS),
+               zz = z && !TEST(axis_known_position, Z_AXIS);
+  #else
+    const bool xx = x && !TEST(axis_homed, X_AXIS),
+               yy = y && !TEST(axis_homed, Y_AXIS),
+               zz = z && !TEST(axis_homed, Z_AXIS);
+  #endif
+  if (xx || yy || zz) {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_HOME " ");
+    if (xx) SERIAL_CHAR('X');
+    if (yy) SERIAL_CHAR('Y');
+    if (zz) SERIAL_CHAR('Z');
+    SERIAL_ECHOLNPGM(" " MSG_FIRST);
+
+    #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+      ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
     #endif
-    if (xx || yy || zz) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM(MSG_HOME " ");
-      if (xx) SERIAL_ECHOPGM(MSG_X);
-      if (yy) SERIAL_ECHOPGM(MSG_Y);
-      if (zz) SERIAL_ECHOPGM(MSG_Z);
-      SERIAL_ECHOLNPGM(" " MSG_FIRST);
-
-      #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
-        ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
-      #endif
-      return true;
-    }
-    return false;
+    return true;
   }
-
-#endif // HAS_AXIS_UNHOMED_ERR
+  return false;
+}
 
 /**
  * Homing bump feedrate (mm/s)
  */
 float get_homing_bump_feedrate(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c9973816c4..44266e24b1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -99,20 +99,31 @@ float current_position[XYZE] = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 float destination[XYZE]; // = { 0 }
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
+  void reset_hotend_offsets() {
+    constexpr float tmp[XYZ][HOTENDS] = { HOTEND_OFFSET_X, HOTEND_OFFSET_Y, HOTEND_OFFSET_Z };
+    static_assert(
+      tmp[X_AXIS][0] == 0 && tmp[Y_AXIS][0] == 0 && tmp[Z_AXIS][0] == 0,
+      "Offsets for the first hotend must be 0.0."
+    );
+    LOOP_XYZ(i) HOTEND_LOOP() hotend_offset[i][e] = tmp[i][e];
+    #if ENABLED(DUAL_X_CARRIAGE)
+      hotend_offset[X_AXIS][1] = MAX(X2_HOME_POS, X2_MAX_POS);
+    #endif
+  }
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 float feedrate_mm_s = MMM_TO_MMS(1500.0f);
 
 int16_t feedrate_percentage = 100;
 
@@ -123,25 +134,37 @@ const float homing_feedrate_mm_s[XYZ] PROGMEM = {
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z)
 };
 
 // Cartesian conversion result goes here:
 float cartes[XYZ];
 
 #if IS_KINEMATIC
+
   float delta[ABC];
-#endif
 
-#if HAS_SCARA_OFFSET
-  float scara_home_offset[ABC];
+  #if HAS_SCARA_OFFSET
+    float scara_home_offset[ABC];
+  #endif
+
+  #if HAS_SOFTWARE_ENDSTOPS
+    float soft_endstop_radius, soft_endstop_radius_2;
+  #elif IS_SCARA
+    constexpr float soft_endstop_radius = SCARA_PRINTABLE_RADIUS,
+                    soft_endstop_radius_2 = sq(SCARA_PRINTABLE_RADIUS);
+  #else // DELTA
+    constexpr float soft_endstop_radius = DELTA_PRINTABLE_RADIUS,
+                    soft_endstop_radius_2 = sq(DELTA_PRINTABLE_RADIUS);
+  #endif
+
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
 #if HAS_POSITION_SHIFT
   // The distance that XYZ has been offset by G92. Reset by G28.
   float position_shift[XYZ] = { 0 };
 #endif
@@ -433,80 +456,43 @@ void clean_up_after_endstop_or_probe_move() {
 }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   bool soft_endstops_enabled = true;
 
   // Software Endstops are based on the configured limits.
   float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
-  #if IS_KINEMATIC
-    float soft_endstop_radius, soft_endstop_radius_2;
-  #endif
-
-  /**
-   * Constrain the given coordinates to the software endstops.
-   *
-   * For DELTA/SCARA the XY constraint is based on the smallest
-   * radius within the set software endstops.
-   */
-  void clamp_to_software_endstops(float target[XYZ]) {
-    if (!soft_endstops_enabled) return;
-    #if IS_KINEMATIC
-      const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
-      if (dist_2 > soft_endstop_radius_2) {
-        const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
-        target[X_AXIS] *= ratio;
-        target[Y_AXIS] *= ratio;
-      }
-    #else
-      #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
-      #endif
-      #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
-      #endif
-      #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
-      #endif
-      #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
-      #endif
-    #endif
-    #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-      NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
-    #endif
-    #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-      NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
-    #endif
-  }
-
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
-  void update_software_endstops(const AxisEnum axis) {
+  void update_software_endstops(const AxisEnum axis
+    #if HAS_HOTEND_OFFSET
+      , const uint8_t old_tool_index/*=0*/, const uint8_t new_tool_index/*=0*/
+    #endif
+  ) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
-        if (active_extruder != 0) {
+        if (new_tool_index != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop_min[X_AXIS] = X2_MIN_POS;
           soft_endstop_max[X_AXIS] = dual_max_x;
         }
         else if (dxc_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop_min[X_AXIS] = X1_MIN_POS;
           soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
@@ -531,37 +517,105 @@ void clean_up_after_endstop_or_probe_move() {
         case Y_AXIS:
           // Get a minimum radius for clamping
           soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
           soft_endstop_radius_2 = sq(soft_endstop_radius);
           break;
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
 
+    #elif HAS_HOTEND_OFFSET
+
+      // Software endstops are relative to the tool 0 workspace, so
+      // the movement limits must be shifted by the tool offset to
+      // retain the same physical limit when other tools are selected.
+      if (old_tool_index != new_tool_index) {
+        const float offs = hotend_offset[axis][new_tool_index] - hotend_offset[axis][old_tool_index];
+        soft_endstop_min[axis] += offs;
+        soft_endstop_max[axis] += offs;
+      }
+      else {
+        const float offs = hotend_offset[axis][active_extruder];
+        soft_endstop_min[axis] = base_min_pos(axis) + offs;
+        soft_endstop_max[axis] = base_max_pos(axis) + offs;
+      }
+
     #else
 
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = base_max_pos(axis);
 
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
         SERIAL_ECHOPAIR(" axis:\n soft_endstop_min = ", soft_endstop_min[axis]);
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
   }
 
-#endif
+#endif // HAS_SOFTWARE_ENDSTOPS
+
+/**
+ * Constrain the given coordinates to the software endstops.
+ *
+ * For DELTA/SCARA the XY constraint is based on the smallest
+ * radius within the set software endstops.
+ */
+void clamp_to_software_endstops(float target[XYZ]) {
+
+  if (!soft_endstops_enabled) return;
+
+  #if IS_KINEMATIC
+
+    #if HAS_HOTEND_OFFSET && ENABLED(DELTA)
+      // The effector center position will be the target minus the hotend offset.
+      const float offx = hotend_offset[X_AXIS][active_extruder], offy = hotend_offset[Y_AXIS][active_extruder];
+    #else
+      // SCARA needs to consider the angle of the arm through the entire move, so for now use no tool offset.
+      constexpr float offx = 0, offy = 0;
+    #endif
+
+    const float dist_2 = HYPOT2(target[X_AXIS] - offx, target[Y_AXIS] - offy);
+    if (dist_2 > soft_endstop_radius_2) {
+      const float ratio = (soft_endstop_radius) / SQRT(dist_2); // 200 / 300 = 0.66
+      target[X_AXIS] *= ratio;
+      target[Y_AXIS] *= ratio;
+    }
+
+  #else
+
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+      NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
+    #endif
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+      NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
+    #endif
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+      NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+    #endif
+    #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+      NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+    #endif
+
+  #endif
+
+  #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+    NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
+  #endif
+  #if !HAS_SOFTWARE_ENDSTOPS || ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+    NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
+  #endif
+}
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.

commit 15738ea506a5dab194bfbcac7289527fbabe3fc7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 4 19:09:51 2019 -0600

    Update a motion comment

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 891947558f..c9973816c4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -78,21 +78,21 @@ XYZ_CONSTS(signed char, home_dir, HOME_DIR);
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 uint8_t axis_homed, axis_known_position; // = 0
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
- *   Used by 'buffer_line_to_current_position' to do a move after changing it.
+ *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 float current_position[XYZE] = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */

commit 99d0022fae0efd9164946062bf641f7294597675
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 1 00:27:45 2019 -0600

    Drop the Z_MIN_PROBE_ENDSTOP option (#13276)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 60a86c7d8d..891947558f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1302,21 +1302,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
           }
         #endif
 
       #elif ENABLED(DEBUG_LEVELING_FEATURE)
 
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP ***");
 
       #endif
     }
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       #if HAS_HOME_OFFSET
         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);

commit a2e3226597ee5fea26ad456d0287eeb223d78d86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 2 18:06:20 2018 -0600

    Init XYZ to configured home position

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b418f29884..60a86c7d8d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -81,29 +81,29 @@ uint8_t axis_homed, axis_known_position; // = 0
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
-float current_position[XYZE] = { 0 };
+float current_position[XYZE] = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
-float destination[XYZE] = { 0 };
+float destination[XYZE]; // = { 0 }
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   uint8_t active_extruder; // = 0
 #endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
 #endif

commit 5d28575d4d113aadf2f2c5a341b898e6a5b62d2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 25 14:28:01 2019 -0600

    Clean up some motion code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 481719b742..b418f29884 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -246,38 +246,38 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
   if (axis == ALL_AXES)
     COPY(current_position, cartes);
   else
     current_position[axis] = cartes[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position() {
-  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
+void line_to_current_position(const float &fr_mm_s/*=feedrate_mm_s*/) {
+  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s, active_extruder);
 }
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
 void buffer_line_to_destination(const float fr_mm_s) {
   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
 }
 
 #if IS_KINEMATIC
 
   /**
    * Calculate delta, start a line, and set current_position to destination
    */
-  void prepare_uninterpolated_move_to_destination(const float fr_mm_s/*=0.0*/) {
+  void prepare_uninterpolated_move_to_destination(const float &fr_mm_s/*=0.0*/) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
     #endif
 
     #if UBL_SEGMENTED
       // ubl segmented line will do z-only moves in single segment
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
@@ -290,33 +290,32 @@ void buffer_line_to_destination(const float fr_mm_s) {
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
-  const float old_feedrate_mm_s = feedrate_mm_s;
-
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
-  const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+  const float z_feedrate  = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS),
+              xy_feedrate = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
-    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+    REMEMBER(fr, feedrate_mm_s, xy_feedrate);
 
     set_destination_from_current();          // sync destination at the start
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
     #endif
 
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
       if (rz > delta_clip_start_height) {   // staying in the danger zone
@@ -366,95 +365,79 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
     set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
     if (destination[Z_AXIS] < rz) {
       destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(z_feedrate);
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
-    prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
+    prepare_uninterpolated_move_to_destination(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
     if (destination[Z_AXIS] > rz) {
       destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(z_feedrate);
     }
 
   #else
 
     // If Z needs to raise, do it before moving XY
     if (current_position[Z_AXIS] < rz) {
-      feedrate_mm_s = z_feedrate;
       current_position[Z_AXIS] = rz;
-      line_to_current_position();
+      line_to_current_position(z_feedrate);
     }
 
-    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
     current_position[X_AXIS] = rx;
     current_position[Y_AXIS] = ry;
-    line_to_current_position();
+    line_to_current_position(xy_feedrate);
 
     // If Z needs to lower, do it after moving XY
     if (current_position[Z_AXIS] > rz) {
-      feedrate_mm_s = z_feedrate;
       current_position[Z_AXIS] = rz;
-      line_to_current_position();
+      line_to_current_position(z_feedrate);
     }
 
   #endif
 
-  feedrate_mm_s = old_feedrate_mm_s;
-
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   #endif
 
   planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
-// Prepare to do endstop or probe moves
-// with custom feedrates.
-//
-//  - Save current feedrates
-//  - Reset the rate multiplier
+// Prepare to do endstop or probe moves with custom feedrates.
+//  - Save / restore current feedrate and multiplier
 //
-void bracket_probe_move(const bool before) {
-  static float saved_feedrate_mm_s;
-  static int16_t saved_feedrate_percentage;
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
-  #endif
-  if (before) {
-    saved_feedrate_mm_s = feedrate_mm_s;
-    saved_feedrate_percentage = feedrate_percentage;
-    feedrate_percentage = 100;
-  }
-  else {
-    feedrate_mm_s = saved_feedrate_mm_s;
-    feedrate_percentage = saved_feedrate_percentage;
-  }
+static float saved_feedrate_mm_s;
+static int16_t saved_feedrate_percentage;
+void setup_for_endstop_or_probe_move() {
+  saved_feedrate_mm_s = feedrate_mm_s;
+  saved_feedrate_percentage = feedrate_percentage;
+  feedrate_percentage = 100;
+}
+void clean_up_after_endstop_or_probe_move() {
+  feedrate_mm_s = saved_feedrate_mm_s;
+  feedrate_percentage = saved_feedrate_percentage;
 }
-
-void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
-void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   bool soft_endstops_enabled = true;
 
   // Software Endstops are based on the configured limits.
   float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
   #if IS_KINEMATIC

commit 808b076000e89fd7dae071bd2e4899833c872af6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 24 20:29:03 2019 -0600

    Update some ABL/UBL conditionals

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3f727b815f..481719b742 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -148,21 +148,21 @@ float cartes[XYZ];
 #if HAS_HOME_OFFSET
   // This offset is added to the configured home position.
   // Set by M206, M428, or menu item. Saved to EEPROM.
   float home_offset[XYZ] = { 0 };
 #endif
 #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   // The above two are combined to save on computes
   float workspace_offset[XYZ] = { 0 };
 #endif
 
-#if OLDSCHOOL_ABL
+#if HAS_ABL_NOT_UBL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
   SERIAL_ECHOPAIR("X:", LOGICAL_X_POSITION(current_position[X_AXIS]));
   SERIAL_ECHOPAIR(" Y:", LOGICAL_Y_POSITION(current_position[Y_AXIS]));
   SERIAL_ECHOPAIR(" Z:", LOGICAL_Z_POSITION(current_position[Z_AXIS]));

commit be9a409980a71e6dc15baf363791158b49d7450a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 14 05:25:29 2019 -0600

    Fix M125 XY parameters, export get_homing_bump_feedrate

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b20fe2fab9..3f727b815f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -287,21 +287,21 @@ void buffer_line_to_destination(const float fr_mm_s) {
 
       planner.buffer_line(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     #endif
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
- *  Plan a move to (X, Y, Z) and set the current_position
+ * Plan a move to (X, Y, Z) and set the current_position
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
 
@@ -1025,21 +1025,21 @@ void prepare_move_to_destination() {
       return true;
     }
     return false;
   }
 
 #endif // HAS_AXIS_UNHOMED_ERR
 
 /**
  * Homing bump feedrate (mm/s)
  */
-inline float get_homing_bump_feedrate(const AxisEnum axis) {
+float get_homing_bump_feedrate(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 299fd32208..b20fe2fab9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 1bd9a630492e0b029c39e4c885c6a1f49dc0c6ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 6 04:59:22 2019 -0600

    Add HAS_EXTRA_ENDSTOPS macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e64d312342..299fd32208 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1414,21 +1414,21 @@ void homeaxis(const AxisEnum axis) {
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   #endif
 
   // Set flags for X, Y, Z motor locking
-  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #if HAS_EXTRA_ENDSTOPS
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
       #if Z_MULTI_ENDSTOPS
         case Z_AXIS:
       #endif
@@ -1492,21 +1492,21 @@ void homeaxis(const AxisEnum axis) {
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be stowed after trigger to rearm itself
       if (axis == Z_AXIS) set_bltouch_deployed(false);
     #endif
   }
 
-  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  #if HAS_EXTRA_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x2_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_x_lock(false);
           stepper.set_x2_lock(false);
         }

commit 0358ffcd4caf64b7e78449a4c184ed5b00dfdb72
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 23 19:25:57 2019 -0600

    Drop E element from `homing_feedrate_mm_s`

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3ec48b499f..e64d312342 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -110,27 +110,27 @@ float destination[XYZE] = { 0 };
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 float feedrate_mm_s = MMM_TO_MMS(1500.0f);
 
 int16_t feedrate_percentage = 100;
 
 // Homing feedrate is const progmem - compare to constexpr in the header
-const float homing_feedrate_mm_s[4] PROGMEM = {
+const float homing_feedrate_mm_s[XYZ] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
-  MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
+  MMM_TO_MMS(HOMING_FEEDRATE_Z)
 };
 
 // Cartesian conversion result goes here:
 float cartes[XYZ];
 
 #if IS_KINEMATIC
   float delta[ABC];
 #endif
 
 #if HAS_SCARA_OFFSET

commit c3cb449990e037ca02826596d4b54aafa51db55c
Author: mattfredwill <mattfredwill@gmail.com>
Date:   Sat Feb 2 08:09:01 2019 +0800

    TMC2130 dual-stepper Sensorless Homing (#13061)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 803ddbc8c0..3ec48b499f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1043,84 +1043,108 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
 #if ENABLED(SENSORLESS_HOMING)
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
-    sensorless_t stealth_states { false, false, false };
+    sensorless_t stealth_states { false, false, false, false, false, false, false };
 
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           stealth_states.x = tmc_enable_stallguard(stepperX);
+          #if AXIS_HAS_STALLGUARD(X2)
+            stealth_states.x2 = tmc_enable_stallguard(stepperX2);
+          #endif
           #if CORE_IS_XY && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #elif CORE_IS_XZ && Z_SENSORLESS
             stealth_states.z = tmc_enable_stallguard(stepperZ);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
           stealth_states.y = tmc_enable_stallguard(stepperY);
+          #if AXIS_HAS_STALLGUARD(Y2)
+            stealth_states.y2 = tmc_enable_stallguard(stepperY2);
+          #endif
           #if CORE_IS_XY && X_SENSORLESS
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Z_SENSORLESS
             stealth_states.z = tmc_enable_stallguard(stepperZ);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           stealth_states.z = tmc_enable_stallguard(stepperZ);
+          #if AXIS_HAS_STALLGUARD(Z2)
+            stealth_states.z2 = tmc_enable_stallguard(stepperZ2);
+          #endif
+          #if AXIS_HAS_STALLGUARD(Z3)
+            stealth_states.z3 = tmc_enable_stallguard(stepperZ3);
+          #endif
           #if CORE_IS_XZ && X_SENSORLESS
             stealth_states.x = tmc_enable_stallguard(stepperX);
           #elif CORE_IS_YZ && Y_SENSORLESS
             stealth_states.y = tmc_enable_stallguard(stepperY);
           #endif
           break;
       #endif
     }
     return stealth_states;
   }
 
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
           tmc_disable_stallguard(stepperX, enable_stealth.x);
+          #if AXIS_HAS_STALLGUARD(X2)
+            tmc_disable_stallguard(stepperX2, enable_stealth.x2);
+          #endif
           #if CORE_IS_XY && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #elif CORE_IS_XZ && Z_SENSORLESS
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
           tmc_disable_stallguard(stepperY, enable_stealth.y);
+          #if AXIS_HAS_STALLGUARD(Y2)
+            tmc_disable_stallguard(stepperY2, enable_stealth.y2);
+          #endif
           #if CORE_IS_XY && X_SENSORLESS
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Z_SENSORLESS
             tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
           tmc_disable_stallguard(stepperZ, enable_stealth.z);
+          #if AXIS_HAS_STALLGUARD(Z2)
+            tmc_disable_stallguard(stepperZ2, enable_stealth.z2);
+          #endif
+          #if AXIS_HAS_STALLGUARD(Z3)
+            tmc_disable_stallguard(stepperZ3, enable_stealth.z3);
+          #endif
           #if CORE_IS_XZ && X_SENSORLESS
             tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Y_SENSORLESS
             tmc_disable_stallguard(stepperY, enable_stealth.y);
           #endif
           break;
       #endif
     }
   }
 

commit 60cb36bef3644640f2eb1c9d2b30189e41e81ef2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 1 14:17:48 2019 -0700

    Misc. improvements (#12747)
    
    * Make ExtUI respect MAXTEMP limits
      - Temperatures are now clamped by MAXTEMP limits rather than arbitrary values.
    * Speed up USB init, add status
      - Speed up USB initialization
      - Show status message if init failed
    * Enable status messages for EXTENSIBLE_UI
    * Adjust max limit to MAX_TEMP - 15
    * Misc. tweaks to formatting, const, etc.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index be0a6cda80..803ddbc8c0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -40,21 +40,21 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if HAS_AXIS_UNHOMED_ERR && ENABLED(ULTRA_LCD)
+#if HAS_AXIS_UNHOMED_ERR && (ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI))
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
@@ -1012,21 +1012,21 @@ void prepare_move_to_destination() {
                  zz = z && !TEST(axis_homed, Z_AXIS);
     #endif
     if (xx || yy || zz) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM(MSG_HOME " ");
       if (xx) SERIAL_ECHOPGM(MSG_X);
       if (yy) SERIAL_ECHOPGM(MSG_Y);
       if (zz) SERIAL_ECHOPGM(MSG_Z);
       SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
-      #if ENABLED(ULTRA_LCD)
+      #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
         ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
       #endif
       return true;
     }
     return false;
   }
 
 #endif // HAS_AXIS_UNHOMED_ERR
 
 /**

commit c6e09c2689df184e60c572a628312ad9842582d9
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Tue Dec 18 19:43:38 2018 +0100

    [2.0.x] G33 clean up (#12648)
    
    Remove obsolete workarounds in G33 for the now fixed zprobe_zoffset bug

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f5a4deb015..be0a6cda80 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -532,21 +532,21 @@ void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
           soft_endstop_min[X_AXIS] = X1_MIN_POS;
           soft_endstop_max[X_AXIS] = X1_MAX_POS;
         }
       }
 
     #elif ENABLED(DELTA)
 
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height
       #if HAS_BED_PROBE
-        - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
+        - zprobe_zoffset
       #endif
       : base_max_pos(axis));
 
       switch (axis) {
         case X_AXIS:
         case Y_AXIS:
           // Get a minimum radius for clamping
           soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
           soft_endstop_radius_2 = sq(soft_endstop_radius);
           break;
@@ -1270,21 +1270,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
+      - zprobe_zoffset
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 532f73974c..f5a4deb015 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1039,54 +1039,92 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
 #if ENABLED(SENSORLESS_HOMING)
-
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
-  void sensorless_homing_per_axis(const AxisEnum axis, const bool enable/*=true*/) {
+  sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis) {
+    sensorless_t stealth_states { false, false, false };
+
+    switch (axis) {
+      default: break;
+      #if X_SENSORLESS
+        case X_AXIS:
+          stealth_states.x = tmc_enable_stallguard(stepperX);
+          #if CORE_IS_XY && Y_SENSORLESS
+            stealth_states.y = tmc_enable_stallguard(stepperY);
+          #elif CORE_IS_XZ && Z_SENSORLESS
+            stealth_states.z = tmc_enable_stallguard(stepperZ);
+          #endif
+          break;
+      #endif
+      #if Y_SENSORLESS
+        case Y_AXIS:
+          stealth_states.y = tmc_enable_stallguard(stepperY);
+          #if CORE_IS_XY && X_SENSORLESS
+            stealth_states.x = tmc_enable_stallguard(stepperX);
+          #elif CORE_IS_YZ && Z_SENSORLESS
+            stealth_states.z = tmc_enable_stallguard(stepperZ);
+          #endif
+          break;
+      #endif
+      #if Z_SENSORLESS
+        case Z_AXIS:
+          stealth_states.z = tmc_enable_stallguard(stepperZ);
+          #if CORE_IS_XZ && X_SENSORLESS
+            stealth_states.x = tmc_enable_stallguard(stepperX);
+          #elif CORE_IS_YZ && Y_SENSORLESS
+            stealth_states.y = tmc_enable_stallguard(stepperY);
+          #endif
+          break;
+      #endif
+    }
+    return stealth_states;
+  }
+
+  void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
-          tmc_stallguard(stepperX, enable);
+          tmc_disable_stallguard(stepperX, enable_stealth.x);
           #if CORE_IS_XY && Y_SENSORLESS
-            tmc_stallguard(stepperY, enable);
+            tmc_disable_stallguard(stepperY, enable_stealth.y);
           #elif CORE_IS_XZ && Z_SENSORLESS
-            tmc_stallguard(stepperZ, enable);
+            tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
-          tmc_stallguard(stepperY, enable);
+          tmc_disable_stallguard(stepperY, enable_stealth.y);
           #if CORE_IS_XY && X_SENSORLESS
-            tmc_stallguard(stepperX, enable);
+            tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Z_SENSORLESS
-            tmc_stallguard(stepperZ, enable);
+            tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
-          tmc_stallguard(stepperZ, enable);
+          tmc_disable_stallguard(stepperZ, enable_stealth.z);
           #if CORE_IS_XZ && X_SENSORLESS
-            tmc_stallguard(stepperX, enable);
+            tmc_disable_stallguard(stepperX, enable_stealth.x);
           #elif CORE_IS_YZ && Y_SENSORLESS
-            tmc_stallguard(stepperY, enable);
+            tmc_disable_stallguard(stepperY, enable_stealth.y);
           #endif
           break;
       #endif
     }
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
@@ -1119,29 +1157,33 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
+  #if ENABLED(SENSORLESS_HOMING)
+    sensorless_t stealth_states;
+  #endif
+
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_homing_per_axis(axis);
+      stealth_states = start_sensorless_homing_per_axis(axis);
     #endif
   }
 
   #if IS_SCARA
     // Tell the planner the axis is at 0
     current_position[axis] = 0;
     sync_plan_position();
     current_position[axis] = distance;
     planner.buffer_line(current_position, fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
@@ -1168,21 +1210,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(false);
     #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_homing_per_axis(axis, false);
+      end_sensorless_homing_per_axis(axis, stealth_states);
     #endif
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif

commit e874f9664c541b5a9f0d24149fba2b5956b623ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 30 14:25:43 2018 -0600

    Tweaks to endstops code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f223f939a7..532f73974c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1543,24 +1543,22 @@ void homeaxis(const AxisEnum axis) {
     // Delta homing treats the axes as normal linear axes.
 
     // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
       #endif
       do_homing_move(axis, delta_endstop_adj[axis] - (MIN_STEPS_PER_SEGMENT + 1) * planner.steps_to_mm[axis] * Z_HOME_DIR);
     }
 
-  #else
+  #else // CARTESIAN / CORE
 
-    // For cartesian/core machines,
-    // set the axis to its home position
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dab6e816bf..f223f939a7 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -156,28 +156,24 @@ float cartes[XYZ];
 #endif
 
 #if OLDSCHOOL_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
-  SERIAL_PROTOCOLPGM("X:");
-  SERIAL_PROTOCOL(LOGICAL_X_POSITION(current_position[X_AXIS]));
-  SERIAL_PROTOCOLPGM(" Y:");
-  SERIAL_PROTOCOL(LOGICAL_Y_POSITION(current_position[Y_AXIS]));
-  SERIAL_PROTOCOLPGM(" Z:");
-  SERIAL_PROTOCOL(LOGICAL_Z_POSITION(current_position[Z_AXIS]));
-  SERIAL_PROTOCOLPGM(" E:");
-  SERIAL_PROTOCOL(current_position[E_AXIS]);
+  SERIAL_ECHOPAIR("X:", LOGICAL_X_POSITION(current_position[X_AXIS]));
+  SERIAL_ECHOPAIR(" Y:", LOGICAL_Y_POSITION(current_position[Y_AXIS]));
+  SERIAL_ECHOPAIR(" Z:", LOGICAL_Z_POSITION(current_position[Z_AXIS]));
+  SERIAL_ECHOPAIR(" E:", current_position[E_AXIS]);
 
   stepper.report_positions();
 
   #if IS_SCARA
     scara_report_positions();
   #endif
 }
 
 /**
  * sync_plan_position
@@ -960,29 +956,27 @@ void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 void prepare_move_to_destination() {
   clamp_to_software_endstops(destination);
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-            SERIAL_ECHO_START();
-            SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+            SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
           if (ABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-            SERIAL_ECHO_START();
-            SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
@@ -1039,22 +1033,21 @@ void prepare_move_to_destination() {
  * Homing bump feedrate (mm/s)
  */
 inline float get_homing_bump_feedrate(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
+    SERIAL_ECHO_MSG("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
 #if ENABLED(SENSORLESS_HOMING)
 
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable/*=true*/) {

commit caca3c850324308645ff216efdd223b0c044a3c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 23 20:39:12 2018 -0600

    Use wait_for_bed with WAIT_FOR_BED_HEATER
    
    Addressing #12517

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ec888f12b5..dab6e816bf 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1113,21 +1113,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
       }
       SERIAL_ECHOLNPGM(")");
     }
   #endif
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
-      while (thermalManager.isHeatingBed()) safe_delay(200);
+      thermalManager.wait_for_bed();
       ui.reset_status();
     }
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9cd83907c1..ec888f12b5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1019,21 +1019,21 @@ void prepare_move_to_destination() {
     #endif
     if (xx || yy || zz) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM(MSG_HOME " ");
       if (xx) SERIAL_ECHOPGM(MSG_X);
       if (yy) SERIAL_ECHOPGM(MSG_Y);
       if (zz) SERIAL_ECHOPGM(MSG_Z);
       SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
       #if ENABLED(ULTRA_LCD)
-        lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
+        ui.status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
       #endif
       return true;
     }
     return false;
   }
 
 #endif // HAS_AXIS_UNHOMED_ERR
 
 /**
  * Homing bump feedrate (mm/s)
@@ -1114,21 +1114,21 @@ void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm
       SERIAL_ECHOLNPGM(")");
     }
   #endif
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
-      lcd_reset_status();
+      ui.reset_status();
     }
   #endif
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);

commit fd7fd55662f380c9015789e4af939d4a23894553
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Nov 9 21:58:04 2018 +0100

    Solve endstops issues (#12382)
    
    - Partially reverts #11900 and tries to solve #12336

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d549dc3cca..9cd83907c1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1515,20 +1515,34 @@ void homeaxis(const AxisEnum axis) {
           (*lock[1])(true);
           do_homing_move(axis, adj[0] - adj[1]);
         }
 
         stepper.set_z_lock(false);
         stepper.set_z2_lock(false);
         stepper.set_z3_lock(false);
       }
     #endif
 
+    // Reset flags for X, Y, Z motor locking
+    switch (axis) {
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        case X_AXIS:
+      #endif
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        case Y_AXIS:
+      #endif
+      #if Z_MULTI_ENDSTOPS
+        case Z_AXIS:
+      #endif
+      stepper.set_separate_multi_axis(false);
+      default: break;
+    }
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     sync_plan_position();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28

commit 525ea554a1e53cef7d60dfa8d33664a99bcd4a3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 8 10:55:18 2018 -0600

    Remove obsolete comments

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cd16ea6a9c..d549dc3cca 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -425,22 +425,20 @@ void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves
 // with custom feedrates.
 //
 //  - Save current feedrates
 //  - Reset the rate multiplier
-//  - Reset the command timeout
-//  - Enable the endstops (for endstop moves)
 //
 void bracket_probe_move(const bool before) {
   static float saved_feedrate_mm_s;
   static int16_t saved_feedrate_percentage;
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
   #endif
   if (before) {
     saved_feedrate_mm_s = feedrate_mm_s;
     saved_feedrate_percentage = feedrate_percentage;

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9463f11129..cd16ea6a9c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -122,25 +122,28 @@ const float homing_feedrate_mm_s[4] PROGMEM = {
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
 };
 
 // Cartesian conversion result goes here:
 float cartes[XYZ];
 
-// Until kinematics.cpp is created, create this here
 #if IS_KINEMATIC
   float delta[ABC];
 #endif
 
+#if HAS_SCARA_OFFSET
+  float scara_home_offset[ABC];
+#endif
+
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
 #if HAS_POSITION_SHIFT
   // The distance that XYZ has been offset by G92. Reset by G28.
   float position_shift[XYZ] = { 0 };
 #endif
 #if HAS_HOME_OFFSET
   // This offset is added to the configured home position.
@@ -445,29 +448,28 @@ void bracket_probe_move(const bool before) {
   }
   else {
     feedrate_mm_s = saved_feedrate_mm_s;
     feedrate_percentage = saved_feedrate_percentage;
   }
 }
 
 void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
 void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
-// Software Endstops are based on the configured limits.
-float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
-      soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
-
 #if HAS_SOFTWARE_ENDSTOPS
 
-  // Software Endstops are based on the configured limits.
   bool soft_endstops_enabled = true;
 
+  // Software Endstops are based on the configured limits.
+  float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
+        soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
+
   #if IS_KINEMATIC
     float soft_endstop_radius, soft_endstop_radius_2;
   #endif
 
   /**
    * Constrain the given coordinates to the software endstops.
    *
    * For DELTA/SCARA the XY constraint is based on the smallest
    * radius within the set software endstops.
    */
@@ -495,20 +497,93 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #endif
     #endif
     #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
     #endif
     #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
+  /**
+   * Software endstops can be used to monitor the open end of
+   * an axis that has a hardware endstop on the other end. Or
+   * they can prevent axes from moving past endstops and grinding.
+   *
+   * To keep doing their job as the coordinate system changes,
+   * the software endstop positions must be refreshed to remain
+   * at the same positions relative to the machine.
+   */
+  void update_software_endstops(const AxisEnum axis) {
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+
+      if (axis == X_AXIS) {
+
+        // In Dual X mode hotend_offset[X] is T1's home position
+        const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
+
+        if (active_extruder != 0) {
+          // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
+          soft_endstop_min[X_AXIS] = X2_MIN_POS;
+          soft_endstop_max[X_AXIS] = dual_max_x;
+        }
+        else if (dxc_is_duplicating()) {
+          // In Duplication Mode, T0 can move as far left as X1_MIN_POS
+          // but not so far to the right that T1 would move past the end
+          soft_endstop_min[X_AXIS] = X1_MIN_POS;
+          soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
+        }
+        else {
+          // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
+          soft_endstop_min[X_AXIS] = X1_MIN_POS;
+          soft_endstop_max[X_AXIS] = X1_MAX_POS;
+        }
+      }
+
+    #elif ENABLED(DELTA)
+
+      soft_endstop_min[axis] = base_min_pos(axis);
+      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height
+      #if HAS_BED_PROBE
+        - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
+      #endif
+      : base_max_pos(axis));
+
+      switch (axis) {
+        case X_AXIS:
+        case Y_AXIS:
+          // Get a minimum radius for clamping
+          soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
+          soft_endstop_radius_2 = sq(soft_endstop_radius);
+          break;
+        case Z_AXIS:
+          delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+        default: break;
+      }
+
+    #else
+
+      soft_endstop_min[axis] = base_min_pos(axis);
+      soft_endstop_max[axis] = base_max_pos(axis);
+
+    #endif
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
+        SERIAL_ECHOPAIR(" axis:\n soft_endstop_min = ", soft_endstop_min[axis]);
+        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
+      }
+    #endif
+  }
+
 #endif
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if IS_SCARA
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
@@ -1147,21 +1222,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
   SBI(axis_known_position, axis);
   SBI(axis_homed, axis);
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
-    update_software_endstops(axis);
+    update_workspace_offset(axis);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
@@ -1497,104 +1572,33 @@ void homeaxis(const AxisEnum axis) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
-#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
-
-  /**
-   * Software endstops can be used to monitor the open end of
-   * an axis that has a hardware endstop on the other end. Or
-   * they can prevent axes from moving past endstops and grinding.
-   *
-   * To keep doing their job as the coordinate system changes,
-   * the software endstop positions must be refreshed to remain
-   * at the same positions relative to the machine.
-   */
-  void update_software_endstops(const AxisEnum axis) {
-    #if HAS_HOME_OFFSET
-      workspace_offset[axis] = home_offset[axis] + position_shift[axis];
-    #endif
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      if (axis == X_AXIS) {
-
-        // In Dual X mode hotend_offset[X] is T1's home position
-        const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
-
-        if (active_extruder != 0) {
-          // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
-          soft_endstop_min[X_AXIS] = X2_MIN_POS;
-          soft_endstop_max[X_AXIS] = dual_max_x;
-        }
-        else if (dxc_is_duplicating()) {
-          // In Duplication Mode, T0 can move as far left as X1_MIN_POS
-          // but not so far to the right that T1 would move past the end
-          soft_endstop_min[X_AXIS] = X1_MIN_POS;
-          soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
-        }
-        else {
-          // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
-          soft_endstop_min[X_AXIS] = X1_MIN_POS;
-          soft_endstop_max[X_AXIS] = X1_MAX_POS;
-        }
-      }
-    #elif ENABLED(DELTA)
-      soft_endstop_min[axis] = base_min_pos(axis);
-      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height
-      #if HAS_BED_PROBE
-        - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
-      #endif
-      : base_max_pos(axis));
-    #else
-      soft_endstop_min[axis] = base_min_pos(axis);
-      soft_endstop_max[axis] = base_max_pos(axis);
-    #endif
-
+#if HAS_WORKSPACE_OFFSET
+  void update_workspace_offset(const AxisEnum axis) {
+    workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
-        #if HAS_HOME_OFFSET
-          SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
-        #endif
-        #if HAS_POSITION_SHIFT
-          SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
-        #endif
-        SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
-        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
-      }
-    #endif
-
-    #if ENABLED(DELTA)
-      switch (axis) {
-        #if HAS_SOFTWARE_ENDSTOPS
-          case X_AXIS:
-          case Y_AXIS:
-            // Get a minimum radius for clamping
-            soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
-            soft_endstop_radius_2 = sq(soft_endstop_radius);
-            break;
-        #endif
-        case Z_AXIS:
-          delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
-        default: break;
+        SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
+        SERIAL_ECHOLNPAIR("\n position_shift = ", position_shift[axis]);
       }
     #endif
   }
-
-#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE || DELTA
+#endif
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;
-    update_software_endstops(axis);
+    update_workspace_offset(axis);
   }
 #endif // HAS_M206_COMMAND

commit 2c9586be0cb55fc821b50413287735ff83f0d321
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:39:15 2018 -0500

    Clear up HAS_WORKSPACE_OFFSET meaning

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 95c5522a08..9463f11129 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -131,34 +131,32 @@ float cartes[XYZ];
 
 // Until kinematics.cpp is created, create this here
 #if IS_KINEMATIC
   float delta[ABC];
 #endif
 
 /**
  * The workspace can be offset by some commands, or
  * these offsets may be omitted to save on computation.
  */
-#if HAS_WORKSPACE_OFFSET
-  #if HAS_POSITION_SHIFT
-    // The distance that XYZ has been offset by G92. Reset by G28.
-    float position_shift[XYZ] = { 0 };
-  #endif
-  #if HAS_HOME_OFFSET
-    // This offset is added to the configured home position.
-    // Set by M206, M428, or menu item. Saved to EEPROM.
-    float home_offset[XYZ] = { 0 };
-  #endif
-  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-    // The above two are combined to save on computes
-    float workspace_offset[XYZ] = { 0 };
-  #endif
+#if HAS_POSITION_SHIFT
+  // The distance that XYZ has been offset by G92. Reset by G28.
+  float position_shift[XYZ] = { 0 };
+#endif
+#if HAS_HOME_OFFSET
+  // This offset is added to the configured home position.
+  // Set by M206, M428, or menu item. Saved to EEPROM.
+  float home_offset[XYZ] = { 0 };
+#endif
+#if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+  // The above two are combined to save on computes
+  float workspace_offset[XYZ] = { 0 };
 #endif
 
 #if OLDSCHOOL_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
@@ -1511,21 +1509,21 @@ void homeaxis(const AxisEnum axis) {
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
   void update_software_endstops(const AxisEnum axis) {
-    #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+    #if HAS_HOME_OFFSET
       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {

commit 44f2a82a567333312c3d85f72176f437bafc9625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:07:52 2018 -0500

    Move axis_homed, axis_known_position to motion.*

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 202bb12cb3..95c5522a08 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -61,20 +61,31 @@
 
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
+/**
+ * axis_homed
+ *   Flags that each linear axis was homed.
+ *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
+ *
+ * axis_known_position
+ *   Flags that the position is known in each linear axis. Set when homed.
+ *   Cleared whenever a stepper powers off, potentially losing its position.
+ */
+uint8_t axis_homed, axis_known_position; // = 0
+
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0 };

commit 553622835911b520c6ba43bc03e71868f3972cb3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Oct 29 20:01:36 2018 +0100

    G34 Auto-align multi-stepper Z axis (#11302)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 22d071f65d..202bb12cb3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1202,20 +1202,48 @@ void set_axis_is_at_home(const AxisEnum axis) {
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.homed(axis);
   #endif
 }
 
+/**
+ * Set an axis' to be unhomed.
+ */
+void set_axis_is_not_at_home(const AxisEnum axis) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> set_axis_is_not_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  CBI(axis_known_position, axis);
+  CBI(axis_homed, axis);
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< set_axis_is_not_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    I2CPEM.unhomed(axis);
+  #endif
+}
+
 /**
  * Home an individual "raw axis" to its endstop.
  * This applies to XYZ on Cartesian and Core robots, and
  * to the individual ABC steppers on DELTA and SCARA.
  *
  * At the end of the procedure the axis is marked as
  * homed and the current position of that axis is updated.
  * Kinematic robots should wait till all axes are homed
  * before updating the current position.
  */
@@ -1253,31 +1281,21 @@ void homeaxis(const AxisEnum axis) {
 
   // Set flags for X, Y, Z motor locking
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
-      #if ENABLED(Z_DUAL_ENDSTOPS)
-        case Z_AXIS:
-      #endif
-      stepper.set_separate_multi_axis(true);
-      default: break;
-    }
-  #endif
-
-  #if ENABLED(Z_TRIPLE_ENDSTOPS)
-    switch (axis) {
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      #if Z_MULTI_ENDSTOPS
         case Z_AXIS:
       #endif
       stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");

commit 53c535a0c151418d362169c06ba1f1dfbf6e420a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 25 09:45:57 2018 -0500

    Remove trailing whitespace

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5f5d256f0c..22d071f65d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1153,21 +1153,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
     current_position[axis] = (axis == Z_AXIS ? delta_height
     #if HAS_BED_PROBE
-      - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER    
+      - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
     #endif
     : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0

commit 7243101135abc42e0e3c5acf61e52979793e899f
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Oct 25 16:11:26 2018 +0200

    z_offset fix for deltas (#12210)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index bc28c778c3..5f5d256f0c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1151,21 +1151,25 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #elif ENABLED(DELTA)
-    current_position[axis] = (axis == Z_AXIS ? delta_height : base_home_pos(axis));
+    current_position[axis] = (axis == Z_AXIS ? delta_height
+    #if HAS_BED_PROBE
+      - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER    
+    #endif
+    : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
@@ -1507,21 +1511,25 @@ void homeaxis(const AxisEnum axis) {
           soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
           soft_endstop_min[X_AXIS] = X1_MIN_POS;
           soft_endstop_max[X_AXIS] = X1_MAX_POS;
         }
       }
     #elif ENABLED(DELTA)
       soft_endstop_min[axis] = base_min_pos(axis);
-      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis));
+      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height
+      #if HAS_BED_PROBE
+        - zprobe_zoffset + Z_PROBE_OFFSET_FROM_EXTRUDER
+      #endif
+      : base_max_pos(axis));
     #else
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = base_max_pos(axis);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
         #if HAS_HOME_OFFSET
           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dbf85e4548..bc28c778c3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -810,23 +810,23 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
 
             #define CUR_X    current_position[X_AXIS]
             #define CUR_Y    current_position[Y_AXIS]
             #define CUR_Z    current_position[Z_AXIS]
             #define CUR_E    current_position[E_AXIS]
             #define RAISED_X raised_parked_position[X_AXIS]
             #define RAISED_Y raised_parked_position[Y_AXIS]
             #define RAISED_Z raised_parked_position[Z_AXIS]
 
-            if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder))
+            if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder))
               if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
-                  planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+                  planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
         case DXC_SCALED_DUPLICATION_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -834,21 +834,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
               }
             #endif
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 
             if (!planner.buffer_line(
                 dual_x_carriage_mode == DXC_DUPLICATION_MODE ? duplicate_extruder_x_offset + current_position[X_AXIS] : inactive_extruder_x_pos,
                 current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
-                planner.max_feedrate_mm_s[X_AXIS], 1
+                planner.settings.max_feedrate_mm_s[X_AXIS], 1
               )
             ) break;
             planner.synchronize();
             sync_plan_position();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }

commit 3c40933713c268dd057f850e3190f3c6f4c39751
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 30 20:42:47 2018 -0500

    Remove trailing spaces, old comment

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8f8965576a..dbf85e4548 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -280,21 +280,20 @@ void buffer_line_to_destination(const float fr_mm_s) {
       planner.buffer_line(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     #endif
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
- *  The final current_position may not be the one that was requested
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
 

commit b30ca652aed417be0ba8857922c1cf2b4df26f2d
Author: AnoNymous <dgdanielf@gmail.com>
Date:   Sun Sep 30 11:59:14 2018 +0200

    Replace MIN# / MAX# with variadic MIN / MAX (#11960)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 91487d28e5..8f8965576a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1534,21 +1534,21 @@ void homeaxis(const AxisEnum axis) {
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
 
     #if ENABLED(DELTA)
       switch (axis) {
         #if HAS_SOFTWARE_ENDSTOPS
           case X_AXIS:
           case Y_AXIS:
             // Get a minimum radius for clamping
-            soft_endstop_radius = MIN3(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
+            soft_endstop_radius = MIN(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
             soft_endstop_radius_2 = sq(soft_endstop_radius);
             break;
         #endif
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
     #endif
   }
 

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a08482166a..91487d28e5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -974,45 +974,45 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
 #if ENABLED(SENSORLESS_HOMING)
 
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable/*=true*/) {
     switch (axis) {
       default: break;
       #if X_SENSORLESS
         case X_AXIS:
-          tmc_sensorless_homing(stepperX, enable);
+          tmc_stallguard(stepperX, enable);
           #if CORE_IS_XY && Y_SENSORLESS
-            tmc_sensorless_homing(stepperY, enable);
+            tmc_stallguard(stepperY, enable);
           #elif CORE_IS_XZ && Z_SENSORLESS
-            tmc_sensorless_homing(stepperZ, enable);
+            tmc_stallguard(stepperZ, enable);
           #endif
           break;
       #endif
       #if Y_SENSORLESS
         case Y_AXIS:
-          tmc_sensorless_homing(stepperY, enable);
+          tmc_stallguard(stepperY, enable);
           #if CORE_IS_XY && X_SENSORLESS
-            tmc_sensorless_homing(stepperX, enable);
+            tmc_stallguard(stepperX, enable);
           #elif CORE_IS_YZ && Z_SENSORLESS
-            tmc_sensorless_homing(stepperZ, enable);
+            tmc_stallguard(stepperZ, enable);
           #endif
           break;
       #endif
       #if Z_SENSORLESS
         case Z_AXIS:
-          tmc_sensorless_homing(stepperZ, enable);
+          tmc_stallguard(stepperZ, enable);
           #if CORE_IS_XZ && X_SENSORLESS
-            tmc_sensorless_homing(stepperX, enable);
+            tmc_stallguard(stepperX, enable);
           #elif CORE_IS_YZ && Y_SENSORLESS
-            tmc_sensorless_homing(stepperY, enable);
+            tmc_stallguard(stepperY, enable);
           #endif
           break;
       #endif
     }
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis

commit 1104054d7347668a61e90fb6216e22afae2ef9f3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Sep 24 10:40:48 2018 -0400

    2.0 IDEX Independent z offset and other fixes (#11862)
    
    * Add Formbot Raptor board
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Add a second Z probe Z offset
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Modify method to utilize live adjustment of hotend z offset
    
    Should probably move config option to babystepping and rename as it may now apply to all multiextruder systems
    
    * Move config item and catchup other code to current method

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index caab4f73ab..a08482166a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1495,29 +1495,29 @@ void homeaxis(const AxisEnum axis) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop_min[X_AXIS] = X2_MIN_POS;
           soft_endstop_max[X_AXIS] = dual_max_x;
         }
         else if (dxc_is_duplicating()) {
-          // In Duplication Mode, T0 can move as far left as X_MIN_POS
+          // In Duplication Mode, T0 can move as far left as X1_MIN_POS
           // but not so far to the right that T1 would move past the end
-          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
-          soft_endstop_max[X_AXIS] = MIN(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
+          soft_endstop_min[X_AXIS] = X1_MIN_POS;
+          soft_endstop_max[X_AXIS] = MIN(X1_MAX_POS, dual_max_x - duplicate_extruder_x_offset);
         }
         else {
-          // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
-          soft_endstop_min[axis] = base_min_pos(axis);
-          soft_endstop_max[axis] = base_max_pos(axis);
+          // In other modes, T0 can move from X1_MIN_POS to X1_MAX_POS
+          soft_endstop_min[X_AXIS] = X1_MIN_POS;
+          soft_endstop_max[X_AXIS] = X1_MAX_POS;
         }
       }
     #elif ENABLED(DELTA)
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis));
     #else
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = base_max_pos(axis);
     #endif
 

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5094a0952a..caab4f73ab 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -575,21 +575,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 },
                 cartesian_segment_mm = cartesian_mm * inv_segments;
-    
+
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float inv_duration = _feedrate_mm_s / cartesian_segment_mm;
     #endif
 
     /*
     SERIAL_ECHOPAIR("mm=", cartesian_mm);
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
     SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 06db3caf04..5094a0952a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -753,21 +753,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false,                              // Used in Dual X mode 2 & 3
-       symmetric_duplication_mode   = false;                              // Used in Dual X mode 2 & 3
+       scaled_duplication_mode      = false;                              // Used in Dual X mode 2 & 3
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
@@ -811,62 +811,64 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
 
             #define CUR_X    current_position[X_AXIS]
             #define CUR_Y    current_position[Y_AXIS]
             #define CUR_Z    current_position[Z_AXIS]
             #define CUR_E    current_position[E_AXIS]
             #define RAISED_X raised_parked_position[X_AXIS]
             #define RAISED_Y raised_parked_position[Y_AXIS]
             #define RAISED_Z raised_parked_position[Z_AXIS]
 
-            //SERIAL_ECHOLNPGM("dual_x_carriage_unpark()\n");
-
             if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder))
               if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
                   planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
+        case DXC_SCALED_DUPLICATION_MODE:
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
               }
             #endif
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+
             if (!planner.buffer_line(
-              current_position[X_AXIS] + duplicate_extruder_x_offset,
-              current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
-              planner.max_feedrate_mm_s[X_AXIS], 1)
+                dual_x_carriage_mode == DXC_DUPLICATION_MODE ? duplicate_extruder_x_offset + current_position[X_AXIS] : inactive_extruder_x_pos,
+                current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
+                planner.max_feedrate_mm_s[X_AXIS], 1
+              )
             ) break;
             planner.synchronize();
             sync_plan_position();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
             #endif
           }
           break;
       }
     }
+    stepper.set_directions();
     return false;
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
@@ -899,23 +901,23 @@ void prepare_move_to_destination() {
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
 
   if (
     #if UBL_SEGMENTED
-//    ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))   // This does not seem to work correctly on UBL.
-      #if ENABLED(DELTA)                                                      // A Delta case and a Cartesian case can work
-        ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)) // around the problem until it is fixed.
+      //ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))   // This doesn't seem to work correctly on UBL.
+      #if IS_KINEMATIC                                                          // Use Kinematic / Cartesian cases as a workaround for now.
+        ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
       #else
         prepare_move_to_destination_cartesian()
       #endif
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
@@ -1492,21 +1494,21 @@ void homeaxis(const AxisEnum axis) {
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop_min[X_AXIS] = X2_MIN_POS;
           soft_endstop_max[X_AXIS] = dual_max_x;
         }
-        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
+        else if (dxc_is_duplicating()) {
           // In Duplication Mode, T0 can move as far left as X_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
           soft_endstop_max[X_AXIS] = MIN(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
           soft_endstop_min[axis] = base_min_pos(axis);
           soft_endstop_max[axis] = base_max_pos(axis);
         }

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dee9983b1b..06db3caf04 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -68,21 +68,21 @@ XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
- *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
+ *   Used by 'sync_plan_position' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0 };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0 };
@@ -211,29 +211,36 @@ void get_cartesian_from_steppers() {
     cartes[Z_AXIS] = planner.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
- * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
+ * sync_plan_position after updating axes with this.
  *
  * To keep hosts in sync, always call report_current_position
  * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
-  #if PLANNER_LEVELING
-    planner.unapply_leveling(cartes);
+
+  #if HAS_POSITION_MODIFIERS
+    float pos[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], current_position[E_AXIS] };
+    planner.unapply_modifiers(pos
+      #if HAS_LEVELING
+        , true
+      #endif
+    );
+    const float (&cartes)[XYZE] = pos;
   #endif
   if (axis == ALL_AXES)
     COPY(current_position, cartes);
   else
     current_position[axis] = cartes[axis];
 }
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
@@ -245,46 +252,39 @@ void line_to_current_position() {
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
 void buffer_line_to_destination(const float fr_mm_s) {
   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
 }
 
 #if IS_KINEMATIC
 
-  void sync_plan_position_kinematic() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
-    #endif
-    planner.set_position_mm_kinematic(current_position);
-  }
-
   /**
    * Calculate delta, start a line, and set current_position to destination
    */
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s/*=0.0*/) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
     #endif
 
     #if UBL_SEGMENTED
       // ubl segmented line will do z-only moves in single segment
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
 
-      planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
+      planner.buffer_line(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     #endif
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
@@ -531,21 +531,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
 
     // If the move is only in Z/E don't split up the move
     if (!xdiff && !ydiff) {
-      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
+      planner.buffer_line(rtarget, _feedrate_mm_s, active_extruder);
       return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
 
     // Remaining cartesian distances
     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
 
@@ -573,154 +573,65 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0f / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
-                };
-
-    #if !HAS_FEEDRATE_SCALING
-      const float cartesian_segment_mm = cartesian_mm * inv_segments;
+                },
+                cartesian_segment_mm = cartesian_mm * inv_segments;
+    
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      const float inv_duration = _feedrate_mm_s / cartesian_segment_mm;
     #endif
 
     /*
     SERIAL_ECHOPAIR("mm=", cartesian_mm);
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
-    #if !HAS_FEEDRATE_SCALING
-      SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
-    #endif
+    SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     SERIAL_EOL();
     //*/
 
-    #if HAS_FEEDRATE_SCALING
-      // SCARA needs to scale the feed rate from mm/s to degrees/s
-      // i.e., Complete the angular vector in the given time.
-      const float segment_length = cartesian_mm * inv_segments,
-                  inv_segment_length = 1.0f / segment_length, // 1/mm/segs
-                  inverse_secs = inv_segment_length * _feedrate_mm_s;
-
-      float oldA = planner.position_float[A_AXIS],
-            oldB = planner.position_float[B_AXIS]
-            #if ENABLED(DELTA_FEEDRATE_SCALING)
-              , oldC = planner.position_float[C_AXIS]
-            #endif
-            ;
-
-      /*
-      SERIAL_ECHOPGM("Scaled kinematic move: ");
-      SERIAL_ECHOPAIR(" segment_length (inv)=", segment_length);
-      SERIAL_ECHOPAIR(" (", inv_segment_length);
-      SERIAL_ECHOPAIR(") _feedrate_mm_s=", _feedrate_mm_s);
-      SERIAL_ECHOPAIR(" inverse_secs=", inverse_secs);
-      SERIAL_ECHOPAIR(" oldA=", oldA);
-      SERIAL_ECHOPAIR(" oldB=", oldB);
-      #if ENABLED(DELTA_FEEDRATE_SCALING)
-        SERIAL_ECHOPAIR(" oldC=", oldC);
-      #endif
-      SERIAL_EOL();
-      safe_delay(5);
-      //*/
-    #endif
-
-     // Get the current position as starting point
+    // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
     // Calculate and execute the segments
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
-      #if ENABLED(DELTA) && HOTENDS < 2
-        DELTA_IK(raw); // Delta can inline its kinematics
-      #else
-        inverse_kinematics(raw);
-      #endif
-      ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
-
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        // For SCARA scale the feed rate from mm/s to degrees/s
-        // i.e., Complete the angular vector in the given time.
-        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, segment_length))
-          break;
-        /*
-        SERIAL_ECHO(segments);
-        SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
-        SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
-        SERIAL_ECHOLNPAIR(" F", HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs * 60);
-        safe_delay(5);
-        //*/
-        oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
-      #elif ENABLED(DELTA_FEEDRATE_SCALING)
-        // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
-        // i.e., Complete the linear vector in the given time.
-        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder, segment_length))
-          break;
-        /*
-        SERIAL_ECHO(segments);
-        SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
-        SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
-        SERIAL_ECHOLNPAIR(" F", SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs * 60);
-        safe_delay(5);
-        //*/
-        oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
-      #else
-        if (!planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm))
-          break;
-      #endif
+      if (!planner.buffer_line(raw, _feedrate_mm_s, active_extruder, cartesian_segment_mm
+        #if ENABLED(SCARA_FEEDRATE_SCALING)
+          , inv_duration
+        #endif
+      ))
+        break;
     }
 
     // Ensure last segment arrives at target location.
-    #if HAS_FEEDRATE_SCALING
-      inverse_kinematics(rtarget);
-      ADJUST_DELTA(rtarget);
-    #endif
-
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
-      if (diff2) {
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, segment_length);
-        /*
-        SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
-        SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB);
-        SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
-        SERIAL_EOL();
-        safe_delay(5);
-        //*/
-      }
-    #elif ENABLED(DELTA_FEEDRATE_SCALING)
-      const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
-      if (diff2) {
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, segment_length);
-        /*
-        SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
-        SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB); SERIAL_ECHOPAIR(" cdiff=", delta[C_AXIS] - oldC);
-        SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
-        SERIAL_EOL();
-        safe_delay(5);
-        //*/
-      }
-    #else
-      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
-    #endif
+    planner.buffer_line(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        , inv_duration
+      #endif
+    );
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
@@ -729,21 +640,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
      * small incremental moves. This allows the planner to
      * apply more detailed bed leveling to the full move.
      */
     inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
 
       const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
                   ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
 
       // If the move is only in Z/E don't split up the move
       if (!xdiff && !ydiff) {
-        planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
+        planner.buffer_line(destination, fr_mm_s, active_extruder);
         return;
       }
 
       // Remaining cartesian distances
       const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
                   ediff = destination[E_AXIS] - current_position[E_AXIS];
 
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
@@ -759,44 +670,56 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       // The approximate length of each segment
       const float inv_segments = 1.0f / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments,
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };
 
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        const float inv_duration = _feedrate_mm_s / cartesian_segment_mm;
+      #endif
+
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
       // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       float raw[XYZE];
       COPY(raw, current_position);
 
       // Calculate and execute the segments
       while (--segments) {
         static millis_t next_idle_ms = millis() + 200UL;
         thermalManager.manage_heater();  // This returns immediately if not really needed.
         if (ELAPSED(millis(), next_idle_ms)) {
           next_idle_ms = millis() + 200UL;
           idle();
         }
         LOOP_XYZE(i) raw[i] += segment_distance[i];
-        if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder, cartesian_segment_mm))
+        if (!planner.buffer_line(raw, fr_mm_s, active_extruder, cartesian_segment_mm
+          #if ENABLED(SCARA_FEEDRATE_SCALING)
+            , inv_duration
+          #endif
+        ))
           break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
-      planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder, cartesian_segment_mm);
+      planner.buffer_line(destination, fr_mm_s, active_extruder, cartesian_segment_mm
+        #if ENABLED(SCARA_FEEDRATE_SCALING)
+          , inv_duration
+        #endif
+      );
     }
 
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
@@ -915,21 +838,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
               }
             #endif
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
             if (!planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
               planner.max_feedrate_mm_s[X_AXIS], 1)
             ) break;
             planner.synchronize();
-            SYNC_PLAN_POSITION_KINEMATIC();
+            sync_plan_position();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
             #endif
@@ -1085,21 +1008,21 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
           break;
       #endif
     }
   }
 
 #endif // SENSORLESS_HOMING
 
 /**
  * Home an individual linear axis
  */
-static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
+void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPGM(", ");
       if (fr_mm_s)
         SERIAL_ECHO(fr_mm_s);
       else {
         SERIAL_ECHOPAIR("[", homing_feedrate(axis));
@@ -1132,32 +1055,43 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(true);
     #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis);
     #endif
   }
 
-  // Tell the planner the axis is at 0
-  current_position[axis] = 0;
-
   #if IS_SCARA
-    SYNC_PLAN_POSITION_KINEMATIC();
+    // Tell the planner the axis is at 0
+    current_position[axis] = 0;
+    sync_plan_position();
     current_position[axis] = distance;
-    inverse_kinematics(current_position);
-    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+    planner.buffer_line(current_position, fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
-    sync_plan_position();
-    current_position[axis] = distance; // Set delta/cartesian axes directly
-    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+    float target[ABCE] = { planner.get_axis_position_mm(A_AXIS), planner.get_axis_position_mm(B_AXIS), planner.get_axis_position_mm(C_AXIS), planner.get_axis_position_mm(E_AXIS) };
+    target[axis] = 0;
+    planner.set_machine_position_mm(target);
+    target[axis] = distance;
+
+    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      const float delta_mm_cart[XYZE] = {0, 0, 0, 0};
+    #endif
+
+    // Set delta/cartesian axes directly
+    planner.buffer_segment(target
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , delta_mm_cart
+      #endif
+      , fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder
+    );
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
     #if HOMING_Z_WITH_PROBE && QUIET_PROBING
       if (axis == Z_AXIS) probing_pause(false);
     #endif
 
@@ -1342,21 +1276,28 @@ void homeaxis(const AxisEnum axis) {
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be deployed every time
     if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
   #endif
 
-  do_homing_move(axis, 1.5f * max_length(axis) * axis_home_dir);
+  do_homing_move(axis, 1.5f * max_length(
+    #if ENABLED(DELTA)
+      Z_AXIS
+    #else
+      axis
+    #endif
+    ) * axis_home_dir
+  );
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be stowed after trigger to rearm itself
     if (axis == Z_AXIS) set_bltouch_deployed(false);
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
@@ -1474,21 +1415,21 @@ void homeaxis(const AxisEnum axis) {
         stepper.set_z2_lock(false);
         stepper.set_z3_lock(false);
       }
     #endif
 
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
-    SYNC_PLAN_POSITION_KINEMATIC();
+    sync_plan_position();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
     // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d77a647314..dee9983b1b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1306,32 +1306,42 @@ void homeaxis(const AxisEnum axis) {
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   #endif
 
   // Set flags for X, Y, Z motor locking
-  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
       #endif
       #if ENABLED(Z_DUAL_ENDSTOPS)
         case Z_AXIS:
       #endif
-      stepper.set_homing_dual_axis(true);
+      stepper.set_separate_multi_axis(true);
+      default: break;
+    }
+  #endif
+
+  #if ENABLED(Z_TRIPLE_ENDSTOPS)
+    switch (axis) {
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        case Z_AXIS:
+      #endif
+      stepper.set_separate_multi_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
@@ -1377,56 +1387,102 @@ void homeaxis(const AxisEnum axis) {
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be stowed after trigger to rearm itself
       if (axis == Z_AXIS) set_bltouch_deployed(false);
     #endif
   }
 
-  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
-        const float adj = ABS(endstops.x_endstop_adj);
+        const float adj = ABS(endstops.x2_endstop_adj);
         if (adj) {
-          if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
+          if (pos_dir ? (endstops.x2_endstop_adj > 0) : (endstops.x2_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_x_lock(false);
           stepper.set_x2_lock(false);
         }
       }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       if (axis == Y_AXIS) {
-        const float adj = ABS(endstops.y_endstop_adj);
+        const float adj = ABS(endstops.y2_endstop_adj);
         if (adj) {
-          if (pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
+          if (pos_dir ? (endstops.y2_endstop_adj > 0) : (endstops.y2_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_y_lock(false);
           stepper.set_y2_lock(false);
         }
       }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       if (axis == Z_AXIS) {
-        const float adj = ABS(endstops.z_endstop_adj);
+        const float adj = ABS(endstops.z2_endstop_adj);
         if (adj) {
-          if (pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+          if (pos_dir ? (endstops.z2_endstop_adj > 0) : (endstops.z2_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_z_lock(false);
           stepper.set_z2_lock(false);
         }
       }
     #endif
-    stepper.set_homing_dual_axis(false);
+    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      if (axis == Z_AXIS) {
+        // we push the function pointers for the stepper lock function into an array
+        void (*lock[3]) (bool)= {&stepper.set_z_lock, &stepper.set_z2_lock, &stepper.set_z3_lock};
+        float adj[3] = {0, endstops.z2_endstop_adj, endstops.z3_endstop_adj};
+
+        void (*tempLock) (bool);
+        float tempAdj;
+
+        // manual bubble sort by adjust value
+        if (adj[1] < adj[0]) {
+          tempLock = lock[0], tempAdj = adj[0];
+          lock[0] = lock[1], adj[0] = adj[1];
+          lock[1] = tempLock, adj[1] = tempAdj;
+        }
+        if (adj[2] < adj[1]) {
+          tempLock = lock[1], tempAdj = adj[1];
+          lock[1] = lock[2], adj[1] = adj[2];
+          lock[2] = tempLock, adj[2] = tempAdj;
+        }
+        if (adj[1] < adj[0]) {
+          tempLock = lock[0], tempAdj = adj[0];
+          lock[0] = lock[1], adj[0] = adj[1];
+          lock[1] = tempLock, adj[1] = tempAdj;
+        }
+
+        if (pos_dir) {
+          // normalize adj to smallest value and do the first move
+          (*lock[0])(true);
+          do_homing_move(axis, adj[1] - adj[0]);
+          // lock the second stepper for the final correction
+          (*lock[1])(true);
+          do_homing_move(axis, adj[2] - adj[1]);
+        }
+        else {
+          (*lock[2])(true);
+          do_homing_move(axis, adj[1] - adj[2]);
+          (*lock[1])(true);
+          do_homing_move(axis, adj[0] - adj[1]);
+        }
+
+        stepper.set_z_lock(false);
+        stepper.set_z2_lock(false);
+        stepper.set_z3_lock(false);
+      }
+    #endif
+
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 9c15d065a0..d77a647314 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -80,23 +80,24 @@ bool relative_mode; // = false;
 float current_position[XYZE] = { 0 };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0 };
 
-
 // The active extruder (tool). Set with T<extruder> command.
-uint8_t active_extruder; // = 0;
+#if EXTRUDERS > 1
+  uint8_t active_extruder; // = 0
+#endif
 
 // Extruder offsets
 #if HAS_HOTEND_OFFSET
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!

commit 0c01099f17685cffc3777e1bf89363f39492022f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 8 21:16:41 2018 -0500

    hop_amount => current_hop

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 32e13879a4..9c15d065a0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1455,21 +1455,21 @@ void homeaxis(const AxisEnum axis) {
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
-    if (axis == Z_AXIS) fwretract.hop_amount = 0.0;
+    if (axis == Z_AXIS) fwretract.current_hop = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()

commit dcfde2317fe9e3fe2cc37bd87fa4e09e73b74354
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 6 01:40:22 2018 -0500

    Pass segment length in prepare_kinematic_move_to (#11737)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 7795ba6498..32e13879a4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -644,34 +644,34 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #if ENABLED(DELTA) && HOTENDS < 2
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // i.e., Complete the angular vector in the given time.
-        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
+        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, segment_length))
           break;
         /*
         SERIAL_ECHO(segments);
         SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
         SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOLNPAIR(" F", HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs * 60);
         safe_delay(5);
         //*/
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
       #elif ENABLED(DELTA_FEEDRATE_SCALING)
         // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
         // i.e., Complete the linear vector in the given time.
-        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder))
+        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder, segment_length))
           break;
         /*
         SERIAL_ECHO(segments);
         SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
         SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
         SERIAL_ECHOLNPAIR(" F", SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs * 60);
         safe_delay(5);
         //*/
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
       #else
@@ -682,33 +682,33 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // Ensure last segment arrives at target location.
     #if HAS_FEEDRATE_SCALING
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
     #endif
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
       if (diff2) {
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, segment_length);
         /*
         SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB);
         SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
         SERIAL_EOL();
         safe_delay(5);
         //*/
       }
     #elif ENABLED(DELTA_FEEDRATE_SCALING)
       const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
       if (diff2) {
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, segment_length);
         /*
         SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
         SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB); SERIAL_ECHOPAIR(" cdiff=", delta[C_AXIS] - oldC);
         SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
         SERIAL_EOL();
         safe_delay(5);
         //*/
       }
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2c2fcdb3fe..7795ba6498 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -828,22 +828,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2 & 3
-  bool symmetric_duplication_mode   = false;                              // Used in Dual X mode 2 & 3
+  bool extruder_duplication_enabled = false,                              // Used in Dual X mode 2 & 3
+       symmetric_duplication_mode   = false;                              // Used in Dual X mode 2 & 3
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
@@ -887,25 +887,25 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
 
             #define CUR_X    current_position[X_AXIS]
             #define CUR_Y    current_position[Y_AXIS]
             #define CUR_Z    current_position[Z_AXIS]
             #define CUR_E    current_position[E_AXIS]
             #define RAISED_X raised_parked_position[X_AXIS]
             #define RAISED_Y raised_parked_position[Y_AXIS]
             #define RAISED_Z raised_parked_position[Z_AXIS]
 
-SERIAL_ECHOLNPGM("dual_x_carriage_unpark()\n");
+            //SERIAL_ECHOLNPGM("dual_x_carriage_unpark()\n");
 
-            if (planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder)) 
-              if (planner.buffer_line( CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder)) 
-                  planner.buffer_line( CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            if (  planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder))
+              if (planner.buffer_line(   CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder))
+                  planner.buffer_line(   CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fbc2111172..2c2fcdb3fe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -828,21 +828,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
+  bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2 & 3
+  bool symmetric_duplication_mode   = false;                              // Used in Dual X mode 2 & 3
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
@@ -877,29 +878,34 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
               set_current_from_destination();
               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
               delayed_move_time = millis();
               return true;
             }
           }
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
-          for (uint8_t i = 0; i < 3; i++)
-            if (!planner.buffer_line(
-              i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
-              i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
-              i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
-              current_position[E_AXIS],
-              i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
-              active_extruder)
-            ) break;
+
+            #define CUR_X    current_position[X_AXIS]
+            #define CUR_Y    current_position[Y_AXIS]
+            #define CUR_Z    current_position[Z_AXIS]
+            #define CUR_E    current_position[E_AXIS]
+            #define RAISED_X raised_parked_position[X_AXIS]
+            #define RAISED_Y raised_parked_position[Y_AXIS]
+            #define RAISED_Z raised_parked_position[Z_AXIS]
+
+SERIAL_ECHOLNPGM("dual_x_carriage_unpark()\n");
+
+            if (planner.buffer_line(RAISED_X, RAISED_Y, RAISED_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder)) 
+              if (planner.buffer_line( CUR_X,    CUR_Y, RAISED_Z, CUR_E, PLANNER_XY_FEEDRATE(),             active_extruder)) 
+                  planner.buffer_line( CUR_X,    CUR_Y,    CUR_Z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
@@ -969,21 +975,26 @@ void prepare_move_to_destination() {
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (dual_x_carriage_unpark()) return;
   #endif
 
   if (
     #if UBL_SEGMENTED
-      ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
+//    ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))   // This does not seem to work correctly on UBL.
+      #if ENABLED(DELTA)                                                      // A Delta case and a Cartesian case can work
+        ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)) // around the problem until it is fixed.
+      #else
+        prepare_move_to_destination_cartesian()
+      #endif
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_from_destination();
 }
 

commit d1c9517903da3e7ab84e34ffb2c23d0772f2ce8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:26:29 2018 -0500

    Followup to hotend_offset[Z] patch

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 864d04609b..fbc2111172 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -85,21 +85,21 @@ float current_position[XYZE] = { 0 };
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder; // = 0;
 
 // Extruder offsets
-#if HOTENDS > 1
+#if HAS_HOTEND_OFFSET
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 float feedrate_mm_s = MMM_TO_MMS(1500.0f);
 
 int16_t feedrate_percentage = 100;

commit 9c62c47579fdefccdae5bb58dc706a58689eed0f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 3 20:47:29 2018 -0500

    [2.0.x] Fix Dual X Carriage tool change crash (#11447)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index de94ccd788..864d04609b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1476,21 +1476,21 @@ void homeaxis(const AxisEnum axis) {
    */
   void update_software_endstops(const AxisEnum axis) {
     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
-        float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
+        const float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop_min[X_AXIS] = X2_MIN_POS;
           soft_endstop_max[X_AXIS] = dual_max_x;
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
           // In Duplication Mode, T0 can move as far left as X_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);

commit 74900f7a70f339071fd1e03176260f61f668d4cd
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sun Jul 29 02:30:14 2018 +0200

    [2.0.x] bltouch home refinements (#11397)
    
    Just create  a better functions call logic flow

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index d7cfd2a479..de94ccd788 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1290,26 +1290,21 @@ void homeaxis(const AxisEnum axis) {
 
   const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
       axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) {
-      if (DEPLOY_PROBE()) return;
-      #if ENABLED(BLTOUCH)
-        if (set_bltouch_deployed(true)) return;
-      #endif
-    }
+    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   #endif
 
   // Set flags for X, Y, Z motor locking
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
@@ -1319,20 +1314,26 @@ void homeaxis(const AxisEnum axis) {
       #endif
       stepper.set_homing_dual_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
+
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    // BLTOUCH needs to be deployed every time
+    if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
+  #endif
+
   do_homing_move(axis, 1.5f * max_length(axis) * axis_home_dir);
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     // BLTOUCH needs to be stowed after trigger to rearm itself
     if (axis == Z_AXIS) set_bltouch_deployed(false);
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
@@ -1357,20 +1358,25 @@ void homeaxis(const AxisEnum axis) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
       // BLTOUCH needs to be deployed every time
       if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
     #endif
 
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
+
+    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+      // BLTOUCH needs to be stowed after trigger to rearm itself
+      if (axis == Z_AXIS) set_bltouch_deployed(false);
+    #endif
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
@@ -1433,26 +1439,21 @@ void homeaxis(const AxisEnum axis) {
     destination[axis] = current_position[axis];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) {
-      #if ENABLED(BLTOUCH)
-        if (set_bltouch_deployed(false)) return;
-      #endif
-      if (STOW_PROBE()) return;
-    }
+    if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.hop_amount = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);

commit 5ce5ff8e9befae837d583527b591445936fbb7da
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jul 28 01:30:08 2018 +0200

    [2.0.x] fix bltouch homing (#11379)
    
    Partially revert. Seems to solve the issue, but one report says G29 still fails.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1cb57688e9..d7cfd2a479 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1290,21 +1290,26 @@ void homeaxis(const AxisEnum axis) {
 
   const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
       axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis)
   );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
+    if (axis == Z_AXIS) {
+      if (DEPLOY_PROBE()) return;
+      #if ENABLED(BLTOUCH)
+        if (set_bltouch_deployed(true)) return;
+      #endif
+    }
   #endif
 
   // Set flags for X, Y, Z motor locking
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     switch (axis) {
       #if ENABLED(X_DUAL_ENDSTOPS)
         case X_AXIS:
       #endif
       #if ENABLED(Y_DUAL_ENDSTOPS)
         case Y_AXIS:
@@ -1315,22 +1320,23 @@ void homeaxis(const AxisEnum axis) {
       stepper.set_homing_dual_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5f * max_length(axis) * axis_home_dir);
+
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    // BLTOUCH needs to be stowed after trigger to let rearm itself
+    // BLTOUCH needs to be stowed after trigger to rearm itself
     if (axis == Z_AXIS) set_bltouch_deployed(false);
   #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
@@ -1346,31 +1352,27 @@ void homeaxis(const AxisEnum axis) {
         , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
 
     #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-      // BLTOUCH needs to deploy everytime
+      // BLTOUCH needs to be deployed every time
       if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
     #endif
+
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
-  // Put away the Z probe
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && STOW_PROBE()) return;
-  #endif
-
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_x_lock(false);
           stepper.set_x2_lock(false);
@@ -1429,20 +1431,30 @@ void homeaxis(const AxisEnum axis) {
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
+  // Put away the Z probe
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS) {
+      #if ENABLED(BLTOUCH)
+        if (set_bltouch_deployed(false)) return;
+      #endif
+      if (STOW_PROBE()) return;
+    }
+  #endif
+
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.hop_amount = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();

commit 4237c3d9f88b3b2b9d6c43e3e51964f404f154f0
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 26 12:04:09 2018 +0200

    [2.0.x] different bltouch init (#11135)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 53523f9b44..1cb57688e9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1110,30 +1110,23 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   if (is_home_dir) {
 
-    if (axis == Z_AXIS) {
-      #if HOMING_Z_WITH_PROBE
-        #if ENABLED(BLTOUCH)
-          set_bltouch_deployed(true);
-        #endif
-        #if QUIET_PROBING
-          probing_pause(true);
-        #endif
-      #endif
-    }
+    #if HOMING_Z_WITH_PROBE && QUIET_PROBING
+      if (axis == Z_AXIS) probing_pause(true);
+    #endif
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis);
     #endif
   }
 
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
@@ -1145,30 +1138,23 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #else
     sync_plan_position();
     current_position[axis] = distance; // Set delta/cartesian axes directly
     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #endif
 
   planner.synchronize();
 
   if (is_home_dir) {
 
-    if (axis == Z_AXIS) {
-      #if HOMING_Z_WITH_PROBE
-        #if QUIET_PROBING
-          probing_pause(false);
-        #endif
-        #if ENABLED(BLTOUCH)
-          set_bltouch_deployed(false);
-        #endif
-      #endif
-    }
+    #if HOMING_Z_WITH_PROBE && QUIET_PROBING
+      if (axis == Z_AXIS) probing_pause(false);
+    #endif
 
     endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis, false);
     #endif
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -1329,20 +1315,24 @@ void homeaxis(const AxisEnum axis) {
       stepper.set_homing_dual_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5f * max_length(axis) * axis_home_dir);
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    // BLTOUCH needs to be stowed after trigger to let rearm itself
+    if (axis == Z_AXIS) set_bltouch_deployed(false);
+  #endif
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
@@ -1354,23 +1344,33 @@ void homeaxis(const AxisEnum axis) {
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
         , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
+
+    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+      // BLTOUCH needs to deploy everytime
+      if (axis == Z_AXIS && set_bltouch_deployed(true)) return;
+    #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
+  // Put away the Z probe
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS && STOW_PROBE()) return;
+  #endif
+
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x_endstop_adj);
         if (adj) {
           if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
           do_homing_move(axis, pos_dir ? -adj : adj);
           stepper.set_x_lock(false);
           stepper.set_x2_lock(false);
@@ -1429,25 +1429,20 @@ void homeaxis(const AxisEnum axis) {
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
-  // Put away the Z probe
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && STOW_PROBE()) return;
-  #endif
-
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS) fwretract.hop_amount = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();

commit e5ea9d200f0ab02ed26ed3cdd949b28495716657
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jul 14 06:12:43 2018 +0200

    [2.0.x] fix kill printer (#11260)
    
    This will fix kill message on dual printer with 0 alignment offset

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index bf8e49dc1c..53523f9b44 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1362,42 +1362,48 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x_endstop_adj);
-        if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
-        do_homing_move(axis, pos_dir ? -adj : adj);
-        stepper.set_x_lock(false);
-        stepper.set_x2_lock(false);
+        if (adj) {
+          if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
+          do_homing_move(axis, pos_dir ? -adj : adj);
+          stepper.set_x_lock(false);
+          stepper.set_x2_lock(false);
+        }
       }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       if (axis == Y_AXIS) {
         const float adj = ABS(endstops.y_endstop_adj);
-        if (pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
-        do_homing_move(axis, pos_dir ? -adj : adj);
-        stepper.set_y_lock(false);
-        stepper.set_y2_lock(false);
+        if (adj) {
+          if (pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
+          do_homing_move(axis, pos_dir ? -adj : adj);
+          stepper.set_y_lock(false);
+          stepper.set_y2_lock(false);
+        }
       }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       if (axis == Z_AXIS) {
         const float adj = ABS(endstops.z_endstop_adj);
-        if (pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-        do_homing_move(axis, pos_dir ? -adj : adj);
-        stepper.set_z_lock(false);
-        stepper.set_z2_lock(false);
+        if (adj) {
+          if (pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+          do_homing_move(axis, pos_dir ? -adj : adj);
+          stepper.set_z_lock(false);
+          stepper.set_z2_lock(false);
+        }
       }
     #endif
     stepper.set_homing_dual_axis(false);
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     SYNC_PLAN_POSITION_KINEMATIC();
 

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1b74694fd8..bf8e49dc1c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -70,44 +70,44 @@ XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
-float current_position[XYZE] = { 0.0 };
+float current_position[XYZE] = { 0 };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
-float destination[XYZE] = { 0.0 };
+float destination[XYZE] = { 0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder; // = 0;
 
 // Extruder offsets
 #if HOTENDS > 1
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
-float feedrate_mm_s = MMM_TO_MMS(1500.0);
+float feedrate_mm_s = MMM_TO_MMS(1500.0f);
 
 int16_t feedrate_percentage = 100;
 
 // Homing feedrate is const progmem - compare to constexpr in the header
 const float homing_feedrate_mm_s[4] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
@@ -502,21 +502,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     /**
      * Before raising this value, use M665 S[seg_per_sec] to decrease
      * the number of segments-per-second. Default is 200. Some deltas
      * do better with 160 or lower. It would be good to know how many
      * segments-per-second are actually possible for SCARA on AVR.
      *
      * Longer segments result in less kinematic overhead
      * but may produce jagged lines. Try 0.5mm, 1.0mm, and 2.0mm
      * and compare the difference.
      */
-    #define SCARA_MIN_SEGMENT_LENGTH 0.5
+    #define SCARA_MIN_SEGMENT_LENGTH 0.5f
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * Called from prepare_move_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
@@ -559,28 +559,28 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / _feedrate_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
-      NOMORE(segments, cartesian_mm * (1.0 / SCARA_MIN_SEGMENT_LENGTH));
+      NOMORE(segments, cartesian_mm * (1.0f / float(SCARA_MIN_SEGMENT_LENGTH)));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1U);
 
     // The approximate length of each segment
-    const float inv_segments = 1.0 / float(segments),
+    const float inv_segments = 1.0f / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
     #if !HAS_FEEDRATE_SCALING
       const float cartesian_segment_mm = cartesian_mm * inv_segments;
     #endif
@@ -592,21 +592,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #if !HAS_FEEDRATE_SCALING
       SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     #endif
     SERIAL_EOL();
     //*/
 
     #if HAS_FEEDRATE_SCALING
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float segment_length = cartesian_mm * inv_segments,
-                  inv_segment_length = 1.0 / segment_length, // 1/mm/segs
+                  inv_segment_length = 1.0f / segment_length, // 1/mm/segs
                   inverse_secs = inv_segment_length * _feedrate_mm_s;
 
       float oldA = planner.position_float[A_AXIS],
             oldB = planner.position_float[B_AXIS]
             #if ENABLED(DELTA_FEEDRATE_SCALING)
               , oldC = planner.position_float[C_AXIS]
             #endif
             ;
 
       /*
@@ -749,21 +749,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
       if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1U);
 
       // The approximate length of each segment
-      const float inv_segments = 1.0 / float(segments),
+      const float inv_segments = 1.0f / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments,
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
@@ -1328,21 +1328,21 @@ void homeaxis(const AxisEnum axis) {
       #endif
       stepper.set_homing_dual_axis(true);
       default: break;
     }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
-  do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
+  do_homing_move(axis, 1.5f * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index edacc94d61..1b74694fd8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1156,21 +1156,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
       #if HOMING_Z_WITH_PROBE
         #if QUIET_PROBING
           probing_pause(false);
         #endif
         #if ENABLED(BLTOUCH)
           set_bltouch_deployed(false);
         #endif
       #endif
     }
 
-    endstops.hit_on_purpose();
+    endstops.validate_homing_move();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis, false);
     #endif
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);

commit 8eaac0dab37b4376ac06f1fefd469cdd6bc80673
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 13:44:27 2018 -0500

    Add delta feedrate scaling (#11153)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e8e3ee5bb7..edacc94d61 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -574,53 +574,60 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // The approximate length of each segment
     const float inv_segments = 1.0 / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
-    #if DISABLED(SCARA_FEEDRATE_SCALING)
+    #if !HAS_FEEDRATE_SCALING
       const float cartesian_segment_mm = cartesian_mm * inv_segments;
     #endif
 
     /*
     SERIAL_ECHOPAIR("mm=", cartesian_mm);
     SERIAL_ECHOPAIR(" seconds=", seconds);
     SERIAL_ECHOPAIR(" segments=", segments);
-    #if DISABLED(SCARA_FEEDRATE_SCALING)
-      SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
-    #else
-      SERIAL_EOL();
+    #if !HAS_FEEDRATE_SCALING
+      SERIAL_ECHOPAIR(" segment_mm=", cartesian_segment_mm);
     #endif
+    SERIAL_EOL();
     //*/
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
+    #if HAS_FEEDRATE_SCALING
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float segment_length = cartesian_mm * inv_segments,
                   inv_segment_length = 1.0 / segment_length, // 1/mm/segs
                   inverse_secs = inv_segment_length * _feedrate_mm_s;
 
       float oldA = planner.position_float[A_AXIS],
-            oldB = planner.position_float[B_AXIS];
+            oldB = planner.position_float[B_AXIS]
+            #if ENABLED(DELTA_FEEDRATE_SCALING)
+              , oldC = planner.position_float[C_AXIS]
+            #endif
+            ;
 
       /*
       SERIAL_ECHOPGM("Scaled kinematic move: ");
       SERIAL_ECHOPAIR(" segment_length (inv)=", segment_length);
       SERIAL_ECHOPAIR(" (", inv_segment_length);
       SERIAL_ECHOPAIR(") _feedrate_mm_s=", _feedrate_mm_s);
       SERIAL_ECHOPAIR(" inverse_secs=", inverse_secs);
       SERIAL_ECHOPAIR(" oldA=", oldA);
-      SERIAL_ECHOLNPAIR(" oldB=", oldB);
+      SERIAL_ECHOPAIR(" oldB=", oldB);
+      #if ENABLED(DELTA_FEEDRATE_SCALING)
+        SERIAL_ECHOPAIR(" oldC=", oldC);
+      #endif
+      SERIAL_EOL();
       safe_delay(5);
       //*/
     #endif
 
      // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
     // Calculate and execute the segments
     while (--segments) {
@@ -647,38 +654,65 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
           break;
         /*
         SERIAL_ECHO(segments);
         SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
         SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOLNPAIR(" F", HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs * 60);
         safe_delay(5);
         //*/
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+      #elif ENABLED(DELTA_FEEDRATE_SCALING)
+        // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
+        // i.e., Complete the linear vector in the given time.
+        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder))
+          break;
+        /*
+        SERIAL_ECHO(segments);
+        SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
+        SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
+        SERIAL_ECHOLNPAIR(" F", SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs * 60);
+        safe_delay(5);
+        //*/
+        oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
       #else
         if (!planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm))
           break;
       #endif
     }
 
     // Ensure last segment arrives at target location.
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
+    #if HAS_FEEDRATE_SCALING
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
+    #endif
+
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
       if (diff2) {
         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
-
         /*
         SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB);
-        SERIAL_ECHOLNPAIR(" F", (SQRT(diff2) * inverse_secs) * 60);
+        SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
+        SERIAL_EOL();
+        safe_delay(5);
+        //*/
+      }
+    #elif ENABLED(DELTA_FEEDRATE_SCALING)
+      const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
+      if (diff2) {
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+        /*
+        SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]); SERIAL_ECHOPAIR(" C=", delta[C_AXIS]);
+        SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB); SERIAL_ECHOPAIR(" cdiff=", delta[C_AXIS] - oldC);
+        SERIAL_ECHOLNPAIR(" F", SQRT(diff2) * inverse_secs * 60);
         SERIAL_EOL();
         safe_delay(5);
         //*/
       }
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
     #endif
 
     return false; // caller will update current_position
   }

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 4587704983..e8e3ee5bb7 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -950,27 +950,27 @@ void prepare_move_to_destination() {
     #endif
   ) return;
 
   set_current_from_destination();
 }
 
 #if HAS_AXIS_UNHOMED_ERR
 
   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
     #if ENABLED(HOME_AFTER_DEACTIVATE)
-      const bool xx = x && !axis_known_position[X_AXIS],
-                 yy = y && !axis_known_position[Y_AXIS],
-                 zz = z && !axis_known_position[Z_AXIS];
+      const bool xx = x && !TEST(axis_known_position, X_AXIS),
+                 yy = y && !TEST(axis_known_position, Y_AXIS),
+                 zz = z && !TEST(axis_known_position, Z_AXIS);
     #else
-      const bool xx = x && !axis_homed[X_AXIS],
-                 yy = y && !axis_homed[Y_AXIS],
-                 zz = z && !axis_homed[Z_AXIS];
+      const bool xx = x && !TEST(axis_homed, X_AXIS),
+                 yy = y && !TEST(axis_homed, Y_AXIS),
+                 zz = z && !TEST(axis_homed, Z_AXIS);
     #endif
     if (xx || yy || zz) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM(MSG_HOME " ");
       if (xx) SERIAL_ECHOPGM(MSG_X);
       if (yy) SERIAL_ECHOPGM(MSG_Y);
       if (zz) SERIAL_ECHOPGM(MSG_Z);
       SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
       #if ENABLED(ULTRA_LCD)
@@ -1166,21 +1166,22 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
  */
 void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
-  axis_known_position[axis] = axis_homed[axis] = true;
+  SBI(axis_known_position, axis);
+  SBI(axis_homed, axis);
 
   #if HAS_POSITION_SHIFT
     position_shift[axis] = 0;
     update_software_endstops(axis);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;

commit b64cc9329e821f5ab5b00b112636aa8c2c7b7637
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sun Jun 10 09:08:47 2018 +0200

    [2.0.x] Fix dual enstop home (#10980)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 846d99b2dd..4587704983 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1328,39 +1328,39 @@ void homeaxis(const AxisEnum axis) {
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const float adj = ABS(endstops.x_endstop_adj);
         if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
-        do_homing_move(axis, pos_dir ? adj : -adj);
+        do_homing_move(axis, pos_dir ? -adj : adj);
         stepper.set_x_lock(false);
         stepper.set_x2_lock(false);
       }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       if (axis == Y_AXIS) {
         const float adj = ABS(endstops.y_endstop_adj);
         if (pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
-        do_homing_move(axis, pos_dir ? adj : -adj);
+        do_homing_move(axis, pos_dir ? -adj : adj);
         stepper.set_y_lock(false);
         stepper.set_y2_lock(false);
       }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       if (axis == Z_AXIS) {
         const float adj = ABS(endstops.z_endstop_adj);
         if (pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-        do_homing_move(axis, pos_dir ? adj : -adj);
+        do_homing_move(axis, pos_dir ? -adj : adj);
         stepper.set_z_lock(false);
         stepper.set_z2_lock(false);
       }
     #endif
     stepper.set_homing_dual_axis(false);
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);

commit ad8d3150aa4d6b792b5e06a63d2645991136fc50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:39:00 2018 -0500

    Cleanup for dual endstops homing

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 94f810e7d2..846d99b2dd 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1045,23 +1045,28 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
 
 /**
  * Home an individual linear axis
  */
 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
-      SERIAL_ECHOPAIR(", ", fr_mm_s);
-      SERIAL_ECHOPAIR(" [", fr_mm_s ? fr_mm_s : homing_feedrate(axis));
-      SERIAL_ECHOLNPGM("])");
+      SERIAL_ECHOPGM(", ");
+      if (fr_mm_s)
+        SERIAL_ECHO(fr_mm_s);
+      else {
+        SERIAL_ECHOPAIR("[", homing_feedrate(axis));
+        SERIAL_CHAR(']');
+      }
+      SERIAL_ECHOLNPGM(")");
     }
   #endif
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();
@@ -1255,40 +1260,47 @@ void homeaxis(const AxisEnum axis) {
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
-  const int axis_home_dir =
+  const int axis_home_dir = (
     #if ENABLED(DUAL_X_CARRIAGE)
-      (axis == X_AXIS) ? x_home_dir(active_extruder) :
+      axis == X_AXIS ? x_home_dir(active_extruder) :
     #endif
-    home_dir(axis);
+    home_dir(axis)
+  );
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   #endif
 
   // Set flags for X, Y, Z motor locking
-  #if ENABLED(X_DUAL_ENDSTOPS)
-    if (axis == X_AXIS) stepper.set_homing_flag_x(true);
-  #endif
-  #if ENABLED(Y_DUAL_ENDSTOPS)
-    if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
-  #endif
-  #if ENABLED(Z_DUAL_ENDSTOPS)
-    if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
+  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+    switch (axis) {
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        case X_AXIS:
+      #endif
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        case Y_AXIS:
+      #endif
+      #if ENABLED(Z_DUAL_ENDSTOPS)
+        case Z_AXIS:
+      #endif
+      stepper.set_homing_dual_axis(true);
+      default: break;
+    }
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
@@ -1314,51 +1326,46 @@ void homeaxis(const AxisEnum axis) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
-        const bool lock_x1 = pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0);
-        float adj = ABS(endstops.x_endstop_adj);
-        if (pos_dir) adj = -adj;
-        if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
-        do_homing_move(axis, adj);
-        if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
-        stepper.set_homing_flag_x(false);
+        const float adj = ABS(endstops.x_endstop_adj);
+        if (pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0)) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
+        do_homing_move(axis, pos_dir ? adj : -adj);
+        stepper.set_x_lock(false);
+        stepper.set_x2_lock(false);
       }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       if (axis == Y_AXIS) {
-        const bool lock_y1 = pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0);
-        float adj = ABS(endstops.y_endstop_adj);
-        if (pos_dir) adj = -adj;
-        if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
-        do_homing_move(axis, adj);
-        if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
-        stepper.set_homing_flag_y(false);
+        const float adj = ABS(endstops.y_endstop_adj);
+        if (pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0)) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
+        do_homing_move(axis, pos_dir ? adj : -adj);
+        stepper.set_y_lock(false);
+        stepper.set_y2_lock(false);
       }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       if (axis == Z_AXIS) {
-        const bool lock_z1 = pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0);
-        float adj = ABS(endstops.z_endstop_adj);
-        if (pos_dir) adj = -adj;
-        if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-        do_homing_move(axis, adj);
-        if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
-        stepper.set_homing_flag_z(false);
+        const float adj = ABS(endstops.z_endstop_adj);
+        if (pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0)) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+        do_homing_move(axis, pos_dir ? adj : -adj);
+        stepper.set_z_lock(false);
+        stepper.set_z2_lock(false);
       }
     #endif
+    stepper.set_homing_dual_axis(false);
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
@@ -1386,24 +1393,23 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
-  // Clear z_lift if homing the Z axis
+  // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
-    if (axis == Z_AXIS)
-      fwretract.hop_amount = 0.0;
+    if (axis == Z_AXIS) fwretract.hop_amount = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
@@ -1463,21 +1469,21 @@ void homeaxis(const AxisEnum axis) {
         #endif
         #if HAS_POSITION_SHIFT
           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
         #endif
         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
 
     #if ENABLED(DELTA)
-      switch(axis) {
+      switch (axis) {
         #if HAS_SOFTWARE_ENDSTOPS
           case X_AXIS:
           case Y_AXIS:
             // Get a minimum radius for clamping
             soft_endstop_radius = MIN3(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
             soft_endstop_radius_2 = sq(soft_endstop_radius);
             break;
         #endif
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b6f53b4acc..94f810e7d2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -637,31 +637,33 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #if ENABLED(DELTA) && HOTENDS < 2
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // i.e., Complete the angular vector in the given time.
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+        if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
+          break;
         /*
         SERIAL_ECHO(segments);
         SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
         SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOLNPAIR(" F", HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs * 60);
         safe_delay(5);
         //*/
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
       #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
+        if (!planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm))
+          break;
       #endif
     }
 
     // Ensure last segment arrives at target location.
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
       const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
       if (diff2) {
         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
@@ -739,21 +741,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
       // Calculate and execute the segments
       while (--segments) {
         static millis_t next_idle_ms = millis() + 200UL;
         thermalManager.manage_heater();  // This returns immediately if not really needed.
         if (ELAPSED(millis(), next_idle_ms)) {
           next_idle_ms = millis() + 200UL;
           idle();
         }
         LOOP_XYZE(i) raw[i] += segment_distance[i];
-        planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder, cartesian_segment_mm);
+        if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder, cartesian_segment_mm))
+          break;
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder, cartesian_segment_mm);
     }
 
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
@@ -841,49 +844,49 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
               set_current_from_destination();
               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
               delayed_move_time = millis();
               return true;
             }
           }
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
           for (uint8_t i = 0; i < 3; i++)
-            planner.buffer_line(
+            if (!planner.buffer_line(
               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
               current_position[E_AXIS],
               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
-              active_extruder
-            );
+              active_extruder)
+            ) break;
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
               }
             #endif
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-            planner.buffer_line(
+            if (!planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
-              planner.max_feedrate_mm_s[X_AXIS], 1
-            );
+              planner.max_feedrate_mm_s[X_AXIS], 1)
+            ) break;
             planner.synchronize();
             SYNC_PLAN_POSITION_KINEMATIC();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 50270b53a0a2b8d716f1a771563e17f9753e14ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 17 18:40:22 2018 -0500

    Clear up some more compile warnings

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b91b84d7c8..b6f53b4acc 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -563,21 +563,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
 
     // For SCARA enforce a minimum segment size
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * (1.0 / SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
-    NOLESS(segments, 1);
+    NOLESS(segments, 1U);
 
     // The approximate length of each segment
     const float inv_segments = 1.0 / float(segments),
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
@@ -710,21 +710,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
       float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
       if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
-      NOLESS(segments, 1);
+      NOLESS(segments, 1U);
 
       // The approximate length of each segment
       const float inv_segments = 1.0 / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments,
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };

commit 836b0bbeee9f447685f4ae3f649fb85dfe91554f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 16:48:42 2018 -0500

    Fix MBL line_to_destination
    
    Fix #10708

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e62c659b3e..b91b84d7c8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -773,21 +773,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
           return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
-              mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
+              mbl.line_to_destination(MMS_SCALED(feedrate_mm_s));
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));

commit 08e36e264e72f56bada1f25c1a784d6e3f9d2135
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:44:24 2018 -0500

    Apply _AXIS macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ae413d2077..e62c659b3e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1240,21 +1240,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
  * before updating the current position.
  */
 
 void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   #else
     #define CAN_HOME(A) \
-      (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
+      (axis == _AXIS(A) && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e9818e776b..ae413d2077 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -545,21 +545,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
 
     // Remaining cartesian distances
     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
 
     // Get the linear distance in XYZ
     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
 
     // If the move is very short, check the E move distance
-    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
+    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / _feedrate_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
@@ -658,20 +658,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #endif
     }
 
     // Ensure last segment arrives at target location.
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
       const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
       if (diff2) {
         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+
         /*
         SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
         SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB);
         SERIAL_ECHOLNPAIR(" F", (SQRT(diff2) * inverse_secs) * 60);
         SERIAL_EOL();
         safe_delay(5);
         //*/
       }
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
@@ -703,21 +704,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       }
 
       // Remaining cartesian distances
       const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
                   ediff = destination[E_AXIS] - current_position[E_AXIS];
 
       // Get the linear distance in XYZ
       // If the move is very short, check the E move distance
       // No E move either? Game over.
       float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
-      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
+      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = ABS(ediff);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1);
 
       // The approximate length of each segment
       const float inv_segments = 1.0 / float(segments),
                   cartesian_segment_mm = cartesian_mm * inv_segments,
@@ -914,21 +915,21 @@ void prepare_move_to_destination() {
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
+          if (ABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
@@ -1282,21 +1283,21 @@ void homeaxis(const AxisEnum axis) {
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? max(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
+      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? MAX(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
     #endif
@@ -1311,43 +1312,43 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;
     #if ENABLED(X_DUAL_ENDSTOPS)
       if (axis == X_AXIS) {
         const bool lock_x1 = pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0);
-        float adj = FABS(endstops.x_endstop_adj);
+        float adj = ABS(endstops.x_endstop_adj);
         if (pos_dir) adj = -adj;
         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
         do_homing_move(axis, adj);
         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
         stepper.set_homing_flag_x(false);
       }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       if (axis == Y_AXIS) {
         const bool lock_y1 = pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0);
-        float adj = FABS(endstops.y_endstop_adj);
+        float adj = ABS(endstops.y_endstop_adj);
         if (pos_dir) adj = -adj;
         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
         do_homing_move(axis, adj);
         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
         stepper.set_homing_flag_y(false);
       }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       if (axis == Z_AXIS) {
         const bool lock_z1 = pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0);
-        float adj = FABS(endstops.z_endstop_adj);
+        float adj = ABS(endstops.z_endstop_adj);
         if (pos_dir) adj = -adj;
         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
         do_homing_move(axis, adj);
         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
         stepper.set_homing_flag_z(false);
       }
     #endif
   #endif
 
   #if IS_SCARA
@@ -1417,32 +1418,32 @@ void homeaxis(const AxisEnum axis) {
    */
   void update_software_endstops(const AxisEnum axis) {
     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
-        float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
+        float dual_max_x = MAX(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
           soft_endstop_min[X_AXIS] = X2_MIN_POS;
           soft_endstop_max[X_AXIS] = dual_max_x;
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
           // In Duplication Mode, T0 can move as far left as X_MIN_POS
           // but not so far to the right that T1 would move past the end
           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
-          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
+          soft_endstop_max[X_AXIS] = MIN(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
           soft_endstop_min[axis] = base_min_pos(axis);
           soft_endstop_max[axis] = base_max_pos(axis);
         }
       }
     #elif ENABLED(DELTA)
       soft_endstop_min[axis] = base_min_pos(axis);
       soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis));
@@ -1464,21 +1465,21 @@ void homeaxis(const AxisEnum axis) {
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
 
     #if ENABLED(DELTA)
       switch(axis) {
         #if HAS_SOFTWARE_ENDSTOPS
           case X_AXIS:
           case Y_AXIS:
             // Get a minimum radius for clamping
-            soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
+            soft_endstop_radius = MIN3(ABS(MAX(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
             soft_endstop_radius_2 = sq(soft_endstop_radius);
             break;
         #endif
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
     #endif
   }
 

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index cbaaf82bfe..e9818e776b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -186,35 +186,35 @@ void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]
  * Forward kinematics are applied for DELTA and SCARA.
  *
  * The result is in the current coordinate space with
  * leveling applied. The coordinates need to be run through
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics_DELTA(
-      stepper.get_axis_position_mm(A_AXIS),
-      stepper.get_axis_position_mm(B_AXIS),
-      stepper.get_axis_position_mm(C_AXIS)
+      planner.get_axis_position_mm(A_AXIS),
+      planner.get_axis_position_mm(B_AXIS),
+      planner.get_axis_position_mm(C_AXIS)
     );
   #else
     #if IS_SCARA
       forward_kinematics_SCARA(
-        stepper.get_axis_position_degrees(A_AXIS),
-        stepper.get_axis_position_degrees(B_AXIS)
+        planner.get_axis_position_degrees(A_AXIS),
+        planner.get_axis_position_degrees(B_AXIS)
       );
     #else
-      cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
-      cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+      cartes[X_AXIS] = planner.get_axis_position_mm(X_AXIS);
+      cartes[Y_AXIS] = planner.get_axis_position_mm(Y_AXIS);
     #endif
-    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+    cartes[Z_AXIS] = planner.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  *
  * To prevent small shifts in axis position always call
  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
@@ -863,26 +863,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           break;
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
               }
             #endif
             // move duplicate extruder into correct duplication position.
-            planner.set_position_mm(
-              inactive_extruder_x_pos,
-              current_position[Y_AXIS],
-              current_position[Z_AXIS],
-              current_position[E_AXIS]
-            );
+            planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
             planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
               planner.max_feedrate_mm_s[X_AXIS], 1
             );
             planner.synchronize();
             SYNC_PLAN_POSITION_KINEMATIC();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 042661f54d..cbaaf82bfe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -395,21 +395,21 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
     }
 
   #endif
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   #endif
 
-  stepper.synchronize();
+  planner.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
@@ -874,21 +874,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
               inactive_extruder_x_pos,
               current_position[Y_AXIS],
               current_position[Z_AXIS],
               current_position[E_AXIS]
             );
             planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
               planner.max_feedrate_mm_s[X_AXIS], 1
             );
-            stepper.synchronize();
+            planner.synchronize();
             SYNC_PLAN_POSITION_KINEMATIC();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
@@ -1103,21 +1103,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
     current_position[axis] = distance; // Set delta/cartesian axes directly
     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #endif
 
-  stepper.synchronize();
+  planner.synchronize();
 
   if (is_home_dir) {
 
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
         #if QUIET_PROBING
           probing_pause(false);
         #endif
         #if ENABLED(BLTOUCH)
           set_bltouch_deployed(false);

commit 23a876b08d235bb60a19c85a7d00891d4991018b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 10 15:03:37 2018 -0500

    Update a comment in motion.cpp

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fdb92fb03e..042661f54d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -76,21 +76,21 @@ bool relative_mode; // = false;
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
- *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
+ *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0.0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder; // = 0;
 
 // Extruder offsets
 #if HOTENDS > 1
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()

commit bfe223e1209af4e50917e752124c7215a4c38953
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 20:51:10 2018 -0500

    Adjust usage of stepper.synchronize

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 66da413741..fdb92fb03e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -389,27 +389,27 @@ void do_blocking_move_to(const float rx, const float ry, const float rz, const f
 
     // If Z needs to lower, do it after moving XY
     if (current_position[Z_AXIS] > rz) {
       feedrate_mm_s = z_feedrate;
       current_position[Z_AXIS] = rz;
       line_to_current_position();
     }
 
   #endif
 
-  stepper.synchronize();
-
   feedrate_mm_s = old_feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   #endif
+
+  stepper.synchronize();
 }
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
@@ -874,22 +874,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
               inactive_extruder_x_pos,
               current_position[Y_AXIS],
               current_position[Z_AXIS],
               current_position[E_AXIS]
             );
             planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
               planner.max_feedrate_mm_s[X_AXIS], 1
             );
-            SYNC_PLAN_POSITION_KINEMATIC();
             stepper.synchronize();
+            SYNC_PLAN_POSITION_KINEMATIC();
             extruder_duplication_enabled = true;
             active_extruder_parked = false;
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
             #endif
@@ -1099,21 +1099,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
   #if IS_SCARA
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
-    current_position[axis] = distance;
+    current_position[axis] = distance; // Set delta/cartesian axes directly
     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #endif
 
   stepper.synchronize();
 
   if (is_home_dir) {
 
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
         #if QUIET_PROBING

commit 2c1205d8b1061feee62f66883855f5a3336c5988
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 23:49:51 2018 -0500

    Improve debug of homing move feedrate

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 57d43a1df3..66da413741 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1047,22 +1047,22 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
 /**
  * Home an individual linear axis
  */
 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPAIR(", ", fr_mm_s);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
+      SERIAL_ECHOPAIR(" [", fr_mm_s ? fr_mm_s : homing_feedrate(axis));
+      SERIAL_ECHOLNPGM("])");
     }
   #endif
 
   #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();

commit c8e4b7c8a6035bd39ce7c880a94e8b01138ec24c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 23:49:07 2018 -0500

    Fix XY homing move away rate

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 47d07c8ce2..57d43a1df3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1300,21 +1300,21 @@ void homeaxis(const AxisEnum axis) {
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
     #endif
     do_homing_move(axis, -bump
       #if HOMING_Z_WITH_PROBE
-        , MMM_TO_MMS(Z_PROBE_SPEED_FAST)
+        , axis == Z_AXIS ? MMM_TO_MMS(Z_PROBE_SPEED_FAST) : 0.0
       #endif
     );
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 

commit 4dfc011d86b8a271fca23b42a8cb73902d622fb2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:35:07 2018 -0500

    Fix homing with probe feedrates

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 0ec1a4c370..47d07c8ce2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -978,25 +978,25 @@ void prepare_move_to_destination() {
         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
       #endif
       return true;
     }
     return false;
   }
 
 #endif // HAS_AXIS_UNHOMED_ERR
 
 /**
- * The homing feedrate may vary
+ * Homing bump feedrate (mm/s)
  */
 inline float get_homing_bump_feedrate(const AxisEnum axis) {
   #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS) return Z_PROBE_SPEED_SLOW;
+    if (axis == Z_AXIS) return MMM_TO_MMS(Z_PROBE_SPEED_SLOW);
   #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
@@ -1287,32 +1287,36 @@ void homeaxis(const AxisEnum axis) {
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS && Z_HOME_BUMP_MM) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
+      (axis == Z_AXIS && (Z_HOME_BUMP_MM)) ? max(Z_CLEARANCE_BETWEEN_PROBES, Z_HOME_BUMP_MM) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
     #endif
-    do_homing_move(axis, -bump);
+    do_homing_move(axis, -bump
+      #if HOMING_Z_WITH_PROBE
+        , MMM_TO_MMS(Z_PROBE_SPEED_FAST)
+      #endif
+    );
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     const bool pos_dir = axis_home_dir > 0;

commit 7546f879498a775d4d24097434f2041094ddb8e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 28 10:23:46 2018 -0500

    Allow a home bump of 0 when homing Z with probe

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1a657fd07f..0ec1a4c370 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1287,21 +1287,21 @@ void homeaxis(const AxisEnum axis) {
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
+      (axis == Z_AXIS && Z_HOME_BUMP_MM) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
     #endif
     home_bump_mm(axis)
   );
 
   // If a second homing move is configured...
   if (bump) {
     // Move away from the endstop by the axis HOME_BUMP_MM
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
     #endif

commit 683dc24e0f466f68f6c2d3d2427418f2c9ed41c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 28 08:50:23 2018 -0500

    When homing with Z probe bump at Z_PROBE_SPEED_SLOW

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 93641b7102..1a657fd07f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -981,20 +981,23 @@ void prepare_move_to_destination() {
     }
     return false;
   }
 
 #endif // HAS_AXIS_UNHOMED_ERR
 
 /**
  * The homing feedrate may vary
  */
 inline float get_homing_bump_feedrate(const AxisEnum axis) {
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS) return Z_PROBE_SPEED_SLOW;
+  #endif
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 

commit cb46cb8480c33ffc9f6361b96ed200986a3bd9ac
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 23 17:13:01 2018 -0500

    Add HAS_HEATED_BED conditional (#10495)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a9f6898a05..93641b7102 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1049,21 +1049,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPAIR(", ", fr_mm_s);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
-  #if HOMING_Z_WITH_PROBE && HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+  #if HOMING_Z_WITH_PROBE && HAS_HEATED_BED && ENABLED(WAIT_FOR_BED_HEATER)
     // Wait for bed to heat back up between probing points
     if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
       serialprintPGM(msg_wait_for_bed_heating);
       LCD_MESSAGEPGM(MSG_BED_HEATING);
       while (thermalManager.isHeatingBed()) safe_delay(200);
       lcd_reset_status();
     }
   #endif
 
   // Only do some things when moving towards an endstop

commit a90cbc633993dc236fdb5d2aa174b52c321533c4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 21 15:43:21 2018 -0500

    [2.0.x] Wait for bed heaters between probing (#10472)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c2a76836af..a9f6898a05 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1049,20 +1049,30 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPAIR(", ", fr_mm_s);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
+  #if HOMING_Z_WITH_PROBE && HAS_TEMP_BED && ENABLED(WAIT_FOR_BED_HEATER)
+    // Wait for bed to heat back up between probing points
+    if (axis == Z_AXIS && distance < 0 && thermalManager.isHeatingBed()) {
+      serialprintPGM(msg_wait_for_bed_heating);
+      LCD_MESSAGEPGM(MSG_BED_HEATING);
+      while (thermalManager.isHeatingBed()) safe_delay(200);
+      lcd_reset_status();
+    }
+  #endif
+
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   if (is_home_dir) {
 

commit 12785583d0d79375b8b089c7b5fb2f118ea2cedd
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Fri Apr 13 03:22:29 2018 +0200

    [2.0.x] G33 MIN_STEPS_PER_SEGMENT (#10386)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ecd31a7ea5..c2a76836af 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1347,21 +1347,21 @@ void homeaxis(const AxisEnum axis) {
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
     // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
       #endif
-      do_homing_move(axis, delta_endstop_adj[axis] - MIN_STEPS_PER_SEGMENT / planner.axis_steps_per_mm[axis] * Z_HOME_DIR);
+      do_homing_move(axis, delta_endstop_adj[axis] - (MIN_STEPS_PER_SEGMENT + 1) * planner.steps_to_mm[axis] * Z_HOME_DIR);
     }
 
   #else
 
     // For cartesian/core machines,
     // set the axis to its home position
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];

commit 646aa20b433cbde61a849a2b79ddf1c0a13714ef
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 04:14:48 2018 +0200

    Overhaul of G33 Delta Calibration (#8822)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 76e5f3483e..ecd31a7ea5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -610,21 +610,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       SERIAL_ECHOPGM("Scaled kinematic move: ");
       SERIAL_ECHOPAIR(" segment_length (inv)=", segment_length);
       SERIAL_ECHOPAIR(" (", inv_segment_length);
       SERIAL_ECHOPAIR(") _feedrate_mm_s=", _feedrate_mm_s);
       SERIAL_ECHOPAIR(" inverse_secs=", inverse_secs);
       SERIAL_ECHOPAIR(" oldA=", oldA);
       SERIAL_ECHOLNPAIR(" oldB=", oldB);
       safe_delay(5);
       //*/
     #endif
- 
+
      // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
     // Calculate and execute the segments
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
@@ -1342,26 +1342,26 @@ void homeaxis(const AxisEnum axis) {
 
     set_axis_is_at_home(axis);
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
-    // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
+    // retrace by the amount specified in delta_endstop_adj + additional dist in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
       #endif
-      do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
+      do_homing_move(axis, delta_endstop_adj[axis] - MIN_STEPS_PER_SEGMENT / planner.axis_steps_per_mm[axis] * Z_HOME_DIR);
     }
 
   #else
 
     // For cartesian/core machines,
     // set the axis to its home position
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];

commit e8e60263c8e454454d126f9154cf5c7ac3213725
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 5 15:47:56 2018 -0500

    Scale feedrate (mm/s to deg/s) for SCARA

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 17097acead..76e5f3483e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -491,34 +491,32 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
 #if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
-  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-    #if ENABLED(DELTA)
-      #define ADJUST_DELTA(V) \
-        if (planner.leveling_active) { \
-          const float zadj = bilinear_z_offset(V); \
-          delta[A_AXIS] += zadj; \
-          delta[B_AXIS] += zadj; \
-          delta[C_AXIS] += zadj; \
-        }
-    #else
-      #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
-    #endif
-  #else
-    #define ADJUST_DELTA(V) NOOP
+  #if IS_SCARA
+    /**
+     * Before raising this value, use M665 S[seg_per_sec] to decrease
+     * the number of segments-per-second. Default is 200. Some deltas
+     * do better with 160 or lower. It would be good to know how many
+     * segments-per-second are actually possible for SCARA on AVR.
+     *
+     * Longer segments result in less kinematic overhead
+     * but may produce jagged lines. Try 0.5mm, 1.0mm, and 2.0mm
+     * and compare the difference.
+     */
+    #define SCARA_MIN_SEGMENT_LENGTH 0.5
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * Called from prepare_move_to_destination as the
    * default Delta/SCARA segmenter.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
@@ -559,72 +557,132 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / _feedrate_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
 
-    // For SCARA minimum segment size is 0.25mm
+    // For SCARA enforce a minimum segment size
     #if IS_SCARA
-      NOMORE(segments, cartesian_mm * 4);
+      NOMORE(segments, cartesian_mm * (1.0 / SCARA_MIN_SEGMENT_LENGTH));
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1);
 
     // The approximate length of each segment
     const float inv_segments = 1.0 / float(segments),
-                cartesian_segment_mm = cartesian_mm * inv_segments,
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
-    // SERIAL_ECHOPAIR("mm=", cartesian_mm);
-    // SERIAL_ECHOPAIR(" seconds=", seconds);
-    // SERIAL_ECHOLNPAIR(" segments=", segments);
-    // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
+    #if DISABLED(SCARA_FEEDRATE_SCALING)
+      const float cartesian_segment_mm = cartesian_mm * inv_segments;
+    #endif
 
-    // Get the current position as starting point
+    /*
+    SERIAL_ECHOPAIR("mm=", cartesian_mm);
+    SERIAL_ECHOPAIR(" seconds=", seconds);
+    SERIAL_ECHOPAIR(" segments=", segments);
+    #if DISABLED(SCARA_FEEDRATE_SCALING)
+      SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
+    #else
+      SERIAL_EOL();
+    #endif
+    //*/
+
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      // SCARA needs to scale the feed rate from mm/s to degrees/s
+      // i.e., Complete the angular vector in the given time.
+      const float segment_length = cartesian_mm * inv_segments,
+                  inv_segment_length = 1.0 / segment_length, // 1/mm/segs
+                  inverse_secs = inv_segment_length * _feedrate_mm_s;
+
+      float oldA = planner.position_float[A_AXIS],
+            oldB = planner.position_float[B_AXIS];
+
+      /*
+      SERIAL_ECHOPGM("Scaled kinematic move: ");
+      SERIAL_ECHOPAIR(" segment_length (inv)=", segment_length);
+      SERIAL_ECHOPAIR(" (", inv_segment_length);
+      SERIAL_ECHOPAIR(") _feedrate_mm_s=", _feedrate_mm_s);
+      SERIAL_ECHOPAIR(" inverse_secs=", inverse_secs);
+      SERIAL_ECHOPAIR(" oldA=", oldA);
+      SERIAL_ECHOLNPAIR(" oldB=", oldB);
+      safe_delay(5);
+      //*/
+    #endif
+ 
+     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
-
     // Calculate and execute the segments
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
       #if ENABLED(DELTA) && HOTENDS < 2
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        // For SCARA scale the feed rate from mm/s to degrees/s
+        // i.e., Complete the angular vector in the given time.
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+        /*
+        SERIAL_ECHO(segments);
+        SERIAL_ECHOPAIR(": X=", raw[X_AXIS]); SERIAL_ECHOPAIR(" Y=", raw[Y_AXIS]);
+        SERIAL_ECHOPAIR(" A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
+        SERIAL_ECHOLNPAIR(" F", HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs * 60);
+        safe_delay(5);
+        //*/
+        oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+      #else
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
+      #endif
     }
 
     // Ensure last segment arrives at target location.
-    planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      inverse_kinematics(rtarget);
+      ADJUST_DELTA(rtarget);
+      const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
+      if (diff2) {
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+        /*
+        SERIAL_ECHOPAIR("final: A=", delta[A_AXIS]); SERIAL_ECHOPAIR(" B=", delta[B_AXIS]);
+        SERIAL_ECHOPAIR(" adiff=", delta[A_AXIS] - oldA); SERIAL_ECHOPAIR(" bdiff=", delta[B_AXIS] - oldB);
+        SERIAL_ECHOLNPAIR(" F", (SQRT(diff2) * inverse_secs) * 60);
+        SERIAL_EOL();
+        safe_delay(5);
+        //*/
+      }
+    #else
+      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
+    #endif
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.

commit b852781ebae71e7c6fac46910b7ff44f8547365e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 16:57:06 2018 -0500

    Fix BLTOUCH compile error
    
    Followup to #10250

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ad76683f54..17097acead 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1000,28 +1000,31 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
 
   // Only do some things when moving towards an endstop
   const int8_t axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
   const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
   if (is_home_dir) {
-    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-      const bool deploy_bltouch = (axis == Z_AXIS && is_home_dir);
-      if (deploy_bltouch) set_bltouch_deployed(true);
-    #endif
 
-    #if QUIET_PROBING
-      if (axis == Z_AXIS) probing_pause(true);
-    #endif
+    if (axis == Z_AXIS) {
+      #if HOMING_Z_WITH_PROBE
+        #if ENABLED(BLTOUCH)
+          set_bltouch_deployed(true);
+        #endif
+        #if QUIET_PROBING
+          probing_pause(true);
+        #endif
+      #endif
+    }
 
     // Disable stealthChop if used. Enable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis);
     #endif
   }
 
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
@@ -1032,27 +1035,31 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
     current_position[axis] = distance;
     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #endif
 
   stepper.synchronize();
 
   if (is_home_dir) {
-    #if QUIET_PROBING
-      if (axis == Z_AXIS) probing_pause(false);
-    #endif
 
-    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-      if (deploy_bltouch) set_bltouch_deployed(false);
-    #endif
+    if (axis == Z_AXIS) {
+      #if HOMING_Z_WITH_PROBE
+        #if QUIET_PROBING
+          probing_pause(false);
+        #endif
+        #if ENABLED(BLTOUCH)
+          set_bltouch_deployed(false);
+        #endif
+      #endif
+    }
 
     endstops.hit_on_purpose();
 
     // Re-enable stealthChop if used. Disable diag1 pin on driver.
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(axis, false);
     #endif
   }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)

commit dbe2b6f7b0067f7398b85ffb57b78cd4ecb857ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 21:26:43 2018 -0500

    Do moves towards endstops differently in do_homing_move

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 414c65e3ab..ad76683f54 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -991,64 +991,76 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPAIR(", ", fr_mm_s);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
-    if (deploy_bltouch) set_bltouch_deployed(true);
-  #endif
+  // Only do some things when moving towards an endstop
+  const int8_t axis_home_dir =
+    #if ENABLED(DUAL_X_CARRIAGE)
+      (axis == X_AXIS) ? x_home_dir(active_extruder) :
+    #endif
+    home_dir(axis);
+  const bool is_home_dir = (axis_home_dir > 0) == (distance > 0);
 
-  #if QUIET_PROBING
-    if (axis == Z_AXIS) probing_pause(true);
-  #endif
+  if (is_home_dir) {
+    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+      const bool deploy_bltouch = (axis == Z_AXIS && is_home_dir);
+      if (deploy_bltouch) set_bltouch_deployed(true);
+    #endif
 
-  // Disable stealthChop if used. Enable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    sensorless_homing_per_axis(axis);
-  #endif
+    #if QUIET_PROBING
+      if (axis == Z_AXIS) probing_pause(true);
+    #endif
+
+    // Disable stealthChop if used. Enable diag1 pin on driver.
+    #if ENABLED(SENSORLESS_HOMING)
+      sensorless_homing_per_axis(axis);
+    #endif
+  }
 
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
   #if IS_SCARA
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
     current_position[axis] = distance;
     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #endif
 
   stepper.synchronize();
 
-  #if QUIET_PROBING
-    if (axis == Z_AXIS) probing_pause(false);
-  #endif
+  if (is_home_dir) {
+    #if QUIET_PROBING
+      if (axis == Z_AXIS) probing_pause(false);
+    #endif
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    if (deploy_bltouch) set_bltouch_deployed(false);
-  #endif
+    #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+      if (deploy_bltouch) set_bltouch_deployed(false);
+    #endif
 
-  endstops.hit_on_purpose();
+    endstops.hit_on_purpose();
 
-  // Re-enable stealthChop if used. Disable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    sensorless_homing_per_axis(axis, false);
-  #endif
+    // Re-enable stealthChop if used. Disable diag1 pin on driver.
+    #if ENABLED(SENSORLESS_HOMING)
+      sensorless_homing_per_axis(axis, false);
+    #endif
+  }
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 }
 

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2f04af07bd..414c65e3ab 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -259,22 +259,20 @@ void buffer_line_to_destination(const float fr_mm_s) {
   }
 
   /**
    * Calculate delta, start a line, and set current_position to destination
    */
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s/*=0.0*/) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
     #endif
 
-    gcode.refresh_cmd_timeout();
-
     #if UBL_SEGMENTED
       // ubl segmented line will do z-only moves in single segment
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
 
@@ -428,26 +426,24 @@ void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm
 void bracket_probe_move(const bool before) {
   static float saved_feedrate_mm_s;
   static int16_t saved_feedrate_percentage;
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
   #endif
   if (before) {
     saved_feedrate_mm_s = feedrate_mm_s;
     saved_feedrate_percentage = feedrate_percentage;
     feedrate_percentage = 100;
-    gcode.refresh_cmd_timeout();
   }
   else {
     feedrate_mm_s = saved_feedrate_mm_s;
     feedrate_percentage = saved_feedrate_percentage;
-    gcode.refresh_cmd_timeout();
   }
 }
 
 void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
 void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
 // Software Endstops are based on the configured limits.
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
@@ -852,21 +848,20 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
  * Make sure current_position[E] and destination[E] are good
  * before calling or cold/lengthy extrusion may get missed.
  */
 void prepare_move_to_destination() {
   clamp_to_software_endstops(destination);
-  gcode.refresh_cmd_timeout();
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);

commit 9fd1016bb1ddb21e2c736da9fbdd802708b91b96
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 05:45:23 2018 -0500

    Trust the bootloader to clear globals

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f38e7a610a..2f04af07bd 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -62,41 +62,41 @@
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
-bool relative_mode = false;
+bool relative_mode; // = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
  *   The destination for a move, filled in by G-code movement commands,
  *   and expected by functions like 'prepare_move_to_destination'.
  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0.0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
-uint8_t active_extruder = 0;
+uint8_t active_extruder; // = 0;
 
 // Extruder offsets
 #if HOTENDS > 1
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
 #endif
 
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!

commit a6feb58837fa97167f5340abaa7b1175ca858450
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 16 00:46:42 2018 -0500

    Delta support for multiple hotends with offsets (#10118)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f3ec0dfe7e..f38e7a610a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -603,21 +603,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
-      #if ENABLED(DELTA)
+      #if ENABLED(DELTA) && HOTENDS < 2
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
     }
 
     // Ensure last segment arrives at target location.

commit e7a61de8afb20718875cd4afd3ae605e51499a77
Author: Studiodyne <diabolomix@hotmail.fr>
Date:   Wed Mar 14 07:35:30 2018 +0100

    [2.0] FWRetract Reset (Best way) (#10083)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 446fd08f9f..f3ec0dfe7e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1298,24 +1298,24 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
-  // Clear retracted status if homing the Z axis
+  // Clear z_lift if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS)
-      for (uint8_t i = 0; i < EXTRUDERS; i++) fwretract.retracted[i] = false;
+      fwretract.hop_amount = 0.0;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()

commit 07cf2cd9c44bb537b7821e898a4b9e648d207352
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 13 23:15:19 2018 -0500

    Fix sensorless_homing_per_axis compile warning

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c34e163fdd..446fd08f9f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -945,20 +945,21 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
   return homing_feedrate(axis) / hbd;
 }
 
 #if ENABLED(SENSORLESS_HOMING)
 
   /**
    * Set sensorless homing if the axis has it, accounting for Core Kinematics.
    */
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable/*=true*/) {
     switch (axis) {
+      default: break;
       #if X_SENSORLESS
         case X_AXIS:
           tmc_sensorless_homing(stepperX, enable);
           #if CORE_IS_XY && Y_SENSORLESS
             tmc_sensorless_homing(stepperY, enable);
           #elif CORE_IS_XZ && Z_SENSORLESS
             tmc_sensorless_homing(stepperZ, enable);
           #endif
           break;
       #endif

commit 468f34104b0e71a3561d2dd99756220f90671e54
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 12 08:16:08 2018 -0500

    Patch do_blocking_move_to so 'destination' can be used

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a12a987163..c34e163fdd 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -283,21 +283,21 @@ void buffer_line_to_destination(const float fr_mm_s) {
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
  */
-void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
 
   #if ENABLED(DELTA)
 

commit f3914a432e33687b5a34ef2eafb7cd40cb8d4ad0
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Mon Jan 29 19:40:04 2018 +0000

    Clear retracted status when homing the Z axis

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 45adc5aa9c..a12a987163 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1297,20 +1297,26 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
+  // Clear retracted status if homing the Z axis
+  #if ENABLED(FWRETRACT)
+    if (axis == Z_AXIS)
+      for (uint8_t i = 0; i < EXTRUDERS; i++) fwretract.retracted[i] = false;
+  #endif
+
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)

commit 23a576faf701d88ba4b4d2d1cad4a4d08c4a9119
Author: Studiodyne <diabolomix@hotmail.fr>
Date:   Thu Mar 1 22:15:40 2018 +0100

    [2.0] Fix for FW retract  (#9878)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a12a987163..45adc5aa9c 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1297,26 +1297,20 @@ void homeaxis(const AxisEnum axis) {
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
-  // Clear retracted status if homing the Z axis
-  #if ENABLED(FWRETRACT)
-    if (axis == Z_AXIS)
-      for (uint8_t i = 0; i < EXTRUDERS; i++) fwretract.retracted[i] = false;
-  #endif
-
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)

commit 91db7930dc7c8e429f579549544183ac94c59200
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 1 04:30:41 2018 -0600

    Drop SCARA_FEEDRATE_SCALING
    
    The updated planner takes the length of the move, so this pre-calculation is no longer needed.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 819faf1ef6..a12a987163 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -586,28 +586,20 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
     // SERIAL_ECHOPAIR(" seconds=", seconds);
     // SERIAL_ECHOLNPAIR(" segments=", segments);
     // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      // SCARA needs to scale the feed rate from mm/s to degrees/s
-      const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
-                  inverse_secs = inv_segment_length * _feedrate_mm_s;
-      float oldA = stepper.get_axis_position_degrees(A_AXIS),
-            oldB = stepper.get_axis_position_degrees(B_AXIS);
-    #endif
-
     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
 
     // Calculate and execute the segments
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
@@ -618,38 +610,25 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
       #if ENABLED(DELTA)
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        // For SCARA scale the feed rate from mm/s to degrees/s
-        // i.e., Complete the angular vector in the given time.
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, cartesian_segment_mm);
-        oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
-      #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
-      #endif
+      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
     }
 
     // Ensure last segment arrives at target location.
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      inverse_kinematics(rtarget);
-      ADJUST_DELTA(rtarget);
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, cartesian_segment_mm);
-    #else
-      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
-    #endif
+    planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.

commit a446433c87dc8b715ed5b9d98a34104f90b676b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 1 01:37:31 2018 -0600

    Fix SENSORLESS_HOMING for Core Kinematics (#9868)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a3831ff983..819faf1ef6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -959,20 +959,62 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
+#if ENABLED(SENSORLESS_HOMING)
+
+  /**
+   * Set sensorless homing if the axis has it, accounting for Core Kinematics.
+   */
+  void sensorless_homing_per_axis(const AxisEnum axis, const bool enable/*=true*/) {
+    switch (axis) {
+      #if X_SENSORLESS
+        case X_AXIS:
+          tmc_sensorless_homing(stepperX, enable);
+          #if CORE_IS_XY && Y_SENSORLESS
+            tmc_sensorless_homing(stepperY, enable);
+          #elif CORE_IS_XZ && Z_SENSORLESS
+            tmc_sensorless_homing(stepperZ, enable);
+          #endif
+          break;
+      #endif
+      #if Y_SENSORLESS
+        case Y_AXIS:
+          tmc_sensorless_homing(stepperY, enable);
+          #if CORE_IS_XY && X_SENSORLESS
+            tmc_sensorless_homing(stepperX, enable);
+          #elif CORE_IS_YZ && Z_SENSORLESS
+            tmc_sensorless_homing(stepperZ, enable);
+          #endif
+          break;
+      #endif
+      #if Z_SENSORLESS
+        case Z_AXIS:
+          tmc_sensorless_homing(stepperZ, enable);
+          #if CORE_IS_XZ && X_SENSORLESS
+            tmc_sensorless_homing(stepperX, enable);
+          #elif CORE_IS_YZ && Y_SENSORLESS
+            tmc_sensorless_homing(stepperY, enable);
+          #endif
+          break;
+      #endif
+    }
+  }
+
+#endif // SENSORLESS_HOMING
+
 /**
  * Home an individual linear axis
  */
 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
       SERIAL_ECHOPAIR(", ", distance);
       SERIAL_ECHOPAIR(", ", fr_mm_s);
@@ -985,29 +1027,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
     if (deploy_bltouch) set_bltouch_deployed(true);
   #endif
 
   #if QUIET_PROBING
     if (axis == Z_AXIS) probing_pause(true);
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
-      if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
-    #endif
-    #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
-      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
-    #endif
-    #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
-      if (axis == Z_AXIS) tmc_sensorless_homing(stepperZ);
-    #endif
+    sensorless_homing_per_axis(axis);
   #endif
 
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
   #if IS_SCARA
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
@@ -1024,29 +1058,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #endif
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     if (deploy_bltouch) set_bltouch_deployed(false);
   #endif
 
   endstops.hit_on_purpose();
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
-      if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
-    #endif
-    #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
-      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
-    #endif
-    #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
-      if (axis == Z_AXIS) tmc_sensorless_homing(stepperZ, false);
-    #endif
+    sensorless_homing_per_axis(axis, false);
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 }

commit 1541224a81a80b91a1ac2009c917f1f33e816cfb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Feb 8 04:20:44 2018 -0600

    Enable Z axis and delta sensorless homing (#9516)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 5a4f49619e..a3831ff983 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -983,20 +983,33 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
     if (deploy_bltouch) set_bltouch_deployed(true);
   #endif
 
   #if QUIET_PROBING
     if (axis == Z_AXIS) probing_pause(true);
   #endif
 
+  // Disable stealthChop if used. Enable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+      if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
+    #endif
+    #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
+    #endif
+    #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
+      if (axis == Z_AXIS) tmc_sensorless_homing(stepperZ);
+    #endif
+  #endif
+
   // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
   #if IS_SCARA
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
@@ -1009,20 +1022,33 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
   #if QUIET_PROBING
     if (axis == Z_AXIS) probing_pause(false);
   #endif
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     if (deploy_bltouch) set_bltouch_deployed(false);
   #endif
 
   endstops.hit_on_purpose();
 
+  // Re-enable stealthChop if used. Disable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+      if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
+    #endif
+    #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
+    #endif
+    #if ENABLED(Z_IS_TMC2130) && defined(Z_HOMING_SENSITIVITY)
+      if (axis == Z_AXIS) tmc_sensorless_homing(stepperZ, false);
+    #endif
+  #endif
+
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 }
 
 /**
@@ -1161,30 +1187,20 @@ void homeaxis(const AxisEnum axis) {
   #if ENABLED(X_DUAL_ENDSTOPS)
     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
   #endif
   #if ENABLED(Y_DUAL_ENDSTOPS)
     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
   #endif
   #if ENABLED(Z_DUAL_ENDSTOPS)
     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   #endif
 
-  // Disable stealthChop if used. Enable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
-    #endif
-  #endif
-
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
   const float bump = axis_home_dir * (
     #if HOMING_Z_WITH_PROBE
       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
@@ -1271,30 +1287,20 @@ void homeaxis(const AxisEnum axis) {
     sync_plan_position();
 
     destination[axis] = current_position[axis];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
-  // Re-enable stealthChop if used. Disable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
-    #endif
-  #endif
-
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   // Clear retracted status if homing the Z axis
   #if ENABLED(FWRETRACT)
     if (axis == Z_AXIS)
       for (uint8_t i = 0; i < EXTRUDERS; i++) fwretract.retracted[i] = false;
   #endif

commit 786746404b8aa58c44a93734afd61c701d2abecb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Feb 4 00:26:05 2018 -0600

    [2.0.x] Apply feedrate to nozzle movement for kinematic machines (#8778)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b167365c9a..5a4f49619e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -573,30 +573,32 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // For SCARA minimum segment size is 0.25mm
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * 4);
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1);
 
     // The approximate length of each segment
     const float inv_segments = 1.0 / float(segments),
+                cartesian_segment_mm = cartesian_mm * inv_segments,
                 segment_distance[XYZE] = {
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
     // SERIAL_ECHOPAIR(" seconds=", seconds);
     // SERIAL_ECHOLNPAIR(" segments=", segments);
+    // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
                   inverse_secs = inv_segment_length * _feedrate_mm_s;
       float oldA = stepper.get_axis_position_degrees(A_AXIS),
             oldB = stepper.get_axis_position_degrees(B_AXIS);
     #endif
 
     // Get the current position as starting point
@@ -619,34 +621,34 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #if ENABLED(DELTA)
         DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // i.e., Complete the angular vector in the given time.
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, cartesian_segment_mm);
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
       #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder, cartesian_segment_mm);
       #endif
     }
 
     // Ensure last segment arrives at target location.
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, cartesian_segment_mm);
     #else
-      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
+      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder, cartesian_segment_mm);
     #endif
 
     return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
@@ -678,49 +680,51 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
       if (UNEAR_ZERO(cartesian_mm)) return;
 
       // The length divided by the segment size
       // At least one segment is required
       uint16_t segments = cartesian_mm / segment_size;
       NOLESS(segments, 1);
 
       // The approximate length of each segment
       const float inv_segments = 1.0 / float(segments),
+                  cartesian_segment_mm = cartesian_mm * inv_segments,
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
+      // SERIAL_ECHOLNPAIR(" segment_mm=", cartesian_segment_mm);
 
       // Get the raw current position as starting point
       float raw[XYZE];
       COPY(raw, current_position);
 
       // Calculate and execute the segments
       while (--segments) {
         static millis_t next_idle_ms = millis() + 200UL;
         thermalManager.manage_heater();  // This returns immediately if not really needed.
         if (ELAPSED(millis(), next_idle_ms)) {
           next_idle_ms = millis() + 200UL;
           idle();
         }
         LOOP_XYZE(i) raw[i] += segment_distance[i];
-        planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+        planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder, cartesian_segment_mm);
       }
 
       // Since segment_distance is only approximate,
       // the final move must be to the exact destination.
-      planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
+      planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder, cartesian_segment_mm);
     }
 
   #endif // SEGMENT_LEVELED_MOVES
 
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *

commit ea9ad4e46d9dea69e1e3fe851912f287f12d2ad1
Author: GMagician <3684609+GMagician@users.noreply.github.com>
Date:   Fri Feb 2 08:44:48 2018 +0100

    [2.0.x] Fix compile error on delta when NO_WORKSPACE_OFFSETS (#9388)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a3005202ba..b167365c9a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1297,21 +1297,21 @@ void homeaxis(const AxisEnum axis) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
-#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
@@ -1375,21 +1375,21 @@ void homeaxis(const AxisEnum axis) {
             soft_endstop_radius_2 = sq(soft_endstop_radius);
             break;
         #endif
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
     #endif
   }
 
-#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
+#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE || DELTA
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis.
    * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
     home_offset[axis] = v;
     update_software_endstops(axis);
   }

commit 703547198216c7c7aec903f6e4a7fd3e0de46904
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Mon Jan 29 19:40:04 2018 +0000

    Clear retracted status when homing the Z axis

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 90960ad8c6..a3005202ba 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -48,20 +48,24 @@
 #endif
 
 #if HAS_AXIS_UNHOMED_ERR && ENABLED(ULTRA_LCD)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc_util.h"
 #endif
 
+#if ENABLED(FWRETRACT)
+  #include "../feature/fwretract.h"
+#endif
+
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
@@ -1278,20 +1282,26 @@ void homeaxis(const AxisEnum axis) {
     #if ENABLED(Y_IS_TMC2130)
       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
     #endif
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
+  // Clear retracted status if homing the Z axis
+  #if ENABLED(FWRETRACT)
+    if (axis == Z_AXIS)
+      for (uint8_t i = 0; i < EXTRUDERS; i++) fwretract.retracted[i] = false;
+  #endif
+
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)

commit 51c7b5d46f1d2e5eb9cd7f0db67499591f6ad434
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 06:10:35 2018 -0600

    Fix set_home_offset bug from bad porting

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b1155e7f07..90960ad8c6 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1369,23 +1369,18 @@ void homeaxis(const AxisEnum axis) {
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
     #endif
   }
 
 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
 
 #if HAS_M206_COMMAND
   /**
-   * Change the home offset for an axis, update the current
-   * position and the software endstops to retain the same
-   * relative distance to the new home.
-   *
-   * Since this changes the current_position, code should
-   * call sync_plan_position soon after this.
+   * Change the home offset for an axis.
+   * Also refreshes the workspace offset.
    */
   void set_home_offset(const AxisEnum axis, const float v) {
-    current_position[axis] += v - home_offset[axis];
     home_offset[axis] = v;
     update_software_endstops(axis);
   }
 #endif // HAS_M206_COMMAND

commit 44239b1062d25e585d1627cce0fbf433d6d5cfb7
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Jan 20 09:40:36 2018 -0600

    Allow DELTA to compile with soft endstops disabled

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fc24f4c5bf..b1155e7f07 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1350,26 +1350,28 @@ void homeaxis(const AxisEnum axis) {
         #if HAS_POSITION_SHIFT
           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
         #endif
         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
 
     #if ENABLED(DELTA)
       switch(axis) {
-        case X_AXIS:
-        case Y_AXIS:
-          // Get a minimum radius for clamping
-          soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
-          soft_endstop_radius_2 = sq(soft_endstop_radius);
-          break;
+        #if HAS_SOFTWARE_ENDSTOPS
+          case X_AXIS:
+          case Y_AXIS:
+            // Get a minimum radius for clamping
+            soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
+            soft_endstop_radius_2 = sq(soft_endstop_radius);
+            break;
+        #endif
         case Z_AXIS:
           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
         default: break;
       }
     #endif
   }
 
 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
 
 #if HAS_M206_COMMAND

commit d80c4f1a6ef00657a32997c1cb041b45cf46e76d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 31 01:39:45 2017 -0600

    Fix typo in delta call to buffer_line
    
    Fix #8901

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8214bf4759..fc24f4c5bf 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -618,21 +618,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // i.e., Complete the angular vector in the given time.
         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
       #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
       #endif
     }
 
     // Ensure last segment arrives at target location.
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);

commit 705ea98fd3a243c8a0332b34d076deceb5a5cf6a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 24 22:56:23 2017 -0600

    Comment `return false` in motion functions

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b13438dab5..8214bf4759 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -533,21 +533,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
 
     // If the move is only in Z/E don't split up the move
     if (!xdiff && !ydiff) {
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
-      return false;
+      return false; // caller will update current_position
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
 
     // Remaining cartesian distances
     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
 
     // Get the linear distance in XYZ
@@ -631,21 +631,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 
     // Ensure last segment arrives at target location.
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
-    return false;
+    return false; // caller will update current_position
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)
 
     /**
      * Prepare a segmented move on a CARTESIAN setup.
      *
      * This calls planner.buffer_line several times, adding
@@ -723,40 +723,40 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
    * Returns true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_cartesian() {
     #if HAS_MESH
       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
           return true;                                                                    // all moves, including Z-only moves.
         #elif ENABLED(SEGMENT_LEVELED_MOVES)
           segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
-          return false;
+          return false; // caller will update current_position
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
-    return false;
+    return false; // caller will update current_position
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_SEGMENTED
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)

commit caa50934984692e7b0de8aeb05438be9a19ce660
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 22:41:57 2017 -0600

    General DELTA_IK macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 11803c184b..b13438dab5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -606,21 +606,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
 
       #if ENABLED(DELTA)
-        DELTA_RAW_IK(); // Delta can inline its kinematics
+        DELTA_IK(raw); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // i.e., Complete the angular vector in the given time.
         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];

commit c6946084505149b2d20e0129eb13130f7a6af53d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 21:43:39 2017 -0600

    Apply SCARA_FEEDRATE_SCALING to G2/G3

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 731335356d..11803c184b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -580,21 +580,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
                   xdiff * inv_segments,
                   ydiff * inv_segments,
                   zdiff * inv_segments,
                   ediff * inv_segments
                 };
 
     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
     // SERIAL_ECHOPAIR(" seconds=", seconds);
     // SERIAL_ECHOLNPAIR(" segments=", segments);
 
-    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
                   inverse_secs = inv_segment_length * _feedrate_mm_s;
       float oldA = stepper.get_axis_position_degrees(A_AXIS),
             oldB = stepper.get_axis_position_degrees(B_AXIS);
     #endif
 
     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
@@ -604,52 +604,43 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
+
       #if ENABLED(DELTA)
         DELTA_RAW_IK(); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
-
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
-      #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
-        // Use ratio between the length of the move and the larger angle change
-        const float adiff = abs(delta[A_AXIS] - oldA),
-                    bdiff = abs(delta[B_AXIS] - oldB);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * inverse_secs, active_extruder);
-        oldA = delta[A_AXIS];
-        oldB = delta[B_AXIS];
+        // i.e., Complete the angular vector in the given time.
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+        oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
       #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
       #endif
     }
 
-    // Since segment_distance is only approximate,
-    // the final move must be to the exact destination.
-
-    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
-      // For SCARA scale the feed rate from mm/s to degrees/s
-      // With segments > 1 length is 1 segment, otherwise total length
+    // Ensure last segment arrives at target location.
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
-      const float adiff = abs(delta[A_AXIS] - oldA),
-                  bdiff = abs(delta[B_AXIS] - oldB);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * inverse_secs, active_extruder);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 93eabc436b..731335356d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -45,21 +45,21 @@
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_AXIS_UNHOMED_ERR && ENABLED(ULTRA_LCD)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
-  #include "../feature/tmc2130.h"
+  #include "../feature/tmc_util.h"
 #endif
 
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
@@ -1165,24 +1165,24 @@ void homeaxis(const AxisEnum axis) {
   #if ENABLED(Y_DUAL_ENDSTOPS)
     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
   #endif
   #if ENABLED(Z_DUAL_ENDSTOPS)
     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_HOMING)
     #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
+      if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
     #endif
     #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
+      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
     #endif
   #endif
 
   // Fast move towards endstop until triggered
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   #endif
   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
 
   // When homing Z with probe respect probe clearance
@@ -1275,24 +1275,24 @@ void homeaxis(const AxisEnum axis) {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
     #endif
 
   #endif
 
   // Re-enable stealthChop if used. Disable diag1 pin on driver.
   #if ENABLED(SENSORLESS_HOMING)
     #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
+      if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
     #endif
     #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
+      if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
     #endif
   #endif
 
   // Put away the Z probe
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && STOW_PROBE()) return;
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {

commit 24f9bec6f4c806221b4f51b27fde711e01c10e95
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 08:00:47 2017 -0600

    UBL + DUAL_X_CARRIAGE compatibility

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 12c75f7ab4..93eabc436b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -789,21 +789,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
        * without firmware reflash (through the M218 command).
        */
       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
   }
 
   /**
    * Prepare a linear move in a dual X axis setup
    *
    * Return true if current_position[] was set to destination[]
    */
-  inline bool prepare_move_to_destination_dualx() {
+  inline bool dual_x_carriage_unpark() {
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
           break;
         case DXC_AUTO_PARK_MODE:
           if (current_position[E_AXIS] == destination[E_AXIS]) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
@@ -858,21 +858,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
             #endif
           }
           break;
       }
     }
-    return prepare_move_to_destination_cartesian();
+    return false;
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  *
@@ -899,27 +899,29 @@ void prepare_move_to_destination() {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
+  #if ENABLED(DUAL_X_CARRIAGE)
+    if (dual_x_carriage_unpark()) return;
+  #endif
+
   if (
     #if UBL_SEGMENTED
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
-    #elif ENABLED(DUAL_X_CARRIAGE)
-      prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_from_destination();
 }
 
 #if HAS_AXIS_UNHOMED_ERR
 

commit a71d2f3f40639945676eede207a9b4f4f5c6d122
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:11:31 2017 -0600

    UBL_DELTA => UBL_SEGMENTED

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index dba1655f4d..12c75f7ab4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -257,21 +257,21 @@ void buffer_line_to_destination(const float fr_mm_s) {
   /**
    * Calculate delta, start a line, and set current_position to destination
    */
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s/*=0.0*/) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
     #endif
 
     gcode.refresh_cmd_timeout();
 
-    #if UBL_DELTA
+    #if UBL_SEGMENTED
       // ubl segmented line will do z-only moves in single segment
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
 
       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
@@ -488,21 +488,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
     #endif
     #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
-#if !UBL_DELTA
+#if !UBL_SEGMENTED
 #if IS_KINEMATIC
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     #if ENABLED(DELTA)
       #define ADJUST_DELTA(V) \
         if (planner.leveling_active) { \
           const float zadj = bilinear_z_offset(V); \
           delta[A_AXIS] += zadj; \
           delta[B_AXIS] += zadj; \
           delta[C_AXIS] += zadj; \
@@ -755,21 +755,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           }
         #endif
       }
     #endif // HAS_MESH
 
     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false;
   }
 
 #endif // !IS_KINEMATIC
-#endif // !UBL_DELTA
+#endif // !UBL_SEGMENTED
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
@@ -900,21 +900,21 @@ void prepare_move_to_destination() {
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   if (
-    #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
+    #if UBL_SEGMENTED
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1384cb9c52..dba1655f4d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -510,27 +510,33 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #else
       #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
     #endif
   #else
     #define ADJUST_DELTA(V) NOOP
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
+   * Called from prepare_move_to_destination as the
+   * default Delta/SCARA segmenter.
+   *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    *
    * For Unified Bed Leveling (Delta or Segmented Cartesian)
    * the ubl.prepare_segmented_line_to method replaces this.
+   *
+   * For Auto Bed Leveling (Bilinear) with SEGMENT_LEVELED_MOVES
+   * this is replaced by segmented_line_to_destination below.
    */
-  inline bool prepare_kinematic_move_to(float rtarget[XYZE]) {
+  inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
 
     // If the move is only in Z/E don't split up the move
     if (!xdiff && !ydiff) {
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);

commit 03ba79f1446034d3313e86bfd5d2790728772392
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 10 21:17:07 2017 -0600

    Sync and report changed position

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b013faf353..1384cb9c52 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -204,20 +204,26 @@ void get_cartesian_from_steppers() {
       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
     #endif
     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
+ *
+ * To prevent small shifts in axis position always call
+ * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
+ *
+ * To keep hosts in sync, always call report_current_position
+ * after updating the current_position.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   #if PLANNER_LEVELING
     planner.unapply_leveling(cartes);
   #endif
   if (axis == ALL_AXES)
     COPY(current_position, cartes);
   else
     current_position[axis] = cartes[axis];

commit 81c0a918af8b6e21cb969ecb31f854f4712e7ca1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 23:03:33 2017 -0600

    feed_factor => inverse_secs

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8ed841be3a..b013faf353 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -571,21 +571,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
                   ediff * inv_segments
                 };
 
     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
     // SERIAL_ECHOPAIR(" seconds=", seconds);
     // SERIAL_ECHOLNPAIR(" segments=", segments);
 
     #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
-                  feed_factor = inv_segment_length * _feedrate_mm_s;
+                  inverse_secs = inv_segment_length * _feedrate_mm_s;
       float oldA = stepper.get_axis_position_degrees(A_AXIS),
             oldB = stepper.get_axis_position_degrees(B_AXIS);
     #endif
 
     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
 
     // Calculate and execute the segments
@@ -605,39 +605,39 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
         inverse_kinematics(raw);
       #endif
 
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // Use ratio between the length of the move and the larger angle change
         const float adiff = abs(delta[A_AXIS] - oldA),
                     bdiff = abs(delta[B_AXIS] - oldB);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * inverse_secs, active_extruder);
         oldA = delta[A_AXIS];
         oldB = delta[B_AXIS];
       #else
         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
       #endif
     }
 
     // Since segment_distance is only approximate,
     // the final move must be to the exact destination.
 
     #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // With segments > 1 length is 1 segment, otherwise total length
       inverse_kinematics(rtarget);
       ADJUST_DELTA(rtarget);
       const float adiff = abs(delta[A_AXIS] - oldA),
                   bdiff = abs(delta[B_AXIS] - oldB);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * inverse_secs, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
 #else // !IS_KINEMATIC
 
   #if ENABLED(SEGMENT_LEVELED_MOVES)

commit 840289e7ccaa79846acfdceee63ffc1baa77168c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:44:44 2017 -0600

    Use block cleaning instead of split flag

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 503a0e97c9..8ed841be3a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -419,27 +419,25 @@ void bracket_probe_move(const bool before) {
   static float saved_feedrate_mm_s;
   static int16_t saved_feedrate_percentage;
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
   #endif
   if (before) {
     saved_feedrate_mm_s = feedrate_mm_s;
     saved_feedrate_percentage = feedrate_percentage;
     feedrate_percentage = 100;
     gcode.refresh_cmd_timeout();
-    planner.split_first_move = false;
   }
   else {
     feedrate_mm_s = saved_feedrate_mm_s;
     feedrate_percentage = saved_feedrate_percentage;
     gcode.refresh_cmd_timeout();
-    planner.split_first_move = true;
   }
 }
 
 void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
 void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
 // Software Endstops are based on the configured limits.
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 

commit a993c5227d4b48106798b08b327a36a53d60d302
Author: AnHardt <github@kitelab.de>
Date:   Wed Dec 6 14:08:49 2017 +0100

    Don't split first_move while homing or probing
    While homing or probing it might be bad if the stop/trobe triggers during the first part and the second is still in the buffer.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8ed841be3a..503a0e97c9 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -419,25 +419,27 @@ void bracket_probe_move(const bool before) {
   static float saved_feedrate_mm_s;
   static int16_t saved_feedrate_percentage;
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
   #endif
   if (before) {
     saved_feedrate_mm_s = feedrate_mm_s;
     saved_feedrate_percentage = feedrate_percentage;
     feedrate_percentage = 100;
     gcode.refresh_cmd_timeout();
+    planner.split_first_move = false;
   }
   else {
     feedrate_mm_s = saved_feedrate_mm_s;
     feedrate_percentage = saved_feedrate_percentage;
     gcode.refresh_cmd_timeout();
+    planner.split_first_move = true;
   }
 }
 
 void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
 void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
 // Software Endstops are based on the configured limits.
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 

commit 63a91cd37a3d1c73dfa76a008378efec825e3104
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 2 21:02:37 2017 -0600

    Fix a homing comment

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index fdde5c00ea..8ed841be3a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -970,21 +970,21 @@ static void do_homing_move(const AxisEnum axis, const float distance, const floa
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
     if (deploy_bltouch) set_bltouch_deployed(true);
   #endif
 
   #if QUIET_PROBING
     if (axis == Z_AXIS) probing_pause(true);
   #endif
 
-  // Tell the planner we're at Z=0
+  // Tell the planner the axis is at 0
   current_position[axis] = 0;
 
   #if IS_SCARA
     SYNC_PLAN_POSITION_KINEMATIC();
     current_position[axis] = distance;
     inverse_kinematics(current_position);
     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
   #else
     sync_plan_position();
     current_position[axis] = distance;

commit 000b3b3117c500f51be05cdb136ce56617edd69a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 21:43:44 2017 -0600

    Comment/cleanup of motion code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a8bd25ef0f..fdde5c00ea 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -580,26 +580,23 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
                   feed_factor = inv_segment_length * _feedrate_mm_s;
       float oldA = stepper.get_axis_position_degrees(A_AXIS),
             oldB = stepper.get_axis_position_degrees(B_AXIS);
     #endif
 
     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
-    // Drop one segment so the last move is to the exact target.
-    // If there's only 1 segment, loops will be skipped entirely.
-    --segments;
 
     // Calculate and execute the segments
-    for (uint16_t s = segments + 1; --s;) {
+    while (--segments) {
 
       static millis_t next_idle_ms = millis() + 200UL;
       thermalManager.manage_heater();  // This returns immediately if not really needed.
       if (ELAPSED(millis(), next_idle_ms)) {
         next_idle_ms = millis() + 200UL;
         idle();
       }
 
       LOOP_XYZE(i) raw[i] += segment_distance[i];
       #if ENABLED(DELTA)
@@ -684,30 +681,26 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
                   segment_distance[XYZE] = {
                     xdiff * inv_segments,
                     ydiff * inv_segments,
                     zdiff * inv_segments,
                     ediff * inv_segments
                   };
 
       // SERIAL_ECHOPAIR("mm=", cartesian_mm);
       // SERIAL_ECHOLNPAIR(" segments=", segments);
 
-      // Drop one segment so the last move is to the exact target.
-      // If there's only 1 segment, loops will be skipped entirely.
-      --segments;
-
       // Get the raw current position as starting point
       float raw[XYZE];
       COPY(raw, current_position);
 
       // Calculate and execute the segments
-      for (uint16_t s = segments + 1; --s;) {
+      while (--segments) {
         static millis_t next_idle_ms = millis() + 200UL;
         thermalManager.manage_heater();  // This returns immediately if not really needed.
         if (ELAPSED(millis(), next_idle_ms)) {
           next_idle_ms = millis() + 200UL;
           idle();
         }
         LOOP_XYZE(i) raw[i] += segment_distance[i];
         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
       }
 

commit ef2531558cab8317a772ac766ae5243d742fc89a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 29 15:30:42 2017 -0600

    Add an option to segment leveled moves

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index c026712c68..a8bd25ef0f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -515,42 +515,41 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
    * small incremental moves for DELTA or SCARA.
    *
    * For Unified Bed Leveling (Delta or Segmented Cartesian)
    * the ubl.prepare_segmented_line_to method replaces this.
    */
   inline bool prepare_kinematic_move_to(float rtarget[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
+    const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
+                ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
+
     // If the move is only in Z/E don't split up the move
-    if (rtarget[X_AXIS] == current_position[X_AXIS] && rtarget[Y_AXIS] == current_position[Y_AXIS]) {
+    if (!xdiff && !ydiff) {
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
       return false;
     }
 
     // Fail if attempting move outside printable radius
     if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
 
-    // Get the cartesian distances moved in XYZE
-    const float difference[XYZE] = {
-      rtarget[X_AXIS] - current_position[X_AXIS],
-      rtarget[Y_AXIS] - current_position[Y_AXIS],
-      rtarget[Z_AXIS] - current_position[Z_AXIS],
-      rtarget[E_AXIS] - current_position[E_AXIS]
-    };
+    // Remaining cartesian distances
+    const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
+                ediff = rtarget[E_AXIS] - current_position[E_AXIS];
 
     // Get the linear distance in XYZ
-    float cartesian_mm = SQRT(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
+    float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
 
     // If the move is very short, check the E move distance
-    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(difference[E_AXIS]);
+    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
 
     // Minimum number of seconds to move the given distance
     const float seconds = cartesian_mm / _feedrate_mm_s;
 
     // The number of segments-per-second times the duration
     // gives the number of segments
     uint16_t segments = delta_segments_per_second * seconds;
@@ -559,24 +558,24 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #if IS_SCARA
       NOMORE(segments, cartesian_mm * 4);
     #endif
 
     // At least one segment is required
     NOLESS(segments, 1);
 
     // The approximate length of each segment
     const float inv_segments = 1.0 / float(segments),
                 segment_distance[XYZE] = {
-                  difference[X_AXIS] * inv_segments,
-                  difference[Y_AXIS] * inv_segments,
-                  difference[Z_AXIS] * inv_segments,
-                  difference[E_AXIS] * inv_segments
+                  xdiff * inv_segments,
+                  ydiff * inv_segments,
+                  zdiff * inv_segments,
+                  ediff * inv_segments
                 };
 
     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
     // SERIAL_ECHOPAIR(" seconds=", seconds);
     // SERIAL_ECHOLNPAIR(" segments=", segments);
 
     #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
                   feed_factor = inv_segment_length * _feedrate_mm_s;
@@ -637,34 +636,112 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
 #else // !IS_KINEMATIC
 
+  #if ENABLED(SEGMENT_LEVELED_MOVES)
+
+    /**
+     * Prepare a segmented move on a CARTESIAN setup.
+     *
+     * This calls planner.buffer_line several times, adding
+     * small incremental moves. This allows the planner to
+     * apply more detailed bed leveling to the full move.
+     */
+    inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
+
+      const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
+                  ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
+
+      // If the move is only in Z/E don't split up the move
+      if (!xdiff && !ydiff) {
+        planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
+        return;
+      }
+
+      // Remaining cartesian distances
+      const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
+                  ediff = destination[E_AXIS] - current_position[E_AXIS];
+
+      // Get the linear distance in XYZ
+      // If the move is very short, check the E move distance
+      // No E move either? Game over.
+      float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
+      if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
+      if (UNEAR_ZERO(cartesian_mm)) return;
+
+      // The length divided by the segment size
+      // At least one segment is required
+      uint16_t segments = cartesian_mm / segment_size;
+      NOLESS(segments, 1);
+
+      // The approximate length of each segment
+      const float inv_segments = 1.0 / float(segments),
+                  segment_distance[XYZE] = {
+                    xdiff * inv_segments,
+                    ydiff * inv_segments,
+                    zdiff * inv_segments,
+                    ediff * inv_segments
+                  };
+
+      // SERIAL_ECHOPAIR("mm=", cartesian_mm);
+      // SERIAL_ECHOLNPAIR(" segments=", segments);
+
+      // Drop one segment so the last move is to the exact target.
+      // If there's only 1 segment, loops will be skipped entirely.
+      --segments;
+
+      // Get the raw current position as starting point
+      float raw[XYZE];
+      COPY(raw, current_position);
+
+      // Calculate and execute the segments
+      for (uint16_t s = segments + 1; --s;) {
+        static millis_t next_idle_ms = millis() + 200UL;
+        thermalManager.manage_heater();  // This returns immediately if not really needed.
+        if (ELAPSED(millis(), next_idle_ms)) {
+          next_idle_ms = millis() + 200UL;
+          idle();
+        }
+        LOOP_XYZE(i) raw[i] += segment_distance[i];
+        planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+      }
+
+      // Since segment_distance is only approximate,
+      // the final move must be to the exact destination.
+      planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
+    }
+
+  #endif // SEGMENT_LEVELED_MOVES
+
   /**
    * Prepare a linear move in a Cartesian setup.
    *
    * When a mesh-based leveling system is active, moves are segmented
    * according to the configuration of the leveling system.
    *
    * Returns true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_cartesian() {
     #if HAS_MESH
-      if (planner.leveling_active) {
+      if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
           return true;                                                                    // all moves, including Z-only moves.
+        #elif ENABLED(SEGMENT_LEVELED_MOVES)
+          segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
+          return false;
         #else
           /**
            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
            * Otherwise fall through to do a direct single move.
            */
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));

commit 02aa93a6ad3047eeac2648fb689b6fb77862ca29
Author: AnHardt <github@kitelab.de>
Date:   Tue Nov 28 17:03:51 2017 +0100

    Fix Watchdog time out during long lasting DELTA moves
    
    During long lasting moves of a delta machine neither the temperatures are maintained nor buttons checked nor ... .
    The fix is to call 'manage_heater()' and 'idle()' every now and then in the loop where the move is segmented.
    The code is abot the same as in G2_G3 wher we had the same problem with too large circles lasting too long.
    Fixing #7510

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 045a088dfe..c026712c68 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -587,20 +587,28 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // Get the current position as starting point
     float raw[XYZE];
     COPY(raw, current_position);
 
     // Drop one segment so the last move is to the exact target.
     // If there's only 1 segment, loops will be skipped entirely.
     --segments;
 
     // Calculate and execute the segments
     for (uint16_t s = segments + 1; --s;) {
+
+      static millis_t next_idle_ms = millis() + 200UL;
+      thermalManager.manage_heater();  // This returns immediately if not really needed.
+      if (ELAPSED(millis(), next_idle_ms)) {
+        next_idle_ms = millis() + 200UL;
+        idle();
+      }
+
       LOOP_XYZE(i) raw[i] += segment_distance[i];
       #if ENABLED(DELTA)
         DELTA_RAW_IK(); // Delta can inline its kinematics
       #else
         inverse_kinematics(raw);
       #endif
 
       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)

commit 25674da90cdb25ebb8382512f2141363b3ca4dda
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 25 23:31:16 2017 -0600

    Tweaks to do_blocking_move

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 3efd8658fa..045a088dfe 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -280,20 +280,22 @@ void buffer_line_to_destination(const float fr_mm_s) {
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
  */
 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
+  const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+
   #if ENABLED(DELTA)
 
     if (!position_is_reachable(rx, ry)) return;
 
     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
     set_destination_from_current();          // sync destination at the start
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
@@ -304,91 +306,89 @@ void do_blocking_move_to(const float &rx, const float &ry, const float &rz, cons
       if (rz > delta_clip_start_height) {   // staying in the danger zone
         destination[X_AXIS] = rx;           // move directly (uninterpolated)
         destination[Y_AXIS] = ry;
         destination[Z_AXIS] = rz;
         prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         #endif
         return;
       }
-      else {
-        destination[Z_AXIS] = delta_clip_start_height;
-        prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
-        #endif
-      }
+      destination[Z_AXIS] = delta_clip_start_height;
+      prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
+      #endif
     }
 
     if (rz > current_position[Z_AXIS]) {    // raising?
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
+      prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
       #endif
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
     prepare_move_to_destination();         // set_current_from_destination()
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
     #endif
 
     if (rz < current_position[Z_AXIS]) {    // lowering?
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
+      prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
       #endif
     }
 
   #elif IS_SCARA
 
     if (!position_is_reachable(rx, ry)) return;
 
     set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
     if (destination[Z_AXIS] < rz) {
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+      prepare_uninterpolated_move_to_destination(z_feedrate);
     }
 
     destination[X_AXIS] = rx;
     destination[Y_AXIS] = ry;
     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
 
     // If Z needs to lower, do it after moving XY
     if (destination[Z_AXIS] > rz) {
       destination[Z_AXIS] = rz;
-      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+      prepare_uninterpolated_move_to_destination(z_feedrate);
     }
 
   #else
 
     // If Z needs to raise, do it before moving XY
     if (current_position[Z_AXIS] < rz) {
-      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      feedrate_mm_s = z_feedrate;
       current_position[Z_AXIS] = rz;
       line_to_current_position();
     }
 
     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
     current_position[X_AXIS] = rx;
     current_position[Y_AXIS] = ry;
     line_to_current_position();
 
     // If Z needs to lower, do it after moving XY
     if (current_position[Z_AXIS] > rz) {
-      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      feedrate_mm_s = z_feedrate;
       current_position[Z_AXIS] = rz;
       line_to_current_position();
     }
 
   #endif
 
   stepper.synchronize();
 
   feedrate_mm_s = old_feedrate_mm_s;
 

commit f5d210c35cad6c7fdb124f901218bd2c4c915fb5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 12 23:02:53 2017 -0600

    Fix report_current_position

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f204b18e9b..3efd8658fa 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -140,25 +140,25 @@ float cartes[XYZ];
 
 #if OLDSCHOOL_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
   SERIAL_PROTOCOLPGM("X:");
-  SERIAL_PROTOCOL(current_position[X_AXIS]);
+  SERIAL_PROTOCOL(LOGICAL_X_POSITION(current_position[X_AXIS]));
   SERIAL_PROTOCOLPGM(" Y:");
-  SERIAL_PROTOCOL(current_position[Y_AXIS]);
+  SERIAL_PROTOCOL(LOGICAL_Y_POSITION(current_position[Y_AXIS]));
   SERIAL_PROTOCOLPGM(" Z:");
-  SERIAL_PROTOCOL(current_position[Z_AXIS]);
+  SERIAL_PROTOCOL(LOGICAL_Z_POSITION(current_position[Z_AXIS]));
   SERIAL_PROTOCOLPGM(" E:");
   SERIAL_PROTOCOL(current_position[E_AXIS]);
 
   stepper.report_positions();
 
   #if IS_SCARA
     scara_report_positions();
   #endif
 }
 

commit 06ee6584fdf0d6639e917a4e1c2b456892bff8f4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 11 21:25:24 2017 -0600

    Remove offsets from soft endstops, tool change

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 802190297f..f204b18e9b 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1216,62 +1216,53 @@ void homeaxis(const AxisEnum axis) {
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
    */
   void update_software_endstops(const AxisEnum axis) {
-    const float offs = 0.0
-      #if HAS_HOME_OFFSET
-        + home_offset[axis]
-      #endif
-      #if HAS_POSITION_SHIFT
-        + position_shift[axis]
-      #endif
-    ;
-
     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-      workspace_offset[axis] = offs;
+      workspace_offset[axis] = home_offset[axis] + position_shift[axis];
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       if (axis == X_AXIS) {
 
         // In Dual X mode hotend_offset[X] is T1's home position
         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
 
         if (active_extruder != 0) {
           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
-          soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
-          soft_endstop_max[X_AXIS] = dual_max_x + offs;
+          soft_endstop_min[X_AXIS] = X2_MIN_POS;
+          soft_endstop_max[X_AXIS] = dual_max_x;
         }
         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
           // In Duplication Mode, T0 can move as far left as X_MIN_POS
           // but not so far to the right that T1 would move past the end
-          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
-          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
+          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
+          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
         }
         else {
           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
-          soft_endstop_min[axis] = base_min_pos(axis) + offs;
-          soft_endstop_max[axis] = base_max_pos(axis) + offs;
+          soft_endstop_min[axis] = base_min_pos(axis);
+          soft_endstop_max[axis] = base_max_pos(axis);
         }
       }
     #elif ENABLED(DELTA)
-      soft_endstop_min[axis] = base_min_pos(axis) + offs;
-      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis)) + offs;
+      soft_endstop_min[axis] = base_min_pos(axis);
+      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis));
     #else
-      soft_endstop_min[axis] = base_min_pos(axis) + offs;
-      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+      soft_endstop_min[axis] = base_min_pos(axis);
+      soft_endstop_max[axis] = base_max_pos(axis);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
         #if HAS_HOME_OFFSET
           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
         #endif
         #if HAS_POSITION_SHIFT
           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);

commit d4a1154c25093c35d4bc940c5f0017e4ff48d2c7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 20:49:37 2017 -0600

    Use do_blocking_move_to where possible

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 854a8e34ef..802190297f 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -778,20 +778,23 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     return prepare_move_to_destination_cartesian();
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
+ *
+ * Make sure current_position[E] and destination[E] are good
+ * before calling or cold/lengthy extrusion may get missed.
  */
 void prepare_move_to_destination() {
   clamp_to_software_endstops(destination);
   gcode.refresh_cmd_timeout();
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 227f4cc410..854a8e34ef 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -795,21 +795,21 @@ void prepare_move_to_destination() {
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (thermalManager.tooColdToExtrude(active_extruder)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
           }
         #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          if (FABS(destination[E_AXIS] - current_position[E_AXIS]) > (EXTRUDE_MAXLENGTH) / planner.volumetric_multiplier[active_extruder]) {
+          if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 

commit 600c85226ec85ca5851f0a2472f87c2b083f78af
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Thu Nov 9 22:50:32 2017 -0600

    Normalize load/unload length in M600

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 1177addf3f..227f4cc410 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -783,40 +783,42 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  */
 void prepare_move_to_destination() {
   clamp_to_software_endstops(destination);
   gcode.refresh_cmd_timeout();
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
+  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
 
     if (!DEBUGGING(DRYRUN)) {
       if (destination[E_AXIS] != current_position[E_AXIS]) {
-        if (thermalManager.tooColdToExtrude(active_extruder)) {
-          current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
-        }
+        #if ENABLED(PREVENT_COLD_EXTRUSION)
+          if (thermalManager.tooColdToExtrude(active_extruder)) {
+            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            SERIAL_ECHO_START();
+            SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+          }
+        #endif // PREVENT_COLD_EXTRUSION
         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          if (destination[E_AXIS] - current_position[E_AXIS] > EXTRUDE_MAXLENGTH) {
+          if (FABS(destination[E_AXIS] - current_position[E_AXIS]) > (EXTRUDE_MAXLENGTH) / planner.volumetric_multiplier[active_extruder]) {
             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
             SERIAL_ECHO_START();
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
-        #endif
+        #endif // PREVENT_LENGTHY_EXTRUDE
       }
     }
 
-  #endif
+  #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   if (
     #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()

commit c66696c507628e87174ddea9ed0ebbfbbe5eb63a
Merge: 02e91ffa02 f34c3597dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 9 01:21:53 2017 -0600

    Merge pull request #8344 from tcm0116/2.0.x-delta_height
    
    [2.0.x] Add delta_height variable in lieu of using home_offset

diff --combined Marlin/src/module/motion.cpp
index eca9ca19ed,d32f1569b4..1177addf3f
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@@ -63,30 -63,30 +63,30 @@@ XYZ_CONSTS(float, base_home_pos,  HOME_
  XYZ_CONSTS(float, max_length,     MAX_LENGTH);
  XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
  XYZ_CONSTS(signed char, home_dir, HOME_DIR);
  
  // Relative Mode. Enable with G91, disable with G90.
  bool relative_mode = false;
  
  /**
   * Cartesian Current Position
   *   Used to track the native machine position as moves are queued.
 - *   Used by 'line_to_current_position' to do a move after changing it.
 + *   Used by 'buffer_line_to_current_position' to do a move after changing it.
   *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
   */
  float current_position[XYZE] = { 0.0 };
  
  /**
   * Cartesian Destination
 - *   A temporary position, usually applied to 'current_position'.
 - *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
 - *   'line_to_destination' sets 'current_position' to 'destination'.
 + *   The destination for a move, filled in by G-code movement commands,
 + *   and expected by functions like 'prepare_move_to_destination'.
 + *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
   */
  float destination[XYZE] = { 0.0 };
  
  
  // The active extruder (tool). Set with T<extruder> command.
  uint8_t active_extruder = 0;
  
  // Extruder offsets
  #if HOTENDS > 1
    float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
@@@ -228,21 -228,21 +228,21 @@@ void set_current_from_steppers_for_axis
   * (or from wherever it has been told it is located).
   */
  void line_to_current_position() {
    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
  }
  
  /**
   * Move the planner to the position stored in the destination array, which is
   * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
   */
 -void line_to_destination(const float fr_mm_s) {
 +void buffer_line_to_destination(const float fr_mm_s) {
    planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
  }
  
  #if IS_KINEMATIC
  
    void sync_plan_position_kinematic() {
      #if ENABLED(DEBUG_LEVELING_FEATURE)
        if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
      #endif
      planner.set_position_mm_kinematic(current_position);
@@@ -482,22 -482,21 +482,22 @@@ float soft_endstop_min[XYZ] = { X_MIN_B
      #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
        NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
      #endif
      #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
        NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
      #endif
    }
  
  #endif
  
 -#if IS_KINEMATIC && !UBL_DELTA
 +#if !UBL_DELTA
 +#if IS_KINEMATIC
  
    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
      #if ENABLED(DELTA)
        #define ADJUST_DELTA(V) \
          if (planner.leveling_active) { \
            const float zadj = bilinear_z_offset(V); \
            delta[A_AXIS] += zadj; \
            delta[B_AXIS] += zadj; \
            delta[C_AXIS] += zadj; \
          }
@@@ -506,23 -505,20 +506,23 @@@
      #endif
    #else
      #define ADJUST_DELTA(V) NOOP
    #endif
  
    /**
     * Prepare a linear move in a DELTA or SCARA setup.
     *
     * This calls planner.buffer_line several times, adding
     * small incremental moves for DELTA or SCARA.
 +   *
 +   * For Unified Bed Leveling (Delta or Segmented Cartesian)
 +   * the ubl.prepare_segmented_line_to method replaces this.
     */
    inline bool prepare_kinematic_move_to(float rtarget[XYZE]) {
  
      // Get the top feedrate of the move in the XY plane
      const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
  
      // If the move is only in Z/E don't split up the move
      if (rtarget[X_AXIS] == current_position[X_AXIS] && rtarget[Y_AXIS] == current_position[Y_AXIS]) {
        planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
        return false;
@@@ -627,59 -623,61 +627,59 @@@
        const float adiff = abs(delta[A_AXIS] - oldA),
                    bdiff = abs(delta[B_AXIS] - oldB);
        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
      #else
        planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
      #endif
  
      return false;
    }
  
 -#else // !IS_KINEMATIC || UBL_DELTA
 +#else // !IS_KINEMATIC
  
    /**
     * Prepare a linear move in a Cartesian setup.
 -   * Bed Leveling will be applied to the move if enabled.
 +   *
 +   * When a mesh-based leveling system is active, moves are segmented
 +   * according to the configuration of the leveling system.
     *
     * Returns true if current_position[] was set to destination[]
     */
 -
    inline bool prepare_move_to_destination_cartesian() {
 -    const float fr_scaled = MMS_SCALED(feedrate_mm_s);
 -      #if HAS_MESH
 -        if (!planner.leveling_active) {
 -          line_to_destination(fr_scaled);
 -          return false;
 -        }
 +    #if HAS_MESH
 +      if (planner.leveling_active) {
          #if ENABLED(AUTO_BED_LEVELING_UBL)
 -          ubl.line_to_destination_cartesian(fr_scaled, active_extruder);  // UBL's motion routine needs to know about all moves,
 -          return true;                                                    // even purely Z-Axis moves
 +          ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
 +          return true;                                                                    // all moves, including Z-only moves.
          #else
 +          /**
 +           * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
 +           * Otherwise fall through to do a direct single move.
 +           */
            if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
              #if ENABLED(MESH_BED_LEVELING)
 -              mesh_line_to_destination(fr_scaled);
 +              mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
              #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 -              bilinear_line_to_destination(fr_scaled);
 +              bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
              #endif
              return true;
            }
 -          else {
 -            line_to_destination();
 -            return false;
 -          }
          #endif
 -      #else
 -        line_to_destination();  
 -      #endif // HAS_MESH
 +      }
 +    #endif // HAS_MESH
  
 +    buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
      return false;
    }
  
 -#endif // !IS_KINEMATIC || UBL_DELTA
 +#endif // !IS_KINEMATIC
 +#endif // !UBL_DELTA
  
  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
    bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
  #endif
  
  #if ENABLED(DUAL_X_CARRIAGE)
  
    DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
    float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
          raised_parked_position[XYZE],                                     // used in mode 1
@@@ -965,20 -963,22 +965,22 @@@ void set_axis_is_at_home(const AxisEnu
  
    #if ENABLED(DUAL_X_CARRIAGE)
      if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
        current_position[X_AXIS] = x_home_pos(active_extruder);
        return;
      }
    #endif
  
    #if ENABLED(MORGAN_SCARA)
      scara_set_axis_is_at_home(axis);
+   #elif ENABLED(DELTA)
+     current_position[axis] = (axis == Z_AXIS ? delta_height : base_home_pos(axis));
    #else
      current_position[axis] = base_home_pos(axis);
    #endif
  
    /**
     * Z Probe Z Homing? Account for the probe's Z offset.
     */
    #if HAS_BED_PROBE && Z_HOME_DIR < 0
      if (axis == Z_AXIS) {
        #if HOMING_Z_WITH_PROBE
@@@ -1246,22 -1246,22 +1248,22 @@@ void homeaxis(const AxisEnum axis) 
            soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
            soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
          }
          else {
            // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
            soft_endstop_min[axis] = base_min_pos(axis) + offs;
            soft_endstop_max[axis] = base_max_pos(axis) + offs;
          }
        }
      #elif ENABLED(DELTA)
-       soft_endstop_min[axis] = base_min_pos(axis) + (axis == Z_AXIS ? 0 : offs);
-       soft_endstop_max[axis] = base_max_pos(axis) + offs;
+       soft_endstop_min[axis] = base_min_pos(axis) + offs;
+       soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis)) + offs;
      #else
        soft_endstop_min[axis] = base_min_pos(axis) + offs;
        soft_endstop_max[axis] = base_max_pos(axis) + offs;
      #endif
  
      #if ENABLED(DEBUG_LEVELING_FEATURE)
        if (DEBUGGING(LEVELING)) {
          SERIAL_ECHOPAIR("For ", axis_codes[axis]);
          #if HAS_HOME_OFFSET
            SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);

commit 0cfb936dd124d22a6079a5e85802ddc14f0b4328
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 8 22:13:33 2017 -0600

    Clarify some motion code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 35401f2f63..eca9ca19ed 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -63,30 +63,30 @@ XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode = false;
 
 /**
  * Cartesian Current Position
  *   Used to track the native machine position as moves are queued.
- *   Used by 'line_to_current_position' to do a move after changing it.
+ *   Used by 'buffer_line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
- *   A temporary position, usually applied to 'current_position'.
- *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
- *   'line_to_destination' sets 'current_position' to 'destination'.
+ *   The destination for a move, filled in by G-code movement commands,
+ *   and expected by functions like 'prepare_move_to_destination'.
+ *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
  */
 float destination[XYZE] = { 0.0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder = 0;
 
 // Extruder offsets
 #if HOTENDS > 1
   float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
@@ -228,21 +228,21 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position() {
   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
 }
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
-void line_to_destination(const float fr_mm_s) {
+void buffer_line_to_destination(const float fr_mm_s) {
   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
 }
 
 #if IS_KINEMATIC
 
   void sync_plan_position_kinematic() {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
     #endif
     planner.set_position_mm_kinematic(current_position);
@@ -660,21 +660,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #endif
             return true;
           }
         #endif
       }
     #endif // HAS_MESH
 
-    line_to_destination(MMS_SCALED(feedrate_mm_s));
+    buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false;
   }
 
 #endif // !IS_KINEMATIC
 #endif // !UBL_DELTA
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 

commit f34c3597dcaef54624c82f732f13151215bbe650
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Wed Nov 8 22:10:08 2017 -0600

    Add delta_height variable in lieu of using home_offset

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a998fc71c3..d32f1569b4 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -963,20 +963,22 @@ void set_axis_is_at_home(const AxisEnum axis) {
 
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
+  #elif ENABLED(DELTA)
+    current_position[axis] = (axis == Z_AXIS ? delta_height : base_home_pos(axis));
   #else
     current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
@@ -1244,22 +1246,22 @@ void homeaxis(const AxisEnum axis) {
           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
         }
         else {
           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
           soft_endstop_min[axis] = base_min_pos(axis) + offs;
           soft_endstop_max[axis] = base_max_pos(axis) + offs;
         }
       }
     #elif ENABLED(DELTA)
-      soft_endstop_min[axis] = base_min_pos(axis) + (axis == Z_AXIS ? 0 : offs);
-      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+      soft_endstop_min[axis] = base_min_pos(axis) + offs;
+      soft_endstop_max[axis] = (axis == Z_AXIS ? delta_height : base_max_pos(axis)) + offs;
     #else
       soft_endstop_min[axis] = base_min_pos(axis) + offs;
       soft_endstop_max[axis] = base_max_pos(axis) + offs;
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
         #if HAS_HOME_OFFSET
           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);

commit b0b4a209303aed5b68869f9ac3e72accd2818a34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 8 19:49:51 2017 -0600

    Tweaks to core motion code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index a998fc71c3..35401f2f63 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -482,21 +482,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
     #endif
     #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
-#if IS_KINEMATIC && !UBL_DELTA
+#if !UBL_DELTA
+#if IS_KINEMATIC
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     #if ENABLED(DELTA)
       #define ADJUST_DELTA(V) \
         if (planner.leveling_active) { \
           const float zadj = bilinear_z_offset(V); \
           delta[A_AXIS] += zadj; \
           delta[B_AXIS] += zadj; \
           delta[C_AXIS] += zadj; \
         }
@@ -505,20 +506,23 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #endif
   #else
     #define ADJUST_DELTA(V) NOOP
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
+   *
+   * For Unified Bed Leveling (Delta or Segmented Cartesian)
+   * the ubl.prepare_segmented_line_to method replaces this.
    */
   inline bool prepare_kinematic_move_to(float rtarget[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
     // If the move is only in Z/E don't split up the move
     if (rtarget[X_AXIS] == current_position[X_AXIS] && rtarget[Y_AXIS] == current_position[Y_AXIS]) {
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
       return false;
@@ -623,61 +627,59 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       const float adiff = abs(delta[A_AXIS] - oldA),
                   bdiff = abs(delta[B_AXIS] - oldB);
       planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
     #else
       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
-#else // !IS_KINEMATIC || UBL_DELTA
+#else // !IS_KINEMATIC
 
   /**
    * Prepare a linear move in a Cartesian setup.
-   * Bed Leveling will be applied to the move if enabled.
+   *
+   * When a mesh-based leveling system is active, moves are segmented
+   * according to the configuration of the leveling system.
    *
    * Returns true if current_position[] was set to destination[]
    */
-
   inline bool prepare_move_to_destination_cartesian() {
-    const float fr_scaled = MMS_SCALED(feedrate_mm_s);
-      #if HAS_MESH
-        if (!planner.leveling_active) {
-          line_to_destination(fr_scaled);
-          return false;
-        }
+    #if HAS_MESH
+      if (planner.leveling_active) {
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.line_to_destination_cartesian(fr_scaled, active_extruder);  // UBL's motion routine needs to know about all moves,
-          return true;                                                    // even purely Z-Axis moves
+          ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
+          return true;                                                                    // all moves, including Z-only moves.
         #else
+          /**
+           * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
+           * Otherwise fall through to do a direct single move.
+           */
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
-              mesh_line_to_destination(fr_scaled);
+              mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-              bilinear_line_to_destination(fr_scaled);
+              bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
             #endif
             return true;
           }
-          else {
-            line_to_destination();
-            return false;
-          }
         #endif
-      #else
-        line_to_destination();  
-      #endif // HAS_MESH
+      }
+    #endif // HAS_MESH
 
+    line_to_destination(MMS_SCALED(feedrate_mm_s));
     return false;
   }
 
-#endif // !IS_KINEMATIC || UBL_DELTA
+#endif // !IS_KINEMATIC
+#endif // !UBL_DELTA
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1

commit 1c6e83c137c91c8510d77a9a01d761c1a5f525f0
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Nov 8 09:42:21 2017 -0600

    if !HAS_MESH we still need to do some motion! (#8328)
    
    * if !HAS_MESH we still need to do some motion!
    
    Thank You MagoKimbra !
    
    * Ooops....   need #else and not #elif

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 2d2e9a3b52..a998fc71c3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -651,23 +651,27 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           return true;                                                    // even purely Z-Axis moves
         #else
           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
             #if ENABLED(MESH_BED_LEVELING)
               mesh_line_to_destination(fr_scaled);
             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
               bilinear_line_to_destination(fr_scaled);
             #endif
             return true;
           }
-          else
+          else {
             line_to_destination();
+            return false;
+          }
         #endif
+      #else
+        line_to_destination();  
       #endif // HAS_MESH
 
     return false;
   }
 
 #endif // !IS_KINEMATIC || UBL_DELTA
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif

commit ed62c621d78bdcfcf8ace903ac4130d07834dca1
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Nov 7 17:13:53 2017 -0600

    Fix G26 Circle Drawing.  Add Default Extrusion Settings (#8313)
    
    - Fix G26 Circle Drawing.
    - Add default extrusion settings so machine can print lines on print bed
    - Yet to be done: Get LCD Menu's to use these settings.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 03aecfe7b2..2d2e9a3b52 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -631,39 +631,44 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
   }
 
 #else // !IS_KINEMATIC || UBL_DELTA
 
   /**
    * Prepare a linear move in a Cartesian setup.
    * Bed Leveling will be applied to the move if enabled.
    *
    * Returns true if current_position[] was set to destination[]
    */
+
   inline bool prepare_move_to_destination_cartesian() {
-    if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
-      const float fr_scaled = MMS_SCALED(feedrate_mm_s);
+    const float fr_scaled = MMS_SCALED(feedrate_mm_s);
       #if HAS_MESH
-        if (planner.leveling_active) {
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-            ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
-          #elif ENABLED(MESH_BED_LEVELING)
-            mesh_line_to_destination(fr_scaled);
-          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-            bilinear_line_to_destination(fr_scaled);
-          #endif
-          return true;
+        if (!planner.leveling_active) {
+          line_to_destination(fr_scaled);
+          return false;
         }
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          ubl.line_to_destination_cartesian(fr_scaled, active_extruder);  // UBL's motion routine needs to know about all moves,
+          return true;                                                    // even purely Z-Axis moves
+        #else
+          if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
+            #if ENABLED(MESH_BED_LEVELING)
+              mesh_line_to_destination(fr_scaled);
+            #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+              bilinear_line_to_destination(fr_scaled);
+            #endif
+            return true;
+          }
+          else
+            line_to_destination();
+        #endif
       #endif // HAS_MESH
-      line_to_destination(fr_scaled);
-    }
-    else
-      line_to_destination();
 
     return false;
   }
 
 #endif // !IS_KINEMATIC || UBL_DELTA
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 

commit 79772219aeb0531cccfa7eb73cea246ceb6dbb6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 21:01:41 2017 -0500

    Fix Fan Multiplexer init

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index b49486bf7d..03aecfe7b2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -32,24 +32,20 @@
 
 #include "../gcode/gcode.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/ultralcd.h"
 #endif
 
-// #if ENABLED(DUAL_X_CARRIAGE)
-//   #include "tool_change.h"
-// #endif
-
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_AXIS_UNHOMED_ERR && ENABLED(ULTRA_LCD)
   #include "../lcd/ultralcd.h"

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ec5d516c74..b49486bf7d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -66,21 +66,21 @@ XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
 
 // Relative Mode. Enable with G91, disable with G90.
 bool relative_mode = false;
 
 /**
  * Cartesian Current Position
- *   Used to track the logical position as moves are queued.
+ *   Used to track the native machine position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
  *   A temporary position, usually applied to 'current_position'.
  *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  *   'line_to_destination' sets 'current_position' to 'destination'.
@@ -190,34 +190,30 @@ void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]
  * unapply_leveling to obtain the "ideal" coordinates
  * suitable for current_position, etc.
  */
 void get_cartesian_from_steppers() {
   #if ENABLED(DELTA)
     forward_kinematics_DELTA(
       stepper.get_axis_position_mm(A_AXIS),
       stepper.get_axis_position_mm(B_AXIS),
       stepper.get_axis_position_mm(C_AXIS)
     );
-    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
-    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
-    cartes[Z_AXIS] += LOGICAL_Z_POSITION(0);
-  #elif IS_SCARA
-    forward_kinematics_SCARA(
-      stepper.get_axis_position_degrees(A_AXIS),
-      stepper.get_axis_position_degrees(B_AXIS)
-    );
-    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
-    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
-    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   #else
-    cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
-    cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+    #if IS_SCARA
+      forward_kinematics_SCARA(
+        stepper.get_axis_position_degrees(A_AXIS),
+        stepper.get_axis_position_degrees(B_AXIS)
+      );
+    #else
+      cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
+      cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+    #endif
     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   #endif
 }
 
 /**
  * Set the current_position for an axis based on
  * the stepper positions, removing any leveling that
  * may have been applied.
  */
 void set_current_from_steppers_for_axis(const AxisEnum axis) {
@@ -281,144 +277,144 @@ void line_to_destination(const float fr_mm_s) {
 
     set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
  */
-void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
+void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
+    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, rx, ry, rz);
   #endif
 
   #if ENABLED(DELTA)
 
-    if (!position_is_reachable_xy(lx, ly)) return;
+    if (!position_is_reachable(rx, ry)) return;
 
     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
     set_destination_from_current();          // sync destination at the start
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
     #endif
 
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
-      if (lz > delta_clip_start_height) {   // staying in the danger zone
-        destination[X_AXIS] = lx;           // move directly (uninterpolated)
-        destination[Y_AXIS] = ly;
-        destination[Z_AXIS] = lz;
+      if (rz > delta_clip_start_height) {   // staying in the danger zone
+        destination[X_AXIS] = rx;           // move directly (uninterpolated)
+        destination[Y_AXIS] = ry;
+        destination[Z_AXIS] = rz;
         prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         #endif
         return;
       }
       else {
         destination[Z_AXIS] = delta_clip_start_height;
         prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
         #endif
       }
     }
 
-    if (lz > current_position[Z_AXIS]) {    // raising?
-      destination[Z_AXIS] = lz;
+    if (rz > current_position[Z_AXIS]) {    // raising?
+      destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
       #endif
     }
 
-    destination[X_AXIS] = lx;
-    destination[Y_AXIS] = ly;
+    destination[X_AXIS] = rx;
+    destination[Y_AXIS] = ry;
     prepare_move_to_destination();         // set_current_from_destination()
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
     #endif
 
-    if (lz < current_position[Z_AXIS]) {    // lowering?
-      destination[Z_AXIS] = lz;
+    if (rz < current_position[Z_AXIS]) {    // lowering?
+      destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
       #endif
     }
 
   #elif IS_SCARA
 
-    if (!position_is_reachable_xy(lx, ly)) return;
+    if (!position_is_reachable(rx, ry)) return;
 
     set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
-    if (destination[Z_AXIS] < lz) {
-      destination[Z_AXIS] = lz;
+    if (destination[Z_AXIS] < rz) {
+      destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
     }
 
-    destination[X_AXIS] = lx;
-    destination[Y_AXIS] = ly;
+    destination[X_AXIS] = rx;
+    destination[Y_AXIS] = ry;
     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
 
     // If Z needs to lower, do it after moving XY
-    if (destination[Z_AXIS] > lz) {
-      destination[Z_AXIS] = lz;
+    if (destination[Z_AXIS] > rz) {
+      destination[Z_AXIS] = rz;
       prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
     }
 
   #else
 
     // If Z needs to raise, do it before moving XY
-    if (current_position[Z_AXIS] < lz) {
+    if (current_position[Z_AXIS] < rz) {
       feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = lz;
+      current_position[Z_AXIS] = rz;
       line_to_current_position();
     }
 
     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
-    current_position[X_AXIS] = lx;
-    current_position[Y_AXIS] = ly;
+    current_position[X_AXIS] = rx;
+    current_position[Y_AXIS] = ry;
     line_to_current_position();
 
     // If Z needs to lower, do it after moving XY
-    if (current_position[Z_AXIS] > lz) {
+    if (current_position[Z_AXIS] > rz) {
       feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = lz;
+      current_position[Z_AXIS] = rz;
       line_to_current_position();
     }
 
   #endif
 
   stepper.synchronize();
 
   feedrate_mm_s = old_feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   #endif
 }
-void do_blocking_move_to_x(const float &lx, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(lx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
+void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
 }
-void do_blocking_move_to_z(const float &lz, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], lz, fr_mm_s);
+void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
 }
-void do_blocking_move_to_xy(const float &lx, const float &ly, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(lx, ly, current_position[Z_AXIS], fr_mm_s);
+void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
 }
 
 //
 // Prepare to do endstop or probe moves
 // with custom feedrates.
 //
 //  - Save current feedrates
 //  - Reset the rate multiplier
 //  - Reset the command timeout
 //  - Enable the endstops (for endstop moves)
@@ -514,40 +510,40 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
   #else
     #define ADJUST_DELTA(V) NOOP
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    */
-  inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
+  inline bool prepare_kinematic_move_to(float rtarget[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
 
     // If the move is only in Z/E don't split up the move
-    if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
-      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+    if (rtarget[X_AXIS] == current_position[X_AXIS] && rtarget[Y_AXIS] == current_position[Y_AXIS]) {
+      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
       return false;
     }
 
     // Fail if attempting move outside printable radius
-    if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS])) return true;
+    if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
 
     // Get the cartesian distances moved in XYZE
     const float difference[XYZE] = {
-      ltarget[X_AXIS] - current_position[X_AXIS],
-      ltarget[Y_AXIS] - current_position[Y_AXIS],
-      ltarget[Z_AXIS] - current_position[Z_AXIS],
-      ltarget[E_AXIS] - current_position[E_AXIS]
+      rtarget[X_AXIS] - current_position[X_AXIS],
+      rtarget[Y_AXIS] - current_position[Y_AXIS],
+      rtarget[Z_AXIS] - current_position[Z_AXIS],
+      rtarget[E_AXIS] - current_position[E_AXIS]
     };
 
     // Get the linear distance in XYZ
     float cartesian_mm = SQRT(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
 
     // If the move is very short, check the E move distance
     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(difference[E_AXIS]);
 
     // No E move either? Game over.
     if (UNEAR_ZERO(cartesian_mm)) return true;
@@ -581,65 +577,65 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     // SERIAL_ECHOLNPAIR(" segments=", segments);
 
     #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
       // SCARA needs to scale the feed rate from mm/s to degrees/s
       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
                   feed_factor = inv_segment_length * _feedrate_mm_s;
       float oldA = stepper.get_axis_position_degrees(A_AXIS),
             oldB = stepper.get_axis_position_degrees(B_AXIS);
     #endif
 
-    // Get the logical current position as starting point
-    float logical[XYZE];
-    COPY(logical, current_position);
+    // Get the current position as starting point
+    float raw[XYZE];
+    COPY(raw, current_position);
 
     // Drop one segment so the last move is to the exact target.
     // If there's only 1 segment, loops will be skipped entirely.
     --segments;
 
     // Calculate and execute the segments
     for (uint16_t s = segments + 1; --s;) {
-      LOOP_XYZE(i) logical[i] += segment_distance[i];
+      LOOP_XYZE(i) raw[i] += segment_distance[i];
       #if ENABLED(DELTA)
-        DELTA_LOGICAL_IK(); // Delta can inline its kinematics
+        DELTA_RAW_IK(); // Delta can inline its kinematics
       #else
-        inverse_kinematics(logical);
+        inverse_kinematics(raw);
       #endif
 
-      ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
+      ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
 
       #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
         // For SCARA scale the feed rate from mm/s to degrees/s
         // Use ratio between the length of the move and the larger angle change
         const float adiff = abs(delta[A_AXIS] - oldA),
                     bdiff = abs(delta[B_AXIS] - oldB);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
         oldA = delta[A_AXIS];
         oldB = delta[B_AXIS];
       #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
       #endif
     }
 
     // Since segment_distance is only approximate,
     // the final move must be to the exact destination.
 
     #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // With segments > 1 length is 1 segment, otherwise total length
-      inverse_kinematics(ltarget);
-      ADJUST_DELTA(ltarget);
+      inverse_kinematics(rtarget);
+      ADJUST_DELTA(rtarget);
       const float adiff = abs(delta[A_AXIS] - oldA),
                   bdiff = abs(delta[B_AXIS] - oldB);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
     #else
-      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+      planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
 #else // !IS_KINEMATIC || UBL_DELTA
 
   /**
    * Prepare a linear move in a Cartesian setup.
    * Bed Leveling will be applied to the move if enabled.
@@ -680,29 +676,29 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
   DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
   float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
         raised_parked_position[XYZE],                                     // used in mode 1
         duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
   bool active_extruder_parked            = false;                         // used in mode 1 & 2
   millis_t delayed_move_time             = 0;                             // used in mode 1
   int16_t duplicate_extruder_temp_offset = 0;                             // used in mode 2
 
   float x_home_pos(const int extruder) {
     if (extruder == 0)
-      return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
+      return base_home_pos(X_AXIS);
     else
       /**
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
-      return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
+      return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
   }
 
   /**
    * Prepare a linear move in a dual X axis setup
    *
    * Return true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_dualx() {
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
@@ -733,27 +729,27 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
           delayed_move_time = 0;
           active_extruder_parked = false;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
           #endif
           break;
         case DXC_DUPLICATION_MODE:
           if (active_extruder == 0) {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
+                SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
               }
             #endif
             // move duplicate extruder into correct duplication position.
             planner.set_position_mm(
-              LOGICAL_X_POSITION(inactive_extruder_x_pos),
+              inactive_extruder_x_pos,
               current_position[Y_AXIS],
               current_position[Z_AXIS],
               current_position[E_AXIS]
             );
             planner.buffer_line(
               current_position[X_AXIS] + duplicate_extruder_x_offset,
               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
               planner.max_feedrate_mm_s[X_AXIS], 1
             );
             SYNC_PLAN_POSITION_KINEMATIC();
@@ -963,21 +959,21 @@ void set_axis_is_at_home(const AxisEnum axis) {
   #if ENABLED(DUAL_X_CARRIAGE)
     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
       current_position[X_AXIS] = x_home_pos(active_extruder);
       return;
     }
   #endif
 
   #if ENABLED(MORGAN_SCARA)
     scara_set_axis_is_at_home(axis);
   #else
-    current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
+    current_position[axis] = base_home_pos(axis);
   #endif
 
   /**
    * Z Probe Z Homing? Account for the probe's Z offset.
    */
   #if HAS_BED_PROBE && Z_HOME_DIR < 0
     if (axis == Z_AXIS) {
       #if HOMING_Z_WITH_PROBE
 
         current_position[Z_AXIS] -= zprobe_zoffset;

commit 04c0d9f3c362b220c9de1caf45d185f4fd7bc763
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 30 14:45:11 2017 -0500

    Implement kinematic software endstops

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index e7cd631ff3..ec5d516c74 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -447,43 +447,56 @@ void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 
 // Software Endstops are based on the configured limits.
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   bool soft_endstops_enabled = true;
 
+  #if IS_KINEMATIC
+    float soft_endstop_radius, soft_endstop_radius_2;
+  #endif
+
   /**
    * Constrain the given coordinates to the software endstops.
    *
-   * NOTE: This will only apply to Z on DELTA and SCARA. XY is
-   *       constrained to a circle on these kinematic systems.
+   * For DELTA/SCARA the XY constraint is based on the smallest
+   * radius within the set software endstops.
    */
   void clamp_to_software_endstops(float target[XYZ]) {
     if (!soft_endstops_enabled) return;
-    #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-      NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
-    #endif
-    #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-      NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+    #if IS_KINEMATIC
+      const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
+      if (dist_2 > soft_endstop_radius_2) {
+        const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
+        target[X_AXIS] *= ratio;
+        target[Y_AXIS] *= ratio;
+      }
+    #else
+      #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
+      #endif
+      #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+      #endif
+      #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
+      #endif
+      #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+      #endif
     #endif
     #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
     #endif
-    #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-      NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
-    #endif
-    #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-      NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
-    #endif
     #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
 #if IS_KINEMATIC && !UBL_DELTA
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -1252,22 +1265,31 @@ void homeaxis(const AxisEnum axis) {
         #endif
         #if HAS_POSITION_SHIFT
           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
         #endif
         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
       }
     #endif
 
     #if ENABLED(DELTA)
-      if (axis == Z_AXIS)
-        delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+      switch(axis) {
+        case X_AXIS:
+        case Y_AXIS:
+          // Get a minimum radius for clamping
+          soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
+          soft_endstop_radius_2 = sq(soft_endstop_radius);
+          break;
+        case Z_AXIS:
+          delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+        default: break;
+      }
     #endif
   }
 
 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
 
 #if HAS_M206_COMMAND
   /**
    * Change the home offset for an axis, update the current
    * position and the software endstops to retain the same
    * relative distance to the new home.

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index f887429b83..e7cd631ff3 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1036,23 +1036,29 @@ void homeaxis(const AxisEnum axis) {
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
     home_dir(axis);
 
   // Homing Z towards the bed? Deploy the Z probe or endstop.
   #if HOMING_Z_WITH_PROBE
     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   #endif
 
-  // Set a flag for Z motor locking
+  // Set flags for X, Y, Z motor locking
+  #if ENABLED(X_DUAL_ENDSTOPS)
+    if (axis == X_AXIS) stepper.set_homing_flag_x(true);
+  #endif
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
+  #endif
   #if ENABLED(Z_DUAL_ENDSTOPS)
-    if (axis == Z_AXIS) stepper.set_homing_flag(true);
+    if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   #endif
 
   // Disable stealthChop if used. Enable diag1 pin on driver.
   #if ENABLED(SENSORLESS_HOMING)
     #if ENABLED(X_IS_TMC2130)
       if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
     #endif
     #if ENABLED(Y_IS_TMC2130)
       if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
     #endif
@@ -1080,39 +1086,55 @@ void homeaxis(const AxisEnum axis) {
     #endif
     do_homing_move(axis, -bump);
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
-  #if ENABLED(Z_DUAL_ENDSTOPS)
-    if (axis == Z_AXIS) {
-      float adj = FABS(endstops.z_endstop_adj);
-      bool lockZ1;
-      if (axis_home_dir > 0) {
-        adj = -adj;
-        lockZ1 = (endstops.z_endstop_adj > 0);
+  #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+    const bool pos_dir = axis_home_dir > 0;
+    #if ENABLED(X_DUAL_ENDSTOPS)
+      if (axis == X_AXIS) {
+        const bool lock_x1 = pos_dir ? (endstops.x_endstop_adj > 0) : (endstops.x_endstop_adj < 0);
+        float adj = FABS(endstops.x_endstop_adj);
+        if (pos_dir) adj = -adj;
+        if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
+        do_homing_move(axis, adj);
+        if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
+        stepper.set_homing_flag_x(false);
       }
-      else
-        lockZ1 = (endstops.z_endstop_adj < 0);
-
-      if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-
-      // Move to the adjusted endstop height
-      do_homing_move(axis, adj);
-
-      if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
-      stepper.set_homing_flag(false);
-    } // Z_AXIS
+    #endif
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      if (axis == Y_AXIS) {
+        const bool lock_y1 = pos_dir ? (endstops.y_endstop_adj > 0) : (endstops.y_endstop_adj < 0);
+        float adj = FABS(endstops.y_endstop_adj);
+        if (pos_dir) adj = -adj;
+        if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
+        do_homing_move(axis, adj);
+        if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
+        stepper.set_homing_flag_y(false);
+      }
+    #endif
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      if (axis == Z_AXIS) {
+        const bool lock_z1 = pos_dir ? (endstops.z_endstop_adj > 0) : (endstops.z_endstop_adj < 0);
+        float adj = FABS(endstops.z_endstop_adj);
+        if (pos_dir) adj = -adj;
+        if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+        do_homing_move(axis, adj);
+        if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
+        stepper.set_homing_flag_z(false);
+      }
+    #endif
   #endif
 
   #if IS_SCARA
 
     set_axis_is_at_home(axis);
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #elif ENABLED(DELTA)
 
     // Delta has already moved all three towers up in G28

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 74fbfc1a6e..f887429b83 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -75,21 +75,21 @@ bool relative_mode = false;
  * Cartesian Current Position
  *   Used to track the logical position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
  *   A temporary position, usually applied to 'current_position'.
- *   Set with 'get_destination_from_command' or 'set_destination_to_current'.
+ *   Set with 'get_destination_from_command' or 'set_destination_from_current'.
  *   'line_to_destination' sets 'current_position' to 'destination'.
  */
 float destination[XYZE] = { 0.0 };
 
 
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder = 0;
 
 // Extruder offsets
 #if HOTENDS > 1
@@ -272,21 +272,21 @@ void line_to_destination(const float fr_mm_s) {
     #else
       if ( current_position[X_AXIS] == destination[X_AXIS]
         && current_position[Y_AXIS] == destination[Y_AXIS]
         && current_position[Z_AXIS] == destination[Z_AXIS]
         && current_position[E_AXIS] == destination[E_AXIS]
       ) return;
 
       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     #endif
 
-    set_current_to_destination();
+    set_current_from_destination();
   }
 
 #endif // IS_KINEMATIC
 
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
  */
 void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
@@ -294,75 +294,75 @@ void do_blocking_move_to(const float &lx, const float &ly, const float &lz, cons
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
   #endif
 
   #if ENABLED(DELTA)
 
     if (!position_is_reachable_xy(lx, ly)) return;
 
     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
-    set_destination_to_current();          // sync destination at the start
+    set_destination_from_current();          // sync destination at the start
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
     #endif
 
     // when in the danger zone
     if (current_position[Z_AXIS] > delta_clip_start_height) {
       if (lz > delta_clip_start_height) {   // staying in the danger zone
         destination[X_AXIS] = lx;           // move directly (uninterpolated)
         destination[Y_AXIS] = ly;
         destination[Z_AXIS] = lz;
-        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
         #endif
         return;
       }
       else {
         destination[Z_AXIS] = delta_clip_start_height;
-        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        prepare_uninterpolated_move_to_destination(); // set_current_from_destination()
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
         #endif
       }
     }
 
     if (lz > current_position[Z_AXIS]) {    // raising?
       destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
       #endif
     }
 
     destination[X_AXIS] = lx;
     destination[Y_AXIS] = ly;
-    prepare_move_to_destination();         // set_current_to_destination
+    prepare_move_to_destination();         // set_current_from_destination()
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
     #endif
 
     if (lz < current_position[Z_AXIS]) {    // lowering?
       destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      prepare_uninterpolated_move_to_destination();   // set_current_from_destination()
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
       #endif
     }
 
   #elif IS_SCARA
 
     if (!position_is_reachable_xy(lx, ly)) return;
 
-    set_destination_to_current();
+    set_destination_from_current();
 
     // If Z needs to raise, do it before moving XY
     if (destination[Z_AXIS] < lz) {
       destination[Z_AXIS] = lz;
       prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
     }
 
     destination[X_AXIS] = lx;
     destination[Y_AXIS] = ly;
     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
@@ -694,21 +694,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
           break;
         case DXC_AUTO_PARK_MODE:
           if (current_position[E_AXIS] == destination[E_AXIS]) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position
             // (so it can be used as the start of the next non-travel move)
             if (delayed_move_time != 0xFFFFFFFFUL) {
-              set_current_to_destination();
+              set_current_from_destination();
               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
               delayed_move_time = millis();
               return true;
             }
           }
           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
           for (uint8_t i = 0; i < 3; i++)
             planner.buffer_line(
               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
@@ -800,21 +800,21 @@ void prepare_move_to_destination() {
       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
-  set_current_to_destination();
+  set_current_from_destination();
 }
 
 #if HAS_AXIS_UNHOMED_ERR
 
   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
     #if ENABLED(HOME_AFTER_DEACTIVATE)
       const bool xx = x && !axis_known_position[X_AXIS],
                  yy = y && !axis_known_position[Y_AXIS],
                  zz = z && !axis_known_position[Z_AXIS];
     #else

commit c46189e429056e351afe4b3aaeb195e4575d7e43
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 15 16:31:09 2017 -0500

    Fix UBL+Delta segmented feedrate
    
    Based on #7948

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 26620be8f5..74fbfc1a6e 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -790,21 +790,21 @@ void prepare_move_to_destination() {
             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         #endif
       }
     }
 
   #endif
 
   if (
     #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
-      ubl.prepare_segmented_line_to(destination, feedrate_mm_s)
+      ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_to_destination();

commit b206f70693c68494b15451518062e19f31a9e019
Author: Jeff Eberl <jeffeb3@gmail.com>
Date:   Sat Oct 14 06:18:09 2017 -0600

    Split the software endstop capability by axis.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index ecc3f8bf97..26620be8f5 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -449,43 +449,42 @@ void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   bool soft_endstops_enabled = true;
 
   /**
    * Constrain the given coordinates to the software endstops.
+   *
+   * NOTE: This will only apply to Z on DELTA and SCARA. XY is
+   *       constrained to a circle on these kinematic systems.
    */
-
-  // NOTE: This makes no sense for delta beds other than Z-axis.
-  //       For delta the X/Y would need to be clamped at
-  //       DELTA_PRINTABLE_RADIUS from center of bed, but delta
-  //       now enforces is_position_reachable for X/Y regardless
-  //       of HAS_SOFTWARE_ENDSTOPS, so that enforcement would be
-  //       redundant here.
-
   void clamp_to_software_endstops(float target[XYZ]) {
     if (!soft_endstops_enabled) return;
-    #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
-      #if DISABLED(DELTA)
-        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
-        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
-      #endif
+    #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+      NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
+    #endif
+    #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+      NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+    #endif
+    #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
     #endif
-    #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-      #if DISABLED(DELTA)
-        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
-        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
-      #endif
+    #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+      NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
+    #endif
+    #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+      NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+    #endif
+    #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
 #if IS_KINEMATIC && !UBL_DELTA
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     #if ENABLED(DELTA)

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 0704e28c8d..ecc3f8bf97 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -483,28 +483,28 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #endif
   }
 
 #endif
 
 #if IS_KINEMATIC && !UBL_DELTA
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     #if ENABLED(DELTA)
       #define ADJUST_DELTA(V) \
-        if (LEVELING_IS_ACTIVE()) { \
+        if (planner.leveling_active) { \
           const float zadj = bilinear_z_offset(V); \
           delta[A_AXIS] += zadj; \
           delta[B_AXIS] += zadj; \
           delta[C_AXIS] += zadj; \
         }
     #else
-      #define ADJUST_DELTA(V) if (LEVELING_IS_ACTIVE()) { delta[Z_AXIS] += bilinear_z_offset(V); }
+      #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
     #endif
   #else
     #define ADJUST_DELTA(V) NOOP
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
@@ -623,55 +623,44 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
     #endif
 
     return false;
   }
 
 #else // !IS_KINEMATIC || UBL_DELTA
 
   /**
    * Prepare a linear move in a Cartesian setup.
-   * If Mesh Bed Leveling is enabled, perform a mesh move.
+   * Bed Leveling will be applied to the move if enabled.
    *
-   * Returns true if the caller didn't update current_position.
+   * Returns true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_cartesian() {
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
+    if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
       const float fr_scaled = MMS_SCALED(feedrate_mm_s);
-      if (ubl.state.active) { // direct use of ubl.state.active for speed
-        ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
-        return true;
-      }
-      else
-        line_to_destination(fr_scaled);
-    #else
-      // Do not use feedrate_percentage for E or Z only moves
-      if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS])
-        line_to_destination();
-      else {
-        const float fr_scaled = MMS_SCALED(feedrate_mm_s);
-        #if ENABLED(MESH_BED_LEVELING)
-          if (mbl.active()) { // direct used of mbl.active() for speed
+      #if HAS_MESH
+        if (planner.leveling_active) {
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
+          #elif ENABLED(MESH_BED_LEVELING)
             mesh_line_to_destination(fr_scaled);
-            return true;
-          }
-          else
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          if (planner.abl_enabled) { // direct use of abl_enabled for speed
+          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
             bilinear_line_to_destination(fr_scaled);
-            return true;
-          }
-          else
-        #endif
-            line_to_destination(fr_scaled);
-      }
-    #endif
+          #endif
+          return true;
+        }
+      #endif // HAS_MESH
+      line_to_destination(fr_scaled);
+    }
+    else
+      line_to_destination();
+
     return false;
   }
 
 #endif // !IS_KINEMATIC || UBL_DELTA
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
@@ -692,20 +681,22 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
        * In dual carriage mode the extruder offset provides an override of the
        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
        * This allows soft recalibration of the second extruder home position
        * without firmware reflash (through the M218 command).
        */
       return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
   }
 
   /**
    * Prepare a linear move in a dual X axis setup
+   *
+   * Return true if current_position[] was set to destination[]
    */
   inline bool prepare_move_to_destination_dualx() {
     if (active_extruder_parked) {
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
           break;
         case DXC_AUTO_PARK_MODE:
           if (current_position[E_AXIS] == destination[E_AXIS]) {
             // This is a travel move (with no extrusion)
             // Skip it, but keep track of the current position

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 87cf0b9bf0..0704e28c8d 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -483,28 +483,28 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
     #endif
   }
 
 #endif
 
 #if IS_KINEMATIC && !UBL_DELTA
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     #if ENABLED(DELTA)
       #define ADJUST_DELTA(V) \
-        if (planner.abl_enabled) { \
+        if (LEVELING_IS_ACTIVE()) { \
           const float zadj = bilinear_z_offset(V); \
           delta[A_AXIS] += zadj; \
           delta[B_AXIS] += zadj; \
           delta[C_AXIS] += zadj; \
         }
     #else
-      #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
+      #define ADJUST_DELTA(V) if (LEVELING_IS_ACTIVE()) { delta[Z_AXIS] += bilinear_z_offset(V); }
     #endif
   #else
     #define ADJUST_DELTA(V) NOOP
   #endif
 
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.

commit 6ea2cc029348444168fd05e225e9c3ab3b5fefec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 2 23:32:28 2017 -0500

    Make prepare_move_to_destination_dualx a proper move function

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index bb8ca3106a..87cf0b9bf0 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -762,21 +762,21 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
             #endif
           }
           else {
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
             #endif
           }
           break;
       }
     }
-    return false;
+    return prepare_move_to_destination_cartesian();
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prepare a single move and get ready for the next one
  *
  * This may result in several calls to planner.buffer_line to
  * do smaller moves for DELTA, SCARA, mesh moves, etc.
  */
@@ -804,21 +804,21 @@ void prepare_move_to_destination() {
     }
 
   #endif
 
   if (
     #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
       ubl.prepare_segmented_line_to(destination, feedrate_mm_s)
     #elif IS_KINEMATIC
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
-      prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
+      prepare_move_to_destination_dualx()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_to_destination();
 }
 
 #if HAS_AXIS_UNHOMED_ERR
 

commit 90af1fe5eefd353c9fb9c40430f45031147fd675
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:34:58 2017 -0500

    Implement NO_MOTION_BEFORE_HOMING option

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 407dd756b8..bb8ca3106a 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -44,21 +44,21 @@
 // #endif
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if NEED_UNHOMED_ERR && ENABLED(ULTRA_LCD)
+#if HAS_AXIS_UNHOMED_ERR && ENABLED(ULTRA_LCD)
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../feature/tmc2130.h"
 #endif
 
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
@@ -813,21 +813,21 @@ void prepare_move_to_destination() {
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_to_destination();
 }
 
-#if NEED_UNHOMED_ERR
+#if HAS_AXIS_UNHOMED_ERR
 
   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
     #if ENABLED(HOME_AFTER_DEACTIVATE)
       const bool xx = x && !axis_known_position[X_AXIS],
                  yy = y && !axis_known_position[Y_AXIS],
                  zz = z && !axis_known_position[Z_AXIS];
     #else
       const bool xx = x && !axis_homed[X_AXIS],
                  yy = y && !axis_homed[Y_AXIS],
                  zz = z && !axis_homed[Z_AXIS];
@@ -841,21 +841,21 @@ void prepare_move_to_destination() {
       SERIAL_ECHOLNPGM(" " MSG_FIRST);
 
       #if ENABLED(ULTRA_LCD)
         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
       #endif
       return true;
     }
     return false;
   }
 
-#endif
+#endif // HAS_AXIS_UNHOMED_ERR
 
 /**
  * The homing feedrate may vary
  */
 inline float get_homing_bump_feedrate(const AxisEnum axis) {
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_START();

commit 6d5fcac54ae76374065aed322e9f66f71756af70
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 24 02:18:15 2017 -0500

    G33 changes from 1.1.x

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 35a97d25b1..407dd756b8 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1127,21 +1127,21 @@ void homeaxis(const AxisEnum axis) {
 
     // Delta has already moved all three towers up in G28
     // so here it re-homes each tower in turn.
     // Delta homing treats the axes as normal linear axes.
 
     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
       #endif
-      do_homing_move(axis, delta_endstop_adj[axis] - 0.1);
+      do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
     }
 
   #else
 
     // For cartesian/core machines,
     // set the axis to its home position
     set_axis_is_at_home(axis);
     sync_plan_position();
 
     destination[axis] = current_position[axis];

commit 64dfb464610e35c3a65748170b5f015ffe1bc9bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:56:10 2017 -0500

    Move z_endstop_adj to Endstops

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index 8a99d99eb2..35a97d25b1 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -1092,28 +1092,28 @@ void homeaxis(const AxisEnum axis) {
 
     // Slow move towards endstop until triggered
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
     #endif
     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
   #if ENABLED(Z_DUAL_ENDSTOPS)
     if (axis == Z_AXIS) {
-      float adj = FABS(z_endstop_adj);
+      float adj = FABS(endstops.z_endstop_adj);
       bool lockZ1;
       if (axis_home_dir > 0) {
         adj = -adj;
-        lockZ1 = (z_endstop_adj > 0);
+        lockZ1 = (endstops.z_endstop_adj > 0);
       }
       else
-        lockZ1 = (z_endstop_adj < 0);
+        lockZ1 = (endstops.z_endstop_adj < 0);
 
       if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
 
       // Move to the adjusted endstop height
       do_homing_move(axis, adj);
 
       if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
       stepper.set_homing_flag(false);
     } // Z_AXIS
   #endif

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
index df227d7e48..8a99d99eb2 100644
--- a/Marlin/src/module/motion.cpp
+++ b/Marlin/src/module/motion.cpp
@@ -18,37 +18,52 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * motion.cpp
  */
 
 #include "motion.h"
+#include "endstops.h"
+#include "stepper.h"
+#include "planner.h"
+#include "temperature.h"
 
 #include "../gcode/gcode.h"
-// #include "../module/planner.h"
-// #include "../Marlin.h"
-// #include "../inc/MarlinConfig.h"
 
-#include "../core/serial.h"
-#include "../module/stepper.h"
-#include "../module/temperature.h"
+#include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../libs/buzzer.h"
   #include "../lcd/ultralcd.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../feature/ubl/ubl.h"
+// #if ENABLED(DUAL_X_CARRIAGE)
+//   #include "tool_change.h"
+// #endif
+
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
+
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
+#if NEED_UNHOMED_ERR && ENABLED(ULTRA_LCD)
+  #include "../lcd/ultralcd.h"
+#endif
+
+#if ENABLED(SENSORLESS_HOMING)
+  #include "../feature/tmc2130.h"
 #endif
 
 #define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
 
 XYZ_CONSTS(float, base_min_pos,   MIN_POS);
 XYZ_CONSTS(float, base_max_pos,   MAX_POS);
 XYZ_CONSTS(float, base_home_pos,  HOME_POS);
 XYZ_CONSTS(float, max_length,     MAX_LENGTH);
 XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_CONSTS(signed char, home_dir, HOME_DIR);
@@ -65,44 +80,164 @@ bool relative_mode = false;
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
  *   A temporary position, usually applied to 'current_position'.
  *   Set with 'get_destination_from_command' or 'set_destination_to_current'.
  *   'line_to_destination' sets 'current_position' to 'destination'.
  */
 float destination[XYZE] = { 0.0 };
 
+
 // The active extruder (tool). Set with T<extruder> command.
 uint8_t active_extruder = 0;
 
+// Extruder offsets
+#if HOTENDS > 1
+  float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
+#endif
+
 // The feedrate for the current move, often used as the default if
 // no other feedrate is specified. Overridden for special moves.
 // Set by the last G0 through G5 command's "F" parameter.
 // Functions that override this for custom moves *must always* restore it!
 float feedrate_mm_s = MMM_TO_MMS(1500.0);
 
+int16_t feedrate_percentage = 100;
+
+// Homing feedrate is const progmem - compare to constexpr in the header
+const float homing_feedrate_mm_s[4] PROGMEM = {
+  #if ENABLED(DELTA)
+    MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
+  #else
+    MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
+  #endif
+  MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
+};
+
+// Cartesian conversion result goes here:
+float cartes[XYZ];
+
+// Until kinematics.cpp is created, create this here
+#if IS_KINEMATIC
+  float delta[ABC];
+#endif
+
+/**
+ * The workspace can be offset by some commands, or
+ * these offsets may be omitted to save on computation.
+ */
+#if HAS_WORKSPACE_OFFSET
+  #if HAS_POSITION_SHIFT
+    // The distance that XYZ has been offset by G92. Reset by G28.
+    float position_shift[XYZ] = { 0 };
+  #endif
+  #if HAS_HOME_OFFSET
+    // This offset is added to the configured home position.
+    // Set by M206, M428, or menu item. Saved to EEPROM.
+    float home_offset[XYZ] = { 0 };
+  #endif
+  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+    // The above two are combined to save on computes
+    float workspace_offset[XYZ] = { 0 };
+  #endif
+#endif
+
+#if OLDSCHOOL_ABL
+  float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
+#endif
+
+/**
+ * Output the current position to serial
+ */
+void report_current_position() {
+  SERIAL_PROTOCOLPGM("X:");
+  SERIAL_PROTOCOL(current_position[X_AXIS]);
+  SERIAL_PROTOCOLPGM(" Y:");
+  SERIAL_PROTOCOL(current_position[Y_AXIS]);
+  SERIAL_PROTOCOLPGM(" Z:");
+  SERIAL_PROTOCOL(current_position[Z_AXIS]);
+  SERIAL_PROTOCOLPGM(" E:");
+  SERIAL_PROTOCOL(current_position[E_AXIS]);
+
+  stepper.report_positions();
+
+  #if IS_SCARA
+    scara_report_positions();
+  #endif
+}
+
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   #endif
   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
 }
 
 void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
 
+/**
+ * Get the stepper positions in the cartes[] array.
+ * Forward kinematics are applied for DELTA and SCARA.
+ *
+ * The result is in the current coordinate space with
+ * leveling applied. The coordinates need to be run through
+ * unapply_leveling to obtain the "ideal" coordinates
+ * suitable for current_position, etc.
+ */
+void get_cartesian_from_steppers() {
+  #if ENABLED(DELTA)
+    forward_kinematics_DELTA(
+      stepper.get_axis_position_mm(A_AXIS),
+      stepper.get_axis_position_mm(B_AXIS),
+      stepper.get_axis_position_mm(C_AXIS)
+    );
+    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
+    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
+    cartes[Z_AXIS] += LOGICAL_Z_POSITION(0);
+  #elif IS_SCARA
+    forward_kinematics_SCARA(
+      stepper.get_axis_position_degrees(A_AXIS),
+      stepper.get_axis_position_degrees(B_AXIS)
+    );
+    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
+    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
+    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+  #else
+    cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
+    cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+  #endif
+}
+
+/**
+ * Set the current_position for an axis based on
+ * the stepper positions, removing any leveling that
+ * may have been applied.
+ */
+void set_current_from_steppers_for_axis(const AxisEnum axis) {
+  get_cartesian_from_steppers();
+  #if PLANNER_LEVELING
+    planner.unapply_leveling(cartes);
+  #endif
+  if (axis == ALL_AXES)
+    COPY(current_position, cartes);
+  else
+    current_position[axis] = cartes[axis];
+}
+
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position() {
   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
 }
 
 /**
  * Move the planner to the position stored in the destination array, which is
@@ -142,20 +277,181 @@ void line_to_destination(const float fr_mm_s) {
       ) return;
 
       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
     #endif
 
     set_current_to_destination();
   }
 
 #endif // IS_KINEMATIC
 
+/**
+ *  Plan a move to (X, Y, Z) and set the current_position
+ *  The final current_position may not be the one that was requested
+ */
+void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
+  const float old_feedrate_mm_s = feedrate_mm_s;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
+  #endif
+
+  #if ENABLED(DELTA)
+
+    if (!position_is_reachable_xy(lx, ly)) return;
+
+    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+
+    set_destination_to_current();          // sync destination at the start
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
+    #endif
+
+    // when in the danger zone
+    if (current_position[Z_AXIS] > delta_clip_start_height) {
+      if (lz > delta_clip_start_height) {   // staying in the danger zone
+        destination[X_AXIS] = lx;           // move directly (uninterpolated)
+        destination[Y_AXIS] = ly;
+        destination[Z_AXIS] = lz;
+        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
+        #endif
+        return;
+      }
+      else {
+        destination[Z_AXIS] = delta_clip_start_height;
+        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
+        #endif
+      }
+    }
+
+    if (lz > current_position[Z_AXIS]) {    // raising?
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
+      #endif
+    }
+
+    destination[X_AXIS] = lx;
+    destination[Y_AXIS] = ly;
+    prepare_move_to_destination();         // set_current_to_destination
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
+    #endif
+
+    if (lz < current_position[Z_AXIS]) {    // lowering?
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
+      #endif
+    }
+
+  #elif IS_SCARA
+
+    if (!position_is_reachable_xy(lx, ly)) return;
+
+    set_destination_to_current();
+
+    // If Z needs to raise, do it before moving XY
+    if (destination[Z_AXIS] < lz) {
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+    }
+
+    destination[X_AXIS] = lx;
+    destination[Y_AXIS] = ly;
+    prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
+
+    // If Z needs to lower, do it after moving XY
+    if (destination[Z_AXIS] > lz) {
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+    }
+
+  #else
+
+    // If Z needs to raise, do it before moving XY
+    if (current_position[Z_AXIS] < lz) {
+      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = lz;
+      line_to_current_position();
+    }
+
+    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+    current_position[X_AXIS] = lx;
+    current_position[Y_AXIS] = ly;
+    line_to_current_position();
+
+    // If Z needs to lower, do it after moving XY
+    if (current_position[Z_AXIS] > lz) {
+      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = lz;
+      line_to_current_position();
+    }
+
+  #endif
+
+  stepper.synchronize();
+
+  feedrate_mm_s = old_feedrate_mm_s;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
+  #endif
+}
+void do_blocking_move_to_x(const float &lx, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(lx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
+}
+void do_blocking_move_to_z(const float &lz, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], lz, fr_mm_s);
+}
+void do_blocking_move_to_xy(const float &lx, const float &ly, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(lx, ly, current_position[Z_AXIS], fr_mm_s);
+}
+
+//
+// Prepare to do endstop or probe moves
+// with custom feedrates.
+//
+//  - Save current feedrates
+//  - Reset the rate multiplier
+//  - Reset the command timeout
+//  - Enable the endstops (for endstop moves)
+//
+void bracket_probe_move(const bool before) {
+  static float saved_feedrate_mm_s;
+  static int16_t saved_feedrate_percentage;
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("bracket_probe_move", current_position);
+  #endif
+  if (before) {
+    saved_feedrate_mm_s = feedrate_mm_s;
+    saved_feedrate_percentage = feedrate_percentage;
+    feedrate_percentage = 100;
+    gcode.refresh_cmd_timeout();
+  }
+  else {
+    feedrate_mm_s = saved_feedrate_mm_s;
+    feedrate_percentage = saved_feedrate_percentage;
+    gcode.refresh_cmd_timeout();
+  }
+}
+
+void setup_for_endstop_or_probe_move() { bracket_probe_move(true); }
+void clean_up_after_endstop_or_probe_move() { bracket_probe_move(false); }
+
 // Software Endstops are based on the configured limits.
 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   // Software Endstops are based on the configured limits.
   bool soft_endstops_enabled = true;
 
   /**
@@ -182,87 +478,38 @@ float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
       #if DISABLED(DELTA)
         NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
         NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
       #endif
       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
     #endif
   }
 
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
-
-  #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
-
-  /**
-   * Prepare a bilinear-leveled linear move on Cartesian,
-   * splitting the move where it crosses grid borders.
-   */
-  void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF);
-    int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
-        cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
-        cx2 = CELL_INDEX(X, destination[X_AXIS]),
-        cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
-    cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
-    cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
-    cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
-    cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
-
-    if (cx1 == cx2 && cy1 == cy2) {
-      // Start and end on same mesh square
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
-
-    float normalized_dist, end[XYZE];
-
-    // Split at the left/front border of the right/top square
-    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
-    if (cx2 != cx1 && TEST(x_splits, gcx)) {
-      COPY(end, destination);
-      destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
-      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
-      destination[Y_AXIS] = LINE_SEGMENT_END(Y);
-      CBI(x_splits, gcx);
-    }
-    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
-      COPY(end, destination);
-      destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
-      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
-      destination[X_AXIS] = LINE_SEGMENT_END(X);
-      CBI(y_splits, gcy);
-    }
-    else {
-      // Already split on a border
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    destination[Z_AXIS] = LINE_SEGMENT_END(Z);
-    destination[E_AXIS] = LINE_SEGMENT_END(E);
-
-    // Do the split and look for more borders
-    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
-
-    // Restore destination from stack
-    COPY(destination, end);
-    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
-  }
-
-#endif // AUTO_BED_LEVELING_BILINEAR
-
 #if IS_KINEMATIC && !UBL_DELTA
 
+  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    #if ENABLED(DELTA)
+      #define ADJUST_DELTA(V) \
+        if (planner.abl_enabled) { \
+          const float zadj = bilinear_z_offset(V); \
+          delta[A_AXIS] += zadj; \
+          delta[B_AXIS] += zadj; \
+          delta[C_AXIS] += zadj; \
+        }
+    #else
+      #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
+    #endif
+  #else
+    #define ADJUST_DELTA(V) NOOP
+  #endif
+
   /**
    * Prepare a linear move in a DELTA or SCARA setup.
    *
    * This calls planner.buffer_line several times, adding
    * small incremental moves for DELTA or SCARA.
    */
   inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
 
     // Get the top feedrate of the move in the XY plane
     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
@@ -565,10 +812,460 @@ void prepare_move_to_destination() {
       prepare_kinematic_move_to(destination)
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_to_destination();
 }
+
+#if NEED_UNHOMED_ERR
+
+  bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
+    #if ENABLED(HOME_AFTER_DEACTIVATE)
+      const bool xx = x && !axis_known_position[X_AXIS],
+                 yy = y && !axis_known_position[Y_AXIS],
+                 zz = z && !axis_known_position[Z_AXIS];
+    #else
+      const bool xx = x && !axis_homed[X_AXIS],
+                 yy = y && !axis_homed[Y_AXIS],
+                 zz = z && !axis_homed[Z_AXIS];
+    #endif
+    if (xx || yy || zz) {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM(MSG_HOME " ");
+      if (xx) SERIAL_ECHOPGM(MSG_X);
+      if (yy) SERIAL_ECHOPGM(MSG_Y);
+      if (zz) SERIAL_ECHOPGM(MSG_Z);
+      SERIAL_ECHOLNPGM(" " MSG_FIRST);
+
+      #if ENABLED(ULTRA_LCD)
+        lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
+      #endif
+      return true;
+    }
+    return false;
+  }
+
+#endif
+
+/**
+ * The homing feedrate may vary
+ */
+inline float get_homing_bump_feedrate(const AxisEnum axis) {
+  static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
+  uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
+  if (hbd < 1) {
+    hbd = 10;
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
+  }
+  return homing_feedrate(axis) / hbd;
+}
+
+/**
+ * Home an individual linear axis
+ */
+static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
+      SERIAL_ECHOPAIR(", ", distance);
+      SERIAL_ECHOPAIR(", ", fr_mm_s);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
+    if (deploy_bltouch) set_bltouch_deployed(true);
+  #endif
+
+  #if QUIET_PROBING
+    if (axis == Z_AXIS) probing_pause(true);
+  #endif
+
+  // Tell the planner we're at Z=0
+  current_position[axis] = 0;
+
+  #if IS_SCARA
+    SYNC_PLAN_POSITION_KINEMATIC();
+    current_position[axis] = distance;
+    inverse_kinematics(current_position);
+    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+  #else
+    sync_plan_position();
+    current_position[axis] = distance;
+    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+  #endif
+
+  stepper.synchronize();
+
+  #if QUIET_PROBING
+    if (axis == Z_AXIS) probing_pause(false);
+  #endif
+
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    if (deploy_bltouch) set_bltouch_deployed(false);
+  #endif
+
+  endstops.hit_on_purpose();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+}
+
+/**
+ * Set an axis' current position to its home position (after homing).
+ *
+ * For Core and Cartesian robots this applies one-to-one when an
+ * individual axis has been homed.
+ *
+ * DELTA should wait until all homing is done before setting the XYZ
+ * current_position to home, because homing is a single operation.
+ * In the case where the axis positions are already known and previously
+ * homed, DELTA could home to X or Y individually by moving either one
+ * to the center. However, homing Z always homes XY and Z.
+ *
+ * SCARA should wait until all XY homing is done before setting the XY
+ * current_position to home, because neither X nor Y is at home until
+ * both are at home. Z can however be homed individually.
+ *
+ * Callers must sync the planner position after calling this!
+ */
+void set_axis_is_at_home(const AxisEnum axis) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  axis_known_position[axis] = axis_homed[axis] = true;
+
+  #if HAS_POSITION_SHIFT
+    position_shift[axis] = 0;
+    update_software_endstops(axis);
+  #endif
+
+  #if ENABLED(DUAL_X_CARRIAGE)
+    if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
+      current_position[X_AXIS] = x_home_pos(active_extruder);
+      return;
+    }
+  #endif
+
+  #if ENABLED(MORGAN_SCARA)
+    scara_set_axis_is_at_home(axis);
+  #else
+    current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
+  #endif
+
+  /**
+   * Z Probe Z Homing? Account for the probe's Z offset.
+   */
+  #if HAS_BED_PROBE && Z_HOME_DIR < 0
+    if (axis == Z_AXIS) {
+      #if HOMING_Z_WITH_PROBE
+
+        current_position[Z_AXIS] -= zprobe_zoffset;
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
+            SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
+          }
+        #endif
+
+      #elif ENABLED(DEBUG_LEVELING_FEATURE)
+
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
+
+      #endif
+    }
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      #if HAS_HOME_OFFSET
+        SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
+        SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
+      #endif
+      DEBUG_POS("", current_position);
+      SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    I2CPEM.homed(axis);
+  #endif
+}
+
+/**
+ * Home an individual "raw axis" to its endstop.
+ * This applies to XYZ on Cartesian and Core robots, and
+ * to the individual ABC steppers on DELTA and SCARA.
+ *
+ * At the end of the procedure the axis is marked as
+ * homed and the current position of that axis is updated.
+ * Kinematic robots should wait till all axes are homed
+ * before updating the current position.
+ */
+
+void homeaxis(const AxisEnum axis) {
+
+  #if IS_SCARA
+    // Only Z homing (with probe) is permitted
+    if (axis != Z_AXIS) { BUZZ(100, 880); return; }
+  #else
+    #define CAN_HOME(A) \
+      (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
+    if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  const int axis_home_dir =
+    #if ENABLED(DUAL_X_CARRIAGE)
+      (axis == X_AXIS) ? x_home_dir(active_extruder) :
+    #endif
+    home_dir(axis);
+
+  // Homing Z towards the bed? Deploy the Z probe or endstop.
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
+  #endif
+
+  // Set a flag for Z motor locking
+  #if ENABLED(Z_DUAL_ENDSTOPS)
+    if (axis == Z_AXIS) stepper.set_homing_flag(true);
+  #endif
+
+  // Disable stealthChop if used. Enable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130)
+      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
+    #endif
+  #endif
+
+  // Fast move towards endstop until triggered
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
+  #endif
+  do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
+
+  // When homing Z with probe respect probe clearance
+  const float bump = axis_home_dir * (
+    #if HOMING_Z_WITH_PROBE
+      (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
+    #endif
+    home_bump_mm(axis)
+  );
+
+  // If a second homing move is configured...
+  if (bump) {
+    // Move away from the endstop by the axis HOME_BUMP_MM
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
+    #endif
+    do_homing_move(axis, -bump);
+
+    // Slow move towards endstop until triggered
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
+    #endif
+    do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
+  }
+
+  #if ENABLED(Z_DUAL_ENDSTOPS)
+    if (axis == Z_AXIS) {
+      float adj = FABS(z_endstop_adj);
+      bool lockZ1;
+      if (axis_home_dir > 0) {
+        adj = -adj;
+        lockZ1 = (z_endstop_adj > 0);
+      }
+      else
+        lockZ1 = (z_endstop_adj < 0);
+
+      if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+
+      // Move to the adjusted endstop height
+      do_homing_move(axis, adj);
+
+      if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
+      stepper.set_homing_flag(false);
+    } // Z_AXIS
+  #endif
+
+  #if IS_SCARA
+
+    set_axis_is_at_home(axis);
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+  #elif ENABLED(DELTA)
+
+    // Delta has already moved all three towers up in G28
+    // so here it re-homes each tower in turn.
+    // Delta homing treats the axes as normal linear axes.
+
+    // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
+    if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
+      #endif
+      do_homing_move(axis, delta_endstop_adj[axis] - 0.1);
+    }
+
+  #else
+
+    // For cartesian/core machines,
+    // set the axis to its home position
+    set_axis_is_at_home(axis);
+    sync_plan_position();
+
+    destination[axis] = current_position[axis];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
+    #endif
+
+  #endif
+
+  // Re-enable stealthChop if used. Disable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130)
+      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
+    #endif
+  #endif
+
+  // Put away the Z probe
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS && STOW_PROBE()) return;
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+} // homeaxis()
+
+#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+
+  /**
+   * Software endstops can be used to monitor the open end of
+   * an axis that has a hardware endstop on the other end. Or
+   * they can prevent axes from moving past endstops and grinding.
+   *
+   * To keep doing their job as the coordinate system changes,
+   * the software endstop positions must be refreshed to remain
+   * at the same positions relative to the machine.
+   */
+  void update_software_endstops(const AxisEnum axis) {
+    const float offs = 0.0
+      #if HAS_HOME_OFFSET
+        + home_offset[axis]
+      #endif
+      #if HAS_POSITION_SHIFT
+        + position_shift[axis]
+      #endif
+    ;
+
+    #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+      workspace_offset[axis] = offs;
+    #endif
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (axis == X_AXIS) {
+
+        // In Dual X mode hotend_offset[X] is T1's home position
+        float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
+
+        if (active_extruder != 0) {
+          // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
+          soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
+          soft_endstop_max[X_AXIS] = dual_max_x + offs;
+        }
+        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
+          // In Duplication Mode, T0 can move as far left as X_MIN_POS
+          // but not so far to the right that T1 would move past the end
+          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
+          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
+        }
+        else {
+          // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
+          soft_endstop_min[axis] = base_min_pos(axis) + offs;
+          soft_endstop_max[axis] = base_max_pos(axis) + offs;
+        }
+      }
+    #elif ENABLED(DELTA)
+      soft_endstop_min[axis] = base_min_pos(axis) + (axis == Z_AXIS ? 0 : offs);
+      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+    #else
+      soft_endstop_min[axis] = base_min_pos(axis) + offs;
+      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+    #endif
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
+        #if HAS_HOME_OFFSET
+          SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
+        #endif
+        #if HAS_POSITION_SHIFT
+          SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
+        #endif
+        SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
+        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
+      }
+    #endif
+
+    #if ENABLED(DELTA)
+      if (axis == Z_AXIS)
+        delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+    #endif
+  }
+
+#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
+
+#if HAS_M206_COMMAND
+  /**
+   * Change the home offset for an axis, update the current
+   * position and the software endstops to retain the same
+   * relative distance to the new home.
+   *
+   * Since this changes the current_position, code should
+   * call sync_plan_position soon after this.
+   */
+  void set_home_offset(const AxisEnum axis, const float v) {
+    current_position[axis] += v - home_offset[axis];
+    home_offset[axis] = v;
+    update_software_endstops(axis);
+  }
+#endif // HAS_M206_COMMAND

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/module/motion.cpp b/Marlin/src/module/motion.cpp
new file mode 100644
index 0000000000..df227d7e48
--- /dev/null
+++ b/Marlin/src/module/motion.cpp
@@ -0,0 +1,574 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * motion.cpp
+ */
+
+#include "motion.h"
+
+#include "../gcode/gcode.h"
+// #include "../module/planner.h"
+// #include "../Marlin.h"
+// #include "../inc/MarlinConfig.h"
+
+#include "../core/serial.h"
+#include "../module/stepper.h"
+#include "../module/temperature.h"
+
+#if IS_SCARA
+  #include "../libs/buzzer.h"
+  #include "../lcd/ultralcd.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../feature/ubl/ubl.h"
+#endif
+
+#define XYZ_CONSTS(type, array, CONFIG) const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }
+
+XYZ_CONSTS(float, base_min_pos,   MIN_POS);
+XYZ_CONSTS(float, base_max_pos,   MAX_POS);
+XYZ_CONSTS(float, base_home_pos,  HOME_POS);
+XYZ_CONSTS(float, max_length,     MAX_LENGTH);
+XYZ_CONSTS(float, home_bump_mm,   HOME_BUMP_MM);
+XYZ_CONSTS(signed char, home_dir, HOME_DIR);
+
+// Relative Mode. Enable with G91, disable with G90.
+bool relative_mode = false;
+
+/**
+ * Cartesian Current Position
+ *   Used to track the logical position as moves are queued.
+ *   Used by 'line_to_current_position' to do a move after changing it.
+ *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
+ */
+float current_position[XYZE] = { 0.0 };
+
+/**
+ * Cartesian Destination
+ *   A temporary position, usually applied to 'current_position'.
+ *   Set with 'get_destination_from_command' or 'set_destination_to_current'.
+ *   'line_to_destination' sets 'current_position' to 'destination'.
+ */
+float destination[XYZE] = { 0.0 };
+
+// The active extruder (tool). Set with T<extruder> command.
+uint8_t active_extruder = 0;
+
+// The feedrate for the current move, often used as the default if
+// no other feedrate is specified. Overridden for special moves.
+// Set by the last G0 through G5 command's "F" parameter.
+// Functions that override this for custom moves *must always* restore it!
+float feedrate_mm_s = MMM_TO_MMS(1500.0);
+
+/**
+ * sync_plan_position
+ *
+ * Set the planner/stepper positions directly from current_position with
+ * no kinematic translation. Used for homing axes and cartesian/core syncing.
+ */
+void sync_plan_position() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
+  #endif
+  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+}
+
+void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
+
+/**
+ * Move the planner to the current position from wherever it last moved
+ * (or from wherever it has been told it is located).
+ */
+void line_to_current_position() {
+  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
+}
+
+/**
+ * Move the planner to the position stored in the destination array, which is
+ * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
+ */
+void line_to_destination(const float fr_mm_s) {
+  planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
+}
+
+#if IS_KINEMATIC
+
+  void sync_plan_position_kinematic() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
+    #endif
+    planner.set_position_mm_kinematic(current_position);
+  }
+
+  /**
+   * Calculate delta, start a line, and set current_position to destination
+   */
+  void prepare_uninterpolated_move_to_destination(const float fr_mm_s/*=0.0*/) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
+    #endif
+
+    gcode.refresh_cmd_timeout();
+
+    #if UBL_DELTA
+      // ubl segmented line will do z-only moves in single segment
+      ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
+    #else
+      if ( current_position[X_AXIS] == destination[X_AXIS]
+        && current_position[Y_AXIS] == destination[Y_AXIS]
+        && current_position[Z_AXIS] == destination[Z_AXIS]
+        && current_position[E_AXIS] == destination[E_AXIS]
+      ) return;
+
+      planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
+    #endif
+
+    set_current_to_destination();
+  }
+
+#endif // IS_KINEMATIC
+
+// Software Endstops are based on the configured limits.
+float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
+      soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
+
+#if HAS_SOFTWARE_ENDSTOPS
+
+  // Software Endstops are based on the configured limits.
+  bool soft_endstops_enabled = true;
+
+  /**
+   * Constrain the given coordinates to the software endstops.
+   */
+
+  // NOTE: This makes no sense for delta beds other than Z-axis.
+  //       For delta the X/Y would need to be clamped at
+  //       DELTA_PRINTABLE_RADIUS from center of bed, but delta
+  //       now enforces is_position_reachable for X/Y regardless
+  //       of HAS_SOFTWARE_ENDSTOPS, so that enforcement would be
+  //       redundant here.
+
+  void clamp_to_software_endstops(float target[XYZ]) {
+    if (!soft_endstops_enabled) return;
+    #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
+      #if DISABLED(DELTA)
+        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
+        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+      #endif
+      NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
+    #endif
+    #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+      #if DISABLED(DELTA)
+        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
+        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+      #endif
+      NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
+    #endif
+  }
+
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
+
+  #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
+
+  /**
+   * Prepare a bilinear-leveled linear move on Cartesian,
+   * splitting the move where it crosses grid borders.
+   */
+  void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF);
+    int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
+        cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
+        cx2 = CELL_INDEX(X, destination[X_AXIS]),
+        cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
+    cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
+    cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
+    cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
+    cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
+
+    if (cx1 == cx2 && cy1 == cy2) {
+      // Start and end on same mesh square
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
+
+    float normalized_dist, end[XYZE];
+
+    // Split at the left/front border of the right/top square
+    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
+    if (cx2 != cx1 && TEST(x_splits, gcx)) {
+      COPY(end, destination);
+      destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
+      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
+      destination[Y_AXIS] = LINE_SEGMENT_END(Y);
+      CBI(x_splits, gcx);
+    }
+    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
+      COPY(end, destination);
+      destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
+      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
+      destination[X_AXIS] = LINE_SEGMENT_END(X);
+      CBI(y_splits, gcy);
+    }
+    else {
+      // Already split on a border
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    destination[Z_AXIS] = LINE_SEGMENT_END(Z);
+    destination[E_AXIS] = LINE_SEGMENT_END(E);
+
+    // Do the split and look for more borders
+    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
+
+    // Restore destination from stack
+    COPY(destination, end);
+    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
+  }
+
+#endif // AUTO_BED_LEVELING_BILINEAR
+
+#if IS_KINEMATIC && !UBL_DELTA
+
+  /**
+   * Prepare a linear move in a DELTA or SCARA setup.
+   *
+   * This calls planner.buffer_line several times, adding
+   * small incremental moves for DELTA or SCARA.
+   */
+  inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
+
+    // Get the top feedrate of the move in the XY plane
+    const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
+
+    // If the move is only in Z/E don't split up the move
+    if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
+      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+      return false;
+    }
+
+    // Fail if attempting move outside printable radius
+    if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS])) return true;
+
+    // Get the cartesian distances moved in XYZE
+    const float difference[XYZE] = {
+      ltarget[X_AXIS] - current_position[X_AXIS],
+      ltarget[Y_AXIS] - current_position[Y_AXIS],
+      ltarget[Z_AXIS] - current_position[Z_AXIS],
+      ltarget[E_AXIS] - current_position[E_AXIS]
+    };
+
+    // Get the linear distance in XYZ
+    float cartesian_mm = SQRT(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
+
+    // If the move is very short, check the E move distance
+    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(difference[E_AXIS]);
+
+    // No E move either? Game over.
+    if (UNEAR_ZERO(cartesian_mm)) return true;
+
+    // Minimum number of seconds to move the given distance
+    const float seconds = cartesian_mm / _feedrate_mm_s;
+
+    // The number of segments-per-second times the duration
+    // gives the number of segments
+    uint16_t segments = delta_segments_per_second * seconds;
+
+    // For SCARA minimum segment size is 0.25mm
+    #if IS_SCARA
+      NOMORE(segments, cartesian_mm * 4);
+    #endif
+
+    // At least one segment is required
+    NOLESS(segments, 1);
+
+    // The approximate length of each segment
+    const float inv_segments = 1.0 / float(segments),
+                segment_distance[XYZE] = {
+                  difference[X_AXIS] * inv_segments,
+                  difference[Y_AXIS] * inv_segments,
+                  difference[Z_AXIS] * inv_segments,
+                  difference[E_AXIS] * inv_segments
+                };
+
+    // SERIAL_ECHOPAIR("mm=", cartesian_mm);
+    // SERIAL_ECHOPAIR(" seconds=", seconds);
+    // SERIAL_ECHOLNPAIR(" segments=", segments);
+
+    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+      // SCARA needs to scale the feed rate from mm/s to degrees/s
+      const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
+                  feed_factor = inv_segment_length * _feedrate_mm_s;
+      float oldA = stepper.get_axis_position_degrees(A_AXIS),
+            oldB = stepper.get_axis_position_degrees(B_AXIS);
+    #endif
+
+    // Get the logical current position as starting point
+    float logical[XYZE];
+    COPY(logical, current_position);
+
+    // Drop one segment so the last move is to the exact target.
+    // If there's only 1 segment, loops will be skipped entirely.
+    --segments;
+
+    // Calculate and execute the segments
+    for (uint16_t s = segments + 1; --s;) {
+      LOOP_XYZE(i) logical[i] += segment_distance[i];
+      #if ENABLED(DELTA)
+        DELTA_LOGICAL_IK(); // Delta can inline its kinematics
+      #else
+        inverse_kinematics(logical);
+      #endif
+
+      ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
+
+      #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+        // For SCARA scale the feed rate from mm/s to degrees/s
+        // Use ratio between the length of the move and the larger angle change
+        const float adiff = abs(delta[A_AXIS] - oldA),
+                    bdiff = abs(delta[B_AXIS] - oldB);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+        oldA = delta[A_AXIS];
+        oldB = delta[B_AXIS];
+      #else
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
+      #endif
+    }
+
+    // Since segment_distance is only approximate,
+    // the final move must be to the exact destination.
+
+    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+      // For SCARA scale the feed rate from mm/s to degrees/s
+      // With segments > 1 length is 1 segment, otherwise total length
+      inverse_kinematics(ltarget);
+      ADJUST_DELTA(ltarget);
+      const float adiff = abs(delta[A_AXIS] - oldA),
+                  bdiff = abs(delta[B_AXIS] - oldB);
+      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+    #else
+      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+    #endif
+
+    return false;
+  }
+
+#else // !IS_KINEMATIC || UBL_DELTA
+
+  /**
+   * Prepare a linear move in a Cartesian setup.
+   * If Mesh Bed Leveling is enabled, perform a mesh move.
+   *
+   * Returns true if the caller didn't update current_position.
+   */
+  inline bool prepare_move_to_destination_cartesian() {
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      const float fr_scaled = MMS_SCALED(feedrate_mm_s);
+      if (ubl.state.active) { // direct use of ubl.state.active for speed
+        ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
+        return true;
+      }
+      else
+        line_to_destination(fr_scaled);
+    #else
+      // Do not use feedrate_percentage for E or Z only moves
+      if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS])
+        line_to_destination();
+      else {
+        const float fr_scaled = MMS_SCALED(feedrate_mm_s);
+        #if ENABLED(MESH_BED_LEVELING)
+          if (mbl.active()) { // direct used of mbl.active() for speed
+            mesh_line_to_destination(fr_scaled);
+            return true;
+          }
+          else
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          if (planner.abl_enabled) { // direct use of abl_enabled for speed
+            bilinear_line_to_destination(fr_scaled);
+            return true;
+          }
+          else
+        #endif
+            line_to_destination(fr_scaled);
+      }
+    #endif
+    return false;
+  }
+
+#endif // !IS_KINEMATIC || UBL_DELTA
+
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  bool extruder_duplication_enabled = false;                              // Used in Dual X mode 2
+#endif
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  DualXMode dual_x_carriage_mode         = DEFAULT_DUAL_X_CARRIAGE_MODE;
+  float inactive_extruder_x_pos          = X2_MAX_POS,                    // used in mode 0 & 1
+        raised_parked_position[XYZE],                                     // used in mode 1
+        duplicate_extruder_x_offset      = DEFAULT_DUPLICATION_X_OFFSET;  // used in mode 2
+  bool active_extruder_parked            = false;                         // used in mode 1 & 2
+  millis_t delayed_move_time             = 0;                             // used in mode 1
+  int16_t duplicate_extruder_temp_offset = 0;                             // used in mode 2
+
+  float x_home_pos(const int extruder) {
+    if (extruder == 0)
+      return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
+    else
+      /**
+       * In dual carriage mode the extruder offset provides an override of the
+       * second X-carriage position when homed - otherwise X2_HOME_POS is used.
+       * This allows soft recalibration of the second extruder home position
+       * without firmware reflash (through the M218 command).
+       */
+      return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
+  }
+
+  /**
+   * Prepare a linear move in a dual X axis setup
+   */
+  inline bool prepare_move_to_destination_dualx() {
+    if (active_extruder_parked) {
+      switch (dual_x_carriage_mode) {
+        case DXC_FULL_CONTROL_MODE:
+          break;
+        case DXC_AUTO_PARK_MODE:
+          if (current_position[E_AXIS] == destination[E_AXIS]) {
+            // This is a travel move (with no extrusion)
+            // Skip it, but keep track of the current position
+            // (so it can be used as the start of the next non-travel move)
+            if (delayed_move_time != 0xFFFFFFFFUL) {
+              set_current_to_destination();
+              NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
+              delayed_move_time = millis();
+              return true;
+            }
+          }
+          // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
+          for (uint8_t i = 0; i < 3; i++)
+            planner.buffer_line(
+              i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
+              i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
+              i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
+              current_position[E_AXIS],
+              i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
+              active_extruder
+            );
+          delayed_move_time = 0;
+          active_extruder_parked = false;
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
+          #endif
+          break;
+        case DXC_DUPLICATION_MODE:
+          if (active_extruder == 0) {
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
+                SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
+              }
+            #endif
+            // move duplicate extruder into correct duplication position.
+            planner.set_position_mm(
+              LOGICAL_X_POSITION(inactive_extruder_x_pos),
+              current_position[Y_AXIS],
+              current_position[Z_AXIS],
+              current_position[E_AXIS]
+            );
+            planner.buffer_line(
+              current_position[X_AXIS] + duplicate_extruder_x_offset,
+              current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
+              planner.max_feedrate_mm_s[X_AXIS], 1
+            );
+            SYNC_PLAN_POSITION_KINEMATIC();
+            stepper.synchronize();
+            extruder_duplication_enabled = true;
+            active_extruder_parked = false;
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
+            #endif
+          }
+          else {
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
+            #endif
+          }
+          break;
+      }
+    }
+    return false;
+  }
+
+#endif // DUAL_X_CARRIAGE
+
+/**
+ * Prepare a single move and get ready for the next one
+ *
+ * This may result in several calls to planner.buffer_line to
+ * do smaller moves for DELTA, SCARA, mesh moves, etc.
+ */
+void prepare_move_to_destination() {
+  clamp_to_software_endstops(destination);
+  gcode.refresh_cmd_timeout();
+
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+
+    if (!DEBUGGING(DRYRUN)) {
+      if (destination[E_AXIS] != current_position[E_AXIS]) {
+        if (thermalManager.tooColdToExtrude(active_extruder)) {
+          current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+        }
+        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+          if (destination[E_AXIS] - current_position[E_AXIS] > EXTRUDE_MAXLENGTH) {
+            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            SERIAL_ECHO_START();
+            SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+          }
+        #endif
+      }
+    }
+
+  #endif
+
+  if (
+    #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
+      ubl.prepare_segmented_line_to(destination, feedrate_mm_s)
+    #elif IS_KINEMATIC
+      prepare_kinematic_move_to(destination)
+    #elif ENABLED(DUAL_X_CARRIAGE)
+      prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
+    #else
+      prepare_move_to_destination_cartesian()
+    #endif
+  ) return;
+
+  set_current_to_destination();
+}
