commit f3b8b0b5b94cbd96bb3cdb48625942b14e17babc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 18:29:05 2021 -0600

    🚚 Rename L6470 G-code file

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
deleted file mode 100644
index 8d614603ed..0000000000
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ /dev/null
@@ -1,651 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-//
-// NOTE: All tests assume each axis uses matching driver chips.
-//
-
-#include "../../../inc/MarlinConfig.h"
-
-#if HAS_L64XX
-
-#include "../../gcode.h"
-#include "../../../module/stepper/indirection.h"
-#include "../../../module/planner.h"
-#include "../../../libs/L64XX/L64XX_Marlin.h"
-
-#define DEBUG_OUT ENABLED(L6470_CHITCHAT)
-#include "../../../core/debug_out.h"
-
-/**
- * M916: increase KVAL_HOLD until get thermal warning
- *       NOTE - on L6474 it is TVAL that is used
- *
- * J - select which driver(s) to monitor on multi-driver axis
- *     0 - (default) monitor all drivers on the axis or E0
- *     1 - monitor only X, Y, Z, E1
- *     2 - monitor only X2, Y2, Z2, E2
- *     3 - monitor only Z3, E3
- *     4 - monitor only Z4, E4
- *
- * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
- *     xxx (1-255) is distance moved on either side of current position
- *
- * F - feedrate
- *     optional - will use default max feedrate from configuration.h if not specified
- *
- * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
- *     optional - will report current value from driver if not specified
- *
- * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
- *     optional - will report current value from driver if not specified
- *
- * D - time (in seconds) to run each setting of KVAL_HOLD/TVAL
- *     optional - defaults to zero (runs each setting once)
- */
-
-/**
- * This routine is also useful for determining the approximate KVAL_HOLD
- * where the stepper stops losing steps. The sound will get noticeably quieter
- * as it stops losing steps.
- */
-
-void GcodeSuite::M916() {
-
-  DEBUG_ECHOLNPGM("M916");
-
-  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
-
-  // Variables used by L64xxManager.get_user_input function - some may not be used
-  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
-  L64XX_axis_t axis_index[3];
-  uint16_t axis_status[3];
-  uint8_t driver_count = 1;
-  float position_max;
-  float position_min;
-  float final_feedrate;
-  uint8_t kval_hold;
-  uint8_t OCD_TH_val = 0;
-  uint8_t STALL_TH_val = 0;
-  uint16_t over_current_threshold;
-  constexpr uint8_t over_current_flag = false;  // M916 doesn't play with the overcurrent thresholds
-
-  #define DRIVER_TYPE_L6474(Q) AXIS_DRIVER_TYPE_##Q(L6474)
-
-  uint8_t j;   // general purpose counter
-
-  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
-    return;  // quit if invalid user input
-
-  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
-
-  planner.synchronize();                             // wait for all current movement commands to complete
-
-  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
-  for (j = 0; j < driver_count; j++)
-    L64xxManager.get_status(axis_index[j]);  // clear out any pre-existing error flags
-
-  char temp_axis_string[] = " ";
-  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
-  char gcode_string[80];
-  uint16_t status_composite = 0;
-
-  uint16_t M91x_counter = kval_hold;
-  uint16_t M91x_counter_max;
-  if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {
-    M91x_counter_max = 128;  // TVAL is 7 bits
-    LIMIT(M91x_counter, 0U, 127U);
-  }
-  else
-    M91x_counter_max = 256;  // KVAL_HOLD is 8 bits
-
-  uint8_t M91x_delay_s = parser.byteval('D');   // get delay in seconds
-  millis_t M91x_delay_ms = SEC_TO_MS(M91x_delay_s * 60);
-  millis_t M91x_delay_end;
-
-  DEBUG_ECHOLNPGM(".\n.");
-
-  do {
-
-    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
-      DEBUG_ECHOLNPGM("TVAL current (mA) = ", (M91x_counter + 1) * sh.AXIS_STALL_CURRENT_CONSTANT_INV);        // report TVAL current for this run
-    else
-      DEBUG_ECHOLNPGM("kval_hold = ", M91x_counter);                                   // report KVAL_HOLD for this run
-
-    for (j = 0; j < driver_count; j++)
-      L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, M91x_counter);  //set KVAL_HOLD or TVAL (same register address)
-
-    M91x_delay_end = millis() + M91x_delay_ms;
-    do {
-      // turn the motor(s) both directions
-      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
-      process_subcommands_now(gcode_string);
-
-      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
-      process_subcommands_now(gcode_string);
-
-      // get the status after the motors have stopped
-      planner.synchronize();
-
-      status_composite = 0;    // clear out the old bits
-
-      for (j = 0; j < driver_count; j++) {
-        axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
-        status_composite |= axis_status[j] ;
-      }
-
-      if (status_composite) break;
-    } while (millis() < M91x_delay_end);
-
-    if (status_composite) break;
-
-    M91x_counter++;
-
-  } while (!(status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) && (M91x_counter < M91x_counter_max));
-
-  DEBUG_ECHOLNPGM(".");
-
-  #if ENABLED(L6470_CHITCHAT)
-    if (status_composite) {
-      L64xxManager.error_status_decode(status_composite, axis_index[0],
-        sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
-        sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
-        sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
-      DEBUG_ECHOLNPGM(".");
-    }
-  #endif
-
-  if ((status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)))
-    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Thermal warning/shutdown has occurred");
-  else if (status_composite)
-    DEBUG_ECHOLNPGM(".\n.\nTest completed abnormally - non-thermal error has occurred");
-  else
-    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Unable to get to thermal warning/shutdown");
-
-  L64xxManager.pause_monitor(false);
-}
-
-/**
- * M917: Find minimum current thresholds
- *
- *   Decrease OCD current until overcurrent error
- *   Increase OCD until overcurrent error goes away
- *   Decrease stall threshold until stall (not done on L6474)
- *   Increase stall until stall error goes away (not done on L6474)
- *
- * J - select which driver(s) to monitor on multi-driver axis
- *     0 - (default) monitor all drivers on the axis or E0
- *     1 - monitor only X, Y, Z, E1
- *     2 - monitor only X2, Y2, Z2, E2
- * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
- *     xxx (1-255) is distance moved on either side of current position
- *
- * F - feedrate
- *     optional - will use default max feedrate from Configuration.h if not specified
- *
- * I - starting over-current threshold
- *     optional - will report current value from driver if not specified
- *     if there are multiple drivers on the axis then all will be set the same
- *
- * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
- *     optional - will report current value from driver if not specified
- *
- * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
- *     optional - will report current value from driver if not specified
- */
-void GcodeSuite::M917() {
-
-  DEBUG_ECHOLNPGM("M917");
-
-  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
-
-  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
-  L64XX_axis_t axis_index[3];
-  uint16_t axis_status[3];
-  uint8_t driver_count = 1;
-  float position_max;
-  float position_min;
-  float final_feedrate;
-  uint8_t kval_hold;
-  uint8_t OCD_TH_val = 0;
-  uint8_t STALL_TH_val = 0;
-  uint16_t over_current_threshold;
-  constexpr uint8_t over_current_flag = true;
-
-  uint8_t j;   // general purpose counter
-
-  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
-    return;  // quit if invalid user input
-
-  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
-
-  planner.synchronize();                             // wait for all current movement commands to complete
-
-  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
-  for (j = 0; j < driver_count; j++)
-    L64xxManager.get_status(axis_index[j]);  // clear error flags
-  char temp_axis_string[] = " ";
-  temp_axis_string[0] = axis_mon[0][0];   // need a sprintf format string
-  char gcode_string[80];
-  uint16_t status_composite = 0;
-  uint8_t test_phase = 0;                 // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
-                                          // 1 - increasing OCD - exit when OCD warning stops (ignore STALL)
-                                          // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
-                                          // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
-                                          // 4 - all testing completed
-  DEBUG_ECHOPGM(".\n.\n.\nover_current threshold : ", (OCD_TH_val + 1) * 375);   // first status display
-  DEBUG_ECHOPGM("  (OCD_TH:  : ", OCD_TH_val);
-  if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) {
-    DEBUG_ECHOPGM(")   Stall threshold: ", (STALL_TH_val + 1) * 31.25);
-    DEBUG_ECHOPGM("  (STALL_TH: ", STALL_TH_val);
-  }
-  DEBUG_ECHOLNPGM(")");
-
-  do {
-
-    if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) DEBUG_ECHOPGM("STALL threshold : ", (STALL_TH_val + 1) * 31.25);
-    DEBUG_ECHOLNPGM("   OCD threshold : ", (OCD_TH_val + 1) * 375);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
-    process_subcommands_now(gcode_string);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
-    process_subcommands_now(gcode_string);
-
-    planner.synchronize();
-
-    status_composite = 0;    // clear out the old bits
-
-    for (j = 0; j < driver_count; j++) {
-      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
-      status_composite |= axis_status[j];
-    }
-
-    if (status_composite && (status_composite & sh.STATUS_AXIS_UVLO)) {
-      DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
-      #if ENABLED(L6470_CHITCHAT)
-        for (j = 0; j < driver_count; j++) {
-          if (j) DEBUG_ECHOPGM("...");
-          L64xxManager.error_status_decode(axis_status[j], axis_index[j],
-            sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
-            sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
-            sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
-        }
-      #endif
-      return;
-    }
-
-    if (status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) {
-      DEBUG_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
-      uint16_t status_composite_temp = 0;
-      uint8_t k = 0;
-      do {
-        k++;
-        if (!(k % 4)) {
-          kval_hold *= 0.95;
-          DEBUG_EOL();
-          DEBUG_ECHOLNPGM("Lowering KVAL_HOLD by about 5% to ", kval_hold);
-          for (j = 0; j < driver_count; j++)
-            L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
-        }
-        DEBUG_ECHOLNPGM(".");
-        reset_stepper_timeout(); // keep steppers powered
-        watchdog_refresh();
-        safe_delay(5000);
-        status_composite_temp = 0;
-        for (j = 0; j < driver_count; j++) {
-          axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
-          status_composite_temp |= axis_status[j];
-        }
-      }
-      while (status_composite_temp & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD));
-      DEBUG_EOL();
-    }
-    if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B | sh.STATUS_AXIS_OCD)) {
-      switch (test_phase) {
-
-        case 0: {
-          if (status_composite & sh.STATUS_AXIS_OCD) {
-            // phase 0 with OCD warning - time to go to next phase
-            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
-              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
-              test_phase = 2;            // at highest value so skip phase 1
-              //DEBUG_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
-              DEBUG_ECHOLNPGM("OCD at highest - OCD finalized");
-            }
-            else {
-              OCD_TH_val++;              // normal exit to next phase
-              test_phase = 1;            // setup for first pass of phase 1
-              //DEBUG_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
-              DEBUG_ECHOLNPGM("inc OCD");
-            }
-          }
-          else {  // phase 0 without OCD warning - keep on decrementing if can
-            if (OCD_TH_val) {
-              OCD_TH_val--;              // try lower value
-              //DEBUG_ECHOLNPGM("LOGIC E0C - dec OCD");
-              DEBUG_ECHOLNPGM("dec OCD");
-            }
-            else {
-              test_phase = 2;            // at lowest value without warning so skip phase 1
-              //DEBUG_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
-              DEBUG_ECHOLNPGM("OCD finalized");
-            }
-          }
-        } break;
-
-        case 1: {
-          if (status_composite & sh.STATUS_AXIS_OCD) {
-            // phase 1 with OCD warning - increment if can
-            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
-              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
-              test_phase = 2;            // at highest value so go to next phase
-              //DEBUG_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
-              DEBUG_ECHOLNPGM("OCD finalized");
-            }
-            else {
-              OCD_TH_val++;              // try a higher value
-              //DEBUG_ECHOLNPGM("LOGIC E1B - inc OCD");
-              DEBUG_ECHOLNPGM("inc OCD");
-            }
-          }
-          else { // phase 1 without OCD warning - normal exit to phase 2
-            test_phase = 2;
-            //DEBUG_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
-            DEBUG_ECHOLNPGM("OCD finalized");
-          }
-        } break;
-
-        case 2: {
-          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
-            test_phase = 4;
-            break;
-          }
-          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
-            // phase 2 with stall warning - time to go to next phase
-            if (STALL_TH_val >= 127) {
-              STALL_TH_val = 127;  // limit to max
-              //DEBUG_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
-              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
-              test_phase = 4;
-            }
-            else {
-              test_phase = 3;              // normal exit to next phase (found failing value of STALL)
-              STALL_TH_val++;              // setup for first pass of phase 3
-              //DEBUG_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
-              DEBUG_ECHOLNPGM("inc Stall");
-            }
-          }
-          else {  // phase 2 without stall warning - decrement if can
-            if (STALL_TH_val) {
-              STALL_TH_val--;              // try a lower value
-              //DEBUG_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
-              DEBUG_ECHOLNPGM("dec STALL");
-            }
-            else {
-              DEBUG_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
-              test_phase = 4;
-              //DEBUG_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
-            }
-          }
-        } break;
-
-        case 3: {
-          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
-            test_phase = 4;
-            break;
-          }
-          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
-            // phase 3 with stall warning - increment if can
-            if (STALL_TH_val >= 127) {
-              STALL_TH_val = 127; // limit to max
-              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
-              test_phase = 4;
-              //DEBUG_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
-            }
-            else {
-              STALL_TH_val++;              // still looking for passing value
-              //DEBUG_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
-              DEBUG_ECHOLNPGM("inc stall");
-            }
-          }
-          else {  //phase 3 without stall warning  but have OCD warning
-            DEBUG_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
-            test_phase = 4;
-            //DEBUG_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
-          }
-        } break;
-
-      }
-
-    }
-    else {
-      switch (test_phase) {
-        case 0: { // phase 0 without OCD warning - keep on decrementing if can
-          if (OCD_TH_val) {
-            OCD_TH_val--;             // try lower value
-            //DEBUG_ECHOLNPGM("LOGIC N0A - DEC OCD");
-            DEBUG_ECHOLNPGM("DEC OCD");
-          }
-          else {
-            test_phase = 2;           // at lowest value without warning so skip phase 1
-            //DEBUG_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
-            DEBUG_ECHOLNPGM("OCD finalized");
-          }
-        } break;
-
-        case 1: //DEBUG_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
-                DEBUG_ECHOLNPGM("OCD finalized");
-
-        case 2: { // phase 2 without stall warning - keep on decrementing if can
-          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
-            test_phase = 4;
-            break;
-          }
-          if (STALL_TH_val) {
-            STALL_TH_val--;              // try a lower value (stay in phase 2)
-            //DEBUG_ECHOLNPGM("LOGIC N2B - dec STALL");
-            DEBUG_ECHOLNPGM("dec STALL");
-          }
-          else {
-            DEBUG_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
-            test_phase = 4;
-            //DEBUG_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
-          }
-        } break;
-
-        case 3: {
-          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
-            test_phase = 4;
-            break;
-          }
-          test_phase = 4;
-           //DEBUG_ECHOLNPGM("LOGIC N3 - finished!");
-           DEBUG_ECHOLNPGM("finished!");
-        } break;  // phase 3 without any warnings - desired exit
-      }  //
-    }  // end of status checks
-
-    if (test_phase != 4) {
-      for (j = 0; j < driver_count; j++) {                       // update threshold(s)
-        L64xxManager.set_param(axis_index[j], L6470_OCD_TH, OCD_TH_val);
-        if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) L64xxManager.set_param(axis_index[j], L6470_STALL_TH, STALL_TH_val);
-        if (L64xxManager.get_param(axis_index[j], L6470_OCD_TH) != OCD_TH_val) DEBUG_ECHOLNPGM("OCD mismatch");
-        if ((L64xxManager.get_param(axis_index[j], L6470_STALL_TH) != STALL_TH_val) && (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT)) DEBUG_ECHOLNPGM("STALL mismatch");
-      }
-    }
-
-  } while (test_phase != 4);
-
-  DEBUG_ECHOLNPGM(".");
-  if (status_composite) {
-    #if ENABLED(L6470_CHITCHAT)
-      for (j = 0; j < driver_count; j++) {
-        if (j) DEBUG_ECHOPGM("...");
-        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
-          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
-          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
-          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
-      }
-      DEBUG_ECHOLNPGM(".");
-    #endif
-    DEBUG_ECHOLNPGM("Completed with errors");
-  }
-  else
-    DEBUG_ECHOLNPGM("Completed with no errors");
-  DEBUG_ECHOLNPGM(".");
-
-  L64xxManager.pause_monitor(false);
-}
-
-/**
- * M918: increase speed until error or max feedrate achieved (as shown in configuration.h))
- *
- * J - select which driver(s) to monitor on multi-driver axis
- *     0 - (default) monitor all drivers on the axis or E0
- *     1 - monitor only X, Y, Z, E1
- *     2 - monitor only X2, Y2, Z2, E2
- * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
- *     xxx (1-255) is distance moved on either side of current position
- *
- * I - over current threshold
- *     optional - will report current value from driver if not specified
- *
- * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
- *     optional - will report current value from driver if not specified
- *
- * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
- *     optional - will report current value from driver if not specified
- *
- * M - value for microsteps (1 - 128) (optional)
- *     optional - will report current value from driver if not specified
- */
-void GcodeSuite::M918() {
-
-  DEBUG_ECHOLNPGM("M918");
-
-  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
-
-  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
-  L64XX_axis_t axis_index[3];
-  uint16_t axis_status[3];
-  uint8_t driver_count = 1;
-  float position_max, position_min;
-  float final_feedrate;
-  uint8_t kval_hold;
-  uint8_t OCD_TH_val = 0;
-  uint8_t STALL_TH_val = 0;
-  uint16_t over_current_threshold;
-  constexpr uint8_t over_current_flag = true;
-
-  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
-
-  uint8_t j;   // general purpose counter
-
-  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
-    return;  // quit if invalid user input
-
-  L64xxManager.get_status(axis_index[0]); // populate shadow array
-
-  uint8_t m_steps = parser.byteval('M');
-
-  if (m_steps != 0) {
-    LIMIT(m_steps, 1, sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT ? 16 : 128);  // L6474
-
-    uint8_t stepVal;
-    for (stepVal = 0; stepVal < 8; stepVal++) {  // convert to L64xx register value
-      if (m_steps == 1) break;
-      m_steps >>= 1;
-    }
-
-    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
-      stepVal |= 0x98;  // NO SYNC
-    else
-      stepVal |= (!SYNC_EN) | SYNC_SEL_1 | stepVal;
-
-    for (j = 0; j < driver_count; j++) {
-      L64xxManager.set_param(axis_index[j], dSPIN_HARD_HIZ, 0);          // can't write STEP register if stepper being powered
-                                                                         //   results in an extra NOOP being sent (data 00)
-      L64xxManager.set_param(axis_index[j], L6470_STEP_MODE, stepVal);   // set microsteps
-    }
-  }
-  m_steps = L64xxManager.get_param(axis_index[0], L6470_STEP_MODE) & 0x07;   // get microsteps
-
-  DEBUG_ECHOLNPGM("Microsteps = ", _BV(m_steps));
-  DEBUG_ECHOLNPGM("target (maximum) feedrate = ", final_feedrate);
-
-  const float feedrate_inc = final_feedrate / 10,   // Start at 1/10 of max & go up by 1/10 per step
-              fr_limit = final_feedrate * 0.99f;    // Rounding-safe comparison value
-  float current_feedrate = 0;
-
-  planner.synchronize();                            // Wait for moves to complete
-
-  for (j = 0; j < driver_count; j++)
-    L64xxManager.get_status(axis_index[j]);         // Clear error flags
-
-  char temp_axis_string[2] = " ";
-  temp_axis_string[0] = axis_mon[0][0];             // Need a sprintf format string
-  //temp_axis_string[1] = '\n';
-
-  char gcode_string[80];
-  uint16_t status_composite = 0;
-  DEBUG_ECHOLNPGM(".\n.\n.");                       // Make feedrate outputs easier to read
-
-  do {
-    current_feedrate += feedrate_inc;
-    DEBUG_ECHOLNPGM("...feedrate = ", current_feedrate);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(current_feedrate));
-    process_subcommands_now(gcode_string);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(current_feedrate));
-    process_subcommands_now(gcode_string);
-
-    planner.synchronize();
-
-    for (j = 0; j < driver_count; j++) {
-      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & 0x0800;  // Bits of interest are all active LOW
-      status_composite |= axis_status[j];
-    }
-    if (status_composite) break;              // Break on any error
-  } while (current_feedrate < fr_limit);
-
-  DEBUG_ECHOPGM("Completed with ");
-  if (status_composite) {
-    DEBUG_ECHOLNPGM("errors");
-    #if ENABLED(L6470_CHITCHAT)
-      for (j = 0; j < driver_count; j++) {
-        if (j) DEBUG_ECHOPGM("...");
-        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
-          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
-          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
-          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
-      }
-    #endif
-  }
-  else
-    DEBUG_ECHOLNPGM("no errors");
-
-  L64xxManager.pause_monitor(false);
-}
-
-#endif // HAS_L64XX

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    🎨 Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index ad0a91111d..8d614603ed 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -138,10 +138,10 @@ void GcodeSuite::M916() {
     do {
       // turn the motor(s) both directions
       sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
-      gcode.process_subcommands_now_P(gcode_string);
+      process_subcommands_now(gcode_string);
 
       sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
-      gcode.process_subcommands_now_P(gcode_string);
+      process_subcommands_now(gcode_string);
 
       // get the status after the motors have stopped
       planner.synchronize();
@@ -266,10 +266,10 @@ void GcodeSuite::M917() {
     DEBUG_ECHOLNPGM("   OCD threshold : ", (OCD_TH_val + 1) * 375);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     planner.synchronize();
 
@@ -308,7 +308,7 @@ void GcodeSuite::M917() {
             L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
         DEBUG_ECHOLNPGM(".");
-        gcode.reset_stepper_timeout(); // keep steppers powered
+        reset_stepper_timeout(); // keep steppers powered
         watchdog_refresh();
         safe_delay(5000);
         status_composite_temp = 0;
@@ -615,10 +615,10 @@ void GcodeSuite::M918() {
     DEBUG_ECHOLNPGM("...feedrate = ", current_feedrate);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(current_feedrate));
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(current_feedrate));
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     planner.synchronize();
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 3dd21ef985..ad0a91111d 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -96,7 +96,7 @@ void GcodeSuite::M916() {
   if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
 
   planner.synchronize();                             // wait for all current movement commands to complete
 
@@ -127,9 +127,9 @@ void GcodeSuite::M916() {
   do {
 
     if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
-      DEBUG_ECHOLNPAIR("TVAL current (mA) = ", (M91x_counter + 1) * sh.AXIS_STALL_CURRENT_CONSTANT_INV);        // report TVAL current for this run
+      DEBUG_ECHOLNPGM("TVAL current (mA) = ", (M91x_counter + 1) * sh.AXIS_STALL_CURRENT_CONSTANT_INV);        // report TVAL current for this run
     else
-      DEBUG_ECHOLNPAIR("kval_hold = ", M91x_counter);                                   // report KVAL_HOLD for this run
+      DEBUG_ECHOLNPGM("kval_hold = ", M91x_counter);                                   // report KVAL_HOLD for this run
 
     for (j = 0; j < driver_count; j++)
       L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, M91x_counter);  //set KVAL_HOLD or TVAL (same register address)
@@ -236,7 +236,7 @@ void GcodeSuite::M917() {
   if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
 
   planner.synchronize();                             // wait for all current movement commands to complete
 
@@ -252,18 +252,18 @@ void GcodeSuite::M917() {
                                           // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
                                           // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
                                           // 4 - all testing completed
-  DEBUG_ECHOPAIR(".\n.\n.\nover_current threshold : ", (OCD_TH_val + 1) * 375);   // first status display
-  DEBUG_ECHOPAIR("  (OCD_TH:  : ", OCD_TH_val);
+  DEBUG_ECHOPGM(".\n.\n.\nover_current threshold : ", (OCD_TH_val + 1) * 375);   // first status display
+  DEBUG_ECHOPGM("  (OCD_TH:  : ", OCD_TH_val);
   if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) {
-    DEBUG_ECHOPAIR(")   Stall threshold: ", (STALL_TH_val + 1) * 31.25);
-    DEBUG_ECHOPAIR("  (STALL_TH: ", STALL_TH_val);
+    DEBUG_ECHOPGM(")   Stall threshold: ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOPGM("  (STALL_TH: ", STALL_TH_val);
   }
   DEBUG_ECHOLNPGM(")");
 
   do {
 
-    if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) DEBUG_ECHOPAIR("STALL threshold : ", (STALL_TH_val + 1) * 31.25);
-    DEBUG_ECHOLNPAIR("   OCD threshold : ", (OCD_TH_val + 1) * 375);
+    if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) DEBUG_ECHOPGM("STALL threshold : ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOLNPGM("   OCD threshold : ", (OCD_TH_val + 1) * 375);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
     gcode.process_subcommands_now_P(gcode_string);
@@ -303,7 +303,7 @@ void GcodeSuite::M917() {
         if (!(k % 4)) {
           kval_hold *= 0.95;
           DEBUG_EOL();
-          DEBUG_ECHOLNPAIR("Lowering KVAL_HOLD by about 5% to ", kval_hold);
+          DEBUG_ECHOLNPGM("Lowering KVAL_HOLD by about 5% to ", kval_hold);
           for (j = 0; j < driver_count; j++)
             L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
@@ -590,8 +590,8 @@ void GcodeSuite::M918() {
   }
   m_steps = L64xxManager.get_param(axis_index[0], L6470_STEP_MODE) & 0x07;   // get microsteps
 
-  DEBUG_ECHOLNPAIR("Microsteps = ", _BV(m_steps));
-  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPGM("Microsteps = ", _BV(m_steps));
+  DEBUG_ECHOLNPGM("target (maximum) feedrate = ", final_feedrate);
 
   const float feedrate_inc = final_feedrate / 10,   // Start at 1/10 of max & go up by 1/10 per step
               fr_limit = final_feedrate * 0.99f;    // Rounding-safe comparison value
@@ -612,7 +612,7 @@ void GcodeSuite::M918() {
 
   do {
     current_feedrate += feedrate_inc;
-    DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
+    DEBUG_ECHOLNPGM("...feedrate = ", current_feedrate);
 
     sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(current_feedrate));
     gcode.process_subcommands_now_P(gcode_string);

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    🐛 Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 8a1ea48306..3dd21ef985 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -177,7 +177,7 @@ void GcodeSuite::M916() {
   if ((status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)))
     DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Thermal warning/shutdown has occurred");
   else if (status_composite)
-    DEBUG_ECHOLNPGM(".\n.\nTest completed abnormally - non-thermal error has occured");
+    DEBUG_ECHOLNPGM(".\n.\nTest completed abnormally - non-thermal error has occurred");
   else
     DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Unable to get to thermal warning/shutdown");
 

commit b8186b50817d33999a414400d82d876da7b40ee9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 25 08:32:58 2021 -0600

    Apply SEC_TO_MS and other fixes

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 2672f91239..8a1ea48306 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -119,7 +119,7 @@ void GcodeSuite::M916() {
     M91x_counter_max = 256;  // KVAL_HOLD is 8 bits
 
   uint8_t M91x_delay_s = parser.byteval('D');   // get delay in seconds
-  millis_t M91x_delay_ms = M91x_delay_s * 60 * 1000;
+  millis_t M91x_delay_ms = SEC_TO_MS(M91x_delay_s * 60);
   millis_t M91x_delay_end;
 
   DEBUG_ECHOLNPGM(".\n.");

commit 3893114c86c195d227e023c9e702197b54b2636f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 19 15:51:53 2020 -0600

    MKS WiFi preliminary changes

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 8165b71e44..2672f91239 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -308,8 +308,8 @@ void GcodeSuite::M917() {
             L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
         DEBUG_ECHOLNPGM(".");
-        gcode.reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
-        watchdog_refresh();;   // beat the dog
+        gcode.reset_stepper_timeout(); // keep steppers powered
+        watchdog_refresh();
         safe_delay(5000);
         status_composite_temp = 0;
         for (j = 0; j < driver_count; j++) {

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 29efc06dd9..8165b71e44 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -37,7 +37,6 @@
 #include "../../../core/debug_out.h"
 
 /**
- *
  * M916: increase KVAL_HOLD until get thermal warning
  *       NOTE - on L6474 it is TVAL that is used
  *
@@ -62,7 +61,6 @@
  *
  * D - time (in seconds) to run each setting of KVAL_HOLD/TVAL
  *     optional - defaults to zero (runs each setting once)
- *
  */
 
 /**
@@ -187,7 +185,6 @@ void GcodeSuite::M916() {
 }
 
 /**
- *
  * M917: Find minimum current thresholds
  *
  *   Decrease OCD current until overcurrent error
@@ -214,7 +211,6 @@ void GcodeSuite::M916() {
  *
  * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
  *     optional - will report current value from driver if not specified
- *
  */
 void GcodeSuite::M917() {
 
@@ -522,7 +518,6 @@ void GcodeSuite::M917() {
 }
 
 /**
- *
  * M918: increase speed until error or max feedrate achieved (as shown in configuration.h))
  *
  * J - select which driver(s) to monitor on multi-driver axis
@@ -543,7 +538,6 @@ void GcodeSuite::M917() {
  *
  * M - value for microsteps (1 - 128) (optional)
  *     optional - will report current value from driver if not specified
- *
  */
 void GcodeSuite::M918() {
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index a3eaf7b26a..29efc06dd9 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 9eb097ad49..a3eaf7b26a 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 9827fc38f5..9eb097ad49 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -46,6 +46,7 @@
  *     1 - monitor only X, Y, Z, E1
  *     2 - monitor only X2, Y2, Z2, E2
  *     3 - monitor only Z3, E3
+ *     4 - monitor only Z4, E4
  *
  * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
  *     xxx (1-255) is distance moved on either side of current position

commit 1ad53cee1f4e2768310fca98de0381df9c39b617
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Mon Jan 13 18:47:30 2020 -0600

    Improved STMicro L64XX stepper driver support (#16452)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 96a27f3330..9827fc38f5 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -20,35 +20,26 @@
  *
  */
 
+//
+// NOTE: All tests assume each axis uses matching driver chips.
+//
+
 #include "../../../inc/MarlinConfig.h"
 
-#if HAS_DRIVER(L6470)
+#if HAS_L64XX
 
 #include "../../gcode.h"
 #include "../../../module/stepper/indirection.h"
 #include "../../../module/planner.h"
-#include "../../../libs/L6470/L6470_Marlin.h"
+#include "../../../libs/L64XX/L64XX_Marlin.h"
 
 #define DEBUG_OUT ENABLED(L6470_CHITCHAT)
 #include "../../../core/debug_out.h"
 
-static void jiggle_axis(const char axis_char, const float &min, const float &max, const feedRate_t &fr_mm_m) {
-  char gcode_string[30], str1[11], str2[11];
-
-  // Turn the motor(s) both directions
-  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(min, 1, 3, str1), dtostrf(fr_mm_m, 1, 3, str2));
-  gcode.process_subcommands_now(gcode_string);
-
-  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(max, 1, 3, str1), str2);
-  gcode.process_subcommands_now(gcode_string);
-
-  planner.synchronize();
-}
-
 /**
  *
- * M916: Increase KVAL_HOLD until thermal warning
- *
+ * M916: increase KVAL_HOLD until get thermal warning
+ *       NOTE - on L6474 it is TVAL that is used
  *
  * J - select which driver(s) to monitor on multi-driver axis
  *     0 - (default) monitor all drivers on the axis or E0
@@ -62,8 +53,14 @@ static void jiggle_axis(const char axis_char, const float &min, const float &max
  * F - feedrate
  *     optional - will use default max feedrate from configuration.h if not specified
  *
- * K - starting value for KVAL_HOLD (0 - 255)
- *     optional - will use & report current value from driver if not specified
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
+ *     optional - will report current value from driver if not specified
+ *
+ * D - time (in seconds) to run each setting of KVAL_HOLD/TVAL
+ *     optional - defaults to zero (runs each setting once)
  *
  */
 
@@ -77,80 +74,115 @@ void GcodeSuite::M916() {
 
   DEBUG_ECHOLNPGM("M916");
 
-  // Variables used by L6470_get_user_input function - some may not be used
-  char axis_mon[3][3] = { "  ", "  ", "  " };  // list of Axes to be monitored
-  uint8_t axis_index[3];
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  // Variables used by L64xxManager.get_user_input function - some may not be used
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
   uint16_t axis_status[3];
   uint8_t driver_count = 1;
   float position_max;
   float position_min;
-  feedRate_t final_fr_mm_m;
+  float final_feedrate;
   uint8_t kval_hold;
-  uint8_t ocd_th_val = 0;
-  uint8_t stall_th_val = 0;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
   uint16_t over_current_threshold;
-  constexpr bool over_current_flag = false;  // M916 doesn't play with the overcurrent thresholds
+  constexpr uint8_t over_current_flag = false;  // M916 doesn't play with the overcurrent thresholds
+
+  #define DRIVER_TYPE_L6474(Q) AXIS_DRIVER_TYPE_##Q(L6474)
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_fr_mm_m);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
-  planner.synchronize();                  // Wait for moves to finish
+  planner.synchronize();                             // wait for all current movement commands to complete
 
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);      // Clear out error flags
+    L64xxManager.get_status(axis_index[j]);  // clear out any pre-existing error flags
 
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
+  char gcode_string[80];
   uint16_t status_composite = 0;
 
+  uint16_t M91x_counter = kval_hold;
+  uint16_t M91x_counter_max;
+  if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {
+    M91x_counter_max = 128;  // TVAL is 7 bits
+    LIMIT(M91x_counter, 0U, 127U);
+  }
+  else
+    M91x_counter_max = 256;  // KVAL_HOLD is 8 bits
+
+  uint8_t M91x_delay_s = parser.byteval('D');   // get delay in seconds
+  millis_t M91x_delay_ms = M91x_delay_s * 60 * 1000;
+  millis_t M91x_delay_end;
+
   DEBUG_ECHOLNPGM(".\n.");
 
   do {
 
-    DEBUG_ECHOLNPAIR("kval_hold = ", kval_hold);   // set & report KVAL_HOLD for this run
+    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
+      DEBUG_ECHOLNPAIR("TVAL current (mA) = ", (M91x_counter + 1) * sh.AXIS_STALL_CURRENT_CONSTANT_INV);        // report TVAL current for this run
+    else
+      DEBUG_ECHOLNPAIR("kval_hold = ", M91x_counter);                                   // report KVAL_HOLD for this run
 
     for (j = 0; j < driver_count; j++)
-      L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
+      L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, M91x_counter);  //set KVAL_HOLD or TVAL (same register address)
 
-    // Turn the motor(s) both directions
-    jiggle_axis(axis_mon[0][0], position_min, position_max, final_fr_mm_m);
+    M91x_delay_end = millis() + M91x_delay_ms;
+    do {
+      // turn the motor(s) both directions
+      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
+      gcode.process_subcommands_now_P(gcode_string);
 
-    status_composite = 0;    // clear out the old bits
+      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
+      gcode.process_subcommands_now_P(gcode_string);
 
-    for (j = 0; j < driver_count; j++) {
-      axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
-      status_composite |= axis_status[j] ;
-    }
+      // get the status after the motors have stopped
+      planner.synchronize();
+
+      status_composite = 0;    // clear out the old bits
 
-    if (status_composite && (status_composite & STATUS_UVLO)) {
-      DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
       for (j = 0; j < driver_count; j++) {
-        DEBUG_ECHOPGM("...");
-        L6470.error_status_decode(axis_status[j], axis_index[j]);
+        axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
+        status_composite |= axis_status[j] ;
       }
-      return;
-    }
 
-    // increment KVAL_HOLD if not yet at thermal warning/shutdown
-    if (!(status_composite & (STATUS_TH_WRN | STATUS_TH_SD)))
-      kval_hold++;
+      if (status_composite) break;
+    } while (millis() < M91x_delay_end);
 
-  } while (!(status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) && kval_hold);  // exit when kval_hold == 0 (rolls over)
+    if (status_composite) break;
 
-  DEBUG_ECHOPGM(".\n.\nThermal warning/shutdown ");
-  if ((status_composite & (STATUS_TH_WRN | STATUS_TH_SD))) {
-    DEBUG_ECHOLNPGM("has occurred");
-    for (j = 0; j < driver_count; j++) {
-      DEBUG_ECHOPGM("...");
-      L6470.error_status_decode(axis_status[j], axis_index[j]);
+    M91x_counter++;
+
+  } while (!(status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) && (M91x_counter < M91x_counter_max));
+
+  DEBUG_ECHOLNPGM(".");
+
+  #if ENABLED(L6470_CHITCHAT)
+    if (status_composite) {
+      L64xxManager.error_status_decode(status_composite, axis_index[0],
+        sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+        sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+        sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      DEBUG_ECHOLNPGM(".");
     }
-  }
+  #endif
+
+  if ((status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)))
+    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Thermal warning/shutdown has occurred");
+  else if (status_composite)
+    DEBUG_ECHOLNPGM(".\n.\nTest completed abnormally - non-thermal error has occured");
   else
-    DEBUG_ECHOLNPGM("(Unable to get)");
+    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Unable to get to thermal warning/shutdown");
 
-  DEBUG_ECHOLNPGM(".");
+  L64xxManager.pause_monitor(false);
 }
 
 /**
@@ -159,8 +191,8 @@ void GcodeSuite::M916() {
  *
  *   Decrease OCD current until overcurrent error
  *   Increase OCD until overcurrent error goes away
- *   Decrease stall threshold until stall
- *   Increase stall until stall error goes away
+ *   Decrease stall threshold until stall (not done on L6474)
+ *   Increase stall until stall error goes away (not done on L6474)
  *
  * J - select which driver(s) to monitor on multi-driver axis
  *     0 - (default) monitor all drivers on the axis or E0
@@ -176,7 +208,10 @@ void GcodeSuite::M916() {
  *     optional - will report current value from driver if not specified
  *     if there are multiple drivers on the axis then all will be set the same
  *
- * K - value for KVAL_HOLD (0 - 255)
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
  *     optional - will report current value from driver if not specified
  *
  */
@@ -184,66 +219,85 @@ void GcodeSuite::M917() {
 
   DEBUG_ECHOLNPGM("M917");
 
-  char axis_mon[3][3] = { "  ", "  ", "  " };  // list of axes to be monitored
-  uint8_t axis_index[3];
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
   uint16_t axis_status[3];
   uint8_t driver_count = 1;
   float position_max;
   float position_min;
-  feedRate_t final_fr_mm_m;
+  float final_feedrate;
   uint8_t kval_hold;
-  uint8_t ocd_th_val = 0;
-  uint8_t stall_th_val = 0;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
   uint16_t over_current_threshold;
-  constexpr bool over_current_flag = true;
+  constexpr uint8_t over_current_flag = true;
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_fr_mm_m);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
-  planner.synchronize();                // Wait for moves to finish
+  planner.synchronize();                             // wait for all current movement commands to complete
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);    // Clear out error flags
+    L64xxManager.get_status(axis_index[j]);  // clear error flags
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];   // need a sprintf format string
+  char gcode_string[80];
   uint16_t status_composite = 0;
-  uint8_t test_phase = 0;
-        // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
-        // 1 - increasing OCD - exit when OCD warning stops (ignore STALL) -
-        // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
-        // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
-        // 4 - all testing completed
-  DEBUG_ECHOPAIR(".\n.\n.\nover_current threshold : ", (ocd_th_val + 1) * 375);   // first status display
-  DEBUG_ECHOPAIR("  (OCD_TH:  : ", ocd_th_val);
-  DEBUG_ECHOPAIR(")   Stall threshold: ", (stall_th_val + 1) * 31.25);
-  DEBUG_ECHOPAIR("  (STALL_TH: ", stall_th_val);
+  uint8_t test_phase = 0;                 // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
+                                          // 1 - increasing OCD - exit when OCD warning stops (ignore STALL)
+                                          // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
+                                          // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
+                                          // 4 - all testing completed
+  DEBUG_ECHOPAIR(".\n.\n.\nover_current threshold : ", (OCD_TH_val + 1) * 375);   // first status display
+  DEBUG_ECHOPAIR("  (OCD_TH:  : ", OCD_TH_val);
+  if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) {
+    DEBUG_ECHOPAIR(")   Stall threshold: ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOPAIR("  (STALL_TH: ", STALL_TH_val);
+  }
   DEBUG_ECHOLNPGM(")");
 
   do {
 
-    DEBUG_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
-    DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
+    if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) DEBUG_ECHOPAIR("STALL threshold : ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOLNPAIR("   OCD threshold : ", (OCD_TH_val + 1) * 375);
 
-    jiggle_axis(axis_mon[0][0], position_min, position_max, final_fr_mm_m);
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
+    gcode.process_subcommands_now_P(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
+    gcode.process_subcommands_now_P(gcode_string);
+
+    planner.synchronize();
 
     status_composite = 0;    // clear out the old bits
 
     for (j = 0; j < driver_count; j++) {
-      axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
+      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
       status_composite |= axis_status[j];
     }
 
-    if (status_composite && (status_composite & STATUS_UVLO)) {
+    if (status_composite && (status_composite & sh.STATUS_AXIS_UVLO)) {
       DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
-      for (j = 0; j < driver_count; j++) {
-        DEBUG_ECHOPGM("...");
-        L6470.error_status_decode(axis_status[j], axis_index[j]);
-      }
+      #if ENABLED(L6470_CHITCHAT)
+        for (j = 0; j < driver_count; j++) {
+          if (j) DEBUG_ECHOPGM("...");
+          L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+            sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+            sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+            sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+        }
+      #endif
       return;
     }
 
-    if (status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) {
+    if (status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) {
       DEBUG_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
       uint16_t status_composite_temp = 0;
       uint8_t k = 0;
@@ -251,118 +305,136 @@ void GcodeSuite::M917() {
         k++;
         if (!(k % 4)) {
           kval_hold *= 0.95;
-          L6470_EOL();
+          DEBUG_EOL();
           DEBUG_ECHOLNPAIR("Lowering KVAL_HOLD by about 5% to ", kval_hold);
           for (j = 0; j < driver_count; j++)
-            L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
+            L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
         DEBUG_ECHOLNPGM(".");
-        reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
-        watchdog_refresh();
+        gcode.reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
+        watchdog_refresh();;   // beat the dog
         safe_delay(5000);
         status_composite_temp = 0;
         for (j = 0; j < driver_count; j++) {
-          axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
+          axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
           status_composite_temp |= axis_status[j];
         }
       }
-      while (status_composite_temp & (STATUS_TH_WRN | STATUS_TH_SD));
-      L6470_EOL();
+      while (status_composite_temp & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD));
+      DEBUG_EOL();
     }
-    if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B | STATUS_OCD)) {
+    if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B | sh.STATUS_AXIS_OCD)) {
       switch (test_phase) {
 
         case 0: {
-          if (status_composite & STATUS_OCD) {
+          if (status_composite & sh.STATUS_AXIS_OCD) {
             // phase 0 with OCD warning - time to go to next phase
-            if (ocd_th_val >=15) {
-              ocd_th_val = 15;           // limit to max
+            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
+              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
               test_phase = 2;            // at highest value so skip phase 1
-              DEBUG_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
+              //DEBUG_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
+              DEBUG_ECHOLNPGM("OCD at highest - OCD finalized");
             }
             else {
-              ocd_th_val++;              // normal exit to next phase
+              OCD_TH_val++;              // normal exit to next phase
               test_phase = 1;            // setup for first pass of phase 1
-              DEBUG_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
+              //DEBUG_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
+              DEBUG_ECHOLNPGM("inc OCD");
             }
           }
           else {  // phase 0 without OCD warning - keep on decrementing if can
-            if (ocd_th_val) {
-              ocd_th_val--;              // try lower value
-              DEBUG_ECHOLNPGM("LOGIC E0C - dec OCD");
+            if (OCD_TH_val) {
+              OCD_TH_val--;              // try lower value
+              //DEBUG_ECHOLNPGM("LOGIC E0C - dec OCD");
+              DEBUG_ECHOLNPGM("dec OCD");
             }
             else {
               test_phase = 2;            // at lowest value without warning so skip phase 1
-              DEBUG_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
+              //DEBUG_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
+              DEBUG_ECHOLNPGM("OCD finalized");
             }
           }
         } break;
 
         case 1: {
-          if (status_composite & STATUS_OCD) {
+          if (status_composite & sh.STATUS_AXIS_OCD) {
             // phase 1 with OCD warning - increment if can
-            if (ocd_th_val >= 15) {
-              ocd_th_val = 15;           // limit to max
+            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
+              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
               test_phase = 2;            // at highest value so go to next phase
-              DEBUG_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
+              //DEBUG_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
+              DEBUG_ECHOLNPGM("OCD finalized");
             }
             else {
-              ocd_th_val++;              // try a higher value
-              DEBUG_ECHOLNPGM("LOGIC E1B - inc OCD");
+              OCD_TH_val++;              // try a higher value
+              //DEBUG_ECHOLNPGM("LOGIC E1B - inc OCD");
+              DEBUG_ECHOLNPGM("inc OCD");
             }
           }
           else { // phase 1 without OCD warning - normal exit to phase 2
             test_phase = 2;
-            DEBUG_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
+            //DEBUG_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
+            DEBUG_ECHOLNPGM("OCD finalized");
           }
         } break;
 
         case 2: {
-          if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B)) {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
             // phase 2 with stall warning - time to go to next phase
-            if (stall_th_val >= 127) {
-              stall_th_val = 127;  // limit to max
-              DEBUG_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
+            if (STALL_TH_val >= 127) {
+              STALL_TH_val = 127;  // limit to max
+              //DEBUG_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
               DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
               test_phase = 4;
             }
             else {
               test_phase = 3;              // normal exit to next phase (found failing value of STALL)
-              stall_th_val++;              // setup for first pass of phase 3
-              DEBUG_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
+              STALL_TH_val++;              // setup for first pass of phase 3
+              //DEBUG_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
+              DEBUG_ECHOLNPGM("inc Stall");
             }
           }
           else {  // phase 2 without stall warning - decrement if can
-            if (stall_th_val) {
-              stall_th_val--;              // try a lower value
-              DEBUG_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
+            if (STALL_TH_val) {
+              STALL_TH_val--;              // try a lower value
+              //DEBUG_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
+              DEBUG_ECHOLNPGM("dec STALL");
             }
             else {
               DEBUG_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
               test_phase = 4;
-              DEBUG_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
+              //DEBUG_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
             }
           }
         } break;
 
         case 3: {
-          if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B)) {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
             // phase 3 with stall warning - increment if can
-            if (stall_th_val >= 127) {
-              stall_th_val = 127; // limit to max
+            if (STALL_TH_val >= 127) {
+              STALL_TH_val = 127; // limit to max
               DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
               test_phase = 4;
-              DEBUG_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
+              //DEBUG_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
             }
             else {
-              stall_th_val++;              // still looking for passing value
-              DEBUG_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
+              STALL_TH_val++;              // still looking for passing value
+              //DEBUG_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
+              DEBUG_ECHOLNPGM("inc stall");
             }
           }
           else {  //phase 3 without stall warning  but have OCD warning
             DEBUG_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
             test_phase = 4;
-            DEBUG_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
+            //DEBUG_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
           }
         } break;
 
@@ -372,58 +444,81 @@ void GcodeSuite::M917() {
     else {
       switch (test_phase) {
         case 0: { // phase 0 without OCD warning - keep on decrementing if can
-          if (ocd_th_val) {
-            ocd_th_val--;             // try lower value
-            DEBUG_ECHOLNPGM("LOGIC N0A - DEC OCD");
+          if (OCD_TH_val) {
+            OCD_TH_val--;             // try lower value
+            //DEBUG_ECHOLNPGM("LOGIC N0A - DEC OCD");
+            DEBUG_ECHOLNPGM("DEC OCD");
           }
           else {
             test_phase = 2;           // at lowest value without warning so skip phase 1
-            DEBUG_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
+            //DEBUG_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
+            DEBUG_ECHOLNPGM("OCD finalized");
           }
         } break;
 
-        case 1: DEBUG_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
+        case 1: //DEBUG_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
+                DEBUG_ECHOLNPGM("OCD finalized");
 
         case 2: { // phase 2 without stall warning - keep on decrementing if can
-          if (stall_th_val) {
-            stall_th_val--;              // try a lower value (stay in phase 2)
-            DEBUG_ECHOLNPGM("LOGIC N2B - dec STALL");
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (STALL_TH_val) {
+            STALL_TH_val--;              // try a lower value (stay in phase 2)
+            //DEBUG_ECHOLNPGM("LOGIC N2B - dec STALL");
+            DEBUG_ECHOLNPGM("dec STALL");
           }
           else {
             DEBUG_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
             test_phase = 4;
-            DEBUG_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
+            //DEBUG_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
           }
         } break;
 
-        case 3: { test_phase = 4;
-           DEBUG_ECHOLNPGM("LOGIC N3 - finished!");
+        case 3: {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          test_phase = 4;
+           //DEBUG_ECHOLNPGM("LOGIC N3 - finished!");
+           DEBUG_ECHOLNPGM("finished!");
         } break;  // phase 3 without any warnings - desired exit
       }  //
     }  // end of status checks
 
     if (test_phase != 4) {
       for (j = 0; j < driver_count; j++) {                       // update threshold(s)
-        L6470.set_param(axis_index[j], L6470_OCD_TH, ocd_th_val);
-        L6470.set_param(axis_index[j], L6470_STALL_TH, stall_th_val);
-        if (L6470.get_param(axis_index[j], L6470_OCD_TH) != ocd_th_val) DEBUG_ECHOLNPGM("OCD mismatch");
-        if (L6470.get_param(axis_index[j], L6470_STALL_TH) != stall_th_val) DEBUG_ECHOLNPGM("STALL mismatch");
+        L64xxManager.set_param(axis_index[j], L6470_OCD_TH, OCD_TH_val);
+        if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) L64xxManager.set_param(axis_index[j], L6470_STALL_TH, STALL_TH_val);
+        if (L64xxManager.get_param(axis_index[j], L6470_OCD_TH) != OCD_TH_val) DEBUG_ECHOLNPGM("OCD mismatch");
+        if ((L64xxManager.get_param(axis_index[j], L6470_STALL_TH) != STALL_TH_val) && (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT)) DEBUG_ECHOLNPGM("STALL mismatch");
       }
     }
 
   } while (test_phase != 4);
 
+  DEBUG_ECHOLNPGM(".");
   if (status_composite) {
+    #if ENABLED(L6470_CHITCHAT)
+      for (j = 0; j < driver_count; j++) {
+        if (j) DEBUG_ECHOPGM("...");
+        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      }
+      DEBUG_ECHOLNPGM(".");
+    #endif
     DEBUG_ECHOLNPGM("Completed with errors");
-    for (j = 0; j < driver_count; j++) {
-      DEBUG_ECHOPGM("...");
-      L6470.error_status_decode(axis_status[j], axis_index[j]);
-    }
   }
   else
     DEBUG_ECHOLNPGM("Completed with no errors");
+  DEBUG_ECHOLNPGM(".");
 
-} // M917
+  L64xxManager.pause_monitor(false);
+}
 
 /**
  *
@@ -439,7 +534,13 @@ void GcodeSuite::M917() {
  * I - over current threshold
  *     optional - will report current value from driver if not specified
  *
- * K - value for KVAL_HOLD (0 - 255) (optional)
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
+ *     optional - will report current value from driver if not specified
+ *
+ * M - value for microsteps (1 - 128) (optional)
  *     optional - will report current value from driver if not specified
  *
  */
@@ -447,83 +548,109 @@ void GcodeSuite::M918() {
 
   DEBUG_ECHOLNPGM("M918");
 
-  char axis_mon[3][3] = { "  ", "  ", "  " };  // List of axes to monitor
-  uint8_t axis_index[3];
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
   uint16_t axis_status[3];
   uint8_t driver_count = 1;
   float position_max, position_min;
-  feedRate_t final_fr_mm_m;
+  float final_feedrate;
   uint8_t kval_hold;
-  uint8_t ocd_th_val = 0;
-  uint8_t stall_th_val = 0;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
   uint16_t over_current_threshold;
-  constexpr bool over_current_flag = true;
+  constexpr uint8_t over_current_flag = true;
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
     return;  // quit if invalid user input
 
+  L64xxManager.get_status(axis_index[0]); // populate shadow array
+
   uint8_t m_steps = parser.byteval('M');
-  LIMIT(m_steps, 0, 128);
-  DEBUG_ECHOLNPAIR("M = ", m_steps);
-
-  int8_t m_bits = -1;
-       if (m_steps > 85) m_bits = 7;  // 128 (no synch output)
-  else if (m_steps > 42) m_bits = 6;  //  64 (no synch output)
-  else if (m_steps > 22) m_bits = 5;  //  32 (no synch output)
-  else if (m_steps > 12) m_bits = 4;  //  16 (no synch output)
-  else if (m_steps >  5) m_bits = 3;  //   8 (no synch output)
-  else if (m_steps >  2) m_bits = 2;  //   4 (no synch output)
-  else if (m_steps == 2) m_bits = 1;  //   2 (no synch output)
-  else if (m_steps == 1) m_bits = 0;  //   1 (no synch output)
-  else if (m_steps == 0) m_bits = 7;  // 128 (no synch output)
-
-  if (m_bits >= 0) {
-    const int micros = _BV(m_bits);
-    if (micros < 100) { DEBUG_CHAR(' '); if (micros < 10) DEBUG_CHAR(' '); }
-    DEBUG_ECHO(micros);
-    DEBUG_ECHOPGM(" uSTEPS");
+
+  if (m_steps != 0) {
+    LIMIT(m_steps, 1, sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT ? 16 : 128);  // L6474
+
+    uint8_t stepVal;
+    for (stepVal = 0; stepVal < 8; stepVal++) {  // convert to L64xx register value
+      if (m_steps == 1) break;
+      m_steps >>= 1;
+    }
+
+    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
+      stepVal |= 0x98;  // NO SYNC
+    else
+      stepVal |= (!SYNC_EN) | SYNC_SEL_1 | stepVal;
+
+    for (j = 0; j < driver_count; j++) {
+      L64xxManager.set_param(axis_index[j], dSPIN_HARD_HIZ, 0);          // can't write STEP register if stepper being powered
+                                                                         //   results in an extra NOOP being sent (data 00)
+      L64xxManager.set_param(axis_index[j], L6470_STEP_MODE, stepVal);   // set microsteps
+    }
   }
+  m_steps = L64xxManager.get_param(axis_index[0], L6470_STEP_MODE) & 0x07;   // get microsteps
 
-  for (j = 0; j < driver_count; j++)
-    L6470.set_param(axis_index[j], L6470_STEP_MODE, m_bits);   // set microsteps
+  DEBUG_ECHOLNPAIR("Microsteps = ", _BV(m_steps));
+  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ", final_feedrate);
 
-  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ", final_fr_mm_m);
+  const float feedrate_inc = final_feedrate / 10,   // Start at 1/10 of max & go up by 1/10 per step
+              fr_limit = final_feedrate * 0.99f;    // Rounding-safe comparison value
+  float current_feedrate = 0;
 
-  planner.synchronize();                  // Wait for moves to finish
+  planner.synchronize();                            // Wait for moves to complete
 
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);      // Clear all error flags
+    L64xxManager.get_status(axis_index[j]);         // Clear error flags
 
+  char temp_axis_string[2] = " ";
+  temp_axis_string[0] = axis_mon[0][0];             // Need a sprintf format string
+  //temp_axis_string[1] = '\n';
+
+  char gcode_string[80];
   uint16_t status_composite = 0;
-  DEBUG_ECHOLNPGM(".\n.\n.");             // Make the feedrate prints easier to see
+  DEBUG_ECHOLNPGM(".\n.\n.");                       // Make feedrate outputs easier to read
+
+  do {
+    current_feedrate += feedrate_inc;
+    DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
 
-  constexpr uint8_t iterations = 10;
-  for (uint8_t i = 1; i <= iterations; i++) {
-    const feedRate_t fr_mm_m = i * final_fr_mm_m / iterations;
-    DEBUG_ECHOLNPAIR("...feedrate = ", fr_mm_m);
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(current_feedrate));
+    gcode.process_subcommands_now_P(gcode_string);
 
-    jiggle_axis(axis_mon[0][0], position_min, position_max, fr_mm_m);
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(current_feedrate));
+    gcode.process_subcommands_now_P(gcode_string);
+
+    planner.synchronize();
 
     for (j = 0; j < driver_count; j++) {
-      axis_status[j] = (~L6470.get_status(axis_index[j])) & 0x0800;    // bits of interest are all active low
+      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & 0x0800;  // Bits of interest are all active LOW
       status_composite |= axis_status[j];
     }
-    if (status_composite) break;       // quit if any errors flags are raised
-  }
+    if (status_composite) break;              // Break on any error
+  } while (current_feedrate < fr_limit);
 
-  DEBUG_ECHOPGM("Completed with errors");
+  DEBUG_ECHOPGM("Completed with ");
   if (status_composite) {
     DEBUG_ECHOLNPGM("errors");
-    for (j = 0; j < driver_count; j++) {
-      DEBUG_ECHOPGM("...");
-      L6470.error_status_decode(axis_status[j], axis_index[j]);
-    }
+    #if ENABLED(L6470_CHITCHAT)
+      for (j = 0; j < driver_count; j++) {
+        if (j) DEBUG_ECHOPGM("...");
+        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      }
+    #endif
   }
   else
     DEBUG_ECHOLNPGM("no errors");
 
-} // M918
+  L64xxManager.pause_monitor(false);
+}
 
-#endif // HAS_DRIVER(L6470)
+#endif // HAS_L64XX

commit ca6d00b862049773135a9ef8d04d042f0af7f9d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 1 23:51:25 2019 -0500

    Save some string flash

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 2077e937b9..96a27f3330 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -36,11 +36,11 @@ static void jiggle_axis(const char axis_char, const float &min, const float &max
   char gcode_string[30], str1[11], str2[11];
 
   // Turn the motor(s) both directions
-  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(min, 1, 3, str1), dtostrf(rate, 1, 3, str2));
-  process_subcommands_now(gcode_string);
+  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(min, 1, 3, str1), dtostrf(fr_mm_m, 1, 3, str2));
+  gcode.process_subcommands_now(gcode_string);
 
   sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(max, 1, 3, str1), str2);
-  process_subcommands_now(gcode_string);
+  gcode.process_subcommands_now(gcode_string);
 
   planner.synchronize();
 }

commit 139b7196a0eb2cf74763c9879ff5e1e14ac935c3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 17:57:29 2019 -0500

    Watchdog cleanup (#15283)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 3b62a0f45e..2077e937b9 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -258,7 +258,7 @@ void GcodeSuite::M917() {
         }
         DEBUG_ECHOLNPGM(".");
         reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
-        watchdog_reset();   // beat the dog
+        watchdog_refresh();
         safe_delay(5000);
         status_composite_temp = 0;
         for (j = 0; j < driver_count; j++) {

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index b756c6cf88..3b62a0f45e 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -32,7 +32,7 @@
 #define DEBUG_OUT ENABLED(L6470_CHITCHAT)
 #include "../../../core/debug_out.h"
 
-static void jiggle_axis(const char axis_char, const float &min, const float &max, const float &rate) {
+static void jiggle_axis(const char axis_char, const float &min, const float &max, const feedRate_t &fr_mm_m) {
   char gcode_string[30], str1[11], str2[11];
 
   // Turn the motor(s) both directions
@@ -84,7 +84,7 @@ void GcodeSuite::M916() {
   uint8_t driver_count = 1;
   float position_max;
   float position_min;
-  float final_feedrate;
+  feedRate_t final_fr_mm_m;
   uint8_t kval_hold;
   uint8_t ocd_th_val = 0;
   uint8_t stall_th_val = 0;
@@ -93,10 +93,10 @@ void GcodeSuite::M916() {
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_fr_mm_m);
 
   planner.synchronize();                  // Wait for moves to finish
 
@@ -115,7 +115,7 @@ void GcodeSuite::M916() {
       L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
 
     // Turn the motor(s) both directions
-    jiggle_axis(axis_mon[0][0], position_min, position_max, final_feedrate);
+    jiggle_axis(axis_mon[0][0], position_min, position_max, final_fr_mm_m);
 
     status_composite = 0;    // clear out the old bits
 
@@ -190,7 +190,7 @@ void GcodeSuite::M917() {
   uint8_t driver_count = 1;
   float position_max;
   float position_min;
-  float final_feedrate;
+  feedRate_t final_fr_mm_m;
   uint8_t kval_hold;
   uint8_t ocd_th_val = 0;
   uint8_t stall_th_val = 0;
@@ -199,10 +199,10 @@ void GcodeSuite::M917() {
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_fr_mm_m);
 
   planner.synchronize();                // Wait for moves to finish
   for (j = 0; j < driver_count; j++)
@@ -225,7 +225,7 @@ void GcodeSuite::M917() {
     DEBUG_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
     DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
 
-    jiggle_axis(axis_mon[0][0], position_min, position_max, final_feedrate);
+    jiggle_axis(axis_mon[0][0], position_min, position_max, final_fr_mm_m);
 
     status_composite = 0;    // clear out the old bits
 
@@ -452,7 +452,7 @@ void GcodeSuite::M918() {
   uint16_t axis_status[3];
   uint8_t driver_count = 1;
   float position_max, position_min;
-  float final_feedrate;
+  feedRate_t final_fr_mm_m;
   uint8_t kval_hold;
   uint8_t ocd_th_val = 0;
   uint8_t stall_th_val = 0;
@@ -461,7 +461,7 @@ void GcodeSuite::M918() {
 
   uint8_t j;   // general purpose counter
 
-  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_fr_mm_m, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
     return;  // quit if invalid user input
 
   uint8_t m_steps = parser.byteval('M');
@@ -489,10 +489,7 @@ void GcodeSuite::M918() {
   for (j = 0; j < driver_count; j++)
     L6470.set_param(axis_index[j], L6470_STEP_MODE, m_bits);   // set microsteps
 
-  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ",final_feedrate);
-
-  float feedrate_inc = final_feedrate / 10, // start at 1/10 of max & go up by 1/10 per step)
-        current_feedrate = 0;
+  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ", final_fr_mm_m);
 
   planner.synchronize();                  // Wait for moves to finish
 
@@ -502,18 +499,19 @@ void GcodeSuite::M918() {
   uint16_t status_composite = 0;
   DEBUG_ECHOLNPGM(".\n.\n.");             // Make the feedrate prints easier to see
 
-  do {
-    current_feedrate += feedrate_inc;
-    DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
+  constexpr uint8_t iterations = 10;
+  for (uint8_t i = 1; i <= iterations; i++) {
+    const feedRate_t fr_mm_m = i * final_fr_mm_m / iterations;
+    DEBUG_ECHOLNPAIR("...feedrate = ", fr_mm_m);
 
-    jiggle_axis(axis_mon[0][0], position_min, position_max, current_feedrate);
+    jiggle_axis(axis_mon[0][0], position_min, position_max, fr_mm_m);
 
     for (j = 0; j < driver_count; j++) {
       axis_status[j] = (~L6470.get_status(axis_index[j])) & 0x0800;    // bits of interest are all active low
       status_composite |= axis_status[j];
     }
     if (status_composite) break;       // quit if any errors flags are raised
-  } while (current_feedrate < final_feedrate * 0.99);
+  }
 
   DEBUG_ECHOPGM("Completed with errors");
   if (status_composite) {

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 0e79d5f233..b756c6cf88 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -25,7 +25,7 @@
 #if HAS_DRIVER(L6470)
 
 #include "../../gcode.h"
-#include "../../../module/stepper_indirection.h"
+#include "../../../module/stepper/indirection.h"
 #include "../../../module/planner.h"
 #include "../../../libs/L6470/L6470_Marlin.h"
 

commit c8e30b663973be40855b46560616edd916477bb2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 8 01:51:37 2019 -0500

    Fix code attempting to sprintf %f (#14869)
    
    Arduino doesn't (always) support `float` formatting in strings. So either cast to `int` or use `dtostrf()` to fix these usages.

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 66679a2e0e..0e79d5f233 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -32,6 +32,19 @@
 #define DEBUG_OUT ENABLED(L6470_CHITCHAT)
 #include "../../../core/debug_out.h"
 
+static void jiggle_axis(const char axis_char, const float &min, const float &max, const float &rate) {
+  char gcode_string[30], str1[11], str2[11];
+
+  // Turn the motor(s) both directions
+  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(min, 1, 3, str1), dtostrf(rate, 1, 3, str2));
+  process_subcommands_now(gcode_string);
+
+  sprintf_P(gcode_string, PSTR("G0 %c%s F%s"), axis_char, dtostrf(max, 1, 3, str1), str2);
+  process_subcommands_now(gcode_string);
+
+  planner.synchronize();
+}
+
 /**
  *
  * M916: Increase KVAL_HOLD until thermal warning
@@ -85,14 +98,11 @@ void GcodeSuite::M916() {
 
   DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
-  planner.synchronize();                             // wait for all current movement commands to complete
+  planner.synchronize();                  // Wait for moves to finish
 
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);  // clear out any pre-existing error flags
+    L6470.get_status(axis_index[j]);      // Clear out error flags
 
-  char temp_axis_string[] = " ";
-  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
-  char gcode_string[80];
   uint16_t status_composite = 0;
 
   DEBUG_ECHOLNPGM(".\n.");
@@ -104,15 +114,8 @@ void GcodeSuite::M916() {
     for (j = 0; j < driver_count; j++)
       L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
 
-    // turn the motor(s) both directions
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    process_subcommands_now(gcode_string);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    process_subcommands_now(gcode_string);
-
-    // get the status after the motors have stopped
-    planner.synchronize();
+    // Turn the motor(s) both directions
+    jiggle_axis(axis_mon[0][0], position_min, position_max, final_feedrate);
 
     status_composite = 0;    // clear out the old bits
 
@@ -201,12 +204,9 @@ void GcodeSuite::M917() {
 
   DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
-  planner.synchronize();                             // wait for all current movement commands to complete
+  planner.synchronize();                // Wait for moves to finish
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);  // clear out any pre-existing error flags
-  char temp_axis_string[] = " ";
-  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
-  char gcode_string[80];
+    L6470.get_status(axis_index[j]);    // Clear out error flags
   uint16_t status_composite = 0;
   uint8_t test_phase = 0;
         // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
@@ -225,13 +225,7 @@ void GcodeSuite::M917() {
     DEBUG_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
     DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
 
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    process_subcommands_now(gcode_string);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    process_subcommands_now(gcode_string);
-
-    planner.synchronize();
+    jiggle_axis(axis_mon[0][0], position_min, position_max, final_feedrate);
 
     status_composite = 0;    // clear out the old bits
 
@@ -500,30 +494,19 @@ void GcodeSuite::M918() {
   float feedrate_inc = final_feedrate / 10, // start at 1/10 of max & go up by 1/10 per step)
         current_feedrate = 0;
 
-  planner.synchronize();                  // wait for all current movement commands to complete
+  planner.synchronize();                  // Wait for moves to finish
 
   for (j = 0; j < driver_count; j++)
-    L6470.get_status(axis_index[j]);      // clear all error flags
+    L6470.get_status(axis_index[j]);      // Clear all error flags
 
-  char temp_axis_string[2];
-  temp_axis_string[0] = axis_mon[0][0];   // need to have a string for use within sprintf format section
-  temp_axis_string[1] = '\n';
-
-  char gcode_string[80];
   uint16_t status_composite = 0;
-  DEBUG_ECHOLNPGM(".\n.\n.");            // make the feedrate prints easier to see
+  DEBUG_ECHOLNPGM(".\n.\n.");             // Make the feedrate prints easier to see
 
   do {
     current_feedrate += feedrate_inc;
     DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
 
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_min, current_feedrate);
-    process_subcommands_now(gcode_string);
-
-    sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_max, current_feedrate);
-    process_subcommands_now(gcode_string);
-
-    planner.synchronize();
+    jiggle_axis(axis_mon[0][0], position_min, position_max, current_feedrate);
 
     for (j = 0; j < driver_count; j++) {
       axis_status[j] = (~L6470.get_status(axis_index[j])) & 0x0800;    // bits of interest are all active low

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index abaf8abeec..66679a2e0e 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 17778d1c2a857f16f0d56003674e89111960c952
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 22 00:40:08 2019 -0500

    Fix M916-918 subcommands

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 6c2cd220d7..abaf8abeec 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -106,10 +106,10 @@ void GcodeSuite::M916() {
 
     // turn the motor(s) both directions
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     // get the status after the motors have stopped
     planner.synchronize();
@@ -226,10 +226,10 @@ void GcodeSuite::M917() {
     DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     planner.synchronize();
 
@@ -518,10 +518,10 @@ void GcodeSuite::M918() {
     DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_min, current_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_max, current_feedrate);
-    process_subcommands_now_P(gcode_string);
+    process_subcommands_now(gcode_string);
 
     planner.synchronize();
 

commit b14cc0d7c5d6e029ade5e96a5692d97553221142
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 26 15:29:54 2019 -0500

    Remove extra gcode. prefix

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 7744bfe0e3..6c2cd220d7 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -106,10 +106,10 @@ void GcodeSuite::M916() {
 
     // turn the motor(s) both directions
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     // get the status after the motors have stopped
     planner.synchronize();
@@ -226,10 +226,10 @@ void GcodeSuite::M917() {
     DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     planner.synchronize();
 
@@ -263,7 +263,7 @@ void GcodeSuite::M917() {
             L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
         DEBUG_ECHOLNPGM(".");
-        gcode.reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
+        reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
         watchdog_reset();   // beat the dog
         safe_delay(5000);
         status_composite_temp = 0;
@@ -518,10 +518,10 @@ void GcodeSuite::M918() {
     DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_min, current_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_max, current_feedrate);
-    gcode.process_subcommands_now_P(gcode_string);
+    process_subcommands_now_P(gcode_string);
 
     planner.synchronize();
 

commit fc52c43a26f6a56f04f4968c8fdf3e910226749e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 24 16:30:19 2019 -0500

    Some documentation updates

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 590ae8c541..7744bfe0e3 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -34,7 +34,7 @@
 
 /**
  *
- * M916: increase KVAL_HOLD until get thermal warning
+ * M916: Increase KVAL_HOLD until thermal warning
  *
  *
  * J - select which driver(s) to monitor on multi-driver axis

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 1ec60363a7..590ae8c541 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -29,6 +29,9 @@
 #include "../../../module/planner.h"
 #include "../../../libs/L6470/L6470_Marlin.h"
 
+#define DEBUG_OUT ENABLED(L6470_CHITCHAT)
+#include "../../../core/debug_out.h"
+
 /**
  *
  * M916: increase KVAL_HOLD until get thermal warning
@@ -59,7 +62,7 @@
 
 void GcodeSuite::M916() {
 
-  L6470_ECHOLNPGM("M916");
+  DEBUG_ECHOLNPGM("M916");
 
   // Variables used by L6470_get_user_input function - some may not be used
   char axis_mon[3][3] = { "  ", "  ", "  " };  // list of Axes to be monitored
@@ -80,7 +83,7 @@ void GcodeSuite::M916() {
   if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  L6470_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
   planner.synchronize();                             // wait for all current movement commands to complete
 
@@ -92,11 +95,11 @@ void GcodeSuite::M916() {
   char gcode_string[80];
   uint16_t status_composite = 0;
 
-  L6470_ECHOLNPGM(".\n.");
+  DEBUG_ECHOLNPGM(".\n.");
 
   do {
 
-    L6470_ECHOLNPAIR("kval_hold = ", kval_hold);   // set & report KVAL_HOLD for this run
+    DEBUG_ECHOLNPAIR("kval_hold = ", kval_hold);   // set & report KVAL_HOLD for this run
 
     for (j = 0; j < driver_count; j++)
       L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
@@ -119,9 +122,9 @@ void GcodeSuite::M916() {
     }
 
     if (status_composite && (status_composite & STATUS_UVLO)) {
-      L6470_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
+      DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
       for (j = 0; j < driver_count; j++) {
-        L6470_ECHOPGM("...");
+        DEBUG_ECHOPGM("...");
         L6470.error_status_decode(axis_status[j], axis_index[j]);
       }
       return;
@@ -133,18 +136,18 @@ void GcodeSuite::M916() {
 
   } while (!(status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) && kval_hold);  // exit when kval_hold == 0 (rolls over)
 
-  L6470_ECHOPGM(".\n.\nThermal warning/shutdown ");
+  DEBUG_ECHOPGM(".\n.\nThermal warning/shutdown ");
   if ((status_composite & (STATUS_TH_WRN | STATUS_TH_SD))) {
-    L6470_ECHOLNPGM("has occurred");
+    DEBUG_ECHOLNPGM("has occurred");
     for (j = 0; j < driver_count; j++) {
-      L6470_ECHOPGM("...");
+      DEBUG_ECHOPGM("...");
       L6470.error_status_decode(axis_status[j], axis_index[j]);
     }
   }
   else
-    L6470_ECHOLNPGM("(Unable to get)");
+    DEBUG_ECHOLNPGM("(Unable to get)");
 
-  L6470_ECHOLNPGM(".");
+  DEBUG_ECHOLNPGM(".");
 }
 
 /**
@@ -176,7 +179,7 @@ void GcodeSuite::M916() {
  */
 void GcodeSuite::M917() {
 
-  L6470_ECHOLNPGM("M917");
+  DEBUG_ECHOLNPGM("M917");
 
   char axis_mon[3][3] = { "  ", "  ", "  " };  // list of axes to be monitored
   uint8_t axis_index[3];
@@ -196,7 +199,7 @@ void GcodeSuite::M917() {
   if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
     return;  // quit if invalid user input
 
-  L6470_ECHOLNPAIR("feedrate = ", final_feedrate);
+  DEBUG_ECHOLNPAIR("feedrate = ", final_feedrate);
 
   planner.synchronize();                             // wait for all current movement commands to complete
   for (j = 0; j < driver_count; j++)
@@ -211,16 +214,16 @@ void GcodeSuite::M917() {
         // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
         // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
         // 4 - all testing completed
-  L6470_ECHOPAIR(".\n.\n.\nover_current threshold : ", (ocd_th_val + 1) * 375);   // first status display
-  L6470_ECHOPAIR("  (OCD_TH:  : ", ocd_th_val);
-  L6470_ECHOPAIR(")   Stall threshold: ", (stall_th_val + 1) * 31.25);
-  L6470_ECHOPAIR("  (STALL_TH: ", stall_th_val);
-  L6470_ECHOLNPGM(")");
+  DEBUG_ECHOPAIR(".\n.\n.\nover_current threshold : ", (ocd_th_val + 1) * 375);   // first status display
+  DEBUG_ECHOPAIR("  (OCD_TH:  : ", ocd_th_val);
+  DEBUG_ECHOPAIR(")   Stall threshold: ", (stall_th_val + 1) * 31.25);
+  DEBUG_ECHOPAIR("  (STALL_TH: ", stall_th_val);
+  DEBUG_ECHOLNPGM(")");
 
   do {
 
-    L6470_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
-    L6470_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
+    DEBUG_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
+    DEBUG_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
     gcode.process_subcommands_now_P(gcode_string);
@@ -238,16 +241,16 @@ void GcodeSuite::M917() {
     }
 
     if (status_composite && (status_composite & STATUS_UVLO)) {
-      L6470_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
+      DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
       for (j = 0; j < driver_count; j++) {
-        L6470_ECHOPGM("...");
+        DEBUG_ECHOPGM("...");
         L6470.error_status_decode(axis_status[j], axis_index[j]);
       }
       return;
     }
 
     if (status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) {
-      L6470_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
+      DEBUG_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
       uint16_t status_composite_temp = 0;
       uint8_t k = 0;
       do {
@@ -255,11 +258,11 @@ void GcodeSuite::M917() {
         if (!(k % 4)) {
           kval_hold *= 0.95;
           L6470_EOL();
-          L6470_ECHOLNPAIR("Lowering KVAL_HOLD by about 5% to ", kval_hold);
+          DEBUG_ECHOLNPAIR("Lowering KVAL_HOLD by about 5% to ", kval_hold);
           for (j = 0; j < driver_count; j++)
             L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
         }
-        L6470_ECHOLNPGM(".");
+        DEBUG_ECHOLNPGM(".");
         gcode.reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
         watchdog_reset();   // beat the dog
         safe_delay(5000);
@@ -281,22 +284,22 @@ void GcodeSuite::M917() {
             if (ocd_th_val >=15) {
               ocd_th_val = 15;           // limit to max
               test_phase = 2;            // at highest value so skip phase 1
-              L6470_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
+              DEBUG_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
             }
             else {
               ocd_th_val++;              // normal exit to next phase
               test_phase = 1;            // setup for first pass of phase 1
-              L6470_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
+              DEBUG_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
             }
           }
           else {  // phase 0 without OCD warning - keep on decrementing if can
             if (ocd_th_val) {
               ocd_th_val--;              // try lower value
-              L6470_ECHOLNPGM("LOGIC E0C - dec OCD");
+              DEBUG_ECHOLNPGM("LOGIC E0C - dec OCD");
             }
             else {
               test_phase = 2;            // at lowest value without warning so skip phase 1
-              L6470_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
+              DEBUG_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
             }
           }
         } break;
@@ -307,16 +310,16 @@ void GcodeSuite::M917() {
             if (ocd_th_val >= 15) {
               ocd_th_val = 15;           // limit to max
               test_phase = 2;            // at highest value so go to next phase
-              L6470_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
+              DEBUG_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
             }
             else {
               ocd_th_val++;              // try a higher value
-              L6470_ECHOLNPGM("LOGIC E1B - inc OCD");
+              DEBUG_ECHOLNPGM("LOGIC E1B - inc OCD");
             }
           }
           else { // phase 1 without OCD warning - normal exit to phase 2
             test_phase = 2;
-            L6470_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
+            DEBUG_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
           }
         } break;
 
@@ -325,25 +328,25 @@ void GcodeSuite::M917() {
             // phase 2 with stall warning - time to go to next phase
             if (stall_th_val >= 127) {
               stall_th_val = 127;  // limit to max
-              L6470_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
-              L6470_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              DEBUG_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
+              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
               test_phase = 4;
             }
             else {
               test_phase = 3;              // normal exit to next phase (found failing value of STALL)
               stall_th_val++;              // setup for first pass of phase 3
-              L6470_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
+              DEBUG_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
             }
           }
           else {  // phase 2 without stall warning - decrement if can
             if (stall_th_val) {
               stall_th_val--;              // try a lower value
-              L6470_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
+              DEBUG_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
             }
             else {
-              L6470_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
+              DEBUG_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
               test_phase = 4;
-              L6470_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
+              DEBUG_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
             }
           }
         } break;
@@ -353,19 +356,19 @@ void GcodeSuite::M917() {
             // phase 3 with stall warning - increment if can
             if (stall_th_val >= 127) {
               stall_th_val = 127; // limit to max
-              L6470_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
               test_phase = 4;
-              L6470_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
+              DEBUG_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
             }
             else {
               stall_th_val++;              // still looking for passing value
-              L6470_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
+              DEBUG_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
             }
           }
           else {  //phase 3 without stall warning  but have OCD warning
-            L6470_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
+            DEBUG_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
             test_phase = 4;
-            L6470_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
+            DEBUG_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
           }
         } break;
 
@@ -377,30 +380,30 @@ void GcodeSuite::M917() {
         case 0: { // phase 0 without OCD warning - keep on decrementing if can
           if (ocd_th_val) {
             ocd_th_val--;             // try lower value
-            L6470_ECHOLNPGM("LOGIC N0A - DEC OCD");
+            DEBUG_ECHOLNPGM("LOGIC N0A - DEC OCD");
           }
           else {
             test_phase = 2;           // at lowest value without warning so skip phase 1
-            L6470_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
+            DEBUG_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
           }
         } break;
 
-        case 1: L6470_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
+        case 1: DEBUG_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
 
         case 2: { // phase 2 without stall warning - keep on decrementing if can
           if (stall_th_val) {
             stall_th_val--;              // try a lower value (stay in phase 2)
-            L6470_ECHOLNPGM("LOGIC N2B - dec STALL");
+            DEBUG_ECHOLNPGM("LOGIC N2B - dec STALL");
           }
           else {
-            L6470_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
+            DEBUG_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
             test_phase = 4;
-            L6470_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
+            DEBUG_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
           }
         } break;
 
         case 3: { test_phase = 4;
-           L6470_ECHOLNPGM("LOGIC N3 - finished!");
+           DEBUG_ECHOLNPGM("LOGIC N3 - finished!");
         } break;  // phase 3 without any warnings - desired exit
       }  //
     }  // end of status checks
@@ -409,22 +412,22 @@ void GcodeSuite::M917() {
       for (j = 0; j < driver_count; j++) {                       // update threshold(s)
         L6470.set_param(axis_index[j], L6470_OCD_TH, ocd_th_val);
         L6470.set_param(axis_index[j], L6470_STALL_TH, stall_th_val);
-        if (L6470.get_param(axis_index[j], L6470_OCD_TH) != ocd_th_val) L6470_ECHOLNPGM("OCD mismatch");
-        if (L6470.get_param(axis_index[j], L6470_STALL_TH) != stall_th_val) L6470_ECHOLNPGM("STALL mismatch");
+        if (L6470.get_param(axis_index[j], L6470_OCD_TH) != ocd_th_val) DEBUG_ECHOLNPGM("OCD mismatch");
+        if (L6470.get_param(axis_index[j], L6470_STALL_TH) != stall_th_val) DEBUG_ECHOLNPGM("STALL mismatch");
       }
     }
 
   } while (test_phase != 4);
 
   if (status_composite) {
-    L6470_ECHOLNPGM("Completed with errors");
+    DEBUG_ECHOLNPGM("Completed with errors");
     for (j = 0; j < driver_count; j++) {
-      L6470_ECHOPGM("...");
+      DEBUG_ECHOPGM("...");
       L6470.error_status_decode(axis_status[j], axis_index[j]);
     }
   }
   else
-    L6470_ECHOLNPGM("Completed with no errors");
+    DEBUG_ECHOLNPGM("Completed with no errors");
 
 } // M917
 
@@ -448,7 +451,7 @@ void GcodeSuite::M917() {
  */
 void GcodeSuite::M918() {
 
-  L6470_ECHOLNPGM("M918");
+  DEBUG_ECHOLNPGM("M918");
 
   char axis_mon[3][3] = { "  ", "  ", "  " };  // List of axes to monitor
   uint8_t axis_index[3];
@@ -469,7 +472,7 @@ void GcodeSuite::M918() {
 
   uint8_t m_steps = parser.byteval('M');
   LIMIT(m_steps, 0, 128);
-  L6470_ECHOLNPAIR("M = ", m_steps);
+  DEBUG_ECHOLNPAIR("M = ", m_steps);
 
   int8_t m_bits = -1;
        if (m_steps > 85) m_bits = 7;  // 128 (no synch output)
@@ -484,15 +487,15 @@ void GcodeSuite::M918() {
 
   if (m_bits >= 0) {
     const int micros = _BV(m_bits);
-    if (micros < 100) { L6470_CHAR(' '); if (micros < 10) L6470_CHAR(' '); }
-    L6470_ECHO(micros);
-    L6470_ECHOPGM(" uSTEPS");
+    if (micros < 100) { DEBUG_CHAR(' '); if (micros < 10) DEBUG_CHAR(' '); }
+    DEBUG_ECHO(micros);
+    DEBUG_ECHOPGM(" uSTEPS");
   }
 
   for (j = 0; j < driver_count; j++)
     L6470.set_param(axis_index[j], L6470_STEP_MODE, m_bits);   // set microsteps
 
-  L6470_ECHOLNPAIR("target (maximum) feedrate = ",final_feedrate);
+  DEBUG_ECHOLNPAIR("target (maximum) feedrate = ",final_feedrate);
 
   float feedrate_inc = final_feedrate / 10, // start at 1/10 of max & go up by 1/10 per step)
         current_feedrate = 0;
@@ -508,11 +511,11 @@ void GcodeSuite::M918() {
 
   char gcode_string[80];
   uint16_t status_composite = 0;
-  L6470_ECHOLNPGM(".\n.\n.");            // make the feedrate prints easier to see
+  DEBUG_ECHOLNPGM(".\n.\n.");            // make the feedrate prints easier to see
 
   do {
     current_feedrate += feedrate_inc;
-    L6470_ECHOLNPAIR("...feedrate = ", current_feedrate);
+    DEBUG_ECHOLNPAIR("...feedrate = ", current_feedrate);
 
     sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_min, current_feedrate);
     gcode.process_subcommands_now_P(gcode_string);
@@ -529,15 +532,16 @@ void GcodeSuite::M918() {
     if (status_composite) break;       // quit if any errors flags are raised
   } while (current_feedrate < final_feedrate * 0.99);
 
+  DEBUG_ECHOPGM("Completed with errors");
   if (status_composite) {
-    L6470_ECHOLNPGM("Completed with errors");
+    DEBUG_ECHOLNPGM("errors");
     for (j = 0; j < driver_count; j++) {
-      L6470_ECHOPGM("...");
+      DEBUG_ECHOPGM("...");
       L6470.error_status_decode(axis_status[j], axis_index[j]);
     }
   }
   else
-    L6470_ECHOLNPGM("Completed with no errors");
+    DEBUG_ECHOLNPGM("no errors");
 
 } // M918
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
index 32b0add303..1ec60363a7 100644
--- a/Marlin/src/gcode/feature/L6470/M916-918.cpp
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2018 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 2f35747f294c4b3dc3e6920b34e208f89bd4841d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jan 23 19:06:54 2019 -0600

    L6470 SPI daisy chain support (#12895)

diff --git a/Marlin/src/gcode/feature/L6470/M916-918.cpp b/Marlin/src/gcode/feature/L6470/M916-918.cpp
new file mode 100644
index 0000000000..32b0add303
--- /dev/null
+++ b/Marlin/src/gcode/feature/L6470/M916-918.cpp
@@ -0,0 +1,544 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2018 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if HAS_DRIVER(L6470)
+
+#include "../../gcode.h"
+#include "../../../module/stepper_indirection.h"
+#include "../../../module/planner.h"
+#include "../../../libs/L6470/L6470_Marlin.h"
+
+/**
+ *
+ * M916: increase KVAL_HOLD until get thermal warning
+ *
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ *     3 - monitor only Z3, E3
+ *
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * F - feedrate
+ *     optional - will use default max feedrate from configuration.h if not specified
+ *
+ * K - starting value for KVAL_HOLD (0 - 255)
+ *     optional - will use & report current value from driver if not specified
+ *
+ */
+
+/**
+ * This routine is also useful for determining the approximate KVAL_HOLD
+ * where the stepper stops losing steps. The sound will get noticeably quieter
+ * as it stops losing steps.
+ */
+
+void GcodeSuite::M916() {
+
+  L6470_ECHOLNPGM("M916");
+
+  // Variables used by L6470_get_user_input function - some may not be used
+  char axis_mon[3][3] = { "  ", "  ", "  " };  // list of Axes to be monitored
+  uint8_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max;
+  float position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t ocd_th_val = 0;
+  uint8_t stall_th_val = 0;
+  uint16_t over_current_threshold;
+  constexpr bool over_current_flag = false;  // M916 doesn't play with the overcurrent thresholds
+
+  uint8_t j;   // general purpose counter
+
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  L6470_ECHOLNPAIR("feedrate = ", final_feedrate);
+
+  planner.synchronize();                             // wait for all current movement commands to complete
+
+  for (j = 0; j < driver_count; j++)
+    L6470.get_status(axis_index[j]);  // clear out any pre-existing error flags
+
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+
+  L6470_ECHOLNPGM(".\n.");
+
+  do {
+
+    L6470_ECHOLNPAIR("kval_hold = ", kval_hold);   // set & report KVAL_HOLD for this run
+
+    for (j = 0; j < driver_count; j++)
+      L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
+
+    // turn the motor(s) both directions
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    // get the status after the motors have stopped
+    planner.synchronize();
+
+    status_composite = 0;    // clear out the old bits
+
+    for (j = 0; j < driver_count; j++) {
+      axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
+      status_composite |= axis_status[j] ;
+    }
+
+    if (status_composite && (status_composite & STATUS_UVLO)) {
+      L6470_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
+      for (j = 0; j < driver_count; j++) {
+        L6470_ECHOPGM("...");
+        L6470.error_status_decode(axis_status[j], axis_index[j]);
+      }
+      return;
+    }
+
+    // increment KVAL_HOLD if not yet at thermal warning/shutdown
+    if (!(status_composite & (STATUS_TH_WRN | STATUS_TH_SD)))
+      kval_hold++;
+
+  } while (!(status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) && kval_hold);  // exit when kval_hold == 0 (rolls over)
+
+  L6470_ECHOPGM(".\n.\nThermal warning/shutdown ");
+  if ((status_composite & (STATUS_TH_WRN | STATUS_TH_SD))) {
+    L6470_ECHOLNPGM("has occurred");
+    for (j = 0; j < driver_count; j++) {
+      L6470_ECHOPGM("...");
+      L6470.error_status_decode(axis_status[j], axis_index[j]);
+    }
+  }
+  else
+    L6470_ECHOLNPGM("(Unable to get)");
+
+  L6470_ECHOLNPGM(".");
+}
+
+/**
+ *
+ * M917: Find minimum current thresholds
+ *
+ *   Decrease OCD current until overcurrent error
+ *   Increase OCD until overcurrent error goes away
+ *   Decrease stall threshold until stall
+ *   Increase stall until stall error goes away
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * F - feedrate
+ *     optional - will use default max feedrate from Configuration.h if not specified
+ *
+ * I - starting over-current threshold
+ *     optional - will report current value from driver if not specified
+ *     if there are multiple drivers on the axis then all will be set the same
+ *
+ * K - value for KVAL_HOLD (0 - 255)
+ *     optional - will report current value from driver if not specified
+ *
+ */
+void GcodeSuite::M917() {
+
+  L6470_ECHOLNPGM("M917");
+
+  char axis_mon[3][3] = { "  ", "  ", "  " };  // list of axes to be monitored
+  uint8_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max;
+  float position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t ocd_th_val = 0;
+  uint8_t stall_th_val = 0;
+  uint16_t over_current_threshold;
+  constexpr bool over_current_flag = true;
+
+  uint8_t j;   // general purpose counter
+
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  L6470_ECHOLNPAIR("feedrate = ", final_feedrate);
+
+  planner.synchronize();                             // wait for all current movement commands to complete
+  for (j = 0; j < driver_count; j++)
+    L6470.get_status(axis_index[j]);  // clear out any pre-existing error flags
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+  uint8_t test_phase = 0;
+        // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
+        // 1 - increasing OCD - exit when OCD warning stops (ignore STALL) -
+        // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
+        // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
+        // 4 - all testing completed
+  L6470_ECHOPAIR(".\n.\n.\nover_current threshold : ", (ocd_th_val + 1) * 375);   // first status display
+  L6470_ECHOPAIR("  (OCD_TH:  : ", ocd_th_val);
+  L6470_ECHOPAIR(")   Stall threshold: ", (stall_th_val + 1) * 31.25);
+  L6470_ECHOPAIR("  (STALL_TH: ", stall_th_val);
+  L6470_ECHOLNPGM(")");
+
+  do {
+
+    L6470_ECHOPAIR("STALL threshold : ", (stall_th_val + 1) * 31.25);
+    L6470_ECHOLNPAIR("   OCD threshold : ", (ocd_th_val + 1) * 375);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_min, final_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f  F%4.3f"), temp_axis_string, position_max, final_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    planner.synchronize();
+
+    status_composite = 0;    // clear out the old bits
+
+    for (j = 0; j < driver_count; j++) {
+      axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
+      status_composite |= axis_status[j];
+    }
+
+    if (status_composite && (status_composite & STATUS_UVLO)) {
+      L6470_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
+      for (j = 0; j < driver_count; j++) {
+        L6470_ECHOPGM("...");
+        L6470.error_status_decode(axis_status[j], axis_index[j]);
+      }
+      return;
+    }
+
+    if (status_composite & (STATUS_TH_WRN | STATUS_TH_SD)) {
+      L6470_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
+      uint16_t status_composite_temp = 0;
+      uint8_t k = 0;
+      do {
+        k++;
+        if (!(k % 4)) {
+          kval_hold *= 0.95;
+          L6470_EOL();
+          L6470_ECHOLNPAIR("Lowering KVAL_HOLD by about 5% to ", kval_hold);
+          for (j = 0; j < driver_count; j++)
+            L6470.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
+        }
+        L6470_ECHOLNPGM(".");
+        gcode.reset_stepper_timeout(); // reset_stepper_timeout to keep steppers powered
+        watchdog_reset();   // beat the dog
+        safe_delay(5000);
+        status_composite_temp = 0;
+        for (j = 0; j < driver_count; j++) {
+          axis_status[j] = (~L6470.get_status(axis_index[j])) & L6470_ERROR_MASK;    // bits of interest are all active low
+          status_composite_temp |= axis_status[j];
+        }
+      }
+      while (status_composite_temp & (STATUS_TH_WRN | STATUS_TH_SD));
+      L6470_EOL();
+    }
+    if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B | STATUS_OCD)) {
+      switch (test_phase) {
+
+        case 0: {
+          if (status_composite & STATUS_OCD) {
+            // phase 0 with OCD warning - time to go to next phase
+            if (ocd_th_val >=15) {
+              ocd_th_val = 15;           // limit to max
+              test_phase = 2;            // at highest value so skip phase 1
+              L6470_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
+            }
+            else {
+              ocd_th_val++;              // normal exit to next phase
+              test_phase = 1;            // setup for first pass of phase 1
+              L6470_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
+            }
+          }
+          else {  // phase 0 without OCD warning - keep on decrementing if can
+            if (ocd_th_val) {
+              ocd_th_val--;              // try lower value
+              L6470_ECHOLNPGM("LOGIC E0C - dec OCD");
+            }
+            else {
+              test_phase = 2;            // at lowest value without warning so skip phase 1
+              L6470_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
+            }
+          }
+        } break;
+
+        case 1: {
+          if (status_composite & STATUS_OCD) {
+            // phase 1 with OCD warning - increment if can
+            if (ocd_th_val >= 15) {
+              ocd_th_val = 15;           // limit to max
+              test_phase = 2;            // at highest value so go to next phase
+              L6470_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
+            }
+            else {
+              ocd_th_val++;              // try a higher value
+              L6470_ECHOLNPGM("LOGIC E1B - inc OCD");
+            }
+          }
+          else { // phase 1 without OCD warning - normal exit to phase 2
+            test_phase = 2;
+            L6470_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
+          }
+        } break;
+
+        case 2: {
+          if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B)) {
+            // phase 2 with stall warning - time to go to next phase
+            if (stall_th_val >= 127) {
+              stall_th_val = 127;  // limit to max
+              L6470_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
+              L6470_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              test_phase = 4;
+            }
+            else {
+              test_phase = 3;              // normal exit to next phase (found failing value of STALL)
+              stall_th_val++;              // setup for first pass of phase 3
+              L6470_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
+            }
+          }
+          else {  // phase 2 without stall warning - decrement if can
+            if (stall_th_val) {
+              stall_th_val--;              // try a lower value
+              L6470_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
+            }
+            else {
+              L6470_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
+              test_phase = 4;
+              L6470_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
+            }
+          }
+        } break;
+
+        case 3: {
+          if (status_composite & (STATUS_STEP_LOSS_A | STATUS_STEP_LOSS_B)) {
+            // phase 3 with stall warning - increment if can
+            if (stall_th_val >= 127) {
+              stall_th_val = 127; // limit to max
+              L6470_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              test_phase = 4;
+              L6470_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
+            }
+            else {
+              stall_th_val++;              // still looking for passing value
+              L6470_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
+            }
+          }
+          else {  //phase 3 without stall warning  but have OCD warning
+            L6470_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
+            test_phase = 4;
+            L6470_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
+          }
+        } break;
+
+      }
+
+    }
+    else {
+      switch (test_phase) {
+        case 0: { // phase 0 without OCD warning - keep on decrementing if can
+          if (ocd_th_val) {
+            ocd_th_val--;             // try lower value
+            L6470_ECHOLNPGM("LOGIC N0A - DEC OCD");
+          }
+          else {
+            test_phase = 2;           // at lowest value without warning so skip phase 1
+            L6470_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
+          }
+        } break;
+
+        case 1: L6470_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
+
+        case 2: { // phase 2 without stall warning - keep on decrementing if can
+          if (stall_th_val) {
+            stall_th_val--;              // try a lower value (stay in phase 2)
+            L6470_ECHOLNPGM("LOGIC N2B - dec STALL");
+          }
+          else {
+            L6470_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
+            test_phase = 4;
+            L6470_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
+          }
+        } break;
+
+        case 3: { test_phase = 4;
+           L6470_ECHOLNPGM("LOGIC N3 - finished!");
+        } break;  // phase 3 without any warnings - desired exit
+      }  //
+    }  // end of status checks
+
+    if (test_phase != 4) {
+      for (j = 0; j < driver_count; j++) {                       // update threshold(s)
+        L6470.set_param(axis_index[j], L6470_OCD_TH, ocd_th_val);
+        L6470.set_param(axis_index[j], L6470_STALL_TH, stall_th_val);
+        if (L6470.get_param(axis_index[j], L6470_OCD_TH) != ocd_th_val) L6470_ECHOLNPGM("OCD mismatch");
+        if (L6470.get_param(axis_index[j], L6470_STALL_TH) != stall_th_val) L6470_ECHOLNPGM("STALL mismatch");
+      }
+    }
+
+  } while (test_phase != 4);
+
+  if (status_composite) {
+    L6470_ECHOLNPGM("Completed with errors");
+    for (j = 0; j < driver_count; j++) {
+      L6470_ECHOPGM("...");
+      L6470.error_status_decode(axis_status[j], axis_index[j]);
+    }
+  }
+  else
+    L6470_ECHOLNPGM("Completed with no errors");
+
+} // M917
+
+/**
+ *
+ * M918: increase speed until error or max feedrate achieved (as shown in configuration.h))
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * I - over current threshold
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (optional)
+ *     optional - will report current value from driver if not specified
+ *
+ */
+void GcodeSuite::M918() {
+
+  L6470_ECHOLNPGM("M918");
+
+  char axis_mon[3][3] = { "  ", "  ", "  " };  // List of axes to monitor
+  uint8_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max, position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t ocd_th_val = 0;
+  uint8_t stall_th_val = 0;
+  uint16_t over_current_threshold;
+  constexpr bool over_current_flag = true;
+
+  uint8_t j;   // general purpose counter
+
+  if (L6470.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, ocd_th_val, stall_th_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  uint8_t m_steps = parser.byteval('M');
+  LIMIT(m_steps, 0, 128);
+  L6470_ECHOLNPAIR("M = ", m_steps);
+
+  int8_t m_bits = -1;
+       if (m_steps > 85) m_bits = 7;  // 128 (no synch output)
+  else if (m_steps > 42) m_bits = 6;  //  64 (no synch output)
+  else if (m_steps > 22) m_bits = 5;  //  32 (no synch output)
+  else if (m_steps > 12) m_bits = 4;  //  16 (no synch output)
+  else if (m_steps >  5) m_bits = 3;  //   8 (no synch output)
+  else if (m_steps >  2) m_bits = 2;  //   4 (no synch output)
+  else if (m_steps == 2) m_bits = 1;  //   2 (no synch output)
+  else if (m_steps == 1) m_bits = 0;  //   1 (no synch output)
+  else if (m_steps == 0) m_bits = 7;  // 128 (no synch output)
+
+  if (m_bits >= 0) {
+    const int micros = _BV(m_bits);
+    if (micros < 100) { L6470_CHAR(' '); if (micros < 10) L6470_CHAR(' '); }
+    L6470_ECHO(micros);
+    L6470_ECHOPGM(" uSTEPS");
+  }
+
+  for (j = 0; j < driver_count; j++)
+    L6470.set_param(axis_index[j], L6470_STEP_MODE, m_bits);   // set microsteps
+
+  L6470_ECHOLNPAIR("target (maximum) feedrate = ",final_feedrate);
+
+  float feedrate_inc = final_feedrate / 10, // start at 1/10 of max & go up by 1/10 per step)
+        current_feedrate = 0;
+
+  planner.synchronize();                  // wait for all current movement commands to complete
+
+  for (j = 0; j < driver_count; j++)
+    L6470.get_status(axis_index[j]);      // clear all error flags
+
+  char temp_axis_string[2];
+  temp_axis_string[0] = axis_mon[0][0];   // need to have a string for use within sprintf format section
+  temp_axis_string[1] = '\n';
+
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+  L6470_ECHOLNPGM(".\n.\n.");            // make the feedrate prints easier to see
+
+  do {
+    current_feedrate += feedrate_inc;
+    L6470_ECHOLNPAIR("...feedrate = ", current_feedrate);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_min, current_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%4.3f F%4.3f"), temp_axis_string, position_max, current_feedrate);
+    gcode.process_subcommands_now_P(gcode_string);
+
+    planner.synchronize();
+
+    for (j = 0; j < driver_count; j++) {
+      axis_status[j] = (~L6470.get_status(axis_index[j])) & 0x0800;    // bits of interest are all active low
+      status_composite |= axis_status[j];
+    }
+    if (status_composite) break;       // quit if any errors flags are raised
+  } while (current_feedrate < final_feedrate * 0.99);
+
+  if (status_composite) {
+    L6470_ECHOLNPGM("Completed with errors");
+    for (j = 0; j < driver_count; j++) {
+      L6470_ECHOPGM("...");
+      L6470.error_status_decode(axis_status[j], axis_index[j]);
+    }
+  }
+  else
+    L6470_ECHOLNPGM("Completed with no errors");
+
+} // M918
+
+#endif // HAS_DRIVER(L6470)
