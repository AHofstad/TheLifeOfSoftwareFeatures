commit cb291e8d00a6c1ee0a778625e0170b6b7430a004
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 22:41:00 2024 -0600

    ü©π Fix some temp constraints

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 037eafcc94..1212f715c0 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -31,7 +31,9 @@
 
 #include "../ui_api.h"
 #include "../../../module/stepper.h"
+#include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../../feature/pause.h"
 #endif
@@ -266,15 +268,19 @@ void DGUSTxHandler::tempMax(DGUS_VP &vp) {
 
   switch (vp.addr) {
     default: return;
-    case DGUS_Addr::TEMP_Max_Bed:
-      temp = BED_MAX_TARGET;
-      break;
-    case DGUS_Addr::TEMP_Max_H0:
-      temp = HEATER_0_MAXTEMP - HOTEND_OVERSHOOT;
-      break;
+    #if HAS_HEATED_BED
+      case DGUS_Addr::TEMP_Max_Bed:
+        temp = BED_MAX_TARGET;
+        break;
+    #endif
+    #if HAS_HOTEND
+      case DGUS_Addr::TEMP_Max_H0:
+        temp = thermalManager.hotend_max_target(0);
+        break;
+    #endif
     #if HAS_MULTI_HOTEND
       case DGUS_Addr::TEMP_Max_H1:
-        temp = HEATER_1_MAXTEMP - HOTEND_OVERSHOOT;
+        temp = thermalManager.hotend_max_target(1);
         break;
     #endif
   }

commit bc385122e94d7eda79bdf1573a7c2071c4589da2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 13:34:13 2023 -0500

    üé® Lowercase method / data member names (#25914)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index c7d650c03e..037eafcc94 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -37,7 +37,7 @@
 #endif
 
 #if HAS_MEDIA
-  void DGUSTxHandler::SetFileControlState(int16_t file, bool state) {
+  void DGUSTxHandler::setFileControlState(int16_t file, bool state) {
     DGUS_Control control;
 
     switch (file) {
@@ -60,40 +60,40 @@
     }
 
     if (state) {
-      dgus_display.EnableControl(DGUS_Screen::PRINT,
+      dgus.enableControl(DGUS_ScreenID::PRINT,
                                  DGUSDisplay::RETURN_KEY_CODE,
                                  control);
     }
     else {
-      dgus_display.DisableControl(DGUS_Screen::PRINT,
+      dgus.disableControl(DGUS_ScreenID::PRINT,
                                   DGUSDisplay::RETURN_KEY_CODE,
                                   control);
     }
   }
 
-  void DGUSTxHandler::FileType(DGUS_VP &vp) {
+  void DGUSTxHandler::fileType(DGUS_VP &vp) {
     // Batch send
     uint16_t data[DGUS_FILE_COUNT];
 
     for (int16_t i = 0; i < DGUS_FILE_COUNT; i++) {
-      if (!dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_offset + i)) {
+      if (!screen.filelist.seek(screen.filelist_offset + i)) {
         data[i] = Swap16(DGUS_Data::SDType::NONE);
 
-        SetFileControlState(i, false);
+        setFileControlState(i, false);
         continue;
       }
 
-      data[i] = dgus_screen_handler.filelist.isDir() ?
+      data[i] = screen.filelist.isDir() ?
                   Swap16(DGUS_Data::SDType::DIRECTORY)
                 : Swap16(DGUS_Data::SDType::FILE);
 
-      SetFileControlState(i, true);
+      setFileControlState(i, true);
     }
 
-    dgus_display.Write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_FILE_COUNT);
+    dgus.write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_FILE_COUNT);
   }
 
-  void DGUSTxHandler::FileName(DGUS_VP &vp) {
+  void DGUSTxHandler::fileName(DGUS_VP &vp) {
     uint8_t offset;
 
     switch (vp.addr) {
@@ -115,84 +115,84 @@
         break;
     }
 
-    if (dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_offset + offset)) {
-      dgus_display.WriteString((uint16_t)vp.addr, dgus_screen_handler.filelist.filename(), vp.size);
+    if (screen.filelist.seek(screen.filelist_offset + offset)) {
+      dgus.writeString((uint16_t)vp.addr, screen.filelist.filename(), vp.size);
     }
     else {
-      dgus_display.WriteStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
+      dgus.writeStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
     }
   }
 
-  void DGUSTxHandler::ScrollIcons(DGUS_VP &vp) {
+  void DGUSTxHandler::scrollIcons(DGUS_VP &vp) {
     uint16_t icons = 0;
 
-    if (!dgus_screen_handler.filelist.isAtRootDir()) {
+    if (!screen.filelist.isAtRootDir()) {
       icons |= (uint16_t)DGUS_Data::ScrollIcon::GO_BACK;
 
-      dgus_display.EnableControl(DGUS_Screen::PRINT,
+      dgus.enableControl(DGUS_ScreenID::PRINT,
                                  DGUSDisplay::RETURN_KEY_CODE,
                                  DGUS_Control::GO_BACK);
     }
     else {
-      dgus_display.DisableControl(DGUS_Screen::PRINT,
+      dgus.disableControl(DGUS_ScreenID::PRINT,
                                   DGUSDisplay::RETURN_KEY_CODE,
                                   DGUS_Control::GO_BACK);
     }
 
-    if (dgus_screen_handler.filelist_offset > 0) {
+    if (screen.filelist_offset > 0) {
       icons |= (uint16_t)DGUS_Data::ScrollIcon::UP;
 
-      dgus_display.EnableControl(DGUS_Screen::PRINT,
+      dgus.enableControl(DGUS_ScreenID::PRINT,
                                  DGUSDisplay::RETURN_KEY_CODE,
                                  DGUS_Control::SCROLL_UP);
     }
     else {
-      dgus_display.DisableControl(DGUS_Screen::PRINT,
+      dgus.disableControl(DGUS_ScreenID::PRINT,
                                   DGUSDisplay::RETURN_KEY_CODE,
                                   DGUS_Control::SCROLL_UP);
     }
 
-    if (dgus_screen_handler.filelist_offset + DGUS_FILE_COUNT < dgus_screen_handler.filelist.count()) {
+    if (screen.filelist_offset + DGUS_FILE_COUNT < screen.filelist.count()) {
       icons |= (uint16_t)DGUS_Data::ScrollIcon::DOWN;
 
-      dgus_display.EnableControl(DGUS_Screen::PRINT,
+      dgus.enableControl(DGUS_ScreenID::PRINT,
                                  DGUSDisplay::RETURN_KEY_CODE,
                                  DGUS_Control::SCROLL_DOWN);
     }
     else {
-      dgus_display.DisableControl(DGUS_Screen::PRINT,
+      dgus.disableControl(DGUS_ScreenID::PRINT,
                                   DGUSDisplay::RETURN_KEY_CODE,
                                   DGUS_Control::SCROLL_DOWN);
     }
 
-    dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+    dgus.write((uint16_t)vp.addr, Swap16(icons));
   }
 
-  void DGUSTxHandler::SelectedFileName(DGUS_VP &vp) {
-    if (dgus_screen_handler.filelist_selected < 0
-        || !dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_selected)) {
-      dgus_display.WriteStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
+  void DGUSTxHandler::selectedFileName(DGUS_VP &vp) {
+    if (screen.filelist_selected < 0
+        || !screen.filelist.seek(screen.filelist_selected)) {
+      dgus.writeStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
       return;
     }
 
-    dgus_display.WriteString((uint16_t)vp.addr, dgus_screen_handler.filelist.filename(), vp.size);
+    dgus.writeString((uint16_t)vp.addr, screen.filelist.filename(), vp.size);
   }
 #endif // HAS_MEDIA
 
-void DGUSTxHandler::PositionZ(DGUS_VP &vp) {
+void DGUSTxHandler::zPosition(DGUS_VP &vp) {
   const float position = ExtUI::isAxisPositionKnown(ExtUI::Z) ? planner.get_axis_position_mm(Z_AXIS) : 0;
-  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(int32_t(position * 50.0f) / 50.0f); // Round to 0.02
-  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+  const int32_t data = dgus.toFixedPoint<float, int32_t, 2>(int32_t(position * 50.0f) / 50.0f); // Round to 0.02
+  dgus.write((uint16_t)vp.addr, dgus.swapBytes(data));
 }
 
-void DGUSTxHandler::Elapsed(DGUS_VP &vp) {
+void DGUSTxHandler::elapsed(DGUS_VP &vp) {
   char buffer[21];
   duration_t(print_job_timer.duration()).toString(buffer);
 
-  dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+  dgus.writeString((uint16_t)vp.addr, buffer, vp.size);
 }
 
-void DGUSTxHandler::Percent(DGUS_VP &vp) {
+void DGUSTxHandler::percent(DGUS_VP &vp) {
   uint16_t progress;
 
   switch (vp.addr) {
@@ -205,21 +205,21 @@ void DGUSTxHandler::Percent(DGUS_VP &vp) {
       break;
   }
 
-  dgus_display.Write((uint16_t)DGUS_Addr::STATUS_Percent, Swap16(progress));
+  dgus.write((uint16_t)DGUS_Addr::STATUS_Percent, Swap16(progress));
 }
 
-void DGUSTxHandler::StatusIcons(DGUS_VP &vp) {
+void DGUSTxHandler::statusIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
   if (ExtUI::isPrinting()) {
     icons |= (uint16_t)DGUS_Data::StatusIcon::PAUSE;
 
-    dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
+    dgus.enableControl(DGUS_ScreenID::PRINT_STATUS,
                                DGUSDisplay::POPUP_WINDOW,
                                DGUS_Control::PAUSE);
   }
   else {
-    dgus_display.DisableControl(DGUS_Screen::PRINT_STATUS,
+    dgus.disableControl(DGUS_ScreenID::PRINT_STATUS,
                                 DGUSDisplay::POPUP_WINDOW,
                                 DGUS_Control::PAUSE);
   }
@@ -227,20 +227,20 @@ void DGUSTxHandler::StatusIcons(DGUS_VP &vp) {
   if (ExtUI::isPrintingPaused()) {
     icons |= (uint16_t)DGUS_Data::StatusIcon::RESUME;
 
-    dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
+    dgus.enableControl(DGUS_ScreenID::PRINT_STATUS,
                                DGUSDisplay::POPUP_WINDOW,
                                DGUS_Control::RESUME);
   }
   else {
-    dgus_display.DisableControl(DGUS_Screen::PRINT_STATUS,
+    dgus.disableControl(DGUS_ScreenID::PRINT_STATUS,
                                 DGUSDisplay::POPUP_WINDOW,
                                 DGUS_Control::RESUME);
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  dgus.write((uint16_t)vp.addr, Swap16(icons));
 }
 
-void DGUSTxHandler::Flowrate(DGUS_VP &vp) {
+void DGUSTxHandler::flowrate(DGUS_VP &vp) {
   int16_t flowrate;
 
   switch (vp.addr) {
@@ -258,10 +258,10 @@ void DGUSTxHandler::Flowrate(DGUS_VP &vp) {
     #endif
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(flowrate));
+  dgus.write((uint16_t)vp.addr, Swap16(flowrate));
 }
 
-void DGUSTxHandler::TempMax(DGUS_VP &vp) {
+void DGUSTxHandler::tempMax(DGUS_VP &vp) {
   uint16_t temp;
 
   switch (vp.addr) {
@@ -279,15 +279,15 @@ void DGUSTxHandler::TempMax(DGUS_VP &vp) {
     #endif
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(temp));
+  dgus.write((uint16_t)vp.addr, Swap16(temp));
 }
 
-void DGUSTxHandler::StepperStatus(DGUS_VP &vp) {
+void DGUSTxHandler::stepperStatus(DGUS_VP &vp) {
   const bool motor_on = stepper.axis_enabled.bits & (_BV(NUM_AXES) - 1);
-  dgus_display.Write((uint16_t)vp.addr, Swap16(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED));
+  dgus.write((uint16_t)vp.addr, Swap16(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED));
 }
 
-void DGUSTxHandler::StepIcons(DGUS_VP &vp) {
+void DGUSTxHandler::stepIcons(DGUS_VP &vp) {
   if (!vp.extra) return;
   uint16_t icons = 0;
   DGUS_Data::StepSize size = *(DGUS_Data::StepSize*)vp.extra;
@@ -307,31 +307,31 @@ void DGUSTxHandler::StepIcons(DGUS_VP &vp) {
       break;
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  dgus.write((uint16_t)vp.addr, Swap16(icons));
 }
 
-void DGUSTxHandler::ABLDisableIcon(DGUS_VP &vp) {
+void DGUSTxHandler::ablDisableIcon(DGUS_VP &vp) {
   uint16_t data;
 
   if (ExtUI::getLevelingActive()) {
     data = (uint16_t)DGUS_Data::Status::ENABLED;
 
-    dgus_display.EnableControl(DGUS_Screen::LEVELING_AUTOMATIC,
+    dgus.enableControl(DGUS_ScreenID::LEVELING_AUTOMATIC,
                                DGUSDisplay::RETURN_KEY_CODE,
                                DGUS_Control::DISABLE);
   }
   else {
     data = (uint16_t)DGUS_Data::Status::DISABLED;
 
-    dgus_display.DisableControl(DGUS_Screen::LEVELING_AUTOMATIC,
+    dgus.disableControl(DGUS_ScreenID::LEVELING_AUTOMATIC,
                                 DGUSDisplay::RETURN_KEY_CODE,
                                 DGUS_Control::DISABLE);
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(data));
+  dgus.write((uint16_t)vp.addr, Swap16(data));
 }
 
-void DGUSTxHandler::ABLGrid(DGUS_VP &vp) {
+void DGUSTxHandler::ablGrid(DGUS_VP &vp) {
   // Batch send
   int16_t data[DGUS_LEVEL_GRID_SIZE];
   xy_uint8_t point;
@@ -340,17 +340,17 @@ void DGUSTxHandler::ABLGrid(DGUS_VP &vp) {
   for (int16_t i = 0; i < DGUS_LEVEL_GRID_SIZE; i++) {
     point.x = i % (GRID_MAX_POINTS_X);
     point.y = i / (GRID_MAX_POINTS_X);
-    fixed = dgus_display.ToFixedPoint<float, int16_t, 3>(ExtUI::getMeshPoint(point));
+    fixed = dgus.toFixedPoint<float, int16_t, 3>(ExtUI::getMeshPoint(point));
     data[i] = Swap16(fixed);
   }
 
-  dgus_display.Write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_LEVEL_GRID_SIZE);
+  dgus.write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_LEVEL_GRID_SIZE);
 }
 
-void DGUSTxHandler::FilamentIcons(DGUS_VP &vp) {
+void DGUSTxHandler::filamentIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
-  switch (dgus_screen_handler.filament_extruder) {
+  switch (screen.filament_extruder) {
     default: return;
     case DGUS_Data::Extruder::CURRENT:
       #if HAS_MULTI_EXTRUDER
@@ -373,29 +373,29 @@ void DGUSTxHandler::FilamentIcons(DGUS_VP &vp) {
       break;
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  dgus.write((uint16_t)vp.addr, Swap16(icons));
 }
 
-void DGUSTxHandler::BLTouch(DGUS_VP &vp) {
+void DGUSTxHandler::blTouch(DGUS_VP &vp) {
   #if ENABLED(BLTOUCH)
-    dgus_display.EnableControl(DGUS_Screen::SETTINGS_MENU2,
+    dgus.enableControl(DGUS_ScreenID::SETTINGS_MENU2,
                                DGUSDisplay::RETURN_KEY_CODE,
                                DGUS_Control::EXTRA2);
 
-    dgus_display.Write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::ENABLED));
+    dgus.write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::ENABLED));
   #else
-    dgus_display.DisableControl(DGUS_Screen::SETTINGS_MENU2,
+    dgus.disableControl(DGUS_ScreenID::SETTINGS_MENU2,
                                 DGUSDisplay::RETURN_KEY_CODE,
                                 DGUS_Control::EXTRA2);
 
-    dgus_display.Write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::DISABLED));
+    dgus.write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::DISABLED));
   #endif
 }
 
-void DGUSTxHandler::PIDIcons(DGUS_VP &vp) {
+void DGUSTxHandler::pidIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
-  switch (dgus_screen_handler.pid_heater) {
+  switch (screen.pid_heater) {
     default: return;
     case DGUS_Data::Heater::BED:
       icons |= (uint16_t)DGUS_Data::HeaterIcon::BED;
@@ -408,13 +408,13 @@ void DGUSTxHandler::PIDIcons(DGUS_VP &vp) {
       break;
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  dgus.write((uint16_t)vp.addr, Swap16(icons));
 }
 
-void DGUSTxHandler::PIDKp(DGUS_VP &vp) {
+void DGUSTxHandler::pidKp(DGUS_VP &vp) {
   float value;
 
-  switch (dgus_screen_handler.pid_heater) {
+  switch (screen.pid_heater) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
@@ -433,14 +433,14 @@ void DGUSTxHandler::PIDKp(DGUS_VP &vp) {
     #endif
   }
 
-  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
-  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+  const int32_t data = dgus.toFixedPoint<float, int32_t, 2>(value);
+  dgus.write((uint16_t)vp.addr, dgus.swapBytes(data));
 }
 
-void DGUSTxHandler::PIDKi(DGUS_VP &vp) {
+void DGUSTxHandler::pidKi(DGUS_VP &vp) {
   float value;
 
-  switch (dgus_screen_handler.pid_heater) {
+  switch (screen.pid_heater) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
@@ -459,14 +459,14 @@ void DGUSTxHandler::PIDKi(DGUS_VP &vp) {
     #endif
   }
 
-  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
-  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+  const int32_t data = dgus.toFixedPoint<float, int32_t, 2>(value);
+  dgus.write((uint16_t)vp.addr, dgus.swapBytes(data));
 }
 
-void DGUSTxHandler::PIDKd(DGUS_VP &vp) {
+void DGUSTxHandler::pidKd(DGUS_VP &vp) {
   float value;
 
-  switch (dgus_screen_handler.pid_heater) {
+  switch (screen.pid_heater) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
@@ -485,99 +485,99 @@ void DGUSTxHandler::PIDKd(DGUS_VP &vp) {
     #endif
   }
 
-  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
-  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+  const int32_t data = dgus.toFixedPoint<float, int32_t, 2>(value);
+  dgus.write((uint16_t)vp.addr, dgus.swapBytes(data));
 }
 
-void DGUSTxHandler::BuildVolume(DGUS_VP &vp) {
+void DGUSTxHandler::buildVolume(DGUS_VP &vp) {
   char buffer[vp.size];
   snprintf_P(buffer, vp.size, PSTR("%dx%dx%d"), X_BED_SIZE, Y_BED_SIZE, (Z_MAX_POS - Z_MIN_POS));
 
-  dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+  dgus.writeString((uint16_t)vp.addr, buffer, vp.size);
 }
 
-void DGUSTxHandler::TotalPrints(DGUS_VP &vp) {
+void DGUSTxHandler::totalPrints(DGUS_VP &vp) {
   #if ENABLED(PRINTCOUNTER)
-    dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(print_job_timer.getStats().totalPrints));
+    dgus.write((uint16_t)vp.addr, dgus.swapBytes(print_job_timer.getStats().totalPrints));
   #else
     UNUSED(vp);
   #endif
 }
 
-void DGUSTxHandler::FinishedPrints(DGUS_VP &vp) {
+void DGUSTxHandler::finishedPrints(DGUS_VP &vp) {
   #if ENABLED(PRINTCOUNTER)
-    dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(print_job_timer.getStats().finishedPrints));
+    dgus.write((uint16_t)vp.addr, dgus.swapBytes(print_job_timer.getStats().finishedPrints));
   #else
     UNUSED(vp);
   #endif
 }
 
-void DGUSTxHandler::PrintTime(DGUS_VP &vp) {
+void DGUSTxHandler::printTime(DGUS_VP &vp) {
   #if ENABLED(PRINTCOUNTER)
     char buffer[21];
     ExtUI::getTotalPrintTime_str(buffer);
 
-    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+    dgus.writeString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
+    dgus.writeString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 
-void DGUSTxHandler::LongestPrint(DGUS_VP &vp) {
+void DGUSTxHandler::longestPrint(DGUS_VP &vp) {
   #if ENABLED(PRINTCOUNTER)
     char buffer[21];
     ExtUI::getLongestPrint_str(buffer);
 
-    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+    dgus.writeString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
+    dgus.writeString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 
-void DGUSTxHandler::FilamentUsed(DGUS_VP &vp) {
+void DGUSTxHandler::filamentUsed(DGUS_VP &vp) {
   #if ENABLED(PRINTCOUNTER)
     char buffer[21];
     ExtUI::getFilamentUsed_str(buffer);
 
-    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+    dgus.writeString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
+    dgus.writeString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 
-void DGUSTxHandler::WaitIcons(DGUS_VP &vp) {
+void DGUSTxHandler::waitIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
   if (ExtUI::isPrintingPaused()) {
     icons |= (uint16_t)DGUS_Data::WaitIcon::ABORT;
 
-    dgus_display.EnableControl(DGUS_Screen::WAIT,
+    dgus.enableControl(DGUS_ScreenID::WAIT,
                                DGUSDisplay::POPUP_WINDOW,
                                DGUS_Control::ABORT);
   }
   else {
-    dgus_display.DisableControl(DGUS_Screen::WAIT,
+    dgus.disableControl(DGUS_ScreenID::WAIT,
                                 DGUSDisplay::POPUP_WINDOW,
                                 DGUS_Control::ABORT);
   }
 
-  if (dgus_screen_handler.wait_continue) {
+  if (screen.wait_continue) {
     icons |= (uint16_t)DGUS_Data::WaitIcon::CONTINUE;
 
-    dgus_display.EnableControl(DGUS_Screen::WAIT,
+    dgus.enableControl(DGUS_ScreenID::WAIT,
                                DGUSDisplay::RETURN_KEY_CODE,
                                DGUS_Control::CONTINUE);
   }
   else {
-    dgus_display.DisableControl(DGUS_Screen::WAIT,
+    dgus.disableControl(DGUS_ScreenID::WAIT,
                                 DGUSDisplay::RETURN_KEY_CODE,
                                 DGUS_Control::CONTINUE);
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  dgus.write((uint16_t)vp.addr, Swap16(icons));
 }
 
-void DGUSTxHandler::FanSpeed(DGUS_VP &vp) {
+void DGUSTxHandler::fanSpeed(DGUS_VP &vp) {
   uint16_t fan_speed;
 
   switch (vp.addr) {
@@ -585,31 +585,31 @@ void DGUSTxHandler::FanSpeed(DGUS_VP &vp) {
     case DGUS_Addr::FAN0_Speed: fan_speed = ExtUI::getTargetFan_percent(ExtUI::FAN0); break;
   }
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(fan_speed));
+  dgus.write((uint16_t)vp.addr, Swap16(fan_speed));
 }
 
-void DGUSTxHandler::Volume(DGUS_VP &vp) {
-  const uint16_t volume = dgus_display.GetVolume();
+void DGUSTxHandler::volume(DGUS_VP &vp) {
+  const uint16_t volume = dgus.getVolume();
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(volume));
+  dgus.write((uint16_t)vp.addr, Swap16(volume));
 }
 
-void DGUSTxHandler::Brightness(DGUS_VP &vp) {
-  const uint16_t brightness = dgus_display.GetBrightness();
+void DGUSTxHandler::brightness(DGUS_VP &vp) {
+  const uint16_t brightness = dgus.getBrightness();
 
-  dgus_display.Write((uint16_t)vp.addr, Swap16(brightness));
+  dgus.write((uint16_t)vp.addr, Swap16(brightness));
 }
 
-void DGUSTxHandler::ExtraToString(DGUS_VP &vp) {
+void DGUSTxHandler::extraToString(DGUS_VP &vp) {
   if (!vp.size || !vp.extra) return;
 
-  dgus_display.WriteString((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
+  dgus.writeString((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
 }
 
-void DGUSTxHandler::ExtraPGMToString(DGUS_VP &vp) {
+void DGUSTxHandler::extraPGMToString(DGUS_VP &vp) {
   if (!vp.size || !vp.extra) return;
 
-  dgus_display.WriteStringPGM((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
+  dgus.writeStringPGM((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
 }
 
 #endif // DGUS_LCD_UI_RELOADED

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index b27988a89f..c7d650c03e 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -36,7 +36,7 @@
   #include "../../../feature/pause.h"
 #endif
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
   void DGUSTxHandler::SetFileControlState(int16_t file, bool state) {
     DGUS_Control control;
 
@@ -177,7 +177,7 @@
 
     dgus_display.WriteString((uint16_t)vp.addr, dgus_screen_handler.filelist.filename(), vp.size);
   }
-#endif // SDSUPPORT
+#endif // HAS_MEDIA
 
 void DGUSTxHandler::PositionZ(DGUS_VP &vp) {
   const float position = ExtUI::isAxisPositionKnown(ExtUI::Z) ? planner.get_axis_position_mm(Z_AXIS) : 0;

commit 9039e99df1b95f6a352fb1b2ae27f893b091cfe7
Author: Neo2003 <Neo2003@users.noreply.github.com>
Date:   Mon Mar 13 22:55:03 2023 +0100

    üì∫ DGUS_RELOADED 1.03 (#25490)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index dc2aea8bef..b27988a89f 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -180,12 +180,9 @@
 #endif // SDSUPPORT
 
 void DGUSTxHandler::PositionZ(DGUS_VP &vp) {
-  float position = ExtUI::isAxisPositionKnown(ExtUI::Z) ?
-                     planner.get_axis_position_mm(Z_AXIS)
-                   : 0;
-
-  const int16_t data = dgus_display.ToFixedPoint<float, int16_t, 1>(position);
-  dgus_display.Write((uint16_t)vp.addr, Swap16(data));
+  const float position = ExtUI::isAxisPositionKnown(ExtUI::Z) ? planner.get_axis_position_mm(Z_AXIS) : 0;
+  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(int32_t(position * 50.0f) / 50.0f); // Round to 0.02
+  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
 }
 
 void DGUSTxHandler::Elapsed(DGUS_VP &vp) {

commit 4b9bb85b1266e8febbcb1931c8427d410a05bf84
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 6 22:55:55 2023 -0600

    üîß Add DGUS_LCD_UI RELOADED conditions

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index eb1b3aa510..dc2aea8bef 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -522,7 +522,7 @@ void DGUSTxHandler::PrintTime(DGUS_VP &vp) {
 
     dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 
@@ -533,7 +533,7 @@ void DGUSTxHandler::LongestPrint(DGUS_VP &vp) {
 
     dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 
@@ -544,7 +544,7 @@ void DGUSTxHandler::FilamentUsed(DGUS_VP &vp) {
 
     dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
   #else
-    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+    dgus_display.WriteString((uint16_t)vp.addr, F("-"), vp.size);
   #endif
 }
 

commit cc31537ae3ca3be37ffb171540e7445f30827930
Author: albatorsssx <albator_ssx@hotmail.com>
Date:   Tue Mar 7 03:04:47 2023 +0100

    üåê DGUS Reloaded non-accented French (#25443)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 39b3f57e96..eb1b3aa510 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -188,7 +188,7 @@ void DGUSTxHandler::PositionZ(DGUS_VP &vp) {
   dgus_display.Write((uint16_t)vp.addr, Swap16(data));
 }
 
-void DGUSTxHandler::Ellapsed(DGUS_VP &vp) {
+void DGUSTxHandler::Elapsed(DGUS_VP &vp) {
   char buffer[21];
   duration_t(print_job_timer.duration()).toString(buffer);
 

commit 96bc084f3d791bc93265f217181986863e8e5fc7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 18 02:15:16 2023 -0600

    üé® Misc. LCD cleanup (#25400)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 47603052e9..39b3f57e96 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -37,7 +37,7 @@
 #endif
 
 #if ENABLED(SDSUPPORT)
-  void DGUSTxHandler::SetFileControlState(int file, bool state) {
+  void DGUSTxHandler::SetFileControlState(int16_t file, bool state) {
     DGUS_Control control;
 
     switch (file) {
@@ -75,17 +75,17 @@
     // Batch send
     uint16_t data[DGUS_FILE_COUNT];
 
-    for (int i = 0; i < DGUS_FILE_COUNT; i++) {
+    for (int16_t i = 0; i < DGUS_FILE_COUNT; i++) {
       if (!dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_offset + i)) {
-        data[i] = Swap16((uint16_t)DGUS_Data::SDType::NONE);
+        data[i] = Swap16(DGUS_Data::SDType::NONE);
 
         SetFileControlState(i, false);
         continue;
       }
 
       data[i] = dgus_screen_handler.filelist.isDir() ?
-                  Swap16((uint16_t)DGUS_Data::SDType::DIRECTORY)
-                : Swap16((uint16_t)DGUS_Data::SDType::FILE);
+                  Swap16(DGUS_Data::SDType::DIRECTORY)
+                : Swap16(DGUS_Data::SDType::FILE);
 
       SetFileControlState(i, true);
     }
@@ -287,7 +287,7 @@ void DGUSTxHandler::TempMax(DGUS_VP &vp) {
 
 void DGUSTxHandler::StepperStatus(DGUS_VP &vp) {
   const bool motor_on = stepper.axis_enabled.bits & (_BV(NUM_AXES) - 1);
-  dgus_display.Write((uint16_t)vp.addr, Swap16(uint16_t(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED)));
+  dgus_display.Write((uint16_t)vp.addr, Swap16(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED));
 }
 
 void DGUSTxHandler::StepIcons(DGUS_VP &vp) {
@@ -340,7 +340,7 @@ void DGUSTxHandler::ABLGrid(DGUS_VP &vp) {
   xy_uint8_t point;
   int16_t fixed;
 
-  for (int i = 0; i < DGUS_LEVEL_GRID_SIZE; i++) {
+  for (int16_t i = 0; i < DGUS_LEVEL_GRID_SIZE; i++) {
     point.x = i % (GRID_MAX_POINTS_X);
     point.y = i / (GRID_MAX_POINTS_X);
     fixed = dgus_display.ToFixedPoint<float, int16_t, 3>(ExtUI::getMeshPoint(point));
@@ -385,13 +385,13 @@ void DGUSTxHandler::BLTouch(DGUS_VP &vp) {
                                DGUSDisplay::RETURN_KEY_CODE,
                                DGUS_Control::EXTRA2);
 
-    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::ENABLED));
+    dgus_display.Write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::ENABLED));
   #else
     dgus_display.DisableControl(DGUS_Screen::SETTINGS_MENU2,
                                 DGUSDisplay::RETURN_KEY_CODE,
                                 DGUS_Control::EXTRA2);
 
-    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::DISABLED));
+    dgus_display.Write((uint16_t)vp.addr, Swap16(DGUS_Data::Status::DISABLED));
   #endif
 }
 

commit c3fe4abd446336c50bdb892f08fa24a08f1bdda5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 7 22:59:25 2023 -0600

    üî® DGUS_LCD_UI version check

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 1837a0c93a..47603052e9 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -22,7 +22,7 @@
 
 #include "../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(DGUS_LCD_UI_RELOADED)
+#if DGUS_LCD_UI_RELOADED
 
 #include "DGUSTxHandler.h"
 

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 62df84e53d..1837a0c93a 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -421,16 +421,16 @@ void DGUSTxHandler::PIDKp(DGUS_VP &vp) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
-        value = ExtUI::getBedPIDValues_Kp();
+        value = ExtUI::getBedPID_Kp();
         break;
     #endif
     #if ENABLED(PIDTEMP)
       case DGUS_Data::Heater::H0:
-        value = ExtUI::getPIDValues_Kp(ExtUI::E0);
+        value = ExtUI::getPID_Kp(ExtUI::E0);
         break;
       #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
-          value = ExtUI::getPIDValues_Kp(ExtUI::E1);
+          value = ExtUI::getPID_Kp(ExtUI::E1);
           break;
       #endif
     #endif
@@ -447,16 +447,16 @@ void DGUSTxHandler::PIDKi(DGUS_VP &vp) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
-        value = ExtUI::getBedPIDValues_Ki();
+        value = ExtUI::getBedPID_Ki();
         break;
     #endif
     #if ENABLED(PIDTEMP)
       case DGUS_Data::Heater::H0:
-        value = ExtUI::getPIDValues_Ki(ExtUI::E0);
+        value = ExtUI::getPID_Ki(ExtUI::E0);
         break;
       #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
-          value = ExtUI::getPIDValues_Ki(ExtUI::E1);
+          value = ExtUI::getPID_Ki(ExtUI::E1);
           break;
       #endif
     #endif
@@ -473,16 +473,16 @@ void DGUSTxHandler::PIDKd(DGUS_VP &vp) {
     default: return;
     #if ENABLED(PIDTEMPBED)
       case DGUS_Data::Heater::BED:
-        value = ExtUI::getBedPIDValues_Kd();
+        value = ExtUI::getBedPID_Kd();
         break;
     #endif
     #if ENABLED(PIDTEMP)
       case DGUS_Data::Heater::H0:
-        value = ExtUI::getPIDValues_Kd(ExtUI::E0);
+        value = ExtUI::getPID_Kd(ExtUI::E0);
         break;
       #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
-          value = ExtUI::getPIDValues_Kd(ExtUI::E1);
+          value = ExtUI::getPID_Kd(ExtUI::E1);
           break;
       #endif
     #endif

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 961b29ca22..62df84e53d 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -341,8 +341,8 @@ void DGUSTxHandler::ABLGrid(DGUS_VP &vp) {
   int16_t fixed;
 
   for (int i = 0; i < DGUS_LEVEL_GRID_SIZE; i++) {
-    point.x = i % GRID_MAX_POINTS_X;
-    point.y = i / GRID_MAX_POINTS_X;
+    point.x = i % (GRID_MAX_POINTS_X);
+    point.y = i / (GRID_MAX_POINTS_X);
     fixed = dgus_display.ToFixedPoint<float, int16_t, 3>(ExtUI::getMeshPoint(point));
     data[i] = Swap16(fixed);
   }

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 8d57038765..961b29ca22 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -286,7 +286,7 @@ void DGUSTxHandler::TempMax(DGUS_VP &vp) {
 }
 
 void DGUSTxHandler::StepperStatus(DGUS_VP &vp) {
-  const bool motor_on = stepper.axis_enabled.bits & (_BV(LINEAR_AXES) - 1);
+  const bool motor_on = stepper.axis_enabled.bits & (_BV(NUM_AXES) - 1);
   dgus_display.Write((uint16_t)vp.addr, Swap16(uint16_t(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED)));
 }
 

commit aa2c6387e95bdab955499627e3890561842f0a6a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 26 21:54:43 2021 -0500

    üé® Apply HAS_MULTI_HOTEND conditional

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 3fc48d2ebb..8d57038765 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -275,7 +275,7 @@ void DGUSTxHandler::TempMax(DGUS_VP &vp) {
     case DGUS_Addr::TEMP_Max_H0:
       temp = HEATER_0_MAXTEMP - HOTEND_OVERSHOOT;
       break;
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       case DGUS_Addr::TEMP_Max_H1:
         temp = HEATER_1_MAXTEMP - HOTEND_OVERSHOOT;
         break;
@@ -428,7 +428,7 @@ void DGUSTxHandler::PIDKp(DGUS_VP &vp) {
       case DGUS_Data::Heater::H0:
         value = ExtUI::getPIDValues_Kp(ExtUI::E0);
         break;
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
           value = ExtUI::getPIDValues_Kp(ExtUI::E1);
           break;
@@ -454,7 +454,7 @@ void DGUSTxHandler::PIDKi(DGUS_VP &vp) {
       case DGUS_Data::Heater::H0:
         value = ExtUI::getPIDValues_Ki(ExtUI::E0);
         break;
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
           value = ExtUI::getPIDValues_Ki(ExtUI::E1);
           break;
@@ -480,7 +480,7 @@ void DGUSTxHandler::PIDKd(DGUS_VP &vp) {
       case DGUS_Data::Heater::H0:
         value = ExtUI::getPIDValues_Kd(ExtUI::E0);
         break;
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         case DGUS_Data::Heater::H1:
           value = ExtUI::getPIDValues_Kd(ExtUI::E1);
           break;

commit 9d72cbf84b970e5060f8dceef7158b9ca8252856
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 15 15:07:47 2021 -0500

    üí° Update old gnu.org links

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 6c14745904..3fc48d2ebb 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index b419428fbc..6c14745904 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -286,14 +286,8 @@ void DGUSTxHandler::TempMax(DGUS_VP &vp) {
 }
 
 void DGUSTxHandler::StepperStatus(DGUS_VP &vp) {
-  if (X_ENABLE_READ() == X_ENABLE_ON
-      && Y_ENABLE_READ() == Y_ENABLE_ON
-      && Z_ENABLE_READ() == Z_ENABLE_ON) {
-    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::ENABLED));
-  }
-  else {
-    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::DISABLED));
-  }
+  const bool motor_on = stepper.axis_enabled.bits & (_BV(LINEAR_AXES) - 1);
+  dgus_display.Write((uint16_t)vp.addr, Swap16(uint16_t(motor_on ? DGUS_Data::Status::ENABLED : DGUS_Data::Status::DISABLED)));
 }
 
 void DGUSTxHandler::StepIcons(DGUS_VP &vp) {

commit b88117d6364b8919a8a7df6c80d8132af98a6afc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 21 06:25:13 2021 -0500

    üé® Fix L64xx enable, clean up conditionals

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index b2fa8c18b3..b419428fbc 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -249,13 +249,9 @@ void DGUSTxHandler::Flowrate(DGUS_VP &vp) {
   switch (vp.addr) {
     default: return;
     case DGUS_Addr::ADJUST_Flowrate_CUR:
-      #if EXTRUDERS > 1
-        flowrate = ExtUI::getFlow_percent(ExtUI::getActiveTool());
-      #else
-        flowrate = ExtUI::getFlow_percent(ExtUI::E0);
-      #endif
+      flowrate = ExtUI::getFlow_percent(TERN(HAS_MULTI_EXTRUDER, ExtUI::getActiveTool(), ExtUI::E0));
       break;
-    #if EXTRUDERS > 1
+    #if HAS_MULTI_EXTRUDER
       case DGUS_Addr::ADJUST_Flowrate_E0:
         flowrate = ExtUI::getFlow_percent(ExtUI::E0);
         break;
@@ -366,7 +362,7 @@ void DGUSTxHandler::FilamentIcons(DGUS_VP &vp) {
   switch (dgus_screen_handler.filament_extruder) {
     default: return;
     case DGUS_Data::Extruder::CURRENT:
-      #if EXTRUDERS > 1
+      #if HAS_MULTI_EXTRUDER
         switch (ExtUI::getActiveTool()) {
           default: break;
           case ExtUI::E0:

commit 23d10ceccb16e5886a6441a364fcbc08391287fe
Author: Desuuuu <contact@desuuuu.com>
Date:   Fri Sep 10 12:15:08 2021 +0200

    üé® Use ExtUI API where applicable

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
index 04362b07e8..b2fa8c18b3 100644
--- a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -214,7 +214,7 @@ void DGUSTxHandler::Percent(DGUS_VP &vp) {
 void DGUSTxHandler::StatusIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
-  if (printingIsActive()) {
+  if (ExtUI::isPrinting()) {
     icons |= (uint16_t)DGUS_Data::StatusIcon::PAUSE;
 
     dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
@@ -227,7 +227,7 @@ void DGUSTxHandler::StatusIcons(DGUS_VP &vp) {
                                 DGUS_Control::PAUSE);
   }
 
-  if (printingIsPaused()) {
+  if (ExtUI::isPrintingPaused()) {
     icons |= (uint16_t)DGUS_Data::StatusIcon::RESUME;
 
     dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
@@ -561,11 +561,7 @@ void DGUSTxHandler::FilamentUsed(DGUS_VP &vp) {
 void DGUSTxHandler::WaitIcons(DGUS_VP &vp) {
   uint16_t icons = 0;
 
-  if (printingIsPaused()
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      && did_pause_print
-    #endif
-  ) {
+  if (ExtUI::isPrintingPaused()) {
     icons |= (uint16_t)DGUS_Data::WaitIcon::ABORT;
 
     dgus_display.EnableControl(DGUS_Screen::WAIT,

commit b0e798330d8f5ade4a230e0a91f05482d100bb97
Author: mrv96 <mrv96@users.noreply.github.com>
Date:   Tue Sep 7 02:51:04 2021 +0200

    ‚ú®Add DGUS_LCD_UI_RELOADED (#21931)

diff --git a/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
new file mode 100644
index 0000000000..04362b07e8
--- /dev/null
+++ b/Marlin/src/lcd/extui/dgus_reloaded/DGUSTxHandler.cpp
@@ -0,0 +1,632 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DGUS_LCD_UI_RELOADED)
+
+#include "DGUSTxHandler.h"
+
+#include "DGUSScreenHandler.h"
+#include "config/DGUS_Data.h"
+
+#include "../ui_api.h"
+#include "../../../module/stepper.h"
+#include "../../../module/printcounter.h"
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../../../feature/pause.h"
+#endif
+
+#if ENABLED(SDSUPPORT)
+  void DGUSTxHandler::SetFileControlState(int file, bool state) {
+    DGUS_Control control;
+
+    switch (file) {
+      default: return;
+      case 0:
+        control = DGUS_Control::FILE0;
+        break;
+      case 1:
+        control = DGUS_Control::FILE1;
+        break;
+      case 2:
+        control = DGUS_Control::FILE2;
+        break;
+      case 3:
+        control = DGUS_Control::FILE3;
+        break;
+      case 4:
+        control = DGUS_Control::FILE4;
+        break;
+    }
+
+    if (state) {
+      dgus_display.EnableControl(DGUS_Screen::PRINT,
+                                 DGUSDisplay::RETURN_KEY_CODE,
+                                 control);
+    }
+    else {
+      dgus_display.DisableControl(DGUS_Screen::PRINT,
+                                  DGUSDisplay::RETURN_KEY_CODE,
+                                  control);
+    }
+  }
+
+  void DGUSTxHandler::FileType(DGUS_VP &vp) {
+    // Batch send
+    uint16_t data[DGUS_FILE_COUNT];
+
+    for (int i = 0; i < DGUS_FILE_COUNT; i++) {
+      if (!dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_offset + i)) {
+        data[i] = Swap16((uint16_t)DGUS_Data::SDType::NONE);
+
+        SetFileControlState(i, false);
+        continue;
+      }
+
+      data[i] = dgus_screen_handler.filelist.isDir() ?
+                  Swap16((uint16_t)DGUS_Data::SDType::DIRECTORY)
+                : Swap16((uint16_t)DGUS_Data::SDType::FILE);
+
+      SetFileControlState(i, true);
+    }
+
+    dgus_display.Write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_FILE_COUNT);
+  }
+
+  void DGUSTxHandler::FileName(DGUS_VP &vp) {
+    uint8_t offset;
+
+    switch (vp.addr) {
+      default: return;
+      case DGUS_Addr::SD_FileName0:
+        offset = 0;
+        break;
+      case DGUS_Addr::SD_FileName1:
+        offset = 1;
+        break;
+      case DGUS_Addr::SD_FileName2:
+        offset = 2;
+        break;
+      case DGUS_Addr::SD_FileName3:
+        offset = 3;
+        break;
+      case DGUS_Addr::SD_FileName4:
+        offset = 4;
+        break;
+    }
+
+    if (dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_offset + offset)) {
+      dgus_display.WriteString((uint16_t)vp.addr, dgus_screen_handler.filelist.filename(), vp.size);
+    }
+    else {
+      dgus_display.WriteStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
+    }
+  }
+
+  void DGUSTxHandler::ScrollIcons(DGUS_VP &vp) {
+    uint16_t icons = 0;
+
+    if (!dgus_screen_handler.filelist.isAtRootDir()) {
+      icons |= (uint16_t)DGUS_Data::ScrollIcon::GO_BACK;
+
+      dgus_display.EnableControl(DGUS_Screen::PRINT,
+                                 DGUSDisplay::RETURN_KEY_CODE,
+                                 DGUS_Control::GO_BACK);
+    }
+    else {
+      dgus_display.DisableControl(DGUS_Screen::PRINT,
+                                  DGUSDisplay::RETURN_KEY_CODE,
+                                  DGUS_Control::GO_BACK);
+    }
+
+    if (dgus_screen_handler.filelist_offset > 0) {
+      icons |= (uint16_t)DGUS_Data::ScrollIcon::UP;
+
+      dgus_display.EnableControl(DGUS_Screen::PRINT,
+                                 DGUSDisplay::RETURN_KEY_CODE,
+                                 DGUS_Control::SCROLL_UP);
+    }
+    else {
+      dgus_display.DisableControl(DGUS_Screen::PRINT,
+                                  DGUSDisplay::RETURN_KEY_CODE,
+                                  DGUS_Control::SCROLL_UP);
+    }
+
+    if (dgus_screen_handler.filelist_offset + DGUS_FILE_COUNT < dgus_screen_handler.filelist.count()) {
+      icons |= (uint16_t)DGUS_Data::ScrollIcon::DOWN;
+
+      dgus_display.EnableControl(DGUS_Screen::PRINT,
+                                 DGUSDisplay::RETURN_KEY_CODE,
+                                 DGUS_Control::SCROLL_DOWN);
+    }
+    else {
+      dgus_display.DisableControl(DGUS_Screen::PRINT,
+                                  DGUSDisplay::RETURN_KEY_CODE,
+                                  DGUS_Control::SCROLL_DOWN);
+    }
+
+    dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+  }
+
+  void DGUSTxHandler::SelectedFileName(DGUS_VP &vp) {
+    if (dgus_screen_handler.filelist_selected < 0
+        || !dgus_screen_handler.filelist.seek(dgus_screen_handler.filelist_selected)) {
+      dgus_display.WriteStringPGM((uint16_t)vp.addr, NUL_STR, vp.size);
+      return;
+    }
+
+    dgus_display.WriteString((uint16_t)vp.addr, dgus_screen_handler.filelist.filename(), vp.size);
+  }
+#endif // SDSUPPORT
+
+void DGUSTxHandler::PositionZ(DGUS_VP &vp) {
+  float position = ExtUI::isAxisPositionKnown(ExtUI::Z) ?
+                     planner.get_axis_position_mm(Z_AXIS)
+                   : 0;
+
+  const int16_t data = dgus_display.ToFixedPoint<float, int16_t, 1>(position);
+  dgus_display.Write((uint16_t)vp.addr, Swap16(data));
+}
+
+void DGUSTxHandler::Ellapsed(DGUS_VP &vp) {
+  char buffer[21];
+  duration_t(print_job_timer.duration()).toString(buffer);
+
+  dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+}
+
+void DGUSTxHandler::Percent(DGUS_VP &vp) {
+  uint16_t progress;
+
+  switch (vp.addr) {
+    default: return;
+    case DGUS_Addr::STATUS_Percent:
+      progress = constrain(ExtUI::getProgress_percent(), 0, 100);
+      break;
+    case DGUS_Addr::STATUS_Percent_Complete:
+      progress = 100;
+      break;
+  }
+
+  dgus_display.Write((uint16_t)DGUS_Addr::STATUS_Percent, Swap16(progress));
+}
+
+void DGUSTxHandler::StatusIcons(DGUS_VP &vp) {
+  uint16_t icons = 0;
+
+  if (printingIsActive()) {
+    icons |= (uint16_t)DGUS_Data::StatusIcon::PAUSE;
+
+    dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
+                               DGUSDisplay::POPUP_WINDOW,
+                               DGUS_Control::PAUSE);
+  }
+  else {
+    dgus_display.DisableControl(DGUS_Screen::PRINT_STATUS,
+                                DGUSDisplay::POPUP_WINDOW,
+                                DGUS_Control::PAUSE);
+  }
+
+  if (printingIsPaused()) {
+    icons |= (uint16_t)DGUS_Data::StatusIcon::RESUME;
+
+    dgus_display.EnableControl(DGUS_Screen::PRINT_STATUS,
+                               DGUSDisplay::POPUP_WINDOW,
+                               DGUS_Control::RESUME);
+  }
+  else {
+    dgus_display.DisableControl(DGUS_Screen::PRINT_STATUS,
+                                DGUSDisplay::POPUP_WINDOW,
+                                DGUS_Control::RESUME);
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+}
+
+void DGUSTxHandler::Flowrate(DGUS_VP &vp) {
+  int16_t flowrate;
+
+  switch (vp.addr) {
+    default: return;
+    case DGUS_Addr::ADJUST_Flowrate_CUR:
+      #if EXTRUDERS > 1
+        flowrate = ExtUI::getFlow_percent(ExtUI::getActiveTool());
+      #else
+        flowrate = ExtUI::getFlow_percent(ExtUI::E0);
+      #endif
+      break;
+    #if EXTRUDERS > 1
+      case DGUS_Addr::ADJUST_Flowrate_E0:
+        flowrate = ExtUI::getFlow_percent(ExtUI::E0);
+        break;
+      case DGUS_Addr::ADJUST_Flowrate_E1:
+        flowrate = ExtUI::getFlow_percent(ExtUI::E1);
+        break;
+    #endif
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(flowrate));
+}
+
+void DGUSTxHandler::TempMax(DGUS_VP &vp) {
+  uint16_t temp;
+
+  switch (vp.addr) {
+    default: return;
+    case DGUS_Addr::TEMP_Max_Bed:
+      temp = BED_MAX_TARGET;
+      break;
+    case DGUS_Addr::TEMP_Max_H0:
+      temp = HEATER_0_MAXTEMP - HOTEND_OVERSHOOT;
+      break;
+    #if HOTENDS > 1
+      case DGUS_Addr::TEMP_Max_H1:
+        temp = HEATER_1_MAXTEMP - HOTEND_OVERSHOOT;
+        break;
+    #endif
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(temp));
+}
+
+void DGUSTxHandler::StepperStatus(DGUS_VP &vp) {
+  if (X_ENABLE_READ() == X_ENABLE_ON
+      && Y_ENABLE_READ() == Y_ENABLE_ON
+      && Z_ENABLE_READ() == Z_ENABLE_ON) {
+    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::ENABLED));
+  }
+  else {
+    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::DISABLED));
+  }
+}
+
+void DGUSTxHandler::StepIcons(DGUS_VP &vp) {
+  if (!vp.extra) return;
+  uint16_t icons = 0;
+  DGUS_Data::StepSize size = *(DGUS_Data::StepSize*)vp.extra;
+
+  switch (size) {
+    case DGUS_Data::StepSize::MM10:
+      icons |= (uint16_t)DGUS_Data::StepIcon::MM10;
+      break;
+    case DGUS_Data::StepSize::MM1:
+      icons |= (uint16_t)DGUS_Data::StepIcon::MM1;
+      break;
+    case DGUS_Data::StepSize::MMP1:
+      icons |= (uint16_t)DGUS_Data::StepIcon::MMP1;
+      break;
+    case DGUS_Data::StepSize::MMP01:
+      icons |= (uint16_t)DGUS_Data::StepIcon::MMP01;
+      break;
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+}
+
+void DGUSTxHandler::ABLDisableIcon(DGUS_VP &vp) {
+  uint16_t data;
+
+  if (ExtUI::getLevelingActive()) {
+    data = (uint16_t)DGUS_Data::Status::ENABLED;
+
+    dgus_display.EnableControl(DGUS_Screen::LEVELING_AUTOMATIC,
+                               DGUSDisplay::RETURN_KEY_CODE,
+                               DGUS_Control::DISABLE);
+  }
+  else {
+    data = (uint16_t)DGUS_Data::Status::DISABLED;
+
+    dgus_display.DisableControl(DGUS_Screen::LEVELING_AUTOMATIC,
+                                DGUSDisplay::RETURN_KEY_CODE,
+                                DGUS_Control::DISABLE);
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(data));
+}
+
+void DGUSTxHandler::ABLGrid(DGUS_VP &vp) {
+  // Batch send
+  int16_t data[DGUS_LEVEL_GRID_SIZE];
+  xy_uint8_t point;
+  int16_t fixed;
+
+  for (int i = 0; i < DGUS_LEVEL_GRID_SIZE; i++) {
+    point.x = i % GRID_MAX_POINTS_X;
+    point.y = i / GRID_MAX_POINTS_X;
+    fixed = dgus_display.ToFixedPoint<float, int16_t, 3>(ExtUI::getMeshPoint(point));
+    data[i] = Swap16(fixed);
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, data, sizeof(*data) * DGUS_LEVEL_GRID_SIZE);
+}
+
+void DGUSTxHandler::FilamentIcons(DGUS_VP &vp) {
+  uint16_t icons = 0;
+
+  switch (dgus_screen_handler.filament_extruder) {
+    default: return;
+    case DGUS_Data::Extruder::CURRENT:
+      #if EXTRUDERS > 1
+        switch (ExtUI::getActiveTool()) {
+          default: break;
+          case ExtUI::E0:
+            icons |= (uint16_t)DGUS_Data::ExtruderIcon::E0;
+            break;
+          case ExtUI::E1:
+            icons |= (uint16_t)DGUS_Data::ExtruderIcon::E1;
+            break;
+        }
+        break;
+      #endif
+    case DGUS_Data::Extruder::E0:
+      icons |= (uint16_t)DGUS_Data::ExtruderIcon::E0;
+      break;
+    case DGUS_Data::Extruder::E1:
+      icons |= (uint16_t)DGUS_Data::ExtruderIcon::E1;
+      break;
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+}
+
+void DGUSTxHandler::BLTouch(DGUS_VP &vp) {
+  #if ENABLED(BLTOUCH)
+    dgus_display.EnableControl(DGUS_Screen::SETTINGS_MENU2,
+                               DGUSDisplay::RETURN_KEY_CODE,
+                               DGUS_Control::EXTRA2);
+
+    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::ENABLED));
+  #else
+    dgus_display.DisableControl(DGUS_Screen::SETTINGS_MENU2,
+                                DGUSDisplay::RETURN_KEY_CODE,
+                                DGUS_Control::EXTRA2);
+
+    dgus_display.Write((uint16_t)vp.addr, Swap16((uint16_t)DGUS_Data::Status::DISABLED));
+  #endif
+}
+
+void DGUSTxHandler::PIDIcons(DGUS_VP &vp) {
+  uint16_t icons = 0;
+
+  switch (dgus_screen_handler.pid_heater) {
+    default: return;
+    case DGUS_Data::Heater::BED:
+      icons |= (uint16_t)DGUS_Data::HeaterIcon::BED;
+      break;
+    case DGUS_Data::Heater::H0:
+      icons |= (uint16_t)DGUS_Data::HeaterIcon::H0;
+      break;
+    case DGUS_Data::Heater::H1:
+      icons |= (uint16_t)DGUS_Data::HeaterIcon::H1;
+      break;
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+}
+
+void DGUSTxHandler::PIDKp(DGUS_VP &vp) {
+  float value;
+
+  switch (dgus_screen_handler.pid_heater) {
+    default: return;
+    #if ENABLED(PIDTEMPBED)
+      case DGUS_Data::Heater::BED:
+        value = ExtUI::getBedPIDValues_Kp();
+        break;
+    #endif
+    #if ENABLED(PIDTEMP)
+      case DGUS_Data::Heater::H0:
+        value = ExtUI::getPIDValues_Kp(ExtUI::E0);
+        break;
+      #if HOTENDS > 1
+        case DGUS_Data::Heater::H1:
+          value = ExtUI::getPIDValues_Kp(ExtUI::E1);
+          break;
+      #endif
+    #endif
+  }
+
+  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
+  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+}
+
+void DGUSTxHandler::PIDKi(DGUS_VP &vp) {
+  float value;
+
+  switch (dgus_screen_handler.pid_heater) {
+    default: return;
+    #if ENABLED(PIDTEMPBED)
+      case DGUS_Data::Heater::BED:
+        value = ExtUI::getBedPIDValues_Ki();
+        break;
+    #endif
+    #if ENABLED(PIDTEMP)
+      case DGUS_Data::Heater::H0:
+        value = ExtUI::getPIDValues_Ki(ExtUI::E0);
+        break;
+      #if HOTENDS > 1
+        case DGUS_Data::Heater::H1:
+          value = ExtUI::getPIDValues_Ki(ExtUI::E1);
+          break;
+      #endif
+    #endif
+  }
+
+  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
+  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+}
+
+void DGUSTxHandler::PIDKd(DGUS_VP &vp) {
+  float value;
+
+  switch (dgus_screen_handler.pid_heater) {
+    default: return;
+    #if ENABLED(PIDTEMPBED)
+      case DGUS_Data::Heater::BED:
+        value = ExtUI::getBedPIDValues_Kd();
+        break;
+    #endif
+    #if ENABLED(PIDTEMP)
+      case DGUS_Data::Heater::H0:
+        value = ExtUI::getPIDValues_Kd(ExtUI::E0);
+        break;
+      #if HOTENDS > 1
+        case DGUS_Data::Heater::H1:
+          value = ExtUI::getPIDValues_Kd(ExtUI::E1);
+          break;
+      #endif
+    #endif
+  }
+
+  const int32_t data = dgus_display.ToFixedPoint<float, int32_t, 2>(value);
+  dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(data));
+}
+
+void DGUSTxHandler::BuildVolume(DGUS_VP &vp) {
+  char buffer[vp.size];
+  snprintf_P(buffer, vp.size, PSTR("%dx%dx%d"), X_BED_SIZE, Y_BED_SIZE, (Z_MAX_POS - Z_MIN_POS));
+
+  dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+}
+
+void DGUSTxHandler::TotalPrints(DGUS_VP &vp) {
+  #if ENABLED(PRINTCOUNTER)
+    dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(print_job_timer.getStats().totalPrints));
+  #else
+    UNUSED(vp);
+  #endif
+}
+
+void DGUSTxHandler::FinishedPrints(DGUS_VP &vp) {
+  #if ENABLED(PRINTCOUNTER)
+    dgus_display.Write((uint16_t)vp.addr, dgus_display.SwapBytes(print_job_timer.getStats().finishedPrints));
+  #else
+    UNUSED(vp);
+  #endif
+}
+
+void DGUSTxHandler::PrintTime(DGUS_VP &vp) {
+  #if ENABLED(PRINTCOUNTER)
+    char buffer[21];
+    ExtUI::getTotalPrintTime_str(buffer);
+
+    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+  #else
+    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+  #endif
+}
+
+void DGUSTxHandler::LongestPrint(DGUS_VP &vp) {
+  #if ENABLED(PRINTCOUNTER)
+    char buffer[21];
+    ExtUI::getLongestPrint_str(buffer);
+
+    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+  #else
+    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+  #endif
+}
+
+void DGUSTxHandler::FilamentUsed(DGUS_VP &vp) {
+  #if ENABLED(PRINTCOUNTER)
+    char buffer[21];
+    ExtUI::getFilamentUsed_str(buffer);
+
+    dgus_display.WriteString((uint16_t)vp.addr, buffer, vp.size);
+  #else
+    dgus_display.WriteStringPGM((uint16_t)vp.addr, DGUS_MSG_UNDEF, vp.size);
+  #endif
+}
+
+void DGUSTxHandler::WaitIcons(DGUS_VP &vp) {
+  uint16_t icons = 0;
+
+  if (printingIsPaused()
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      && did_pause_print
+    #endif
+  ) {
+    icons |= (uint16_t)DGUS_Data::WaitIcon::ABORT;
+
+    dgus_display.EnableControl(DGUS_Screen::WAIT,
+                               DGUSDisplay::POPUP_WINDOW,
+                               DGUS_Control::ABORT);
+  }
+  else {
+    dgus_display.DisableControl(DGUS_Screen::WAIT,
+                                DGUSDisplay::POPUP_WINDOW,
+                                DGUS_Control::ABORT);
+  }
+
+  if (dgus_screen_handler.wait_continue) {
+    icons |= (uint16_t)DGUS_Data::WaitIcon::CONTINUE;
+
+    dgus_display.EnableControl(DGUS_Screen::WAIT,
+                               DGUSDisplay::RETURN_KEY_CODE,
+                               DGUS_Control::CONTINUE);
+  }
+  else {
+    dgus_display.DisableControl(DGUS_Screen::WAIT,
+                                DGUSDisplay::RETURN_KEY_CODE,
+                                DGUS_Control::CONTINUE);
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(icons));
+}
+
+void DGUSTxHandler::FanSpeed(DGUS_VP &vp) {
+  uint16_t fan_speed;
+
+  switch (vp.addr) {
+    default: return;
+    case DGUS_Addr::FAN0_Speed: fan_speed = ExtUI::getTargetFan_percent(ExtUI::FAN0); break;
+  }
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(fan_speed));
+}
+
+void DGUSTxHandler::Volume(DGUS_VP &vp) {
+  const uint16_t volume = dgus_display.GetVolume();
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(volume));
+}
+
+void DGUSTxHandler::Brightness(DGUS_VP &vp) {
+  const uint16_t brightness = dgus_display.GetBrightness();
+
+  dgus_display.Write((uint16_t)vp.addr, Swap16(brightness));
+}
+
+void DGUSTxHandler::ExtraToString(DGUS_VP &vp) {
+  if (!vp.size || !vp.extra) return;
+
+  dgus_display.WriteString((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
+}
+
+void DGUSTxHandler::ExtraPGMToString(DGUS_VP &vp) {
+  if (!vp.size || !vp.extra) return;
+
+  dgus_display.WriteStringPGM((uint16_t)vp.addr, vp.extra, vp.size, true, false, false);
+}
+
+#endif // DGUS_LCD_UI_RELOADED
