commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
deleted file mode 100644
index e6cc227465..0000000000
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ /dev/null
@@ -1,1520 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if HAS_MARLINUI_HD44780
-
-/**
- * ultralcd_HD44780.cpp
- *
- * LCD display implementations for Hitachi HD44780.
- * These are the most common LCD character displays.
- */
-
-#include "ultralcd_HD44780.h"
-#include "../ultralcd.h"
-#include "../../libs/numtostr.h"
-
-#include "../../sd/cardreader.h"
-#include "../../module/temperature.h"
-#include "../../module/printcounter.h"
-#include "../../module/planner.h"
-#include "../../module/motion.h"
-
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-  #include "../../feature/filwidth.h"
-  #include "../../gcode/parser.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
-
-//
-// Create LCD instance and chipset-specific information
-//
-
-#if ENABLED(LCD_I2C_TYPE_PCF8575)
-
-  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_I2C_PIN_EN, LCD_I2C_PIN_RW, LCD_I2C_PIN_RS, LCD_I2C_PIN_D4, LCD_I2C_PIN_D5, LCD_I2C_PIN_D6, LCD_I2C_PIN_D7);
-
-#elif EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
-
-  LCD_CLASS lcd(LCD_I2C_ADDRESS
-    #ifdef DETECT_DEVICE
-      , 1
-    #endif
-  );
-
-#elif ENABLED(LCD_I2C_TYPE_PCA8574)
-
-  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);
-
-#elif ENABLED(SR_LCD_2W_NL)
-
-  // 2 wire Non-latching LCD SR from:
-  // https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
-
-  LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN
-    #if PIN_EXISTS(SR_STROBE)
-      , SR_STROBE_PIN
-    #endif
-  );
-
-#elif ENABLED(SR_LCD_3W_NL)
-
-  // NewLiquidCrystal was not working
-  // https://github.com/mikeshub/SailfishLCD
-  // uses the code directly from Sailfish
-
-  LCD_CLASS lcd(SR_STROBE_PIN, SR_DATA_PIN, SR_CLK_PIN);
-
-#elif ENABLED(LCM1602)
-
-  LCD_CLASS lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
-
-#else
-
-  // Standard direct-connected LCD implementations
-  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5, LCD_PINS_D6, LCD_PINS_D7);
-
-#endif
-
-static void createChar_P(const char c, const byte * const ptr) {
-  byte temp[8];
-  LOOP_L_N(i, 8)
-    temp[i] = pgm_read_byte(&ptr[i]);
-  lcd.createChar(c, temp);
-}
-
-#if ENABLED(LCD_PROGRESS_BAR)
-  #define LCD_STR_PROGRESS  "\x03\x04\x05"
-#endif
-
-#if ENABLED(LCD_USE_I2C_BUZZER)
-  void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    lcd.buzz(duration, freq);
-  }
-#endif
-
-void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
-  #if NONE(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
-    UNUSED(screen_charset);
-  #endif
-
-  // CHARSET_BOOT
-  #if ENABLED(SHOW_BOOTSCREEN)
-    const static PROGMEM byte corner[4][8] = { {
-      B00000,
-      B00000,
-      B00000,
-      B00000,
-      B00001,
-      B00010,
-      B00100,
-      B00100
-    }, {
-      B00000,
-      B00000,
-      B00000,
-      B11100,
-      B11100,
-      B01100,
-      B00100,
-      B00100
-    }, {
-      B00100,
-      B00010,
-      B00001,
-      B00000,
-      B00000,
-      B00000,
-      B00000,
-      B00000
-    }, {
-      B00100,
-      B01000,
-      B10000,
-      B00000,
-      B00000,
-      B00000,
-      B00000,
-      B00000
-    } };
-  #endif // SHOW_BOOTSCREEN
-
-  // CHARSET_INFO
-  const static PROGMEM byte bedTemp[8] = {
-    B00000,
-    B11111,
-    B10101,
-    B10001,
-    B10101,
-    B11111,
-    B00000,
-    B00000
-  };
-
-  const static PROGMEM byte degree[8] = {
-    B01100,
-    B10010,
-    B10010,
-    B01100,
-    B00000,
-    B00000,
-    B00000,
-    B00000
-  };
-
-  const static PROGMEM byte thermometer[8] = {
-    B00100,
-    B01010,
-    B01010,
-    B01010,
-    B01010,
-    B10001,
-    B10001,
-    B01110
-  };
-
-  const static PROGMEM byte uplevel[8] = {
-    B00100,
-    B01110,
-    B11111,
-    B00100,
-    B11100,
-    B00000,
-    B00000,
-    B00000
-  };
-
-  const static PROGMEM byte feedrate[8] = {
-    #if LCD_INFO_SCREEN_STYLE == 1
-      B00000,
-      B00100,
-      B10010,
-      B01001,
-      B10010,
-      B00100,
-      B00000,
-      B00000
-    #else
-      B11100,
-      B10000,
-      B11000,
-      B10111,
-      B00101,
-      B00110,
-      B00101,
-      B00000
-    #endif
-  };
-
-  const static PROGMEM byte clock[8] = {
-    B00000,
-    B01110,
-    B10011,
-    B10101,
-    B10001,
-    B01110,
-    B00000,
-    B00000
-  };
-
-  #if ENABLED(LCD_PROGRESS_BAR)
-
-    // CHARSET_INFO
-    const static PROGMEM byte progress[3][8] = { {
-      B00000,
-      B10000,
-      B10000,
-      B10000,
-      B10000,
-      B10000,
-      B10000,
-      B00000
-    }, {
-      B00000,
-      B10100,
-      B10100,
-      B10100,
-      B10100,
-      B10100,
-      B10100,
-      B00000
-    }, {
-      B00000,
-      B10101,
-      B10101,
-      B10101,
-      B10101,
-      B10101,
-      B10101,
-      B00000
-    } };
-
-  #endif // LCD_PROGRESS_BAR
-
-  #if BOTH(SDSUPPORT, HAS_LCD_MENU)
-
-    // CHARSET_MENU
-    const static PROGMEM byte refresh[8] = {
-      B00000,
-      B00110,
-      B11001,
-      B11000,
-      B00011,
-      B10011,
-      B01100,
-      B00000,
-    };
-    const static PROGMEM byte folder[8] = {
-      B00000,
-      B11100,
-      B11111,
-      B10001,
-      B10001,
-      B11111,
-      B00000,
-      B00000
-    };
-
-  #endif // SDSUPPORT
-
-  #if ENABLED(SHOW_BOOTSCREEN)
-    // Set boot screen corner characters
-    if (screen_charset == CHARSET_BOOT) {
-      for (uint8_t i = 4; i--;)
-        createChar_P(i, corner[i]);
-    }
-    else
-  #endif
-    { // Info Screen uses 5 special characters
-      createChar_P(LCD_STR_BEDTEMP[0], bedTemp);
-      createChar_P(LCD_STR_DEGREE[0], degree);
-      createChar_P(LCD_STR_THERMOMETER[0], thermometer);
-      createChar_P(LCD_STR_FEEDRATE[0], feedrate);
-      createChar_P(LCD_STR_CLOCK[0], clock);
-
-      #if ENABLED(LCD_PROGRESS_BAR)
-        if (screen_charset == CHARSET_INFO) { // 3 Progress bar characters for info screen
-          for (int16_t i = 3; i--;)
-            createChar_P(LCD_STR_PROGRESS[i], progress[i]);
-        }
-        else
-      #endif
-        {
-          createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if BOTH(SDSUPPORT, HAS_LCD_MENU)
-            // SD Card sub-menu special characters
-            createChar_P(LCD_STR_REFRESH[0], refresh);
-            createChar_P(LCD_STR_FOLDER[0], folder);
-          #endif
-        }
-    }
-
-}
-
-void MarlinUI::init_lcd() {
-
-  #if ENABLED(LCD_I2C_TYPE_PCF8575)
-    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-    #ifdef LCD_I2C_PIN_BL
-      lcd.setBacklightPin(LCD_I2C_PIN_BL, POSITIVE);
-      lcd.setBacklight(HIGH);
-    #endif
-
-  #elif ENABLED(LCD_I2C_TYPE_MCP23017)
-    lcd.setMCPType(LTI_TYPE_MCP23017);
-    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-    update_indicators();
-
-  #elif ENABLED(LCD_I2C_TYPE_MCP23008)
-    lcd.setMCPType(LTI_TYPE_MCP23008);
-    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-
-  #elif ENABLED(LCD_I2C_TYPE_PCA8574)
-    lcd.init();
-    lcd.backlight();
-
-  #else
-    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
-  #endif
-
-  set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
-
-  lcd.clear();
-}
-
-bool MarlinUI::detected() {
-  return (true
-    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
-      && lcd.LcdDetected() == 1
-    #endif
-  );
-}
-
-#if HAS_SLOW_BUTTONS
-  uint8_t MarlinUI::read_slow_buttons() {
-    #if ENABLED(LCD_I2C_TYPE_MCP23017)
-      // Reading these buttons is too slow for interrupt context
-      // so they are read during LCD update in the main loop.
-      uint8_t slow_bits = lcd.readButtons()
-        #if !BUTTON_EXISTS(ENC)
-          << B_I2C_BTN_OFFSET
-        #endif
-      ;
-      #if ENABLED(LCD_I2C_VIKI)
-        if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
-          slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
-      #endif
-      return slow_bits;
-    #endif // LCD_I2C_TYPE_MCP23017
-  }
-#endif
-
-void MarlinUI::clear_lcd() { lcd.clear(); }
-
-#if ENABLED(SHOW_BOOTSCREEN)
-
-  void lcd_erase_line(const lcd_uint_t line) {
-    lcd_moveto(0, line);
-    for (uint8_t i = LCD_WIDTH + 1; --i;)
-      lcd_put_wchar(' ');
-  }
-
-  // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
-  void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, PGM_P const text, const uint8_t len, const int16_t time) {
-    uint8_t slen = utf8_strlen_P(text);
-    if (slen < len) {
-      lcd_put_u8str_max_P(col, line, text, len);
-      for (; slen < len; ++slen) lcd_put_wchar(' ');
-      safe_delay(time);
-    }
-    else {
-      PGM_P p = text;
-      int dly = time / _MAX(slen, 1);
-      LOOP_LE_N(i, slen) {
-
-        // Print the text at the correct place
-        lcd_put_u8str_max_P(col, line, p, len);
-
-        // Fill with spaces
-        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_wchar(' ');
-
-        // Delay
-        safe_delay(dly);
-
-        // Advance to the next UTF8 valid position
-        p++;
-        while (!START_OF_UTF8_CHAR(pgm_read_byte(p))) p++;
-      }
-    }
-  }
-
-  static void logo_lines(PGM_P const extra) {
-    int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
-    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
-    lcd_put_u8str_P(indent, 1, PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
-    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
-  }
-
-  void MarlinUI::show_bootscreen() {
-    set_custom_characters(CHARSET_BOOT);
-    lcd.clear();
-
-    #define LCD_EXTRA_SPACE (LCD_WIDTH-8)
-
-    #define CENTER_OR_SCROLL(STRING,DELAY) \
-      lcd_erase_line(3); \
-      if (utf8_strlen(STRING) <= LCD_WIDTH) { \
-        lcd_put_u8str_P((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3, PSTR(STRING)); \
-        safe_delay(DELAY); \
-      } \
-      else { \
-        lcd_scroll(0, 3, PSTR(STRING), LCD_WIDTH, DELAY); \
-      }
-
-    //
-    // Show the Marlin logo with splash line 1
-    //
-    if (LCD_EXTRA_SPACE >= utf8_strlen(SHORT_BUILD_VERSION) + 1) {
-      //
-      // Show the Marlin logo, splash line1, and splash line 2
-      //
-      logo_lines(PSTR(" " SHORT_BUILD_VERSION));
-      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 2000);
-    }
-    else {
-      //
-      // Show the Marlin logo and short build version
-      // After a delay show the website URL
-      //
-      extern const char NUL_STR[];
-      logo_lines(NUL_STR);
-      CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
-      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);
-      #ifdef STRING_SPLASH_LINE3
-        CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
-      #endif
-    }
-
-    lcd.clear();
-    safe_delay(100);
-    set_custom_characters(CHARSET_INFO);
-    lcd.clear();
-  }
-
-#endif // SHOW_BOOTSCREEN
-
-void MarlinUI::draw_kill_screen() {
-  lcd_put_u8str(0, 0, status_message);
-  lcd_uint_t y = 2;
-  #if LCD_HEIGHT >= 4
-    lcd_put_u8str_P(0, y++, GET_TEXT(MSG_HALTED));
-  #endif
-  lcd_put_u8str_P(0, y, GET_TEXT(MSG_PLEASE_RESET));
-}
-
-//
-// Before homing, blink '123' <-> '???'.
-// Homed but unknown... '123' <-> '   '.
-// Homed and known, display constantly.
-//
-FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const bool blink) {
-  lcd_put_wchar('X' + uint8_t(axis));
-  if (blink)
-    lcd_put_u8str(value);
-  else {
-    if (!TEST(axis_homed, axis))
-      while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
-    else {
-      #if NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
-        if (!TEST(axis_known_position, axis))
-          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
-        else
-      #endif
-          lcd_put_u8str(value);
-    }
-  }
-}
-
-FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
-  #if HAS_HEATED_BED
-    const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
-    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
-                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
-  #else
-    const float t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
-  #endif
-
-  if (prefix >= 0) lcd_put_wchar(prefix);
-
-  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
-  lcd_put_wchar('/');
-
-  #if !HEATER_IDLE_HANDLER
-    UNUSED(blink);
-  #else
-    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
-      lcd_put_wchar(' ');
-      if (t2 >= 10) lcd_put_wchar(' ');
-      if (t2 >= 100) lcd_put_wchar(' ');
-    }
-    else
-  #endif
-      lcd_put_u8str(i16tostr3left(t2 + 0.5));
-
-  if (prefix >= 0) {
-    lcd_put_wchar(LCD_STR_DEGREE[0]);
-    lcd_put_wchar(' ');
-    if (t2 < 10) lcd_put_wchar(' ');
-  }
-}
-
-FORCE_INLINE void _draw_bed_status(const bool blink) {
-  _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
-}
-
-#if HAS_PRINT_PROGRESS
-
-  FORCE_INLINE void _draw_print_progress() {
-    const uint8_t progress = ui.get_progress_percent();
-    lcd_put_u8str_P(PSTR(TERN(SDSUPPORT, "SD", "P:")));
-    if (progress)
-      lcd_put_u8str(ui8tostr3rj(progress));
-    else
-      lcd_put_u8str_P(PSTR("---"));
-    lcd_put_wchar('%');
-  }
-
-#endif
-
-#if ENABLED(LCD_PROGRESS_BAR)
-
-  void MarlinUI::draw_progress_bar(const uint8_t percent) {
-    const int16_t tix = (int16_t)(percent * (LCD_WIDTH) * 3) / 100,
-              cel = tix / 3,
-              rem = tix % 3;
-    uint8_t i = LCD_WIDTH;
-    char msg[LCD_WIDTH + 1], b = ' ';
-    msg[LCD_WIDTH] = '\0';
-    while (i--) {
-      if (i == cel - 1)
-        b = LCD_STR_PROGRESS[2];
-      else if (i == cel && rem != 0)
-        b = LCD_STR_PROGRESS[rem - 1];
-      msg[i] = b;
-    }
-    lcd_put_u8str(msg);
-  }
-
-#endif // LCD_PROGRESS_BAR
-
-void MarlinUI::draw_status_message(const bool blink) {
-
-  lcd_moveto(0, LCD_HEIGHT - 1);
-
-  #if ENABLED(LCD_PROGRESS_BAR)
-
-    // Draw the progress bar if the message has shown long enough
-    // or if there is no message set.
-    if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !has_status()) {
-      const uint8_t progress = get_progress_percent();
-      if (progress > 2) return draw_progress_bar(progress);
-    }
-
-  #elif BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-
-    // Alternate Status message and Filament display
-    if (ELAPSED(millis(), next_filament_display)) {
-      lcd_put_u8str_P(PSTR("Dia "));
-      lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
-      lcd_put_u8str_P(PSTR(" V"));
-      lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
-      lcd_put_wchar('%');
-      return;
-    }
-
-  #endif // FILAMENT_LCD_DISPLAY && SDSUPPORT
-
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    static bool last_blink = false;
-
-    // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(status_message);
-
-    // If the string fits into the LCD, just print it and do not scroll it
-    if (slen <= LCD_WIDTH) {
-
-      // The string isn't scrolling and may not fill the screen
-      lcd_put_u8str(status_message);
-
-      // Fill the rest with spaces
-      while (slen < LCD_WIDTH) { lcd_put_wchar(' '); ++slen; }
-    }
-    else {
-      // String is larger than the available space in screen.
-
-      // Get a pointer to the next valid UTF8 character
-      // and the string remaining length
-      uint8_t rlen;
-      const char *stat = status_and_len(rlen);
-      lcd_put_u8str_max(stat, LCD_WIDTH);     // The string leaves space
-
-      // If the remaining string doesn't completely fill the screen
-      if (rlen < LCD_WIDTH) {
-        lcd_put_wchar('.');                   // Always at 1+ spaces left, draw a dot
-        uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
-        if (--chars) {                        // Draw a second dot if there's space
-          lcd_put_wchar('.');
-          if (--chars)
-            lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
-        }
-      }
-      if (last_blink != blink) {
-        last_blink = blink;
-        advance_status_scroll();
-      }
-    }
-  #else
-    UNUSED(blink);
-
-    // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(status_message);
-
-    // Just print the string to the LCD
-    lcd_put_u8str_max(status_message, LCD_WIDTH);
-
-    // Fill the rest with spaces if there are missing spaces
-    while (slen < LCD_WIDTH) {
-      lcd_put_wchar(' ');
-      ++slen;
-    }
-  #endif
-}
-
-/**
- *  LCD_INFO_SCREEN_STYLE 0 : Classic Status Screen
- *
- *  16x2   |000/000 B000/000|
- *         |0123456789012345|
- *
- *  16x4   |000/000 B000/000|
- *         |SD---%  Z 000.00|
- *         |F---%     T--:--|
- *         |0123456789012345|
- *
- *  20x2   |T000/000° B000/000° |
- *         |01234567890123456789|
- *
- *  20x4   |T000/000° B000/000° |
- *         |X 000 Y 000 Z000.000|
- *         |F---%  SD---% T--:--|
- *         |01234567890123456789|
- *
- *  LCD_INFO_SCREEN_STYLE 1 : Průša-style Status Screen
- *
- *  |T000/000°  Z 000.00 |
- *  |B000/000°  F---%    |
- *  |SD---%     T--:--   |
- *  |01234567890123456789|
- *
- *  |T000/000°  Z 000.00 |
- *  |T000/000°  F---%    |
- *  |B000/000°  SD---%   |
- *  |01234567890123456789|
- */
-
-void MarlinUI::draw_status_screen() {
-
-  const bool blink = get_blink();
-  lcd_moveto(0, 0);
-
-  #if LCD_INFO_SCREEN_STYLE == 0
-
-    // ========== Line 1 ==========
-
-    #if LCD_WIDTH < 20
-
-      //
-      // Hotend 0 Temperature
-      //
-      _draw_heater_status(H_E0, -1, blink);
-
-      //
-      // Hotend 1 or Bed Temperature
-      //
-      #if HAS_MULTI_HOTEND
-        lcd_moveto(8, 0);
-        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
-      #elif HAS_HEATED_BED
-        lcd_moveto(8, 0);
-        _draw_bed_status(blink);
-      #endif
-
-    #else // LCD_WIDTH >= 20
-
-      //
-      // Hotend 0 Temperature
-      //
-      _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
-
-      //
-      // Hotend 1 or Bed Temperature
-      //
-      #if HAS_MULTI_HOTEND
-        lcd_moveto(10, 0);
-        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
-      #elif HAS_HEATED_BED
-        lcd_moveto(10, 0);
-        _draw_bed_status(blink);
-      #endif
-
-    #endif // LCD_WIDTH >= 20
-
-    // ========== Line 2 ==========
-
-    #if LCD_HEIGHT > 2
-
-      #if LCD_WIDTH < 20
-
-        #if HAS_PRINT_PROGRESS
-          lcd_moveto(0, 2);
-          _draw_print_progress();
-        #endif
-
-      #else // LCD_WIDTH >= 20
-
-        lcd_moveto(0, 1);
-
-        // If the first line has two extruder temps,
-        // show more temperatures on the next line
-
-        #if HOTENDS > 2 || (HAS_MULTI_HOTEND && HAS_HEATED_BED)
-
-          #if HOTENDS > 2
-            _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
-            lcd_moveto(10, 1);
-          #endif
-
-          _draw_bed_status(blink);
-
-        #else // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
-
-          #if HAS_DUAL_MIXING
-
-            // Two-component mix / gradient instead of XY
-
-            char mixer_messages[12];
-            const char *mix_label;
-            #if ENABLED(GRADIENT_MIX)
-              if (mixer.gradient.enabled) {
-                mixer.update_mix_from_gradient();
-                mix_label = "Gr";
-              }
-              else
-            #endif
-              {
-                mixer.update_mix_from_vtool();
-                mix_label = "Mx";
-              }
-            sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
-            lcd_put_u8str(mixer_messages);
-
-          #else // !HAS_DUAL_MIXING
-
-            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive() || marlin_state == MF_SD_COMPLETE);
-
-            if (show_e_total) {
-              #if ENABLED(LCD_SHOW_E_TOTAL)
-                char tmp[20];
-                const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
-                sprintf_P(tmp, PSTR("E %ld%cm       "), uint32_t(_MAX(e_move_accumulator, 0.0f)) / escale, escale == 10 ? 'c' : 'm'); // 1234567mm
-                lcd_put_u8str(tmp);
-              #endif
-            }
-            else {
-              const xy_pos_t lpos = current_position.asLogical();
-              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-              lcd_put_wchar(' ');
-              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
-            }
-
-          #endif // !HAS_DUAL_MIXING
-
-        #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
-
-      #endif // LCD_WIDTH >= 20
-
-      lcd_moveto(LCD_WIDTH - 8, 1);
-      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
-
-      #if HAS_LEVELING && !HAS_HEATED_BED
-        lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
-      #endif
-
-    #endif // LCD_HEIGHT > 2
-
-    // ========== Line 3 ==========
-
-    #if LCD_HEIGHT > 3
-
-      lcd_put_wchar(0, 2, LCD_STR_FEEDRATE[0]);
-      lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-      lcd_put_wchar('%');
-
-      char buffer[14];
-      uint8_t timepos = 0;
-      #if ENABLED(SHOW_REMAINING_TIME)
-        const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
-        if (show_remain) {
-          #if ENABLED(USE_M73_REMAINING_TIME)
-            duration_t remaining = get_remaining_time();
-          #else
-            uint8_t progress = get_progress_percent();
-            uint32_t elapsed = print_job_timer.duration();
-            duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
-          #endif
-          const uint8_t len = remaining.toDigital(buffer);
-          timepos = LCD_WIDTH - 1 - len;
-          lcd_put_wchar(timepos, 2, 'R');
-        }
-      #else
-        constexpr bool show_remain = false;
-      #endif
-
-      if (!show_remain) {
-        duration_t elapsed = print_job_timer.duration();
-        const uint8_t len = elapsed.toDigital(buffer);
-        timepos = LCD_WIDTH - 1 - len;
-        lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
-      }
-      lcd_put_u8str(buffer);
-
-      #if LCD_WIDTH >= 20
-        lcd_moveto(timepos - 7, 2);
-        #if HAS_PRINT_PROGRESS
-          _draw_print_progress();
-        #else
-          char c;
-          uint16_t per;
-          #if HAS_FAN0
-            if (true
-              #if EXTRUDERS && ENABLED(ADAPTIVE_FAN_SLOWING)
-                && (blink || thermalManager.fan_speed_scaler[0] < 128)
-              #endif
-            ) {
-              uint16_t spd = thermalManager.fan_speed[0];
-              if (blink) c = 'F';
-              #if ENABLED(ADAPTIVE_FAN_SLOWING)
-                else { c = '*'; spd = thermalManager.scaledFanSpeed(0, spd); }
-              #endif
-              per = thermalManager.fanPercent(spd);
-            }
-            else
-          #endif
-            {
-              #if EXTRUDERS
-                c = 'E';
-                per = planner.flow_percentage[0];
-              #endif
-            }
-          lcd_put_wchar(c);
-          lcd_put_u8str(i16tostr3rj(per));
-          lcd_put_wchar('%');
-        #endif
-      #endif
-
-    #endif // LCD_HEIGHT > 3
-
-  #elif LCD_INFO_SCREEN_STYLE == 1
-
-    // ========== Line 1 ==========
-
-    //
-    // Hotend 0 Temperature
-    //
-    _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
-
-    //
-    // Z Coordinate
-    //
-    lcd_moveto(LCD_WIDTH - 9, 0);
-    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
-
-    #if HAS_LEVELING && (HAS_MULTI_HOTEND || !HAS_HEATED_BED)
-      lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
-    #endif
-
-    // ========== Line 2 ==========
-
-    //
-    // Hotend 1 or Bed Temperature
-    //
-    lcd_moveto(0, 1);
-    #if HAS_MULTI_HOTEND
-      _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
-    #elif HAS_HEATED_BED
-      _draw_bed_status(blink);
-    #endif
-
-    lcd_put_wchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
-    lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-    lcd_put_wchar('%');
-
-    // ========== Line 3 ==========
-
-    //
-    // SD Percent, Hotend 2, or Bed
-    //
-    lcd_moveto(0, 2);
-    #if HOTENDS > 2
-      _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
-    #elif HAS_MULTI_HOTEND && HAS_HEATED_BED
-      _draw_bed_status(blink);
-    #elif HAS_PRINT_PROGRESS
-      #define DREW_PRINT_PROGRESS
-      _draw_print_progress();
-    #endif
-
-    //
-    // Elapsed Time or SD Percent
-    //
-    lcd_moveto(LCD_WIDTH - 9, 2);
-    #if HAS_PRINT_PROGRESS && !defined(DREW_PRINT_PROGRESS)
-      _draw_print_progress();
-    #else
-      duration_t elapsed = print_job_timer.duration();
-      char buffer[14];
-      (void)elapsed.toDigital(buffer);
-      lcd_put_wchar(LCD_STR_CLOCK[0]);
-      lcd_put_u8str(buffer);
-    #endif
-
-  #endif // LCD_INFO_SCREEN_STYLE 1
-
-  // ========= Last Line ========
-
-  //
-  // Status Message (which may be a Progress Bar or Filament display)
-  //
-  draw_status_message(blink);
-}
-
-#if HAS_LCD_MENU
-
-  #include "../menu/menu.h"
-
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-    void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
-      if (row < LCD_HEIGHT) {
-        lcd_moveto(LCD_WIDTH - 9, row);
-        _draw_heater_status((heater_id_t)extruder, LCD_STR_THERMOMETER[0], get_blink());
-      }
-    }
-
-  #endif // ADVANCED_PAUSE_FEATURE
-
-  // Draw a static item with no left-right margin required. Centered by default.
-  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
-    int8_t n = LCD_WIDTH;
-    lcd_moveto(0, row);
-    const int8_t plen = pstr ? utf8_strlen_P(pstr) : 0,
-                 vlen = vstr ? utf8_strlen(vstr) : 0;
-    if (style & SS_CENTER) {
-      int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
-      while (--pad >= 0) { lcd_put_wchar(' '); n--; }
-    }
-    if (plen) n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
-    if (vlen) n -= lcd_put_u8str_max(vstr, n);
-    for (; n > 0; --n) lcd_put_wchar(' ');
-  }
-
-  // Draw a generic menu item with pre_char (if selected) and post_char
-  void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
-    lcd_put_wchar(0, row, sel ? pre_char : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2);
-    for (; n; --n) lcd_put_wchar(' ');
-    lcd_put_wchar(post_char);
-  }
-
-  // Draw a menu item with a (potentially) editable value
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const inStr, const bool pgm) {
-    const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
-    lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
-    if (vlen) {
-      lcd_put_wchar(':');
-      for (; n; --n) lcd_put_wchar(' ');
-      if (pgm) lcd_put_u8str_P(inStr); else lcd_put_u8str(inStr);
-    }
-  }
-
-  // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
-    ui.encoder_direction_normal();
-    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
-    if (value != nullptr) {
-      lcd_put_wchar(':'); n--;
-      const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
-      const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit
-      lcd_put_wchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
-      lcd_put_u8str(value);
-    }
-  }
-
-  // The Select Screen presents a prompt and two "buttons"
-  void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-    ui.draw_select_screen_prompt(pref, string, suff);
-    SETCURSOR(0, LCD_HEIGHT - 1);
-    lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
-    SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
-    lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
-  }
-
-  #if ENABLED(SDSUPPORT)
-
-    void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
-      lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-      constexpr uint8_t maxlen = LCD_WIDTH - 2;
-      uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
-      for (; n; --n) lcd_put_wchar(' ');
-      lcd_put_wchar(isDir ? LCD_STR_FOLDER[0] : ' ');
-    }
-
-  #endif
-
-  #if ENABLED(LCD_HAS_STATUS_INDICATORS)
-
-    void MarlinUI::update_indicators() {
-      // Set the LEDS - referred to as backlights by the LiquidTWI2 library
-      static uint8_t ledsprev = 0;
-      uint8_t leds = 0;
-
-      if (TERN0(HAS_HEATED_BED, thermalManager.degTargetBed() > 0)) leds |= LED_A;
-      if (TERN0(HAS_HOTEND, thermalManager.degTargetHotend(0) > 0)) leds |= LED_B;
-
-      #if HAS_FAN
-        if ( TERN0(HAS_FAN0, thermalManager.fan_speed[0])
-          || TERN0(HAS_FAN1, thermalManager.fan_speed[1])
-          || TERN0(HAS_FAN2, thermalManager.fan_speed[2])
-          || TERN0(HAS_FAN3, thermalManager.fan_speed[3])
-          || TERN0(HAS_FAN4, thermalManager.fan_speed[4])
-          || TERN0(HAS_FAN5, thermalManager.fan_speed[5])
-          || TERN0(HAS_FAN6, thermalManager.fan_speed[6])
-          || TERN0(HAS_FAN7, thermalManager.fan_speed[7])
-        ) leds |= LED_C;
-      #endif // HAS_FAN
-
-      if (TERN0(HAS_MULTI_HOTEND, thermalManager.degTargetHotend(1) > 0)) leds |= LED_C;
-
-      if (leds != ledsprev) {
-        lcd.setBacklight(leds);
-        ledsprev = leds;
-      }
-    }
-
-  #endif // LCD_HAS_STATUS_INDICATORS
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    #define HD44780_CHAR_WIDTH    5
-    #define HD44780_CHAR_HEIGHT   8
-    #define MESH_MAP_COLS         7
-    #define MESH_MAP_ROWS         4
-
-    #define CHAR_LINE_TOP         0
-    #define CHAR_LINE_BOT         1
-    #define CHAR_EDGE_L           2
-    #define CHAR_EDGE_R           3
-    #define CHAR_UL_UL            4
-    #define CHAR_LR_UL            5
-    #define CHAR_UL_LR            6
-    #define CHAR_LR_LR            7
-
-    #define TOP_LEFT         _BV(0)
-    #define TOP_RIGHT        _BV(1)
-    #define LOWER_LEFT       _BV(2)
-    #define LOWER_RIGHT      _BV(3)
-
-    /**
-     * Possible map screens:
-     *
-     * 16x2   |X000.00  Y000.00|
-     *        |(00,00)  Z00.000|
-     *
-     * 20x2   | X:000.00  Y:000.00 |
-     *        | (00,00)   Z:00.000 |
-     *
-     * 16x4   |+-------+(00,00)|
-     *        ||       |X000.00|
-     *        ||       |Y000.00|
-     *        |+-------+Z00.000|
-     *
-     * 20x4   | +-------+  (00,00) |
-     *        | |       |  X:000.00|
-     *        | |       |  Y:000.00|
-     *        | +-------+  Z:00.000|
-     */
-
-    typedef struct {
-      uint8_t custom_char_bits[HD44780_CHAR_HEIGHT];
-    } custom_char;
-
-    typedef struct {
-      lcd_uint_t column, row,
-                 x_pixel_offset, y_pixel_offset;
-      uint8_t x_pixel_mask;
-    } coordinate;
-
-    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location);
-    FORCE_INLINE static void clear_custom_char(custom_char * const cc) { ZERO(cc->custom_char_bits); }
-
-    coordinate pixel_location(int16_t x, int16_t y) {
-      coordinate ret_val;
-      int16_t xp, yp, r, c;
-
-      x++; y++; // +1 because lines on the left and top
-
-      c = x / (HD44780_CHAR_WIDTH);
-      r = y / (HD44780_CHAR_HEIGHT);
-
-      ret_val.column = c;
-      ret_val.row    = r;
-
-      xp = x - c * (HD44780_CHAR_WIDTH);                                    // Get the pixel offsets into the character cell
-      xp = HD44780_CHAR_WIDTH - 1 - xp;                                     // Column within relevant character cell (0 on the right)
-      yp = y - r * (HD44780_CHAR_HEIGHT);
-
-      ret_val.x_pixel_mask   = _BV(xp);
-      ret_val.x_pixel_offset = xp;
-      ret_val.y_pixel_offset = yp;
-      return ret_val;
-    }
-
-    inline coordinate pixel_location(const lcd_uint_t x, const lcd_uint_t y) { return pixel_location((int16_t)x, (int16_t)y); }
-
-    void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const lcd_uint_t x, const lcd_uint_t y) {
-      add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
-      lcd.createChar(c, (uint8_t*)&chrdata);
-      lcd_put_wchar(x, y, c);
-    }
-
-    void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
-
-      #if LCD_WIDTH >= 20
-        #define _LCD_W_POS 12
-        #define _PLOT_X 1
-        #define _MAP_X 3
-        #define _LABEL(C,X,Y) lcd_put_u8str_P(X, Y, C)
-        #define _XLABEL(X,Y) _LABEL(X_LBL,X,Y)
-        #define _YLABEL(X,Y) _LABEL(Y_LBL,X,Y)
-        #define _ZLABEL(X,Y) _LABEL(Z_LBL,X,Y)
-      #else
-        #define _LCD_W_POS 8
-        #define _PLOT_X 0
-        #define _MAP_X 1
-        #define _LABEL(X,Y,C) lcd_put_wchar(X, Y, C)
-        #define _XLABEL(X,Y) _LABEL('X',X,Y)
-        #define _YLABEL(X,Y) _LABEL('Y',X,Y)
-        #define _ZLABEL(X,Y) _LABEL('Z',X,Y)
-      #endif
-
-      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
-
-        /**
-         * Show X and Y positions
-         */
-        _XLABEL(_PLOT_X, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
-        _YLABEL(_LCD_W_POS, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
-
-        lcd_moveto(_PLOT_X, 0);
-
-      #else // 16x4 or 20x4 display
-
-        coordinate upper_left, lower_right, bottom_right_corner;
-        custom_char new_char;
-        uint8_t i, n, n_rows, n_cols;
-        lcd_uint_t j, k, l, m, bottom_line, right_edge,
-                   x_map_pixels, y_map_pixels,
-                   pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
-                   suppress_x_offset = 0, suppress_y_offset = 0;
-
-        const uint8_t y_plot_inv = (GRID_MAX_POINTS_Y - 1) - y_plot;
-
-        upper_left.column  = 0;
-        upper_left.row     = 0;
-        lower_right.column = 0;
-        lower_right.row    = 0;
-
-        clear_lcd();
-
-        x_map_pixels = (HD44780_CHAR_WIDTH) * (MESH_MAP_COLS) - 2;          // Minus 2 because we are drawing a box around the map
-        y_map_pixels = (HD44780_CHAR_HEIGHT) * (MESH_MAP_ROWS) - 2;
-
-        pixels_per_x_mesh_pnt = x_map_pixels / (GRID_MAX_POINTS_X);
-        pixels_per_y_mesh_pnt = y_map_pixels / (GRID_MAX_POINTS_Y);
-
-        if (pixels_per_x_mesh_pnt >= HD44780_CHAR_WIDTH) {                  // There are only 2 custom characters available, so the X
-          pixels_per_x_mesh_pnt = HD44780_CHAR_WIDTH;                       // Size of the mesh point needs to fit within them independent
-          suppress_x_offset = 1;                                            // Of where the starting pixel is located.
-        }
-
-        if (pixels_per_y_mesh_pnt >= HD44780_CHAR_HEIGHT) {                 // There are only 2 custom characters available, so the Y
-          pixels_per_y_mesh_pnt = HD44780_CHAR_HEIGHT;                      // Size of the mesh point needs to fit within them independent
-          suppress_y_offset = 1;                                            // Of where the starting pixel is located.
-        }
-
-        x_map_pixels = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X);         // Now we have the right number of pixels to make both
-        y_map_pixels = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y);         // Directions fit nicely
-
-        right_edge   = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X) + 1;     // Find location of right edge within the character cell
-        bottom_line  = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 1;     // Find location of bottome line within the character cell
-
-        n_rows = bottom_line / (HD44780_CHAR_HEIGHT) + 1;
-        n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;
-
-        for (i = 0; i < n_cols; i++) {
-          lcd_put_wchar(i, 0, CHAR_LINE_TOP);                               // Box Top line
-          lcd_put_wchar(i, n_rows - 1, CHAR_LINE_BOT);                      // Box Bottom line
-        }
-
-        for (j = 0; j < n_rows; j++) {
-          lcd_put_wchar(0, j, CHAR_EDGE_L);                                 // Box Left edge
-          lcd_put_wchar(n_cols - 1, j, CHAR_EDGE_R);                        // Box Right edge
-        }
-
-        /**
-         * If the entire 4th row is not in use, do not put vertical bars all the way down to the bottom of the display
-         */
-
-        k = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 2;
-        l = (HD44780_CHAR_HEIGHT) * n_rows;
-        if (l > k && l - k >= (HD44780_CHAR_HEIGHT) / 2) {
-          lcd_put_wchar(0, n_rows - 1, ' ');                                // Box Left edge
-          lcd_put_wchar(n_cols - 1, n_rows - 1, ' ');                       // Box Right edge
-        }
-
-        clear_custom_char(&new_char);
-        new_char.custom_char_bits[0] = 0b11111U;                            // Char #0 is used for the box top line
-        lcd.createChar(CHAR_LINE_TOP, (uint8_t*)&new_char);
-
-        clear_custom_char(&new_char);
-        k = (GRID_MAX_POINTS_Y) * pixels_per_y_mesh_pnt + 1;                // Row of pixels for the bottom box line
-        l = k % (HD44780_CHAR_HEIGHT);                                      // Row within relevant character cell
-        new_char.custom_char_bits[l] = 0b11111U;                            // Char #1 is used for the box bottom line
-        lcd.createChar(CHAR_LINE_BOT, (uint8_t*)&new_char);
-
-        clear_custom_char(&new_char);
-        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
-          new_char.custom_char_bits[j] = 0b10000U;                          // Char #2 is used for the box left edge
-        lcd.createChar(CHAR_EDGE_L, (uint8_t*)&new_char);
-
-        clear_custom_char(&new_char);
-        m = (GRID_MAX_POINTS_X) * pixels_per_x_mesh_pnt + 1;                // Column of pixels for the right box line
-        n = m % (HD44780_CHAR_WIDTH);                                       // Column within relevant character cell
-        i = HD44780_CHAR_WIDTH - 1 - n;                                     // Column within relevant character cell (0 on the right)
-        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
-          new_char.custom_char_bits[j] = (uint8_t)_BV(i);                   // Char #3 is used for the box right edge
-        lcd.createChar(CHAR_EDGE_R, (uint8_t*)&new_char);
-
-        i = x_plot * pixels_per_x_mesh_pnt - suppress_x_offset;
-        j = y_plot_inv * pixels_per_y_mesh_pnt - suppress_y_offset;
-        upper_left = pixel_location(i, j);
-
-        k = (x_plot + 1) * pixels_per_x_mesh_pnt - 1 - suppress_x_offset;
-        l = (y_plot_inv + 1) * pixels_per_y_mesh_pnt - 1 - suppress_y_offset;
-        lower_right = pixel_location(k, l);
-
-        bottom_right_corner = pixel_location(x_map_pixels, y_map_pixels);
-
-        /**
-         * First, handle the simple case where everything is within a single character cell.
-         * If part of the Mesh Plot is outside of this character cell, we will follow up
-         * and deal with that next.
-         */
-
-        clear_custom_char(&new_char);
-        const lcd_uint_t ypix = _MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
-        for (j = upper_left.y_pixel_offset; j < ypix; j++) {
-          i = upper_left.x_pixel_mask;
-          for (k = 0; k < pixels_per_x_mesh_pnt; k++) {
-            new_char.custom_char_bits[j] |= i;
-            i >>= 1;
-          }
-        }
-
-        prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_LEFT, CHAR_UL_UL, upper_left.column, upper_left.row);
-
-        /**
-         * Next, check for two side by side character cells being used to display the Mesh Point
-         * If found...  do the right hand character cell next.
-         */
-        if (upper_left.column == lower_right.column - 1) {
-          l = upper_left.x_pixel_offset;
-          clear_custom_char(&new_char);
-          for (j = upper_left.y_pixel_offset; j < ypix; j++) {
-            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
-            for (k = 0; k < pixels_per_x_mesh_pnt - 1 - l; k++) {
-              new_char.custom_char_bits[j] |= i;
-              i >>= 1;
-            }
-          }
-          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_RIGHT, CHAR_LR_UL, lower_right.column, upper_left.row);
-        }
-
-        /**
-         * Next, check for two character cells stacked on top of each other being used to display the Mesh Point
-         */
-        if (upper_left.row == lower_right.row - 1) {
-          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
-          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
-          clear_custom_char(&new_char);
-          for (j = 0; j < k; j++) {
-            i = upper_left.x_pixel_mask;
-            for (m = 0; m < pixels_per_x_mesh_pnt; m++) {                   // Fill in the top side of the bottom character cell
-              new_char.custom_char_bits[j] |= i;
-              if (!(i >>= 1)) break;
-            }
-          }
-          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_LEFT, CHAR_UL_LR, upper_left.column, lower_right.row);
-        }
-
-        /**
-         * Next, check for four character cells being used to display the Mesh Point.  If that is
-         * what is here, we work to fill in the character cell that is down one and to the right one
-         * from the upper_left character cell.
-         */
-
-        if (upper_left.column == lower_right.column - 1 && upper_left.row == lower_right.row - 1) {
-          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
-          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
-          clear_custom_char(&new_char);
-          for (j = 0; j < k; j++) {
-            l = upper_left.x_pixel_offset;
-            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
-            for (m = 0; m < pixels_per_x_mesh_pnt - 1 - l; m++) {           // Fill in the top side of the bottom character cell
-              new_char.custom_char_bits[j] |= i;
-              i >>= 1;
-            }
-          }
-          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_RIGHT, CHAR_LR_LR, lower_right.column, lower_right.row);
-        }
-
-      #endif
-
-      /**
-       * Print plot position
-       */
-      lcd_put_wchar(_LCD_W_POS, 0, '(');
-      lcd_put_u8str(ui8tostr3rj(x_plot));
-      lcd_put_wchar(',');
-      lcd_put_u8str(ui8tostr3rj(y_plot));
-      lcd_put_wchar(')');
-
-      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
-
-        /**
-         * Print Z values
-         */
-        _ZLABEL(_LCD_W_POS, 1);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
-        else
-          lcd_put_u8str_P(PSTR(" -----"));
-
-      #else                 // 16x4 or 20x4 display
-
-        /**
-         * Show all values at right of screen
-         */
-        _XLABEL(_LCD_W_POS, 1);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
-        _YLABEL(_LCD_W_POS, 2);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
-
-        /**
-         * Show the location value
-         */
-        _ZLABEL(_LCD_W_POS, 3);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
-        else
-          lcd_put_u8str_P(PSTR(" -----"));
-
-      #endif // LCD_HEIGHT > 3
-    }
-
-    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location) {
-      uint8_t i, k;
-      int16_t n_rows = lr.row    - ul.row    + 1,
-              n_cols = lr.column - ul.column + 1;
-
-      /**
-       * Check if Top line of box needs to be filled in
-       */
-
-      if (ul.row == 0 && (cell_location & (TOP_LEFT|TOP_RIGHT))) {   // Only fill in the top line for the top character cells
-
-        if (n_cols == 1) {
-          if (ul.column != brc.column)
-            custom.custom_char_bits[0] = 0xFF;                              // Single column in middle
-          else
-            for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)       // Single column on right side
-              SBI(custom.custom_char_bits[0], i);
-        }
-        else if ((cell_location & TOP_LEFT) || lr.column != brc.column)     // Multiple column in the middle or with right cell in middle
-          custom.custom_char_bits[0] = 0xFF;
-        else
-          for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)
-            SBI(custom.custom_char_bits[0], i);
-      }
-
-      /**
-       * Check if left line of box needs to be filled in
-       */
-      if (cell_location & (TOP_LEFT|LOWER_LEFT)) {
-        if (ul.column == 0) {                                               // Left column of characters on LCD Display
-          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT; // If it isn't the last row... do the full character cell
-          for (i = 0; i < k; i++)
-            SBI(custom.custom_char_bits[i], HD44780_CHAR_WIDTH - 1);
-        }
-      }
-
-      /**
-       * Check if bottom line of box needs to be filled in
-       */
-
-      // Single row of mesh plot cells
-      if (n_rows == 1 /* && (cell_location & (TOP_LEFT|TOP_RIGHT)) */ && ul.row == brc.row) {
-        if (n_cols == 1)                                                    // Single row, single column case
-          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
-        else if (cell_location & TOP_RIGHT)                                 // Single row, multiple column case
-          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
-        else                                                                // Single row, left of multiple columns
-          k = 0x01;
-        while (k < _BV(HD44780_CHAR_WIDTH)) {
-          custom.custom_char_bits[brc.y_pixel_offset] |= k;
-          k <<= 1;
-        }
-      }
-
-      // Double row of characters on LCD Display
-      // And this is a bottom custom character
-      if (n_rows == 2 && (cell_location & (LOWER_LEFT|LOWER_RIGHT)) && lr.row == brc.row) {
-        if (n_cols == 1)                                                    // Double row, single column case
-          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
-        else if (cell_location & LOWER_RIGHT)                               // Double row, multiple column case
-          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
-        else                                                                // Double row, left of multiple columns
-          k = 0x01;
-        while (k < _BV(HD44780_CHAR_WIDTH)) {
-          custom.custom_char_bits[brc.y_pixel_offset] |= k;
-          k <<= 1;
-        }
-      }
-
-      /**
-       * Check if right line of box needs to be filled in
-       */
-
-      // Nothing to do if the lower right part of the mesh pnt isn't in the same column as the box line
-      if (lr.column == brc.column) {
-        // This mesh point is in the same character cell as the right box line
-        if (ul.column == brc.column || (cell_location & (TOP_RIGHT|LOWER_RIGHT))) {
-          // If not the last row... do the full character cell
-          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT;
-          for (i = 0; i < k; i++) custom.custom_char_bits[i] |= brc.x_pixel_mask;
-        }
-      }
-    }
-
-  #endif // AUTO_BED_LEVELING_UBL
-
-#endif // HAS_LCD_MENU
-
-#endif // HAS_MARLINUI_HD44780

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 3dc0925b43..e6cc227465 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_CHARACTER_LCD
+#if HAS_MARLINUI_HD44780
 
 /**
  * ultralcd_HD44780.cpp
@@ -1517,4 +1517,4 @@ void MarlinUI::draw_status_screen() {
 
 #endif // HAS_LCD_MENU
 
-#endif // HAS_CHARACTER_LCD
+#endif // HAS_MARLINUI_HD44780

commit 24d8daa01bfbb18b039045775f8fc7a33608d923
Author: deram <deram@iki.fi>
Date:   Thu Sep 17 13:41:13 2020 +0300

    SHOW_REMAINING_TIME for HD44780 character LCD (#19416)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 0a1177d63e..3dc0925b43 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -845,10 +845,31 @@ void MarlinUI::draw_status_screen() {
       lcd_put_wchar('%');
 
       char buffer[14];
-      duration_t elapsed = print_job_timer.duration();
-      const uint8_t len = elapsed.toDigital(buffer),
-                    timepos = LCD_WIDTH - len - 1;
-      lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
+      uint8_t timepos = 0;
+      #if ENABLED(SHOW_REMAINING_TIME)
+        const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
+        if (show_remain) {
+          #if ENABLED(USE_M73_REMAINING_TIME)
+            duration_t remaining = get_remaining_time();
+          #else
+            uint8_t progress = get_progress_percent();
+            uint32_t elapsed = print_job_timer.duration();
+            duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
+          #endif
+          const uint8_t len = remaining.toDigital(buffer);
+          timepos = LCD_WIDTH - 1 - len;
+          lcd_put_wchar(timepos, 2, 'R');
+        }
+      #else
+        constexpr bool show_remain = false;
+      #endif
+
+      if (!show_remain) {
+        duration_t elapsed = print_job_timer.duration();
+        const uint8_t len = elapsed.toDigital(buffer);
+        timepos = LCD_WIDTH - 1 - len;
+        lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
+      }
       lcd_put_u8str(buffer);
 
       #if LCD_WIDTH >= 20

commit 979876e958e73e642b51eb655461c92947fe1deb
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Sep 14 16:58:39 2020 +1200

    Improve temperature runaway, idle timeout (#19339)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 81ba4653a1..0a1177d63e 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -521,7 +521,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
 
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
-    const bool isBed = heater_id < 0;
+    const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
     const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
                 t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
   #else
@@ -536,14 +536,7 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
   #if !HEATER_IDLE_HANDLER
     UNUSED(blink);
   #else
-    const bool is_idle = (
-      #if HAS_HEATED_BED
-        isBed ? thermalManager.bed_idle.timed_out :
-      #endif
-      thermalManager.hotend_idle[heater_id].timed_out
-    );
-
-    if (!blink && is_idle) {
+    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
       lcd_put_wchar(' ');
       if (t2 >= 10) lcd_put_wchar(' ');
       if (t2 >= 100) lcd_put_wchar(' ');
@@ -560,27 +553,14 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
 }
 
 FORCE_INLINE void _draw_bed_status(const bool blink) {
-  _draw_heater_status(H_BED, (
-      #if HAS_LEVELING
-        planner.leveling_active && blink ? '_' :
-      #endif
-      LCD_STR_BEDTEMP[0]
-    ),
-    blink
-  );
+  _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
 }
 
 #if HAS_PRINT_PROGRESS
 
   FORCE_INLINE void _draw_print_progress() {
     const uint8_t progress = ui.get_progress_percent();
-    lcd_put_u8str_P(PSTR(
-      #if ENABLED(SDSUPPORT)
-        "SD"
-      #elif ENABLED(LCD_SET_PROGRESS_MANUALLY)
-        "P:"
-      #endif
-    ));
+    lcd_put_u8str_P(PSTR(TERN(SDSUPPORT, "SD", "P:")));
     if (progress)
       lcd_put_u8str(ui8tostr3rj(progress));
     else

commit 49ca16c3fb103e8e29f64107ba664aa82917b9f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 13 18:06:14 2020 -0500

    heater_ind_t => heater_id_t

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 22dd63f68c..81ba4653a1 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -519,13 +519,13 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
   }
 }
 
-FORCE_INLINE void _draw_heater_status(const heater_ind_t heater, const char prefix, const bool blink) {
+FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
-    const bool isBed = heater < 0;
-    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater)),
-                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater));
+    const bool isBed = heater_id < 0;
+    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
+                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
   #else
-    const float t1 = thermalManager.degHotend(heater), t2 = thermalManager.degTargetHotend(heater);
+    const float t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
   #endif
 
   if (prefix >= 0) lcd_put_wchar(prefix);
@@ -540,7 +540,7 @@ FORCE_INLINE void _draw_heater_status(const heater_ind_t heater, const char pref
       #if HAS_HEATED_BED
         isBed ? thermalManager.bed_idle.timed_out :
       #endif
-      thermalManager.hotend_idle[heater].timed_out
+      thermalManager.hotend_idle[heater_id].timed_out
     );
 
     if (!blink && is_idle) {
@@ -990,7 +990,7 @@ void MarlinUI::draw_status_screen() {
     void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
       if (row < LCD_HEIGHT) {
         lcd_moveto(LCD_WIDTH - 9, row);
-        _draw_heater_status((heater_ind_t)extruder, LCD_STR_THERMOMETER[0], get_blink());
+        _draw_heater_status((heater_id_t)extruder, LCD_STR_THERMOMETER[0], get_blink());
       }
     }
 

commit c2d5b63a9882dc02f41017a5b2f24363a55fef8d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 8 18:21:44 2020 -0500

    Fix up STATIC_ITEM (#18962)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index a924528c30..22dd63f68c 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -997,15 +997,17 @@ void MarlinUI::draw_status_screen() {
   #endif // ADVANCED_PAUSE_FEATURE
 
   // Draw a static item with no left-right margin required. Centered by default.
-  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
-    if ((style & SS_CENTER) && !valstr) {
-      int8_t pad = (LCD_WIDTH - utf8_strlen_P(pstr)) / 2;
+    const int8_t plen = pstr ? utf8_strlen_P(pstr) : 0,
+                 vlen = vstr ? utf8_strlen(vstr) : 0;
+    if (style & SS_CENTER) {
+      int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }
-    n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
-    if (valstr) n -= lcd_put_u8str_max(valstr, n);
+    if (plen) n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
+    if (vlen) n -= lcd_put_u8str_max(vstr, n);
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 7804914d66..a924528c30 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 0e1cb10909b47d939d0766c35cdd3cbbd1d37def
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 13 19:59:32 2020 -0500

    Fix / improve menu items (#18644)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 5b1de8008a..7804914d66 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1032,13 +1032,12 @@ void MarlinUI::draw_status_screen() {
   // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
   void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
-
     uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
     if (value != nullptr) {
-      lcd_put_wchar(':');
-      int len = utf8_strlen(value);
-      const lcd_uint_t valrow = (n < len + 1) ? 2 : 1;          // Value on the next row if it won't fit
-      lcd_put_wchar((LCD_WIDTH - 1) - (len + 1), valrow, ' ');  // Right-justified, padded, leading space
+      lcd_put_wchar(':'); n--;
+      const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
+      const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit
+      lcd_put_wchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
       lcd_put_u8str(value);
     }
   }

commit b0c6cfb0511b8d71fec26ab91cd945f3d623b3c0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 9 10:11:57 2020 +0200

    MarlinUI support for up to 5 Material Presets (#18488)
    
    - Add `I` preset parameter to `G26`, `M106`, `M140`, and `M190`.
    - Extend menu items to permit a string interpolation.
    - Keep material names in a list and interpolate in menu items.
    - Extend material presets to support up to 5 predefined materials.
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 21e8130850..5b1de8008a 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1004,7 +1004,7 @@ void MarlinUI::draw_status_screen() {
       int8_t pad = (LCD_WIDTH - utf8_strlen_P(pstr)) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }
-    n = lcd_put_u8str_ind_P(pstr, itemIndex, n);
+    n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
     if (valstr) n -= lcd_put_u8str_max(valstr, n);
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
@@ -1012,20 +1012,20 @@ void MarlinUI::draw_status_screen() {
   // Draw a generic menu item with pre_char (if selected) and post_char
   void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
     lcd_put_wchar(0, row, sel ? pre_char : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, LCD_WIDTH - 2);
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2);
     for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
   // Draw a menu item with a (potentially) editable value
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
-    const uint8_t vlen = data ? (pgm ? utf8_strlen_P(data) : utf8_strlen(data)) : 0;
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const inStr, const bool pgm) {
+    const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, LCD_WIDTH - 2 - vlen);
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
     if (vlen) {
       lcd_put_wchar(':');
       for (; n; --n) lcd_put_wchar(' ');
-      if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
+      if (pgm) lcd_put_u8str_P(inStr); else lcd_put_u8str(inStr);
     }
   }
 
@@ -1033,7 +1033,7 @@ void MarlinUI::draw_status_screen() {
   void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
 
-    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, LCD_WIDTH - 1);
+    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
     if (value != nullptr) {
       lcd_put_wchar(':');
       int len = utf8_strlen(value);

commit f445bc26e52de36239e595ee3fbd2d25abc97258
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 25 16:39:22 2020 -0500

    Minor LCD cleanup, improvement

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 18befefc13..21e8130850 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -824,13 +824,9 @@ void MarlinUI::draw_status_screen() {
 
           #else // !HAS_DUAL_MIXING
 
-            if (TERN1(LCD_SHOW_E_TOTAL, !printingIsActive())) {
-              const xy_pos_t lpos = current_position.asLogical();
-              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-              lcd_put_wchar(' ');
-              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
-            }
-            else {
+            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive() || marlin_state == MF_SD_COMPLETE);
+
+            if (show_e_total) {
               #if ENABLED(LCD_SHOW_E_TOTAL)
                 char tmp[20];
                 const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
@@ -838,6 +834,12 @@ void MarlinUI::draw_status_screen() {
                 lcd_put_u8str(tmp);
               #endif
             }
+            else {
+              const xy_pos_t lpos = current_position.asLogical();
+              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
+              lcd_put_wchar(' ');
+              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+            }
 
           #endif // !HAS_DUAL_MIXING
 

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index ff76741ce7..18befefc13 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1072,7 +1072,7 @@ void MarlinUI::draw_status_screen() {
       if (TERN0(HAS_HEATED_BED, thermalManager.degTargetBed() > 0)) leds |= LED_A;
       if (TERN0(HAS_HOTEND, thermalManager.degTargetHotend(0) > 0)) leds |= LED_B;
 
-      #if FAN_COUNT > 0
+      #if HAS_FAN
         if ( TERN0(HAS_FAN0, thermalManager.fan_speed[0])
           || TERN0(HAS_FAN1, thermalManager.fan_speed[1])
           || TERN0(HAS_FAN2, thermalManager.fan_speed[2])
@@ -1082,7 +1082,7 @@ void MarlinUI::draw_status_screen() {
           || TERN0(HAS_FAN6, thermalManager.fan_speed[6])
           || TERN0(HAS_FAN7, thermalManager.fan_speed[7])
         ) leds |= LED_C;
-      #endif // FAN_COUNT > 0
+      #endif // HAS_FAN
 
       if (TERN0(HAS_MULTI_HOTEND, thermalManager.degTargetHotend(1) > 0)) leds |= LED_C;
 

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index ac4cd63322..ff76741ce7 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -275,7 +275,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // LCD_PROGRESS_BAR
 
-  #if ENABLED(SDSUPPORT) && HAS_LCD_MENU
+  #if BOTH(SDSUPPORT, HAS_LCD_MENU)
 
     // CHARSET_MENU
     const static PROGMEM byte refresh[8] = {
@@ -325,7 +325,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       #endif
         {
           createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if ENABLED(SDSUPPORT) && HAS_LCD_MENU
+          #if BOTH(SDSUPPORT, HAS_LCD_MENU)
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
             createChar_P(LCD_STR_FOLDER[0], folder);

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 905a72b053..ac4cd63322 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -802,7 +802,7 @@ void MarlinUI::draw_status_screen() {
 
         #else // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
 
-          #if DUAL_MIXING_EXTRUDER
+          #if HAS_DUAL_MIXING
 
             // Two-component mix / gradient instead of XY
 
@@ -822,13 +822,9 @@ void MarlinUI::draw_status_screen() {
             sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
             lcd_put_u8str(mixer_messages);
 
-          #else // !DUAL_MIXING_EXTRUDER
+          #else // !HAS_DUAL_MIXING
 
-            if (true
-              #if ENABLED(LCD_SHOW_E_TOTAL)
-                && !printingIsActive()
-              #endif
-            ) {
+            if (TERN1(LCD_SHOW_E_TOTAL, !printingIsActive())) {
               const xy_pos_t lpos = current_position.asLogical();
               _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
               lcd_put_wchar(' ');
@@ -843,7 +839,7 @@ void MarlinUI::draw_status_screen() {
               #endif
             }
 
-          #endif // !DUAL_MIXING_EXTRUDER
+          #endif // !HAS_DUAL_MIXING
 
         #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
 
@@ -1073,46 +1069,22 @@ void MarlinUI::draw_status_screen() {
       static uint8_t ledsprev = 0;
       uint8_t leds = 0;
 
-      #if HAS_HEATED_BED
-        if (thermalManager.degTargetBed() > 0) leds |= LED_A;
-      #endif
-
-      #if HAS_HOTEND
-        if (thermalManager.degTargetHotend(0) > 0) leds |= LED_B;
-      #endif
+      if (TERN0(HAS_HEATED_BED, thermalManager.degTargetBed() > 0)) leds |= LED_A;
+      if (TERN0(HAS_HOTEND, thermalManager.degTargetHotend(0) > 0)) leds |= LED_B;
 
       #if FAN_COUNT > 0
-        if (0
-          #if HAS_FAN0
-            || thermalManager.fan_speed[0]
-          #endif
-          #if HAS_FAN1
-            || thermalManager.fan_speed[1]
-          #endif
-          #if HAS_FAN2
-            || thermalManager.fan_speed[2]
-          #endif
-          #if HAS_FAN3
-            || thermalManager.fan_speed[3]
-          #endif
-          #if HAS_FAN4
-            || thermalManager.fan_speed[4]
-          #endif
-          #if HAS_FAN5
-            || thermalManager.fan_speed[5]
-          #endif
-          #if HAS_FAN6
-            || thermalManager.fan_speed[6]
-          #endif
-          #if HAS_FAN7
-            || thermalManager.fan_speed[7]
-          #endif
+        if ( TERN0(HAS_FAN0, thermalManager.fan_speed[0])
+          || TERN0(HAS_FAN1, thermalManager.fan_speed[1])
+          || TERN0(HAS_FAN2, thermalManager.fan_speed[2])
+          || TERN0(HAS_FAN3, thermalManager.fan_speed[3])
+          || TERN0(HAS_FAN4, thermalManager.fan_speed[4])
+          || TERN0(HAS_FAN5, thermalManager.fan_speed[5])
+          || TERN0(HAS_FAN6, thermalManager.fan_speed[6])
+          || TERN0(HAS_FAN7, thermalManager.fan_speed[7])
         ) leds |= LED_C;
       #endif // FAN_COUNT > 0
 
-      #if HAS_MULTI_HOTEND
-        if (thermalManager.degTargetHotend(1) > 0) leds |= LED_C;
-      #endif
+      if (TERN0(HAS_MULTI_HOTEND, thermalManager.degTargetHotend(1) > 0)) leds |= LED_C;
 
       if (leds != ledsprev) {
         lcd.setBacklight(leds);

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 3c89d1803c..905a72b053 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -745,7 +745,7 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 1 or Bed Temperature
       //
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         lcd_moveto(8, 0);
         _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
       #elif HAS_HEATED_BED
@@ -763,7 +763,7 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 1 or Bed Temperature
       //
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         lcd_moveto(10, 0);
         _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
       #elif HAS_HEATED_BED
@@ -791,7 +791,7 @@ void MarlinUI::draw_status_screen() {
         // If the first line has two extruder temps,
         // show more temperatures on the next line
 
-        #if HOTENDS > 2 || (HOTENDS > 1 && HAS_HEATED_BED)
+        #if HOTENDS > 2 || (HAS_MULTI_HOTEND && HAS_HEATED_BED)
 
           #if HOTENDS > 2
             _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
@@ -924,7 +924,7 @@ void MarlinUI::draw_status_screen() {
     lcd_moveto(LCD_WIDTH - 9, 0);
     _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
 
-    #if HAS_LEVELING && (HOTENDS > 1 || !HAS_HEATED_BED)
+    #if HAS_LEVELING && (HAS_MULTI_HOTEND || !HAS_HEATED_BED)
       lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
     #endif
 
@@ -934,7 +934,7 @@ void MarlinUI::draw_status_screen() {
     // Hotend 1 or Bed Temperature
     //
     lcd_moveto(0, 1);
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
     #elif HAS_HEATED_BED
       _draw_bed_status(blink);
@@ -952,7 +952,7 @@ void MarlinUI::draw_status_screen() {
     lcd_moveto(0, 2);
     #if HOTENDS > 2
       _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
-    #elif HOTENDS > 1 && HAS_HEATED_BED
+    #elif HAS_MULTI_HOTEND && HAS_HEATED_BED
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
       #define DREW_PRINT_PROGRESS
@@ -1077,7 +1077,7 @@ void MarlinUI::draw_status_screen() {
         if (thermalManager.degTargetBed() > 0) leds |= LED_A;
       #endif
 
-      #if HOTENDS
+      #if HAS_HOTEND
         if (thermalManager.degTargetHotend(0) > 0) leds |= LED_B;
       #endif
 
@@ -1110,7 +1110,7 @@ void MarlinUI::draw_status_screen() {
         ) leds |= LED_C;
       #endif // FAN_COUNT > 0
 
-      #if HOTENDS > 1
+      #if HAS_MULTI_HOTEND
         if (thermalManager.degTargetHotend(1) > 0) leds |= LED_C;
       #endif
 

commit 514afddeb4b3a7ede9ff481504aae69219a95f68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 18:53:58 2020 -0500

    Minor code cleanup

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index ee025f6585..3c89d1803c 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -367,11 +367,11 @@ void MarlinUI::init_lcd() {
 }
 
 bool MarlinUI::detected() {
-  return true
+  return (true
     #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
       && lcd.LcdDetected() == 1
     #endif
-  ;
+  );
 }
 
 #if HAS_SLOW_BUTTONS

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index a032450add..ee025f6585 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -102,7 +102,7 @@
 
 static void createChar_P(const char c, const byte * const ptr) {
   byte temp[8];
-  for (uint8_t i = 0; i < 8; i++)
+  LOOP_L_N(i, 8)
     temp[i] = pgm_read_byte(&ptr[i]);
   lcd.createChar(c, temp);
 }
@@ -414,7 +414,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     else {
       PGM_P p = text;
       int dly = time / _MAX(slen, 1);
-      for (uint8_t i = 0; i <= slen; i++) {
+      LOOP_LE_N(i, slen) {
 
         // Print the text at the correct place
         lcd_put_u8str_max_P(col, line, p, len);

commit 13118dbd8d9142d7698ca113cb05d1feae3b1bd3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 8 19:42:18 2020 -0500

    Additional numtostr functions

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index d79a7ccf61..a032450add 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -530,7 +530,7 @@ FORCE_INLINE void _draw_heater_status(const heater_ind_t heater, const char pref
 
   if (prefix >= 0) lcd_put_wchar(prefix);
 
-  lcd_put_u8str(i16tostr3(t1 + 0.5));
+  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
   lcd_put_wchar('/');
 
   #if !HEATER_IDLE_HANDLER
@@ -582,7 +582,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
       #endif
     ));
     if (progress)
-      lcd_put_u8str(ui8tostr3(progress));
+      lcd_put_u8str(ui8tostr3rj(progress));
     else
       lcd_put_u8str_P(PSTR("---"));
     lcd_put_wchar('%');
@@ -631,7 +631,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str_P(PSTR("Dia "));
       lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
       lcd_put_u8str_P(PSTR(" V"));
-      lcd_put_u8str(i16tostr3(planner.volumetric_percent(parser.volumetric_enabled)));
+      lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
       lcd_put_wchar('%');
       return;
     }
@@ -863,7 +863,7 @@ void MarlinUI::draw_status_screen() {
     #if LCD_HEIGHT > 3
 
       lcd_put_wchar(0, 2, LCD_STR_FEEDRATE[0]);
-      lcd_put_u8str(i16tostr3(feedrate_percentage));
+      lcd_put_u8str(i16tostr3rj(feedrate_percentage));
       lcd_put_wchar('%');
 
       char buffer[14];
@@ -902,7 +902,7 @@ void MarlinUI::draw_status_screen() {
               #endif
             }
           lcd_put_wchar(c);
-          lcd_put_u8str(i16tostr3(per));
+          lcd_put_u8str(i16tostr3rj(per));
           lcd_put_wchar('%');
         #endif
       #endif
@@ -941,7 +941,7 @@ void MarlinUI::draw_status_screen() {
     #endif
 
     lcd_put_wchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
-    lcd_put_u8str(i16tostr3(feedrate_percentage));
+    lcd_put_u8str(i16tostr3rj(feedrate_percentage));
     lcd_put_wchar('%');
 
     // ========== Line 3 ==========
@@ -1415,9 +1415,9 @@ void MarlinUI::draw_status_screen() {
        * Print plot position
        */
       lcd_put_wchar(_LCD_W_POS, 0, '(');
-      lcd_put_u8str(ui8tostr3(x_plot));
+      lcd_put_u8str(ui8tostr3rj(x_plot));
       lcd_put_wchar(',');
-      lcd_put_u8str(ui8tostr3(y_plot));
+      lcd_put_u8str(ui8tostr3rj(y_plot));
       lcd_put_wchar(')');
 
       #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display

commit 3473b21710e236669017ddab2650f566499dde64
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 09:50:53 2020 -0600

    Move millis_t includes

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 0e6374b8d2..d79a7ccf61 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -829,7 +829,7 @@ void MarlinUI::draw_status_screen() {
                 && !printingIsActive()
               #endif
             ) {
-              xy_pos_t lpos = current_position; toLogical(lpos);
+              const xy_pos_t lpos = current_position.asLogical();
               _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
               lcd_put_wchar(' ');
               _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);

commit 5e9a10dbaeaa885a670af0bd7ef3e7c068f5a7b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 07:36:25 2020 -0600

    Use PSTR for common labels

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 7cee7db4b4..0e6374b8d2 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1212,10 +1212,10 @@ void MarlinUI::draw_status_screen() {
         #define _LCD_W_POS 12
         #define _PLOT_X 1
         #define _MAP_X 3
-        #define _LABEL(C,X,Y) lcd_put_u8str(X, Y, C)
-        #define _XLABEL(X,Y) _LABEL("X:",X,Y)
-        #define _YLABEL(X,Y) _LABEL("Y:",X,Y)
-        #define _ZLABEL(X,Y) _LABEL("Z:",X,Y)
+        #define _LABEL(C,X,Y) lcd_put_u8str_P(X, Y, C)
+        #define _XLABEL(X,Y) _LABEL(X_LBL,X,Y)
+        #define _YLABEL(X,Y) _LABEL(Y_LBL,X,Y)
+        #define _ZLABEL(X,Y) _LABEL(Z_LBL,X,Y)
       #else
         #define _LCD_W_POS 8
         #define _PLOT_X 0

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index bf57f1dfc2..7cee7db4b4 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index d6ce8bfdd6..bf57f1dfc2 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1092,6 +1092,21 @@ void MarlinUI::draw_status_screen() {
           #if HAS_FAN2
             || thermalManager.fan_speed[2]
           #endif
+          #if HAS_FAN3
+            || thermalManager.fan_speed[3]
+          #endif
+          #if HAS_FAN4
+            || thermalManager.fan_speed[4]
+          #endif
+          #if HAS_FAN5
+            || thermalManager.fan_speed[5]
+          #endif
+          #if HAS_FAN6
+            || thermalManager.fan_speed[6]
+          #endif
+          #if HAS_FAN7
+            || thermalManager.fan_speed[7]
+          #endif
         ) leds |= LED_C;
       #endif // FAN_COUNT > 0
 

commit 27cb4db80eae73eb842f1a944260517bb8783eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 14 20:30:30 2019 -0600

    Reduced string storage using tokens (#15593)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 2585607e64..d6ce8bfdd6 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1006,40 +1006,41 @@ void MarlinUI::draw_status_screen() {
       int8_t pad = (LCD_WIDTH - utf8_strlen_P(pstr)) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }
-    n -= lcd_put_u8str_max_P(pstr, n);
+    n = lcd_put_u8str_ind_P(pstr, itemIndex, n);
     if (valstr) n -= lcd_put_u8str_max(valstr, n);
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 
   // Draw a generic menu item with pre_char (if selected) and post_char
   void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
-    uint8_t n = LCD_WIDTH - 2;
     lcd_put_wchar(0, row, sel ? pre_char : ' ');
-    n -= lcd_put_u8str_max_P(pstr, n);
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, LCD_WIDTH - 2);
     for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
-  // Draw an edit menu item with label and value string
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P pstr, const char* const data, const bool pgm) {
-    int8_t n = LCD_WIDTH - 2 - (pgm ? utf8_strlen_P(data) : utf8_strlen(data));
+  // Draw a menu item with a (potentially) editable value
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
+    const uint8_t vlen = data ? (pgm ? utf8_strlen_P(data) : utf8_strlen(data)) : 0;
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    n -= lcd_put_u8str_max_P(pstr, n);
-    lcd_put_wchar(':');
-    for (; n > 0; --n) lcd_put_wchar(' ');
-    if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, LCD_WIDTH - 2 - vlen);
+    if (vlen) {
+      lcd_put_wchar(':');
+      for (; n; --n) lcd_put_wchar(' ');
+      if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
+    }
   }
 
-  // Draw the edit screen for an editable menu item
-  void MenuEditItemBase::edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+  // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
+  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
 
-    lcd_put_u8str_P(0, 1, pstr);
+    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, LCD_WIDTH - 1);
     if (value != nullptr) {
       lcd_put_wchar(':');
       int len = utf8_strlen(value);
-      const lcd_uint_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit
-      lcd_put_wchar((LCD_WIDTH - 1) - (len + 1), valrow, ' ');                                   // Right-justified, padded, add a leading space
+      const lcd_uint_t valrow = (n < len + 1) ? 2 : 1;          // Value on the next row if it won't fit
+      lcd_put_wchar((LCD_WIDTH - 1) - (len + 1), valrow, ' ');  // Right-justified, padded, leading space
       lcd_put_u8str(value);
     }
   }

commit 786617e3754d704c201e7231ea647dbb90a5450a
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Nov 6 19:52:28 2019 -0300

    Fix RAMPS + VIKI i2c (#15811)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 536ddcfbb1..2585607e64 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -111,6 +111,12 @@ static void createChar_P(const char c, const byte * const ptr) {
   #define LCD_STR_PROGRESS  "\x03\x04\x05"
 #endif
 
+#if ENABLED(LCD_USE_I2C_BUZZER)
+  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    lcd.buzz(duration, freq);
+  }
+#endif
+
 void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
   #if NONE(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
     UNUSED(screen_charset);

commit e6dfc991ae6907e03751e869dabfaa5176f834af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 6 16:28:36 2019 -0600

    Patch tabs, heater led tests

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 880caad96b..536ddcfbb1 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1066,9 +1066,13 @@ void MarlinUI::draw_status_screen() {
       static uint8_t ledsprev = 0;
       uint8_t leds = 0;
 
-      if (thermalManager.degTargetBed() > 0) leds |= LED_A;
+      #if HAS_HEATED_BED
+        if (thermalManager.degTargetBed() > 0) leds |= LED_A;
+      #endif
 
-      if (thermalManager.degTargetHotend(0) > 0) leds |= LED_B;
+      #if HOTENDS
+        if (thermalManager.degTargetHotend(0) > 0) leds |= LED_B;
+      #endif
 
       #if FAN_COUNT > 0
         if (0

commit 15f94e5ee5eb35aab7d8121eeabf2b1b01104f43
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 2 07:09:57 2019 -0500

    Add NUL_STR global

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 8103efe2cd..880caad96b 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -464,7 +464,8 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       // Show the Marlin logo and short build version
       // After a delay show the website URL
       //
-      logo_lines(PSTR(""));
+      extern const char NUL_STR[];
+      logo_lines(NUL_STR);
       CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
       CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);
       #ifdef STRING_SPLASH_LINE3

commit ea3217cd4613d723567d9bc8ab375e68d75b294b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 2 07:28:20 2019 -0500

    Move 'draw' methods into Menu Item classes (#15760)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 92ef0c83cd..8103efe2cd 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -991,7 +991,8 @@ void MarlinUI::draw_status_screen() {
 
   #endif // ADVANCED_PAUSE_FEATURE
 
-  void draw_menu_item_static(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+  // Draw a static item with no left-right margin required. Centered by default.
+  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
     if ((style & SS_CENTER) && !valstr) {
@@ -1003,7 +1004,8 @@ void MarlinUI::draw_status_screen() {
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 
-  void draw_menu_item(const bool sel, const uint8_t row, PGM_P pstr, const char pre_char, const char post_char) {
+  // Draw a generic menu item with pre_char (if selected) and post_char
+  void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
     uint8_t n = LCD_WIDTH - 2;
     lcd_put_wchar(0, row, sel ? pre_char : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
@@ -1011,16 +1013,18 @@ void MarlinUI::draw_status_screen() {
     lcd_put_wchar(post_char);
   }
 
-  void _draw_menu_item_edit(const bool sel, const uint8_t row, PGM_P pstr, const char* const data, const bool pgm) {
-    uint8_t n = LCD_WIDTH - 2 - (pgm ? utf8_strlen_P(data) : utf8_strlen(data));
+  // Draw an edit menu item with label and value string
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P pstr, const char* const data, const bool pgm) {
+    int8_t n = LCD_WIDTH - 2 - (pgm ? utf8_strlen_P(data) : utf8_strlen(data));
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     lcd_put_wchar(':');
-    for (; n; --n) lcd_put_wchar(' ');
+    for (; n > 0; --n) lcd_put_wchar(' ');
     if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
   }
 
-  void draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+  // Draw the edit screen for an editable menu item
+  void MenuEditItemBase::edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
 
     lcd_put_u8str_P(0, 1, pstr);
@@ -1033,7 +1037,8 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
-  void draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
+  // The Select Screen presents a prompt and two "buttons"
+  void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     ui.draw_select_screen_prompt(pref, string, suff);
     SETCURSOR(0, LCD_HEIGHT - 1);
     lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
@@ -1043,9 +1048,7 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(SDSUPPORT)
 
-    void draw_sd_menu_item(const bool sel, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
-      UNUSED(pstr);
-
+    void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
       lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       constexpr uint8_t maxlen = LCD_WIDTH - 2;
       uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
@@ -1053,7 +1056,7 @@ void MarlinUI::draw_status_screen() {
       lcd_put_wchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }
 
-  #endif // SDSUPPORT
+  #endif
 
   #if ENABLED(LCD_HAS_STATUS_INDICATORS)
 

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 83b218aec3..92ef0c83cd 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -815,14 +815,28 @@ void MarlinUI::draw_status_screen() {
             sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
             lcd_put_u8str(mixer_messages);
 
-          #else
+          #else // !DUAL_MIXING_EXTRUDER
 
-            xy_pos_t lpos = current_position; toLogical(lpos);
-            _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-            lcd_put_wchar(' ');
-            _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+            if (true
+              #if ENABLED(LCD_SHOW_E_TOTAL)
+                && !printingIsActive()
+              #endif
+            ) {
+              xy_pos_t lpos = current_position; toLogical(lpos);
+              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
+              lcd_put_wchar(' ');
+              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+            }
+            else {
+              #if ENABLED(LCD_SHOW_E_TOTAL)
+                char tmp[20];
+                const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
+                sprintf_P(tmp, PSTR("E %ld%cm       "), uint32_t(_MAX(e_move_accumulator, 0.0f)) / escale, escale == 10 ? 'c' : 'm'); // 1234567mm
+                lcd_put_u8str(tmp);
+              #endif
+            }
 
-          #endif
+          #endif // !DUAL_MIXING_EXTRUDER
 
         #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
 

commit b20d5a7cc627164877c95859baaa614f8afc7b99
Author: LinFor <linfor@gmail.com>
Date:   Fri Oct 11 05:03:33 2019 +0300

    Estimate Remaining Time (graphical display) (#15497)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index e497cfe9ee..83b218aec3 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -566,7 +566,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
 #if HAS_PRINT_PROGRESS
 
   FORCE_INLINE void _draw_print_progress() {
-    const uint8_t progress = ui.get_progress();
+    const uint8_t progress = ui.get_progress_percent();
     lcd_put_u8str_P(PSTR(
       #if ENABLED(SDSUPPORT)
         "SD"
@@ -613,7 +613,7 @@ void MarlinUI::draw_status_message(const bool blink) {
     // Draw the progress bar if the message has shown long enough
     // or if there is no message set.
     if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !has_status()) {
-      const uint8_t progress = get_progress();
+      const uint8_t progress = get_progress_percent();
       if (progress > 2) return draw_progress_bar(progress);
     }
 

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 9f34946137..e497cfe9ee 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -484,9 +484,9 @@ void MarlinUI::draw_kill_screen() {
   lcd_put_u8str(0, 0, status_message);
   lcd_uint_t y = 2;
   #if LCD_HEIGHT >= 4
-    lcd_put_u8str_P(0, y++, PSTR(MSG_HALTED));
+    lcd_put_u8str_P(0, y++, GET_TEXT(MSG_HALTED));
   #endif
-  lcd_put_u8str_P(0, y, PSTR(MSG_PLEASE_RESET));
+  lcd_put_u8str_P(0, y, GET_TEXT(MSG_PLEASE_RESET));
 }
 
 //
@@ -977,7 +977,7 @@ void MarlinUI::draw_status_screen() {
 
   #endif // ADVANCED_PAUSE_FEATURE
 
-  void draw_menu_item_static(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_CENTER*/, const char * const valstr/*=nullptr*/) {
+  void draw_menu_item_static(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
     if ((style & SS_CENTER) && !valstr) {

commit dc14d4a13c1eb80a76237ebcab6d8a512d960391
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:44:49 2019 -0600

    Improvements and fixes to Lulzbot UI (#15490)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 819a5c5bc6..9f34946137 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -861,7 +861,7 @@ void MarlinUI::draw_status_screen() {
           uint16_t per;
           #if HAS_FAN0
             if (true
-              #if EXTRUDERS
+              #if EXTRUDERS && ENABLED(ADAPTIVE_FAN_SLOWING)
                 && (blink || thermalManager.fan_speed_scaler[0] < 128)
               #endif
             ) {

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 1465637504..819a5c5bc6 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -817,11 +817,10 @@ void MarlinUI::draw_status_screen() {
 
           #else
 
-            _draw_axis_value(X_AXIS, ftostr4sign(LOGICAL_X_POSITION(current_position[X_AXIS])), blink);
-
+            xy_pos_t lpos = current_position; toLogical(lpos);
+            _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
             lcd_put_wchar(' ');
-
-            _draw_axis_value(Y_AXIS, ftostr4sign(LOGICAL_Y_POSITION(current_position[Y_AXIS])), blink);
+            _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
 
           #endif
 
@@ -830,7 +829,7 @@ void MarlinUI::draw_status_screen() {
       #endif // LCD_WIDTH >= 20
 
       lcd_moveto(LCD_WIDTH - 8, 1);
-      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position[Z_AXIS])), blink);
+      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
 
       #if HAS_LEVELING && !HAS_HEATED_BED
         lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
@@ -902,7 +901,7 @@ void MarlinUI::draw_status_screen() {
     // Z Coordinate
     //
     lcd_moveto(LCD_WIDTH - 9, 0);
-    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position[Z_AXIS])), blink);
+    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
 
     #if HAS_LEVELING && (HOTENDS > 1 || !HAS_HEATED_BED)
       lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
@@ -1189,10 +1188,9 @@ void MarlinUI::draw_status_screen() {
          * Show X and Y positions
          */
         _XLABEL(_PLOT_X, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]))));
-
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
         _YLABEL(_LCD_W_POS, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
 
         lcd_moveto(_PLOT_X, 0);
 
@@ -1395,9 +1393,9 @@ void MarlinUI::draw_status_screen() {
          * Show all values at right of screen
          */
         _XLABEL(_LCD_W_POS, 1);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]))));
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
         _YLABEL(_LCD_W_POS, 2);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
 
         /**
          * Show the location value

commit 4c16661153b5035c2c8b4ed9eccce6307ae5ebb4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 27 03:06:23 2019 -0500

    Use named styles in draw_menu_item_static

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index b16a298659..1465637504 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -965,6 +965,8 @@ void MarlinUI::draw_status_screen() {
 
 #if HAS_LCD_MENU
 
+  #include "../menu/menu.h"
+
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
     void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
@@ -976,11 +978,10 @@ void MarlinUI::draw_status_screen() {
 
   #endif // ADVANCED_PAUSE_FEATURE
 
-  void draw_menu_item_static(const uint8_t row, PGM_P pstr, const bool center/*=true*/, const bool invert/*=false*/, const char *valstr/*=nullptr*/) {
-    UNUSED(invert);
+  void draw_menu_item_static(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_CENTER*/, const char * const valstr/*=nullptr*/) {
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
-    if (center && !valstr) {
+    if ((style & SS_CENTER) && !valstr) {
       int8_t pad = (LCD_WIDTH - utf8_strlen_P(pstr)) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index b7ccbfec71..b16a298659 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -47,7 +47,7 @@
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../../feature/bedlevel/ubl/ubl.h"
+  #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 //

commit 75927e17dd2114c14a593c12394d941eff684685
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:48:58 2019 -0500

    Filament Width Sensor singleton (#15191)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index c08067fb6b..b7ccbfec71 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -622,14 +622,9 @@ void MarlinUI::draw_status_message(const bool blink) {
     // Alternate Status message and Filament display
     if (ELAPSED(millis(), next_filament_display)) {
       lcd_put_u8str_P(PSTR("Dia "));
-      lcd_put_u8str(ftostr12ns(filament_width_meas));
+      lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
       lcd_put_u8str_P(PSTR(" V"));
-      lcd_put_u8str(i16tostr3(100.0 * (
-          parser.volumetric_enabled
-            ? planner.volumetric_area_nominal / planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
-            : planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
-        )
-      ));
+      lcd_put_u8str(i16tostr3(planner.volumetric_percent(parser.volumetric_enabled)));
       lcd_put_wchar('%');
       return;
     }

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index b7ebc111a5..c08067fb6b 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -866,7 +866,11 @@ void MarlinUI::draw_status_screen() {
           char c;
           uint16_t per;
           #if HAS_FAN0
-            if (blink || thermalManager.fan_speed_scaler[0] < 128) {
+            if (true
+              #if EXTRUDERS
+                && (blink || thermalManager.fan_speed_scaler[0] < 128)
+              #endif
+            ) {
               uint16_t spd = thermalManager.fan_speed[0];
               if (blink) c = 'F';
               #if ENABLED(ADAPTIVE_FAN_SLOWING)
@@ -877,8 +881,10 @@ void MarlinUI::draw_status_screen() {
             else
           #endif
             {
-              c = 'E';
-              per = planner.flow_percentage[0];
+              #if EXTRUDERS
+                c = 'E';
+                per = planner.flow_percentage[0];
+              #endif
             }
           lcd_put_wchar(c);
           lcd_put_u8str(i16tostr3(per));

commit 6b05d5d65d0b4f557021c0ed5c47ec4e5e97b43c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Sep 5 01:13:05 2019 +0700

    Allow TOUCH_BUTTONS to be swapped (#15100)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index a8cf421dcb..b7ebc111a5 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -371,8 +371,8 @@ bool MarlinUI::detected() {
 #if HAS_SLOW_BUTTONS
   uint8_t MarlinUI::read_slow_buttons() {
     #if ENABLED(LCD_I2C_TYPE_MCP23017)
-      // Reading these buttons this is likely to be too slow to call inside interrupt context
-      // so they are called during normal lcd_update
+      // Reading these buttons is too slow for interrupt context
+      // so they are read during LCD update in the main loop.
       uint8_t slow_bits = lcd.readButtons()
         #if !BUTTON_EXISTS(ENC)
           << B_I2C_BTN_OFFSET
@@ -381,7 +381,7 @@ bool MarlinUI::detected() {
       #if ENABLED(LCD_I2C_VIKI)
         if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
           slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
-      #endif // LCD_I2C_VIKI
+      #endif
       return slow_bits;
     #endif // LCD_I2C_TYPE_MCP23017
   }

commit 3ac76f048973e1ecb5ea6f2c50eb5990bbd6a5b9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Aug 28 07:40:18 2019 -0500

    Invariant Marlin bootscreen (#15057)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 47666857b3..a8cf421dcb 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -449,59 +449,28 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
         lcd_scroll(0, 3, PSTR(STRING), LCD_WIDTH, DELAY); \
       }
 
-    #ifdef STRING_SPLASH_LINE1
-      //
-      // Show the Marlin logo with splash line 1
-      //
-      if (LCD_EXTRA_SPACE >= utf8_strlen(STRING_SPLASH_LINE1) + 1) {
-        //
-        // Show the Marlin logo, splash line1, and splash line 2
-        //
-        logo_lines(PSTR(" " STRING_SPLASH_LINE1));
-        #ifdef STRING_SPLASH_LINE2
-          CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 2000);
-        #else
-          safe_delay(2000);
-        #endif
-      }
-      else {
-        //
-        // Show the Marlin logo with splash line 1
-        // After a delay show splash line 2, if it exists
-        //
-        #ifdef STRING_SPLASH_LINE2
-          #define _SPLASH_WAIT_1 1500
-        #else
-          #define _SPLASH_WAIT_1 2000
-        #endif
-        logo_lines(PSTR(""));
-        CENTER_OR_SCROLL(STRING_SPLASH_LINE1, _SPLASH_WAIT_1);
-        #ifdef STRING_SPLASH_LINE2
-          CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 1500);
-          #ifdef STRING_SPLASH_LINE3
-            CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
-          #endif
-        #endif
-      }
-    #elif defined(STRING_SPLASH_LINE2)
+    //
+    // Show the Marlin logo with splash line 1
+    //
+    if (LCD_EXTRA_SPACE >= utf8_strlen(SHORT_BUILD_VERSION) + 1) {
       //
-      // Show splash line 2 only, alongside the logo if possible
+      // Show the Marlin logo, splash line1, and splash line 2
       //
-      if (LCD_EXTRA_SPACE >= utf8_strlen(STRING_SPLASH_LINE2) + 1) {
-        logo_lines(PSTR(" " STRING_SPLASH_LINE2));
-        safe_delay(2000);
-      }
-      else {
-        logo_lines(PSTR(""));
-        CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 2000);
-      }
-    #else
+      logo_lines(PSTR(" " SHORT_BUILD_VERSION));
+      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 2000);
+    }
+    else {
       //
-      // Show only the Marlin logo
+      // Show the Marlin logo and short build version
+      // After a delay show the website URL
       //
       logo_lines(PSTR(""));
-      safe_delay(2000);
-    #endif
+      CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
+      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);
+      #ifdef STRING_SPLASH_LINE3
+        CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
+      #endif
+    }
 
     lcd.clear();
     safe_delay(100);
@@ -585,11 +554,13 @@ FORCE_INLINE void _draw_heater_status(const heater_ind_t heater, const char pref
 
 FORCE_INLINE void _draw_bed_status(const bool blink) {
   _draw_heater_status(H_BED, (
-    #if HAS_LEVELING
-      planner.leveling_active && blink ? '_' :
-    #endif
-    LCD_STR_BEDTEMP[0]
-  ), blink);
+      #if HAS_LEVELING
+        planner.leveling_active && blink ? '_' :
+      #endif
+      LCD_STR_BEDTEMP[0]
+    ),
+    blink
+  );
 }
 
 #if HAS_PRINT_PROGRESS

commit 7924e0d819fb50b3d3102b1d464e303c8214b213
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Aug 22 19:36:18 2019 -0500

    Add print at position shortcuts

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 54eb614cb4..47666857b3 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -401,9 +401,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, PGM_P const text, const uint8_t len, const int16_t time) {
     uint8_t slen = utf8_strlen_P(text);
     if (slen < len) {
-      // Fits into,
-      lcd_moveto(col, line);
-      lcd_put_u8str_max_P(text, len);
+      lcd_put_u8str_max_P(col, line, text, len);
       for (; slen < len; ++slen) lcd_put_wchar(' ');
       safe_delay(time);
     }
@@ -412,11 +410,8 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       int dly = time / _MAX(slen, 1);
       for (uint8_t i = 0; i <= slen; i++) {
 
-        // Go to the correct place
-        lcd_moveto(col, line);
-
-        // Print the text
-        lcd_put_u8str_max_P(p, len);
+        // Print the text at the correct place
+        lcd_put_u8str_max_P(col, line, p, len);
 
         // Fill with spaces
         for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_wchar(' ');
@@ -433,9 +428,9 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
   static void logo_lines(PGM_P const extra) {
     int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
-    lcd_moveto(indent, 0); lcd_put_wchar('\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
-    lcd_moveto(indent, 1);                        lcd_put_u8str_P(PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
-    lcd_moveto(indent, 2); lcd_put_wchar('\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
+    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
+    lcd_put_u8str_P(indent, 1, PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
+    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
   }
 
   void MarlinUI::show_bootscreen() {
@@ -447,8 +442,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     #define CENTER_OR_SCROLL(STRING,DELAY) \
       lcd_erase_line(3); \
       if (utf8_strlen(STRING) <= LCD_WIDTH) { \
-        lcd_moveto((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3); \
-        lcd_put_u8str_P(PSTR(STRING)); \
+        lcd_put_u8str_P((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3, PSTR(STRING)); \
         safe_delay(DELAY); \
       } \
       else { \
@@ -518,16 +512,12 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 #endif // SHOW_BOOTSCREEN
 
 void MarlinUI::draw_kill_screen() {
-  lcd_moveto(0, 0);
-  lcd_put_u8str(status_message);
-  #if LCD_HEIGHT < 4
-    lcd_moveto(0, 2);
-  #else
-    lcd_moveto(0, 2);
-    lcd_put_u8str_P(PSTR(MSG_HALTED));
-    lcd_moveto(0, 3);
+  lcd_put_u8str(0, 0, status_message);
+  lcd_uint_t y = 2;
+  #if LCD_HEIGHT >= 4
+    lcd_put_u8str_P(0, y++, PSTR(MSG_HALTED));
   #endif
-  lcd_put_u8str_P(PSTR(MSG_PLEASE_RESET));
+  lcd_put_u8str_P(0, y, PSTR(MSG_PLEASE_RESET));
 }
 
 //
@@ -886,8 +876,7 @@ void MarlinUI::draw_status_screen() {
 
     #if LCD_HEIGHT > 3
 
-      lcd_moveto(0, 2);
-      lcd_put_wchar(LCD_STR_FEEDRATE[0]);
+      lcd_put_wchar(0, 2, LCD_STR_FEEDRATE[0]);
       lcd_put_u8str(i16tostr3(feedrate_percentage));
       lcd_put_wchar('%');
 
@@ -895,8 +884,7 @@ void MarlinUI::draw_status_screen() {
       duration_t elapsed = print_job_timer.duration();
       const uint8_t len = elapsed.toDigital(buffer),
                     timepos = LCD_WIDTH - len - 1;
-      lcd_moveto(timepos, 2);
-      lcd_put_wchar(LCD_STR_CLOCK[0]);
+      lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
       lcd_put_u8str(buffer);
 
       #if LCD_WIDTH >= 20
@@ -945,8 +933,7 @@ void MarlinUI::draw_status_screen() {
     _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position[Z_AXIS])), blink);
 
     #if HAS_LEVELING && (HOTENDS > 1 || !HAS_HEATED_BED)
-      lcd_moveto(LCD_WIDTH - 1, 0);
-      lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
+      lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
     #endif
 
     // ========== Line 2 ==========
@@ -961,8 +948,7 @@ void MarlinUI::draw_status_screen() {
       _draw_bed_status(blink);
     #endif
 
-    lcd_moveto(LCD_WIDTH - 9, 1);
-    lcd_put_wchar(LCD_STR_FEEDRATE[0]);
+    lcd_put_wchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
     lcd_put_u8str(i16tostr3(feedrate_percentage));
     lcd_put_wchar('%');
 
@@ -1033,8 +1019,7 @@ void MarlinUI::draw_status_screen() {
 
   void draw_menu_item(const bool sel, const uint8_t row, PGM_P pstr, const char pre_char, const char post_char) {
     uint8_t n = LCD_WIDTH - 2;
-    lcd_moveto(0, row);
-    lcd_put_wchar(sel ? pre_char : ' ');
+    lcd_put_wchar(0, row, sel ? pre_char : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
@@ -1042,8 +1027,7 @@ void MarlinUI::draw_status_screen() {
 
   void _draw_menu_item_edit(const bool sel, const uint8_t row, PGM_P pstr, const char* const data, const bool pgm) {
     uint8_t n = LCD_WIDTH - 2 - (pgm ? utf8_strlen_P(data) : utf8_strlen(data));
-    lcd_moveto(0, row);
-    lcd_put_wchar(sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+    lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     lcd_put_wchar(':');
     for (; n; --n) lcd_put_wchar(' ');
@@ -1053,14 +1037,12 @@ void MarlinUI::draw_status_screen() {
   void draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
 
-    lcd_moveto(0, 1);
-    lcd_put_u8str_P(pstr);
+    lcd_put_u8str_P(0, 1, pstr);
     if (value != nullptr) {
       lcd_put_wchar(':');
       int len = utf8_strlen(value);
       const lcd_uint_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit
-      lcd_moveto((LCD_WIDTH - 1) - (len + 1), valrow);                                           // Right-justified, padded by spaces
-      lcd_put_wchar(' ');                                                                        // Overwrite char if value gets shorter
+      lcd_put_wchar((LCD_WIDTH - 1) - (len + 1), valrow, ' ');                                   // Right-justified, padded, add a leading space
       lcd_put_u8str(value);
     }
   }
@@ -1078,8 +1060,7 @@ void MarlinUI::draw_status_screen() {
     void draw_sd_menu_item(const bool sel, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
       UNUSED(pstr);
 
-      lcd_moveto(0, row);
-      lcd_put_wchar(sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+      lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       constexpr uint8_t maxlen = LCD_WIDTH - 2;
       uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
       for (; n; --n) lcd_put_wchar(' ');
@@ -1206,8 +1187,7 @@ void MarlinUI::draw_status_screen() {
     void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const lcd_uint_t x, const lcd_uint_t y) {
       add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
       lcd.createChar(c, (uint8_t*)&chrdata);
-      lcd_moveto(x, y);
-      lcd_put_wchar(c);
+      lcd_put_wchar(x, y, c);
     }
 
     void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
@@ -1216,7 +1196,7 @@ void MarlinUI::draw_status_screen() {
         #define _LCD_W_POS 12
         #define _PLOT_X 1
         #define _MAP_X 3
-        #define _LABEL(C,X,Y) lcd_moveto(X, Y); lcd_put_u8str(C)
+        #define _LABEL(C,X,Y) lcd_put_u8str(X, Y, C)
         #define _XLABEL(X,Y) _LABEL("X:",X,Y)
         #define _YLABEL(X,Y) _LABEL("Y:",X,Y)
         #define _ZLABEL(X,Y) _LABEL("Z:",X,Y)
@@ -1224,7 +1204,7 @@ void MarlinUI::draw_status_screen() {
         #define _LCD_W_POS 8
         #define _PLOT_X 0
         #define _MAP_X 1
-        #define _LABEL(X,Y,C) lcd_moveto(X, Y); lcd_put_wchar(C)
+        #define _LABEL(X,Y,C) lcd_put_wchar(X, Y, C)
         #define _XLABEL(X,Y) _LABEL('X',X,Y)
         #define _YLABEL(X,Y) _LABEL('Y',X,Y)
         #define _ZLABEL(X,Y) _LABEL('Z',X,Y)
@@ -1288,17 +1268,13 @@ void MarlinUI::draw_status_screen() {
         n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;
 
         for (i = 0; i < n_cols; i++) {
-          lcd_moveto(i, 0);
-          lcd_put_wchar(CHAR_LINE_TOP);                                     // Box Top line
-          lcd_moveto(i, n_rows - 1);
-          lcd_put_wchar(CHAR_LINE_BOT);                                     // Box Bottom line
+          lcd_put_wchar(i, 0, CHAR_LINE_TOP);                               // Box Top line
+          lcd_put_wchar(i, n_rows - 1, CHAR_LINE_BOT);                      // Box Bottom line
         }
 
         for (j = 0; j < n_rows; j++) {
-          lcd_moveto(0, j);
-          lcd_put_wchar(CHAR_EDGE_L);                                       // Box Left edge
-          lcd_moveto(n_cols - 1, j);
-          lcd_put_wchar(CHAR_EDGE_R);                                       // Box Right edge
+          lcd_put_wchar(0, j, CHAR_EDGE_L);                                 // Box Left edge
+          lcd_put_wchar(n_cols - 1, j, CHAR_EDGE_R);                        // Box Right edge
         }
 
         /**
@@ -1308,10 +1284,8 @@ void MarlinUI::draw_status_screen() {
         k = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 2;
         l = (HD44780_CHAR_HEIGHT) * n_rows;
         if (l > k && l - k >= (HD44780_CHAR_HEIGHT) / 2) {
-          lcd_moveto(0, n_rows - 1);                                        // Box Left edge
-          lcd_put_wchar(' ');
-          lcd_moveto(n_cols - 1, n_rows - 1);                               // Box Right edge
-          lcd_put_wchar(' ');
+          lcd_put_wchar(0, n_rows - 1, ' ');                                // Box Left edge
+          lcd_put_wchar(n_cols - 1, n_rows - 1, ' ');                       // Box Right edge
         }
 
         clear_custom_char(&new_char);
@@ -1425,8 +1399,7 @@ void MarlinUI::draw_status_screen() {
       /**
        * Print plot position
        */
-      lcd_moveto(_LCD_W_POS, 0);
-      lcd_put_wchar('(');
+      lcd_put_wchar(_LCD_W_POS, 0, '(');
       lcd_put_u8str(ui8tostr3(x_plot));
       lcd_put_wchar(',');
       lcd_put_u8str(ui8tostr3(y_plot));

commit 05995d1fd6c3b85717d428ff5c0c269f7872857b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Aug 20 09:01:37 2019 +0200

    Unify buzz methods as MarlinUI::buzz (#14803)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 9e1a614cd6..54eb614cb4 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -360,6 +360,33 @@ void MarlinUI::init_lcd() {
   lcd.clear();
 }
 
+bool MarlinUI::detected() {
+  return true
+    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
+      && lcd.LcdDetected() == 1
+    #endif
+  ;
+}
+
+#if HAS_SLOW_BUTTONS
+  uint8_t MarlinUI::read_slow_buttons() {
+    #if ENABLED(LCD_I2C_TYPE_MCP23017)
+      // Reading these buttons this is likely to be too slow to call inside interrupt context
+      // so they are called during normal lcd_update
+      uint8_t slow_bits = lcd.readButtons()
+        #if !BUTTON_EXISTS(ENC)
+          << B_I2C_BTN_OFFSET
+        #endif
+      ;
+      #if ENABLED(LCD_I2C_VIKI)
+        if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
+          slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
+      #endif // LCD_I2C_VIKI
+      return slow_bits;
+    #endif // LCD_I2C_TYPE_MCP23017
+  }
+#endif
+
 void MarlinUI::clear_lcd() { lcd.clear(); }
 
 #if ENABLED(SHOW_BOOTSCREEN)
@@ -1063,7 +1090,7 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(LCD_HAS_STATUS_INDICATORS)
 
-    static void MarlinUI::update_indicators() {
+    void MarlinUI::update_indicators() {
       // Set the LEDS - referred to as backlights by the LiquidTWI2 library
       static uint8_t ledsprev = 0;
       uint8_t leds = 0;

commit 823178c272b06f2cdcdb087e8f6c7b2ef0e3e6ed
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Aug 18 07:58:38 2019 +0700

    Use u8g int type for screen coordinates (#14965)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 65f50efa24..9e1a614cd6 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -364,14 +364,14 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
 #if ENABLED(SHOW_BOOTSCREEN)
 
-  void lcd_erase_line(const int16_t line) {
+  void lcd_erase_line(const lcd_uint_t line) {
     lcd_moveto(0, line);
     for (uint8_t i = LCD_WIDTH + 1; --i;)
       lcd_put_wchar(' ');
   }
 
   // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
-  void lcd_scroll(const uint8_t col, const uint8_t line, PGM_P const text, const uint8_t len, const int16_t time) {
+  void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, PGM_P const text, const uint8_t len, const int16_t time) {
     uint8_t slen = utf8_strlen_P(text);
     if (slen < len) {
       // Fits into,
@@ -1031,9 +1031,9 @@ void MarlinUI::draw_status_screen() {
     if (value != nullptr) {
       lcd_put_wchar(':');
       int len = utf8_strlen(value);
-      const uint8_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit
-      lcd_moveto((LCD_WIDTH - 1) - (len + 1), valrow);                                        // Right-justified, padded by spaces
-      lcd_put_wchar(' ');                                                                     // Overwrite char if value gets shorter
+      const lcd_uint_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit
+      lcd_moveto((LCD_WIDTH - 1) - (len + 1), valrow);                                           // Right-justified, padded by spaces
+      lcd_put_wchar(' ');                                                                        // Overwrite char if value gets shorter
       lcd_put_u8str(value);
     }
   }
@@ -1144,9 +1144,9 @@ void MarlinUI::draw_status_screen() {
     } custom_char;
 
     typedef struct {
-      uint8_t column, row,
-              x_pixel_offset, y_pixel_offset,
-              x_pixel_mask;
+      lcd_uint_t column, row,
+                 x_pixel_offset, y_pixel_offset;
+      uint8_t x_pixel_mask;
     } coordinate;
 
     void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location);
@@ -1174,16 +1174,16 @@ void MarlinUI::draw_status_screen() {
       return ret_val;
     }
 
-    inline coordinate pixel_location(const uint8_t x, const uint8_t y) { return pixel_location((int16_t)x, (int16_t)y); }
+    inline coordinate pixel_location(const lcd_uint_t x, const lcd_uint_t y) { return pixel_location((int16_t)x, (int16_t)y); }
 
-    void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const uint8_t x, const uint8_t y) {
+    void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const lcd_uint_t x, const lcd_uint_t y) {
       add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
       lcd.createChar(c, (uint8_t*)&chrdata);
       lcd_moveto(x, y);
       lcd_put_wchar(c);
     }
 
-    void MarlinUI::ubl_plot(const uint8_t x, const uint8_t inverted_y) {
+    void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
 
       #if LCD_WIDTH >= 20
         #define _LCD_W_POS 12
@@ -1209,10 +1209,10 @@ void MarlinUI::draw_status_screen() {
          * Show X and Y positions
          */
         _XLABEL(_PLOT_X, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x]))));
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]))));
 
         _YLABEL(_LCD_W_POS, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[inverted_y]))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]))));
 
         lcd_moveto(_PLOT_X, 0);
 
@@ -1220,13 +1220,13 @@ void MarlinUI::draw_status_screen() {
 
         coordinate upper_left, lower_right, bottom_right_corner;
         custom_char new_char;
-        uint8_t i, j, k, l, m, n, n_rows, n_cols, y,
-                bottom_line, right_edge,
-                x_map_pixels, y_map_pixels,
-                pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
-                suppress_x_offset = 0, suppress_y_offset = 0;
+        uint8_t i, n, n_rows, n_cols;
+        lcd_uint_t j, k, l, m, bottom_line, right_edge,
+                   x_map_pixels, y_map_pixels,
+                   pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
+                   suppress_x_offset = 0, suppress_y_offset = 0;
 
-        y = GRID_MAX_POINTS_Y - inverted_y - 1;
+        const uint8_t y_plot_inv = (GRID_MAX_POINTS_Y - 1) - y_plot;
 
         upper_left.column  = 0;
         upper_left.row     = 0;
@@ -1310,12 +1310,12 @@ void MarlinUI::draw_status_screen() {
           new_char.custom_char_bits[j] = (uint8_t)_BV(i);                   // Char #3 is used for the box right edge
         lcd.createChar(CHAR_EDGE_R, (uint8_t*)&new_char);
 
-        i = x * pixels_per_x_mesh_pnt - suppress_x_offset;
-        j = y * pixels_per_y_mesh_pnt - suppress_y_offset;
+        i = x_plot * pixels_per_x_mesh_pnt - suppress_x_offset;
+        j = y_plot_inv * pixels_per_y_mesh_pnt - suppress_y_offset;
         upper_left = pixel_location(i, j);
 
-        k = (x + 1) * pixels_per_x_mesh_pnt - 1 - suppress_x_offset;
-        l = (y + 1) * pixels_per_y_mesh_pnt - 1 - suppress_y_offset;
+        k = (x_plot + 1) * pixels_per_x_mesh_pnt - 1 - suppress_x_offset;
+        l = (y_plot_inv + 1) * pixels_per_y_mesh_pnt - 1 - suppress_y_offset;
         lower_right = pixel_location(k, l);
 
         bottom_right_corner = pixel_location(x_map_pixels, y_map_pixels);
@@ -1327,7 +1327,7 @@ void MarlinUI::draw_status_screen() {
          */
 
         clear_custom_char(&new_char);
-        const uint8_t ypix = _MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
+        const lcd_uint_t ypix = _MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
         for (j = upper_left.y_pixel_offset; j < ypix; j++) {
           i = upper_left.x_pixel_mask;
           for (k = 0; k < pixels_per_x_mesh_pnt; k++) {
@@ -1400,9 +1400,9 @@ void MarlinUI::draw_status_screen() {
        */
       lcd_moveto(_LCD_W_POS, 0);
       lcd_put_wchar('(');
-      lcd_put_u8str(ui8tostr3(x));
+      lcd_put_u8str(ui8tostr3(x_plot));
       lcd_put_wchar(',');
-      lcd_put_u8str(ui8tostr3(inverted_y));
+      lcd_put_u8str(ui8tostr3(y_plot));
       lcd_put_wchar(')');
 
       #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
@@ -1411,8 +1411,8 @@ void MarlinUI::draw_status_screen() {
          * Print Z values
          */
         _ZLABEL(_LCD_W_POS, 1);
-        if (!isnan(ubl.z_values[x][inverted_y]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x][inverted_y]));
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));
 
@@ -1422,16 +1422,16 @@ void MarlinUI::draw_status_screen() {
          * Show all values at right of screen
          */
         _XLABEL(_LCD_W_POS, 1);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x]))));
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]))));
         _YLABEL(_LCD_W_POS, 2);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[inverted_y]))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]))));
 
         /**
          * Show the location value
          */
         _ZLABEL(_LCD_W_POS, 3);
-        if (!isnan(ubl.z_values[x][inverted_y]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x][inverted_y]));
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));
 

commit d7172a45588b61264e8bee0f0cd6ddfd485e8702
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Aug 11 02:22:18 2019 +0200

    Cleanup and conditions (#14886)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index b40aab6e09..65f50efa24 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -269,7 +269,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // LCD_PROGRESS_BAR
 
-  #if ENABLED(SDSUPPORT)
+  #if ENABLED(SDSUPPORT) && HAS_LCD_MENU
 
     // CHARSET_MENU
     const static PROGMEM byte refresh[8] = {
@@ -319,7 +319,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       #endif
         {
           createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if ENABLED(SDSUPPORT)
+          #if ENABLED(SDSUPPORT) && HAS_LCD_MENU
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
             createChar_P(LCD_STR_FOLDER[0], folder);

commit eb7840dabb5852a3bc7bfe1a2466ad691d2bdae4
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Jul 28 23:02:42 2019 -0600

    Match select item to encoder direction (#14673)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 888158c663..b40aab6e09 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1024,6 +1024,8 @@ void MarlinUI::draw_status_screen() {
   }
 
   void draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+    ui.encoder_direction_normal();
+
     lcd_moveto(0, 1);
     lcd_put_u8str_P(pstr);
     if (value != nullptr) {

commit fe0224104498a42a3921b97ef3902581fba6c309
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:20:15 2019 -0500

    NONE on combined options

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 2084c2db07..888158c663 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -112,7 +112,7 @@ static void createChar_P(const char c, const byte * const ptr) {
 #endif
 
 void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
-  #if DISABLED(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
+  #if NONE(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
     UNUSED(screen_charset);
   #endif
 
@@ -516,7 +516,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
     if (!TEST(axis_homed, axis))
       while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
     else {
-      #if DISABLED(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
+      #if NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
         if (!TEST(axis_known_position, axis))
           lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
         else

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 0f3c1251ca..2084c2db07 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -382,7 +382,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     }
     else {
       PGM_P p = text;
-      int dly = time / MAX(slen, 1);
+      int dly = time / _MAX(slen, 1);
       for (uint8_t i = 0; i <= slen; i++) {
 
         // Go to the correct place
@@ -1325,7 +1325,7 @@ void MarlinUI::draw_status_screen() {
          */
 
         clear_custom_char(&new_char);
-        const uint8_t ypix = MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
+        const uint8_t ypix = _MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
         for (j = upper_left.y_pixel_offset; j < ypix; j++) {
           i = upper_left.x_pixel_mask;
           for (k = 0; k < pixels_per_x_mesh_pnt; k++) {

commit ae9232962e7eef54de71d582b535c21df3a0f1b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 23:29:43 2019 -0500

    Use heater index defines

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 1f9de12f53..0f3c1251ca 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -526,7 +526,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
   }
 }
 
-FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, const bool blink) {
+FORCE_INLINE void _draw_heater_status(const heater_ind_t heater, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
     const bool isBed = heater < 0;
     const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater)),
@@ -567,7 +567,7 @@ FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, co
 }
 
 FORCE_INLINE void _draw_bed_status(const bool blink) {
-  _draw_heater_status(-1, (
+  _draw_heater_status(H_BED, (
     #if HAS_LEVELING
       planner.leveling_active && blink ? '_' :
     #endif
@@ -750,19 +750,17 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 0 Temperature
       //
-      _draw_heater_status(0, -1, blink);
+      _draw_heater_status(H_E0, -1, blink);
 
       //
       // Hotend 1 or Bed Temperature
       //
       #if HOTENDS > 1
         lcd_moveto(8, 0);
-        lcd_put_wchar(LCD_STR_THERMOMETER[0]);
-        _draw_heater_status(1, -1, blink);
+        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
       #elif HAS_HEATED_BED
         lcd_moveto(8, 0);
-        lcd_put_wchar(LCD_STR_BEDTEMP[0]);
-        _draw_heater_status(-1, -1, blink);
+        _draw_bed_status(blink);
       #endif
 
     #else // LCD_WIDTH >= 20
@@ -770,14 +768,14 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 0 Temperature
       //
-      _draw_heater_status(0, LCD_STR_THERMOMETER[0], blink);
+      _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
 
       //
       // Hotend 1 or Bed Temperature
       //
       #if HOTENDS > 1
         lcd_moveto(10, 0);
-        _draw_heater_status(1, LCD_STR_THERMOMETER[0], blink);
+        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
       #elif HAS_HEATED_BED
         lcd_moveto(10, 0);
         _draw_bed_status(blink);
@@ -806,7 +804,7 @@ void MarlinUI::draw_status_screen() {
         #if HOTENDS > 2 || (HOTENDS > 1 && HAS_HEATED_BED)
 
           #if HOTENDS > 2
-            _draw_heater_status(2, LCD_STR_THERMOMETER[0], blink);
+            _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
             lcd_moveto(10, 1);
           #endif
 
@@ -911,7 +909,7 @@ void MarlinUI::draw_status_screen() {
     //
     // Hotend 0 Temperature
     //
-    _draw_heater_status(0, LCD_STR_THERMOMETER[0], blink);
+    _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
 
     //
     // Z Coordinate
@@ -931,7 +929,7 @@ void MarlinUI::draw_status_screen() {
     //
     lcd_moveto(0, 1);
     #if HOTENDS > 1
-      _draw_heater_status(1, LCD_STR_THERMOMETER[0], blink);
+      _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
     #elif HAS_HEATED_BED
       _draw_bed_status(blink);
     #endif
@@ -948,7 +946,7 @@ void MarlinUI::draw_status_screen() {
     //
     lcd_moveto(0, 2);
     #if HOTENDS > 2
-      _draw_heater_status(2, LCD_STR_THERMOMETER[0], blink);
+      _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
     #elif HOTENDS > 1 && HAS_HEATED_BED
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
@@ -987,7 +985,7 @@ void MarlinUI::draw_status_screen() {
     void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
       if (row < LCD_HEIGHT) {
         lcd_moveto(LCD_WIDTH - 9, row);
-        _draw_heater_status(extruder, LCD_STR_THERMOMETER[0], get_blink());
+        _draw_heater_status((heater_ind_t)extruder, LCD_STR_THERMOMETER[0], get_blink());
       }
     }
 

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index d49dfb6b22..1f9de12f53 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -886,7 +886,7 @@ void MarlinUI::draw_status_screen() {
               uint16_t spd = thermalManager.fan_speed[0];
               if (blink) c = 'F';
               #if ENABLED(ADAPTIVE_FAN_SLOWING)
-                else { c = '*'; spd = (spd * thermalManager.fan_speed_scaler[0]) >> 7; }
+                else { c = '*'; spd = thermalManager.scaledFanSpeed(0, spd); }
               #endif
               per = thermalManager.fanPercent(spd);
             }

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 03a3f97628..d49dfb6b22 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 2a96d4e23ad0090dc371710d079af731136dfe97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 11 05:58:43 2019 -0500

    Move number-to-string functions to libs

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 4d205be300..03a3f97628 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -33,6 +33,7 @@
 
 #include "ultralcd_HD44780.h"
 #include "../ultralcd.h"
+#include "../../libs/numtostr.h"
 
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 57a6e96904..4d205be300 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -992,7 +992,7 @@ void MarlinUI::draw_status_screen() {
 
   #endif // ADVANCED_PAUSE_FEATURE
 
-  void draw_menu_item_static(const uint8_t row, PGM_P pstr, const bool center/*=true*/, const bool invert/*=false*/, const char *valstr/*=NULL*/) {
+  void draw_menu_item_static(const uint8_t row, PGM_P pstr, const bool center/*=true*/, const bool invert/*=false*/, const char *valstr/*=nullptr*/) {
     UNUSED(invert);
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
@@ -1024,10 +1024,10 @@ void MarlinUI::draw_status_screen() {
     if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
   }
 
-  void draw_edit_screen(PGM_P const pstr, const char* const value/*=NULL*/) {
+  void draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     lcd_moveto(0, 1);
     lcd_put_u8str_P(pstr);
-    if (value != NULL) {
+    if (value != nullptr) {
       lcd_put_wchar(':');
       int len = utf8_strlen(value);
       const uint8_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit

commit 5051909c3c43ae42c14765d0adce4405b8e9a423
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 10:13:44 2019 -0500

    Update do_select_screen for general use (#13800)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index c8927725c5..57a6e96904 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1038,9 +1038,7 @@ void MarlinUI::draw_status_screen() {
   }
 
   void draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
-    SETCURSOR(0, 0); lcd_put_u8str_P(pref);
-    if (string) wrap_string(1, string);
-    if (suff) lcd_put_u8str_P(suff);
+    ui.draw_select_screen_prompt(pref, string, suff);
     SETCURSOR(0, LCD_HEIGHT - 1);
     lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
     SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);

commit bf28ad4b6c8deb00086851a32f65c2a97288b20d
Author: Antonio Pérez <aperez@skarcha.com>
Date:   Wed Apr 17 21:52:20 2019 +0200

    Fix clear of Z position last digit (#13731)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index c493b371c2..c8927725c5 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -517,7 +517,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
     else {
       #if DISABLED(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
         if (!TEST(axis_known_position, axis))
-          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("      ") : PSTR("    "));
+          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
         else
       #endif
           lcd_put_u8str(value);

commit 9abe9aff56d44d42c9dc52679cc9f17592cd0bd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 13:44:35 2019 -0500

    Confirm before starting SD print (#13616)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index d400915e7e..c493b371c2 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1037,6 +1037,16 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
+  void draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
+    SETCURSOR(0, 0); lcd_put_u8str_P(pref);
+    if (string) wrap_string(1, string);
+    if (suff) lcd_put_u8str_P(suff);
+    SETCURSOR(0, LCD_HEIGHT - 1);
+    lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
+    SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
+    lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
+  }
+
   #if ENABLED(SDSUPPORT)
 
     void draw_sd_menu_item(const bool sel, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 56127b5464..d400915e7e 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1025,7 +1025,7 @@ void MarlinUI::draw_status_screen() {
   }
 
   void draw_edit_screen(PGM_P const pstr, const char* const value/*=NULL*/) {
-    lcd_moveto(1, 1);
+    lcd_moveto(0, 1);
     lcd_put_u8str_P(pstr);
     if (value != NULL) {
       lcd_put_wchar(':');

commit b376c7e374bbbc2cb69b6009c619f923f42f84b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:50:06 2019 -0500

    Group DISABLED items

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index ce391bb406..56127b5464 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -111,7 +111,7 @@ static void createChar_P(const char c, const byte * const ptr) {
 #endif
 
 void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
-  #if DISABLED(LCD_PROGRESS_BAR) && DISABLED(SHOW_BOOTSCREEN)
+  #if DISABLED(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
     UNUSED(screen_charset);
   #endif
 
@@ -515,7 +515,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
     if (!TEST(axis_homed, axis))
       while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
     else {
-      #if DISABLED(HOME_AFTER_DEACTIVATE) && DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
+      #if DISABLED(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
         if (!TEST(axis_known_position, axis))
           lcd_put_u8str_P(axis == Z_AXIS ? PSTR("      ") : PSTR("    "));
         else

commit 58bca6788374e6a0fcd8b3a5c513e1ad520b9a10
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:32:12 2019 -0500

    Unify status scrolling further

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 5ae69c7224..ce391bb406 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -660,33 +660,22 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str(status_message);
 
       // Fill the rest with spaces
-      while (slen < LCD_WIDTH) {
-        lcd_put_wchar(' ');
-        ++slen;
-      }
+      while (slen < LCD_WIDTH) { lcd_put_wchar(' '); ++slen; }
     }
     else {
       // String is larger than the available space in screen.
 
       // Get a pointer to the next valid UTF8 character
-      const char *stat = status_message + status_scroll_offset;
-
-      // Get the string remaining length
-      const uint8_t rlen = utf8_strlen(stat);
-
-      // If we have enough characters to display
-      if (rlen >= LCD_WIDTH) {
-        // The remaining string fills the screen - Print it
-        lcd_put_u8str_max(stat, LCD_WIDTH);
-      }
-      else {
-
-        // The remaining string does not completely fill the screen
-        lcd_put_u8str_max(stat, LCD_WIDTH);               // The string leaves space
-        uint8_t chars = LCD_WIDTH - rlen;                 // Amount of space left in characters
-
-        lcd_put_wchar('.');                               // Always at 1+ spaces left, draw a dot
-        if (--chars) {                                    // Draw a second dot if there's space
+      // and the string remaining length
+      uint8_t rlen;
+      const char *stat = status_and_len(rlen);
+      lcd_put_u8str_max(stat, LCD_WIDTH);     // The string leaves space
+
+      // If the remaining string doesn't completely fill the screen
+      if (rlen < LCD_WIDTH) {
+        lcd_put_wchar('.');                   // Always at 1+ spaces left, draw a dot
+        uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
+        if (--chars) {                        // Draw a second dot if there's space
           lcd_put_wchar('.');
           if (--chars)
             lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
@@ -694,15 +683,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       }
       if (last_blink != blink) {
         last_blink = blink;
-
-        // Adjust by complete UTF8 characters
-        if (status_scroll_offset < slen) {
-          status_scroll_offset++;
-          while (!START_OF_UTF8_CHAR(status_message[status_scroll_offset]))
-            status_scroll_offset++;
-        }
-        else
-          status_scroll_offset = 0;
+        advance_status_scroll();
       }
     }
   #else

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 217d99e090..5ae69c7224 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -40,7 +40,7 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
@@ -57,7 +57,7 @@
 
   LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_I2C_PIN_EN, LCD_I2C_PIN_RW, LCD_I2C_PIN_RS, LCD_I2C_PIN_D4, LCD_I2C_PIN_D5, LCD_I2C_PIN_D6, LCD_I2C_PIN_D7);
 
-#elif ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)
+#elif EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
 
   LCD_CLASS lcd(LCD_I2C_ADDRESS
     #ifdef DETECT_DEVICE
@@ -628,7 +628,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       if (progress > 2) return draw_progress_bar(progress);
     }
 
-  #elif ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+  #elif BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
 
     // Alternate Status message and Filament display
     if (ELAPSED(millis(), next_filament_display)) {

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index dc7858589a..217d99e090 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -544,9 +544,9 @@ FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, co
   #else
     const bool is_idle = (
       #if HAS_HEATED_BED
-        isBed ? thermalManager.is_bed_idle() :
+        isBed ? thermalManager.bed_idle.timed_out :
       #endif
-      thermalManager.is_heater_idle(heater)
+      thermalManager.hotend_idle[heater].timed_out
     );
 
     if (!blink && is_idle) {

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 4bfe55b867..dc7858589a 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 6de3d3437849c0710881311bc9ad4069b0aee55d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 10 04:54:23 2019 -0600

    M166 Gradients, LCD Menu for 2-channel Mixer (Geeetech A10M/A20M) (#13022)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 2493646a36..4bfe55b867 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -832,11 +832,35 @@ void MarlinUI::draw_status_screen() {
 
         #else // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
 
-          _draw_axis_value(X_AXIS, ftostr4sign(LOGICAL_X_POSITION(current_position[X_AXIS])), blink);
+          #if DUAL_MIXING_EXTRUDER
 
-          lcd_put_wchar(' ');
+            // Two-component mix / gradient instead of XY
+
+            char mixer_messages[12];
+            const char *mix_label;
+            #if ENABLED(GRADIENT_MIX)
+              if (mixer.gradient.enabled) {
+                mixer.update_mix_from_gradient();
+                mix_label = "Gr";
+              }
+              else
+            #endif
+              {
+                mixer.update_mix_from_vtool();
+                mix_label = "Mx";
+              }
+            sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
+            lcd_put_u8str(mixer_messages);
+
+          #else
+
+            _draw_axis_value(X_AXIS, ftostr4sign(LOGICAL_X_POSITION(current_position[X_AXIS])), blink);
 
-          _draw_axis_value(Y_AXIS, ftostr4sign(LOGICAL_Y_POSITION(current_position[Y_AXIS])), blink);
+            lcd_put_wchar(' ');
+
+            _draw_axis_value(Y_AXIS, ftostr4sign(LOGICAL_Y_POSITION(current_position[Y_AXIS])), blink);
+
+          #endif
 
         #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
 

commit 2f8e89adc395c59678ba0b4a8b2f65230371a732
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 5 19:04:26 2019 -0600

    Remove extraneous ui. prefixes

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 87671aa45b..2493646a36 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -981,7 +981,7 @@ void MarlinUI::draw_status_screen() {
     void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
       if (row < LCD_HEIGHT) {
         lcd_moveto(LCD_WIDTH - 9, row);
-        _draw_heater_status(extruder, LCD_STR_THERMOMETER[0], ui.get_blink());
+        _draw_heater_status(extruder, LCD_STR_THERMOMETER[0], get_blink());
       }
     }
 

commit 0f07ba4f093f5a010955595738ca8b6c833d2e47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 23 20:17:21 2019 -0600

    Tweak some comments

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 7513317274..87671aa45b 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -741,7 +741,7 @@ void MarlinUI::draw_status_message(const bool blink) {
  *         |F---%  SD---% T--:--|
  *         |01234567890123456789|
  *
- *  LCD_INFO_SCREEN_STYLE 1 : Prusa-style Status Screen
+ *  LCD_INFO_SCREEN_STYLE 1 : Průša-style Status Screen
  *
  *  |T000/000°  Z 000.00 |
  *  |B000/000°  F---%    |

commit 7fde8d9d1e264c09246b0c7f64fc5c56b3752cd6
Author: mikeshub <mikesbaker@gmail.com>
Date:   Mon Jan 14 14:29:55 2019 -0600

    Add CreatorPro / Makerbot / QIDI / etc and Mightboard RevE support (#12855)
    
    - Fix a bug in MAXxxxx thermocouple temp reporting.
    - Add support for 3-wire HD44780.
    - Add support for PCA9533 RGB driver.
    - Add configuration examples for FlashForge CreatorPro.

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index bd3c30c8c7..7513317274 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -80,6 +80,14 @@
     #endif
   );
 
+#elif ENABLED(SR_LCD_3W_NL)
+
+  // NewLiquidCrystal was not working
+  // https://github.com/mikeshub/SailfishLCD
+  // uses the code directly from Sailfish
+
+  LCD_CLASS lcd(SR_STROBE_PIN, SR_DATA_PIN, SR_CLK_PIN);
+
 #elif ENABLED(LCM1602)
 
   LCD_CLASS lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);

commit eb78aed863cf20cc02f07b8c3e47d27ae4ed91dd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 12 16:01:04 2019 -0600

    Rename LCD menus according to variable types (#12892)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index e9f552f880..bd3c30c8c7 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -528,7 +528,7 @@ FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, co
 
   if (prefix >= 0) lcd_put_wchar(prefix);
 
-  lcd_put_u8str(itostr3(t1 + 0.5));
+  lcd_put_u8str(i16tostr3(t1 + 0.5));
   lcd_put_wchar('/');
 
   #if !HEATER_IDLE_HANDLER
@@ -548,7 +548,7 @@ FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, co
     }
     else
   #endif
-      lcd_put_u8str(itostr3left(t2 + 0.5));
+      lcd_put_u8str(i16tostr3left(t2 + 0.5));
 
   if (prefix >= 0) {
     lcd_put_wchar(LCD_STR_DEGREE[0]);
@@ -578,7 +578,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
       #endif
     ));
     if (progress)
-      lcd_put_u8str(itostr3(progress));
+      lcd_put_u8str(ui8tostr3(progress));
     else
       lcd_put_u8str_P(PSTR("---"));
     lcd_put_wchar('%');
@@ -627,7 +627,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str_P(PSTR("Dia "));
       lcd_put_u8str(ftostr12ns(filament_width_meas));
       lcd_put_u8str_P(PSTR(" V"));
-      lcd_put_u8str(itostr3(100.0 * (
+      lcd_put_u8str(i16tostr3(100.0 * (
           parser.volumetric_enabled
             ? planner.volumetric_area_nominal / planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
@@ -849,7 +849,7 @@ void MarlinUI::draw_status_screen() {
 
       lcd_moveto(0, 2);
       lcd_put_wchar(LCD_STR_FEEDRATE[0]);
-      lcd_put_u8str(itostr3(feedrate_percentage));
+      lcd_put_u8str(i16tostr3(feedrate_percentage));
       lcd_put_wchar('%');
 
       char buffer[14];
@@ -883,7 +883,7 @@ void MarlinUI::draw_status_screen() {
               per = planner.flow_percentage[0];
             }
           lcd_put_wchar(c);
-          lcd_put_u8str(itostr3(per));
+          lcd_put_u8str(i16tostr3(per));
           lcd_put_wchar('%');
         #endif
       #endif
@@ -924,7 +924,7 @@ void MarlinUI::draw_status_screen() {
 
     lcd_moveto(LCD_WIDTH - 9, 1);
     lcd_put_wchar(LCD_STR_FEEDRATE[0]);
-    lcd_put_u8str(itostr3(feedrate_percentage));
+    lcd_put_u8str(i16tostr3(feedrate_percentage));
     lcd_put_wchar('%');
 
     // ========== Line 3 ==========
@@ -1378,9 +1378,9 @@ void MarlinUI::draw_status_screen() {
        */
       lcd_moveto(_LCD_W_POS, 0);
       lcd_put_wchar('(');
-      lcd_put_u8str(itostr3(x));
+      lcd_put_u8str(ui8tostr3(x));
       lcd_put_wchar(',');
-      lcd_put_u8str(itostr3(inverted_y));
+      lcd_put_u8str(ui8tostr3(inverted_y));
       lcd_put_wchar(')');
 
       #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index c309500b13..e9f552f880 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -866,11 +866,15 @@ void MarlinUI::draw_status_screen() {
           _draw_print_progress();
         #else
           char c;
-          int per;
+          uint16_t per;
           #if HAS_FAN0
-            if (blink) {
-              c = 'F';
-              per = ((int(fan_speed[0]) + 1) * 100) / 256;
+            if (blink || thermalManager.fan_speed_scaler[0] < 128) {
+              uint16_t spd = thermalManager.fan_speed[0];
+              if (blink) c = 'F';
+              #if ENABLED(ADAPTIVE_FAN_SLOWING)
+                else { c = '*'; spd = (spd * thermalManager.fan_speed_scaler[0]) >> 7; }
+              #endif
+              per = thermalManager.fanPercent(spd);
             }
             else
           #endif
@@ -1049,13 +1053,13 @@ void MarlinUI::draw_status_screen() {
       #if FAN_COUNT > 0
         if (0
           #if HAS_FAN0
-            || fan_speed[0]
+            || thermalManager.fan_speed[0]
           #endif
           #if HAS_FAN1
-            || fan_speed[1]
+            || thermalManager.fan_speed[1]
           #endif
           #if HAS_FAN2
-            || fan_speed[2]
+            || thermalManager.fan_speed[2]
           #endif
         ) leds |= LED_C;
       #endif // FAN_COUNT > 0

commit 1f93d2bcf70f1cbe63ac9f21892543663723c8f3
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Nov 19 03:39:49 2018 +0100

    Fix LCD compile error, etc. (#12472)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index a792ce46f1..c309500b13 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -25,7 +25,7 @@
 #if HAS_CHARACTER_LCD
 
 /**
- * ultralcd_impl_HD44780.cpp
+ * ultralcd_HD44780.cpp
  *
  * LCD display implementations for Hitachi HD44780.
  * These are the most common LCD character displays.

commit 826d5701627f4c725ab9e0c61a53643008c5dbbf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 18 19:58:02 2018 -0600

    Combine Travis CI option-setting commands (#12474)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 96921ed755..a792ce46f1 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -40,6 +40,11 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
+#if DISABLED(LCD_PROGRESS_BAR) && ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+  #include "../../feature/filwidth.h"
+  #include "../../gcode/parser.h"
+#endif
+
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/ubl/ubl.h"
 #endif
@@ -97,11 +102,11 @@ static void createChar_P(const char c, const byte * const ptr) {
   #define LCD_STR_PROGRESS  "\x03\x04\x05"
 #endif
 
-void MarlinUI::set_custom_characters(
-  #if ENABLED(LCD_PROGRESS_BAR) || ENABLED(SHOW_BOOTSCREEN)
-    const HD44780CharSet screen_charset/*=CHARSET_INFO*/
+void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
+  #if DISABLED(LCD_PROGRESS_BAR) && DISABLED(SHOW_BOOTSCREEN)
+    UNUSED(screen_charset);
   #endif
-) {
+
   // CHARSET_BOOT
   #if ENABLED(SHOW_BOOTSCREEN)
     const static PROGMEM byte corner[4][8] = { {
@@ -341,7 +346,7 @@ void MarlinUI::init_lcd() {
     lcd.begin(LCD_WIDTH, LCD_HEIGHT);
   #endif
 
-  LCD_SET_CHARSET(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
+  set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
 
   lcd.clear();
 }
@@ -398,7 +403,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   }
 
   void MarlinUI::show_bootscreen() {
-    LCD_SET_CHARSET(CHARSET_BOOT);
+    set_custom_characters(CHARSET_BOOT);
     lcd.clear();
 
     #define LCD_EXTRA_SPACE (LCD_WIDTH-8)
@@ -470,7 +475,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
     lcd.clear();
     safe_delay(100);
-    LCD_SET_CHARSET(CHARSET_INFO);
+    set_custom_characters(CHARSET_INFO);
     lcd.clear();
   }
 
@@ -583,7 +588,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
 
 #if ENABLED(LCD_PROGRESS_BAR)
 
-  inline void lcd_draw_progress_bar(const uint8_t percent) {
+  void MarlinUI::draw_progress_bar(const uint8_t percent) {
     const int16_t tix = (int16_t)(percent * (LCD_WIDTH) * 3) / 100,
               cel = tix / 3,
               rem = tix % 3;
@@ -612,7 +617,7 @@ void MarlinUI::draw_status_message(const bool blink) {
     // or if there is no message set.
     if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !has_status()) {
       const uint8_t progress = get_progress();
-      if (progress > 2) return lcd_draw_progress_bar(progress);
+      if (progress > 2) return draw_progress_bar(progress);
     }
 
   #elif ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)

commit 3e9ffaddb679c6eadd37123fd2d6e1ec0bee4e44
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 21:44:48 2018 -0600

    Consolidate, optimize some LCD menu code (#12450)

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 1a1e7b1750..96921ed755 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -363,10 +363,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       // Fits into,
       lcd_moveto(col, line);
       lcd_put_u8str_max_P(text, len);
-      while (slen < len) {
-        lcd_put_wchar(' ');
-        ++slen;
-      }
+      for (; slen < len; ++slen) lcd_put_wchar(' ');
       safe_delay(time);
     }
     else {
@@ -381,11 +378,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
         lcd_put_u8str_max_P(p, len);
 
         // Fill with spaces
-        uint8_t ix = slen - i;
-        while (ix < len) {
-          lcd_put_wchar(' ');
-          ++ix;
-        }
+        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_wchar(' ');
 
         // Delay
         safe_delay(dly);
@@ -995,7 +988,7 @@ void MarlinUI::draw_status_screen() {
     lcd_moveto(0, row);
     lcd_put_wchar(sel ? pre_char : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
-    while (n--) lcd_put_wchar(' ');
+    for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
@@ -1005,7 +998,7 @@ void MarlinUI::draw_status_screen() {
     lcd_put_wchar(sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     lcd_put_wchar(':');
-    while (n--) lcd_put_wchar(' ');
+    for (; n; --n) lcd_put_wchar(' ');
     if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
   }
 
@@ -1025,40 +1018,14 @@ void MarlinUI::draw_status_screen() {
   #if ENABLED(SDSUPPORT)
 
     void draw_sd_menu_item(const bool sel, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
-      const char post_char = isDir ? LCD_STR_FOLDER[0] : ' ',
-                 sel_char = sel ? LCD_STR_ARROW_RIGHT[0] : ' ';
       UNUSED(pstr);
-      lcd_moveto(0, row);
-      lcd_put_wchar(sel_char);
-
-      uint8_t n = LCD_WIDTH - 2;
-      const char *outstr = theCard.longest_filename();
-      if (theCard.longFilename[0]) {
-        #if ENABLED(SCROLL_LONG_FILENAMES)
-          static uint8_t filename_scroll_hash;
-          if (sel) {
-            uint8_t name_hash = row;
-            for (uint8_t l = FILENAME_LENGTH; l--;)
-              name_hash = ((name_hash << 1) | (name_hash >> 7)) ^ theCard.filename[l];  // rotate, xor
-            if (filename_scroll_hash != name_hash) {                            // If the hash changed...
-              filename_scroll_hash = name_hash;                                 // Save the new hash
-              ui.filename_scroll_max = MAX(0, utf8_strlen(theCard.longFilename) - n); // Update the scroll limit
-              ui.filename_scroll_pos = 0;                                       // Reset scroll to the start
-              ui.lcd_status_update_delay = 8;                                   // Don't scroll right away
-            }
-            outstr += ui.filename_scroll_pos;
-          }
-        #else
-          theCard.longFilename[n] = '\0'; // cutoff at screen edge
-        #endif
-      }
 
       lcd_moveto(0, row);
-      lcd_put_wchar(sel_char);
-      n -= lcd_put_u8str_max(outstr, n);
-
+      lcd_put_wchar(sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+      constexpr uint8_t maxlen = LCD_WIDTH - 2;
+      uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
       for (; n; --n) lcd_put_wchar(' ');
-      lcd_put_wchar(post_char);
+      lcd_put_wchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }
 
   #endif // SDSUPPORT

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
index 1c5c9832a3..1a1e7b1750 100644
--- a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -290,11 +290,11 @@ void MarlinUI::set_custom_characters(
     else
   #endif
     { // Info Screen uses 5 special characters
-      createChar_P(LCD_BEDTEMP_CHAR, bedTemp);
-      createChar_P(LCD_DEGREE_CHAR, degree);
+      createChar_P(LCD_STR_BEDTEMP[0], bedTemp);
+      createChar_P(LCD_STR_DEGREE[0], degree);
       createChar_P(LCD_STR_THERMOMETER[0], thermometer);
-      createChar_P(LCD_FEEDRATE_CHAR, feedrate);
-      createChar_P(LCD_CLOCK_CHAR, clock);
+      createChar_P(LCD_STR_FEEDRATE[0], feedrate);
+      createChar_P(LCD_STR_CLOCK[0], clock);
 
       #if ENABLED(LCD_PROGRESS_BAR)
         if (screen_charset == CHARSET_INFO) { // 3 Progress bar characters for info screen
@@ -304,7 +304,7 @@ void MarlinUI::set_custom_characters(
         else
       #endif
         {
-          createChar_P(LCD_UPLEVEL_CHAR, uplevel);
+          createChar_P(LCD_STR_UPLEVEL[0], uplevel);
           #if ENABLED(SDSUPPORT)
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
@@ -553,7 +553,7 @@ FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, co
       lcd_put_u8str(itostr3left(t2 + 0.5));
 
   if (prefix >= 0) {
-    lcd_put_wchar(LCD_DEGREE_CHAR);
+    lcd_put_wchar(LCD_STR_DEGREE[0]);
     lcd_put_wchar(' ');
     if (t2 < 10) lcd_put_wchar(' ');
   }
@@ -564,7 +564,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
     #if HAS_LEVELING
       planner.leveling_active && blink ? '_' :
     #endif
-    LCD_BEDTEMP_CHAR
+    LCD_STR_BEDTEMP[0]
   ), blink);
 }
 
@@ -769,11 +769,11 @@ void MarlinUI::draw_status_screen() {
       //
       #if HOTENDS > 1
         lcd_moveto(8, 0);
-        lcd_put_wchar((char)LCD_STR_THERMOMETER[0]);
+        lcd_put_wchar(LCD_STR_THERMOMETER[0]);
         _draw_heater_status(1, -1, blink);
       #elif HAS_HEATED_BED
         lcd_moveto(8, 0);
-        lcd_put_wchar((char)LCD_BEDTEMP_CHAR);
+        lcd_put_wchar(LCD_STR_BEDTEMP[0]);
         _draw_heater_status(-1, -1, blink);
       #endif
 
@@ -850,7 +850,7 @@ void MarlinUI::draw_status_screen() {
     #if LCD_HEIGHT > 3
 
       lcd_moveto(0, 2);
-      lcd_put_wchar(LCD_FEEDRATE_CHAR);
+      lcd_put_wchar(LCD_STR_FEEDRATE[0]);
       lcd_put_u8str(itostr3(feedrate_percentage));
       lcd_put_wchar('%');
 
@@ -859,7 +859,7 @@ void MarlinUI::draw_status_screen() {
       const uint8_t len = elapsed.toDigital(buffer),
                     timepos = LCD_WIDTH - len - 1;
       lcd_moveto(timepos, 2);
-      lcd_put_wchar(LCD_CLOCK_CHAR);
+      lcd_put_wchar(LCD_STR_CLOCK[0]);
       lcd_put_u8str(buffer);
 
       #if LCD_WIDTH >= 20
@@ -921,7 +921,7 @@ void MarlinUI::draw_status_screen() {
     #endif
 
     lcd_moveto(LCD_WIDTH - 9, 1);
-    lcd_put_wchar(LCD_FEEDRATE_CHAR);
+    lcd_put_wchar(LCD_STR_FEEDRATE[0]);
     lcd_put_u8str(itostr3(feedrate_percentage));
     lcd_put_wchar('%');
 
@@ -950,7 +950,7 @@ void MarlinUI::draw_status_screen() {
       duration_t elapsed = print_job_timer.duration();
       char buffer[14];
       (void)elapsed.toDigital(buffer);
-      lcd_put_wchar(LCD_CLOCK_CHAR);
+      lcd_put_wchar(LCD_STR_CLOCK[0]);
       lcd_put_u8str(buffer);
     #endif
 
@@ -990,32 +990,23 @@ void MarlinUI::draw_status_screen() {
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 
-  void draw_menu_item_generic(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char post_char) {
+  void draw_menu_item(const bool sel, const uint8_t row, PGM_P pstr, const char pre_char, const char post_char) {
     uint8_t n = LCD_WIDTH - 2;
     lcd_moveto(0, row);
-    lcd_put_wchar(isSelected ? pre_char : ' ');
+    lcd_put_wchar(sel ? pre_char : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     while (n--) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
-  void draw_menu_item_setting_edit_generic(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char* const data) {
-    uint8_t n = LCD_WIDTH - 2 - utf8_strlen(data);
+  void _draw_menu_item_edit(const bool sel, const uint8_t row, PGM_P pstr, const char* const data, const bool pgm) {
+    uint8_t n = LCD_WIDTH - 2 - (pgm ? utf8_strlen_P(data) : utf8_strlen(data));
     lcd_moveto(0, row);
-    lcd_put_wchar(isSelected ? pre_char : ' ');
+    lcd_put_wchar(sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     n -= lcd_put_u8str_max_P(pstr, n);
     lcd_put_wchar(':');
     while (n--) lcd_put_wchar(' ');
-    lcd_put_u8str(data);
-  }
-  void draw_menu_item_setting_edit_generic_P(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char* const data) {
-    uint8_t n = LCD_WIDTH - 2 - utf8_strlen_P(data);
-    lcd_moveto(0, row);
-    lcd_put_wchar(isSelected ? pre_char : ' ');
-    n -= lcd_put_u8str_max_P(pstr, n);
-    lcd_put_wchar(':');
-    while (n--) lcd_put_wchar(' ');
-    lcd_put_u8str_P(data);
+    if (pgm) lcd_put_u8str_P(data); else lcd_put_u8str(data);
   }
 
   void draw_edit_screen(PGM_P const pstr, const char* const value/*=NULL*/) {
@@ -1033,9 +1024,9 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(SDSUPPORT)
 
-    void draw_sd_menu_item(const bool isSelected, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
+    void draw_sd_menu_item(const bool sel, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
       const char post_char = isDir ? LCD_STR_FOLDER[0] : ' ',
-                 sel_char = isSelected ? '>' : ' ';
+                 sel_char = sel ? LCD_STR_ARROW_RIGHT[0] : ' ';
       UNUSED(pstr);
       lcd_moveto(0, row);
       lcd_put_wchar(sel_char);
@@ -1045,7 +1036,7 @@ void MarlinUI::draw_status_screen() {
       if (theCard.longFilename[0]) {
         #if ENABLED(SCROLL_LONG_FILENAMES)
           static uint8_t filename_scroll_hash;
-          if (isSelected) {
+          if (sel) {
             uint8_t name_hash = row;
             for (uint8_t l = FILENAME_LENGTH; l--;)
               name_hash = ((name_hash << 1) | (name_hash >> 7)) ^ theCard.filename[l];  // rotate, xor

commit 0ee1a92971bba0fe5ed290e2562bca71cfb5ea46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 13 01:47:45 2018 -0600

    Group status methods, share reset_status with Extensible UI (#12414)
    
    * Group status methods, share reset_status with Extensible UI
    * Move common DOGM code to headers

diff --git a/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
new file mode 100644
index 0000000000..1c5c9832a3
--- /dev/null
+++ b/Marlin/src/lcd/HD44780/ultralcd_HD44780.cpp
@@ -0,0 +1,1540 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_CHARACTER_LCD
+
+/**
+ * ultralcd_impl_HD44780.cpp
+ *
+ * LCD display implementations for Hitachi HD44780.
+ * These are the most common LCD character displays.
+ */
+
+#include "ultralcd_HD44780.h"
+#include "../ultralcd.h"
+
+#include "../../sd/cardreader.h"
+#include "../../module/temperature.h"
+#include "../../module/printcounter.h"
+#include "../../module/planner.h"
+#include "../../module/motion.h"
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../feature/bedlevel/ubl/ubl.h"
+#endif
+
+//
+// Create LCD instance and chipset-specific information
+//
+
+#if ENABLED(LCD_I2C_TYPE_PCF8575)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_I2C_PIN_EN, LCD_I2C_PIN_RW, LCD_I2C_PIN_RS, LCD_I2C_PIN_D4, LCD_I2C_PIN_D5, LCD_I2C_PIN_D6, LCD_I2C_PIN_D7);
+
+#elif ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS
+    #ifdef DETECT_DEVICE
+      , 1
+    #endif
+  );
+
+#elif ENABLED(LCD_I2C_TYPE_PCA8574)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);
+
+#elif ENABLED(SR_LCD_2W_NL)
+
+  // 2 wire Non-latching LCD SR from:
+  // https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+
+  LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN
+    #if PIN_EXISTS(SR_STROBE)
+      , SR_STROBE_PIN
+    #endif
+  );
+
+#elif ENABLED(LCM1602)
+
+  LCD_CLASS lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
+
+#else
+
+  // Standard direct-connected LCD implementations
+  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5, LCD_PINS_D6, LCD_PINS_D7);
+
+#endif
+
+static void createChar_P(const char c, const byte * const ptr) {
+  byte temp[8];
+  for (uint8_t i = 0; i < 8; i++)
+    temp[i] = pgm_read_byte(&ptr[i]);
+  lcd.createChar(c, temp);
+}
+
+#if ENABLED(LCD_PROGRESS_BAR)
+  #define LCD_STR_PROGRESS  "\x03\x04\x05"
+#endif
+
+void MarlinUI::set_custom_characters(
+  #if ENABLED(LCD_PROGRESS_BAR) || ENABLED(SHOW_BOOTSCREEN)
+    const HD44780CharSet screen_charset/*=CHARSET_INFO*/
+  #endif
+) {
+  // CHARSET_BOOT
+  #if ENABLED(SHOW_BOOTSCREEN)
+    const static PROGMEM byte corner[4][8] = { {
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00001,
+      B00010,
+      B00100,
+      B00100
+    }, {
+      B00000,
+      B00000,
+      B00000,
+      B11100,
+      B11100,
+      B01100,
+      B00100,
+      B00100
+    }, {
+      B00100,
+      B00010,
+      B00001,
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00000
+    }, {
+      B00100,
+      B01000,
+      B10000,
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00000
+    } };
+  #endif // SHOW_BOOTSCREEN
+
+  // CHARSET_INFO
+  const static PROGMEM byte bedTemp[8] = {
+    B00000,
+    B11111,
+    B10101,
+    B10001,
+    B10101,
+    B11111,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte degree[8] = {
+    B01100,
+    B10010,
+    B10010,
+    B01100,
+    B00000,
+    B00000,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte thermometer[8] = {
+    B00100,
+    B01010,
+    B01010,
+    B01010,
+    B01010,
+    B10001,
+    B10001,
+    B01110
+  };
+
+  const static PROGMEM byte uplevel[8] = {
+    B00100,
+    B01110,
+    B11111,
+    B00100,
+    B11100,
+    B00000,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte feedrate[8] = {
+    #if LCD_INFO_SCREEN_STYLE == 1
+      B00000,
+      B00100,
+      B10010,
+      B01001,
+      B10010,
+      B00100,
+      B00000,
+      B00000
+    #else
+      B11100,
+      B10000,
+      B11000,
+      B10111,
+      B00101,
+      B00110,
+      B00101,
+      B00000
+    #endif
+  };
+
+  const static PROGMEM byte clock[8] = {
+    B00000,
+    B01110,
+    B10011,
+    B10101,
+    B10001,
+    B01110,
+    B00000,
+    B00000
+  };
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+
+    // CHARSET_INFO
+    const static PROGMEM byte progress[3][8] = { {
+      B00000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B00000
+    }, {
+      B00000,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B00000
+    }, {
+      B00000,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B00000
+    } };
+
+  #endif // LCD_PROGRESS_BAR
+
+  #if ENABLED(SDSUPPORT)
+
+    // CHARSET_MENU
+    const static PROGMEM byte refresh[8] = {
+      B00000,
+      B00110,
+      B11001,
+      B11000,
+      B00011,
+      B10011,
+      B01100,
+      B00000,
+    };
+    const static PROGMEM byte folder[8] = {
+      B00000,
+      B11100,
+      B11111,
+      B10001,
+      B10001,
+      B11111,
+      B00000,
+      B00000
+    };
+
+  #endif // SDSUPPORT
+
+  #if ENABLED(SHOW_BOOTSCREEN)
+    // Set boot screen corner characters
+    if (screen_charset == CHARSET_BOOT) {
+      for (uint8_t i = 4; i--;)
+        createChar_P(i, corner[i]);
+    }
+    else
+  #endif
+    { // Info Screen uses 5 special characters
+      createChar_P(LCD_BEDTEMP_CHAR, bedTemp);
+      createChar_P(LCD_DEGREE_CHAR, degree);
+      createChar_P(LCD_STR_THERMOMETER[0], thermometer);
+      createChar_P(LCD_FEEDRATE_CHAR, feedrate);
+      createChar_P(LCD_CLOCK_CHAR, clock);
+
+      #if ENABLED(LCD_PROGRESS_BAR)
+        if (screen_charset == CHARSET_INFO) { // 3 Progress bar characters for info screen
+          for (int16_t i = 3; i--;)
+            createChar_P(LCD_STR_PROGRESS[i], progress[i]);
+        }
+        else
+      #endif
+        {
+          createChar_P(LCD_UPLEVEL_CHAR, uplevel);
+          #if ENABLED(SDSUPPORT)
+            // SD Card sub-menu special characters
+            createChar_P(LCD_STR_REFRESH[0], refresh);
+            createChar_P(LCD_STR_FOLDER[0], folder);
+          #endif
+        }
+    }
+
+}
+
+void MarlinUI::init_lcd() {
+
+  #if ENABLED(LCD_I2C_TYPE_PCF8575)
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    #ifdef LCD_I2C_PIN_BL
+      lcd.setBacklightPin(LCD_I2C_PIN_BL, POSITIVE);
+      lcd.setBacklight(HIGH);
+    #endif
+
+  #elif ENABLED(LCD_I2C_TYPE_MCP23017)
+    lcd.setMCPType(LTI_TYPE_MCP23017);
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    update_indicators();
+
+  #elif ENABLED(LCD_I2C_TYPE_MCP23008)
+    lcd.setMCPType(LTI_TYPE_MCP23008);
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+
+  #elif ENABLED(LCD_I2C_TYPE_PCA8574)
+    lcd.init();
+    lcd.backlight();
+
+  #else
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+  #endif
+
+  LCD_SET_CHARSET(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
+
+  lcd.clear();
+}
+
+void MarlinUI::clear_lcd() { lcd.clear(); }
+
+#if ENABLED(SHOW_BOOTSCREEN)
+
+  void lcd_erase_line(const int16_t line) {
+    lcd_moveto(0, line);
+    for (uint8_t i = LCD_WIDTH + 1; --i;)
+      lcd_put_wchar(' ');
+  }
+
+  // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
+  void lcd_scroll(const uint8_t col, const uint8_t line, PGM_P const text, const uint8_t len, const int16_t time) {
+    uint8_t slen = utf8_strlen_P(text);
+    if (slen < len) {
+      // Fits into,
+      lcd_moveto(col, line);
+      lcd_put_u8str_max_P(text, len);
+      while (slen < len) {
+        lcd_put_wchar(' ');
+        ++slen;
+      }
+      safe_delay(time);
+    }
+    else {
+      PGM_P p = text;
+      int dly = time / MAX(slen, 1);
+      for (uint8_t i = 0; i <= slen; i++) {
+
+        // Go to the correct place
+        lcd_moveto(col, line);
+
+        // Print the text
+        lcd_put_u8str_max_P(p, len);
+
+        // Fill with spaces
+        uint8_t ix = slen - i;
+        while (ix < len) {
+          lcd_put_wchar(' ');
+          ++ix;
+        }
+
+        // Delay
+        safe_delay(dly);
+
+        // Advance to the next UTF8 valid position
+        p++;
+        while (!START_OF_UTF8_CHAR(pgm_read_byte(p))) p++;
+      }
+    }
+  }
+
+  static void logo_lines(PGM_P const extra) {
+    int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
+    lcd_moveto(indent, 0); lcd_put_wchar('\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
+    lcd_moveto(indent, 1);                        lcd_put_u8str_P(PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
+    lcd_moveto(indent, 2); lcd_put_wchar('\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
+  }
+
+  void MarlinUI::show_bootscreen() {
+    LCD_SET_CHARSET(CHARSET_BOOT);
+    lcd.clear();
+
+    #define LCD_EXTRA_SPACE (LCD_WIDTH-8)
+
+    #define CENTER_OR_SCROLL(STRING,DELAY) \
+      lcd_erase_line(3); \
+      if (utf8_strlen(STRING) <= LCD_WIDTH) { \
+        lcd_moveto((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3); \
+        lcd_put_u8str_P(PSTR(STRING)); \
+        safe_delay(DELAY); \
+      } \
+      else { \
+        lcd_scroll(0, 3, PSTR(STRING), LCD_WIDTH, DELAY); \
+      }
+
+    #ifdef STRING_SPLASH_LINE1
+      //
+      // Show the Marlin logo with splash line 1
+      //
+      if (LCD_EXTRA_SPACE >= utf8_strlen(STRING_SPLASH_LINE1) + 1) {
+        //
+        // Show the Marlin logo, splash line1, and splash line 2
+        //
+        logo_lines(PSTR(" " STRING_SPLASH_LINE1));
+        #ifdef STRING_SPLASH_LINE2
+          CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 2000);
+        #else
+          safe_delay(2000);
+        #endif
+      }
+      else {
+        //
+        // Show the Marlin logo with splash line 1
+        // After a delay show splash line 2, if it exists
+        //
+        #ifdef STRING_SPLASH_LINE2
+          #define _SPLASH_WAIT_1 1500
+        #else
+          #define _SPLASH_WAIT_1 2000
+        #endif
+        logo_lines(PSTR(""));
+        CENTER_OR_SCROLL(STRING_SPLASH_LINE1, _SPLASH_WAIT_1);
+        #ifdef STRING_SPLASH_LINE2
+          CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 1500);
+          #ifdef STRING_SPLASH_LINE3
+            CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
+          #endif
+        #endif
+      }
+    #elif defined(STRING_SPLASH_LINE2)
+      //
+      // Show splash line 2 only, alongside the logo if possible
+      //
+      if (LCD_EXTRA_SPACE >= utf8_strlen(STRING_SPLASH_LINE2) + 1) {
+        logo_lines(PSTR(" " STRING_SPLASH_LINE2));
+        safe_delay(2000);
+      }
+      else {
+        logo_lines(PSTR(""));
+        CENTER_OR_SCROLL(STRING_SPLASH_LINE2, 2000);
+      }
+    #else
+      //
+      // Show only the Marlin logo
+      //
+      logo_lines(PSTR(""));
+      safe_delay(2000);
+    #endif
+
+    lcd.clear();
+    safe_delay(100);
+    LCD_SET_CHARSET(CHARSET_INFO);
+    lcd.clear();
+  }
+
+#endif // SHOW_BOOTSCREEN
+
+void MarlinUI::draw_kill_screen() {
+  lcd_moveto(0, 0);
+  lcd_put_u8str(status_message);
+  #if LCD_HEIGHT < 4
+    lcd_moveto(0, 2);
+  #else
+    lcd_moveto(0, 2);
+    lcd_put_u8str_P(PSTR(MSG_HALTED));
+    lcd_moveto(0, 3);
+  #endif
+  lcd_put_u8str_P(PSTR(MSG_PLEASE_RESET));
+}
+
+//
+// Before homing, blink '123' <-> '???'.
+// Homed but unknown... '123' <-> '   '.
+// Homed and known, display constantly.
+//
+FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const bool blink) {
+  lcd_put_wchar('X' + uint8_t(axis));
+  if (blink)
+    lcd_put_u8str(value);
+  else {
+    if (!TEST(axis_homed, axis))
+      while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
+    else {
+      #if DISABLED(HOME_AFTER_DEACTIVATE) && DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
+        if (!TEST(axis_known_position, axis))
+          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("      ") : PSTR("    "));
+        else
+      #endif
+          lcd_put_u8str(value);
+    }
+  }
+}
+
+FORCE_INLINE void _draw_heater_status(const int8_t heater, const char prefix, const bool blink) {
+  #if HAS_HEATED_BED
+    const bool isBed = heater < 0;
+    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater)),
+                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater));
+  #else
+    const float t1 = thermalManager.degHotend(heater), t2 = thermalManager.degTargetHotend(heater);
+  #endif
+
+  if (prefix >= 0) lcd_put_wchar(prefix);
+
+  lcd_put_u8str(itostr3(t1 + 0.5));
+  lcd_put_wchar('/');
+
+  #if !HEATER_IDLE_HANDLER
+    UNUSED(blink);
+  #else
+    const bool is_idle = (
+      #if HAS_HEATED_BED
+        isBed ? thermalManager.is_bed_idle() :
+      #endif
+      thermalManager.is_heater_idle(heater)
+    );
+
+    if (!blink && is_idle) {
+      lcd_put_wchar(' ');
+      if (t2 >= 10) lcd_put_wchar(' ');
+      if (t2 >= 100) lcd_put_wchar(' ');
+    }
+    else
+  #endif
+      lcd_put_u8str(itostr3left(t2 + 0.5));
+
+  if (prefix >= 0) {
+    lcd_put_wchar(LCD_DEGREE_CHAR);
+    lcd_put_wchar(' ');
+    if (t2 < 10) lcd_put_wchar(' ');
+  }
+}
+
+FORCE_INLINE void _draw_bed_status(const bool blink) {
+  _draw_heater_status(-1, (
+    #if HAS_LEVELING
+      planner.leveling_active && blink ? '_' :
+    #endif
+    LCD_BEDTEMP_CHAR
+  ), blink);
+}
+
+#if HAS_PRINT_PROGRESS
+
+  FORCE_INLINE void _draw_print_progress() {
+    const uint8_t progress = ui.get_progress();
+    lcd_put_u8str_P(PSTR(
+      #if ENABLED(SDSUPPORT)
+        "SD"
+      #elif ENABLED(LCD_SET_PROGRESS_MANUALLY)
+        "P:"
+      #endif
+    ));
+    if (progress)
+      lcd_put_u8str(itostr3(progress));
+    else
+      lcd_put_u8str_P(PSTR("---"));
+    lcd_put_wchar('%');
+  }
+
+#endif
+
+#if ENABLED(LCD_PROGRESS_BAR)
+
+  inline void lcd_draw_progress_bar(const uint8_t percent) {
+    const int16_t tix = (int16_t)(percent * (LCD_WIDTH) * 3) / 100,
+              cel = tix / 3,
+              rem = tix % 3;
+    uint8_t i = LCD_WIDTH;
+    char msg[LCD_WIDTH + 1], b = ' ';
+    msg[LCD_WIDTH] = '\0';
+    while (i--) {
+      if (i == cel - 1)
+        b = LCD_STR_PROGRESS[2];
+      else if (i == cel && rem != 0)
+        b = LCD_STR_PROGRESS[rem - 1];
+      msg[i] = b;
+    }
+    lcd_put_u8str(msg);
+  }
+
+#endif // LCD_PROGRESS_BAR
+
+void MarlinUI::draw_status_message(const bool blink) {
+
+  lcd_moveto(0, LCD_HEIGHT - 1);
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+
+    // Draw the progress bar if the message has shown long enough
+    // or if there is no message set.
+    if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !has_status()) {
+      const uint8_t progress = get_progress();
+      if (progress > 2) return lcd_draw_progress_bar(progress);
+    }
+
+  #elif ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+
+    // Alternate Status message and Filament display
+    if (ELAPSED(millis(), next_filament_display)) {
+      lcd_put_u8str_P(PSTR("Dia "));
+      lcd_put_u8str(ftostr12ns(filament_width_meas));
+      lcd_put_u8str_P(PSTR(" V"));
+      lcd_put_u8str(itostr3(100.0 * (
+          parser.volumetric_enabled
+            ? planner.volumetric_area_nominal / planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
+            : planner.volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
+        )
+      ));
+      lcd_put_wchar('%');
+      return;
+    }
+
+  #endif // FILAMENT_LCD_DISPLAY && SDSUPPORT
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    static bool last_blink = false;
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(status_message);
+
+    // If the string fits into the LCD, just print it and do not scroll it
+    if (slen <= LCD_WIDTH) {
+
+      // The string isn't scrolling and may not fill the screen
+      lcd_put_u8str(status_message);
+
+      // Fill the rest with spaces
+      while (slen < LCD_WIDTH) {
+        lcd_put_wchar(' ');
+        ++slen;
+      }
+    }
+    else {
+      // String is larger than the available space in screen.
+
+      // Get a pointer to the next valid UTF8 character
+      const char *stat = status_message + status_scroll_offset;
+
+      // Get the string remaining length
+      const uint8_t rlen = utf8_strlen(stat);
+
+      // If we have enough characters to display
+      if (rlen >= LCD_WIDTH) {
+        // The remaining string fills the screen - Print it
+        lcd_put_u8str_max(stat, LCD_WIDTH);
+      }
+      else {
+
+        // The remaining string does not completely fill the screen
+        lcd_put_u8str_max(stat, LCD_WIDTH);               // The string leaves space
+        uint8_t chars = LCD_WIDTH - rlen;                 // Amount of space left in characters
+
+        lcd_put_wchar('.');                               // Always at 1+ spaces left, draw a dot
+        if (--chars) {                                    // Draw a second dot if there's space
+          lcd_put_wchar('.');
+          if (--chars)
+            lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
+        }
+      }
+      if (last_blink != blink) {
+        last_blink = blink;
+
+        // Adjust by complete UTF8 characters
+        if (status_scroll_offset < slen) {
+          status_scroll_offset++;
+          while (!START_OF_UTF8_CHAR(status_message[status_scroll_offset]))
+            status_scroll_offset++;
+        }
+        else
+          status_scroll_offset = 0;
+      }
+    }
+  #else
+    UNUSED(blink);
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(status_message);
+
+    // Just print the string to the LCD
+    lcd_put_u8str_max(status_message, LCD_WIDTH);
+
+    // Fill the rest with spaces if there are missing spaces
+    while (slen < LCD_WIDTH) {
+      lcd_put_wchar(' ');
+      ++slen;
+    }
+  #endif
+}
+
+/**
+ *  LCD_INFO_SCREEN_STYLE 0 : Classic Status Screen
+ *
+ *  16x2   |000/000 B000/000|
+ *         |0123456789012345|
+ *
+ *  16x4   |000/000 B000/000|
+ *         |SD---%  Z 000.00|
+ *         |F---%     T--:--|
+ *         |0123456789012345|
+ *
+ *  20x2   |T000/000° B000/000° |
+ *         |01234567890123456789|
+ *
+ *  20x4   |T000/000° B000/000° |
+ *         |X 000 Y 000 Z000.000|
+ *         |F---%  SD---% T--:--|
+ *         |01234567890123456789|
+ *
+ *  LCD_INFO_SCREEN_STYLE 1 : Prusa-style Status Screen
+ *
+ *  |T000/000°  Z 000.00 |
+ *  |B000/000°  F---%    |
+ *  |SD---%     T--:--   |
+ *  |01234567890123456789|
+ *
+ *  |T000/000°  Z 000.00 |
+ *  |T000/000°  F---%    |
+ *  |B000/000°  SD---%   |
+ *  |01234567890123456789|
+ */
+
+void MarlinUI::draw_status_screen() {
+
+  const bool blink = get_blink();
+  lcd_moveto(0, 0);
+
+  #if LCD_INFO_SCREEN_STYLE == 0
+
+    // ========== Line 1 ==========
+
+    #if LCD_WIDTH < 20
+
+      //
+      // Hotend 0 Temperature
+      //
+      _draw_heater_status(0, -1, blink);
+
+      //
+      // Hotend 1 or Bed Temperature
+      //
+      #if HOTENDS > 1
+        lcd_moveto(8, 0);
+        lcd_put_wchar((char)LCD_STR_THERMOMETER[0]);
+        _draw_heater_status(1, -1, blink);
+      #elif HAS_HEATED_BED
+        lcd_moveto(8, 0);
+        lcd_put_wchar((char)LCD_BEDTEMP_CHAR);
+        _draw_heater_status(-1, -1, blink);
+      #endif
+
+    #else // LCD_WIDTH >= 20
+
+      //
+      // Hotend 0 Temperature
+      //
+      _draw_heater_status(0, LCD_STR_THERMOMETER[0], blink);
+
+      //
+      // Hotend 1 or Bed Temperature
+      //
+      #if HOTENDS > 1
+        lcd_moveto(10, 0);
+        _draw_heater_status(1, LCD_STR_THERMOMETER[0], blink);
+      #elif HAS_HEATED_BED
+        lcd_moveto(10, 0);
+        _draw_bed_status(blink);
+      #endif
+
+    #endif // LCD_WIDTH >= 20
+
+    // ========== Line 2 ==========
+
+    #if LCD_HEIGHT > 2
+
+      #if LCD_WIDTH < 20
+
+        #if HAS_PRINT_PROGRESS
+          lcd_moveto(0, 2);
+          _draw_print_progress();
+        #endif
+
+      #else // LCD_WIDTH >= 20
+
+        lcd_moveto(0, 1);
+
+        // If the first line has two extruder temps,
+        // show more temperatures on the next line
+
+        #if HOTENDS > 2 || (HOTENDS > 1 && HAS_HEATED_BED)
+
+          #if HOTENDS > 2
+            _draw_heater_status(2, LCD_STR_THERMOMETER[0], blink);
+            lcd_moveto(10, 1);
+          #endif
+
+          _draw_bed_status(blink);
+
+        #else // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
+
+          _draw_axis_value(X_AXIS, ftostr4sign(LOGICAL_X_POSITION(current_position[X_AXIS])), blink);
+
+          lcd_put_wchar(' ');
+
+          _draw_axis_value(Y_AXIS, ftostr4sign(LOGICAL_Y_POSITION(current_position[Y_AXIS])), blink);
+
+        #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
+
+      #endif // LCD_WIDTH >= 20
+
+      lcd_moveto(LCD_WIDTH - 8, 1);
+      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position[Z_AXIS])), blink);
+
+      #if HAS_LEVELING && !HAS_HEATED_BED
+        lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
+      #endif
+
+    #endif // LCD_HEIGHT > 2
+
+    // ========== Line 3 ==========
+
+    #if LCD_HEIGHT > 3
+
+      lcd_moveto(0, 2);
+      lcd_put_wchar(LCD_FEEDRATE_CHAR);
+      lcd_put_u8str(itostr3(feedrate_percentage));
+      lcd_put_wchar('%');
+
+      char buffer[14];
+      duration_t elapsed = print_job_timer.duration();
+      const uint8_t len = elapsed.toDigital(buffer),
+                    timepos = LCD_WIDTH - len - 1;
+      lcd_moveto(timepos, 2);
+      lcd_put_wchar(LCD_CLOCK_CHAR);
+      lcd_put_u8str(buffer);
+
+      #if LCD_WIDTH >= 20
+        lcd_moveto(timepos - 7, 2);
+        #if HAS_PRINT_PROGRESS
+          _draw_print_progress();
+        #else
+          char c;
+          int per;
+          #if HAS_FAN0
+            if (blink) {
+              c = 'F';
+              per = ((int(fan_speed[0]) + 1) * 100) / 256;
+            }
+            else
+          #endif
+            {
+              c = 'E';
+              per = planner.flow_percentage[0];
+            }
+          lcd_put_wchar(c);
+          lcd_put_u8str(itostr3(per));
+          lcd_put_wchar('%');
+        #endif
+      #endif
+
+    #endif // LCD_HEIGHT > 3
+
+  #elif LCD_INFO_SCREEN_STYLE == 1
+
+    // ========== Line 1 ==========
+
+    //
+    // Hotend 0 Temperature
+    //
+    _draw_heater_status(0, LCD_STR_THERMOMETER[0], blink);
+
+    //
+    // Z Coordinate
+    //
+    lcd_moveto(LCD_WIDTH - 9, 0);
+    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position[Z_AXIS])), blink);
+
+    #if HAS_LEVELING && (HOTENDS > 1 || !HAS_HEATED_BED)
+      lcd_moveto(LCD_WIDTH - 1, 0);
+      lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
+    #endif
+
+    // ========== Line 2 ==========
+
+    //
+    // Hotend 1 or Bed Temperature
+    //
+    lcd_moveto(0, 1);
+    #if HOTENDS > 1
+      _draw_heater_status(1, LCD_STR_THERMOMETER[0], blink);
+    #elif HAS_HEATED_BED
+      _draw_bed_status(blink);
+    #endif
+
+    lcd_moveto(LCD_WIDTH - 9, 1);
+    lcd_put_wchar(LCD_FEEDRATE_CHAR);
+    lcd_put_u8str(itostr3(feedrate_percentage));
+    lcd_put_wchar('%');
+
+    // ========== Line 3 ==========
+
+    //
+    // SD Percent, Hotend 2, or Bed
+    //
+    lcd_moveto(0, 2);
+    #if HOTENDS > 2
+      _draw_heater_status(2, LCD_STR_THERMOMETER[0], blink);
+    #elif HOTENDS > 1 && HAS_HEATED_BED
+      _draw_bed_status(blink);
+    #elif HAS_PRINT_PROGRESS
+      #define DREW_PRINT_PROGRESS
+      _draw_print_progress();
+    #endif
+
+    //
+    // Elapsed Time or SD Percent
+    //
+    lcd_moveto(LCD_WIDTH - 9, 2);
+    #if HAS_PRINT_PROGRESS && !defined(DREW_PRINT_PROGRESS)
+      _draw_print_progress();
+    #else
+      duration_t elapsed = print_job_timer.duration();
+      char buffer[14];
+      (void)elapsed.toDigital(buffer);
+      lcd_put_wchar(LCD_CLOCK_CHAR);
+      lcd_put_u8str(buffer);
+    #endif
+
+  #endif // LCD_INFO_SCREEN_STYLE 1
+
+  // ========= Last Line ========
+
+  //
+  // Status Message (which may be a Progress Bar or Filament display)
+  //
+  draw_status_message(blink);
+}
+
+#if HAS_LCD_MENU
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+    void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
+      if (row < LCD_HEIGHT) {
+        lcd_moveto(LCD_WIDTH - 9, row);
+        _draw_heater_status(extruder, LCD_STR_THERMOMETER[0], ui.get_blink());
+      }
+    }
+
+  #endif // ADVANCED_PAUSE_FEATURE
+
+  void draw_menu_item_static(const uint8_t row, PGM_P pstr, const bool center/*=true*/, const bool invert/*=false*/, const char *valstr/*=NULL*/) {
+    UNUSED(invert);
+    int8_t n = LCD_WIDTH;
+    lcd_moveto(0, row);
+    if (center && !valstr) {
+      int8_t pad = (LCD_WIDTH - utf8_strlen_P(pstr)) / 2;
+      while (--pad >= 0) { lcd_put_wchar(' '); n--; }
+    }
+    n -= lcd_put_u8str_max_P(pstr, n);
+    if (valstr) n -= lcd_put_u8str_max(valstr, n);
+    for (; n > 0; --n) lcd_put_wchar(' ');
+  }
+
+  void draw_menu_item_generic(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char post_char) {
+    uint8_t n = LCD_WIDTH - 2;
+    lcd_moveto(0, row);
+    lcd_put_wchar(isSelected ? pre_char : ' ');
+    n -= lcd_put_u8str_max_P(pstr, n);
+    while (n--) lcd_put_wchar(' ');
+    lcd_put_wchar(post_char);
+  }
+
+  void draw_menu_item_setting_edit_generic(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char* const data) {
+    uint8_t n = LCD_WIDTH - 2 - utf8_strlen(data);
+    lcd_moveto(0, row);
+    lcd_put_wchar(isSelected ? pre_char : ' ');
+    n -= lcd_put_u8str_max_P(pstr, n);
+    lcd_put_wchar(':');
+    while (n--) lcd_put_wchar(' ');
+    lcd_put_u8str(data);
+  }
+  void draw_menu_item_setting_edit_generic_P(const bool isSelected, const uint8_t row, PGM_P pstr, const char pre_char, const char* const data) {
+    uint8_t n = LCD_WIDTH - 2 - utf8_strlen_P(data);
+    lcd_moveto(0, row);
+    lcd_put_wchar(isSelected ? pre_char : ' ');
+    n -= lcd_put_u8str_max_P(pstr, n);
+    lcd_put_wchar(':');
+    while (n--) lcd_put_wchar(' ');
+    lcd_put_u8str_P(data);
+  }
+
+  void draw_edit_screen(PGM_P const pstr, const char* const value/*=NULL*/) {
+    lcd_moveto(1, 1);
+    lcd_put_u8str_P(pstr);
+    if (value != NULL) {
+      lcd_put_wchar(':');
+      int len = utf8_strlen(value);
+      const uint8_t valrow = (utf8_strlen_P(pstr) + 1 + len + 1) > (LCD_WIDTH - 2) ? 2 : 1;   // Value on the next row if it won't fit
+      lcd_moveto((LCD_WIDTH - 1) - (len + 1), valrow);                                        // Right-justified, padded by spaces
+      lcd_put_wchar(' ');                                                                     // Overwrite char if value gets shorter
+      lcd_put_u8str(value);
+    }
+  }
+
+  #if ENABLED(SDSUPPORT)
+
+    void draw_sd_menu_item(const bool isSelected, const uint8_t row, PGM_P const pstr, CardReader &theCard, const bool isDir) {
+      const char post_char = isDir ? LCD_STR_FOLDER[0] : ' ',
+                 sel_char = isSelected ? '>' : ' ';
+      UNUSED(pstr);
+      lcd_moveto(0, row);
+      lcd_put_wchar(sel_char);
+
+      uint8_t n = LCD_WIDTH - 2;
+      const char *outstr = theCard.longest_filename();
+      if (theCard.longFilename[0]) {
+        #if ENABLED(SCROLL_LONG_FILENAMES)
+          static uint8_t filename_scroll_hash;
+          if (isSelected) {
+            uint8_t name_hash = row;
+            for (uint8_t l = FILENAME_LENGTH; l--;)
+              name_hash = ((name_hash << 1) | (name_hash >> 7)) ^ theCard.filename[l];  // rotate, xor
+            if (filename_scroll_hash != name_hash) {                            // If the hash changed...
+              filename_scroll_hash = name_hash;                                 // Save the new hash
+              ui.filename_scroll_max = MAX(0, utf8_strlen(theCard.longFilename) - n); // Update the scroll limit
+              ui.filename_scroll_pos = 0;                                       // Reset scroll to the start
+              ui.lcd_status_update_delay = 8;                                   // Don't scroll right away
+            }
+            outstr += ui.filename_scroll_pos;
+          }
+        #else
+          theCard.longFilename[n] = '\0'; // cutoff at screen edge
+        #endif
+      }
+
+      lcd_moveto(0, row);
+      lcd_put_wchar(sel_char);
+      n -= lcd_put_u8str_max(outstr, n);
+
+      for (; n; --n) lcd_put_wchar(' ');
+      lcd_put_wchar(post_char);
+    }
+
+  #endif // SDSUPPORT
+
+  #if ENABLED(LCD_HAS_STATUS_INDICATORS)
+
+    static void MarlinUI::update_indicators() {
+      // Set the LEDS - referred to as backlights by the LiquidTWI2 library
+      static uint8_t ledsprev = 0;
+      uint8_t leds = 0;
+
+      if (thermalManager.degTargetBed() > 0) leds |= LED_A;
+
+      if (thermalManager.degTargetHotend(0) > 0) leds |= LED_B;
+
+      #if FAN_COUNT > 0
+        if (0
+          #if HAS_FAN0
+            || fan_speed[0]
+          #endif
+          #if HAS_FAN1
+            || fan_speed[1]
+          #endif
+          #if HAS_FAN2
+            || fan_speed[2]
+          #endif
+        ) leds |= LED_C;
+      #endif // FAN_COUNT > 0
+
+      #if HOTENDS > 1
+        if (thermalManager.degTargetHotend(1) > 0) leds |= LED_C;
+      #endif
+
+      if (leds != ledsprev) {
+        lcd.setBacklight(leds);
+        ledsprev = leds;
+      }
+    }
+
+  #endif // LCD_HAS_STATUS_INDICATORS
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    #define HD44780_CHAR_WIDTH    5
+    #define HD44780_CHAR_HEIGHT   8
+    #define MESH_MAP_COLS         7
+    #define MESH_MAP_ROWS         4
+
+    #define CHAR_LINE_TOP         0
+    #define CHAR_LINE_BOT         1
+    #define CHAR_EDGE_L           2
+    #define CHAR_EDGE_R           3
+    #define CHAR_UL_UL            4
+    #define CHAR_LR_UL            5
+    #define CHAR_UL_LR            6
+    #define CHAR_LR_LR            7
+
+    #define TOP_LEFT         _BV(0)
+    #define TOP_RIGHT        _BV(1)
+    #define LOWER_LEFT       _BV(2)
+    #define LOWER_RIGHT      _BV(3)
+
+    /**
+     * Possible map screens:
+     *
+     * 16x2   |X000.00  Y000.00|
+     *        |(00,00)  Z00.000|
+     *
+     * 20x2   | X:000.00  Y:000.00 |
+     *        | (00,00)   Z:00.000 |
+     *
+     * 16x4   |+-------+(00,00)|
+     *        ||       |X000.00|
+     *        ||       |Y000.00|
+     *        |+-------+Z00.000|
+     *
+     * 20x4   | +-------+  (00,00) |
+     *        | |       |  X:000.00|
+     *        | |       |  Y:000.00|
+     *        | +-------+  Z:00.000|
+     */
+
+    typedef struct {
+      uint8_t custom_char_bits[HD44780_CHAR_HEIGHT];
+    } custom_char;
+
+    typedef struct {
+      uint8_t column, row,
+              x_pixel_offset, y_pixel_offset,
+              x_pixel_mask;
+    } coordinate;
+
+    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location);
+    FORCE_INLINE static void clear_custom_char(custom_char * const cc) { ZERO(cc->custom_char_bits); }
+
+    coordinate pixel_location(int16_t x, int16_t y) {
+      coordinate ret_val;
+      int16_t xp, yp, r, c;
+
+      x++; y++; // +1 because lines on the left and top
+
+      c = x / (HD44780_CHAR_WIDTH);
+      r = y / (HD44780_CHAR_HEIGHT);
+
+      ret_val.column = c;
+      ret_val.row    = r;
+
+      xp = x - c * (HD44780_CHAR_WIDTH);                                    // Get the pixel offsets into the character cell
+      xp = HD44780_CHAR_WIDTH - 1 - xp;                                     // Column within relevant character cell (0 on the right)
+      yp = y - r * (HD44780_CHAR_HEIGHT);
+
+      ret_val.x_pixel_mask   = _BV(xp);
+      ret_val.x_pixel_offset = xp;
+      ret_val.y_pixel_offset = yp;
+      return ret_val;
+    }
+
+    inline coordinate pixel_location(const uint8_t x, const uint8_t y) { return pixel_location((int16_t)x, (int16_t)y); }
+
+    void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const uint8_t x, const uint8_t y) {
+      add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
+      lcd.createChar(c, (uint8_t*)&chrdata);
+      lcd_moveto(x, y);
+      lcd_put_wchar(c);
+    }
+
+    void MarlinUI::ubl_plot(const uint8_t x, const uint8_t inverted_y) {
+
+      #if LCD_WIDTH >= 20
+        #define _LCD_W_POS 12
+        #define _PLOT_X 1
+        #define _MAP_X 3
+        #define _LABEL(C,X,Y) lcd_moveto(X, Y); lcd_put_u8str(C)
+        #define _XLABEL(X,Y) _LABEL("X:",X,Y)
+        #define _YLABEL(X,Y) _LABEL("Y:",X,Y)
+        #define _ZLABEL(X,Y) _LABEL("Z:",X,Y)
+      #else
+        #define _LCD_W_POS 8
+        #define _PLOT_X 0
+        #define _MAP_X 1
+        #define _LABEL(X,Y,C) lcd_moveto(X, Y); lcd_put_wchar(C)
+        #define _XLABEL(X,Y) _LABEL('X',X,Y)
+        #define _YLABEL(X,Y) _LABEL('Y',X,Y)
+        #define _ZLABEL(X,Y) _LABEL('Z',X,Y)
+      #endif
+
+      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
+
+        /**
+         * Show X and Y positions
+         */
+        _XLABEL(_PLOT_X, 0);
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x]))));
+
+        _YLABEL(_LCD_W_POS, 0);
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[inverted_y]))));
+
+        lcd_moveto(_PLOT_X, 0);
+
+      #else // 16x4 or 20x4 display
+
+        coordinate upper_left, lower_right, bottom_right_corner;
+        custom_char new_char;
+        uint8_t i, j, k, l, m, n, n_rows, n_cols, y,
+                bottom_line, right_edge,
+                x_map_pixels, y_map_pixels,
+                pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
+                suppress_x_offset = 0, suppress_y_offset = 0;
+
+        y = GRID_MAX_POINTS_Y - inverted_y - 1;
+
+        upper_left.column  = 0;
+        upper_left.row     = 0;
+        lower_right.column = 0;
+        lower_right.row    = 0;
+
+        clear_lcd();
+
+        x_map_pixels = (HD44780_CHAR_WIDTH) * (MESH_MAP_COLS) - 2;          // Minus 2 because we are drawing a box around the map
+        y_map_pixels = (HD44780_CHAR_HEIGHT) * (MESH_MAP_ROWS) - 2;
+
+        pixels_per_x_mesh_pnt = x_map_pixels / (GRID_MAX_POINTS_X);
+        pixels_per_y_mesh_pnt = y_map_pixels / (GRID_MAX_POINTS_Y);
+
+        if (pixels_per_x_mesh_pnt >= HD44780_CHAR_WIDTH) {                  // There are only 2 custom characters available, so the X
+          pixels_per_x_mesh_pnt = HD44780_CHAR_WIDTH;                       // Size of the mesh point needs to fit within them independent
+          suppress_x_offset = 1;                                            // Of where the starting pixel is located.
+        }
+
+        if (pixels_per_y_mesh_pnt >= HD44780_CHAR_HEIGHT) {                 // There are only 2 custom characters available, so the Y
+          pixels_per_y_mesh_pnt = HD44780_CHAR_HEIGHT;                      // Size of the mesh point needs to fit within them independent
+          suppress_y_offset = 1;                                            // Of where the starting pixel is located.
+        }
+
+        x_map_pixels = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X);         // Now we have the right number of pixels to make both
+        y_map_pixels = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y);         // Directions fit nicely
+
+        right_edge   = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X) + 1;     // Find location of right edge within the character cell
+        bottom_line  = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 1;     // Find location of bottome line within the character cell
+
+        n_rows = bottom_line / (HD44780_CHAR_HEIGHT) + 1;
+        n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;
+
+        for (i = 0; i < n_cols; i++) {
+          lcd_moveto(i, 0);
+          lcd_put_wchar(CHAR_LINE_TOP);                                     // Box Top line
+          lcd_moveto(i, n_rows - 1);
+          lcd_put_wchar(CHAR_LINE_BOT);                                     // Box Bottom line
+        }
+
+        for (j = 0; j < n_rows; j++) {
+          lcd_moveto(0, j);
+          lcd_put_wchar(CHAR_EDGE_L);                                       // Box Left edge
+          lcd_moveto(n_cols - 1, j);
+          lcd_put_wchar(CHAR_EDGE_R);                                       // Box Right edge
+        }
+
+        /**
+         * If the entire 4th row is not in use, do not put vertical bars all the way down to the bottom of the display
+         */
+
+        k = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 2;
+        l = (HD44780_CHAR_HEIGHT) * n_rows;
+        if (l > k && l - k >= (HD44780_CHAR_HEIGHT) / 2) {
+          lcd_moveto(0, n_rows - 1);                                        // Box Left edge
+          lcd_put_wchar(' ');
+          lcd_moveto(n_cols - 1, n_rows - 1);                               // Box Right edge
+          lcd_put_wchar(' ');
+        }
+
+        clear_custom_char(&new_char);
+        new_char.custom_char_bits[0] = 0b11111U;                            // Char #0 is used for the box top line
+        lcd.createChar(CHAR_LINE_TOP, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        k = (GRID_MAX_POINTS_Y) * pixels_per_y_mesh_pnt + 1;                // Row of pixels for the bottom box line
+        l = k % (HD44780_CHAR_HEIGHT);                                      // Row within relevant character cell
+        new_char.custom_char_bits[l] = 0b11111U;                            // Char #1 is used for the box bottom line
+        lcd.createChar(CHAR_LINE_BOT, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
+          new_char.custom_char_bits[j] = 0b10000U;                          // Char #2 is used for the box left edge
+        lcd.createChar(CHAR_EDGE_L, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        m = (GRID_MAX_POINTS_X) * pixels_per_x_mesh_pnt + 1;                // Column of pixels for the right box line
+        n = m % (HD44780_CHAR_WIDTH);                                       // Column within relevant character cell
+        i = HD44780_CHAR_WIDTH - 1 - n;                                     // Column within relevant character cell (0 on the right)
+        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
+          new_char.custom_char_bits[j] = (uint8_t)_BV(i);                   // Char #3 is used for the box right edge
+        lcd.createChar(CHAR_EDGE_R, (uint8_t*)&new_char);
+
+        i = x * pixels_per_x_mesh_pnt - suppress_x_offset;
+        j = y * pixels_per_y_mesh_pnt - suppress_y_offset;
+        upper_left = pixel_location(i, j);
+
+        k = (x + 1) * pixels_per_x_mesh_pnt - 1 - suppress_x_offset;
+        l = (y + 1) * pixels_per_y_mesh_pnt - 1 - suppress_y_offset;
+        lower_right = pixel_location(k, l);
+
+        bottom_right_corner = pixel_location(x_map_pixels, y_map_pixels);
+
+        /**
+         * First, handle the simple case where everything is within a single character cell.
+         * If part of the Mesh Plot is outside of this character cell, we will follow up
+         * and deal with that next.
+         */
+
+        clear_custom_char(&new_char);
+        const uint8_t ypix = MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
+        for (j = upper_left.y_pixel_offset; j < ypix; j++) {
+          i = upper_left.x_pixel_mask;
+          for (k = 0; k < pixels_per_x_mesh_pnt; k++) {
+            new_char.custom_char_bits[j] |= i;
+            i >>= 1;
+          }
+        }
+
+        prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_LEFT, CHAR_UL_UL, upper_left.column, upper_left.row);
+
+        /**
+         * Next, check for two side by side character cells being used to display the Mesh Point
+         * If found...  do the right hand character cell next.
+         */
+        if (upper_left.column == lower_right.column - 1) {
+          l = upper_left.x_pixel_offset;
+          clear_custom_char(&new_char);
+          for (j = upper_left.y_pixel_offset; j < ypix; j++) {
+            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
+            for (k = 0; k < pixels_per_x_mesh_pnt - 1 - l; k++) {
+              new_char.custom_char_bits[j] |= i;
+              i >>= 1;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_RIGHT, CHAR_LR_UL, lower_right.column, upper_left.row);
+        }
+
+        /**
+         * Next, check for two character cells stacked on top of each other being used to display the Mesh Point
+         */
+        if (upper_left.row == lower_right.row - 1) {
+          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
+          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
+          clear_custom_char(&new_char);
+          for (j = 0; j < k; j++) {
+            i = upper_left.x_pixel_mask;
+            for (m = 0; m < pixels_per_x_mesh_pnt; m++) {                   // Fill in the top side of the bottom character cell
+              new_char.custom_char_bits[j] |= i;
+              if (!(i >>= 1)) break;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_LEFT, CHAR_UL_LR, upper_left.column, lower_right.row);
+        }
+
+        /**
+         * Next, check for four character cells being used to display the Mesh Point.  If that is
+         * what is here, we work to fill in the character cell that is down one and to the right one
+         * from the upper_left character cell.
+         */
+
+        if (upper_left.column == lower_right.column - 1 && upper_left.row == lower_right.row - 1) {
+          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
+          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
+          clear_custom_char(&new_char);
+          for (j = 0; j < k; j++) {
+            l = upper_left.x_pixel_offset;
+            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
+            for (m = 0; m < pixels_per_x_mesh_pnt - 1 - l; m++) {           // Fill in the top side of the bottom character cell
+              new_char.custom_char_bits[j] |= i;
+              i >>= 1;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_RIGHT, CHAR_LR_LR, lower_right.column, lower_right.row);
+        }
+
+      #endif
+
+      /**
+       * Print plot position
+       */
+      lcd_moveto(_LCD_W_POS, 0);
+      lcd_put_wchar('(');
+      lcd_put_u8str(itostr3(x));
+      lcd_put_wchar(',');
+      lcd_put_u8str(itostr3(inverted_y));
+      lcd_put_wchar(')');
+
+      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
+
+        /**
+         * Print Z values
+         */
+        _ZLABEL(_LCD_W_POS, 1);
+        if (!isnan(ubl.z_values[x][inverted_y]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x][inverted_y]));
+        else
+          lcd_put_u8str_P(PSTR(" -----"));
+
+      #else                 // 16x4 or 20x4 display
+
+        /**
+         * Show all values at right of screen
+         */
+        _XLABEL(_LCD_W_POS, 1);
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x]))));
+        _YLABEL(_LCD_W_POS, 2);
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[inverted_y]))));
+
+        /**
+         * Show the location value
+         */
+        _ZLABEL(_LCD_W_POS, 3);
+        if (!isnan(ubl.z_values[x][inverted_y]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x][inverted_y]));
+        else
+          lcd_put_u8str_P(PSTR(" -----"));
+
+      #endif // LCD_HEIGHT > 3
+    }
+
+    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location) {
+      uint8_t i, k;
+      int16_t n_rows = lr.row    - ul.row    + 1,
+              n_cols = lr.column - ul.column + 1;
+
+      /**
+       * Check if Top line of box needs to be filled in
+       */
+
+      if (ul.row == 0 && (cell_location & (TOP_LEFT|TOP_RIGHT))) {   // Only fill in the top line for the top character cells
+
+        if (n_cols == 1) {
+          if (ul.column != brc.column)
+            custom.custom_char_bits[0] = 0xFF;                              // Single column in middle
+          else
+            for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)       // Single column on right side
+              SBI(custom.custom_char_bits[0], i);
+        }
+        else if ((cell_location & TOP_LEFT) || lr.column != brc.column)     // Multiple column in the middle or with right cell in middle
+          custom.custom_char_bits[0] = 0xFF;
+        else
+          for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)
+            SBI(custom.custom_char_bits[0], i);
+      }
+
+      /**
+       * Check if left line of box needs to be filled in
+       */
+      if (cell_location & (TOP_LEFT|LOWER_LEFT)) {
+        if (ul.column == 0) {                                               // Left column of characters on LCD Display
+          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT; // If it isn't the last row... do the full character cell
+          for (i = 0; i < k; i++)
+            SBI(custom.custom_char_bits[i], HD44780_CHAR_WIDTH - 1);
+        }
+      }
+
+      /**
+       * Check if bottom line of box needs to be filled in
+       */
+
+      // Single row of mesh plot cells
+      if (n_rows == 1 /* && (cell_location & (TOP_LEFT|TOP_RIGHT)) */ && ul.row == brc.row) {
+        if (n_cols == 1)                                                    // Single row, single column case
+          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else if (cell_location & TOP_RIGHT)                                 // Single row, multiple column case
+          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else                                                                // Single row, left of multiple columns
+          k = 0x01;
+        while (k < _BV(HD44780_CHAR_WIDTH)) {
+          custom.custom_char_bits[brc.y_pixel_offset] |= k;
+          k <<= 1;
+        }
+      }
+
+      // Double row of characters on LCD Display
+      // And this is a bottom custom character
+      if (n_rows == 2 && (cell_location & (LOWER_LEFT|LOWER_RIGHT)) && lr.row == brc.row) {
+        if (n_cols == 1)                                                    // Double row, single column case
+          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else if (cell_location & LOWER_RIGHT)                               // Double row, multiple column case
+          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else                                                                // Double row, left of multiple columns
+          k = 0x01;
+        while (k < _BV(HD44780_CHAR_WIDTH)) {
+          custom.custom_char_bits[brc.y_pixel_offset] |= k;
+          k <<= 1;
+        }
+      }
+
+      /**
+       * Check if right line of box needs to be filled in
+       */
+
+      // Nothing to do if the lower right part of the mesh pnt isn't in the same column as the box line
+      if (lr.column == brc.column) {
+        // This mesh point is in the same character cell as the right box line
+        if (ul.column == brc.column || (cell_location & (TOP_RIGHT|LOWER_RIGHT))) {
+          // If not the last row... do the full character cell
+          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT;
+          for (i = 0; i < k; i++) custom.custom_char_bits[i] |= brc.x_pixel_mask;
+        }
+      }
+    }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+#endif // HAS_LCD_MENU
+
+#endif // HAS_CHARACTER_LCD
