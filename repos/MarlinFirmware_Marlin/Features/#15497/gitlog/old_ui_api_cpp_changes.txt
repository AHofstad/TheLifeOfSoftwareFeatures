commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
deleted file mode 100644
index 759d290af6..0000000000
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ /dev/null
@@ -1,1173 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/**************
- * ui_api.cpp *
- **************/
-
-/****************************************************************************
- *   Written By Marcio Teixeira 2018 - Aleph Objects, Inc.                  *
- *                                                                          *
- *   This program is free software: you can redistribute it and/or modify   *
- *   it under the terms of the GNU General Public License as published by   *
- *   the Free Software Foundation, either version 3 of the License, or      *
- *   (at your option) any later version.                                    *
- *                                                                          *
- *   This program is distributed in the hope that it will be useful,        *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
- *   GNU General Public License for more details.                           *
- *                                                                          *
- *   To view a copy of the GNU General Public License, go to the following  *
- *   location: <http://www.gnu.org/licenses/>.                              *
- ****************************************************************************/
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if ENABLED(EXTENSIBLE_UI)
-
-#include "../ultralcd.h"
-#include "../../gcode/queue.h"
-#include "../../module/motion.h"
-#include "../../module/planner.h"
-#include "../../module/probe.h"
-#include "../../module/temperature.h"
-#include "../../module/printcounter.h"
-#include "../../libs/duration_t.h"
-#include "../../HAL/shared/Delay.h"
-
-#if ENABLED(PRINTCOUNTER)
-  #include "../../core/utility.h"
-  #include "../../libs/numtostr.h"
-#endif
-
-#if EXTRUDERS > 1
-  #include "../../module/tool_change.h"
-#endif
-
-#if ENABLED(EMERGENCY_PARSER)
-  #include "../../feature/emergency_parser.h"
-#endif
-
-#if ENABLED(SDSUPPORT)
-  #include "../../sd/cardreader.h"
-  #define IFSD(A,B) (A)
-#else
-  #define IFSD(A,B) (B)
-#endif
-
-#if HAS_TRINAMIC_CONFIG
-  #include "../../feature/tmc_util.h"
-  #include "../../module/stepper/indirection.h"
-#endif
-
-#include "ui_api.h"
-
-#if ENABLED(BACKLASH_GCODE)
-  #include "../../feature/backlash.h"
-#endif
-
-#if HAS_LEVELING
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
-
-#if HAS_FILAMENT_SENSOR
-  #include "../../feature/runout.h"
-#endif
-
-#if ENABLED(CASE_LIGHT_ENABLE)
-  #include "../../feature/caselight.h"
-#endif
-
-#if ENABLED(BABYSTEPPING)
-  #include "../../feature/babystep.h"
-#endif
-
-#if ENABLED(HOST_PROMPT_SUPPORT)
-  #include "../../feature/host_actions.h"
-#endif
-
-namespace ExtUI {
-  static struct {
-    uint8_t printer_killed : 1;
-    #if ENABLED(JOYSTICK)
-      uint8_t jogging : 1;
-    #endif
-  } flags;
-
-  #ifdef __SAM3X8E__
-    /**
-     * Implement a special millis() to allow time measurement
-     * within an ISR (such as when the printer is killed).
-     *
-     * To keep proper time, must be called at least every 1s.
-     */
-    uint32_t safe_millis() {
-      // Not killed? Just call millis()
-      if (!flags.printer_killed) return millis();
-
-      static uint32_t currTimeHI = 0; /* Current time */
-
-      // Machine was killed, reinit SysTick so we are able to compute time without ISRs
-      if (currTimeHI == 0) {
-        // Get the last time the Arduino time computed (from CMSIS) and convert it to SysTick
-        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU / 8000)) >> 24);
-
-        // Reinit the SysTick timer to maximize its period
-        SysTick->LOAD  = SysTick_LOAD_RELOAD_Msk;                    // get the full range for the systick timer
-        SysTick->VAL   = 0;                                          // Load the SysTick Counter Value
-        SysTick->CTRL  = // MCLK/8 as source
-                         // No interrupts
-                         SysTick_CTRL_ENABLE_Msk;                    // Enable SysTick Timer
-     }
-
-      // Check if there was a timer overflow from the last read
-      if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
-        // There was. This means (SysTick_LOAD_RELOAD_Msk * 1000 * 8)/F_CPU ms has elapsed
-        currTimeHI++;
-      }
-
-      // Calculate current time in milliseconds
-      uint32_t currTimeLO = SysTick_LOAD_RELOAD_Msk - SysTick->VAL; // (in MCLK/8)
-      uint64_t currTime = ((uint64_t)currTimeLO) | (((uint64_t)currTimeHI) << 24);
-
-      // The ms count is
-      return (uint32_t)(currTime / (F_CPU / 8000));
-    }
-  #endif // __SAM3X8E__
-
-  void delay_us(unsigned long us) { DELAY_US(us); }
-
-  void delay_ms(unsigned long ms) {
-    if (flags.printer_killed)
-      DELAY_US(ms * 1000);
-    else
-      safe_delay(ms);
-  }
-
-  void yield() {
-    if (!flags.printer_killed)
-      thermalManager.manage_heater();
-  }
-
-  void enableHeater(const extruder_t extruder) {
-    #if HOTENDS && HEATER_IDLE_HANDLER
-      thermalManager.reset_hotend_idle_timer(extruder - E0);
-    #else
-      UNUSED(extruder);
-    #endif
-  }
-
-  void enableHeater(const heater_t heater) {
-    #if HEATER_IDLE_HANDLER
-      switch (heater) {
-        #if HAS_HEATED_BED
-          case BED:
-            thermalManager.reset_bed_idle_timer();
-            return;
-        #endif
-        #if HAS_HEATED_CHAMBER
-          case CHAMBER: return; // Chamber has no idle timer
-        #endif
-        default:
-          #if HOTENDS
-            thermalManager.reset_hotend_idle_timer(heater - H0);
-          #endif
-          break;
-      }
-    #else
-      UNUSED(heater);
-    #endif
-  }
-
-  #if ENABLED(JOYSTICK)
-    /**
-     * Jogs in the direction given by the vector (dx, dy, dz).
-     * The values range from -1 to 1 mapping to the maximum
-     * feedrate for an axis.
-     *
-     * The axis will continue to jog until this function is
-     * called with all zeros.
-     */
-    void jog(const xyz_float_t &dir) {
-      // The "destination" variable is used as a scratchpad in
-      // Marlin by GCODE routines, but should remain untouched
-      // during manual jogging, allowing us to reuse the space
-      // for our direction vector.
-      destination = dir;
-      flags.jogging = !NEAR_ZERO(dir.x) || !NEAR_ZERO(dir.y) || !NEAR_ZERO(dir.z);
-    }
-
-    // Called by the polling routine in "joystick.cpp"
-    void _joystick_update(xyz_float_t &norm_jog) {
-      if (flags.jogging) {
-        #define OUT_OF_RANGE(VALUE) (VALUE < -1.0f || VALUE > 1.0f)
-
-        if (OUT_OF_RANGE(destination.x) || OUT_OF_RANGE(destination.y) || OUT_OF_RANGE(destination.z)) {
-          // If destination on any axis is out of range, it
-          // probably means the UI forgot to stop jogging and
-          // ran GCODE that wrote a position to destination.
-          // To prevent a disaster, stop jogging.
-          flags.jogging = false;
-          return;
-        }
-        norm_jog = destination;
-      }
-    }
-  #endif
-
-  bool isHeaterIdle(const extruder_t extruder) {
-    return false
-      #if HOTENDS && HEATER_IDLE_HANDLER
-        || thermalManager.hotend_idle[extruder - E0].timed_out
-      #else
-        ; UNUSED(extruder)
-      #endif
-    ;
-  }
-
-  bool isHeaterIdle(const heater_t heater) {
-    #if HEATER_IDLE_HANDLER
-      switch (heater) {
-        #if HAS_HEATED_BED
-          case BED: return thermalManager.bed_idle.timed_out;
-        #endif
-        #if HAS_HEATED_CHAMBER
-          case CHAMBER: return false; // Chamber has no idle timer
-        #endif
-        default:
-          #if HOTENDS
-            return thermalManager.hotend_idle[heater - H0].timed_out;
-          #else
-            return false;
-          #endif
-      }
-    #else
-      UNUSED(heater);
-      return false;
-    #endif
-  }
-
-  #ifdef TOUCH_UI_LCD_TEMP_SCALING
-    #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
-  #else
-    #define GET_TEMP_ADJUSTMENT(A) A
-  #endif
-
-  float getActualTemp_celsius(const heater_t heater) {
-    switch (heater) {
-      #if HAS_HEATED_BED
-        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
-      #endif
-      #if HAS_HEATED_CHAMBER
-        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
-      #endif
-      default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
-    }
-  }
-
-  float getActualTemp_celsius(const extruder_t extruder) {
-    return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
-  }
-
-  float getTargetTemp_celsius(const heater_t heater) {
-    switch (heater) {
-      #if HAS_HEATED_BED
-        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
-      #endif
-      #if HAS_HEATED_CHAMBER
-        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
-      #endif
-      default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
-    }
-  }
-
-  float getTargetTemp_celsius(const extruder_t extruder) {
-    return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
-  }
-
-  float getTargetFan_percent(const fan_t fan) {
-    #if FAN_COUNT > 0
-      return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
-    #else
-      UNUSED(fan);
-      return 0;
-    #endif
-  }
-
-  float getActualFan_percent(const fan_t fan) {
-    #if FAN_COUNT > 0
-      return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
-    #else
-      UNUSED(fan);
-      return 0;
-    #endif
-  }
-
-  float getAxisPosition_mm(const axis_t axis) {
-    return
-      #if ENABLED(JOYSTICK)
-        flags.jogging ? destination[axis] :
-      #endif
-      current_position[axis];
-  }
-
-  float getAxisPosition_mm(const extruder_t extruder) {
-    const extruder_t old_tool = getActiveTool();
-    setActiveTool(extruder, true);
-    const float epos = (
-      #if ENABLED(JOYSTICK)
-        flags.jogging ? destination.e :
-      #endif
-      current_position.e
-    );
-    setActiveTool(old_tool, true);
-    return epos;
-  }
-
-  void setAxisPosition_mm(const float position, const axis_t axis) {
-    // Start with no limits to movement
-    float min = current_position[axis] - 1000,
-          max = current_position[axis] + 1000;
-
-    // Limit to software endstops, if enabled
-    #if HAS_SOFTWARE_ENDSTOPS
-      if (soft_endstops_enabled) switch (axis) {
-        case X_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-            min = soft_endstop.min.x;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-            max = soft_endstop.max.x;
-          #endif
-          break;
-        case Y_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-            min = soft_endstop.min.y;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-            max = soft_endstop.max.y;
-          #endif
-          break;
-        case Z_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-            min = soft_endstop.min.z;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-            max = soft_endstop.max.z;
-          #endif
-        default: break;
-      }
-    #endif // HAS_SOFTWARE_ENDSTOPS
-
-    // Delta limits XY based on the current offset from center
-    // This assumes the center is 0,0
-    #if ENABLED(DELTA)
-      if (axis != Z_AXIS) {
-        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
-        min = -max;
-      }
-    #endif
-
-    current_position[axis] = constrain(position, min, max);
-    line_to_current_position(manual_feedrate_mm_s[axis]);
-  }
-
-  void setAxisPosition_mm(const float position, const extruder_t extruder) {
-    setActiveTool(extruder, true);
-
-    current_position.e = position;
-    line_to_current_position(manual_feedrate_mm_s.e);
-  }
-
-  void setActiveTool(const extruder_t extruder, bool no_move) {
-    #if EXTRUDERS > 1
-      const uint8_t e = extruder - E0;
-      if (e != active_extruder) tool_change(e, no_move);
-      active_extruder = e;
-    #else
-      UNUSED(extruder);
-      UNUSED(no_move);
-    #endif
-  }
-
-  extruder_t getActiveTool() {
-    switch (active_extruder) {
-      case 5:  return E5;
-      case 4:  return E4;
-      case 3:  return E3;
-      case 2:  return E2;
-      case 1:  return E1;
-      default: return E0;
-    }
-  }
-
-  bool isMoving() { return planner.has_blocks_queued(); }
-
-  bool canMove(const axis_t axis) {
-    switch (axis) {
-      #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-        case X: return TEST(axis_homed, X_AXIS);
-        case Y: return TEST(axis_homed, Y_AXIS);
-        case Z: return TEST(axis_homed, Z_AXIS);
-      #else
-        case X: case Y: case Z: return true;
-      #endif
-      default: return false;
-    }
-  }
-
-  bool canMove(const extruder_t extruder) {
-    return !thermalManager.tooColdToExtrude(extruder - E0);
-  }
-
-  #if HAS_SOFTWARE_ENDSTOPS
-    bool getSoftEndstopState() { return soft_endstops_enabled; }
-    void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
-  #endif
-
-  #if HAS_TRINAMIC_CONFIG
-    float getAxisCurrent_mA(const axis_t axis) {
-      switch (axis) {
-        #if AXIS_IS_TMC(X)
-          case X: return stepperX.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Y)
-          case Y: return stepperY.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(Z)
-          case Z: return stepperZ.getMilliamps();
-        #endif
-        default: return NAN;
-      };
-    }
-
-    float getAxisCurrent_mA(const extruder_t extruder) {
-      switch (extruder) {
-        #if AXIS_IS_TMC(E0)
-          case E0: return stepperE0.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E1)
-          case E1: return stepperE1.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E2)
-          case E2: return stepperE2.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E3)
-          case E3: return stepperE3.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E4)
-          case E4: return stepperE4.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E5)
-          case E5: return stepperE5.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E6)
-          case E6: return stepperE6.getMilliamps();
-        #endif
-        #if AXIS_IS_TMC(E7)
-          case E7: return stepperE7.getMilliamps();
-        #endif
-        default: return NAN;
-      };
-    }
-
-    void  setAxisCurrent_mA(const float mA, const axis_t axis) {
-      switch (axis) {
-        #if AXIS_IS_TMC(X)
-          case X: stepperX.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(Y)
-          case Y: stepperY.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(Z)
-          case Z: stepperZ.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        default: break;
-      };
-    }
-
-    void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
-      switch (extruder) {
-        #if AXIS_IS_TMC(E0)
-          case E0: stepperE0.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E1)
-          case E1: stepperE1.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E2)
-          case E2: stepperE2.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E3)
-          case E3: stepperE3.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E4)
-          case E4: stepperE4.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E5)
-          case E5: stepperE5.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E6)
-          case E6: stepperE6.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        #if AXIS_IS_TMC(E7)
-          case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
-        #endif
-        default: break;
-      };
-    }
-
-    int getTMCBumpSensitivity(const axis_t axis) {
-      switch (axis) {
-        #if X_SENSORLESS
-          case X: return stepperX.homing_threshold();
-        #endif
-        #if Y_SENSORLESS
-          case Y: return stepperY.homing_threshold();
-        #endif
-        #if Z_SENSORLESS
-          case Z: return stepperZ.homing_threshold();
-        #endif
-        default: return 0;
-      }
-    }
-
-    void setTMCBumpSensitivity(const float value, const axis_t axis) {
-      switch (axis) {
-        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
-          #if X_SENSORLESS
-            case X: stepperX.homing_threshold(value); break;
-          #endif
-          #if Y_SENSORLESS
-            case Y: stepperY.homing_threshold(value); break;
-          #endif
-          #if Z_SENSORLESS
-            case Z: stepperZ.homing_threshold(value); break;
-          #endif
-        #else
-          UNUSED(value);
-        #endif
-        default: break;
-      }
-    }
-  #endif
-
-  float getAxisSteps_per_mm(const axis_t axis) {
-    return planner.settings.axis_steps_per_mm[axis];
-  }
-
-  float getAxisSteps_per_mm(const extruder_t extruder) {
-    UNUSED_E(extruder);
-    return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
-  }
-
-  void setAxisSteps_per_mm(const float value, const axis_t axis) {
-    planner.settings.axis_steps_per_mm[axis] = value;
-  }
-
-  void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
-    UNUSED_E(extruder);
-    planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
-  }
-
-  feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
-    return planner.settings.max_feedrate_mm_s[axis];
-  }
-
-  feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
-    UNUSED_E(extruder);
-    return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
-  }
-
-  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
-    planner.set_max_feedrate(axis, value);
-  }
-
-  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
-    UNUSED_E(extruder);
-    planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
-  }
-
-  float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
-    return planner.settings.max_acceleration_mm_per_s2[axis];
-  }
-
-  float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
-    UNUSED_E(extruder);
-    return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
-  }
-
-  void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
-    planner.set_max_acceleration(axis, value);
-  }
-
-  void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
-    UNUSED_E(extruder);
-    planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
-  }
-
-  #if HAS_FILAMENT_SENSOR
-    bool getFilamentRunoutEnabled()                 { return runout.enabled; }
-    void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
-
-    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
-      float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
-      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
-    #endif
-  #endif
-
-  #if HAS_CASE_LIGHT
-    bool getCaseLightState()                 { return case_light_on; }
-    void setCaseLightState(const bool value) {
-      case_light_on = value;
-      update_case_light();
-    }
-
-    #if DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
-      float getCaseLightBrightness_percent()                 { return ui8_to_percent(case_light_brightness); }
-      void setCaseLightBrightness_percent(const float value) {
-         case_light_brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
-         update_case_light();
-      }
-    #endif
-  #endif
-
-  #if ENABLED(LIN_ADVANCE)
-    float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
-      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
-    }
-
-    void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
-      if (extruder < EXTRUDERS)
-        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 999);
-    }
-  #endif
-
-  #if DISABLED(CLASSIC_JERK)
-
-    float getJunctionDeviation_mm() {
-      return planner.junction_deviation_mm;
-    }
-
-    void setJunctionDeviation_mm(const float value) {
-      planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
-      #if ENABLED(LIN_ADVANCE)
-        planner.recalculate_max_e_jerk();
-      #endif
-    }
-
-  #else
-
-    float getAxisMaxJerk_mm_s(const axis_t axis) {
-      return planner.max_jerk[axis];
-    }
-
-    float getAxisMaxJerk_mm_s(const extruder_t) {
-      return planner.max_jerk.e;
-    }
-
-    void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
-      planner.set_max_jerk((AxisEnum)axis, value);
-    }
-
-    void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
-      planner.set_max_jerk(E_AXIS, value);
-    }
-  #endif
-
-  feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
-  int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
-  feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
-  feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
-  float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
-  float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
-  float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
-  void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
-  void setFlow_percent(const int16_t flow, const extruder_t extr) {
-    planner.flow_percentage[extr] = flow;
-    planner.refresh_e_factor(extr);
-  }
-  void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
-  void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
-  void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
-
-  #if ENABLED(BABYSTEPPING)
-    bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
-      switch (axis) {
-        #if ENABLED(BABYSTEP_XY)
-          case X: babystep.add_steps(X_AXIS, steps); break;
-          case Y: babystep.add_steps(Y_AXIS, steps); break;
-        #endif
-        case Z: babystep.add_steps(Z_AXIS, steps); break;
-        default: return false;
-      };
-      return true;
-    }
-
-    /**
-     * This function adjusts an axis during a print.
-     *
-     * When linked_nozzles is false, each nozzle in a multi-nozzle
-     * printer can be babystepped independently of the others. This
-     * lets the user to fine tune the Z-offset and Nozzle Offsets
-     * while observing the first layer of a print, regardless of
-     * what nozzle is printing.
-     */
-    void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
-      const float mm = steps * planner.steps_to_mm[axis];
-
-      if (!babystepAxis_steps(steps, axis)) return;
-
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        // Make it so babystepping in Z adjusts the Z probe offset.
-        if (axis == Z
-          #if EXTRUDERS > 1
-            && (linked_nozzles || active_extruder == 0)
-          #endif
-        ) probe.offset.z += mm;
-      #else
-        UNUSED(mm);
-      #endif
-
-      #if EXTRUDERS > 1 && HAS_HOTEND_OFFSET
-        /**
-         * When linked_nozzles is false, as an axis is babystepped
-         * adjust the hotend offsets so that the other nozzles are
-         * unaffected by the babystepping of the active nozzle.
-         */
-        if (!linked_nozzles) {
-          HOTEND_LOOP()
-            if (e != active_extruder)
-              hotend_offset[e][axis] += mm;
-
-          normalizeNozzleOffset(X);
-          normalizeNozzleOffset(Y);
-          normalizeNozzleOffset(Z);
-        }
-      #else
-        UNUSED(linked_nozzles);
-        UNUSED(mm);
-      #endif
-    }
-
-    /**
-     * Converts a mm displacement to a number of whole number of
-     * steps that is at least mm long.
-     */
-    int16_t mmToWholeSteps(const float mm, const axis_t axis) {
-      const float steps = mm / planner.steps_to_mm[axis];
-      return steps > 0 ? ceil(steps) : floor(steps);
-    }
-  #endif
-
-  float getZOffset_mm() {
-    #if HAS_BED_PROBE
-      return probe.offset.z;
-    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]);
-    #else
-      return 0.0;
-    #endif
-  }
-
-  void setZOffset_mm(const float value) {
-    #if HAS_BED_PROBE
-      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
-        probe.offset.z = value;
-    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
-    #else
-      UNUSED(value);
-    #endif
-  }
-
-  #if HAS_HOTEND_OFFSET
-
-    float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
-      if (extruder - E0 >= HOTENDS) return 0;
-      return hotend_offset[extruder - E0][axis];
-    }
-
-    void setNozzleOffset_mm(const float value, const axis_t axis, const extruder_t extruder) {
-      if (extruder - E0 >= HOTENDS) return;
-      hotend_offset[extruder - E0][axis] = value;
-    }
-
-    /**
-     * The UI should call this if needs to guarantee the first
-     * nozzle offset is zero (such as when it doesn't allow the
-     * user to edit the offset the first nozzle).
-     */
-    void normalizeNozzleOffset(const axis_t axis) {
-      const float offs = hotend_offset[0][axis];
-      HOTEND_LOOP() hotend_offset[e][axis] -= offs;
-    }
-
-  #endif // HAS_HOTEND_OFFSET
-
-  #if HAS_BED_PROBE
-    float getProbeOffset_mm(const axis_t axis) {
-      return probe.offset.pos[axis];
-    }
-    void setProbeOffset_mm(const float val, const axis_t axis) {
-      probe.offset.pos[axis] = val;
-    }
-  #endif
-
-  #if ENABLED(BACKLASH_GCODE)
-    float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
-    void setAxisBacklash_mm(const float value, const axis_t axis)
-                                                      { backlash.distance_mm[axis] = constrain(value,0,5); }
-
-    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
-    void setBacklashCorrection_percent(const float value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
-
-    #ifdef BACKLASH_SMOOTHING_MM
-      float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
-      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = constrain(value, 0, 999); }
-    #endif
-  #endif
-
-  uint8_t getProgress_percent() {
-    return ui.get_progress_percent();
-  }
-
-  uint32_t getProgress_seconds_elapsed() {
-    const duration_t elapsed = print_job_timer.duration();
-    return elapsed.value;
-  }
-
-  #if HAS_LEVELING
-    bool getLevelingActive() { return planner.leveling_active; }
-    void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
-    bool getMeshValid() { return leveling_is_valid(); }
-    #if HAS_MESH
-      bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
-      float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
-      void setMeshPoint(const xy_uint8_t &pos, const float zoff) {
-        if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
-          Z_VALUES(pos.x, pos.y) = zoff;
-          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-            bed_level_virt_interpolate();
-          #endif
-        }
-      }
-    #endif
-  #endif
-
-  #if ENABLED(HOST_PROMPT_SUPPORT)
-    void setHostResponse(const uint8_t response) { host_response_handler(response); }
-  #endif
-
-  #if ENABLED(PRINTCOUNTER)
-    char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
-    char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
-    char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }
-    char* getLongestPrint_str(char buffer[21])   { return duration_t(print_job_timer.getStats().longestPrint).toString(buffer); }
-    char* getFilamentUsed_str(char buffer[21])   {
-      printStatistics stats = print_job_timer.getStats();
-      sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
-      return buffer;
-    }
-  #endif
-
-  float getFeedrate_percent() { return feedrate_percentage; }
-
-  #if ENABLED(PIDTEMP)
-    float getPIDValues_Kp(const extruder_t tool) {
-      return PID_PARAM(Kp, tool);
-    }
-
-    float getPIDValues_Ki(const extruder_t tool) {
-      return unscalePID_i(PID_PARAM(Ki, tool));
-    }
-
-    float getPIDValues_Kd(const extruder_t tool) {
-      return unscalePID_d(PID_PARAM(Kd, tool));
-    }
-
-    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
-      thermalManager.temp_hotend[tool].pid.Kp = p;
-      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
-      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
-      thermalManager.updatePID();
-    }
-
-    void startPIDTune(const float temp, extruder_t tool){
-      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
-    }
-  #endif
-
-  #if ENABLED(PIDTEMPBED)
-    float getBedPIDValues_Kp() {
-      return thermalManager.temp_bed.pid.Kp;
-    }
-
-    float getBedPIDValues_Ki() {
-      return unscalePID_i(thermalManager.temp_bed.pid.Ki);
-    }
-
-    float getBedPIDValues_Kd() {
-      return unscalePID_d(thermalManager.temp_bed.pid.Kd);
-    }
-
-    void setBedPIDValues(const float p, const float i, const float d) {
-      thermalManager.temp_bed.pid.Kp = p;
-      thermalManager.temp_bed.pid.Ki = scalePID_i(i);
-      thermalManager.temp_bed.pid.Kd = scalePID_d(d);
-      thermalManager.updatePID();
-    }
-
-    void startBedPIDTune(const float temp) {
-      thermalManager.PID_autotune(temp, H_BED, 4, true);
-    }
-  #endif
-
-  void injectCommands_P(PGM_P const gcode) {
-    queue.inject_P(gcode);
-  }
-
-  bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
-
-  bool isAxisPositionKnown(const axis_t axis) {
-    return TEST(axis_known_position, axis);
-  }
-
-  bool isAxisPositionKnown(const extruder_t) {
-    return TEST(axis_known_position, E_AXIS);
-  }
-
-  bool isPositionKnown() { return all_axes_known(); }
-  bool isMachineHomed() { return all_axes_homed(); }
-
-  PGM_P getFirmwareName_str() {
-    static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
-    return firmware_name;
-  }
-
-  void setTargetTemp_celsius(float value, const heater_t heater) {
-    #ifdef TOUCH_UI_LCD_TEMP_SCALING
-      value *= TOUCH_UI_LCD_TEMP_SCALING;
-    #endif
-    enableHeater(heater);
-    #if HAS_HEATED_CHAMBER
-      if (heater == CHAMBER)
-        thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
-      else
-    #endif
-    #if HAS_HEATED_BED
-      if (heater == BED)
-        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
-      else
-    #endif
-      {
-        #if HOTENDS
-          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
-          const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
-        #endif
-      }
-  }
-
-  void setTargetTemp_celsius(float value, const extruder_t extruder) {
-    #ifdef TOUCH_UI_LCD_TEMP_SCALING
-      value *= TOUCH_UI_LCD_TEMP_SCALING;
-    #endif
-    #if HOTENDS
-      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
-      const int16_t e = extruder - E0;
-      enableHeater(extruder);
-      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
-    #endif
-  }
-
-  void setTargetFan_percent(const float value, const fan_t fan) {
-    #if FAN_COUNT > 0
-      if (fan < FAN_COUNT)
-        thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
-    #else
-      UNUSED(value);
-      UNUSED(fan);
-    #endif
-  }
-
-  void setFeedrate_percent(const float value) {
-    feedrate_percentage = constrain(value, 10, 500);
-  }
-
-  void setUserConfirmed() {
-    #if HAS_RESUME_CONTINUE
-      wait_for_user = false;
-    #endif
-  }
-
-  void printFile(const char *filename) {
-    UNUSED(filename);
-    IFSD(card.openAndPrintFile(filename), NOOP);
-  }
-
-  bool isPrintingFromMediaPaused() {
-    return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
-  }
-
-  bool isPrintingFromMedia() {
-    return IFSD(card.isFileOpen(), false);
-  }
-
-  bool isPrinting() {
-    return (planner.movesplanned() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
-  }
-
-  bool isMediaInserted() {
-    return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
-  }
-
-  void pausePrint() {
-    ui.pause_print();
-  }
-
-  void resumePrint() {
-    ui.resume_print();
-  }
-
-  void stopPrint() {
-    ui.abort_print();
-  }
-
-  void onUserConfirmRequired_P(PGM_P const pstr) {
-    char msg[strlen_P(pstr) + 1];
-    strcpy_P(msg, pstr);
-    onUserConfirmRequired(msg);
-  }
-
-  FileList::FileList() { refresh(); }
-
-  void FileList::refresh() { num_files = 0xFFFF; }
-
-  bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
-    #if ENABLED(SDSUPPORT)
-      if (!skip_range_check && (pos + 1) > count()) return false;
-      const uint16_t nr =
-        #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
-          count() - 1 -
-        #endif
-      pos;
-
-      card.getfilename_sorted(nr);
-      return card.filename[0] != '\0';
-    #else
-      UNUSED(pos);
-      UNUSED(skip_range_check);
-      return false;
-    #endif
-  }
-
-  const char* FileList::filename() {
-    return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");
-  }
-
-  const char* FileList::shortFilename() {
-    return IFSD(card.filename, "");
-  }
-
-  const char* FileList::longFilename() {
-    return IFSD(card.longFilename, "");
-  }
-
-  bool FileList::isDir() {
-    return IFSD(card.flag.filenameIsDir, false);
-  }
-
-  uint16_t FileList::count() {
-    return IFSD((num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)), 0);
-  }
-
-  bool FileList::isAtRootDir() {
-    return (true
-      #if ENABLED(SDSUPPORT)
-        && card.flag.workDirIsRoot
-      #endif
-    );
-  }
-
-  void FileList::upDir() {
-    #if ENABLED(SDSUPPORT)
-      card.cdup();
-      num_files = 0xFFFF;
-    #endif
-  }
-
-  void FileList::changeDir(const char * const dirname) {
-    #if ENABLED(SDSUPPORT)
-      card.cd(dirname);
-      num_files = 0xFFFF;
-    #else
-      UNUSED(dirname);
-    #endif
-  }
-
-} // namespace ExtUI
-
-// At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
-
-void MarlinUI::init() {
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
-    SET_INPUT_PULLUP(SD_DETECT_PIN);
-  #endif
-
-  ExtUI::onStartup();
-}
-
-void MarlinUI::update() {
-  #if ENABLED(SDSUPPORT)
-    static bool last_sd_status;
-    const bool sd_status = IS_SD_INSERTED();
-    if (sd_status != last_sd_status) {
-      last_sd_status = sd_status;
-      if (sd_status) {
-        card.mount();
-        if (card.isMounted())
-          ExtUI::onMediaInserted();
-        else
-          ExtUI::onMediaError();
-      }
-      else {
-        const bool ok = card.isMounted();
-        card.release();
-        if (ok) ExtUI::onMediaRemoved();
-      }
-    }
-  #endif // SDSUPPORT
-  ExtUI::onIdle();
-}
-
-void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
-  using namespace ExtUI;
-  if (!flags.printer_killed) {
-    flags.printer_killed = true;
-    onPrinterKilled(error, component);
-  }
-}
-
-#endif // EXTENSIBLE_UI

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 7ef7614b8d..759d290af6 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -75,7 +75,7 @@
   #define IFSD(A,B) (B)
 #endif
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
   #include "../../feature/tmc_util.h"
   #include "../../module/stepper/indirection.h"
 #endif
@@ -445,7 +445,7 @@ namespace ExtUI {
     void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
   #endif
 
-  #if HAS_TRINAMIC
+  #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)

commit 5e197df89af624d556b75c4881aacd1ab57e861d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 24 05:29:13 2020 -0600

    Fix Babystepping loop (again)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 31d195c95d..7ef7614b8d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -785,7 +785,7 @@ namespace ExtUI {
     #if HAS_BED_PROBE
       return probe.offset.z;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_TODO_AXIS(Z_AXIS)]);
+      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]);
     #else
       return 0.0;
     #endif
@@ -898,11 +898,11 @@ namespace ExtUI {
     float getPIDValues_Kp(const extruder_t tool) {
       return PID_PARAM(Kp, tool);
     }
-    
+
     float getPIDValues_Ki(const extruder_t tool) {
       return unscalePID_i(PID_PARAM(Ki, tool));
     }
-    
+
     float getPIDValues_Kd(const extruder_t tool) {
       return unscalePID_d(PID_PARAM(Kd, tool));
     }
@@ -918,27 +918,27 @@ namespace ExtUI {
       thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
     }
   #endif
-  
+
   #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() {
       return thermalManager.temp_bed.pid.Kp;
     }
-    
+
     float getBedPIDValues_Ki() {
       return unscalePID_i(thermalManager.temp_bed.pid.Ki);
     }
-    
+
     float getBedPIDValues_Kd() {
       return unscalePID_d(thermalManager.temp_bed.pid.Kd);
     }
-    
+
     void setBedPIDValues(const float p, const float i, const float d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
-    
+
     void startBedPIDTune(const float temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }

commit 3f87f912c5b78a08b17dca07840333c882ceada2
Author: proferabg <proferabg@users.noreply.github.com>
Date:   Mon Feb 10 17:48:22 2020 -0500

    Enable hotend / bed PID separately in ExtUI (#16827)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 21c99d94a6..31d195c95d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -894,42 +894,51 @@ namespace ExtUI {
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
-  #if HAS_PID_HEATING
+  #if ENABLED(PIDTEMP)
     float getPIDValues_Kp(const extruder_t tool) {
       return PID_PARAM(Kp, tool);
     }
+    
     float getPIDValues_Ki(const extruder_t tool) {
       return unscalePID_i(PID_PARAM(Ki, tool));
     }
+    
     float getPIDValues_Kd(const extruder_t tool) {
       return unscalePID_d(PID_PARAM(Kd, tool));
     }
+
+    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
+      thermalManager.temp_hotend[tool].pid.Kp = p;
+      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
+      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
+      thermalManager.updatePID();
+    }
+
+    void startPIDTune(const float temp, extruder_t tool){
+      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
+    }
+  #endif
+  
+  #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() {
       return thermalManager.temp_bed.pid.Kp;
     }
+    
     float getBedPIDValues_Ki() {
       return unscalePID_i(thermalManager.temp_bed.pid.Ki);
     }
+    
     float getBedPIDValues_Kd() {
       return unscalePID_d(thermalManager.temp_bed.pid.Kd);
     }
-
-    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
-      thermalManager.temp_hotend[tool].pid.Kp = p;
-      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
-      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
-      thermalManager.updatePID();
-    }
+    
     void setBedPIDValues(const float p, const float i, const float d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
-
-    void startPIDTune(const float temp, extruder_t tool){
-      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
-    }
+    
     void startBedPIDTune(const float temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }

commit a9549f7a08381e786b6232297c4a0c5de4f9c9d8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Feb 9 13:22:54 2020 -0500

    Add PID, probe offsets to ExtUI (#16792)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d6b4a96706..21c99d94a6 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -826,6 +826,15 @@ namespace ExtUI {
 
   #endif // HAS_HOTEND_OFFSET
 
+  #if HAS_BED_PROBE
+    float getProbeOffset_mm(const axis_t axis) {
+      return probe.offset.pos[axis];
+    }
+    void setProbeOffset_mm(const float val, const axis_t axis) {
+      probe.offset.pos[axis] = val;
+    }
+  #endif
+
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
     void setAxisBacklash_mm(const float value, const axis_t axis)
@@ -885,6 +894,47 @@ namespace ExtUI {
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
+  #if HAS_PID_HEATING
+    float getPIDValues_Kp(const extruder_t tool) {
+      return PID_PARAM(Kp, tool);
+    }
+    float getPIDValues_Ki(const extruder_t tool) {
+      return unscalePID_i(PID_PARAM(Ki, tool));
+    }
+    float getPIDValues_Kd(const extruder_t tool) {
+      return unscalePID_d(PID_PARAM(Kd, tool));
+    }
+    float getBedPIDValues_Kp() {
+      return thermalManager.temp_bed.pid.Kp;
+    }
+    float getBedPIDValues_Ki() {
+      return unscalePID_i(thermalManager.temp_bed.pid.Ki);
+    }
+    float getBedPIDValues_Kd() {
+      return unscalePID_d(thermalManager.temp_bed.pid.Kd);
+    }
+
+    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
+      thermalManager.temp_hotend[tool].pid.Kp = p;
+      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
+      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
+      thermalManager.updatePID();
+    }
+    void setBedPIDValues(const float p, const float i, const float d) {
+      thermalManager.temp_bed.pid.Kp = p;
+      thermalManager.temp_bed.pid.Ki = scalePID_i(i);
+      thermalManager.temp_bed.pid.Kd = scalePID_d(d);
+      thermalManager.updatePID();
+    }
+
+    void startPIDTune(const float temp, extruder_t tool){
+      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
+    }
+    void startBedPIDTune(const float temp) {
+      thermalManager.PID_autotune(temp, H_BED, 4, true);
+    }
+  #endif
+
   void injectCommands_P(PGM_P const gcode) {
     queue.inject_P(gcode);
   }

commit f312ddfa4fd5772d825908f8e376dedf29442893
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 12:37:20 2020 -0600

    More updates for 8 extruders, REPEAT

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 63f12ac835..d6b4a96706 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -481,6 +481,12 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E5)
           case E5: return stepperE5.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(E6)
+          case E6: return stepperE6.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E7)
+          case E7: return stepperE7.getMilliamps();
+        #endif
         default: return NAN;
       };
     }
@@ -520,6 +526,12 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E5)
           case E5: stepperE5.rms_current(constrain(mA, 500, 1500)); break;
         #endif
+        #if AXIS_IS_TMC(E6)
+          case E6: stepperE6.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E7)
+          case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
         default: break;
       };
     }

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f8db5c8209..63f12ac835 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 7f9c62437e5c72947acc3310d94829f132697c81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 3 00:00:35 2020 -0600

    Corner Leveling: Add inset for each side (#16759)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 0e0a1171ab..f8db5c8209 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -389,14 +389,14 @@ namespace ExtUI {
     #endif
 
     current_position[axis] = constrain(position, min, max);
-    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m[axis]));
+    line_to_current_position(manual_feedrate_mm_s[axis]);
   }
 
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
-    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m.e));
+    line_to_current_position(manual_feedrate_mm_s.e);
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 5e053b670a..0e0a1171ab 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -733,7 +733,7 @@ namespace ExtUI {
           #if EXTRUDERS > 1
             && (linked_nozzles || active_extruder == 0)
           #endif
-        ) probe_offset.z += mm;
+        ) probe.offset.z += mm;
       #else
         UNUSED(mm);
       #endif
@@ -771,7 +771,7 @@ namespace ExtUI {
 
   float getZOffset_mm() {
     #if HAS_BED_PROBE
-      return probe_offset.z;
+      return probe.offset.z;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_TODO_AXIS(Z_AXIS)]);
     #else
@@ -782,7 +782,7 @@ namespace ExtUI {
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
-        probe_offset.z = value;
+        probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
     #else

commit 9caf5c05e7e408c7192e689e4ed5fe2735bb2995
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:43 2020 -0600

    Refactor heater watch, job timer auto-start (#16725)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8c8133f22b..5e053b670a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -171,7 +171,7 @@ namespace ExtUI {
 
   void enableHeater(const extruder_t extruder) {
     #if HOTENDS && HEATER_IDLE_HANDLER
-      thermalManager.reset_heater_idle_timer(extruder - E0);
+      thermalManager.reset_hotend_idle_timer(extruder - E0);
     #else
       UNUSED(extruder);
     #endif
@@ -190,7 +190,7 @@ namespace ExtUI {
         #endif
         default:
           #if HOTENDS
-            thermalManager.reset_heater_idle_timer(heater - H0);
+            thermalManager.reset_hotend_idle_timer(heater - H0);
           #endif
           break;
       }

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 253017493f..8c8133f22b 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -912,7 +912,7 @@ namespace ExtUI {
     #endif
       {
         #if HOTENDS
-          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
+          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
         #endif
@@ -924,7 +924,7 @@ namespace ExtUI {
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HOTENDS
-      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
+      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);

commit 7b512742f49e21f67d9234430a0bbf99d5bfe684
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Dec 12 16:51:56 2019 -0500

    Tweak ExtUI Probeless Babystepping (#16177)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 42e807b8bb..253017493f 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -773,7 +773,7 @@ namespace ExtUI {
     #if HAS_BED_PROBE
       return probe_offset.z;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      return babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1];
+      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_TODO_AXIS(Z_AXIS)]);
     #else
       return 0.0;
     #endif
@@ -784,7 +784,7 @@ namespace ExtUI {
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe_offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      babystep.add_mm(Z_AXIS, (value - babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1]));
+      babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
     #else
       UNUSED(value);
     #endif

commit b24b0f385fc145cd6648d8dbdd47e555d52eca9b
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Nov 30 08:23:53 2019 -0500

    Add ExtUI Flow Rate method (#16048)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d4c92c7d20..42e807b8bb 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -683,12 +683,17 @@ namespace ExtUI {
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
+  int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
+  void setFlow_percent(const int16_t flow, const extruder_t extr) {
+    planner.flow_percentage[extr] = flow;
+    planner.refresh_e_factor(extr);
+  }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }

commit b11551c7675e354d6dfec169f538136708aa9edd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 24 06:08:05 2019 -0600

    Touch UI updates for Cocoa Press (#15986)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d0676b7f88..d4c92c7d20 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -94,6 +94,10 @@
   #include "../../feature/runout.h"
 #endif
 
+#if ENABLED(CASE_LIGHT_ENABLE)
+  #include "../../feature/caselight.h"
+#endif
+
 #if ENABLED(BABYSTEPPING)
   #include "../../feature/babystep.h"
 #endif
@@ -263,36 +267,42 @@ namespace ExtUI {
     #endif
   }
 
+  #ifdef TOUCH_UI_LCD_TEMP_SCALING
+    #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
+  #else
+    #define GET_TEMP_ADJUSTMENT(A) A
+  #endif
+
   float getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
       #if HAS_HEATED_BED
-        case BED: return thermalManager.degBed();
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
       #endif
       #if HAS_HEATED_CHAMBER
-        case CHAMBER: return thermalManager.degChamber();
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
       #endif
-      default: return thermalManager.degHotend(heater - H0);
+      default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
   }
 
   float getActualTemp_celsius(const extruder_t extruder) {
-    return thermalManager.degHotend(extruder - E0);
+    return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
   }
 
   float getTargetTemp_celsius(const heater_t heater) {
     switch (heater) {
       #if HAS_HEATED_BED
-        case BED: return thermalManager.degTargetBed();
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
       #endif
       #if HAS_HEATED_CHAMBER
-        case CHAMBER: return thermalManager.degTargetChamber();
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
       #endif
-      default: return thermalManager.degTargetHotend(heater - H0);
+      default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
-    return thermalManager.degTargetHotend(extruder - E0);
+    return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
@@ -613,6 +623,22 @@ namespace ExtUI {
     #endif
   #endif
 
+  #if HAS_CASE_LIGHT
+    bool getCaseLightState()                 { return case_light_on; }
+    void setCaseLightState(const bool value) {
+      case_light_on = value;
+      update_case_light();
+    }
+
+    #if DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+      float getCaseLightBrightness_percent()                 { return ui8_to_percent(case_light_brightness); }
+      void setCaseLightBrightness_percent(const float value) {
+         case_light_brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
+         update_case_light();
+      }
+    #endif
+  #endif
+
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
@@ -865,27 +891,38 @@ namespace ExtUI {
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
+    #ifdef TOUCH_UI_LCD_TEMP_SCALING
+      value *= TOUCH_UI_LCD_TEMP_SCALING;
+    #endif
     enableHeater(heater);
+    #if HAS_HEATED_CHAMBER
+      if (heater == CHAMBER)
+        thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
+      else
+    #endif
     #if HAS_HEATED_BED
       if (heater == BED)
-        thermalManager.setTargetBed(constrain(value, 0, BED_MAXTEMP - 10));
+        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
       else
     #endif
       {
         #if HOTENDS
           static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
           const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);
+          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
         #endif
       }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
+    #ifdef TOUCH_UI_LCD_TEMP_SCALING
+      value *= TOUCH_UI_LCD_TEMP_SCALING;
+    #endif
     #if HOTENDS
       constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
-      thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);
+      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
     #endif
   }
 

commit 5639b8ca20bd67a4f6c9a8d5cf5ce1db3ec74aa8
Author: Marcio Teixeira <57453521+marcio-cp@users.noreply.github.com>
Date:   Sun Nov 10 17:49:41 2019 -0700

    Touch UI fixes for Cocoa Press (#15847)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 83190438fd..d0676b7f88 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -581,6 +581,7 @@ namespace ExtUI {
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
+    UNUSED_E(extruder);
     planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
   }
 
@@ -598,6 +599,7 @@ namespace ExtUI {
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
@@ -908,6 +910,7 @@ namespace ExtUI {
   }
 
   void printFile(const char *filename) {
+    UNUSED(filename);
     IFSD(card.openAndPrintFile(filename), NOOP);
   }
 
@@ -961,6 +964,8 @@ namespace ExtUI {
       card.getfilename_sorted(nr);
       return card.filename[0] != '\0';
     #else
+      UNUSED(pos);
+      UNUSED(skip_range_check);
       return false;
     #endif
   }
@@ -1004,6 +1009,8 @@ namespace ExtUI {
     #if ENABLED(SDSUPPORT)
       card.cd(dirname);
       num_files = 0xFFFF;
+    #else
+      UNUSED(dirname);
     #endif
   }
 

commit b20d5a7cc627164877c95859baaa614f8afc7b99
Author: LinFor <linfor@gmail.com>
Date:   Fri Oct 11 05:03:33 2019 +0300

    Estimate Remaining Time (graphical display) (#15497)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 66f4edd5de..83190438fd 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -796,7 +796,7 @@ namespace ExtUI {
   #endif
 
   uint8_t getProgress_percent() {
-    return ui.get_progress();
+    return ui.get_progress_percent();
   }
 
   uint32_t getProgress_seconds_elapsed() {

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 206befe7cc..66f4edd5de 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -939,6 +939,12 @@ namespace ExtUI {
     ui.abort_print();
   }
 
+  void onUserConfirmRequired_P(PGM_P const pstr) {
+    char msg[strlen_P(pstr) + 1];
+    strcpy_P(msg, pstr);
+    onUserConfirmRequired(msg);
+  }
+
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
@@ -1036,11 +1042,11 @@ void MarlinUI::update() {
   ExtUI::onIdle();
 }
 
-void MarlinUI::kill_screen(PGM_P const msg) {
+void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
-    onPrinterKilled(msg);
+    onPrinterKilled(error, component);
   }
 }
 

commit c0005e939cf9c1d9db16f20e605c3228bc41a758
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 8 19:42:18 2019 -0500

    Enable junction deviation by default (#15481)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index eebe01d0d2..206befe7cc 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -622,7 +622,7 @@ namespace ExtUI {
     }
   #endif
 
-  #if ENABLED(JUNCTION_DEVIATION)
+  #if DISABLED(CLASSIC_JERK)
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;

commit 71526fa5ce446c7504dca1c9d4a70a64f53fcf74
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 7 16:39:52 2019 -0400

    Fix ExtUI onMeshUpdate event (#15477)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index b70a90b89d..eebe01d0d2 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -819,9 +819,6 @@ namespace ExtUI {
           #endif
         }
       }
-      void onMeshUpdate(const uint8_t xpos, const uint8_t ypos, const float zval) {
-        UNUSED(xpos); UNUSED(ypos); UNUSED(zval);
-      }
     #endif
   #endif
 

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 1c6c1e0618..b70a90b89d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -577,12 +577,11 @@ namespace ExtUI {
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
-    planner.settings.max_feedrate_mm_s[axis] = value;
+    planner.set_max_feedrate(axis, value);
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
-    UNUSED_E(extruder);
-    planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = value;
+    planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
   }
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
@@ -595,12 +594,11 @@ namespace ExtUI {
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
-    planner.settings.max_acceleration_mm_per_s2[axis] = value;
+    planner.set_max_acceleration(axis, value);
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
-    UNUSED_E(extruder);
-    planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)] = value;
+    planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
@@ -648,11 +646,11 @@ namespace ExtUI {
     }
 
     void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
-      planner.max_jerk[axis] = value;
+      planner.set_max_jerk((AxisEnum)axis, value);
     }
 
     void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
-      planner.max_jerk.e = value;
+      planner.set_max_jerk(E_AXIS, value);
     }
   #endif
 

commit 806d64e1bf5a838a88e8a473bcb2b0f353b90c30
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:45:00 2019 -0500

    X_SENSORLESS includes AXIS_HAS_STALLGUARD

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 2cbb0e0822..1c6c1e0618 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -516,13 +516,13 @@ namespace ExtUI {
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
-        #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
+        #if X_SENSORLESS
           case X: return stepperX.homing_threshold();
         #endif
-        #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
+        #if Y_SENSORLESS
           case Y: return stepperY.homing_threshold();
         #endif
-        #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
+        #if Z_SENSORLESS
           case Z: return stepperZ.homing_threshold();
         #endif
         default: return 0;
@@ -531,18 +531,16 @@ namespace ExtUI {
 
     void setTMCBumpSensitivity(const float value, const axis_t axis) {
       switch (axis) {
-        #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
-          case X: stepperX.homing_threshold(value); break;
-        #else
-          UNUSED(value);
-        #endif
-        #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
-          case Y: stepperY.homing_threshold(value); break;
-        #else
-          UNUSED(value);
-        #endif
-        #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
-          case Z: stepperZ.homing_threshold(value); break;
+        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
+          #if X_SENSORLESS
+            case X: stepperX.homing_threshold(value); break;
+          #endif
+          #if Y_SENSORLESS
+            case Y: stepperY.homing_threshold(value); break;
+          #endif
+          #if Z_SENSORLESS
+            case Z: stepperZ.homing_threshold(value); break;
+          #endif
         #else
           UNUSED(value);
         #endif

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index fc6c47e267..2cbb0e0822 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -204,33 +204,29 @@ namespace ExtUI {
      * The axis will continue to jog until this function is
      * called with all zeros.
      */
-    void jog(float dx, float dy, float dz) {
+    void jog(const xyz_float_t &dir) {
       // The "destination" variable is used as a scratchpad in
       // Marlin by GCODE routines, but should remain untouched
       // during manual jogging, allowing us to reuse the space
       // for our direction vector.
-      destination[X] = dx;
-      destination[Y] = dy;
-      destination[Z] = dz;
-      flags.jogging = !NEAR_ZERO(dx) || !NEAR_ZERO(dy) || !NEAR_ZERO(dz);
+      destination = dir;
+      flags.jogging = !NEAR_ZERO(dir.x) || !NEAR_ZERO(dir.y) || !NEAR_ZERO(dir.z);
     }
 
     // Called by the polling routine in "joystick.cpp"
-    void _joystick_update(float (&norm_jog)[XYZ]) {
+    void _joystick_update(xyz_float_t &norm_jog) {
       if (flags.jogging) {
         #define OUT_OF_RANGE(VALUE) (VALUE < -1.0f || VALUE > 1.0f)
 
-        if (OUT_OF_RANGE(destination[X_AXIS]) || OUT_OF_RANGE(destination[Y_AXIS]) || OUT_OF_RANGE(destination[Z_AXIS])) {
-          // If destination[] on any axis is out of range, it
+        if (OUT_OF_RANGE(destination.x) || OUT_OF_RANGE(destination.y) || OUT_OF_RANGE(destination.z)) {
+          // If destination on any axis is out of range, it
           // probably means the UI forgot to stop jogging and
-          // ran GCODE that wrote a position to destination[].
+          // ran GCODE that wrote a position to destination.
           // To prevent a disaster, stop jogging.
           flags.jogging = false;
           return;
         }
-        norm_jog[X_AXIS] = destination[X_AXIS];
-        norm_jog[Y_AXIS] = destination[Y_AXIS];
-        norm_jog[Z_AXIS] = destination[Z_AXIS];
+        norm_jog = destination;
       }
     }
   #endif
@@ -328,18 +324,16 @@ namespace ExtUI {
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
-    const float pos = (
+    const float epos = (
       #if ENABLED(JOYSTICK)
-        flags.jogging ? destination[E_AXIS] :
+        flags.jogging ? destination.e :
       #endif
-      current_position[E_AXIS]
+      current_position.e
     );
     setActiveTool(old_tool, true);
-    return pos;
+    return epos;
   }
 
-  constexpr feedRate_t manual_feedrate_mm_m[XYZE] = MANUAL_FEEDRATE;
-
   void setAxisPosition_mm(const float position, const axis_t axis) {
     // Start with no limits to movement
     float min = current_position[axis] - 1000,
@@ -350,26 +344,26 @@ namespace ExtUI {
       if (soft_endstops_enabled) switch (axis) {
         case X_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-            min = soft_endstop[X_AXIS].min;
+            min = soft_endstop.min.x;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-            max = soft_endstop[X_AXIS].max;
+            max = soft_endstop.max.x;
           #endif
           break;
         case Y_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-            min = soft_endstop[Y_AXIS].min;
+            min = soft_endstop.min.y;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-            max = soft_endstop[Y_AXIS].max;
+            max = soft_endstop.max.y;
           #endif
           break;
         case Z_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-            min = soft_endstop[Z_AXIS].min;
+            min = soft_endstop.min.z;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-            max = soft_endstop[Z_AXIS].max;
+            max = soft_endstop.max.z;
           #endif
         default: break;
       }
@@ -391,8 +385,8 @@ namespace ExtUI {
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
-    current_position[E_AXIS] = position;
-    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m[E_AXIS]));
+    current_position.e = position;
+    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m.e));
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
@@ -652,7 +646,7 @@ namespace ExtUI {
     }
 
     float getAxisMaxJerk_mm_s(const extruder_t) {
-      return planner.max_jerk[E_AXIS];
+      return planner.max_jerk.e;
     }
 
     void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
@@ -660,7 +654,7 @@ namespace ExtUI {
     }
 
     void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
-      planner.max_jerk[E_AXIS] = value;
+      planner.max_jerk.e = value;
     }
   #endif
 
@@ -710,7 +704,7 @@ namespace ExtUI {
           #if EXTRUDERS > 1
             && (linked_nozzles || active_extruder == 0)
           #endif
-        ) probe_offset[Z_AXIS] += mm;
+        ) probe_offset.z += mm;
       #else
         UNUSED(mm);
       #endif
@@ -724,7 +718,7 @@ namespace ExtUI {
         if (!linked_nozzles) {
           HOTEND_LOOP()
             if (e != active_extruder)
-              hotend_offset[axis][e] += mm;
+              hotend_offset[e][axis] += mm;
 
           normalizeNozzleOffset(X);
           normalizeNozzleOffset(Y);
@@ -748,7 +742,7 @@ namespace ExtUI {
 
   float getZOffset_mm() {
     #if HAS_BED_PROBE
-      return probe_offset[Z_AXIS];
+      return probe_offset.z;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       return babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1];
     #else
@@ -759,7 +753,7 @@ namespace ExtUI {
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
-        probe_offset[Z_AXIS] = value;
+        probe_offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, (value - babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1]));
     #else
@@ -771,12 +765,12 @@ namespace ExtUI {
 
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
-      return hotend_offset[axis][extruder - E0];
+      return hotend_offset[extruder - E0][axis];
     }
 
     void setNozzleOffset_mm(const float value, const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return;
-      hotend_offset[axis][extruder - E0] = value;
+      hotend_offset[extruder - E0][axis] = value;
     }
 
     /**
@@ -785,8 +779,8 @@ namespace ExtUI {
      * user to edit the offset the first nozzle).
      */
     void normalizeNozzleOffset(const axis_t axis) {
-      const float offs = hotend_offset[axis][0];
-      HOTEND_LOOP() hotend_offset[axis][e] -= offs;
+      const float offs = hotend_offset[0][axis];
+      HOTEND_LOOP() hotend_offset[e][axis] -= offs;
     }
 
   #endif // HAS_HOTEND_OFFSET
@@ -820,10 +814,10 @@ namespace ExtUI {
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
-      float getMeshPoint(const uint8_t xpos, const uint8_t ypos) { return Z_VALUES(xpos,ypos); }
-      void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {
-        if (WITHIN(xpos, 0, GRID_MAX_POINTS_X) && WITHIN(ypos, 0, GRID_MAX_POINTS_Y)) {
-          Z_VALUES(xpos, ypos) = zoff;
+      float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
+      void setMeshPoint(const xy_uint8_t &pos, const float zoff) {
+        if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
+          Z_VALUES(pos.x, pos.y) = zoff;
           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
             bed_level_virt_interpolate();
           #endif

commit a628d7779809933f87ef131aad1d5b327a8d8056
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Sep 28 22:30:41 2019 +0200

    Fix compile error with 6 hot-ends (#15405)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index dc3fc731ce..fc6c47e267 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -884,7 +884,7 @@ namespace ExtUI {
     #endif
       {
         #if HOTENDS
-          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);
         #endif
@@ -893,7 +893,7 @@ namespace ExtUI {
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #if HOTENDS
-      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);

commit 2277c6dffcdb9acbd33e9d020417b71b2b766f25
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 28 15:28:05 2019 -0500

    Optimize SD card reader, sorting (#15395)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 5035e0cebd..dc3fc731ce 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -1002,14 +1002,14 @@ namespace ExtUI {
 
   void FileList::upDir() {
     #if ENABLED(SDSUPPORT)
-      card.updir();
+      card.cdup();
       num_files = 0xFFFF;
     #endif
   }
 
   void FileList::changeDir(const char * const dirname) {
     #if ENABLED(SDSUPPORT)
-      card.chdir(dirname);
+      card.cd(dirname);
       num_files = 0xFFFF;
     #endif
   }

commit d683f980195fec994b07193006495499adc7f795
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 27 02:59:49 2019 -0500

    Return buffer in duration.toString

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 0b80def5c9..5035e0cebd 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -842,8 +842,8 @@ namespace ExtUI {
   #if ENABLED(PRINTCOUNTER)
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
-    char* getTotalPrintTime_str(char buffer[21]) { duration_t(print_job_timer.getStats().printTime).toString(buffer);       return buffer; }
-    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().longestPrint).toString(buffer);    return buffer; }
+    char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }
+    char* getLongestPrint_str(char buffer[21])   { return duration_t(print_job_timer.getStats().longestPrint).toString(buffer); }
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 4affcb6d7d..0b80def5c9 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -338,6 +338,8 @@ namespace ExtUI {
     return pos;
   }
 
+  constexpr feedRate_t manual_feedrate_mm_m[XYZE] = MANUAL_FEEDRATE;
+
   void setAxisPosition_mm(const float position, const axis_t axis) {
     // Start with no limits to movement
     float min = current_position[axis] - 1000,
@@ -382,23 +384,15 @@ namespace ExtUI {
       }
     #endif
 
-    constexpr float manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_TO_MMS(manual_feedrate[axis]));
-
-    set_destination_from_current();
-    destination[axis] = constrain(position, min, max);
-    prepare_move_to_destination();
+    current_position[axis] = constrain(position, min, max);
+    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m[axis]));
   }
 
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
-    constexpr float manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_TO_MMS(manual_feedrate[E_AXIS]));
-
-    set_destination_from_current();
-    destination[E_AXIS] = position;
-    prepare_move_to_destination();
+    current_position[E_AXIS] = position;
+    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m[E_AXIS]));
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
@@ -581,20 +575,20 @@ namespace ExtUI {
     planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
   }
 
-  float getAxisMaxFeedrate_mm_s(const axis_t axis) {
+  feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
-  float getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
+  feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
   }
 
-  void setAxisMaxFeedrate_mm_s(const float value, const axis_t axis) {
+  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
     planner.settings.max_feedrate_mm_s[axis] = value;
   }
 
-  void setAxisMaxFeedrate_mm_s(const float value, const extruder_t extruder) {
+  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = value;
   }
@@ -670,15 +664,15 @@ namespace ExtUI {
     }
   #endif
 
-  float getFeedrate_mm_s()                            { return feedrate_mm_s; }
-  float getMinFeedrate_mm_s()                         { return planner.settings.min_feedrate_mm_s; }
-  float getMinTravelFeedrate_mm_s()                   { return planner.settings.min_travel_feedrate_mm_s; }
+  feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
+  feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
+  feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
-  void setFeedrate_mm_s(const float fr)               { feedrate_mm_s = fr; }
-  void setMinFeedrate_mm_s(const float fr)            { planner.settings.min_feedrate_mm_s = fr; }
-  void setMinTravelFeedrate_mm_s(const float fr)      { planner.settings.min_travel_feedrate_mm_s = fr; }
+  void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
+  void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
+  void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
   void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
   void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }

commit 8cbb5350ad4cdfdec79ad6bdfaec40d670bc247c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Sep 25 17:46:36 2019 -0600

    Refactor joystick support in ExtUI (#15318)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f5cfefd217..4affcb6d7d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -104,14 +104,12 @@
 
 namespace ExtUI {
   static struct {
-    uint8_t printer_killed  : 1;
-    uint8_t manual_motion   : 1;
+    uint8_t printer_killed : 1;
+    #if ENABLED(JOYSTICK)
+      uint8_t jogging : 1;
+    #endif
   } flags;
 
-  #if ENABLED(JOYSTICK)
-    float norm_jog[XYZ];
-  #endif
-
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
@@ -197,13 +195,45 @@ namespace ExtUI {
     #endif
   }
 
-  void jog(float dx, float dy, float dz) {
-    #if ENABLED(JOYSTICK)
-      norm_jog[X] = dx;
-      norm_jog[Y] = dy;
-      norm_jog[Z] = dz;
-    #endif
-  }
+  #if ENABLED(JOYSTICK)
+    /**
+     * Jogs in the direction given by the vector (dx, dy, dz).
+     * The values range from -1 to 1 mapping to the maximum
+     * feedrate for an axis.
+     *
+     * The axis will continue to jog until this function is
+     * called with all zeros.
+     */
+    void jog(float dx, float dy, float dz) {
+      // The "destination" variable is used as a scratchpad in
+      // Marlin by GCODE routines, but should remain untouched
+      // during manual jogging, allowing us to reuse the space
+      // for our direction vector.
+      destination[X] = dx;
+      destination[Y] = dy;
+      destination[Z] = dz;
+      flags.jogging = !NEAR_ZERO(dx) || !NEAR_ZERO(dy) || !NEAR_ZERO(dz);
+    }
+
+    // Called by the polling routine in "joystick.cpp"
+    void _joystick_update(float (&norm_jog)[XYZ]) {
+      if (flags.jogging) {
+        #define OUT_OF_RANGE(VALUE) (VALUE < -1.0f || VALUE > 1.0f)
+
+        if (OUT_OF_RANGE(destination[X_AXIS]) || OUT_OF_RANGE(destination[Y_AXIS]) || OUT_OF_RANGE(destination[Z_AXIS])) {
+          // If destination[] on any axis is out of range, it
+          // probably means the UI forgot to stop jogging and
+          // ran GCODE that wrote a position to destination[].
+          // To prevent a disaster, stop jogging.
+          flags.jogging = false;
+          return;
+        }
+        norm_jog[X_AXIS] = destination[X_AXIS];
+        norm_jog[Y_AXIS] = destination[Y_AXIS];
+        norm_jog[Z_AXIS] = destination[Z_AXIS];
+      }
+    }
+  #endif
 
   bool isHeaterIdle(const extruder_t extruder) {
     return false
@@ -288,13 +318,22 @@ namespace ExtUI {
   }
 
   float getAxisPosition_mm(const axis_t axis) {
-    return flags.manual_motion ? destination[axis] : current_position[axis];
+    return
+      #if ENABLED(JOYSTICK)
+        flags.jogging ? destination[axis] :
+      #endif
+      current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
-    const float pos = flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
+    const float pos = (
+      #if ENABLED(JOYSTICK)
+        flags.jogging ? destination[E_AXIS] :
+      #endif
+      current_position[E_AXIS]
+    );
     setActiveTool(old_tool, true);
     return pos;
   }
@@ -343,54 +382,23 @@ namespace ExtUI {
       }
     #endif
 
-    constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_TO_MMS(max_manual_feedrate[axis]));
+    constexpr float manual_feedrate[XYZE] = MANUAL_FEEDRATE;
+    setFeedrate_mm_s(MMM_TO_MMS(manual_feedrate[axis]));
 
-    if (!flags.manual_motion) set_destination_from_current();
+    set_destination_from_current();
     destination[axis] = constrain(position, min, max);
-    flags.manual_motion = true;
+    prepare_move_to_destination();
   }
 
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
-    constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_TO_MMS(max_manual_feedrate[E_AXIS]));
-    if (!flags.manual_motion) set_destination_from_current();
-    destination[E_AXIS] = position;
-    flags.manual_motion = true;
-  }
+    constexpr float manual_feedrate[XYZE] = MANUAL_FEEDRATE;
+    setFeedrate_mm_s(MMM_TO_MMS(manual_feedrate[E_AXIS]));
 
-  void _processManualMoveToDestination() {
-    // Lower max_response_lag makes controls more responsive, but makes CPU work harder
-    constexpr float   max_response_lag = 0.1; // seconds
-    constexpr uint8_t segments_to_buffer = 4; // keep planner filled with this many segments
-
-    if (flags.manual_motion && planner.movesplanned() < segments_to_buffer) {
-      float saved_destination[XYZ];
-      COPY(saved_destination, destination);
-      // Compute direction vector from current_position towards destination.
-      destination[X_AXIS] -= current_position[X_AXIS];
-      destination[Y_AXIS] -= current_position[Y_AXIS];
-      destination[Z_AXIS] -= current_position[Z_AXIS];
-      const float inv_length = RSQRT(sq(destination[X_AXIS]) + sq(destination[Y_AXIS]) + sq(destination[Z_AXIS]));
-      // Find move segment length so that all segments can execute in less time than max_response_lag
-      const float scale = inv_length * feedrate_mm_s * max_response_lag / segments_to_buffer;
-      if (scale < 1) {
-        // Move a small bit towards the destination.
-        destination[X_AXIS] = scale * destination[X_AXIS] + current_position[X_AXIS];
-        destination[Y_AXIS] = scale * destination[Y_AXIS] + current_position[Y_AXIS];
-        destination[Z_AXIS] = scale * destination[Z_AXIS] + current_position[Z_AXIS];
-        prepare_move_to_destination();
-        COPY(destination, saved_destination);
-      }
-      else {
-        // We are close enough to finish off the move.
-        COPY(destination, saved_destination);
-        prepare_move_to_destination();
-        flags.manual_motion = false;
-      }
-    }
+    set_destination_from_current();
+    destination[E_AXIS] = position;
+    prepare_move_to_destination();
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
@@ -1044,7 +1052,6 @@ void MarlinUI::update() {
       }
     }
   #endif // SDSUPPORT
-  ExtUI::_processManualMoveToDestination();
   ExtUI::onIdle();
 }
 

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 68b8aad523..f5cfefd217 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -708,7 +708,7 @@ namespace ExtUI {
           #if EXTRUDERS > 1
             && (linked_nozzles || active_extruder == 0)
           #endif
-        ) zprobe_offset[Z_AXIS] += mm;
+        ) probe_offset[Z_AXIS] += mm;
       #else
         UNUSED(mm);
       #endif
@@ -746,7 +746,7 @@ namespace ExtUI {
 
   float getZOffset_mm() {
     #if HAS_BED_PROBE
-      return zprobe_offset[Z_AXIS];
+      return probe_offset[Z_AXIS];
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       return babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1];
     #else
@@ -757,7 +757,7 @@ namespace ExtUI {
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
-        zprobe_offset[Z_AXIS] = value;
+        probe_offset[Z_AXIS] = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, (value - babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1]));
     #else

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 28b2ec006a..68b8aad523 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -708,7 +708,7 @@ namespace ExtUI {
           #if EXTRUDERS > 1
             && (linked_nozzles || active_extruder == 0)
           #endif
-        ) zprobe_zoffset += mm;
+        ) zprobe_offset[Z_AXIS] += mm;
       #else
         UNUSED(mm);
       #endif
@@ -746,7 +746,7 @@ namespace ExtUI {
 
   float getZOffset_mm() {
     #if HAS_BED_PROBE
-      return zprobe_zoffset;
+      return zprobe_offset[Z_AXIS];
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       return babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1];
     #else
@@ -757,7 +757,7 @@ namespace ExtUI {
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
-        zprobe_zoffset = value;
+        zprobe_offset[Z_AXIS] = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, (value - babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1]));
     #else

commit 7f117bfc60aa3fd71e3d53892be39c7cd2d3d96c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Sep 18 18:35:03 2019 -0600

    EXTENSIBLE_UI Joystick support (#15303)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 851e8179ba..28b2ec006a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -102,12 +102,16 @@
   #include "../../feature/host_actions.h"
 #endif
 
-static struct {
-  uint8_t printer_killed  : 1;
-  uint8_t manual_motion : 1;
-} flags;
-
 namespace ExtUI {
+  static struct {
+    uint8_t printer_killed  : 1;
+    uint8_t manual_motion   : 1;
+  } flags;
+
+  #if ENABLED(JOYSTICK)
+    float norm_jog[XYZ];
+  #endif
+
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
@@ -193,6 +197,14 @@ namespace ExtUI {
     #endif
   }
 
+  void jog(float dx, float dy, float dz) {
+    #if ENABLED(JOYSTICK)
+      norm_jog[X] = dx;
+      norm_jog[Y] = dy;
+      norm_jog[Z] = dz;
+    #endif
+  }
+
   bool isHeaterIdle(const extruder_t extruder) {
     return false
       #if HOTENDS && HEATER_IDLE_HANDLER
@@ -1037,9 +1049,10 @@ void MarlinUI::update() {
 }
 
 void MarlinUI::kill_screen(PGM_P const msg) {
+  using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
-    ExtUI::onPrinterKilled(msg);
+    onPrinterKilled(msg);
   }
 }
 

commit 712aaa26d57c1cf0d1c0e91a0477952c58692145
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 18 03:18:03 2019 -0500

    Use provided 'constrain'

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 10085d17ac..851e8179ba 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -102,10 +102,6 @@
   #include "../../feature/host_actions.h"
 #endif
 
-inline float clamp(const float value, const float minimum, const float maximum) {
-  return _MAX(_MIN(value, maximum), minimum);
-}
-
 static struct {
   uint8_t printer_killed  : 1;
   uint8_t manual_motion : 1;
@@ -339,7 +335,7 @@ namespace ExtUI {
     setFeedrate_mm_s(MMM_TO_MMS(max_manual_feedrate[axis]));
 
     if (!flags.manual_motion) set_destination_from_current();
-    destination[axis] = clamp(position, min, max);
+    destination[axis] = constrain(position, min, max);
     flags.manual_motion = true;
   }
 
@@ -474,13 +470,13 @@ namespace ExtUI {
     void  setAxisCurrent_mA(const float mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
-          case X: stepperX.rms_current(clamp(mA, 500, 1500)); break;
+          case X: stepperX.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y)
-          case Y: stepperY.rms_current(clamp(mA, 500, 1500)); break;
+          case Y: stepperY.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z)
-          case Z: stepperZ.rms_current(clamp(mA, 500, 1500)); break;
+          case Z: stepperZ.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         default: break;
       };
@@ -489,22 +485,22 @@ namespace ExtUI {
     void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
-          case E0: stepperE0.rms_current(clamp(mA, 500, 1500)); break;
+          case E0: stepperE0.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E1)
-          case E1: stepperE1.rms_current(clamp(mA, 500, 1500)); break;
+          case E1: stepperE1.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E2)
-          case E2: stepperE2.rms_current(clamp(mA, 500, 1500)); break;
+          case E2: stepperE2.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E3)
-          case E3: stepperE3.rms_current(clamp(mA, 500, 1500)); break;
+          case E3: stepperE3.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E4)
-          case E4: stepperE4.rms_current(clamp(mA, 500, 1500)); break;
+          case E4: stepperE4.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E5)
-          case E5: stepperE5.rms_current(clamp(mA, 500, 1500)); break;
+          case E5: stepperE5.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         default: break;
       };
@@ -607,7 +603,7 @@ namespace ExtUI {
 
     #ifdef FILAMENT_RUNOUT_DISTANCE_MM
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
-      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(clamp(value, 0, 999)); }
+      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
@@ -618,7 +614,7 @@ namespace ExtUI {
 
     void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
-        planner.extruder_advance_K[extruder - E0] = clamp(value, 0, 999);
+        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 999);
     }
   #endif
 
@@ -629,7 +625,7 @@ namespace ExtUI {
     }
 
     void setJunctionDeviation_mm(const float value) {
-      planner.junction_deviation_mm = clamp(value, 0.01, 0.3);
+      planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
       #if ENABLED(LIN_ADVANCE)
         planner.recalculate_max_e_jerk();
       #endif
@@ -784,14 +780,14 @@ namespace ExtUI {
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
     void setAxisBacklash_mm(const float value, const axis_t axis)
-                                                      { backlash.distance_mm[axis] = clamp(value,0,5); }
+                                                      { backlash.distance_mm[axis] = constrain(value,0,5); }
 
     float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
-    void setBacklashCorrection_percent(const float value) { backlash.correction = map(clamp(value, 0, 100), 0, 100, 0, 255); }
+    void setBacklashCorrection_percent(const float value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
       float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
-      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = clamp(value, 0, 999); }
+      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = constrain(value, 0, 999); }
     #endif
   #endif
 
@@ -869,14 +865,14 @@ namespace ExtUI {
     enableHeater(heater);
     #if HAS_HEATED_BED
       if (heater == BED)
-        thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 10));
+        thermalManager.setTargetBed(constrain(value, 0, BED_MAXTEMP - 10));
       else
     #endif
       {
         #if HOTENDS
           static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
           const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+          thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);
         #endif
       }
   }
@@ -886,14 +882,14 @@ namespace ExtUI {
       constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
-      thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+      thermalManager.setTargetHotend(constrain(value, 0, heater_maxtemp[e] - 15), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     #if FAN_COUNT > 0
       if (fan < FAN_COUNT)
-        thermalManager.set_fan_speed(fan - FAN0, map(clamp(value, 0, 100), 0, 100, 0, 255));
+        thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
@@ -901,7 +897,7 @@ namespace ExtUI {
   }
 
   void setFeedrate_percent(const float value) {
-    feedrate_percentage = clamp(value, 10, 500);
+    feedrate_percentage = constrain(value, 10, 500);
   }
 
   void setUserConfirmed() {

commit b73744f9e74745103ac9ac56daad27d00fb0140a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 23:41:34 2019 -0500

    Update ExtUI, add test under DUE (#15298)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 61ad5a2f4a..10085d17ac 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -819,6 +819,9 @@ namespace ExtUI {
           #endif
         }
       }
+      void onMeshUpdate(const uint8_t xpos, const uint8_t ypos, const float zval) {
+        UNUSED(xpos); UNUSED(ypos); UNUSED(zval);
+      }
     #endif
   #endif
 

commit 73ac213cdd781f74425ae585980f20030ef28b04
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 17 19:46:38 2019 -0500

    Fix FileList::isAtRootDir

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 23e6718e14..61ad5a2f4a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -980,11 +980,11 @@ namespace ExtUI {
   }
 
   bool FileList::isAtRootDir() {
-    #if ENABLED(SDSUPPORT)
-      card.flag.workDirIsRoot;
-    #else
-      return true;
-    #endif
+    return (true
+      #if ENABLED(SDSUPPORT)
+        && card.flag.workDirIsRoot
+      #endif
+    );
   }
 
   void FileList::upDir() {

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index aa65a0734d..23e6718e14 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -809,7 +809,7 @@ namespace ExtUI {
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
-      bed_mesh_t getMeshArray() { return Z_VALUES_ARR; }
+      bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const uint8_t xpos, const uint8_t ypos) { return Z_VALUES(xpos,ypos); }
       void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {
         if (WITHIN(xpos, 0, GRID_MAX_POINTS_X) && WITHIN(ypos, 0, GRID_MAX_POINTS_Y)) {

commit f01f0d1956bb5cf0a9efb538b334ed6165a3e20f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 20:31:08 2019 -0500

    Drop C-style 'void' argument

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index ff02d25100..aa65a0734d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -901,7 +901,7 @@ namespace ExtUI {
     feedrate_percentage = clamp(value, 10, 500);
   }
 
-  void setUserConfirmed(void) {
+  void setUserConfirmed() {
     #if HAS_RESUME_CONTINUE
       wait_for_user = false;
     #endif

commit 4c00ddae567ab16f880df8db432dff8b9df76a33
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Sep 16 18:45:05 2019 -0600

    Remove obsolete LULZBOT_TOUCH_UI code (#15284)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 4f9f075d83..ff02d25100 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -529,12 +529,18 @@ namespace ExtUI {
       switch (axis) {
         #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
           case X: stepperX.homing_threshold(value); break;
+        #else
+          UNUSED(value);
         #endif
         #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
           case Y: stepperY.homing_threshold(value); break;
+        #else
+          UNUSED(value);
         #endif
         #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
           case Z: stepperZ.homing_threshold(value); break;
+        #else
+          UNUSED(value);
         #endif
         default: break;
       }

commit 98233b1de0c5871869f9f74c6e4a79247f7fb4f3
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Sep 17 05:49:55 2019 +0700

    Add root flag to CardReader (#15275)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 7b166250a8..4f9f075d83 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -975,8 +975,7 @@ namespace ExtUI {
 
   bool FileList::isAtRootDir() {
     #if ENABLED(SDSUPPORT)
-      card.getWorkDirName();
-      return card.filename[0] == '/';
+      card.flag.workDirIsRoot;
     #else
       return true;
     #endif

commit 7a569ad4d06d2d5541b76f03942cf4d7ab5bc119
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Sep 16 15:49:46 2019 -0600

    LULZBOT_TOUCH_UI fixes. Fix some warnings. (#15276)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 3b4818030e..7b166250a8 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -170,6 +170,8 @@ namespace ExtUI {
   void enableHeater(const extruder_t extruder) {
     #if HOTENDS && HEATER_IDLE_HANDLER
       thermalManager.reset_heater_idle_timer(extruder - E0);
+    #else
+      UNUSED(extruder);
     #endif
   }
 
@@ -190,6 +192,8 @@ namespace ExtUI {
           #endif
           break;
       }
+    #else
+      UNUSED(heater);
     #endif
   }
 
@@ -197,6 +201,8 @@ namespace ExtUI {
     return false
       #if HOTENDS && HEATER_IDLE_HANDLER
         || thermalManager.hotend_idle[extruder - E0].timed_out
+      #else
+        ; UNUSED(extruder)
       #endif
     ;
   }
@@ -218,6 +224,7 @@ namespace ExtUI {
           #endif
       }
     #else
+      UNUSED(heater);
       return false;
     #endif
   }

commit d5f520388077e697209b02f64e5ade61599df970
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 15 03:10:59 2019 -0500

    Use "mount" as card verb

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 9d29c1f1a0..3b4818030e 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -911,7 +911,7 @@ namespace ExtUI {
   }
 
   bool isMediaInserted() {
-    return IFSD(IS_SD_INSERTED() && card.isDetected(), false);
+    return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
   }
 
   void pausePrint() {
@@ -1008,14 +1008,14 @@ void MarlinUI::update() {
     if (sd_status != last_sd_status) {
       last_sd_status = sd_status;
       if (sd_status) {
-        card.initsd();
-        if (card.isDetected())
+        card.mount();
+        if (card.isMounted())
           ExtUI::onMediaInserted();
         else
           ExtUI::onMediaError();
       }
       else {
-        const bool ok = card.isDetected();
+        const bool ok = card.isMounted();
         card.release();
         if (ok) ExtUI::onMediaRemoved();
       }

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 43ffca3655..9d29c1f1a0 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -168,7 +168,7 @@ namespace ExtUI {
   }
 
   void enableHeater(const extruder_t extruder) {
-    #if HEATER_IDLE_HANDLER
+    #if HOTENDS && HEATER_IDLE_HANDLER
       thermalManager.reset_heater_idle_timer(extruder - E0);
     #endif
   }
@@ -184,14 +184,18 @@ namespace ExtUI {
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return; // Chamber has no idle timer
         #endif
-        default: thermalManager.reset_heater_idle_timer(heater - H0);
+        default:
+          #if HOTENDS
+            thermalManager.reset_heater_idle_timer(heater - H0);
+          #endif
+          break;
       }
     #endif
   }
 
   bool isHeaterIdle(const extruder_t extruder) {
     return false
-      #if HEATER_IDLE_HANDLER
+      #if HOTENDS && HEATER_IDLE_HANDLER
         || thermalManager.hotend_idle[extruder - E0].timed_out
       #endif
     ;
@@ -206,7 +210,12 @@ namespace ExtUI {
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return false; // Chamber has no idle timer
         #endif
-        default: return thermalManager.hotend_idle[heater - H0].timed_out;
+        default:
+          #if HOTENDS
+            return thermalManager.hotend_idle[heater - H0].timed_out;
+          #else
+            return false;
+          #endif
       }
     #else
       return false;
@@ -841,22 +850,28 @@ namespace ExtUI {
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
-    constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
-    const int16_t e = heater - H0;
     enableHeater(heater);
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 10));
       else
     #endif
-        thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+      {
+        #if HOTENDS
+          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+          const int16_t e = heater - H0;
+          thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+        #endif
+      }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
-    constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
-    const int16_t e = extruder - E0;
-    enableHeater(extruder);
-    thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+    #if HOTENDS
+      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+      const int16_t e = extruder - E0;
+      enableHeater(extruder);
+      thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
+    #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d24e636b12..43ffca3655 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -77,7 +77,7 @@
 
 #if HAS_TRINAMIC
   #include "../../feature/tmc_util.h"
-  #include "../../module/stepper_indirection.h"
+  #include "../../module/stepper/indirection.h"
 #endif
 
 #include "ui_api.h"

commit 0f386d06a14bcb42b679ce3536540d14fd9c0386
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Aug 28 03:23:13 2019 -0600

    Followup fixes to ExtUI (#15068)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 535556777e..d24e636b12 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -320,7 +320,7 @@ namespace ExtUI {
     #endif
 
     constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_MMS(max_manual_feedrate[axis]));
+    setFeedrate_mm_s(MMM_TO_MMS(max_manual_feedrate[axis]));
 
     if (!flags.manual_motion) set_destination_from_current();
     destination[axis] = clamp(position, min, max);
@@ -331,7 +331,7 @@ namespace ExtUI {
     setActiveTool(extruder, true);
 
     constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(MMM_MMS(max_manual_feedrate[E_AXIS]));
+    setFeedrate_mm_s(MMM_TO_MMS(max_manual_feedrate[E_AXIS]));
     if (!flags.manual_motion) set_destination_from_current();
     destination[E_AXIS] = position;
     flags.manual_motion = true;

commit f218405c36d03094f00d867fcebec07072ba7d44
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Aug 25 05:46:02 2019 -0400

    Fix ExtUI invalid speed, timer (#15031)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index cd6d36a800..535556777e 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -320,7 +320,7 @@ namespace ExtUI {
     #endif
 
     constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(max_manual_feedrate[axis]);
+    setFeedrate_mm_s(MMM_MMS(max_manual_feedrate[axis]));
 
     if (!flags.manual_motion) set_destination_from_current();
     destination[axis] = clamp(position, min, max);
@@ -331,7 +331,7 @@ namespace ExtUI {
     setActiveTool(extruder, true);
 
     constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
-    setFeedrate_mm_s(max_manual_feedrate[E_AXIS]);
+    setFeedrate_mm_s(MMM_MMS(max_manual_feedrate[E_AXIS]));
     if (!flags.manual_motion) set_destination_from_current();
     destination[E_AXIS] = position;
     flags.manual_motion = true;
@@ -714,17 +714,26 @@ namespace ExtUI {
     }
   #endif
 
-  #if HAS_BED_PROBE
-    float getZOffset_mm() {
+  float getZOffset_mm() {
+    #if HAS_BED_PROBE
       return zprobe_zoffset;
-    }
+    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
+      return babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1];
+    #else
+      return 0.0;
+    #endif
+  }
 
-    void setZOffset_mm(const float value) {
-      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+  void setZOffset_mm(const float value) {
+    #if HAS_BED_PROBE
+      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         zprobe_zoffset = value;
-      }
-    }
-  #endif // HAS_BED_PROBE
+    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
+      babystep.add_mm(Z_AXIS, (value - babystep.axis_total[BS_TOTAL_AXIS(Z_AXIS) + 1]));
+    #else
+      UNUSED(value);
+    #endif
+  }
 
   #if HAS_HOTEND_OFFSET
 

commit 69641f14203882d089e9d3c15430177a27196b5c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Aug 21 03:15:37 2019 -0600

    Fix incompatible types error (#15009)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 2f6c685dab..cd6d36a800 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -268,7 +268,7 @@ namespace ExtUI {
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
-    const uint8_t old_tool = active_extruder;
+    const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float pos = flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
     setActiveTool(old_tool, true);

commit 5a7c0216f7bd6e2c4b6daed2c5e79b9b20a3c195
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Aug 20 04:44:17 2019 -0400

    Misc. ExtUI fixes (#14971)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index c57c0f5014..2f6c685dab 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -60,7 +60,7 @@
   #include "../../libs/numtostr.h"
 #endif
 
-#if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
+#if EXTRUDERS > 1
   #include "../../module/tool_change.h"
 #endif
 
@@ -267,8 +267,12 @@ namespace ExtUI {
     return flags.manual_motion ? destination[axis] : current_position[axis];
   }
 
-  float getAxisPosition_mm(const extruder_t) {
-    return flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
+  float getAxisPosition_mm(const extruder_t extruder) {
+    const uint8_t old_tool = active_extruder;
+    setActiveTool(extruder, true);
+    const float pos = flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
+    setActiveTool(old_tool, true);
+    return pos;
   }
 
   void setAxisPosition_mm(const float position, const axis_t axis) {
@@ -315,6 +319,9 @@ namespace ExtUI {
       }
     #endif
 
+    constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
+    setFeedrate_mm_s(max_manual_feedrate[axis]);
+
     if (!flags.manual_motion) set_destination_from_current();
     destination[axis] = clamp(position, min, max);
     flags.manual_motion = true;
@@ -323,6 +330,8 @@ namespace ExtUI {
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
+    constexpr float max_manual_feedrate[XYZE] = MANUAL_FEEDRATE;
+    setFeedrate_mm_s(max_manual_feedrate[E_AXIS]);
     if (!flags.manual_motion) set_destination_from_current();
     destination[E_AXIS] = position;
     flags.manual_motion = true;
@@ -363,9 +372,7 @@ namespace ExtUI {
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if EXTRUDERS > 1
       const uint8_t e = extruder - E0;
-      #if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
-        if (e != active_extruder) tool_change(e, no_move);
-      #endif
+      if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);

commit 13d8dc0b79d650312a1a24c7e59421d3121a8a1b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Aug 10 18:25:30 2019 -0600

    Fix incorrect print stat in ExtUI (#14881)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 014c8da5e5..c57c0f5014 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -792,7 +792,7 @@ namespace ExtUI {
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrintTime_str(char buffer[21]) { duration_t(print_job_timer.getStats().printTime).toString(buffer);       return buffer; }
-    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().printTime).toString(buffer);       return buffer; }
+    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().longestPrint).toString(buffer);    return buffer; }
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);

commit 9cd66f6f7735995d161384015c0c6a9c4149a83d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jul 20 02:55:34 2019 -0400

    Fix missing include & condition (#14682)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index fd3eb5900e..014c8da5e5 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -676,7 +676,7 @@ namespace ExtUI {
         UNUSED(mm);
       #endif
 
-      #if EXTRUDERS > 1
+      #if EXTRUDERS > 1 && HAS_HOTEND_OFFSET
         /**
          * When linked_nozzles is false, as an axis is babystepped
          * adjust the hotend offsets so that the other nozzles are

commit 2c5436e3152363a18d995f8f7f6a4f9b0719d65d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Jul 17 16:07:41 2019 +0700

    Fix HOST_PROMPT_SUPPORT include in ExtUI API (#14650)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f186615b8f..fd3eb5900e 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -98,6 +98,10 @@
   #include "../../feature/babystep.h"
 #endif
 
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../../feature/host_actions.h"
+#endif
+
 inline float clamp(const float value, const float minimum, const float maximum) {
   return _MAX(_MIN(value, maximum), minimum);
 }

commit 57ed063ba11fd58222aa349d8af70b07f3c4935b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:16:10 2019 -0600

    Fix unused variable warnings (#14643)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 947e3d4065..f186615b8f 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -668,6 +668,8 @@ namespace ExtUI {
             && (linked_nozzles || active_extruder == 0)
           #endif
         ) zprobe_zoffset += mm;
+      #else
+        UNUSED(mm);
       #endif
 
       #if EXTRUDERS > 1
@@ -687,6 +689,7 @@ namespace ExtUI {
         }
       #else
         UNUSED(linked_nozzles);
+        UNUSED(mm);
       #endif
     }
 

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d4eb9617fb..947e3d4065 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -99,7 +99,7 @@
 #endif
 
 inline float clamp(const float value, const float minimum, const float maximum) {
-  return MAX(MIN(value, maximum), minimum);
+  return _MAX(_MIN(value, maximum), minimum);
 }
 
 static struct {

commit de8fee6aea9172f2b2cc430c16fdf76d9a6d3987
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 14:11:02 2019 -0500

    Clarify ExtUI command injection

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 32008afc22..d4eb9617fb 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -795,7 +795,7 @@ namespace ExtUI {
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
-  void enqueueCommands_P(PGM_P const gcode) {
+  void injectCommands_P(PGM_P const gcode) {
     queue.inject_P(gcode);
   }
 

commit e6cf7860e8fafb5c2bdb95ff36ad7d598fa5636a
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Jun 28 23:23:57 2019 -0600

    Improve ExtUI, fix compiler errors, warnings (#14441)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 87f2eab92d..32008afc22 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -242,18 +242,28 @@ namespace ExtUI {
   }
 
   float getTargetFan_percent(const fan_t fan) {
-    return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
+    #if FAN_COUNT > 0
+      return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
+    #else
+      UNUSED(fan);
+      return 0;
+    #endif
   }
 
   float getActualFan_percent(const fan_t fan) {
-    return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
+    #if FAN_COUNT > 0
+      return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
+    #else
+      UNUSED(fan);
+      return 0;
+    #endif
   }
 
   float getAxisPosition_mm(const axis_t axis) {
     return flags.manual_motion ? destination[axis] : current_position[axis];
   }
 
-  float getAxisPosition_mm(const extruder_t extruder) {
+  float getAxisPosition_mm(const extruder_t) {
     return flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
   }
 
@@ -353,6 +363,9 @@ namespace ExtUI {
         if (e != active_extruder) tool_change(e, no_move);
       #endif
       active_extruder = e;
+    #else
+      UNUSED(extruder);
+      UNUSED(no_move);
     #endif
   }
 
@@ -506,6 +519,7 @@ namespace ExtUI {
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
+    UNUSED_E(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
@@ -514,6 +528,7 @@ namespace ExtUI {
   }
 
   void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
     planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
   }
 
@@ -522,6 +537,7 @@ namespace ExtUI {
   }
 
   float getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
+    UNUSED_E(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
   }
 
@@ -530,6 +546,7 @@ namespace ExtUI {
   }
 
   void setAxisMaxFeedrate_mm_s(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
     planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = value;
   }
 
@@ -538,6 +555,7 @@ namespace ExtUI {
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
+    UNUSED_E(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
@@ -546,6 +564,7 @@ namespace ExtUI {
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
     planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)] = value;
   }
 
@@ -589,7 +608,7 @@ namespace ExtUI {
       return planner.max_jerk[axis];
     }
 
-    float getAxisMaxJerk_mm_s(const extruder_t extruder) {
+    float getAxisMaxJerk_mm_s(const extruder_t) {
       return planner.max_jerk[E_AXIS];
     }
 
@@ -597,7 +616,7 @@ namespace ExtUI {
       planner.max_jerk[axis] = value;
     }
 
-    void setAxisMaxJerk_mm_s(const float value, const extruder_t extruder) {
+    void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
       planner.max_jerk[E_AXIS] = value;
     }
   #endif
@@ -780,12 +799,16 @@ namespace ExtUI {
     queue.inject_P(gcode);
   }
 
-  bool commandsInQueue() { return (planner.movesplanned() || queue.length); }
+  bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) {
     return TEST(axis_known_position, axis);
   }
 
+  bool isAxisPositionKnown(const extruder_t) {
+    return TEST(axis_known_position, E_AXIS);
+  }
+
   bool isPositionKnown() { return all_axes_known(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
@@ -814,8 +837,13 @@ namespace ExtUI {
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
-    if (fan < FAN_COUNT)
-      thermalManager.set_fan_speed(fan - FAN0, map(clamp(value, 0, 100), 0, 100, 0, 255));
+    #if FAN_COUNT > 0
+      if (fan < FAN_COUNT)
+        thermalManager.set_fan_speed(fan - FAN0, map(clamp(value, 0, 100), 0, 100, 0, 255));
+    #else
+      UNUSED(value);
+      UNUSED(fan);
+    #endif
   }
 
   void setFeedrate_percent(const float value) {

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 2ecfe91d62..87f2eab92d 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -246,7 +246,7 @@ namespace ExtUI {
   }
 
   float getActualFan_percent(const fan_t fan) {
-    return thermalManager.fanPercent((thermalManager.fan_speed[fan - FAN0] * uint16_t(thermalManager.fan_speed_scaler[fan - FAN0])) >> 7);
+    return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
   }
 
   float getAxisPosition_mm(const axis_t axis) {

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8cb8c55b8f..2ecfe91d62 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit aa0383a83b7bc45b86753ef9f5adb41da09c76df
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 23 21:00:48 2019 -0400

    Enhance IDEX toolchange auto-return w/ no park, full control (#14117)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index dff8108d01..8cb8c55b8f 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -350,7 +350,7 @@ namespace ExtUI {
     #if EXTRUDERS > 1
       const uint8_t e = extruder - E0;
       #if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
-        if (e != active_extruder) tool_change(e, 0, no_move);
+        if (e != active_extruder) tool_change(e, no_move);
       #endif
       active_extruder = e;
     #endif

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index e89ed2ec64..dff8108d01 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -473,13 +473,13 @@ namespace ExtUI {
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
-          case X: return stepperX.sgt();
+          case X: return stepperX.homing_threshold();
         #endif
         #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
-          case Y: return stepperY.sgt();
+          case Y: return stepperY.homing_threshold();
         #endif
         #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
-          case Z: return stepperZ.sgt();
+          case Z: return stepperZ.homing_threshold();
         #endif
         default: return 0;
       }
@@ -488,13 +488,13 @@ namespace ExtUI {
     void setTMCBumpSensitivity(const float value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
-          case X: stepperX.sgt(clamp(value, -64, 63)); break;
+          case X: stepperX.homing_threshold(value); break;
         #endif
         #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
-          case Y: stepperY.sgt(clamp(value, -64, 63)); break;
+          case Y: stepperY.homing_threshold(value); break;
         #endif
         #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
-          case Z: stepperZ.sgt(clamp(value, -64, 63)); break;
+          case Z: stepperZ.homing_threshold(value); break;
         #endif
         default: break;
       }

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index cabed6f322..e89ed2ec64 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -777,10 +777,10 @@ namespace ExtUI {
   float getFeedrate_percent() { return feedrate_percentage; }
 
   void enqueueCommands_P(PGM_P const gcode) {
-    enqueue_and_echo_commands_P(gcode);
+    queue.inject_P(gcode);
   }
 
-  bool commandsInQueue() { return (planner.movesplanned() || commands_in_queue); }
+  bool commandsInQueue() { return (planner.movesplanned() || queue.length); }
 
   bool isAxisPositionKnown(const axis_t axis) {
     return TEST(axis_known_position, axis);

commit 2a96d4e23ad0090dc371710d079af731136dfe97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 11 05:58:43 2019 -0500

    Move number-to-string functions to libs

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index b34a4b8238..cabed6f322 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -57,6 +57,7 @@
 
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
+  #include "../../libs/numtostr.h"
 #endif
 
 #if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)

commit 66e22d9f5a9fe8c9a5076f67099be413c99cd9e8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Jun 7 08:08:41 2019 -0400

    ExtUI Heated Chamber support (#14198)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 0871036118..b34a4b8238 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -170,12 +170,17 @@ namespace ExtUI {
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
-      #if HAS_HEATED_BED
-        if (heater == BED)
-          thermalManager.reset_bed_idle_timer();
-        else
-      #endif
-          thermalManager.reset_heater_idle_timer(heater - H0);
+      switch (heater) {
+        #if HAS_HEATED_BED
+          case BED:
+            thermalManager.reset_bed_idle_timer();
+            return;
+        #endif
+        #if HAS_HEATED_CHAMBER
+          case CHAMBER: return; // Chamber has no idle timer
+        #endif
+        default: thermalManager.reset_heater_idle_timer(heater - H0);
+      }
     #endif
   }
 
@@ -188,23 +193,31 @@ namespace ExtUI {
   }
 
   bool isHeaterIdle(const heater_t heater) {
-    return (false
-      #if HEATER_IDLE_HANDLER
-        || (heater == BED ? (false
-          #if HAS_HEATED_BED
-            || thermalManager.bed_idle.timed_out
-          #endif
-        ) : thermalManager.hotend_idle[heater - H0].timed_out)
-      #endif
-    );
+    #if HEATER_IDLE_HANDLER
+      switch (heater) {
+        #if HAS_HEATED_BED
+          case BED: return thermalManager.bed_idle.timed_out;
+        #endif
+        #if HAS_HEATED_CHAMBER
+          case CHAMBER: return false; // Chamber has no idle timer
+        #endif
+        default: return thermalManager.hotend_idle[heater - H0].timed_out;
+      }
+    #else
+      return false;
+    #endif
   }
 
   float getActualTemp_celsius(const heater_t heater) {
-    return heater == BED ? (0
+    switch (heater) {
       #if HAS_HEATED_BED
-        + thermalManager.degBed()
+        case BED: return thermalManager.degBed();
+      #endif
+      #if HAS_HEATED_CHAMBER
+        case CHAMBER: return thermalManager.degChamber();
       #endif
-    ) : thermalManager.degHotend(heater - H0);
+      default: return thermalManager.degHotend(heater - H0);
+    }
   }
 
   float getActualTemp_celsius(const extruder_t extruder) {
@@ -212,11 +225,15 @@ namespace ExtUI {
   }
 
   float getTargetTemp_celsius(const heater_t heater) {
-    return heater == BED ? (0
+    switch (heater) {
       #if HAS_HEATED_BED
-        + thermalManager.degTargetBed()
+        case BED: return thermalManager.degTargetBed();
       #endif
-    ) : thermalManager.degTargetHotend(heater - H0);
+      #if HAS_HEATED_CHAMBER
+        case CHAMBER: return thermalManager.degTargetChamber();
+      #endif
+      default: return thermalManager.degTargetHotend(heater - H0);
+    }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
@@ -839,7 +856,7 @@ namespace ExtUI {
   }
 
   void stopPrint() {
-    ui.stop_print();
+    ui.abort_print();
   }
 
   FileList::FileList() { refresh(); }

commit f889cc6ea62ff07cf2d61de400f403cd55676630
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu May 30 17:24:13 2019 -0400

    ExtUI parity with SPI LCDs (#14172)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 017b652a0c..0871036118 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -831,35 +831,15 @@ namespace ExtUI {
   }
 
   void pausePrint() {
-    #if ENABLED(SDSUPPORT)
-      card.pauseSDPrint();
-      print_job_timer.pause();
-      #if ENABLED(PARK_HEAD_ON_PAUSE)
-        enqueue_and_echo_commands_P(PSTR("M125"));
-      #endif
-      ui.set_status_P(PSTR(MSG_PRINT_PAUSED));
-    #endif
+    ui.pause_print();
   }
 
   void resumePrint() {
-    #if ENABLED(SDSUPPORT)
-      ui.set_status_P(PSTR(MSG_FILAMENT_CHANGE_RESUME_1));
-      #if ENABLED(PARK_HEAD_ON_PAUSE)
-        wait_for_heatup = wait_for_user = false;
-        enqueue_and_echo_commands_P(PSTR("M24"));
-      #else
-        card.startFileprint();
-        print_job_timer.start();
-      #endif
-    #endif
+    ui.resume_print();
   }
 
   void stopPrint() {
-    #if ENABLED(SDSUPPORT)
-      wait_for_heatup = wait_for_user = false;
-      card.flag.abort_sd_printing = true;
-      ui.set_status_P(PSTR(MSG_PRINT_ABORTED));
-    #endif
+    ui.stop_print();
   }
 
   FileList::FileList() { refresh(); }

commit 84ac5b360bb221deafb75fd8a1f773658410d79e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri May 17 21:37:23 2019 -0400

    Fix ExtUI mesh functions (#14027)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 9456f284ff..017b652a0c 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -725,8 +725,8 @@ namespace ExtUI {
   #if HAS_LEVELING
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
+    bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
-      bool getMeshValid() { return leveling_is_valid(); }
       bed_mesh_t getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const uint8_t xpos, const uint8_t ypos) { return Z_VALUES(xpos,ypos); }
       void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {

commit 227f29090d1c46a4da79db3ae4f84bd96ea8a0ee
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 10 14:56:13 2019 -0600

    Add heater timeouts to ExtUI (#13970)
    
    - Add local UI methods to get heater timeout state.
    - Add methods to resume timed-out heaters.
    - Re-enable heaters on UI temperature request.
    - Make `ExtUI` show a dialog box if pause needs a button press after reheat.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index a140896bfa..9456f284ff 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -148,9 +148,7 @@ namespace ExtUI {
     }
   #endif // __SAM3X8E__
 
-  void delay_us(unsigned long us) {
-    DELAY_US(us);
-  }
+  void delay_us(unsigned long us) { DELAY_US(us); }
 
   void delay_ms(unsigned long ms) {
     if (flags.printer_killed)
@@ -164,14 +162,49 @@ namespace ExtUI {
       thermalManager.manage_heater();
   }
 
+  void enableHeater(const extruder_t extruder) {
+    #if HEATER_IDLE_HANDLER
+      thermalManager.reset_heater_idle_timer(extruder - E0);
+    #endif
+  }
+
+  void enableHeater(const heater_t heater) {
+    #if HEATER_IDLE_HANDLER
+      #if HAS_HEATED_BED
+        if (heater == BED)
+          thermalManager.reset_bed_idle_timer();
+        else
+      #endif
+          thermalManager.reset_heater_idle_timer(heater - H0);
+    #endif
+  }
+
+  bool isHeaterIdle(const extruder_t extruder) {
+    return false
+      #if HEATER_IDLE_HANDLER
+        || thermalManager.hotend_idle[extruder - E0].timed_out
+      #endif
+    ;
+  }
+
+  bool isHeaterIdle(const heater_t heater) {
+    return (false
+      #if HEATER_IDLE_HANDLER
+        || (heater == BED ? (false
+          #if HAS_HEATED_BED
+            || thermalManager.bed_idle.timed_out
+          #endif
+        ) : thermalManager.hotend_idle[heater - H0].timed_out)
+      #endif
+    );
+  }
+
   float getActualTemp_celsius(const heater_t heater) {
-    return heater == BED ?
+    return heater == BED ? (0
       #if HAS_HEATED_BED
-        thermalManager.degBed()
-      #else
-        0
+        + thermalManager.degBed()
       #endif
-      : thermalManager.degHotend(heater - H0);
+    ) : thermalManager.degHotend(heater - H0);
   }
 
   float getActualTemp_celsius(const extruder_t extruder) {
@@ -179,13 +212,11 @@ namespace ExtUI {
   }
 
   float getTargetTemp_celsius(const heater_t heater) {
-    return heater == BED ?
+    return heater == BED ? (0
       #if HAS_HEATED_BED
-        thermalManager.degTargetBed()
-      #else
-        0
+        + thermalManager.degTargetBed()
       #endif
-      : thermalManager.degTargetHotend(heater - H0);
+    ) : thermalManager.degTargetHotend(heater - H0);
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
@@ -252,8 +283,7 @@ namespace ExtUI {
       }
     #endif
 
-    if (!flags.manual_motion)
-      set_destination_from_current();
+    if (!flags.manual_motion) set_destination_from_current();
     destination[axis] = clamp(position, min, max);
     flags.manual_motion = true;
   }
@@ -261,8 +291,7 @@ namespace ExtUI {
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);
 
-    if (!flags.manual_motion)
-      set_destination_from_current();
+    if (!flags.manual_motion) set_destination_from_current();
     destination[E_AXIS] = position;
     flags.manual_motion = true;
   }
@@ -303,8 +332,7 @@ namespace ExtUI {
     #if EXTRUDERS > 1
       const uint8_t e = extruder - E0;
       #if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
-        if (e != active_extruder)
-          tool_change(e, 0, no_move);
+        if (e != active_extruder) tool_change(e, 0, no_move);
       #endif
       active_extruder = e;
     #endif
@@ -341,13 +369,8 @@ namespace ExtUI {
   }
 
   #if HAS_SOFTWARE_ENDSTOPS
-    bool getSoftEndstopState() {
-      return soft_endstops_enabled;
-    }
-
-    void setSoftEndstopState(const bool value) {
-      soft_endstops_enabled = value;
-    }
+    bool getSoftEndstopState() { return soft_endstops_enabled; }
+    void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
   #endif
 
   #if HAS_TRINAMIC
@@ -513,13 +536,8 @@ namespace ExtUI {
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
 
     #ifdef FILAMENT_RUNOUT_DISTANCE_MM
-      float getFilamentRunoutDistance_mm() {
-        return runout.runout_distance();
-      }
-
-      void setFilamentRunoutDistance_mm(const float value) {
-        runout.set_runout_distance(clamp(value, 0, 999));
-      }
+      float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
+      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(clamp(value, 0, 999)); }
     #endif
   #endif
 
@@ -761,6 +779,7 @@ namespace ExtUI {
   void setTargetTemp_celsius(float value, const heater_t heater) {
     constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
     const int16_t e = heater - H0;
+    enableHeater(heater);
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 10));
@@ -772,6 +791,7 @@ namespace ExtUI {
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
     const int16_t e = extruder - E0;
+    enableHeater(extruder);
     thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
   }
 

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8e531ec2a9..a140896bfa 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -82,11 +82,7 @@
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
-  extern float backlash_distance_mm[XYZ];
-  extern uint8_t backlash_correction;
-  #ifdef BACKLASH_SMOOTHING_MM
-    extern float backlash_smoothing_mm;
-  #endif
+  #include "../../feature/backlash.h"
 #endif
 
 #if HAS_LEVELING
@@ -111,7 +107,6 @@ static struct {
 } flags;
 
 namespace ExtUI {
-
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
@@ -517,13 +512,13 @@ namespace ExtUI {
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
 
-    #if FILAMENT_RUNOUT_DISTANCE_MM > 0
+    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
       float getFilamentRunoutDistance_mm() {
-        return RunoutResponseDelayed::runout_distance_mm;
+        return runout.runout_distance();
       }
 
       void setFilamentRunoutDistance_mm(const float value) {
-        RunoutResponseDelayed::runout_distance_mm = clamp(value, 0, 999);
+        runout.set_runout_distance(clamp(value, 0, 999));
       }
     #endif
   #endif
@@ -687,16 +682,16 @@ namespace ExtUI {
   #endif // HAS_HOTEND_OFFSET
 
   #if ENABLED(BACKLASH_GCODE)
-    float getAxisBacklash_mm(const axis_t axis)       { return backlash_distance_mm[axis]; }
+    float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
     void setAxisBacklash_mm(const float value, const axis_t axis)
-                                                      { backlash_distance_mm[axis] = clamp(value,0,5); }
+                                                      { backlash.distance_mm[axis] = clamp(value,0,5); }
 
-    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash_correction); }
-    void setBacklashCorrection_percent(const float value) { backlash_correction = map(clamp(value, 0, 100), 0, 100, 0, 255); }
+    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
+    void setBacklashCorrection_percent(const float value) { backlash.correction = map(clamp(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
-      float getBacklashSmoothing_mm()                 { return backlash_smoothing_mm; }
-      void setBacklashSmoothing_mm(const float value) { backlash_smoothing_mm = clamp(value, 0, 999); }
+      float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
+      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = clamp(value, 0, 999); }
     #endif
   #endif
 
@@ -750,7 +745,7 @@ namespace ExtUI {
   }
 
   bool commandsInQueue() { return (planner.movesplanned() || commands_in_queue); }
-  
+
   bool isAxisPositionKnown(const axis_t axis) {
     return TEST(axis_known_position, axis);
   }

commit 610fb4668393265bbe2f18fe96a329b832ddc0c3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Apr 26 03:32:01 2019 -0400

    Fix some ExtUI issues (#13799)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index aa71743e12..8e531ec2a9 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -715,6 +715,7 @@ namespace ExtUI {
     #if HAS_MESH
       bool getMeshValid() { return leveling_is_valid(); }
       bed_mesh_t getMeshArray() { return Z_VALUES_ARR; }
+      float getMeshPoint(const uint8_t xpos, const uint8_t ypos) { return Z_VALUES(xpos,ypos); }
       void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {
         if (WITHIN(xpos, 0, GRID_MAX_POINTS_X) && WITHIN(ypos, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(xpos, ypos) = zoff;
@@ -748,10 +749,15 @@ namespace ExtUI {
     enqueue_and_echo_commands_P(gcode);
   }
 
+  bool commandsInQueue() { return (planner.movesplanned() || commands_in_queue); }
+  
   bool isAxisPositionKnown(const axis_t axis) {
     return TEST(axis_known_position, axis);
   }
 
+  bool isPositionKnown() { return all_axes_known(); }
+  bool isMachineHomed() { return all_axes_homed(); }
+
   PGM_P getFirmwareName_str() {
     static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
     return firmware_name;

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 3965371439..aa71743e12 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -97,6 +97,10 @@
   #include "../../feature/runout.h"
 #endif
 
+#if ENABLED(BABYSTEPPING)
+  #include "../../feature/babystep.h"
+#endif
+
 inline float clamp(const float value, const float minimum, const float maximum) {
   return MAX(MIN(value, maximum), minimum);
 }
@@ -584,10 +588,10 @@ namespace ExtUI {
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
-          case X: thermalManager.babystep_axis(X_AXIS, steps); break;
-          case Y: thermalManager.babystep_axis(Y_AXIS, steps); break;
+          case X: babystep.add_steps(X_AXIS, steps); break;
+          case Y: babystep.add_steps(Y_AXIS, steps); break;
         #endif
-        case Z: thermalManager.babystep_axis(Z_AXIS, steps); break;
+        case Z: babystep.add_steps(Z_AXIS, steps); break;
         default: return false;
       };
       return true;

commit 5679fae11efbc7e8b9de2f0e68dc9a879757ff88
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 29 13:07:43 2019 -0600

    UltraLCD enhancements (lower fan resolution, backlash menu) (#13519)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 329e551b25..3965371439 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -82,7 +82,8 @@
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
-  extern float backlash_distance_mm[XYZ], backlash_correction;
+  extern float backlash_distance_mm[XYZ];
+  extern uint8_t backlash_correction;
   #ifdef BACKLASH_SMOOTHING_MM
     extern float backlash_smoothing_mm;
   #endif
@@ -686,8 +687,8 @@ namespace ExtUI {
     void setAxisBacklash_mm(const float value, const axis_t axis)
                                                       { backlash_distance_mm[axis] = clamp(value,0,5); }
 
-    float getBacklashCorrection_percent()             { return backlash_correction * 100; }
-    void setBacklashCorrection_percent(const float value) { backlash_correction = clamp(value, 0, 100) / 100.0f; }
+    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash_correction); }
+    void setBacklashCorrection_percent(const float value) { backlash_correction = map(clamp(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
       float getBacklashSmoothing_mm()                 { return backlash_smoothing_mm; }

commit 7462fe3068632c2e2bc2d0a33d045a7f74f432a4
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Mar 25 19:41:38 2019 -0600

    Fix compile error, squelch warnings (#13487)
    
    - Fix path to `bedlevel.h` include file
    - Add default to `case` statements to suppress warnings

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 80f84e98fd..329e551b25 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -89,7 +89,7 @@
 #endif
 
 #if HAS_LEVELING
-  #include "../../feature/bedlevel.h"
+  #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
@@ -401,6 +401,7 @@ namespace ExtUI {
         #if AXIS_IS_TMC(Z)
           case Z: stepperZ.rms_current(clamp(mA, 500, 1500)); break;
         #endif
+        default: break;
       };
     }
 
@@ -424,6 +425,7 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E5)
           case E5: stepperE5.rms_current(clamp(mA, 500, 1500)); break;
         #endif
+        default: break;
       };
     }
 
@@ -438,6 +440,7 @@ namespace ExtUI {
         #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
           case Z: return stepperZ.sgt();
         #endif
+        default: return 0;
       }
     }
 
@@ -452,6 +455,7 @@ namespace ExtUI {
         #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
           case Z: stepperZ.sgt(clamp(value, -64, 63)); break;
         #endif
+        default: break;
       }
     }
   #endif

commit a0ca98f699b424dad1e123b89194bfbbcb3e49fe
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Mar 23 22:09:18 2019 -0600

    Additional ExtUI features (#13449)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index e8595b1eec..80f84e98fd 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -74,8 +74,9 @@
   #define IFSD(A,B) (B)
 #endif
 
-#if HAS_TRINAMIC && HAS_LCD_MENU
+#if HAS_TRINAMIC
   #include "../../feature/tmc_util.h"
+  #include "../../module/stepper_indirection.h"
 #endif
 
 #include "ui_api.h"
@@ -339,6 +340,122 @@ namespace ExtUI {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
+  #if HAS_SOFTWARE_ENDSTOPS
+    bool getSoftEndstopState() {
+      return soft_endstops_enabled;
+    }
+
+    void setSoftEndstopState(const bool value) {
+      soft_endstops_enabled = value;
+    }
+  #endif
+
+  #if HAS_TRINAMIC
+    float getAxisCurrent_mA(const axis_t axis) {
+      switch (axis) {
+        #if AXIS_IS_TMC(X)
+          case X: return stepperX.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y)
+          case Y: return stepperY.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z)
+          case Z: return stepperZ.getMilliamps();
+        #endif
+        default: return NAN;
+      };
+    }
+
+    float getAxisCurrent_mA(const extruder_t extruder) {
+      switch (extruder) {
+        #if AXIS_IS_TMC(E0)
+          case E0: return stepperE0.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E1)
+          case E1: return stepperE1.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E2)
+          case E2: return stepperE2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E3)
+          case E3: return stepperE3.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E4)
+          case E4: return stepperE4.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E5)
+          case E5: return stepperE5.getMilliamps();
+        #endif
+        default: return NAN;
+      };
+    }
+
+    void  setAxisCurrent_mA(const float mA, const axis_t axis) {
+      switch (axis) {
+        #if AXIS_IS_TMC(X)
+          case X: stepperX.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Y)
+          case Y: stepperY.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Z)
+          case Z: stepperZ.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+      };
+    }
+
+    void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
+      switch (extruder) {
+        #if AXIS_IS_TMC(E0)
+          case E0: stepperE0.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E1)
+          case E1: stepperE1.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E2)
+          case E2: stepperE2.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E3)
+          case E3: stepperE3.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E4)
+          case E4: stepperE4.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E5)
+          case E5: stepperE5.rms_current(clamp(mA, 500, 1500)); break;
+        #endif
+      };
+    }
+
+    int getTMCBumpSensitivity(const axis_t axis) {
+      switch (axis) {
+        #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
+          case X: return stepperX.sgt();
+        #endif
+        #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
+          case Y: return stepperY.sgt();
+        #endif
+        #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
+          case Z: return stepperZ.sgt();
+        #endif
+      }
+    }
+
+    void setTMCBumpSensitivity(const float value, const axis_t axis) {
+      switch (axis) {
+        #if X_SENSORLESS && AXIS_HAS_STALLGUARD(X)
+          case X: stepperX.sgt(clamp(value, -64, 63)); break;
+        #endif
+        #if Y_SENSORLESS && AXIS_HAS_STALLGUARD(Y)
+          case Y: stepperY.sgt(clamp(value, -64, 63)); break;
+        #endif
+        #if Z_SENSORLESS && AXIS_HAS_STALLGUARD(Z)
+          case Z: stepperZ.sgt(clamp(value, -64, 63)); break;
+        #endif
+      }
+    }
+  #endif
+
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
@@ -787,10 +904,6 @@ void MarlinUI::init() {
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
 
-  #if HAS_TRINAMIC && HAS_LCD_MENU
-    init_tmc_section();
-  #endif
-
   ExtUI::onStartup();
 }
 

commit 5b2c37d6c1318079687eed6e14aecd3a4ef2ce47
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Mar 18 17:31:11 2019 -0400

    Followup to BLTouch (#13422)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 6f2edfe4f1..e8595b1eec 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -588,7 +588,7 @@ namespace ExtUI {
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     #if HAS_MESH
       bool getMeshValid() { return leveling_is_valid(); }
-      bed_mesh_t getMeshArray() { return Z_VALUES; }
+      bed_mesh_t getMeshArray() { return Z_VALUES_ARR; }
       void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {
         if (WITHIN(xpos, 0, GRID_MAX_POINTS_X) && WITHIN(ypos, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(xpos, ypos) = zoff;

commit 3fb8489ae333b76412f38d48d6475249abcdfdde
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 08:57:54 2019 -0400

    EXTUI and UBL compilation fixes (#13420)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index c10a6ca304..6f2edfe4f1 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -87,6 +87,10 @@
   #endif
 #endif
 
+#if HAS_LEVELING
+  #include "../../feature/bedlevel.h"
+#endif
+
 #if HAS_FILAMENT_SENSOR
   #include "../../feature/runout.h"
 #endif
@@ -417,7 +421,9 @@ namespace ExtUI {
 
     void setJunctionDeviation_mm(const float value) {
       planner.junction_deviation_mm = clamp(value, 0.01, 0.3);
-      planner.recalculate_max_e_jerk();
+      #if ENABLED(LIN_ADVANCE)
+        planner.recalculate_max_e_jerk();
+      #endif
     }
 
   #else
@@ -579,7 +585,7 @@ namespace ExtUI {
 
   #if HAS_LEVELING
     bool getLevelingActive() { return planner.leveling_active; }
-    void setLevelingActive(const bool state) { set_bed_leveling_enabled(state) }
+    void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     #if HAS_MESH
       bool getMeshValid() { return leveling_is_valid(); }
       bed_mesh_t getMeshArray() { return Z_VALUES; }

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 02e718c655..c10a6ca304 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -59,7 +59,7 @@
   #include "../../core/utility.h"
 #endif
 
-#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
   #include "../../module/tool_change.h"
 #endif
 
@@ -297,7 +297,7 @@ namespace ExtUI {
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if EXTRUDERS > 1
       const uint8_t e = extruder - E0;
-      #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+      #if DO_SWITCH_EXTRUDER || EITHER(SWITCHING_NOZZLE, PARKING_EXTRUDER)
         if (e != active_extruder)
           tool_change(e, 0, no_move);
       #endif

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index a7823a10da..02e718c655 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -213,26 +213,26 @@ namespace ExtUI {
       if (soft_endstops_enabled) switch (axis) {
         case X_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-            min = soft_endstop_min[X_AXIS];
+            min = soft_endstop[X_AXIS].min;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-            max = soft_endstop_max[X_AXIS];
+            max = soft_endstop[X_AXIS].max;
           #endif
           break;
         case Y_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-            min = soft_endstop_min[Y_AXIS];
+            min = soft_endstop[Y_AXIS].min;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-            max = soft_endstop_max[Y_AXIS];
+            max = soft_endstop[Y_AXIS].max;
           #endif
           break;
         case Z_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-            min = soft_endstop_min[Z_AXIS];
+            min = soft_endstop[Z_AXIS].min;
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-            max = soft_endstop_max[Z_AXIS];
+            max = soft_endstop[Z_AXIS].max;
           #endif
         default: break;
       }

commit c03df89921ba0327dda27c5df52aadd3754074aa
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:45:52 2019 -0400

    ExtUI Mesh Leveling Extensions (#13363)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 4d1a1828d0..a7823a10da 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -577,6 +577,27 @@ namespace ExtUI {
     return elapsed.value;
   }
 
+  #if HAS_LEVELING
+    bool getLevelingActive() { return planner.leveling_active; }
+    void setLevelingActive(const bool state) { set_bed_leveling_enabled(state) }
+    #if HAS_MESH
+      bool getMeshValid() { return leveling_is_valid(); }
+      bed_mesh_t getMeshArray() { return Z_VALUES; }
+      void setMeshPoint(const uint8_t xpos, const uint8_t ypos, const float zoff) {
+        if (WITHIN(xpos, 0, GRID_MAX_POINTS_X) && WITHIN(ypos, 0, GRID_MAX_POINTS_Y)) {
+          Z_VALUES(xpos, ypos) = zoff;
+          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+            bed_level_virt_interpolate();
+          #endif
+        }
+      }
+    #endif
+  #endif
+
+  #if ENABLED(HOST_PROMPT_SUPPORT)
+    void setHostResponse(const uint8_t response) { host_response_handler(response); }
+  #endif
+
   #if ENABLED(PRINTCOUNTER)
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }

commit d94e077901e15557e94f64640adf37e10defb7f2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 20:48:49 2019 -0500

    Apply HAS_HOTEND_OFFSET where needed

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 74f30bd5fe..4d1a1828d0 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -530,7 +530,7 @@ namespace ExtUI {
     }
   #endif // HAS_BED_PROBE
 
-  #if HOTENDS > 1
+  #if HAS_HOTEND_OFFSET
 
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
@@ -552,7 +552,7 @@ namespace ExtUI {
       HOTEND_LOOP() hotend_offset[axis][e] -= offs;
     }
 
-  #endif // HOTENDS > 1
+  #endif // HAS_HOTEND_OFFSET
 
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash_distance_mm[axis]; }

commit e52bcc9408f7ff207140d6fe8c9155237c3ca21b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 16:32:34 2019 -0500

    Limit top bed temp to BED_MAXTEMP - 10
    
    The chances of a 10 overshoot is pretty minimal.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index ae58b51eb8..74f30bd5fe 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -609,7 +609,7 @@ namespace ExtUI {
     const int16_t e = heater - H0;
     #if HAS_HEATED_BED
       if (heater == BED)
-        thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 15));
+        thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 10));
       else
     #endif
         thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);

commit 60e82e3929bfd402384e7dea9d737796c96fa07f
Author: Tobias Frost <coldtobi@users.noreply.github.com>
Date:   Sat Mar 9 21:13:50 2019 +0100

    Send notifications to ExtUI for M0/M1 (#13344)
    
    - Send notifications to ExtUI for M0/M1
    
    - wait_for_user can be non-volatile (not changed by interrupt)
      C / C++ compilers don't optimize away reads of non-volatile variables when a function call is used between accesses, because *any* variable could be changed by the function call. Since `wait_for_user` can't be changed without a function call, it should be non-volatile so the compiler can optimize away cases where it is read more than once without an intervening function call.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 929351201b..ae58b51eb8 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -630,6 +630,12 @@ namespace ExtUI {
     feedrate_percentage = clamp(value, 10, 500);
   }
 
+  void setUserConfirmed(void) {
+    #if HAS_RESUME_CONTINUE
+      wait_for_user = false;
+    #endif
+  }
+
   void printFile(const char *filename) {
     IFSD(card.openAndPrintFile(filename), NOOP);
   }

commit afbec5ff7eb1a88ee8b03111bf5976539d2697d1
Author: Tobias Frost <coldtobi@users.noreply.github.com>
Date:   Fri Mar 8 01:00:38 2019 +0100

    Have ExtUI::getProgress use ui.get_progress (#13328)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 1cbd9b007a..929351201b 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -569,7 +569,7 @@ namespace ExtUI {
   #endif
 
   uint8_t getProgress_percent() {
-    return IFSD(card.percentDone(), 0);
+    return ui.get_progress();
   }
 
   uint32_t getProgress_seconds_elapsed() {

commit 7ce13a6ec102eb32d15bcc70a532ad367a8c034f
Author: Tobias Frost <coldtobi@users.noreply.github.com>
Date:   Tue Mar 5 13:39:15 2019 +0100

    Fix a print_job_timer compile error (#13304)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 7165b5eefa..1cbd9b007a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -51,9 +51,14 @@
 #include "../../module/planner.h"
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
+#include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
 
+#if ENABLED(PRINTCOUNTER)
+  #include "../../core/utility.h"
+#endif
+
 #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "../../module/tool_change.h"
 #endif
@@ -69,11 +74,6 @@
   #define IFSD(A,B) (B)
 #endif
 
-#if ENABLED(PRINTCOUNTER)
-  #include "../../core/utility.h"
-  #include "../../module/printcounter.h"
-#endif
-
 #if HAS_TRINAMIC && HAS_LCD_MENU
   #include "../../feature/tmc_util.h"
 #endif

commit 57afd0ab37060795b8ae5a6b868a918a2ee75810
Author: Tobias Frost <coldtobi@users.noreply.github.com>
Date:   Sat Mar 2 23:43:08 2019 +0100

    Fix range check bug in FileList::seek() (#13286)
    
    When `count()` returns 0, `pos > (count()-1)` will always yield `true` due to integer underflow.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 88b5d35a4a..7165b5eefa 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -688,7 +688,7 @@ namespace ExtUI {
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
-      if (!skip_range_check && pos > (count() - 1)) return false;
+      if (!skip_range_check && (pos + 1) > count()) return false;
       const uint16_t nr =
         #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
           count() - 1 -

commit 7cf9b93f26f728f0104dc9b930f6b23096639d98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 20:08:34 2019 -0600

    Add HAS_FILAMENT_SENSOR ahead of 12962

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 18add7a4d7..88b5d35a4a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -87,7 +87,7 @@
   #endif
 #endif
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+#if HAS_FILAMENT_SENSOR
   #include "../../feature/runout.h"
 #endif
 
@@ -383,7 +383,7 @@ namespace ExtUI {
     planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)] = value;
   }
 
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
 

commit 7f1b69b0c83ae914ed9ae35fdad9f79814069652
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Feb 12 16:55:47 2019 -0500

    Add HOST_PROMPT_SUPPORT (#13039)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f2a0464122..18add7a4d7 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -58,9 +58,12 @@
   #include "../../module/tool_change.h"
 #endif
 
+#if ENABLED(EMERGENCY_PARSER)
+  #include "../../feature/emergency_parser.h"
+#endif
+
 #if ENABLED(SDSUPPORT)
   #include "../../sd/cardreader.h"
-  #include "../../feature/emergency_parser.h"
   #define IFSD(A,B) (A)
 #else
   #define IFSD(A,B) (B)

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8048c80852..f2a0464122 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 113af46a1b0d92a069dbc53593d5da215a727d4b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Feb 6 06:16:54 2019 -0700

    Add ExtUI methods to babystep probe/nozzle offsets (#12590)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 721e9f9b50..8048c80852 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -449,49 +449,86 @@ namespace ExtUI {
   void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
   void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
 
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    float getZOffset_mm() {
-      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-        if (active_extruder != 0)
-          return hotend_offset[Z_AXIS][active_extruder];
-        else
-      #endif
-          return zprobe_zoffset;
+  #if ENABLED(BABYSTEPPING)
+    bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
+      switch (axis) {
+        #if ENABLED(BABYSTEP_XY)
+          case X: thermalManager.babystep_axis(X_AXIS, steps); break;
+          case Y: thermalManager.babystep_axis(Y_AXIS, steps); break;
+        #endif
+        case Z: thermalManager.babystep_axis(Z_AXIS, steps); break;
+        default: return false;
+      };
+      return true;
     }
 
-    void setZOffset_mm(const float value) {
-      const float diff = (value - getZOffset_mm()) / planner.steps_to_mm[Z_AXIS];
-      addZOffset_steps(diff > 0 ? CEIL(diff) : FLOOR(diff));
-    }
+    /**
+     * This function adjusts an axis during a print.
+     *
+     * When linked_nozzles is false, each nozzle in a multi-nozzle
+     * printer can be babystepped independently of the others. This
+     * lets the user to fine tune the Z-offset and Nozzle Offsets
+     * while observing the first layer of a print, regardless of
+     * what nozzle is printing.
+     */
+    void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
+      const float mm = steps * planner.steps_to_mm[axis];
+
+      if (!babystepAxis_steps(steps, axis)) return;
+
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        // Make it so babystepping in Z adjusts the Z probe offset.
+        if (axis == Z
+          #if EXTRUDERS > 1
+            && (linked_nozzles || active_extruder == 0)
+          #endif
+        ) zprobe_zoffset += mm;
+      #endif
 
-    void addZOffset_steps(int16_t babystep_increment) {
-      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-        const bool do_probe = (active_extruder == 0);
+      #if EXTRUDERS > 1
+        /**
+         * When linked_nozzles is false, as an axis is babystepped
+         * adjust the hotend offsets so that the other nozzles are
+         * unaffected by the babystepping of the active nozzle.
+         */
+        if (!linked_nozzles) {
+          HOTEND_LOOP()
+            if (e != active_extruder)
+              hotend_offset[axis][e] += mm;
+
+          normalizeNozzleOffset(X);
+          normalizeNozzleOffset(Y);
+          normalizeNozzleOffset(Z);
+        }
       #else
-        constexpr bool do_probe = true;
+        UNUSED(linked_nozzles);
       #endif
-      const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                  new_probe_offset = zprobe_zoffset + diff,
-                  new_offs =
-                    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-                      do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
-                    #else
-                      new_probe_offset
-                    #endif
-                  ;
-      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-
-        thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-
-        if (do_probe) zprobe_zoffset = new_offs;
-        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          else hotend_offset[Z_AXIS][active_extruder] = new_offs;
-        #endif
+    }
+
+    /**
+     * Converts a mm displacement to a number of whole number of
+     * steps that is at least mm long.
+     */
+    int16_t mmToWholeSteps(const float mm, const axis_t axis) {
+      const float steps = mm / planner.steps_to_mm[axis];
+      return steps > 0 ? ceil(steps) : floor(steps);
+    }
+  #endif
+
+  #if HAS_BED_PROBE
+    float getZOffset_mm() {
+      return zprobe_zoffset;
+    }
+
+    void setZOffset_mm(const float value) {
+      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+        zprobe_zoffset = value;
       }
     }
-  #endif // ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #endif // HAS_BED_PROBE
 
   #if HOTENDS > 1
+
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
       return hotend_offset[axis][extruder - E0];
@@ -501,7 +538,18 @@ namespace ExtUI {
       if (extruder - E0 >= HOTENDS) return;
       hotend_offset[axis][extruder - E0] = value;
     }
-  #endif
+
+    /**
+     * The UI should call this if needs to guarantee the first
+     * nozzle offset is zero (such as when it doesn't allow the
+     * user to edit the offset the first nozzle).
+     */
+    void normalizeNozzleOffset(const axis_t axis) {
+      const float offs = hotend_offset[axis][0];
+      HOTEND_LOOP() hotend_offset[axis][e] -= offs;
+    }
+
+  #endif // HOTENDS > 1
 
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash_distance_mm[axis]; }

commit 54fdf57b8c7365ef13be3739ec7ff9218e26db5a
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 22 22:33:11 2019 -0700

    ExtUI: Fix fan wrapping around from 0 to 100 (#12987)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 417adf9e78..721e9f9b50 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -572,7 +572,7 @@ namespace ExtUI {
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     if (fan < FAN_COUNT)
-      thermalManager.set_fan_speed(fan - FAN0, map(value, 0, 100, 0, 255));
+      thermalManager.set_fan_speed(fan - FAN0, map(clamp(value, 0, 100), 0, 100, 0, 255));
   }
 
   void setFeedrate_percent(const float value) {

commit f4c16e683b63f4be505638212455f13cb4215537
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Jan 17 17:48:29 2019 -0700

    Follow up fixes to #12884 (#12940)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 491650c316..417adf9e78 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -71,6 +71,10 @@
   #include "../../module/printcounter.h"
 #endif
 
+#if HAS_TRINAMIC && HAS_LCD_MENU
+  #include "../../feature/tmc_util.h"
+#endif
+
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
@@ -699,7 +703,7 @@ void MarlinUI::init() {
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
 
-  #if HAS_TRINAMIC
+  #if HAS_TRINAMIC && HAS_LCD_MENU
     init_tmc_section();
   #endif
 

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index af2d83535b..491650c316 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -698,6 +698,11 @@ void MarlinUI::init() {
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
+
+  #if HAS_TRINAMIC
+    init_tmc_section();
+  #endif
+
   ExtUI::onStartup();
 }
 

commit eb78aed863cf20cc02f07b8c3e47d27ae4ed91dd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 12 16:01:04 2019 -0600

    Rename LCD menus according to variable types (#12892)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f5a1301266..af2d83535b 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -523,10 +523,10 @@ namespace ExtUI {
   }
 
   #if ENABLED(PRINTCOUNTER)
-    char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,itostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
-    char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,itostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
-    char* getTotalPrintTime_str(char buffer[21]) { duration_t(print_job_timer.getStats().printTime).toString(buffer);     return buffer; }
-    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().printTime).toString(buffer);     return buffer; }
+    char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
+    char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
+    char* getTotalPrintTime_str(char buffer[21]) { duration_t(print_job_timer.getStats().printTime).toString(buffer);       return buffer; }
+    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().printTime).toString(buffer);       return buffer; }
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 75f9464a09..f5a1301266 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -180,7 +180,13 @@ namespace ExtUI {
     return thermalManager.degTargetHotend(extruder - E0);
   }
 
-  float getFan_percent(const fan_t fan) { return ((float(fan_speed[fan - FAN0]) + 1) * 100) / 256; }
+  float getTargetFan_percent(const fan_t fan) {
+    return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
+  }
+
+  float getActualFan_percent(const fan_t fan) {
+    return thermalManager.fanPercent((thermalManager.fan_speed[fan - FAN0] * uint16_t(thermalManager.fan_speed_scaler[fan - FAN0])) >> 7);
+  }
 
   float getAxisPosition_mm(const axis_t axis) {
     return flags.manual_motion ? destination[axis] : current_position[axis];
@@ -560,9 +566,9 @@ namespace ExtUI {
     thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
   }
 
-  void setFan_percent(float value, const fan_t fan) {
+  void setTargetFan_percent(const float value, const fan_t fan) {
     if (fan < FAN_COUNT)
-      fan_speed[fan - FAN0] = clamp(round(value * 255 / 100), 0, 255);
+      thermalManager.set_fan_speed(fan - FAN0, map(value, 0, 100, 0, 255));
   }
 
   void setFeedrate_percent(const float value) {

commit a403d9a50c43f0c6b8aa16156ef7f5adcce99260
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Jan 11 21:42:11 2019 -0500

    Improve menu pause / resume (#12876)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index c0cc7a55a0..75f9464a09 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -578,7 +578,7 @@ namespace ExtUI {
   }
 
   bool isPrintingFromMedia() {
-    return IFSD(card.flag.cardOK && card.isFileOpen(), false);
+    return IFSD(card.isFileOpen(), false);
   }
 
   bool isPrinting() {
@@ -586,7 +586,7 @@ namespace ExtUI {
   }
 
   bool isMediaInserted() {
-    return IFSD(IS_SD_INSERTED() && card.flag.cardOK, false);
+    return IFSD(IS_SD_INSERTED() && card.isDetected(), false);
   }
 
   void pausePrint() {
@@ -703,13 +703,13 @@ void MarlinUI::update() {
       last_sd_status = sd_status;
       if (sd_status) {
         card.initsd();
-        if (card.flag.cardOK)
+        if (card.isDetected())
           ExtUI::onMediaInserted();
         else
           ExtUI::onMediaError();
       }
       else {
-        const bool ok = card.flag.cardOK;
+        const bool ok = card.isDetected();
         card.release();
         if (ok) ExtUI::onMediaRemoved();
       }

commit da42f27c9e6ffe5bf2501c78ad23edf7a82e9f35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 5 20:53:19 2019 -0600

    Use maths macros for ceil/floor

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 0f6b9607c3..c0cc7a55a0 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -451,7 +451,7 @@ namespace ExtUI {
 
     void setZOffset_mm(const float value) {
       const float diff = (value - getZOffset_mm()) / planner.steps_to_mm[Z_AXIS];
-      addZOffset_steps(diff > 0 ? ceil(diff) : floor(diff));
+      addZOffset_steps(diff > 0 ? CEIL(diff) : FLOOR(diff));
     }
 
     void addZOffset_steps(int16_t babystep_increment) {

commit 81e753064ac81292a4fc47ac5fa3f17686bdff7e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Jan 3 07:36:43 2019 -0700

    Fix ExtUI compile warnings and error (#12799)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 2c756cdb39..0f6b9607c3 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -635,14 +635,14 @@ namespace ExtUI {
       pos;
 
       card.getfilename_sorted(nr);
-      return card.filename && card.filename[0] != '\0';
+      return card.filename[0] != '\0';
     #else
       return false;
     #endif
   }
 
   const char* FileList::filename() {
-    return IFSD(card.longFilename && card.longFilename[0] ? card.longFilename : card.filename, "");
+    return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");
   }
 
   const char* FileList::shortFilename() {

commit 60cb36bef3644640f2eb1c9d2b30189e41e81ef2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 1 14:17:48 2019 -0700

    Misc. improvements (#12747)
    
    * Make ExtUI respect MAXTEMP limits
      - Temperatures are now clamped by MAXTEMP limits rather than arbitrary values.
    * Speed up USB init, add status
      - Speed up USB initialization
      - Show status message if init failed
    * Enable status messages for EXTENSIBLE_UI
    * Adjust max limit to MAX_TEMP - 15
    * Misc. tweaks to formatting, const, etc.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index a9dabaa0ac..2c756cdb39 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -544,16 +544,20 @@ namespace ExtUI {
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
+    constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+    const int16_t e = heater - H0;
     #if HAS_HEATED_BED
       if (heater == BED)
-        thermalManager.setTargetBed(clamp(value,0,200));
+        thermalManager.setTargetBed(clamp(value, 0, BED_MAXTEMP - 15));
       else
     #endif
-        thermalManager.setTargetHotend(clamp(value,0,500), heater - H0);
+        thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
-    thermalManager.setTargetHotend(clamp(value,0,500), extruder - E0);
+    constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+    const int16_t e = extruder - E0;
+    thermalManager.setTargetHotend(clamp(value, 0, heater_maxtemp[e] - 15), e);
   }
 
   void setFan_percent(float value, const fan_t fan) {

commit 50ee747787d395b8d0312a0b43369a160c02e8fc
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Nov 19 23:02:13 2018 -0700

    Fix compilation errors. Followup to #12439 (#12481)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 401ae38d94..a9dabaa0ac 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -134,7 +134,6 @@ namespace ExtUI {
       // The ms count is
       return (uint32_t)(currTime / (F_CPU / 8000));
     }
-
   #endif // __SAM3X8E__
 
   void delay_us(unsigned long us) {

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 390b081174..401ae38d94 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -94,6 +94,7 @@ static struct {
 } flags;
 
 namespace ExtUI {
+
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
@@ -134,12 +135,7 @@ namespace ExtUI {
       return (uint32_t)(currTime / (F_CPU / 8000));
     }
 
-  #else
-
-    // TODO: Implement for AVR
-    FORCE_INLINE uint32_t safe_millis() { return millis(); }
-
-  #endif
+  #endif // __SAM3X8E__
 
   void delay_us(unsigned long us) {
     DELAY_US(us);
@@ -287,12 +283,14 @@ namespace ExtUI {
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
-    const uint8_t e = extruder - E0;
-    #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
-      if (e != active_extruder)
-        tool_change(e, 0, no_move);
+    #if EXTRUDERS > 1
+      const uint8_t e = extruder - E0;
+      #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+        if (e != active_extruder)
+          tool_change(e, 0, no_move);
+      #endif
+      active_extruder = e;
     #endif
-    active_extruder = e;
   }
 
   extruder_t getActiveTool() {
@@ -533,24 +531,26 @@ namespace ExtUI {
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
-  void enqueueCommands(progmem_str gcode) {
-    enqueue_and_echo_commands_P((PGM_P)gcode);
+  void enqueueCommands_P(PGM_P const gcode) {
+    enqueue_and_echo_commands_P(gcode);
   }
 
   bool isAxisPositionKnown(const axis_t axis) {
     return TEST(axis_known_position, axis);
   }
 
-  progmem_str getFirmwareName_str() {
-    return F("Marlin " SHORT_BUILD_VERSION);
+  PGM_P getFirmwareName_str() {
+    static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
+    return firmware_name;
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
     #if HAS_HEATED_BED
-    if (heater == BED)
-      thermalManager.setTargetBed(clamp(value,0,200));
+      if (heater == BED)
+        thermalManager.setTargetBed(clamp(value,0,200));
+      else
     #endif
-      thermalManager.setTargetHotend(clamp(value,0,500), heater - H0);
+        thermalManager.setTargetHotend(clamp(value,0,500), heater - H0);
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
@@ -579,7 +579,7 @@ namespace ExtUI {
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || IS_SD_PRINTING() || isPrintingFromMedia());
+    return (planner.movesplanned() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
   }
 
   bool isMediaInserted() {
@@ -593,19 +593,20 @@ namespace ExtUI {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M125"));
       #endif
-      ExtUI::onStatusChanged(PSTR(MSG_PRINT_PAUSED));
+      ui.set_status_P(PSTR(MSG_PRINT_PAUSED));
     #endif
   }
 
   void resumePrint() {
     #if ENABLED(SDSUPPORT)
+      ui.set_status_P(PSTR(MSG_FILAMENT_CHANGE_RESUME_1));
       #if ENABLED(PARK_HEAD_ON_PAUSE)
+        wait_for_heatup = wait_for_user = false;
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
-      ExtUI::onStatusChanged(PSTR(MSG_PRINTING));
     #endif
   }
 
@@ -613,7 +614,7 @@ namespace ExtUI {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
-      ExtUI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
+      ui.set_status_P(PSTR(MSG_PRINT_ABORTED));
     #endif
   }
 
@@ -621,7 +622,7 @@ namespace ExtUI {
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
-  bool FileList::seek(uint16_t pos, bool skip_range_check) {
+  bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && pos > (count() - 1)) return false;
       const uint16_t nr =
@@ -632,6 +633,8 @@ namespace ExtUI {
 
       card.getfilename_sorted(nr);
       return card.filename && card.filename[0] != '\0';
+    #else
+      return false;
     #endif
   }
 
@@ -671,7 +674,7 @@ namespace ExtUI {
     #endif
   }
 
-  void FileList::changeDir(const char *dirname) {
+  void FileList::changeDir(const char * const dirname) {
     #if ENABLED(SDSUPPORT)
       card.chdir(dirname);
       num_files = 0xFFFF;
@@ -713,20 +716,6 @@ void MarlinUI::update() {
   ExtUI::onIdle();
 }
 
-void MarlinUI::setstatus(const char * const message, const bool persist/*=false*/)  { ExtUI::onStatusChanged(message); }
-void MarlinUI::setstatusPGM(PGM_P const message, int8_t level/*=0*/)                { ExtUI::onStatusChanged((progmem_str)message); }
-void MarlinUI::setalertstatusPGM(PGM_P const message)                               { setstatusPGM(message, 0); }
-
-void MarlinUI::status_printf_P(const uint8_t level, const char * const fmt, ...) {
-  char buff[64];
-  va_list args;
-  va_start(args, fmt);
-  vsnprintf_P(buff, sizeof(buff), fmt, args);
-  va_end(args);
-  buff[63] = '\0';
-  ExtUI::onStatusChanged(buff);
-}
-
 void MarlinUI::kill_screen(PGM_P const msg) {
   if (!flags.printer_killed) {
     flags.printer_killed = true;

commit 66580f32c2f4d39a82b77e4b6982e7ea6dde0766
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 22:39:16 2018 -0600

    Make CardReader class static (#12451)
    
    * Make CardReader a static class
    * Make CardReader flags into bitfields

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 932a276af4..390b081174 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -575,7 +575,7 @@ namespace ExtUI {
   }
 
   bool isPrintingFromMedia() {
-    return IFSD(card.cardOK && card.isFileOpen(), false);
+    return IFSD(card.flag.cardOK && card.isFileOpen(), false);
   }
 
   bool isPrinting() {
@@ -583,7 +583,7 @@ namespace ExtUI {
   }
 
   bool isMediaInserted() {
-    return IFSD(IS_SD_INSERTED() && card.cardOK, false);
+    return IFSD(IS_SD_INSERTED() && card.flag.cardOK, false);
   }
 
   void pausePrint() {
@@ -612,7 +612,7 @@ namespace ExtUI {
   void stopPrint() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
-      card.abort_sd_printing = true;
+      card.flag.abort_sd_printing = true;
       ExtUI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
     #endif
   }
@@ -648,7 +648,7 @@ namespace ExtUI {
   }
 
   bool FileList::isDir() {
-    return IFSD(card.filenameIsDir, false);
+    return IFSD(card.flag.filenameIsDir, false);
   }
 
   uint16_t FileList::count() {
@@ -697,13 +697,13 @@ void MarlinUI::update() {
       last_sd_status = sd_status;
       if (sd_status) {
         card.initsd();
-        if (card.cardOK)
+        if (card.flag.cardOK)
           ExtUI::onMediaInserted();
         else
           ExtUI::onMediaError();
       }
       else {
-        const bool ok = card.cardOK;
+        const bool ok = card.flag.cardOK;
         card.release();
         if (ok) ExtUI::onMediaRemoved();
       }

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8d045a2a71..932a276af4 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -93,7 +93,7 @@ static struct {
   uint8_t manual_motion : 1;
 } flags;
 
-namespace UI {
+namespace ExtUI {
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
@@ -593,7 +593,7 @@ namespace UI {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M125"));
       #endif
-      UI::onStatusChanged(PSTR(MSG_PRINT_PAUSED));
+      ExtUI::onStatusChanged(PSTR(MSG_PRINT_PAUSED));
     #endif
   }
 
@@ -605,7 +605,7 @@ namespace UI {
         card.startFileprint();
         print_job_timer.start();
       #endif
-      UI::onStatusChanged(PSTR(MSG_PRINTING));
+      ExtUI::onStatusChanged(PSTR(MSG_PRINTING));
     #endif
   }
 
@@ -613,7 +613,7 @@ namespace UI {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.abort_sd_printing = true;
-      UI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
+      ExtUI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
     #endif
   }
 
@@ -678,7 +678,7 @@ namespace UI {
     #endif
   }
 
-} // namespace UI
+} // namespace ExtUI
 
 // At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
 
@@ -686,7 +686,7 @@ void MarlinUI::init() {
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
-  UI::onStartup();
+  ExtUI::onStartup();
 }
 
 void MarlinUI::update() {
@@ -698,23 +698,23 @@ void MarlinUI::update() {
       if (sd_status) {
         card.initsd();
         if (card.cardOK)
-          UI::onMediaInserted();
+          ExtUI::onMediaInserted();
         else
-          UI::onMediaError();
+          ExtUI::onMediaError();
       }
       else {
         const bool ok = card.cardOK;
         card.release();
-        if (ok) UI::onMediaRemoved();
+        if (ok) ExtUI::onMediaRemoved();
       }
     }
   #endif // SDSUPPORT
-  UI::_processManualMoveToDestination();
-  UI::onIdle();
+  ExtUI::_processManualMoveToDestination();
+  ExtUI::onIdle();
 }
 
-void MarlinUI::setstatus(const char * const message, const bool persist/*=false*/)  { UI::onStatusChanged(message); }
-void MarlinUI::setstatusPGM(PGM_P const message, int8_t level/*=0*/)                { UI::onStatusChanged((progmem_str)message); }
+void MarlinUI::setstatus(const char * const message, const bool persist/*=false*/)  { ExtUI::onStatusChanged(message); }
+void MarlinUI::setstatusPGM(PGM_P const message, int8_t level/*=0*/)                { ExtUI::onStatusChanged((progmem_str)message); }
 void MarlinUI::setalertstatusPGM(PGM_P const message)                               { setstatusPGM(message, 0); }
 
 void MarlinUI::status_printf_P(const uint8_t level, const char * const fmt, ...) {
@@ -724,13 +724,13 @@ void MarlinUI::status_printf_P(const uint8_t level, const char * const fmt, ...)
   vsnprintf_P(buff, sizeof(buff), fmt, args);
   va_end(args);
   buff[63] = '\0';
-  UI::onStatusChanged(buff);
+  ExtUI::onStatusChanged(buff);
 }
 
 void MarlinUI::kill_screen(PGM_P const msg) {
   if (!flags.printer_killed) {
     flags.printer_killed = true;
-    UI::onPrinterKilled(msg);
+    ExtUI::onPrinterKilled(msg);
   }
 }
 

commit 0ee1a92971bba0fe5ed290e2562bca71cfb5ea46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 13 01:47:45 2018 -0600

    Group status methods, share reset_status with Extensible UI (#12414)
    
    * Group status methods, share reset_status with Extensible UI
    * Move common DOGM code to headers

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 343910e13b..8d045a2a71 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -45,6 +45,7 @@
 
 #if ENABLED(EXTENSIBLE_UI)
 
+#include "../ultralcd.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
@@ -712,32 +713,9 @@ void MarlinUI::update() {
   UI::onIdle();
 }
 
-bool MarlinUI::hasstatus() { return true; }
-bool MarlinUI::detected() { return true; }
-void MarlinUI::reset_alert_level() { }
-void MarlinUI::refresh() { }
-void MarlinUI::setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
-void MarlinUI::setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
-void MarlinUI::setalertstatusPGM(const char * const message)                    { setstatusPGM(message, 0); }
-
-void MarlinUI::reset_status() {
-  static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
-  static const char printing[] PROGMEM = MSG_PRINTING;
-  static const char welcome[] PROGMEM = WELCOME_MSG;
-  PGM_P msg;
-  if (print_job_timer.isPaused())
-    msg = paused;
-  #if ENABLED(SDSUPPORT)
-    else if (IS_SD_PRINTING())
-      return setstatus(card.longest_filename(), true);
-  #endif
-  else if (print_job_timer.isRunning())
-    msg = printing;
-  else
-    msg = welcome;
-
-  setstatusPGM(msg, -1);
-}
+void MarlinUI::setstatus(const char * const message, const bool persist/*=false*/)  { UI::onStatusChanged(message); }
+void MarlinUI::setstatusPGM(PGM_P const message, int8_t level/*=0*/)                { UI::onStatusChanged((progmem_str)message); }
+void MarlinUI::setalertstatusPGM(PGM_P const message)                               { setstatusPGM(message, 0); }
 
 void MarlinUI::status_printf_P(const uint8_t level, const char * const fmt, ...) {
   char buff[64];

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 8d329642c0..343910e13b 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -681,14 +681,14 @@ namespace UI {
 
 // At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
 
-void lcd_init() {
+void MarlinUI::init() {
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
   UI::onStartup();
 }
 
-void lcd_update() {
+void MarlinUI::update() {
   #if ENABLED(SDSUPPORT)
     static bool last_sd_status;
     const bool sd_status = IS_SD_INSERTED();
@@ -712,15 +712,15 @@ void lcd_update() {
   UI::onIdle();
 }
 
-bool lcd_hasstatus() { return true; }
-bool lcd_detected() { return true; }
-void lcd_reset_alert_level() { }
-void lcd_refresh() { }
-void lcd_setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
-void lcd_setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
-void lcd_setalertstatusPGM(const char * const message)                           { lcd_setstatusPGM(message, 0); }
+bool MarlinUI::hasstatus() { return true; }
+bool MarlinUI::detected() { return true; }
+void MarlinUI::reset_alert_level() { }
+void MarlinUI::refresh() { }
+void MarlinUI::setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
+void MarlinUI::setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
+void MarlinUI::setalertstatusPGM(const char * const message)                    { setstatusPGM(message, 0); }
 
-void lcd_reset_status() {
+void MarlinUI::reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
@@ -729,17 +729,17 @@ void lcd_reset_status() {
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (IS_SD_PRINTING())
-      return lcd_setstatus(card.longest_filename(), true);
+      return setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
-  lcd_setstatusPGM(msg, -1);
+  setstatusPGM(msg, -1);
 }
 
-void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
+void MarlinUI::status_printf_P(const uint8_t level, const char * const fmt, ...) {
   char buff[64];
   va_list args;
   va_start(args, fmt);
@@ -749,7 +749,7 @@ void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   UI::onStatusChanged(buff);
 }
 
-void kill_screen(PGM_P msg) {
+void MarlinUI::kill_screen(PGM_P const msg) {
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     UI::onPrinterKilled(msg);

commit 488a17b3f5224ccd50f0cbc916a1e7c7ccf1ad6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 20:52:39 2018 -0600

    Use IS_SD_PRINTING() more

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index a93b226faf..8d329642c0 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -570,7 +570,7 @@ namespace UI {
   }
 
   bool isPrintingFromMediaPaused() {
-    return IFSD(isPrintingFromMedia() && !card.sdprinting, false);
+    return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
   }
 
   bool isPrintingFromMedia() {
@@ -728,7 +728,7 @@ void lcd_reset_status() {
   if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
-    else if (card.sdprinting)
+    else if (IS_SD_PRINTING())
       return lcd_setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 6250d9312a..a93b226faf 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -200,7 +200,7 @@ namespace UI {
           max = current_position[axis] + 1000;
 
     // Limit to software endstops, if enabled
-    #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
+    #if HAS_SOFTWARE_ENDSTOPS
       if (soft_endstops_enabled) switch (axis) {
         case X_AXIS:
           #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
@@ -227,7 +227,7 @@ namespace UI {
           #endif
         default: break;
       }
-    #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
+    #endif // HAS_SOFTWARE_ENDSTOPS
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0

commit 44f2a82a567333312c3d85f72176f437bafc9625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:07:52 2018 -0500

    Move axis_homed, axis_known_position to motion.*

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index af2750cec8..6250d9312a 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -41,7 +41,7 @@
  *   location: <http://www.gnu.org/licenses/>.                              *
  ****************************************************************************/
 
-#include "../../Marlin.h"
+#include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(EXTENSIBLE_UI)
 
@@ -109,7 +109,7 @@ namespace UI {
       // Machine was killed, reinit SysTick so we are able to compute time without ISRs
       if (currTimeHI == 0) {
         // Get the last time the Arduino time computed (from CMSIS) and convert it to SysTick
-        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU/8000)) >> 24);
+        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU / 8000)) >> 24);
 
         // Reinit the SysTick timer to maximize its period
         SysTick->LOAD  = SysTick_LOAD_RELOAD_Msk;                    // get the full range for the systick timer
@@ -136,7 +136,7 @@ namespace UI {
   #else
 
     // TODO: Implement for AVR
-    uint32_t safe_millis() { return millis(); }
+    FORCE_INLINE uint32_t safe_millis() { return millis(); }
 
   #endif
 
@@ -399,6 +399,7 @@ namespace UI {
   #endif
 
   #if ENABLED(JUNCTION_DEVIATION)
+
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
@@ -407,13 +408,15 @@ namespace UI {
       planner.junction_deviation_mm = clamp(value, 0.01, 0.3);
       planner.recalculate_max_e_jerk();
     }
+
   #else
+
     float getAxisMaxJerk_mm_s(const axis_t axis) {
-        return planner.max_jerk[axis];
+      return planner.max_jerk[axis];
     }
 
     float getAxisMaxJerk_mm_s(const extruder_t extruder) {
-        return planner.max_jerk[E_AXIS];
+      return planner.max_jerk[E_AXIS];
     }
 
     void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {

commit 72d8adfd1e5cadafcaf0500315d47954d9d273d7
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 30 18:42:26 2018 -0600

    Cleanup and refactor EXTENSIBLE_UI (#12227)
    
    - Add `axis_t`, `extruder_t`, `heater_t`, and `fan_t` to eliminate ambiguity, improve type safety.
    - Regularized getter/setter argument order and naming.
    - `setAxisPosition` no longer stacks moves in the buffer, allowing it to be called repeatedly on each touch ui tap.
    - Implement better manual moves for `EXTENSIBLE_UI` (#12205)
    - Calling `setAxisPosition_mm` no longer buffers the entire move to the new position, but instead causes small moves towards it to be made during the idle loop. This allows the user to adjust the destination even after the move has started and makes the UI feel much more responsive.
    - As suggested by @ejtagle, the new code keeps the planner buffer full to ensure smooth motion without stops and starts.
    - Change `En`, `Hn` and `FANn` to zero-based indices.
    - Labels consistent with the rest of Marlin code.

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f9963076a3..af2750cec8 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -68,9 +68,6 @@
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
   #include "../../module/printcounter.h"
-  #define IFPC(A,B) (A)
-#else
-  #define IFPC(A,B) (B)
 #endif
 
 #include "ui_api.h"
@@ -90,7 +87,10 @@ inline float clamp(const float value, const float minimum, const float maximum)
   return MAX(MIN(value, maximum), minimum);
 }
 
-static bool printer_killed = false;
+static struct {
+  uint8_t printer_killed  : 1;
+  uint8_t manual_motion : 1;
+} flags;
 
 namespace UI {
   #ifdef __SAM3X8E__
@@ -102,7 +102,7 @@ namespace UI {
      */
     uint32_t safe_millis() {
       // Not killed? Just call millis()
-      if (!printer_killed) return millis();
+      if (!flags.printer_killed) return millis();
 
       static uint32_t currTimeHI = 0; /* Current time */
 
@@ -145,186 +145,256 @@ namespace UI {
   }
 
   void delay_ms(unsigned long ms) {
-    if (printer_killed)
+    if (flags.printer_killed)
       DELAY_US(ms * 1000);
     else
       safe_delay(ms);
   }
 
   void yield() {
-    if (!printer_killed)
+    if (!flags.printer_killed)
       thermalManager.manage_heater();
   }
 
-  float getActualTemp_celsius(const uint8_t extruder) {
-    return extruder ?
-      thermalManager.degHotend(extruder - 1) :
+  float getActualTemp_celsius(const heater_t heater) {
+    return heater == BED ?
       #if HAS_HEATED_BED
         thermalManager.degBed()
       #else
         0
       #endif
-    ;
+      : thermalManager.degHotend(heater - H0);
+  }
+
+  float getActualTemp_celsius(const extruder_t extruder) {
+    return thermalManager.degHotend(extruder - E0);
   }
 
-  float getTargetTemp_celsius(const uint8_t extruder) {
-    return extruder ?
-      thermalManager.degTargetHotend(extruder - 1) :
+  float getTargetTemp_celsius(const heater_t heater) {
+    return heater == BED ?
       #if HAS_HEATED_BED
         thermalManager.degTargetBed()
       #else
         0
       #endif
-    ;
+      : thermalManager.degTargetHotend(heater - H0);
+  }
+
+  float getTargetTemp_celsius(const extruder_t extruder) {
+    return thermalManager.degTargetHotend(extruder - E0);
   }
 
-  float getFan_percent(const uint8_t fan) { return ((float(fan_speed[fan]) + 1) * 100) / 256; }
+  float getFan_percent(const fan_t fan) { return ((float(fan_speed[fan - FAN0]) + 1) * 100) / 256; }
 
   float getAxisPosition_mm(const axis_t axis) {
-    switch (axis) {
-      case X: case Y: case Z:
-        return current_position[axis];
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        return current_position[E_AXIS];
-      default: return 0;
-    }
+    return flags.manual_motion ? destination[axis] : current_position[axis];
   }
 
-  void setAxisPosition_mm(const axis_t axis, float position, float _feedrate_mm_s) {
-    #if EXTRUDERS > 1
-      const int8_t old_extruder = active_extruder;
-    #endif
-    switch (axis) {
-      case X: case Y: case Z: break;
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        #if EXTRUDERS > 1
-          active_extruder = axis - E0;
-        #endif
-        break;
-      default: return;
-    }
-    set_destination_from_current();
-    switch (axis) {
-      case X: case Y: case Z:
-        destination[axis] = position;
-        break;
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        destination[E_AXIS] = position;
-        break;
-    }
+  float getAxisPosition_mm(const extruder_t extruder) {
+    return flags.manual_motion ? destination[E_AXIS] : current_position[E_AXIS];
+  }
+
+  void setAxisPosition_mm(const float position, const axis_t axis) {
+    // Start with no limits to movement
+    float min = current_position[axis] - 1000,
+          max = current_position[axis] + 1000;
 
-    const float old_feedrate = feedrate_mm_s;
-    feedrate_mm_s = _feedrate_mm_s;
-    prepare_move_to_destination();
-    feedrate_mm_s = old_feedrate;
-    #if EXTRUDERS > 1
-      active_extruder = old_extruder;
+    // Limit to software endstops, if enabled
+    #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
+      if (soft_endstops_enabled) switch (axis) {
+        case X_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+            min = soft_endstop_min[X_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+            max = soft_endstop_max[X_AXIS];
+          #endif
+          break;
+        case Y_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+            min = soft_endstop_min[Y_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+            max = soft_endstop_max[Y_AXIS];
+          #endif
+          break;
+        case Z_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+            min = soft_endstop_min[Z_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+            max = soft_endstop_max[Z_AXIS];
+          #endif
+        default: break;
+      }
+    #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS) {
+        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
     #endif
+
+    if (!flags.manual_motion)
+      set_destination_from_current();
+    destination[axis] = clamp(position, min, max);
+    flags.manual_motion = true;
+  }
+
+  void setAxisPosition_mm(const float position, const extruder_t extruder) {
+    setActiveTool(extruder, true);
+
+    if (!flags.manual_motion)
+      set_destination_from_current();
+    destination[E_AXIS] = position;
+    flags.manual_motion = true;
+  }
+
+  void _processManualMoveToDestination() {
+    // Lower max_response_lag makes controls more responsive, but makes CPU work harder
+    constexpr float   max_response_lag = 0.1; // seconds
+    constexpr uint8_t segments_to_buffer = 4; // keep planner filled with this many segments
+
+    if (flags.manual_motion && planner.movesplanned() < segments_to_buffer) {
+      float saved_destination[XYZ];
+      COPY(saved_destination, destination);
+      // Compute direction vector from current_position towards destination.
+      destination[X_AXIS] -= current_position[X_AXIS];
+      destination[Y_AXIS] -= current_position[Y_AXIS];
+      destination[Z_AXIS] -= current_position[Z_AXIS];
+      const float inv_length = RSQRT(sq(destination[X_AXIS]) + sq(destination[Y_AXIS]) + sq(destination[Z_AXIS]));
+      // Find move segment length so that all segments can execute in less time than max_response_lag
+      const float scale = inv_length * feedrate_mm_s * max_response_lag / segments_to_buffer;
+      if (scale < 1) {
+        // Move a small bit towards the destination.
+        destination[X_AXIS] = scale * destination[X_AXIS] + current_position[X_AXIS];
+        destination[Y_AXIS] = scale * destination[Y_AXIS] + current_position[Y_AXIS];
+        destination[Z_AXIS] = scale * destination[Z_AXIS] + current_position[Z_AXIS];
+        prepare_move_to_destination();
+        COPY(destination, saved_destination);
+      }
+      else {
+        // We are close enough to finish off the move.
+        COPY(destination, saved_destination);
+        prepare_move_to_destination();
+        flags.manual_motion = false;
+      }
+    }
   }
 
-  void setActiveTool(uint8_t extruder, bool no_move) {
-    extruder--; // Make zero based
+  void setActiveTool(const extruder_t extruder, bool no_move) {
+    const uint8_t e = extruder - E0;
     #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
-      if (extruder != active_extruder)
-        tool_change(extruder, 0, no_move);
-    #endif
-    #if EXTRUDERS > 1
-      active_extruder = extruder;
+      if (e != active_extruder)
+        tool_change(e, 0, no_move);
     #endif
+    active_extruder = e;
   }
 
-  uint8_t getActiveTool() { return active_extruder + 1; }
+  extruder_t getActiveTool() {
+    switch (active_extruder) {
+      case 5:  return E5;
+      case 4:  return E4;
+      case 3:  return E3;
+      case 2:  return E2;
+      case 1:  return E1;
+      default: return E0;
+    }
+  }
 
   bool isMoving() { return planner.has_blocks_queued(); }
 
-  float getAxisSteps_per_mm(const axis_t axis) {
+  bool canMove(const axis_t axis) {
     switch (axis) {
-      case X: case Y: case Z:
-        return planner.settings.axis_steps_per_mm[axis];
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)];
-      default: return 0;
+      #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
+        case X: return TEST(axis_homed, X_AXIS);
+        case Y: return TEST(axis_homed, Y_AXIS);
+        case Z: return TEST(axis_homed, Z_AXIS);
+      #else
+        case X: case Y: case Z: return true;
+      #endif
+      default: return false;
     }
   }
 
-  void setAxisSteps_per_mm(const axis_t axis, const float steps_per_mm) {
-    switch (axis) {
-      case X: case Y: case Z:
-        planner.settings.axis_steps_per_mm[axis] = steps_per_mm;
-        break;
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = steps_per_mm;
-        break;
-    }
+  bool canMove(const extruder_t extruder) {
+    return !thermalManager.tooColdToExtrude(extruder - E0);
+  }
+
+  float getAxisSteps_per_mm(const axis_t axis) {
+    return planner.settings.axis_steps_per_mm[axis];
+  }
+
+  float getAxisSteps_per_mm(const extruder_t extruder) {
+    return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
+  }
+
+  void setAxisSteps_per_mm(const float value, const axis_t axis) {
+    planner.settings.axis_steps_per_mm[axis] = value;
+  }
+
+  void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
+    planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
   }
 
   float getAxisMaxFeedrate_mm_s(const axis_t axis) {
-    switch (axis) {
-      case X: case Y: case Z:
-        return planner.settings.max_feedrate_mm_s[axis];
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
-      default: return 0;
-    }
+    return planner.settings.max_feedrate_mm_s[axis];
   }
 
-  void setAxisMaxFeedrate_mm_s(const axis_t axis, const float max_feedrate_mm_s) {
-    switch (axis) {
-      case X: case Y: case Z:
-        planner.settings.max_feedrate_mm_s[axis] = max_feedrate_mm_s;
-        break;
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = max_feedrate_mm_s;
-        break;
-      default: return;
-    }
+  float getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
+    return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
+  }
+
+  void setAxisMaxFeedrate_mm_s(const float value, const axis_t axis) {
+    planner.settings.max_feedrate_mm_s[axis] = value;
+  }
+
+  void setAxisMaxFeedrate_mm_s(const float value, const extruder_t extruder) {
+    planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = value;
   }
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
-    switch (axis) {
-      case X: case Y: case Z:
-        return planner.settings.max_acceleration_mm_per_s2[axis];
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)];
-      default: return 0;
-    }
+    return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
-  void setAxisMaxAcceleration_mm_s2(const axis_t axis, const float max_acceleration_mm_per_s2) {
-    switch (axis) {
-      case X: case Y: case Z:
-        planner.settings.max_acceleration_mm_per_s2[axis] = max_acceleration_mm_per_s2;
-        break;
-      case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)] = max_acceleration_mm_per_s2;
-        break;
-      default: return;
-    }
+  float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
+    return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
+  }
+
+  void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
+    planner.settings.max_acceleration_mm_per_s2[axis] = value;
+  }
+
+  void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
+    planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)] = value;
   }
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    bool isFilamentRunoutEnabled()              { return runout.enabled; }
-    void toggleFilamentRunout(const bool state) { runout.enabled = state; }
+    bool getFilamentRunoutEnabled()                 { return runout.enabled; }
+    void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
 
     #if FILAMENT_RUNOUT_DISTANCE_MM > 0
       float getFilamentRunoutDistance_mm() {
         return RunoutResponseDelayed::runout_distance_mm;
       }
 
-      void setFilamentRunoutDistance_mm(const float distance) {
-        RunoutResponseDelayed::runout_distance_mm = clamp(distance, 0, 999);
+      void setFilamentRunoutDistance_mm(const float value) {
+        RunoutResponseDelayed::runout_distance_mm = clamp(value, 0, 999);
       }
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
-    float getLinearAdvance_mm_mm_s(const uint8_t extruder) {
-      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder] : 0;
+    float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
+      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
-    void setLinearAdvance_mm_mm_s(const uint8_t extruder, const float k) {
+    void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
-        planner.extruder_advance_K[extruder] = clamp(k, 0, 999);
+        planner.extruder_advance_K[extruder - E0] = clamp(value, 0, 999);
     }
   #endif
 
@@ -333,39 +403,35 @@ namespace UI {
       return planner.junction_deviation_mm;
     }
 
-    void setJunctionDeviation_mm(const float junc_dev) {
-      planner.junction_deviation_mm = clamp(junc_dev, 0.01, 0.3);
+    void setJunctionDeviation_mm(const float value) {
+      planner.junction_deviation_mm = clamp(value, 0.01, 0.3);
       planner.recalculate_max_e_jerk();
     }
   #else
     float getAxisMaxJerk_mm_s(const axis_t axis) {
-      switch (axis) {
-        case X: case Y: case Z:
-          return planner.max_jerk[axis];
-        case E0: case E1: case E2: case E3: case E4: case E5:
-          return planner.max_jerk[E_AXIS];
-        default: return 0;
-      }
+        return planner.max_jerk[axis];
     }
 
-    void setAxisMaxJerk_mm_s(const axis_t axis, const float max_jerk) {
-      switch (axis) {
-        case X: case Y: case Z:
-          planner.max_jerk[axis] = max_jerk;
-          break;
-        case E0: case E1: case E2: case E3: case E4: case E5:
-          planner.max_jerk[E_AXIS] = max_jerk;
-          break;
-        default: return;
-      }
+    float getAxisMaxJerk_mm_s(const extruder_t extruder) {
+        return planner.max_jerk[E_AXIS];
+    }
+
+    void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
+      planner.max_jerk[axis] = value;
+    }
+
+    void setAxisMaxJerk_mm_s(const float value, const extruder_t extruder) {
+      planner.max_jerk[E_AXIS] = value;
     }
   #endif
 
+  float getFeedrate_mm_s()                            { return feedrate_mm_s; }
   float getMinFeedrate_mm_s()                         { return planner.settings.min_feedrate_mm_s; }
   float getMinTravelFeedrate_mm_s()                   { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
+  void setFeedrate_mm_s(const float fr)               { feedrate_mm_s = fr; }
   void setMinFeedrate_mm_s(const float fr)            { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const float fr)      { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
@@ -382,12 +448,12 @@ namespace UI {
           return zprobe_zoffset;
     }
 
-    void setZOffset_mm(const float zoffset_mm) {
-      const float diff = (zoffset_mm - getZOffset_mm()) / planner.steps_to_mm[Z_AXIS];
-      incrementZOffset_steps(diff > 0 ? ceil(diff) : floor(diff));
+    void setZOffset_mm(const float value) {
+      const float diff = (value - getZOffset_mm()) / planner.steps_to_mm[Z_AXIS];
+      addZOffset_steps(diff > 0 ? ceil(diff) : floor(diff));
     }
 
-    void incrementZOffset_steps(int16_t babystep_increment) {
+    void addZOffset_steps(int16_t babystep_increment) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         const bool do_probe = (active_extruder == 0);
       #else
@@ -415,28 +481,28 @@ namespace UI {
   #endif // ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
   #if HOTENDS > 1
-    float getNozzleOffset_mm(const axis_t axis, uint8_t extruder) {
-      if (extruder >= HOTENDS) return 0;
-      return hotend_offset[axis][extruder];
+    float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
+      if (extruder - E0 >= HOTENDS) return 0;
+      return hotend_offset[axis][extruder - E0];
     }
 
-    void setNozzleOffset_mm(const axis_t axis, uint8_t extruder, float offset) {
-      if (extruder >= HOTENDS) return;
-      hotend_offset[axis][extruder] = offset;
+    void setNozzleOffset_mm(const float value, const axis_t axis, const extruder_t extruder) {
+      if (extruder - E0 >= HOTENDS) return;
+      hotend_offset[axis][extruder - E0] = value;
     }
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
-    float getAxisBacklash_mm(const axis_t axis)       {return backlash_distance_mm[axis];}
-    void setAxisBacklash_mm(const axis_t axis, float distance)
-                                                      {backlash_distance_mm[axis] = clamp(distance,0,5);}
+    float getAxisBacklash_mm(const axis_t axis)       { return backlash_distance_mm[axis]; }
+    void setAxisBacklash_mm(const float value, const axis_t axis)
+                                                      { backlash_distance_mm[axis] = clamp(value,0,5); }
 
-    float getBacklashCorrection_percent()             {return backlash_correction*100;}
-    void setBacklashCorrection_percent(float percent) {backlash_correction = clamp(percent, 0, 100)/100;}
+    float getBacklashCorrection_percent()             { return backlash_correction * 100; }
+    void setBacklashCorrection_percent(const float value) { backlash_correction = clamp(value, 0, 100) / 100.0f; }
 
     #ifdef BACKLASH_SMOOTHING_MM
-      float getBacklashSmoothing_mm()                 {return backlash_smoothing_mm;}
-      void setBacklashSmoothing_mm(float distance)    {backlash_smoothing_mm = clamp(distance,0,999);}
+      float getBacklashSmoothing_mm()                 { return backlash_smoothing_mm; }
+      void setBacklashSmoothing_mm(const float value) { backlash_smoothing_mm = clamp(value, 0, 999); }
     #endif
   #endif
 
@@ -445,7 +511,8 @@ namespace UI {
   }
 
   uint32_t getProgress_seconds_elapsed() {
-    return IFPC(print_job_timer.duration() / 1000UL, 0);
+    const duration_t elapsed = print_job_timer.duration();
+    return elapsed.value;
   }
 
   #if ENABLED(PRINTCOUNTER)
@@ -460,46 +527,43 @@ namespace UI {
     }
   #endif
 
-  float getFeedRate_percent() {
-    return feedrate_percentage;
-  }
+  float getFeedrate_percent() { return feedrate_percentage; }
 
   void enqueueCommands(progmem_str gcode) {
     enqueue_and_echo_commands_P((PGM_P)gcode);
   }
 
   bool isAxisPositionKnown(const axis_t axis) {
-    switch (axis) {
-      case X: case Y: case Z:
-        return TEST(axis_known_position, axis);
-      default: return true;
-    }
+    return TEST(axis_known_position, axis);
   }
 
-  progmem_str getFirmwareName() {
+  progmem_str getFirmwareName_str() {
     return F("Marlin " SHORT_BUILD_VERSION);
   }
 
-  void setTargetTemp_celsius(const uint8_t extruder, float temp) {
-    if (extruder)
-      thermalManager.setTargetHotend(clamp(temp,0,500), extruder-1);
+  void setTargetTemp_celsius(float value, const heater_t heater) {
     #if HAS_HEATED_BED
-      else
-        thermalManager.setTargetBed(clamp(temp,0,200));
+    if (heater == BED)
+      thermalManager.setTargetBed(clamp(value,0,200));
     #endif
+      thermalManager.setTargetHotend(clamp(value,0,500), heater - H0);
+  }
+
+  void setTargetTemp_celsius(float value, const extruder_t extruder) {
+    thermalManager.setTargetHotend(clamp(value,0,500), extruder - E0);
   }
 
-  void setFan_percent(const uint8_t fan, float percent) {
+  void setFan_percent(float value, const fan_t fan) {
     if (fan < FAN_COUNT)
-      fan_speed[fan] = clamp(round(percent * 255 / 100), 0, 255);
+      fan_speed[fan - FAN0] = clamp(round(value * 255 / 100), 0, 255);
   }
 
-  void setFeedrate_percent(const float percent) {
-    feedrate_percentage = clamp(percent, 10, 500);
+  void setFeedrate_percent(const float value) {
+    feedrate_percentage = clamp(value, 10, 500);
   }
 
   void printFile(const char *filename) {
-    IFSD(card.openAndPrintFile(filename), 0);
+    IFSD(card.openAndPrintFile(filename), NOOP);
   }
 
   bool isPrintingFromMediaPaused() {
@@ -511,7 +575,7 @@ namespace UI {
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || IFSD(IS_SD_PRINTING(), false) || isPrintingFromMedia());
+    return (planner.movesplanned() || IS_SD_PRINTING() || isPrintingFromMedia());
   }
 
   bool isMediaInserted() {
@@ -521,9 +585,7 @@ namespace UI {
   void pausePrint() {
     #if ENABLED(SDSUPPORT)
       card.pauseSDPrint();
-      #if ENABLED(PRINTCOUNTER)
-        print_job_timer.pause();
-      #endif
+      print_job_timer.pause();
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M125"));
       #endif
@@ -537,9 +599,7 @@ namespace UI {
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
-        #if ENABLED(PRINTCOUNTER)
-          print_job_timer.start();
-        #endif
+        print_job_timer.start();
       #endif
       UI::onStatusChanged(PSTR(MSG_PRINTING));
     #endif
@@ -553,13 +613,9 @@ namespace UI {
     #endif
   }
 
-  FileList::FileList() {
-    refresh();
-  }
+  FileList::FileList() { refresh(); }
 
-  void FileList::refresh() {
-    num_files = 0xFFFF;
-  }
+  void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(uint16_t pos, bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
@@ -645,39 +701,41 @@ void lcd_update() {
       else {
         const bool ok = card.cardOK;
         card.release();
-        if (ok)
-          UI::onMediaRemoved();
+        if (ok) UI::onMediaRemoved();
       }
     }
   #endif // SDSUPPORT
+  UI::_processManualMoveToDestination();
   UI::onIdle();
 }
 
-bool lcd_hasstatus()                                                             { return true; }
-bool lcd_detected()                                                              { return true; }
-void lcd_reset_alert_level()                                                     {}
-void lcd_refresh()                                                               {}
+bool lcd_hasstatus() { return true; }
+bool lcd_detected() { return true; }
+void lcd_reset_alert_level() { }
+void lcd_refresh() { }
 void lcd_setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
 void lcd_setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
 void lcd_setalertstatusPGM(const char * const message)                           { lcd_setstatusPGM(message, 0); }
+
 void lcd_reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   PGM_P msg;
-  if (IFPC(print_job_timer.isPaused(), false))
+  if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (card.sdprinting)
       return lcd_setstatus(card.longest_filename(), true);
   #endif
-  else if (IFPC(print_job_timer.isRunning(), false))
+  else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
   lcd_setstatusPGM(msg, -1);
 }
+
 void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   char buff[64];
   va_list args;
@@ -689,8 +747,8 @@ void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
 }
 
 void kill_screen(PGM_P msg) {
-  if (!printer_killed) {
-    printer_killed = true;
+  if (!flags.printer_killed) {
+    flags.printer_killed = true;
     UI::onPrinterKilled(msg);
   }
 }

commit f9b80e7217d70c3d36edaf2601bc380ba02fce23
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 29 13:54:04 2018 -0500

    Make getfilename_sorted standard for listings

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index b11e5f8ef2..f9963076a3 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -570,11 +570,7 @@ namespace UI {
         #endif
       pos;
 
-      #if ENABLED(SDCARD_SORT_ALPHA)
-        card.getfilename_sorted(nr);
-      #else
-        card.getfilename(nr);
-      #endif
+      card.getfilename_sorted(nr);
       return card.filename && card.filename[0] != '\0';
     #endif
   }

commit 53c535a0c151418d362169c06ba1f1dfbf6e420a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 25 09:45:57 2018 -0500

    Remove trailing whitespace

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index d5f53d9577..b11e5f8ef2 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -70,7 +70,7 @@
   #include "../../module/printcounter.h"
   #define IFPC(A,B) (A)
 #else
-  #define IFPC(A,B) (B)  
+  #define IFPC(A,B) (B)
 #endif
 
 #include "ui_api.h"

commit 9613f00877159a54675d83a305bba931a6d6e6a8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 24 18:02:30 2018 -0500

    Fix getProgress_seconds_elapsed to return seconds

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 606b7b6fc1..d5f53d9577 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -445,7 +445,7 @@ namespace UI {
   }
 
   uint32_t getProgress_seconds_elapsed() {
-    return IFPC(print_job_timer.duration(), 0);
+    return IFPC(print_job_timer.duration() / 1000UL, 0);
   }
 
   #if ENABLED(PRINTCOUNTER)

commit 5d487ef40e4017beabe4874537b2f51bc3558457
Author: gjdodd <31553294+gjdodd@users.noreply.github.com>
Date:   Wed Oct 24 23:52:39 2018 +0100

    Fix null exception due to duration_t of zero (#12207)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 1ed15cb600..606b7b6fc1 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -445,8 +445,7 @@ namespace UI {
   }
 
   uint32_t getProgress_seconds_elapsed() {
-    const duration_t elapsed = IFPC(print_job_timer.duration(), 0);
-    return elapsed.value;
+    return IFPC(print_job_timer.duration(), 0);
   }
 
   #if ENABLED(PRINTCOUNTER)

commit 0a549fd1f28be756472ded0362c6a16674498297
Author: gjdodd <31553294+gjdodd@users.noreply.github.com>
Date:   Wed Oct 24 22:36:11 2018 +0100

    Fix EXTENSIBLE_UI compile errors (#12206)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 56ac9216f4..1ed15cb600 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -68,6 +68,9 @@
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
   #include "../../module/printcounter.h"
+  #define IFPC(A,B) (A)
+#else
+  #define IFPC(A,B) (B)  
 #endif
 
 #include "ui_api.h"
@@ -194,7 +197,9 @@ namespace UI {
     switch (axis) {
       case X: case Y: case Z: break;
       case E0: case E1: case E2: case E3: case E4: case E5:
-        active_extruder = axis - E0;
+        #if EXTRUDERS > 1
+          active_extruder = axis - E0;
+        #endif
         break;
       default: return;
     }
@@ -223,7 +228,9 @@ namespace UI {
       if (extruder != active_extruder)
         tool_change(extruder, 0, no_move);
     #endif
-    active_extruder = extruder;
+    #if EXTRUDERS > 1
+      active_extruder = extruder;
+    #endif
   }
 
   uint8_t getActiveTool() { return active_extruder + 1; }
@@ -438,7 +445,7 @@ namespace UI {
   }
 
   uint32_t getProgress_seconds_elapsed() {
-    const duration_t elapsed = print_job_timer.duration();
+    const duration_t elapsed = IFPC(print_job_timer.duration(), 0);
     return elapsed.value;
   }
 
@@ -493,7 +500,7 @@ namespace UI {
   }
 
   void printFile(const char *filename) {
-    IFSD(card.openAndPrintFile(filename), NOOP);
+    IFSD(card.openAndPrintFile(filename), 0);
   }
 
   bool isPrintingFromMediaPaused() {
@@ -505,7 +512,7 @@ namespace UI {
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || IS_SD_PRINTING() || isPrintingFromMedia());
+    return (planner.movesplanned() || IFSD(IS_SD_PRINTING(), false) || isPrintingFromMedia());
   }
 
   bool isMediaInserted() {
@@ -515,7 +522,9 @@ namespace UI {
   void pausePrint() {
     #if ENABLED(SDSUPPORT)
       card.pauseSDPrint();
-      print_job_timer.pause();
+      #if ENABLED(PRINTCOUNTER)
+        print_job_timer.pause();
+      #endif
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M125"));
       #endif
@@ -529,7 +538,9 @@ namespace UI {
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
-        print_job_timer.start();
+        #if ENABLED(PRINTCOUNTER)
+          print_job_timer.start();
+        #endif
       #endif
       UI::onStatusChanged(PSTR(MSG_PRINTING));
     #endif
@@ -659,13 +670,13 @@ void lcd_reset_status() {
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   PGM_P msg;
-  if (print_job_timer.isPaused())
+  if (IFPC(print_job_timer.isPaused(), false))
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (card.sdprinting)
       return lcd_setstatus(card.longest_filename(), true);
   #endif
-  else if (print_job_timer.isRunning())
+  else if (IFPC(print_job_timer.isRunning(), false))
     msg = printing;
   else
     msg = welcome;

commit fc31da1114e219cfd573f17d0abb5ffee4e3d244
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Oct 22 18:37:48 2018 -0600

    Implement custom delay/millis for EXTENSIBLE_UI (#12188)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index f324f804a4..56ac9216f4 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -1,3 +1,25 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
 /**************
  * ui_api.cpp *
  **************/
@@ -29,6 +51,7 @@
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
 #include "../../libs/duration_t.h"
+#include "../../HAL/shared/Delay.h"
 
 #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "../../module/tool_change.h"
@@ -64,14 +87,70 @@ inline float clamp(const float value, const float minimum, const float maximum)
   return MAX(MIN(value, maximum), minimum);
 }
 
+static bool printer_killed = false;
+
 namespace UI {
+  #ifdef __SAM3X8E__
+    /**
+     * Implement a special millis() to allow time measurement
+     * within an ISR (such as when the printer is killed).
+     *
+     * To keep proper time, must be called at least every 1s.
+     */
+    uint32_t safe_millis() {
+      // Not killed? Just call millis()
+      if (!printer_killed) return millis();
+
+      static uint32_t currTimeHI = 0; /* Current time */
+
+      // Machine was killed, reinit SysTick so we are able to compute time without ISRs
+      if (currTimeHI == 0) {
+        // Get the last time the Arduino time computed (from CMSIS) and convert it to SysTick
+        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU/8000)) >> 24);
+
+        // Reinit the SysTick timer to maximize its period
+        SysTick->LOAD  = SysTick_LOAD_RELOAD_Msk;                    // get the full range for the systick timer
+        SysTick->VAL   = 0;                                          // Load the SysTick Counter Value
+        SysTick->CTRL  = // MCLK/8 as source
+                         // No interrupts
+                         SysTick_CTRL_ENABLE_Msk;                    // Enable SysTick Timer
+     }
+
+      // Check if there was a timer overflow from the last read
+      if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
+        // There was. This means (SysTick_LOAD_RELOAD_Msk * 1000 * 8)/F_CPU ms has elapsed
+        currTimeHI++;
+      }
+
+      // Calculate current time in milliseconds
+      uint32_t currTimeLO = SysTick_LOAD_RELOAD_Msk - SysTick->VAL; // (in MCLK/8)
+      uint64_t currTime = ((uint64_t)currTimeLO) | (((uint64_t)currTimeHI) << 24);
+
+      // The ms count is
+      return (uint32_t)(currTime / (F_CPU / 8000));
+    }
+
+  #else
+
+    // TODO: Implement for AVR
+    uint32_t safe_millis() { return millis(); }
+
+  #endif
+
+  void delay_us(unsigned long us) {
+    DELAY_US(us);
+  }
 
   void delay_ms(unsigned long ms) {
-    safe_delay(ms);
+    if (printer_killed)
+      DELAY_US(ms * 1000);
+    else
+      safe_delay(ms);
   }
 
   void yield() {
-    thermalManager.manage_heater();
+    if (!printer_killed)
+      thermalManager.manage_heater();
   }
 
   float getActualTemp_celsius(const uint8_t extruder) {
@@ -491,7 +570,7 @@ namespace UI {
   }
 
   const char* FileList::filename() {
-    return IFSD(card.longFilename && card.longFilename[0]) ? card.longFilename : card.filename, "");
+    return IFSD(card.longFilename && card.longFilename[0] ? card.longFilename : card.filename, "");
   }
 
   const char* FileList::shortFilename() {
@@ -603,4 +682,11 @@ void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   UI::onStatusChanged(buff);
 }
 
+void kill_screen(PGM_P msg) {
+  if (!printer_killed) {
+    printer_killed = true;
+    UI::onPrinterKilled(msg);
+  }
+}
+
 #endif // EXTENSIBLE_UI

commit 2e5e689a7f33ce76718d4220045135a782828426
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Oct 20 00:44:46 2018 -0600

    Fix kill() and ExtensibleUI (#12160)
    
    * Fix to isPrintingFromMedia()
    
      - isPrintingFromMedia() will now return true even if SD print is paused.
      - isPrintingFromMediaPaused() allows UI to determine if the print is paused.
    
    * Don't use _delay_us in minkill (#12145)
    
      - In HAL_DUE, _delay_us is simply an alias for delay, which causes the board to hang and subsequently reboot due to the watchdog timer.
    
    * Shorten code with IFSD macro

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 47b635f54f..f324f804a4 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -37,6 +37,9 @@
 #if ENABLED(SDSUPPORT)
   #include "../../sd/cardreader.h"
   #include "../../feature/emergency_parser.h"
+  #define IFSD(A,B) (A)
+#else
+  #define IFSD(A,B) (B)
 #endif
 
 #if ENABLED(PRINTCOUNTER)
@@ -352,11 +355,7 @@ namespace UI {
   #endif
 
   uint8_t getProgress_percent() {
-    #if ENABLED(SDSUPPORT)
-      return card.percentDone();
-    #else
-      return 0;
-    #endif
+    return IFSD(card.percentDone(), 0);
   }
 
   uint32_t getProgress_seconds_elapsed() {
@@ -415,35 +414,23 @@ namespace UI {
   }
 
   void printFile(const char *filename) {
-    #if ENABLED(SDSUPPORT)
-      card.openAndPrintFile(filename);
-    #endif
+    IFSD(card.openAndPrintFile(filename), NOOP);
+  }
+
+  bool isPrintingFromMediaPaused() {
+    return IFSD(isPrintingFromMedia() && !card.sdprinting, false);
   }
 
   bool isPrintingFromMedia() {
-    #if ENABLED(SDSUPPORT)
-      return card.cardOK && card.isFileOpen() && card.sdprinting;
-    #else
-      return false;
-    #endif
+    return IFSD(card.cardOK && card.isFileOpen(), false);
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || IS_SD_PRINTING() ||
-      #if ENABLED(SDSUPPORT)
-        (card.cardOK && card.isFileOpen())
-      #else
-        false
-      #endif
-    );
+    return (planner.movesplanned() || IS_SD_PRINTING() || isPrintingFromMedia());
   }
 
   bool isMediaInserted() {
-    #if ENABLED(SDSUPPORT)
-      return IS_SD_INSERTED() && card.cardOK;
-    #else
-      return false;
-    #endif
+    return IFSD(IS_SD_INSERTED() && card.cardOK, false);
   }
 
   void pausePrint() {
@@ -504,42 +491,23 @@ namespace UI {
   }
 
   const char* FileList::filename() {
-    #if ENABLED(SDSUPPORT)
-      return (card.longFilename && card.longFilename[0]) ? card.longFilename : card.filename;
-    #else
-      return "";
-    #endif
+    return IFSD(card.longFilename && card.longFilename[0]) ? card.longFilename : card.filename, "");
   }
 
   const char* FileList::shortFilename() {
-    #if ENABLED(SDSUPPORT)
-      return card.filename;
-    #else
-      return "";
-    #endif
+    return IFSD(card.filename, "");
   }
 
   const char* FileList::longFilename() {
-    #if ENABLED(SDSUPPORT)
-      return card.longFilename;
-    #else
-      return "";
-    #endif
+    return IFSD(card.longFilename, "");
   }
 
   bool FileList::isDir() {
-    #if ENABLED(SDSUPPORT)
-      return card.filenameIsDir;
-    #else
-      return false;
-    #endif
+    return IFSD(card.filenameIsDir, false);
   }
 
   uint16_t FileList::count() {
-    #if ENABLED(SDSUPPORT)
-      if (num_files == 0xFFFF) num_files = card.get_num_Files();
-      return num_files;
-    #endif
+    return IFSD((num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)), 0);
   }
 
   bool FileList::isAtRootDir() {

commit 1fb9b299d4d96276ff1fb6cd2ee5e73e753e2b23
Author: TheSFReader <TheSFReader@gmail.com>
Date:   Fri Oct 19 21:25:07 2018 +0200

    Add M524 to abort SD printing (#12155)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index e13ca08758..47b635f54f 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -37,10 +37,6 @@
 #if ENABLED(SDSUPPORT)
   #include "../../sd/cardreader.h"
   #include "../../feature/emergency_parser.h"
-
-  bool abort_sd_printing; // =false
-#else
-  constexpr bool abort_sd_printing = false;
 #endif
 
 #if ENABLED(PRINTCOUNTER)
@@ -476,7 +472,7 @@ namespace UI {
   void stopPrint() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
-      abort_sd_printing = true;
+      card.abort_sd_printing = true;
       UI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
     #endif
   }

commit c6a5c7420895bbb32ac3c70f0382ed5622c3746e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:52:44 2018 -0500

    Add parentheses to SD macros

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 26b38b1f25..e13ca08758 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -433,7 +433,7 @@ namespace UI {
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || IS_SD_PRINTING ||
+    return (planner.movesplanned() || IS_SD_PRINTING() ||
       #if ENABLED(SDSUPPORT)
         (card.cardOK && card.isFileOpen())
       #else
@@ -444,7 +444,7 @@ namespace UI {
 
   bool isMediaInserted() {
     #if ENABLED(SDSUPPORT)
-      return IS_SD_INSERTED && card.cardOK;
+      return IS_SD_INSERTED() && card.cardOK;
     #else
       return false;
     #endif
@@ -583,7 +583,7 @@ void lcd_init() {
 void lcd_update() {
   #if ENABLED(SDSUPPORT)
     static bool last_sd_status;
-    const bool sd_status = IS_SD_INSERTED;
+    const bool sd_status = IS_SD_INSERTED();
     if (sd_status != last_sd_status) {
       last_sd_status = sd_status;
       if (sd_status) {

commit f98f4ac7eaab5f509da5cd94420821f23fe7aeea
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 16 15:58:29 2018 -0600

    Fix and improve EXTENSIBLE_UI (#12117)
    
    - Add methods to access print counter data
    - Clean up some inconsistent method names
    - Clear lcd status after filament change
    - Implement `lcd_reset_status` so it works like UltraLCD

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index cb39c6b0a3..26b38b1f25 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -27,9 +27,7 @@
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
-#include "../../module/printcounter.h"
 #include "../../module/temperature.h"
-#include "../../sd/cardreader.h"
 #include "../../libs/duration_t.h"
 
 #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
@@ -37,6 +35,7 @@
 #endif
 
 #if ENABLED(SDSUPPORT)
+  #include "../../sd/cardreader.h"
   #include "../../feature/emergency_parser.h"
 
   bool abort_sd_printing; // =false
@@ -44,6 +43,11 @@
   constexpr bool abort_sd_printing = false;
 #endif
 
+#if ENABLED(PRINTCOUNTER)
+  #include "../../core/utility.h"
+  #include "../../module/printcounter.h"
+#endif
+
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
@@ -272,16 +276,16 @@ namespace UI {
     }
   #endif
 
-  float getMinFeedrate_mm_s()                             { return planner.settings.min_feedrate_mm_s; }
-  float getMinTravelFeedrate_mm_s()                       { return planner.settings.min_travel_feedrate_mm_s; }
-  float getPrintingAcceleration_mm_s2()                   { return planner.settings.acceleration; }
-  float getRetractAcceleration_mm_s2()                    { return planner.settings.retract_acceleration; }
-  float getTravelAcceleration_mm_s2()                     { return planner.settings.travel_acceleration; }
-  void setMinFeedrate_mm_s(const float fr)                { planner.settings.min_feedrate_mm_s = fr; }
-  void setMinTravelFeedrate_mm_s(const float fr)          { planner.settings.min_travel_feedrate_mm_s = fr; }
-  void setPrintingAcceleration_mm_per_s2(const float acc) { planner.settings.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float acc)      { planner.settings.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float acc)       { planner.settings.travel_acceleration = acc; }
+  float getMinFeedrate_mm_s()                         { return planner.settings.min_feedrate_mm_s; }
+  float getMinTravelFeedrate_mm_s()                   { return planner.settings.min_travel_feedrate_mm_s; }
+  float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
+  float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
+  float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
+  void setMinFeedrate_mm_s(const float fr)            { planner.settings.min_feedrate_mm_s = fr; }
+  void setMinTravelFeedrate_mm_s(const float fr)      { planner.settings.min_travel_feedrate_mm_s = fr; }
+  void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     float getZOffset_mm() {
@@ -364,6 +368,18 @@ namespace UI {
     return elapsed.value;
   }
 
+  #if ENABLED(PRINTCOUNTER)
+    char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,itostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
+    char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,itostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
+    char* getTotalPrintTime_str(char buffer[21]) { duration_t(print_job_timer.getStats().printTime).toString(buffer);     return buffer; }
+    char* getLongestPrint_str(char buffer[21])   { duration_t(print_job_timer.getStats().printTime).toString(buffer);     return buffer; }
+    char* getFilamentUsed_str(char buffer[21])   {
+      printStatistics stats = print_job_timer.getStats();
+      sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
+      return buffer;
+    }
+  #endif
+
   float getFeedRate_percent() {
     return feedrate_percentage;
   }
@@ -564,7 +580,7 @@ void lcd_init() {
   UI::onStartup();
 }
 
-void lcd_update()                                                                {
+void lcd_update() {
   #if ENABLED(SDSUPPORT)
     static bool last_sd_status;
     const bool sd_status = IS_SD_INSERTED;
@@ -585,7 +601,7 @@ void lcd_update()
       }
     }
   #endif // SDSUPPORT
-  UI::onUpdate();
+  UI::onIdle();
 }
 
 bool lcd_hasstatus()                                                             { return true; }
@@ -594,8 +610,25 @@ void lcd_reset_alert_level()
 void lcd_refresh()                                                               {}
 void lcd_setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
 void lcd_setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
-void lcd_reset_status()                                                          {}
 void lcd_setalertstatusPGM(const char * const message)                           { lcd_setstatusPGM(message, 0); }
+void lcd_reset_status() {
+  static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
+  static const char printing[] PROGMEM = MSG_PRINTING;
+  static const char welcome[] PROGMEM = WELCOME_MSG;
+  PGM_P msg;
+  if (print_job_timer.isPaused())
+    msg = paused;
+  #if ENABLED(SDSUPPORT)
+    else if (card.sdprinting)
+      return lcd_setstatus(card.longest_filename(), true);
+  #endif
+  else if (print_job_timer.isRunning())
+    msg = printing;
+  else
+    msg = welcome;
+
+  lcd_setstatusPGM(msg, -1);
+}
 void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   char buff[64];
   va_list args;

commit 056561df935f47ecfabc16e2ed777f3754be837c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 16 06:28:52 2018 -0600

    [2.0.x] Enhancements to FILAMENT_RUNOUT_SENSOR (#12069)
    
    - Added FILAMENT_RUNOUT_DISTANCE_MM option
    - Added FILAMENT_MOTION_SENSOR option

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 61eff88480..cb39c6b0a3 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -53,6 +53,10 @@
   #endif
 #endif
 
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "../../feature/runout.h"
+#endif
+
 inline float clamp(const float value, const float minimum, const float maximum) {
   return MAX(MIN(value, maximum), minimum);
 }
@@ -209,6 +213,21 @@ namespace UI {
     }
   }
 
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    bool isFilamentRunoutEnabled()              { return runout.enabled; }
+    void toggleFilamentRunout(const bool state) { runout.enabled = state; }
+
+    #if FILAMENT_RUNOUT_DISTANCE_MM > 0
+      float getFilamentRunoutDistance_mm() {
+        return RunoutResponseDelayed::runout_distance_mm;
+      }
+
+      void setFilamentRunoutDistance_mm(const float distance) {
+        RunoutResponseDelayed::runout_distance_mm = clamp(distance, 0, 999);
+      }
+    #endif
+  #endif
+
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const uint8_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder] : 0;

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index 2c3841b673..61eff88480 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -147,9 +147,9 @@ namespace UI {
   float getAxisSteps_per_mm(const axis_t axis) {
     switch (axis) {
       case X: case Y: case Z:
-        return planner.axis_steps_per_mm[axis];
+        return planner.settings.axis_steps_per_mm[axis];
       case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.axis_steps_per_mm[E_AXIS_N(axis - E0)];
+        return planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)];
       default: return 0;
     }
   }
@@ -157,10 +157,10 @@ namespace UI {
   void setAxisSteps_per_mm(const axis_t axis, const float steps_per_mm) {
     switch (axis) {
       case X: case Y: case Z:
-        planner.axis_steps_per_mm[axis] = steps_per_mm;
+        planner.settings.axis_steps_per_mm[axis] = steps_per_mm;
         break;
       case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.axis_steps_per_mm[E_AXIS_N(axis - E0)] = steps_per_mm;
+        planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = steps_per_mm;
         break;
     }
   }
@@ -168,9 +168,9 @@ namespace UI {
   float getAxisMaxFeedrate_mm_s(const axis_t axis) {
     switch (axis) {
       case X: case Y: case Z:
-        return planner.max_feedrate_mm_s[axis];
+        return planner.settings.max_feedrate_mm_s[axis];
       case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
+        return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
       default: return 0;
     }
   }
@@ -178,10 +178,10 @@ namespace UI {
   void setAxisMaxFeedrate_mm_s(const axis_t axis, const float max_feedrate_mm_s) {
     switch (axis) {
       case X: case Y: case Z:
-        planner.max_feedrate_mm_s[axis] = max_feedrate_mm_s;
+        planner.settings.max_feedrate_mm_s[axis] = max_feedrate_mm_s;
         break;
       case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = max_feedrate_mm_s;
+        planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = max_feedrate_mm_s;
         break;
       default: return;
     }
@@ -190,9 +190,9 @@ namespace UI {
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
     switch (axis) {
       case X: case Y: case Z:
-        return planner.max_acceleration_mm_per_s2[axis];
+        return planner.settings.max_acceleration_mm_per_s2[axis];
       case E0: case E1: case E2: case E3: case E4: case E5:
-        return planner.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)];
+        return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)];
       default: return 0;
     }
   }
@@ -200,10 +200,10 @@ namespace UI {
   void setAxisMaxAcceleration_mm_s2(const axis_t axis, const float max_acceleration_mm_per_s2) {
     switch (axis) {
       case X: case Y: case Z:
-        planner.max_acceleration_mm_per_s2[axis] = max_acceleration_mm_per_s2;
+        planner.settings.max_acceleration_mm_per_s2[axis] = max_acceleration_mm_per_s2;
         break;
       case E0: case E1: case E2: case E3: case E4: case E5:
-        planner.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)] = max_acceleration_mm_per_s2;
+        planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)] = max_acceleration_mm_per_s2;
         break;
       default: return;
     }
@@ -253,16 +253,16 @@ namespace UI {
     }
   #endif
 
-  float getMinFeedrate_mm_s()                             { return planner.min_feedrate_mm_s; }
-  float getMinTravelFeedrate_mm_s()                       { return planner.min_travel_feedrate_mm_s; }
-  float getPrintingAcceleration_mm_s2()                   { return planner.acceleration; }
-  float getRetractAcceleration_mm_s2()                    { return planner.retract_acceleration; }
-  float getTravelAcceleration_mm_s2()                     { return planner.travel_acceleration; }
-  void setMinFeedrate_mm_s(const float fr)                { planner.min_feedrate_mm_s = fr; }
-  void setMinTravelFeedrate_mm_s(const float fr)          { planner.min_travel_feedrate_mm_s = fr; }
-  void setPrintingAcceleration_mm_per_s2(const float acc) { planner.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float acc)      { planner.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float acc)       { planner.travel_acceleration = acc; }
+  float getMinFeedrate_mm_s()                             { return planner.settings.min_feedrate_mm_s; }
+  float getMinTravelFeedrate_mm_s()                       { return planner.settings.min_travel_feedrate_mm_s; }
+  float getPrintingAcceleration_mm_s2()                   { return planner.settings.acceleration; }
+  float getRetractAcceleration_mm_s2()                    { return planner.settings.retract_acceleration; }
+  float getTravelAcceleration_mm_s2()                     { return planner.settings.travel_acceleration; }
+  void setMinFeedrate_mm_s(const float fr)                { planner.settings.min_feedrate_mm_s = fr; }
+  void setMinTravelFeedrate_mm_s(const float fr)          { planner.settings.min_travel_feedrate_mm_s = fr; }
+  void setPrintingAcceleration_mm_per_s2(const float acc) { planner.settings.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float acc)      { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float acc)       { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     float getZOffset_mm() {

commit cef1de89d0b0790126c939f23a29e846edd52dd9
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 9 15:59:34 2018 -0600

    Fixed incorrect axis index. (#12051)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
index e3c552a05b..2c3841b673 100644
--- a/Marlin/src/lcd/extensible_ui/ui_api.cpp
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -115,7 +115,7 @@ namespace UI {
     set_destination_from_current();
     switch (axis) {
       case X: case Y: case Z:
-        destination[Z_AXIS] = position;
+        destination[axis] = position;
         break;
       case E0: case E1: case E2: case E3: case E4: case E5:
         destination[E_AXIS] = position;

commit 906a24fa81586e3d9aeb60e7a3fb179a8b616b9b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Oct 8 14:44:05 2018 -0600

    Extensible user interface API (#11193)

diff --git a/Marlin/src/lcd/extensible_ui/ui_api.cpp b/Marlin/src/lcd/extensible_ui/ui_api.cpp
new file mode 100644
index 0000000000..e3c552a05b
--- /dev/null
+++ b/Marlin/src/lcd/extensible_ui/ui_api.cpp
@@ -0,0 +1,590 @@
+/**************
+ * ui_api.cpp *
+ **************/
+
+/****************************************************************************
+ *   Written By Marcio Teixeira 2018 - Aleph Objects, Inc.                  *
+ *                                                                          *
+ *   This program is free software: you can redistribute it and/or modify   *
+ *   it under the terms of the GNU General Public License as published by   *
+ *   the Free Software Foundation, either version 3 of the License, or      *
+ *   (at your option) any later version.                                    *
+ *                                                                          *
+ *   This program is distributed in the hope that it will be useful,        *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+ *   GNU General Public License for more details.                           *
+ *                                                                          *
+ *   To view a copy of the GNU General Public License, go to the following  *
+ *   location: <http://www.gnu.org/licenses/>.                              *
+ ****************************************************************************/
+
+#include "../../Marlin.h"
+
+#if ENABLED(EXTENSIBLE_UI)
+
+#include "../../gcode/queue.h"
+#include "../../module/motion.h"
+#include "../../module/planner.h"
+#include "../../module/probe.h"
+#include "../../module/printcounter.h"
+#include "../../module/temperature.h"
+#include "../../sd/cardreader.h"
+#include "../../libs/duration_t.h"
+
+#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+  #include "../../module/tool_change.h"
+#endif
+
+#if ENABLED(SDSUPPORT)
+  #include "../../feature/emergency_parser.h"
+
+  bool abort_sd_printing; // =false
+#else
+  constexpr bool abort_sd_printing = false;
+#endif
+
+#include "ui_api.h"
+
+#if ENABLED(BACKLASH_GCODE)
+  extern float backlash_distance_mm[XYZ], backlash_correction;
+  #ifdef BACKLASH_SMOOTHING_MM
+    extern float backlash_smoothing_mm;
+  #endif
+#endif
+
+inline float clamp(const float value, const float minimum, const float maximum) {
+  return MAX(MIN(value, maximum), minimum);
+}
+
+namespace UI {
+
+  void delay_ms(unsigned long ms) {
+    safe_delay(ms);
+  }
+
+  void yield() {
+    thermalManager.manage_heater();
+  }
+
+  float getActualTemp_celsius(const uint8_t extruder) {
+    return extruder ?
+      thermalManager.degHotend(extruder - 1) :
+      #if HAS_HEATED_BED
+        thermalManager.degBed()
+      #else
+        0
+      #endif
+    ;
+  }
+
+  float getTargetTemp_celsius(const uint8_t extruder) {
+    return extruder ?
+      thermalManager.degTargetHotend(extruder - 1) :
+      #if HAS_HEATED_BED
+        thermalManager.degTargetBed()
+      #else
+        0
+      #endif
+    ;
+  }
+
+  float getFan_percent(const uint8_t fan) { return ((float(fan_speed[fan]) + 1) * 100) / 256; }
+
+  float getAxisPosition_mm(const axis_t axis) {
+    switch (axis) {
+      case X: case Y: case Z:
+        return current_position[axis];
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        return current_position[E_AXIS];
+      default: return 0;
+    }
+  }
+
+  void setAxisPosition_mm(const axis_t axis, float position, float _feedrate_mm_s) {
+    #if EXTRUDERS > 1
+      const int8_t old_extruder = active_extruder;
+    #endif
+    switch (axis) {
+      case X: case Y: case Z: break;
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        active_extruder = axis - E0;
+        break;
+      default: return;
+    }
+    set_destination_from_current();
+    switch (axis) {
+      case X: case Y: case Z:
+        destination[Z_AXIS] = position;
+        break;
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        destination[E_AXIS] = position;
+        break;
+    }
+
+    const float old_feedrate = feedrate_mm_s;
+    feedrate_mm_s = _feedrate_mm_s;
+    prepare_move_to_destination();
+    feedrate_mm_s = old_feedrate;
+    #if EXTRUDERS > 1
+      active_extruder = old_extruder;
+    #endif
+  }
+
+  void setActiveTool(uint8_t extruder, bool no_move) {
+    extruder--; // Make zero based
+    #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+      if (extruder != active_extruder)
+        tool_change(extruder, 0, no_move);
+    #endif
+    active_extruder = extruder;
+  }
+
+  uint8_t getActiveTool() { return active_extruder + 1; }
+
+  bool isMoving() { return planner.has_blocks_queued(); }
+
+  float getAxisSteps_per_mm(const axis_t axis) {
+    switch (axis) {
+      case X: case Y: case Z:
+        return planner.axis_steps_per_mm[axis];
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        return planner.axis_steps_per_mm[E_AXIS_N(axis - E0)];
+      default: return 0;
+    }
+  }
+
+  void setAxisSteps_per_mm(const axis_t axis, const float steps_per_mm) {
+    switch (axis) {
+      case X: case Y: case Z:
+        planner.axis_steps_per_mm[axis] = steps_per_mm;
+        break;
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        planner.axis_steps_per_mm[E_AXIS_N(axis - E0)] = steps_per_mm;
+        break;
+    }
+  }
+
+  float getAxisMaxFeedrate_mm_s(const axis_t axis) {
+    switch (axis) {
+      case X: case Y: case Z:
+        return planner.max_feedrate_mm_s[axis];
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        return planner.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
+      default: return 0;
+    }
+  }
+
+  void setAxisMaxFeedrate_mm_s(const axis_t axis, const float max_feedrate_mm_s) {
+    switch (axis) {
+      case X: case Y: case Z:
+        planner.max_feedrate_mm_s[axis] = max_feedrate_mm_s;
+        break;
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        planner.max_feedrate_mm_s[E_AXIS_N(axis - E0)] = max_feedrate_mm_s;
+        break;
+      default: return;
+    }
+  }
+
+  float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
+    switch (axis) {
+      case X: case Y: case Z:
+        return planner.max_acceleration_mm_per_s2[axis];
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        return planner.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)];
+      default: return 0;
+    }
+  }
+
+  void setAxisMaxAcceleration_mm_s2(const axis_t axis, const float max_acceleration_mm_per_s2) {
+    switch (axis) {
+      case X: case Y: case Z:
+        planner.max_acceleration_mm_per_s2[axis] = max_acceleration_mm_per_s2;
+        break;
+      case E0: case E1: case E2: case E3: case E4: case E5:
+        planner.max_acceleration_mm_per_s2[E_AXIS_N(axis - E0)] = max_acceleration_mm_per_s2;
+        break;
+      default: return;
+    }
+  }
+
+  #if ENABLED(LIN_ADVANCE)
+    float getLinearAdvance_mm_mm_s(const uint8_t extruder) {
+      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder] : 0;
+    }
+
+    void setLinearAdvance_mm_mm_s(const uint8_t extruder, const float k) {
+      if (extruder < EXTRUDERS)
+        planner.extruder_advance_K[extruder] = clamp(k, 0, 999);
+    }
+  #endif
+
+  #if ENABLED(JUNCTION_DEVIATION)
+    float getJunctionDeviation_mm() {
+      return planner.junction_deviation_mm;
+    }
+
+    void setJunctionDeviation_mm(const float junc_dev) {
+      planner.junction_deviation_mm = clamp(junc_dev, 0.01, 0.3);
+      planner.recalculate_max_e_jerk();
+    }
+  #else
+    float getAxisMaxJerk_mm_s(const axis_t axis) {
+      switch (axis) {
+        case X: case Y: case Z:
+          return planner.max_jerk[axis];
+        case E0: case E1: case E2: case E3: case E4: case E5:
+          return planner.max_jerk[E_AXIS];
+        default: return 0;
+      }
+    }
+
+    void setAxisMaxJerk_mm_s(const axis_t axis, const float max_jerk) {
+      switch (axis) {
+        case X: case Y: case Z:
+          planner.max_jerk[axis] = max_jerk;
+          break;
+        case E0: case E1: case E2: case E3: case E4: case E5:
+          planner.max_jerk[E_AXIS] = max_jerk;
+          break;
+        default: return;
+      }
+    }
+  #endif
+
+  float getMinFeedrate_mm_s()                             { return planner.min_feedrate_mm_s; }
+  float getMinTravelFeedrate_mm_s()                       { return planner.min_travel_feedrate_mm_s; }
+  float getPrintingAcceleration_mm_s2()                   { return planner.acceleration; }
+  float getRetractAcceleration_mm_s2()                    { return planner.retract_acceleration; }
+  float getTravelAcceleration_mm_s2()                     { return planner.travel_acceleration; }
+  void setMinFeedrate_mm_s(const float fr)                { planner.min_feedrate_mm_s = fr; }
+  void setMinTravelFeedrate_mm_s(const float fr)          { planner.min_travel_feedrate_mm_s = fr; }
+  void setPrintingAcceleration_mm_per_s2(const float acc) { planner.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float acc)      { planner.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float acc)       { planner.travel_acceleration = acc; }
+
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    float getZOffset_mm() {
+      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+        if (active_extruder != 0)
+          return hotend_offset[Z_AXIS][active_extruder];
+        else
+      #endif
+          return zprobe_zoffset;
+    }
+
+    void setZOffset_mm(const float zoffset_mm) {
+      const float diff = (zoffset_mm - getZOffset_mm()) / planner.steps_to_mm[Z_AXIS];
+      incrementZOffset_steps(diff > 0 ? ceil(diff) : floor(diff));
+    }
+
+    void incrementZOffset_steps(int16_t babystep_increment) {
+      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+        const bool do_probe = (active_extruder == 0);
+      #else
+        constexpr bool do_probe = true;
+      #endif
+      const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                  new_probe_offset = zprobe_zoffset + diff,
+                  new_offs =
+                    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+                      do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
+                    #else
+                      new_probe_offset
+                    #endif
+                  ;
+      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+
+        thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+
+        if (do_probe) zprobe_zoffset = new_offs;
+        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+          else hotend_offset[Z_AXIS][active_extruder] = new_offs;
+        #endif
+      }
+    }
+  #endif // ENABLED(BABYSTEP_ZPROBE_OFFSET)
+
+  #if HOTENDS > 1
+    float getNozzleOffset_mm(const axis_t axis, uint8_t extruder) {
+      if (extruder >= HOTENDS) return 0;
+      return hotend_offset[axis][extruder];
+    }
+
+    void setNozzleOffset_mm(const axis_t axis, uint8_t extruder, float offset) {
+      if (extruder >= HOTENDS) return;
+      hotend_offset[axis][extruder] = offset;
+    }
+  #endif
+
+  #if ENABLED(BACKLASH_GCODE)
+    float getAxisBacklash_mm(const axis_t axis)       {return backlash_distance_mm[axis];}
+    void setAxisBacklash_mm(const axis_t axis, float distance)
+                                                      {backlash_distance_mm[axis] = clamp(distance,0,5);}
+
+    float getBacklashCorrection_percent()             {return backlash_correction*100;}
+    void setBacklashCorrection_percent(float percent) {backlash_correction = clamp(percent, 0, 100)/100;}
+
+    #ifdef BACKLASH_SMOOTHING_MM
+      float getBacklashSmoothing_mm()                 {return backlash_smoothing_mm;}
+      void setBacklashSmoothing_mm(float distance)    {backlash_smoothing_mm = clamp(distance,0,999);}
+    #endif
+  #endif
+
+  uint8_t getProgress_percent() {
+    #if ENABLED(SDSUPPORT)
+      return card.percentDone();
+    #else
+      return 0;
+    #endif
+  }
+
+  uint32_t getProgress_seconds_elapsed() {
+    const duration_t elapsed = print_job_timer.duration();
+    return elapsed.value;
+  }
+
+  float getFeedRate_percent() {
+    return feedrate_percentage;
+  }
+
+  void enqueueCommands(progmem_str gcode) {
+    enqueue_and_echo_commands_P((PGM_P)gcode);
+  }
+
+  bool isAxisPositionKnown(const axis_t axis) {
+    switch (axis) {
+      case X: case Y: case Z:
+        return TEST(axis_known_position, axis);
+      default: return true;
+    }
+  }
+
+  progmem_str getFirmwareName() {
+    return F("Marlin " SHORT_BUILD_VERSION);
+  }
+
+  void setTargetTemp_celsius(const uint8_t extruder, float temp) {
+    if (extruder)
+      thermalManager.setTargetHotend(clamp(temp,0,500), extruder-1);
+    #if HAS_HEATED_BED
+      else
+        thermalManager.setTargetBed(clamp(temp,0,200));
+    #endif
+  }
+
+  void setFan_percent(const uint8_t fan, float percent) {
+    if (fan < FAN_COUNT)
+      fan_speed[fan] = clamp(round(percent * 255 / 100), 0, 255);
+  }
+
+  void setFeedrate_percent(const float percent) {
+    feedrate_percentage = clamp(percent, 10, 500);
+  }
+
+  void printFile(const char *filename) {
+    #if ENABLED(SDSUPPORT)
+      card.openAndPrintFile(filename);
+    #endif
+  }
+
+  bool isPrintingFromMedia() {
+    #if ENABLED(SDSUPPORT)
+      return card.cardOK && card.isFileOpen() && card.sdprinting;
+    #else
+      return false;
+    #endif
+  }
+
+  bool isPrinting() {
+    return (planner.movesplanned() || IS_SD_PRINTING ||
+      #if ENABLED(SDSUPPORT)
+        (card.cardOK && card.isFileOpen())
+      #else
+        false
+      #endif
+    );
+  }
+
+  bool isMediaInserted() {
+    #if ENABLED(SDSUPPORT)
+      return IS_SD_INSERTED && card.cardOK;
+    #else
+      return false;
+    #endif
+  }
+
+  void pausePrint() {
+    #if ENABLED(SDSUPPORT)
+      card.pauseSDPrint();
+      print_job_timer.pause();
+      #if ENABLED(PARK_HEAD_ON_PAUSE)
+        enqueue_and_echo_commands_P(PSTR("M125"));
+      #endif
+      UI::onStatusChanged(PSTR(MSG_PRINT_PAUSED));
+    #endif
+  }
+
+  void resumePrint() {
+    #if ENABLED(SDSUPPORT)
+      #if ENABLED(PARK_HEAD_ON_PAUSE)
+        enqueue_and_echo_commands_P(PSTR("M24"));
+      #else
+        card.startFileprint();
+        print_job_timer.start();
+      #endif
+      UI::onStatusChanged(PSTR(MSG_PRINTING));
+    #endif
+  }
+
+  void stopPrint() {
+    #if ENABLED(SDSUPPORT)
+      wait_for_heatup = wait_for_user = false;
+      abort_sd_printing = true;
+      UI::onStatusChanged(PSTR(MSG_PRINT_ABORTED));
+    #endif
+  }
+
+  FileList::FileList() {
+    refresh();
+  }
+
+  void FileList::refresh() {
+    num_files = 0xFFFF;
+  }
+
+  bool FileList::seek(uint16_t pos, bool skip_range_check) {
+    #if ENABLED(SDSUPPORT)
+      if (!skip_range_check && pos > (count() - 1)) return false;
+      const uint16_t nr =
+        #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
+          count() - 1 -
+        #endif
+      pos;
+
+      #if ENABLED(SDCARD_SORT_ALPHA)
+        card.getfilename_sorted(nr);
+      #else
+        card.getfilename(nr);
+      #endif
+      return card.filename && card.filename[0] != '\0';
+    #endif
+  }
+
+  const char* FileList::filename() {
+    #if ENABLED(SDSUPPORT)
+      return (card.longFilename && card.longFilename[0]) ? card.longFilename : card.filename;
+    #else
+      return "";
+    #endif
+  }
+
+  const char* FileList::shortFilename() {
+    #if ENABLED(SDSUPPORT)
+      return card.filename;
+    #else
+      return "";
+    #endif
+  }
+
+  const char* FileList::longFilename() {
+    #if ENABLED(SDSUPPORT)
+      return card.longFilename;
+    #else
+      return "";
+    #endif
+  }
+
+  bool FileList::isDir() {
+    #if ENABLED(SDSUPPORT)
+      return card.filenameIsDir;
+    #else
+      return false;
+    #endif
+  }
+
+  uint16_t FileList::count() {
+    #if ENABLED(SDSUPPORT)
+      if (num_files == 0xFFFF) num_files = card.get_num_Files();
+      return num_files;
+    #endif
+  }
+
+  bool FileList::isAtRootDir() {
+    #if ENABLED(SDSUPPORT)
+      card.getWorkDirName();
+      return card.filename[0] == '/';
+    #else
+      return true;
+    #endif
+  }
+
+  void FileList::upDir() {
+    #if ENABLED(SDSUPPORT)
+      card.updir();
+      num_files = 0xFFFF;
+    #endif
+  }
+
+  void FileList::changeDir(const char *dirname) {
+    #if ENABLED(SDSUPPORT)
+      card.chdir(dirname);
+      num_files = 0xFFFF;
+    #endif
+  }
+
+} // namespace UI
+
+// At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
+
+void lcd_init() {
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+    SET_INPUT_PULLUP(SD_DETECT_PIN);
+  #endif
+  UI::onStartup();
+}
+
+void lcd_update()                                                                {
+  #if ENABLED(SDSUPPORT)
+    static bool last_sd_status;
+    const bool sd_status = IS_SD_INSERTED;
+    if (sd_status != last_sd_status) {
+      last_sd_status = sd_status;
+      if (sd_status) {
+        card.initsd();
+        if (card.cardOK)
+          UI::onMediaInserted();
+        else
+          UI::onMediaError();
+      }
+      else {
+        const bool ok = card.cardOK;
+        card.release();
+        if (ok)
+          UI::onMediaRemoved();
+      }
+    }
+  #endif // SDSUPPORT
+  UI::onUpdate();
+}
+
+bool lcd_hasstatus()                                                             { return true; }
+bool lcd_detected()                                                              { return true; }
+void lcd_reset_alert_level()                                                     {}
+void lcd_refresh()                                                               {}
+void lcd_setstatus(const char * const message, const bool persist /* = false */) { UI::onStatusChanged(message); }
+void lcd_setstatusPGM(const char * const message, int8_t level /* = 0 */)        { UI::onStatusChanged((progmem_str)message); }
+void lcd_reset_status()                                                          {}
+void lcd_setalertstatusPGM(const char * const message)                           { lcd_setstatusPGM(message, 0); }
+void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
+  char buff[64];
+  va_list args;
+  va_start(args, fmt);
+  vsnprintf_P(buff, sizeof(buff), fmt, args);
+  va_end(args);
+  buff[63] = '\0';
+  UI::onStatusChanged(buff);
+}
+
+#endif // EXTENSIBLE_UI
