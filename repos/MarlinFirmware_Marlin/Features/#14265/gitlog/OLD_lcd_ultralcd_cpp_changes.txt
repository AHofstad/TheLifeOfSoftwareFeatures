commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
deleted file mode 100644
index 25f5afc71d..0000000000
--- a/Marlin/src/lcd/ultralcd.cpp
+++ /dev/null
@@ -1,1688 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../inc/MarlinConfig.h"
-
-#ifdef LED_BACKLIGHT_TIMEOUT
-  #include "../feature/leds/leds.h"
-#endif
-
-#if ENABLED(HOST_ACTION_COMMANDS)
-  #include "../feature/host_actions.h"
-#endif
-
-// All displays share the MarlinUI class
-#include "ultralcd.h"
-MarlinUI ui;
-
-#if HAS_DISPLAY
-  #include "../module/printcounter.h"
-  #include "../MarlinCore.h"
-  #include "../gcode/queue.h"
-  #include "fontutils.h"
-  #include "../sd/cardreader.h"
-  #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
-    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
-  #endif
-#endif
-
-#if LCD_HAS_WAIT_FOR_MOVE
-  bool MarlinUI::wait_for_move; // = false
-#endif
-
-constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
-
-#if HAS_WIRED_LCD
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    uint8_t MarlinUI::status_scroll_offset; // = 0
-    constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
-  #else
-    constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
-  #endif
-#elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
-  constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
-#endif
-
-#if EITHER(HAS_WIRED_LCD, EXTENSIBLE_UI)
-  uint8_t MarlinUI::alert_level; // = 0
-  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
-#endif
-
-#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  MarlinUI::progress_t MarlinUI::progress_override; // = 0
-  #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
-    uint32_t MarlinUI::remaining_time;
-  #endif
-#endif
-
-#if EITHER(PCA9632_BUZZER, USE_BEEPER)
-  #include "../libs/buzzer.h" // for BUZZ() macro
-  #if ENABLED(PCA9632_BUZZER)
-    #include "../feature/leds/pca9632.h"
-  #endif
-  void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    #if ENABLED(PCA9632_BUZZER)
-      PCA9632_buzz(duration, freq);
-    #elif USE_BEEPER
-      buzzer.tone(duration, freq);
-    #endif
-  }
-#endif
-
-#if PREHEAT_COUNT
-  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
-  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
-    #ifdef PREHEAT_1_LABEL
-      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
-    #endif
-    #ifdef PREHEAT_2_LABEL
-      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
-    #endif
-    #ifdef PREHEAT_3_LABEL
-      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
-    #endif
-    #ifdef PREHEAT_4_LABEL
-      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
-    #endif
-    #ifdef PREHEAT_5_LABEL
-      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
-    #endif
-
-    #define _PLBL(N) preheat_##N##_label,
-    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
-
-    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
-  }
-#endif
-
-#if HAS_WIRED_LCD
-
-#if HAS_MARLINUI_U8GLIB
-  #include "dogm/ultralcd_DOGM.h"
-#endif
-
-#include "lcdprint.h"
-
-#include "../sd/cardreader.h"
-
-#include "../module/temperature.h"
-#include "../module/planner.h"
-#include "../module/motion.h"
-
-#if HAS_LCD_MENU
-  #include "../module/settings.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../feature/bedlevel/bedlevel.h"
-#endif
-
-#if HAS_TRINAMIC_CONFIG
-  #include "../feature/tmc_util.h"
-#endif
-
-#if HAS_ADC_BUTTONS
-  #include "../module/thermistor/thermistors.h"
-#endif
-
-#if HAS_POWER_MONITOR
-  #include "../feature/power_monitor.h"
-#endif
-
-#if HAS_ENCODER_ACTION
-  volatile uint8_t MarlinUI::buttons;
-  #if HAS_SLOW_BUTTONS
-    volatile uint8_t MarlinUI::slow_buttons;
-  #endif
-  #if HAS_TOUCH_XPT2046
-    #include "touch/touch_buttons.h"
-    bool MarlinUI::on_edit_screen = false;
-  #endif
-#endif
-
-#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
-  bool MarlinUI::defer_return_to_status;
-#endif
-
-uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
-
-#if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-  millis_t MarlinUI::next_filament_display; // = 0
-#endif
-
-millis_t MarlinUI::next_button_update_ms; // = 0
-
-#if HAS_MARLINUI_U8GLIB
-  bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
-#endif
-
-// Encoder Handling
-#if HAS_ENCODER_ACTION
-  uint32_t MarlinUI::encoderPosition;
-  volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
-#endif
-
-#if ENABLED(SDSUPPORT)
-
-  #include "../sd/cardreader.h"
-
-  #if MARLINUI_SCROLL_NAME
-    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
-  #endif
-
-  const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
-    const char *outstr = theCard.longest_filename();
-    if (theCard.longFilename[0]) {
-      #if MARLINUI_SCROLL_NAME
-        if (doScroll) {
-          for (uint8_t l = FILENAME_LENGTH; l--;)
-            hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
-          static uint8_t filename_scroll_hash;
-          if (filename_scroll_hash != hash) {                              // If the hash changed...
-            filename_scroll_hash = hash;                                   // Save the new hash
-            filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
-            filename_scroll_pos = 0;                                       // Reset scroll to the start
-            lcd_status_update_delay = 8;                                   // Don't scroll right away
-          }
-          outstr += filename_scroll_pos;
-        }
-      #else
-        theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
-      #endif
-    }
-    return outstr;
-  }
-
-#endif
-
-#if HAS_LCD_MENU
-  #include "menu/menu.h"
-
-  screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
-  bool MarlinUI::screen_changed;
-
-  #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    bool MarlinUI::encoderRateMultiplierEnabled;
-    millis_t MarlinUI::lastEncoderMovementMillis = 0;
-    void MarlinUI::enable_encoder_multiplier(const bool onoff) {
-      encoderRateMultiplierEnabled = onoff;
-      lastEncoderMovementMillis = 0;
-    }
-  #endif
-
-  #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
-    int8_t MarlinUI::encoderDirection = ENCODERBASE;
-  #endif
-
-  #if HAS_TOUCH_XPT2046
-    uint8_t MarlinUI::touch_buttons;
-    uint8_t MarlinUI::repeat_delay;
-  #endif
-
-  bool MarlinUI::lcd_clicked;
-
-  bool MarlinUI::use_click() {
-    const bool click = lcd_clicked;
-    lcd_clicked = false;
-    return click;
-  }
-
-  #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
-
-    bool MarlinUI::external_control; // = false
-
-    void MarlinUI::wait_for_release() {
-      while (button_pressed()) safe_delay(50);
-      safe_delay(50);
-    }
-
-  #endif
-
-  void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
-    SETCURSOR(col, row);
-    if (!string) return;
-
-    auto _newline = [&col, &row]{
-      col = 0; row++;                 // Move col to string len (plus space)
-      SETCURSOR(0, row);              // Simulate carriage return
-    };
-
-    uint8_t *p = (uint8_t*)string;
-    wchar_t ch;
-    if (wordwrap) {
-      uint8_t *wrd = nullptr, c = 0;
-      // find the end of the part
-      for (;;) {
-        if (!wrd) wrd = p;            // Get word start /before/ advancing
-        p = get_utf8_value_cb(p, cb_read_byte, &ch);
-        const bool eol = !ch;         // zero ends the string
-        // End or a break between phrases?
-        if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
-          if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
-          // Past the right and the word is not too long?
-          if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
-          c += !eol;                  // +1 so the space will be printed
-          col += c;                   // advance col to new position
-          while (c) {                 // character countdown
-            --c;                      // count down to zero
-            wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
-            lcd_put_wchar(ch);        // character to the LCD
-          }
-          if (eol) break;             // all done!
-          wrd = nullptr;              // set up for next word
-        }
-        else c++;                     // count word characters
-      }
-    }
-    else {
-      for (;;) {
-        p = get_utf8_value_cb(p, cb_read_byte, &ch);
-        if (!ch) break;
-        lcd_put_wchar(ch);
-        col++;
-        if (col >= LCD_WIDTH) _newline();
-      }
-    }
-  }
-
-  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-    const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
-    uint8_t col = 0, row = 0;
-    if (!string && plen + slen <= LCD_WIDTH) {
-      col = (LCD_WIDTH - plen - slen) / 2;
-      row = LCD_HEIGHT > 3 ? 1 : 0;
-    }
-    wrap_string_P(col, row, pref, true);
-    if (string) {
-      if (col) { col = 0; row++; } // Move to the start of the next line
-      wrap_string(col, row, string);
-    }
-    if (suff) wrap_string_P(col, row, suff);
-  }
-
-#endif // HAS_LCD_MENU
-
-void MarlinUI::init() {
-
-  init_lcd();
-
-  #if HAS_DIGITAL_BUTTONS
-
-    #if BUTTON_EXISTS(EN1)
-      SET_INPUT_PULLUP(BTN_EN1);
-    #endif
-    #if BUTTON_EXISTS(EN2)
-      SET_INPUT_PULLUP(BTN_EN2);
-    #endif
-    #if BUTTON_EXISTS(ENC)
-      SET_INPUT_PULLUP(BTN_ENC);
-    #endif
-
-    #if BUTTON_EXISTS(BACK)
-      SET_INPUT_PULLUP(BTN_BACK);
-    #endif
-
-    #if BUTTON_EXISTS(UP)
-      SET_INPUT(BTN_UP);
-    #endif
-    #if BUTTON_EXISTS(DWN)
-      SET_INPUT(BTN_DWN);
-    #endif
-    #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LFT);
-    #endif
-    #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RT);
-    #endif
-
-  #endif // !HAS_DIGITAL_BUTTONS
-
-  #if HAS_SHIFT_ENCODER
-
-    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
-
-      SET_OUTPUT(SR_DATA_PIN);
-      SET_OUTPUT(SR_CLK_PIN);
-
-    #elif defined(SHIFT_CLK)
-
-      SET_OUTPUT(SHIFT_CLK);
-      OUT_WRITE(SHIFT_LD, HIGH);
-      #if defined(SHIFT_EN) && SHIFT_EN >= 0
-        OUT_WRITE(SHIFT_EN, LOW);
-      #endif
-      SET_INPUT_PULLUP(SHIFT_OUT);
-
-    #endif
-
-  #endif // HAS_SHIFT_ENCODER
-
-  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
-    slow_buttons = 0;
-  #endif
-
-  update_buttons();
-
-  TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
-}
-
-bool MarlinUI::get_blink() {
-  static uint8_t blink = 0;
-  static millis_t next_blink_ms = 0;
-  millis_t ms = millis();
-  if (ELAPSED(ms, next_blink_ms)) {
-    blink ^= 0xFF;
-    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
-  }
-  return blink != 0;
-}
-
-////////////////////////////////////////////
-///////////// Keypad Handling //////////////
-////////////////////////////////////////////
-
-#if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
-
-  volatile uint8_t MarlinUI::keypad_buttons;
-
-  #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
-
-    void lcd_move_x();
-    void lcd_move_y();
-    void lcd_move_z();
-
-    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
-      ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-      ui.encoderPosition = dir;
-      switch (axis) {
-        case X_AXIS: lcd_move_x(); break;
-        case Y_AXIS: lcd_move_y(); break;
-        case Z_AXIS: lcd_move_z();
-        default: break;
-      }
-    }
-
-  #endif
-
-  bool MarlinUI::handle_keypad() {
-
-    #if HAS_ADC_BUTTONS
-
-      #define ADC_MIN_KEY_DELAY 100
-      if (keypad_buttons) {
-        #if HAS_ENCODER_ACTION
-          refresh(LCDVIEW_REDRAW_NOW);
-          #if HAS_LCD_MENU
-            if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
-                   if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
-              else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
-            }
-            else
-          #endif
-          {
-            #if HAS_LCD_MENU
-                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
-              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
-              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
-              else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
-            #else
-                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= epps;
-              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += epps;
-            #endif
-          }
-        #endif
-        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
-        return true;
-      }
-
-    #else // !HAS_ADC_BUTTONS
-
-      static uint8_t keypad_debounce = 0;
-
-      if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2
-              | EN_KEYPAD_F3    | EN_KEYPAD_DOWN
-              | EN_KEYPAD_RIGHT | EN_KEYPAD_MIDDLE
-              | EN_KEYPAD_UP    | EN_KEYPAD_LEFT )
-      ) {
-        if (keypad_debounce > 0) keypad_debounce--;
-      }
-      else if (!keypad_debounce) {
-        keypad_debounce = 2;
-
-        const bool homed = all_axes_homed();
-
-        #if HAS_LCD_MENU
-
-          if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
-
-          #if DISABLED(DELTA) && Z_HOME_DIR < 0
-            if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
-          #endif
-
-          if (homed) {
-            #if ENABLED(DELTA) || Z_HOME_DIR != -1
-              if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
-            #endif
-            if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
-            if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
-            if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
-            if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
-            if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
-          }
-
-        #endif // HAS_LCD_MENU
-
-        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
-        return true;
-      }
-
-    #endif // !HAS_ADC_BUTTONS
-
-    return false;
-  }
-
-#endif // IS_RRW_KEYPAD && HAS_ENCODER_ACTION
-
-/**
- * Status Screen
- *
- * This is very display-dependent, so the lcd implementation draws this.
- */
-
-#if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
-  millis_t MarlinUI::progress_bar_ms; // = 0
-  #if PROGRESS_MSG_EXPIRE > 0
-    millis_t MarlinUI::expire_status_ms; // = 0
-  #endif
-#endif
-
-void MarlinUI::status_screen() {
-
-  TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
-
-  #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
-
-    //
-    // HD44780 implements the following message blinking and
-    // message expiration because Status Line and Progress Bar
-    // share the same line on the display.
-    //
-
-    #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
-      #define GOT_MS
-      const millis_t ms = millis();
-    #endif
-
-    // If the message will blink rather than expire...
-    #if DISABLED(PROGRESS_MSG_ONCE)
-      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
-        progress_bar_ms = ms;
-    #endif
-
-    #if PROGRESS_MSG_EXPIRE > 0
-
-      // Handle message expire
-      if (expire_status_ms) {
-
-        // Expire the message if a job is active and the bar has ticks
-        if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
-          if (ELAPSED(ms, expire_status_ms)) {
-            status_message[0] = '\0';
-            expire_status_ms = 0;
-          }
-        }
-        else {
-          // Defer message expiration before bar appears
-          // and during any pause (not just SD)
-          expire_status_ms += LCD_UPDATE_INTERVAL;
-        }
-      }
-
-    #endif // PROGRESS_MSG_EXPIRE
-
-  #endif // LCD_PROGRESS_BAR
-
-  #if HAS_LCD_MENU
-    if (use_click()) {
-      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-        next_filament_display = millis() + 5000UL;  // Show status message for 5s
-      #endif
-      goto_screen(menu_main);
-      #if DISABLED(NO_LCD_REINIT)
-        init_lcd(); // May revive the LCD if static electricity killed it
-      #endif
-      return;
-    }
-
-  #endif
-
-  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
-
-    const int16_t old_frm = feedrate_percentage;
-          int16_t new_frm = old_frm + int16_t(encoderPosition);
-
-    // Dead zone at 100% feedrate
-    if (old_frm == 100) {
-      if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
-        new_frm -= ENCODER_FEEDRATE_DEADZONE;
-      else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
-        new_frm += ENCODER_FEEDRATE_DEADZONE;
-      else
-        new_frm = old_frm;
-    }
-    else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
-      new_frm = 100;
-
-    LIMIT(new_frm, 10, 999);
-
-    if (old_frm != new_frm) {
-      feedrate_percentage = new_frm;
-      encoderPosition = 0;
-      #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
-        static millis_t next_beep;
-        #ifndef GOT_MS
-          const millis_t ms = millis();
-        #endif
-        if (ELAPSED(ms, next_beep)) {
-          buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
-          next_beep = ms + 500UL;
-        }
-      #endif
-    }
-
-  #endif // ULTIPANEL_FEEDMULTIPLY
-
-  draw_status_screen();
-}
-
-void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
-  init();
-  status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
-  TERN_(HAS_LCD_MENU, return_to_status());
-
-  // RED ALERT. RED ALERT.
-  #ifdef LED_BACKLIGHT_TIMEOUT
-    leds.set_color(LEDColorRed());
-    #ifdef NEOPIXEL_BKGD_LED_INDEX
-      neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
-      neo.show();
-    #endif
-  #endif
-
-  draw_kill_screen();
-}
-
-void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
-
-  TERN_(HAS_LCD_MENU, refresh());
-
-  #if HAS_ENCODER_ACTION
-    if (clear_buttons) buttons = 0;
-    next_button_update_ms = millis() + 500;
-  #else
-    UNUSED(clear_buttons);
-  #endif
-
-  #if HAS_CHIRP
-    chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_LCD_MENU
-      delay(10);
-    #endif
-  #endif
-}
-
-////////////////////////////////////////////
-/////////////// Manual Move ////////////////
-////////////////////////////////////////////
-
-#if HAS_LCD_MENU
-
-  ManualMove MarlinUI::manual_move{};
-
-  millis_t ManualMove::start_time = 0;
-  float ManualMove::menu_scale = 1;
-  TERN_(IS_KINEMATIC, float ManualMove::offset = 0);
-  TERN_(IS_KINEMATIC, bool ManualMove::processing = false);
-  TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
-  uint8_t ManualMove::axis = (uint8_t)NO_AXIS;
-
-  /**
-   * If a manual move has been posted and its time has arrived, and if the planner
-   * has a space for it, then add a linear move to current_position the planner.
-   *
-   * If any manual move needs to be interrupted, make sure to force a manual move
-   * by setting manual_move.start_time to millis() after updating current_position.
-   *
-   * To post a manual move:
-   *   - Update current_position to the new place you want to go.
-   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES for diagonal moves.
-   *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
-   *
-   * For kinematic machines:
-   *   - Set manual_move.offset to modify one axis and post the move.
-   *     This is used to achieve more rapid stepping on kinematic machines.
-   *
-   * Currently used by the _lcd_move_xyz function in menu_motion.cpp
-   * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
-   */
-  void ManualMove::task() {
-
-    if (processing) return;   // Prevent re-entry from idle() calls
-
-    // Add a manual move to the queue?
-    if (axis != (uint8_t)NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
-
-      const feedRate_t fr_mm_s = (uint8_t(axis) <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
-
-      #if IS_KINEMATIC
-
-        #if HAS_MULTI_EXTRUDER
-          const int8_t old_extruder = active_extruder;
-          if (axis == E_AXIS) active_extruder = e_index;
-        #endif
-
-        // Apply a linear offset to a single axis
-        destination = current_position;
-        if (axis <= XYZE) destination[axis] += offset;
-
-        // Reset for the next move
-        offset = 0;
-        axis = (uint8_t)NO_AXIS;
-
-        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
-        // move_to_destination. This will cause idle() to be called, which can then call this function while the
-        // previous invocation is being blocked. Modifications to offset shouldn't be made while
-        // processing is true or the planner will get out of sync.
-        processing = true;
-        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
-        processing = false;
-
-        TERN_(HAS_MULTI_EXTRUDER, active_extruder = old_extruder);
-
-      #else
-
-        // For Cartesian / Core motion simply move to the current_position
-        planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
-
-        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
-
-        axis = (uint8_t)NO_AXIS;
-
-      #endif
-    }
-  }
-
-  //
-  // Tell ui.update() to start a move to current_position after a short delay.
-  //
-  void ManualMove::soon(AxisEnum move_axis
-    #if MULTI_MANUAL
-      , const int8_t eindex/*=-1*/
-    #endif
-  ) {
-    #if MULTI_MANUAL
-      if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
-    #endif
-    start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
-    axis = (uint8_t)move_axis;
-    //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
-  }
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    void MarlinUI::external_encoder() {
-      if (external_control && encoderDiff) {
-        ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
-        encoderDiff = 0;                  // Hide encoder events from the screen handler
-        refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
-      }
-    }
-
-  #endif
-
-#endif // HAS_LCD_MENU
-
-/**
- * Update the LCD, read encoder buttons, etc.
- *   - Read button states
- *   - Check the SD Card slot state
- *   - Act on RepRap World keypad input
- *   - Update the encoder position
- *   - Apply acceleration to the encoder position
- *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
- *   - Reset the Info Screen timeout if there's any input
- *   - Update status indicators, if any
- *
- *   Run the current LCD menu handler callback function:
- *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
- *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
- *   - Call the menu handler. Menu handlers should do the following:
- *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
- *       (Encoder events automatically set lcdDrawUpdate for you.)
- *     - if (should_draw()) { redraw }
- *     - Before exiting the handler set lcdDrawUpdate to:
- *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
- *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
- *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
- *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
- *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
- *             so don't change lcdDrawUpdate without considering this.
- *
- *   After the menu handler callback runs (or not):
- *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
- *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
- *
- * This function is only called from the main thread.
- */
-
-LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-millis_t next_lcd_update_ms;
-#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
-  millis_t MarlinUI::return_to_status_ms = 0;
-#endif
-
-void MarlinUI::update() {
-
-  static uint16_t max_display_update_time = 0;
-  millis_t ms = millis();
-
-  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
-    #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
-  #else
-    #define RESET_STATUS_TIMEOUT() NOOP
-  #endif
-
-  #ifdef LED_BACKLIGHT_TIMEOUT
-    leds.update_timeout(powersupply_on);
-  #endif
-
-  #if HAS_LCD_MENU
-
-    // Handle any queued Move Axis motion
-    manual_move.task();
-
-    // Update button states for button_pressed(), etc.
-    // If the state changes the next update may be delayed 300-500ms.
-    update_buttons();
-
-    // If the action button is pressed...
-    static bool wait_for_unclick; // = false
-
-    auto do_click = [&]{
-      wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
-      lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
-      wait_for_user = false;                          //  - Any click clears wait for user
-      quick_feedback();                               //  - Always make a click sound
-    };
-
-    #if HAS_TOUCH_XPT2046
-      if (touch_buttons) {
-        RESET_STATUS_TIMEOUT();
-        if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
-          if (ELAPSED(ms, next_button_update_ms)) {
-            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
-            if (touch_buttons & EN_A) encoderDiff *= -1;
-            TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
-            next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
-            if (!wait_for_unclick) {
-              next_button_update_ms += 250;               // Longer delay on first press
-              wait_for_unclick = true;                    // Avoid Back/Select click while repeating
-              chirp();
-            }
-          }
-        }
-        else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
-          do_click();
-      }
-      else // keep wait_for_unclick value
-
-    #endif // HAS_TOUCH_XPT2046
-
-      {
-        // Integrated LCD click handling via button_pressed
-        if (!external_control && button_pressed()) {
-          if (!wait_for_unclick) do_click();              // Handle the click
-        }
-        else
-          wait_for_unclick = false;
-      }
-
-    if (LCD_BACK_CLICKED()) {
-      quick_feedback();
-      goto_previous_screen();
-    }
-
-  #endif // HAS_LCD_MENU
-
-  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
-
-    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
-
-    #if HAS_TOUCH_XPT2046
-
-      if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
-
-      TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
-
-    #endif
-
-    TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
-
-    #if HAS_ENCODER_ACTION
-
-      TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
-
-      if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
-        RESET_STATUS_TIMEOUT();
-
-      uint8_t abs_diff = ABS(encoderDiff);
-
-      #if ENCODER_PULSES_PER_STEP > 1
-        // When reversing the encoder direction, a movement step can be missed because
-        // encoderDiff has a non-zero residual value, making the controller unresponsive.
-        // The fix clears the residual value when the encoder is idle.
-        // Also check if past half the threshold to compensate for missed single steps.
-        static int8_t lastEncoderDiff;
-
-        // Timeout? No decoder change since last check. 10 or 20 times per second.
-        if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
-          encoderDiff = 0;                                            // Clear residual pulses.
-        else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
-          abs_diff = epps;                                            // Treat as a full step size
-          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
-        }
-        lastEncoderDiff = encoderDiff;
-      #endif
-
-      const bool encoderPastThreshold = (abs_diff >= epps);
-      if (encoderPastThreshold || lcd_clicked) {
-        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
-
-          #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
-
-            int32_t encoderMultiplier = 1;
-
-            if (encoderRateMultiplierEnabled) {
-              const float encoderMovementSteps = float(abs_diff) / epps;
-
-              if (lastEncoderMovementMillis) {
-                // Note that the rate is always calculated between two passes through the
-                // loop and that the abs of the encoderDiff value is tracked.
-                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
-
-                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
-                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
-
-                // Enable to output the encoder steps per second value
-                //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                  SERIAL_ECHO_START();
-                  SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
-                  SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
-                  SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                  SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                  SERIAL_EOL();
-                #endif
-              }
-
-              lastEncoderMovementMillis = ms;
-            } // encoderRateMultiplierEnabled
-
-          #else
-
-            constexpr int32_t encoderMultiplier = 1;
-
-          #endif // ENCODER_RATE_MULTIPLIER
-
-          encoderPosition += (encoderDiff * encoderMultiplier) / epps;
-          encoderDiff = 0;
-        }
-
-        RESET_STATUS_TIMEOUT();
-
-        refresh(LCDVIEW_REDRAW_NOW);
-
-        #ifdef LED_BACKLIGHT_TIMEOUT
-          leds.reset_timeout(ms);
-        #endif
-      }
-
-    #endif
-
-    // This runs every ~100ms when idling often enough.
-    // Instead of tracking changes just redraw the Status Screen once per second.
-    if (on_status_screen() && !lcd_status_update_delay--) {
-      lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
-      if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
-      refresh(LCDVIEW_REDRAW_NOW);
-    }
-
-    #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
-      // If scrolling of long file names is enabled and we are in the sd card menu,
-      // cause a refresh to occur until all the text has scrolled into view.
-      if (currentScreen == menu_media && !lcd_status_update_delay--) {
-        lcd_status_update_delay = 4;
-        if (++filename_scroll_pos > filename_scroll_max) {
-          filename_scroll_pos = 0;
-          lcd_status_update_delay = 12;
-        }
-        refresh(LCDVIEW_REDRAW_NOW);
-        RESET_STATUS_TIMEOUT();
-      }
-    #endif
-
-    // Then we want to use only 50% of the time
-    const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
-
-    if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
-
-      // Change state of drawing flag between screen updates
-      if (!drawing_screen) switch (lcdDrawUpdate) {
-        case LCDVIEW_CALL_NO_REDRAW:
-          refresh(LCDVIEW_NONE);
-          break;
-        case LCDVIEW_CLEAR_CALL_REDRAW:
-        case LCDVIEW_CALL_REDRAW_NEXT:
-          refresh(LCDVIEW_REDRAW_NOW);
-        case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
-        case LCDVIEW_NONE:
-          break;
-      } // switch
-
-      TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
-
-      #if HAS_MARLINUI_U8GLIB
-
-        #if ENABLED(LIGHTWEIGHT_UI)
-          const bool in_status = on_status_screen(),
-                     do_u8g_loop = !in_status;
-          lcd_in_status(in_status);
-          if (in_status) status_screen();
-        #else
-          constexpr bool do_u8g_loop = true;
-        #endif
-
-        if (do_u8g_loop) {
-          if (!drawing_screen) {                // If not already drawing pages
-            u8g.firstPage();                    // Start the first page
-            drawing_screen = first_page = true; // Flag as drawing pages
-          }
-          set_font(FONT_MENU);                  // Setup font for every page draw
-          u8g.setColorIndex(1);                 // And reset the color
-          run_current_screen();                 // Draw and process the current screen
-          first_page = false;
-
-          // The screen handler can clear drawing_screen for an action that changes the screen.
-          // If still drawing and there's another page, update max-time and return now.
-          // The nextPage will already be set up on the next call.
-          if (drawing_screen && (drawing_screen = u8g.nextPage())) {
-            if (on_status_screen())
-              NOLESS(max_display_update_time, millis() - ms);
-            return;
-          }
-        }
-
-      #else
-
-        run_current_screen();
-
-      #endif
-
-      TERN_(HAS_LCD_MENU, lcd_clicked = false);
-
-      // Keeping track of the longest time for an individual LCD update.
-      // Used to do screen throttling when the planner starts to fill up.
-      if (on_status_screen())
-        NOLESS(max_display_update_time, millis() - ms);
-    }
-
-    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
-      // Return to Status Screen after a timeout
-      if (on_status_screen() || defer_return_to_status)
-        RESET_STATUS_TIMEOUT();
-      else if (ELAPSED(ms, return_to_status_ms))
-        return_to_status();
-    #endif
-
-    // Change state of drawing flag between screen updates
-    if (!drawing_screen) switch (lcdDrawUpdate) {
-      case LCDVIEW_CLEAR_CALL_REDRAW:
-        clear_lcd(); break;
-      case LCDVIEW_REDRAW_NOW:
-        refresh(LCDVIEW_NONE);
-      case LCDVIEW_NONE:
-      case LCDVIEW_CALL_REDRAW_NEXT:
-      case LCDVIEW_CALL_NO_REDRAW:
-      default: break;
-    } // switch
-
-  } // ELAPSED(ms, next_lcd_update_ms)
-
-  TERN_(HAS_GRAPHICAL_TFT, tft_idle());
-}
-
-#if HAS_ADC_BUTTONS
-
-  typedef struct {
-    uint16_t ADCKeyValueMin, ADCKeyValueMax;
-    uint8_t  ADCKeyNo;
-  } _stADCKeypadTable_;
-
-  #ifndef ADC_BUTTONS_VALUE_SCALE
-    #define ADC_BUTTONS_VALUE_SCALE       1.0  // for the power voltage equal to the reference voltage
-  #endif
-  #ifndef ADC_BUTTONS_R_PULLUP
-    #define ADC_BUTTONS_R_PULLUP          4.7  // common pull-up resistor in the voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_LEFT_R_PULLDOWN
-    #define ADC_BUTTONS_LEFT_R_PULLDOWN   0.47 // pull-down resistor for LEFT button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_RIGHT_R_PULLDOWN
-    #define ADC_BUTTONS_RIGHT_R_PULLDOWN  4.7  // pull-down resistor for RIGHT button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_UP_R_PULLDOWN
-    #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
-    #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
-    #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
-  #endif
-
-  // Calculate the ADC value for the voltage divider with specified pull-down resistor value
-  #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
-
-  static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
-                                adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
-  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
-    // VALUE_MIN, VALUE_MAX, KEY
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F2     }, // F2
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F3     }, // F3
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + adc_button_tolerance, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + adc_button_tolerance, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
-  };
-
-  uint8_t get_ADC_keyValue() {
-    if (thermalManager.ADCKey_count >= 16) {
-      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
-      thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
-      thermalManager.ADCKey_count = 0;
-      if (currentkpADCValue < adc_other_button)
-        LOOP_L_N(i, ADC_KEY_NUM) {
-          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
-                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
-          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
-        }
-    }
-    return 0;
-  }
-
-#endif // HAS_ADC_BUTTONS
-
-#if HAS_ENCODER_ACTION
-
-  /**
-   * Read encoder buttons from the hardware registers
-   * Warning: This function is called from interrupt context!
-   */
-  void MarlinUI::update_buttons() {
-    const millis_t now = millis();
-    if (ELAPSED(now, next_button_update_ms)) {
-
-      #if HAS_DIGITAL_BUTTONS
-
-        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
-
-          uint8_t newbutton = 0;
-
-          #if BUTTON_EXISTS(EN1)
-            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-          #endif
-          #if BUTTON_EXISTS(EN2)
-            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-          #endif
-          #if BUTTON_EXISTS(ENC)
-            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-          #endif
-          #if BUTTON_EXISTS(BACK)
-            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
-          #endif
-
-        #else
-
-          constexpr uint8_t newbutton = 0;
-
-        #endif
-
-        //
-        // Directional buttons
-        //
-        #if ANY_BUTTON(UP, DWN, LFT, RT)
-
-          const int8_t pulses = epps * encoderDirection;
-
-          if (false) {
-            // for the else-ifs below
-          }
-          #if BUTTON_EXISTS(UP)
-            else if (BUTTON_PRESSED(UP)) {
-              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(DWN)
-            else if (BUTTON_PRESSED(DWN)) {
-              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(LFT)
-            else if (BUTTON_PRESSED(LFT)) {
-              encoderDiff = -pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(RT)
-            else if (BUTTON_PRESSED(RT)) {
-              encoderDiff = pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-
-        #endif // UP || DWN || LFT || RT
-
-        buttons = (newbutton
-          #if HAS_SLOW_BUTTONS
-            | slow_buttons
-          #endif
-          #if BOTH(HAS_TOUCH_XPT2046, HAS_ENCODER_ACTION)
-            | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
-          #endif
-        );
-
-      #elif HAS_ADC_BUTTONS
-
-        buttons = 0;
-
-      #endif
-
-      #if HAS_ADC_BUTTONS
-        if (keypad_buttons == 0) {
-          const uint8_t b = get_ADC_keyValue();
-          if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
-        }
-      #endif
-
-      #if HAS_SHIFT_ENCODER
-        /**
-         * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
-         * These values are independent of which pins are used for EN_A / EN_B indications.
-         * The rotary encoder part is also independent of the LCD chipset.
-         */
-        uint8_t val = 0;
-        WRITE(SHIFT_LD, LOW);
-        WRITE(SHIFT_LD, HIGH);
-        LOOP_L_N(i, 8) {
-          val >>= 1;
-          if (READ(SHIFT_OUT)) SBI(val, 7);
-          WRITE(SHIFT_CLK, HIGH);
-          WRITE(SHIFT_CLK, LOW);
-        }
-        TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
-      #endif
-
-      #if IS_TFTGLCD_PANEL
-        next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
-        buttons = slow_buttons;
-        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
-      #endif
-
-    } // next_button_update_ms
-
-    #if HAS_ENCODER_WHEEL
-      static uint8_t lastEncoderBits;
-
-      #define encrot0 0
-      #define encrot1 2
-      #define encrot2 3
-      #define encrot3 1
-
-      // Manage encoder rotation
-      #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
-
-      uint8_t enc = 0;
-      if (buttons & EN_A) enc |= B01;
-      if (buttons & EN_B) enc |= B10;
-      if (enc != lastEncoderBits) {
-        switch (enc) {
-          case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
-          case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
-          case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
-          case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
-        }
-        #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
-          external_encoder();
-        #endif
-        lastEncoderBits = enc;
-      }
-
-    #endif // HAS_ENCODER_WHEEL
-  }
-
-#endif // HAS_ENCODER_ACTION
-
-#endif // HAS_WIRED_LCD
-
-#if HAS_DISPLAY
-
-  #if ENABLED(EXTENSIBLE_UI)
-    #include "extui/ui_api.h"
-  #endif
-
-  ////////////////////////////////////////////
-  /////////////// Status Line ////////////////
-  ////////////////////////////////////////////
-
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    void MarlinUI::advance_status_scroll() {
-      // Advance by one UTF8 code-word
-      if (status_scroll_offset < utf8_strlen(status_message))
-        while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
-      else
-        status_scroll_offset = 0;
-    }
-    char* MarlinUI::status_and_len(uint8_t &len) {
-      char *out = status_message + status_scroll_offset;
-      len = utf8_strlen(out);
-      return out;
-    }
-  #endif
-
-  void MarlinUI::finish_status(const bool persist) {
-
-    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
-      UNUSED(persist);
-    #endif
-
-    #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-      const millis_t ms = millis();
-    #endif
-
-    #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
-      progress_bar_ms = ms;
-      #if PROGRESS_MSG_EXPIRE > 0
-        expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
-      #endif
-    #endif
-
-    #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-      next_filament_display = ms + 5000UL; // Show status message for 5s
-    #endif
-
-    #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
-      status_scroll_offset = 0;
-    #endif
-
-    TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
-  }
-
-  bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
-
-  void MarlinUI::set_status(const char * const message, const bool persist) {
-    if (alert_level) return;
-
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
-
-    // Here we have a problem. The message is encoded in UTF8, so
-    // arbitrarily cutting it will be a problem. We MUST be sure
-    // that there is no cutting in the middle of a multibyte character!
-
-    // Get a pointer to the null terminator
-    const char* pend = message + strlen(message);
-
-    //  If length of supplied UTF8 string is greater than
-    // our buffer size, start cutting whole UTF8 chars
-    while ((pend - message) > MAX_MESSAGE_LENGTH) {
-      --pend;
-      while (!START_OF_UTF8_CHAR(*pend)) --pend;
-    };
-
-    // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - message;
-    strncpy(status_message, message, maxLen);
-    status_message[maxLen] = '\0';
-
-    finish_status(persist);
-  }
-
-  #include <stdarg.h>
-
-  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-    if (level < alert_level) return;
-    alert_level = level;
-    va_list args;
-    va_start(args, fmt);
-    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
-    va_end(args);
-    finish_status(level > 0);
-  }
-
-  void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
-    if (level < 0) level = alert_level = 0;
-    if (level < alert_level) return;
-    alert_level = level;
-
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(message));
-
-    // Since the message is encoded in UTF8 it must
-    // only be cut on a character boundary.
-
-    // Get a pointer to the null terminator
-    PGM_P pend = message + strlen_P(message);
-
-    // If length of supplied UTF8 string is greater than
-    // the buffer size, start cutting whole UTF8 chars
-    while ((pend - message) > MAX_MESSAGE_LENGTH) {
-      --pend;
-      while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
-    };
-
-    // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - message;
-    strncpy_P(status_message, message, maxLen);
-    status_message[maxLen] = '\0';
-
-    finish_status(level > 0);
-  }
-
-  void MarlinUI::set_alert_status_P(PGM_P const message) {
-    set_status_P(message, 1);
-    TERN_(HAS_LCD_MENU, return_to_status());
-  }
-
-  PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
-
-  /**
-   * Reset the status message
-   */
-  void MarlinUI::reset_status(const bool no_welcome) {
-    PGM_P printing = GET_TEXT(MSG_PRINTING);
-    PGM_P welcome  = GET_TEXT(WELCOME_MSG);
-    #if SERVICE_INTERVAL_1 > 0
-      static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
-    #endif
-    #if SERVICE_INTERVAL_2 > 0
-      static PGMSTR(service2, "> " SERVICE_NAME_2 "!");
-    #endif
-    #if SERVICE_INTERVAL_3 > 0
-      static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
-    #endif
-    PGM_P msg;
-    if (printingIsPaused())
-      msg = print_paused;
-    #if ENABLED(SDSUPPORT)
-      else if (IS_SD_PRINTING())
-        return set_status(card.longest_filename(), true);
-    #endif
-    else if (print_job_timer.isRunning())
-      msg = printing;
-
-    #if SERVICE_INTERVAL_1 > 0
-      else if (print_job_timer.needsService(1)) msg = service1;
-    #endif
-    #if SERVICE_INTERVAL_2 > 0
-      else if (print_job_timer.needsService(2)) msg = service2;
-    #endif
-    #if SERVICE_INTERVAL_3 > 0
-      else if (print_job_timer.needsService(3)) msg = service3;
-    #endif
-
-    else if (!no_welcome)
-      msg = welcome;
-    else
-      return;
-
-    set_status_P(msg, -1);
-  }
-
-  void MarlinUI::abort_print() {
-    #if ENABLED(SDSUPPORT)
-      wait_for_heatup = wait_for_user = false;
-      card.flag.abort_sd_printing = true;
-    #endif
-    #ifdef ACTION_ON_CANCEL
-      host_action_cancel();
-    #endif
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
-    print_job_timer.stop();
-    set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
-    TERN_(HAS_LCD_MENU, return_to_status());
-  }
-
-  #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
-    #include "../gcode/queue.h"
-  #endif
-
-  void MarlinUI::pause_print() {
-    #if HAS_LCD_MENU
-      synchronize(GET_TEXT(MSG_PAUSING));
-      defer_status_screen();
-    #endif
-
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
-
-    set_status_P(print_paused);
-
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      TERN_(HAS_WIRED_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
-      queue.inject_P(PSTR("M25 P\nM24"));
-    #elif ENABLED(SDSUPPORT)
-      queue.inject_P(PSTR("M25"));
-    #elif defined(ACTION_ON_PAUSE)
-      host_action_pause();
-    #endif
-  }
-
-  void MarlinUI::resume_print() {
-    reset_status();
-    TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
-    if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
-    #ifdef ACTION_ON_RESUME
-      host_action_resume();
-    #endif
-    print_job_timer.start(); // Also called by M24
-  }
-
-  #if HAS_PRINT_PROGRESS
-
-    MarlinUI::progress_t MarlinUI::_get_progress() {
-      return (
-        TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
-        #if ENABLED(SDSUPPORT)
-          ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
-        #endif
-      );
-    }
-
-  #endif
-
-  #if HAS_TOUCH_XPT2046
-
-    //
-    // Screen Click
-    //  - On menu screens move directly to the touched item
-    //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
-    //  - On select screens (and others) touch the Right Half for +, Left Half for -
-    //  - On edit screens, touch Up Half for -,  Bottom Half to +
-    //
-    void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
-      const millis_t now = millis();
-      if (PENDING(now, next_button_update_ms)) return;
-      next_button_update_ms = now + repeat_delay;    // Assume the repeat delay
-      const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
-                   ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
-      if (on_edit_screen)
-        encoderDiff = epps * ydir;
-      else if (screen_items > 0) {
-        // Last 5 cols act as a scroll :-)
-        if (col > (LCD_WIDTH) - 5)
-          // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
-          encoderDiff = epps * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
-        else
-          encoderDiff = epps * (row - encoderPosition + encoderTopLine);
-      }
-      else if (!on_status_screen())
-        encoderDiff = epps * xdir;
-    }
-
-  #endif
-
-#else // !HAS_DISPLAY
-
-  //
-  // Send the status line as a host notification
-  //
-  void MarlinUI::set_status(const char * const message, const bool) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
-  }
-  void MarlinUI::set_status_P(PGM_P message, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
-  }
-  void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
-  }
-
-#endif // !HAS_DISPLAY
-
-#if ENABLED(SDSUPPORT)
-
-  void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
-    if (old_status == status) {
-      TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
-      return;
-    }
-
-    if (status) {
-      if (old_status < 2) {
-        TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
-        set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
-      }
-    }
-    else {
-      if (old_status < 2) {
-        TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
-        #if PIN_EXISTS(SD_DETECT)
-          set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
-          #if HAS_LCD_MENU
-            if (!defer_return_to_status) return_to_status();
-          #endif
-        #endif
-      }
-    }
-
-    #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
-      init_lcd(); // Revive a noisy shared SPI LCD
-    #endif
-
-    refresh();
-
-    #if HAS_WIRED_LCD || defined(LED_BACKLIGHT_TIMEOUT)
-      const millis_t ms = millis();
-    #endif
-
-    TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
-
-    #ifdef LED_BACKLIGHT_TIMEOUT
-      leds.reset_timeout(ms);
-    #endif
-  }
-
-#endif // SDSUPPORT
-
-#if HAS_LCD_MENU
-  void MarlinUI::reset_settings() { settings.reset(); completion_feedback(); }
-#endif
-
-#if ENABLED(EEPROM_SETTINGS)
-
-  #if HAS_LCD_MENU
-    void MarlinUI::init_eeprom() {
-      const bool good = settings.init_eeprom();
-      completion_feedback(good);
-      return_to_status();
-    }
-    void MarlinUI::load_settings() {
-      const bool good = settings.load();
-      completion_feedback(good);
-    }
-    void MarlinUI::store_settings() {
-      const bool good = settings.save();
-      completion_feedback(good);
-    }
-  #endif
-
-  #if DISABLED(EEPROM_AUTO_INIT)
-
-    static inline PGM_P eeprom_err(const uint8_t msgid) {
-      switch (msgid) {
-        default:
-        case 0: return GET_TEXT(MSG_ERR_EEPROM_CRC);
-        case 1: return GET_TEXT(MSG_ERR_EEPROM_INDEX);
-        case 2: return GET_TEXT(MSG_ERR_EEPROM_VERSION);
-      }
-    }
-
-    void MarlinUI::eeprom_alert(const uint8_t msgid) {
-      #if HAS_LCD_MENU
-        editable.uint8 = msgid;
-        goto_screen([]{
-          PGM_P const restore_msg = GET_TEXT(MSG_INIT_EEPROM);
-          char msg[utf8_strlen_P(restore_msg) + 1];
-          strcpy_P(msg, restore_msg);
-          MenuItem_confirm::select_screen(
-            GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
-            init_eeprom, return_to_status,
-            eeprom_err(editable.uint8), msg, PSTR("?")
-          );
-        });
-      #else
-        set_status_P(eeprom_err(msgid));
-      #endif
-    }
-
-  #endif // EEPROM_AUTO_INIT
-
-#endif // EEPROM_SETTINGS

commit 0b80841c38dcd8259821f72dc40c194e67042c5d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 16 18:19:48 2020 -0300

    Fix Color UI external_control, wait_for_release (#19771)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index da9c3e2456..25f5afc71d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1471,24 +1471,20 @@ void MarlinUI::update() {
     #endif
 
     else if (!no_welcome)
       msg = welcome;
     else
       return;
 
     set_status_P(msg, -1);
   }
 
-  #if ENABLED(SDSUPPORT)
-    extern bool wait_for_user, wait_for_heatup;
-  #endif
-
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
     print_job_timer.stop();

commit f6ffbe548c81abfeecc996c8f2bffd27cabe0014
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 15 03:00:27 2020 -0500

    TFT Presets, Generic options, Sanity checks (#19723)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7003d13fdd..da9c3e2456 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -393,21 +393,21 @@ bool MarlinUI::get_blink() {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
-#if BOTH(REPRAPWORLD_KEYPAD, HAS_ENCODER_ACTION)
+#if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
 
   volatile uint8_t MarlinUI::keypad_buttons;
 
   #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
@@ -425,21 +425,21 @@ bool MarlinUI::get_blink() {
 
   bool MarlinUI::handle_keypad() {
 
     #if HAS_ADC_BUTTONS
 
       #define ADC_MIN_KEY_DELAY 100
       if (keypad_buttons) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           #if HAS_LCD_MENU
-            if (encoderDirection == -(ENCODERBASE)) { // ADC_KEYPAD forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
+            if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
                    if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             }
             else
           #endif
           {
             #if HAS_LCD_MENU
                    if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
@@ -490,26 +490,26 @@ bool MarlinUI::get_blink() {
             if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
             if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
           }
 
         #endif // HAS_LCD_MENU
 
         if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
         return true;
       }
 
-    #endif // !ADC_KEYPAD
+    #endif // !HAS_ADC_BUTTONS
 
     return false;
   }
 
-#endif // REPRAPWORLD_KEYPAD
+#endif // IS_RRW_KEYPAD && HAS_ENCODER_ACTION
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0

commit bcf65aa503b7e827744ba53bd00a7b6a43af2725
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 12 00:59:30 2020 -0500

    Fix screen click reading too often (#19696)
    
    Co-authored-by: andreibobirica <39415547+andreibobirica@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 58e6d9473b..7003d13fdd 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1546,26 +1546,29 @@ void MarlinUI::update() {
   #if HAS_TOUCH_XPT2046
 
     //
     // Screen Click
     //  - On menu screens move directly to the touched item
     //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
     //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
+      const millis_t now = millis();
+      if (PENDING(now, next_button_update_ms)) return;
+      next_button_update_ms = now + repeat_delay;    // Assume the repeat delay
       const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
                    ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
       if (on_edit_screen)
         encoderDiff = epps * ydir;
       else if (screen_items > 0) {
-        // Last 3 cols act as a scroll :-)
+        // Last 5 cols act as a scroll :-)
         if (col > (LCD_WIDTH) - 5)
           // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
           encoderDiff = epps * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
         else
           encoderDiff = epps * (row - encoderPosition + encoderTopLine);
       }
       else if (!on_status_screen())
         encoderDiff = epps * xdir;
     }
 

commit 6831341ab483a49d7daad4c704bb684d3cbbf075
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 9 16:50:17 2020 -0500

    Batch appercase hex values

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 92dd63389f..58e6d9473b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -34,21 +34,21 @@
 #include "ultralcd.h"
 MarlinUI ui;
 
 #if HAS_DISPLAY
   #include "../module/printcounter.h"
   #include "../MarlinCore.h"
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
   #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
-    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
+    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
   #endif
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
   bool MarlinUI::wait_for_move; // = false
 #endif
 
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_WIRED_LCD

commit 631457ffea46debd43079137e09bc2d36b5d4fe4
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 9 08:25:23 2020 -0300

    Support for Debug Codes - Dnnn (#19225)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index de534e4023..92dd63389f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -116,25 +116,29 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_WIRED_LCD
 
 #if HAS_MARLINUI_U8GLIB
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
-#include "../module/settings.h"
+
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
 
+#if HAS_LCD_MENU
+  #include "../module/settings.h"
+#endif
+
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ADC_BUTTONS
   #include "../module/thermistor/thermistors.h"

commit 27bdf4b24e8da06ea7923b6382f38b5fb6292914
Author: Serhiy-K <52166448+Serhiy-K@users.noreply.github.com>
Date:   Mon Sep 28 09:52:38 2020 +0300

    MarlinUI for SPI/I2C TFT-GLCD character-based display bridge (#19375)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 89dc0adaf3..de534e4023 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -499,32 +499,32 @@ bool MarlinUI::get_blink() {
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
-#if ENABLED(LCD_PROGRESS_BAR)
+#if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
     millis_t MarlinUI::expire_status_ms; // = 0
   #endif
 #endif
 
 void MarlinUI::status_screen() {
 
   TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
 
-  #if ENABLED(LCD_PROGRESS_BAR)
+  #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
     #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
       #define GOT_MS
       const millis_t ms = millis();
@@ -908,21 +908,21 @@ void MarlinUI::update() {
           encoderDiff = 0;                                            // Clear residual pulses.
         else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
           abs_diff = epps;                                            // Treat as a full step size
           encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
         }
         lastEncoderDiff = encoderDiff;
       #endif
 
       const bool encoderPastThreshold = (abs_diff >= epps);
       if (encoderPastThreshold || lcd_clicked) {
-        if (encoderPastThreshold) {
+        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
           #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
               const float encoderMovementSteps = float(abs_diff) / epps;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
@@ -1253,20 +1253,26 @@ void MarlinUI::update() {
         WRITE(SHIFT_LD, HIGH);
         LOOP_L_N(i, 8) {
           val >>= 1;
           if (READ(SHIFT_OUT)) SBI(val, 7);
           WRITE(SHIFT_CLK, HIGH);
           WRITE(SHIFT_CLK, LOW);
         }
         TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
       #endif
 
+      #if IS_TFTGLCD_PANEL
+        next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
+        buttons = slow_buttons;
+        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+      #endif
+
     } // next_button_update_ms
 
     #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3
       #define encrot3 1
 
@@ -1324,21 +1330,21 @@ void MarlinUI::update() {
   void MarlinUI::finish_status(const bool persist) {
 
     #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
       UNUSED(persist);
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       const millis_t ms = millis();
     #endif
 
-    #if ENABLED(LCD_PROGRESS_BAR)
+    #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
       progress_bar_ms = ms;
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = ms + 5000UL; // Show status message for 5s
     #endif
 

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fc55c3c2f6..89dc0adaf3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -44,32 +44,32 @@ MarlinUI ui;
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
   bool MarlinUI::wait_for_move; // = false
 #endif
 
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
-#if HAS_SPI_LCD
+#if HAS_WIRED_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
-#if EITHER(HAS_SPI_LCD, EXTENSIBLE_UI)
+#if EITHER(HAS_WIRED_LCD, EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
   #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
 #endif
@@ -107,23 +107,23 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
     #endif
 
     #define _PLBL(N) preheat_##N##_label,
     static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
 
     return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
   }
 #endif
 
-#if HAS_SPI_LCD
+#if HAS_WIRED_LCD
 
-#if HAS_GRAPHICAL_LCD
+#if HAS_MARLINUI_U8GLIB
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/settings.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
@@ -160,21 +160,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
 millis_t MarlinUI::next_button_update_ms; // = 0
 
-#if HAS_GRAPHICAL_LCD
+#if HAS_MARLINUI_U8GLIB
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
 #if ENABLED(SDSUPPORT)
@@ -365,21 +365,21 @@ void MarlinUI::init() {
       OUT_WRITE(SHIFT_LD, HIGH);
       #if defined(SHIFT_EN) && SHIFT_EN >= 0
         OUT_WRITE(SHIFT_EN, LOW);
       #endif
       SET_INPUT_PULLUP(SHIFT_OUT);
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
-  #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
+  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
@@ -866,21 +866,21 @@ void MarlinUI::update() {
           wait_for_unclick = false;
       }
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
       goto_previous_screen();
     }
 
   #endif // HAS_LCD_MENU
 
-  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_GRAPHICAL_LCD, drawing_screen)) {
+  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if HAS_TOUCH_XPT2046
 
       if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
       TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
 
     #endif
@@ -964,21 +964,21 @@ void MarlinUI::update() {
         #ifdef LED_BACKLIGHT_TIMEOUT
           leds.reset_timeout(ms);
         #endif
       }
 
     #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (on_status_screen() && !lcd_status_update_delay--) {
-      lcd_status_update_delay = TERN(HAS_GRAPHICAL_LCD, 12, 9);
+      lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
       if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
@@ -1003,21 +1003,21 @@ void MarlinUI::update() {
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:
           refresh(LCDVIEW_REDRAW_NOW);
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
       TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
 
-      #if HAS_GRAPHICAL_LCD
+      #if HAS_MARLINUI_U8GLIB
 
         #if ENABLED(LIGHTWEIGHT_UI)
           const bool in_status = on_status_screen(),
                      do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) status_screen();
         #else
           constexpr bool do_u8g_loop = true;
         #endif
 
@@ -1287,21 +1287,21 @@ void MarlinUI::update() {
           external_encoder();
         #endif
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
 #endif // HAS_ENCODER_ACTION
 
-#endif // HAS_SPI_LCD
+#endif // HAS_WIRED_LCD
 
 #if HAS_DISPLAY
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extui/ui_api.h"
   #endif
 
   ////////////////////////////////////////////
   /////////////// Status Line ////////////////
   ////////////////////////////////////////////
@@ -1335,21 +1335,21 @@ void MarlinUI::update() {
       progress_bar_ms = ms;
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = ms + 5000UL; // Show status message for 5s
     #endif
 
-    #if BOTH(HAS_SPI_LCD, STATUS_MESSAGE_SCROLLING)
+    #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
     if (alert_level) return;
@@ -1494,21 +1494,21 @@ void MarlinUI::update() {
     #if HAS_LCD_MENU
       synchronize(GET_TEXT(MSG_PAUSING));
       defer_status_screen();
     #endif
 
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
 
     set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
-      TERN_(HAS_SPI_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
+      TERN_(HAS_WIRED_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
@@ -1603,25 +1603,25 @@ void MarlinUI::update() {
         #endif
       }
     }
 
     #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
       init_lcd(); // Revive a noisy shared SPI LCD
     #endif
 
     refresh();
 
-    #if HAS_SPI_LCD || defined(LED_BACKLIGHT_TIMEOUT)
+    #if HAS_WIRED_LCD || defined(LED_BACKLIGHT_TIMEOUT)
       const millis_t ms = millis();
     #endif
 
-    TERN_(HAS_SPI_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
+    TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
 
     #ifdef LED_BACKLIGHT_TIMEOUT
       leds.reset_timeout(ms);
     #endif
   }
 
 #endif // SDSUPPORT
 
 #if HAS_LCD_MENU
   void MarlinUI::reset_settings() { settings.reset(); completion_feedback(); }

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b30f6e49c9..fc55c3c2f6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -688,44 +688,42 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
     if (processing) return;   // Prevent re-entry from idle() calls
 
     // Add a manual move to the queue?
     if (axis != (uint8_t)NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
       const feedRate_t fr_mm_s = (uint8_t(axis) <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
       #if IS_KINEMATIC
 
-        #if EXTRUDERS > 1
+        #if HAS_MULTI_EXTRUDER
           const int8_t old_extruder = active_extruder;
           if (axis == E_AXIS) active_extruder = e_index;
         #endif
 
         // Apply a linear offset to a single axis
         destination = current_position;
         if (axis <= XYZE) destination[axis] += offset;
 
         // Reset for the next move
         offset = 0;
         axis = (uint8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
         // previous invocation is being blocked. Modifications to offset shouldn't be made while
         // processing is true or the planner will get out of sync.
         processing = true;
         prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
         processing = false;
 
-        #if EXTRUDERS > 1
-          active_extruder = old_extruder;
-        #endif
+        TERN_(HAS_MULTI_EXTRUDER, active_extruder = old_extruder);
 
       #else
 
         // For Cartesian / Core motion simply move to the current_position
         planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
 
         //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
 
         axis = (uint8_t)NO_AXIS;
 

commit 646d90f3da2feda848dc4a50fe3661701dc881d1
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Aug 25 22:43:33 2020 -0700

    Fix SD pins for SKR Pro and GTR (#19047)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 09767c72aa..b30f6e49c9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -365,24 +365,20 @@ void MarlinUI::init() {
       OUT_WRITE(SHIFT_LD, HIGH);
       #if defined(SHIFT_EN) && SHIFT_EN >= 0
         OUT_WRITE(SHIFT_EN, LOW);
       #endif
       SET_INPUT_PULLUP(SHIFT_OUT);
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
-    SET_INPUT_PULLUP(SD_DETECT_PIN);
-  #endif
-
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
 }
 
 bool MarlinUI::get_blink() {

commit c488070859c1995fe957938b1b6302c4eeef1ea3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 23 23:57:51 2020 -0500

    Minor cleanup w/r/t LEDs

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f30d9c68cf..09767c72aa 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -74,21 +74,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
 #endif
 
 #if EITHER(PCA9632_BUZZER, USE_BEEPER)
   #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
-      pca9632_buzz(duration, freq);
+      PCA9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
 #if PREHEAT_COUNT
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
   PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
     #ifdef PREHEAT_1_LABEL

commit a37cf2490054ece3c16f0caca26a02c3d33057c8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 21 20:54:21 2020 -0300

    Emulated DOGM via HAL TFT, XPT IO (#19017)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6fa3006fb7..f30d9c68cf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -143,21 +143,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if HAS_TOUCH_XPT2046
-    #include "touch/xpt2046.h"
+    #include "touch/touch_buttons.h"
     bool MarlinUI::on_edit_screen = false;
   #endif
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 

commit 4f67642122059a9270f9e3690978248355f88e72
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 05:21:34 2020 -0500

    Header for individual menus

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 670c916dd7..6fa3006fb7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -931,20 +931,22 @@ void MarlinUI::update() {
               const float encoderMovementSteps = float(abs_diff) / epps;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
+                // Enable to output the encoder steps per second value
+                //#define ENCODER_RATE_MULTIPLIER_DEBUG
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
                   SERIAL_ECHO_START();
                   SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
                   SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
                   SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
                   SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
                   SERIAL_EOL();
                 #endif
               }
 

commit 18adfe87bcd516436db001b53a0e09e58246c9e2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 7 20:51:40 2020 -0500

    configuration_store => settings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6482cf33d0..670c916dd7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -116,21 +116,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
-#include "../module/configuration_store.h"
+#include "../module/settings.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../feature/tmc_util.h"

commit a9912681b40ebaea6b452a41fb0d25ec9c93c8fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Aug 6 00:49:15 2020 -0500

    General cleanup

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b7dd4944ef..6482cf33d0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -67,21 +67,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
   #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
 #endif
 
-#if ENABLED(PCA9632_BUZZER) || USE_BEEPER
+#if EITHER(PCA9632_BUZZER, USE_BEEPER)
   #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif

commit ca0ebf10d10d3c8e99c83c123c5ff2a678cda900
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 3 21:55:37 2020 -0500

    Move scaled TFT / touch defines (#18915)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 92e3f136c9..b7dd4944ef 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -143,21 +143,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if HAS_TOUCH_XPT2046
-    #include "../feature/touch/xpt2046.h"
+    #include "touch/xpt2046.h"
     bool MarlinUI::on_edit_screen = false;
   #endif
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 88a9c36b36..92e3f136c9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -142,21 +142,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
-  #if ENABLED(TOUCH_BUTTONS)
+  #if HAS_TOUCH_XPT2046
     #include "../feature/touch/xpt2046.h"
     bool MarlinUI::on_edit_screen = false;
   #endif
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
@@ -222,21 +222,21 @@ millis_t MarlinUI::next_button_update_ms; // = 0
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
     }
   #endif
 
   #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
     int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
-  #if ENABLED(TOUCH_BUTTONS)
+  #if HAS_TOUCH_XPT2046
     uint8_t MarlinUI::touch_buttons;
     uint8_t MarlinUI::repeat_delay;
   #endif
 
   bool MarlinUI::lcd_clicked;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
@@ -795,28 +795,30 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  *
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * This function is only called from the main thread.
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 millis_t next_lcd_update_ms;
+#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+  millis_t MarlinUI::return_to_status_ms = 0;
+#endif
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   millis_t ms = millis();
 
   #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
-    static millis_t return_to_status_ms = 0;
     #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
   #else
     #define RESET_STATUS_TIMEOUT() NOOP
   #endif
 
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
 
   #if HAS_LCD_MENU
@@ -831,42 +833,42 @@ void MarlinUI::update() {
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
     auto do_click = [&]{
       wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
       lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
       wait_for_user = false;                          //  - Any click clears wait for user
       quick_feedback();                               //  - Always make a click sound
     };
 
-    #if ENABLED(TOUCH_BUTTONS)
+    #if HAS_TOUCH_XPT2046
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
             TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               chirp();
             }
           }
         }
         else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
           do_click();
       }
       else // keep wait_for_unclick value
 
-    #endif // TOUCH_BUTTONS
+    #endif // HAS_TOUCH_XPT2046
 
       {
         // Integrated LCD click handling via button_pressed
         if (!external_control && button_pressed()) {
           if (!wait_for_unclick) do_click();              // Handle the click
         }
         else
           wait_for_unclick = false;
       }
 
@@ -874,21 +876,21 @@ void MarlinUI::update() {
       quick_feedback();
       goto_previous_screen();
     }
 
   #endif // HAS_LCD_MENU
 
   if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_GRAPHICAL_LCD, drawing_screen)) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
-    #if ENABLED(TOUCH_BUTTONS)
+    #if HAS_TOUCH_XPT2046
 
       if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
       TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
 
     #endif
 
     TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
 
     #if HAS_ENCODER_ACTION
@@ -1071,20 +1073,22 @@ void MarlinUI::update() {
         clear_lcd(); break;
       case LCDVIEW_REDRAW_NOW:
         refresh(LCDVIEW_NONE);
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
+
+  TERN_(HAS_GRAPHICAL_TFT, tft_idle());
 }
 
 #if HAS_ADC_BUTTONS
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   #ifndef ADC_BUTTONS_VALUE_SCALE
@@ -1217,21 +1221,21 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
-          #if BOTH(TOUCH_BUTTONS, HAS_ENCODER_ACTION)
+          #if BOTH(HAS_TOUCH_XPT2046, HAS_ENCODER_ACTION)
             | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
           #endif
         );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
@@ -1526,21 +1530,21 @@ void MarlinUI::update() {
       return (
         TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
         #if ENABLED(SDSUPPORT)
           ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
         #endif
       );
     }
 
   #endif
 
-  #if ENABLED(TOUCH_BUTTONS)
+  #if HAS_TOUCH_XPT2046
 
     //
     // Screen Click
     //  - On menu screens move directly to the touched item
     //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
     //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
       const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,

commit 6f26ed23ee0c3fd64bd3521f657e6755b5cacc1a
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Jul 25 17:57:16 2020 -0300

    Fix ui.external_control compile error (#18778)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9968a3218a..88a9c36b36 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -746,33 +746,33 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
   ) {
     #if MULTI_MANUAL
       if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     axis = (uint8_t)move_axis;
     //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
   }
 
-#endif // HAS_LCD_MENU
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  void MarlinUI::external_encoder() {
-    if (external_control && encoderDiff) {
-      ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
-      encoderDiff = 0;                  // Hide encoder events from the screen handler
-      refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+    void MarlinUI::external_encoder() {
+      if (external_control && encoderDiff) {
+        ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+        encoderDiff = 0;                  // Hide encoder events from the screen handler
+        refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+      }
     }
-  }
 
-#endif
+  #endif
+
+#endif // HAS_LCD_MENU
 
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position
  *   - Apply acceleration to the encoder position
  *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
  *   - Reset the Info Screen timeout if there's any input
@@ -1276,21 +1276,23 @@ void MarlinUI::update() {
       uint8_t enc = 0;
       if (buttons & EN_A) enc |= B01;
       if (buttons & EN_B) enc |= B10;
       if (enc != lastEncoderBits) {
         switch (enc) {
           case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
           case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
           case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
           case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
         }
-        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+        #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
+          external_encoder();
+        #endif
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 

commit f23393c1ec8a821e3eca4277f73846ff018d05f3
Author: Mark Langezaal <mark.langezaal@gmail.com>
Date:   Fri Jul 24 04:28:44 2020 +0200

    Simplify encoder handling (#18754)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 45612f6c55..9968a3218a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -42,20 +42,22 @@ MarlinUI ui;
   #include "../sd/cardreader.h"
   #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
   bool MarlinUI::wait_for_move; // = false
 #endif
 
+constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
+
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
@@ -433,27 +435,27 @@ bool MarlinUI::get_blink() {
             if (encoderDirection == -(ENCODERBASE)) { // ADC_KEYPAD forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
                    if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             }
             else
           #endif
           {
             #if HAS_LCD_MENU
-                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= ENCODER_PULSES_PER_STEP;
-              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += ENCODER_PULSES_PER_STEP;
+                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
+              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
               else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
             #else
-                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= ENCODER_PULSES_PER_STEP;
-              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += ENCODER_PULSES_PER_STEP;
+                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= epps;
+              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += epps;
             #endif
           }
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
 
     #else // !HAS_ADC_BUTTONS
 
       static uint8_t keypad_debounce = 0;
@@ -834,21 +836,21 @@ void MarlinUI::update() {
       lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
       wait_for_user = false;                          //  - Any click clears wait for user
       quick_feedback();                               //  - Always make a click sound
     };
 
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
-            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
             TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               chirp();
             }
           }
         }
@@ -894,49 +896,44 @@ void MarlinUI::update() {
       TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
       if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
         RESET_STATUS_TIMEOUT();
 
       uint8_t abs_diff = ABS(encoderDiff);
 
       #if ENCODER_PULSES_PER_STEP > 1
         // When reversing the encoder direction, a movement step can be missed because
         // encoderDiff has a non-zero residual value, making the controller unresponsive.
-        // The fix clears the residual value when the encoder is reversed.
+        // The fix clears the residual value when the encoder is idle.
         // Also check if past half the threshold to compensate for missed single steps.
         static int8_t lastEncoderDiff;
-        int8_t prevDiff = lastEncoderDiff;
-        lastEncoderDiff = encoderDiff;  // Store before updating encoderDiff to save actual steps
-
-        // When not past threshold, and reversing... or past half the threshold
-        if (WITHIN(abs_diff, 1, (ENCODER_PULSES_PER_STEP) - 1)  // Not past threshold
-          && (abs_diff > (ENCODER_PULSES_PER_STEP) / 2          // Passed half the threshold? Done! Call it a full step.
-            || (ABS(encoderDiff - prevDiff) >= (ENCODER_PULSES_PER_STEP)  // A big change when abs_diff is small implies reverse
-                && ABS(prevDiff) < (ENCODER_PULSES_PER_STEP)    // ...especially when starting from a partial or no step.
-               )
-             )
-        ) {
-          abs_diff = ENCODER_PULSES_PER_STEP;
-          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;  // Treat as full step
+
+        // Timeout? No decoder change since last check. 10 or 20 times per second.
+        if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
+          encoderDiff = 0;                                            // Clear residual pulses.
+        else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
+          abs_diff = epps;                                            // Treat as a full step size
+          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
         }
+        lastEncoderDiff = encoderDiff;
       #endif
 
-      const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
+      const bool encoderPastThreshold = (abs_diff >= epps);
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
-              const float encoderMovementSteps = float(abs_diff) / (ENCODER_PULSES_PER_STEP);
+              const float encoderMovementSteps = float(abs_diff) / epps;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
@@ -951,21 +948,21 @@ void MarlinUI::update() {
 
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
 
           #else
 
             constexpr int32_t encoderMultiplier = 1;
 
           #endif // ENCODER_RATE_MULTIPLIER
 
-          encoderPosition += (encoderDiff * encoderMultiplier) / (ENCODER_PULSES_PER_STEP);
+          encoderPosition += (encoderDiff * encoderMultiplier) / epps;
           encoderDiff = 0;
         }
 
         RESET_STATUS_TIMEOUT();
 
         refresh(LCDVIEW_REDRAW_NOW);
 
         #ifdef LED_BACKLIGHT_TIMEOUT
           leds.reset_timeout(ms);
         #endif
@@ -1184,21 +1181,21 @@ void MarlinUI::update() {
 
           constexpr uint8_t newbutton = 0;
 
         #endif
 
         //
         // Directional buttons
         //
         #if ANY_BUTTON(UP, DWN, LFT, RT)
 
-          const int8_t pulses = (ENCODER_PULSES_PER_STEP) * encoderDirection;
+          const int8_t pulses = epps * encoderDirection;
 
           if (false) {
             // for the else-ifs below
           }
           #if BUTTON_EXISTS(UP)
             else if (BUTTON_PRESSED(UP)) {
               encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
             }
           #endif
@@ -1540,31 +1537,31 @@ void MarlinUI::update() {
     // Screen Click
     //  - On menu screens move directly to the touched item
     //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
     //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
       const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
                    ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
       if (on_edit_screen)
-        encoderDiff = (ENCODER_PULSES_PER_STEP) * ydir;
+        encoderDiff = epps * ydir;
       else if (screen_items > 0) {
         // Last 3 cols act as a scroll :-)
         if (col > (LCD_WIDTH) - 5)
           // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
-          encoderDiff = (ENCODER_PULSES_PER_STEP) * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
+          encoderDiff = epps * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
         else
-          encoderDiff = (ENCODER_PULSES_PER_STEP) * (row - encoderPosition + encoderTopLine);
+          encoderDiff = epps * (row - encoderPosition + encoderTopLine);
       }
       else if (!on_status_screen())
-        encoderDiff = (ENCODER_PULSES_PER_STEP) * xdir;
+        encoderDiff = epps * xdir;
     }
 
   #endif
 
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const message, const bool) {

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bed72b19a3..45612f6c55 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfig.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)

commit d96691f8ad6a1a35f0dcba686edd8cb1fbaf7fe5
Author: Mark Langezaal <mark.langezaal@gmail.com>
Date:   Mon Jul 20 00:20:35 2020 +0200

    Fix encoder reverse, partial steps handling (#18694)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b8524e774c..bed72b19a3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -889,31 +889,54 @@ void MarlinUI::update() {
 
     TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
 
     #if HAS_ENCODER_ACTION
 
       TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
       if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
         RESET_STATUS_TIMEOUT();
 
-      const float abs_diff = ABS(encoderDiff);
+      uint8_t abs_diff = ABS(encoderDiff);
+
+      #if ENCODER_PULSES_PER_STEP > 1
+        // When reversing the encoder direction, a movement step can be missed because
+        // encoderDiff has a non-zero residual value, making the controller unresponsive.
+        // The fix clears the residual value when the encoder is reversed.
+        // Also check if past half the threshold to compensate for missed single steps.
+        static int8_t lastEncoderDiff;
+        int8_t prevDiff = lastEncoderDiff;
+        lastEncoderDiff = encoderDiff;  // Store before updating encoderDiff to save actual steps
+
+        // When not past threshold, and reversing... or past half the threshold
+        if (WITHIN(abs_diff, 1, (ENCODER_PULSES_PER_STEP) - 1)  // Not past threshold
+          && (abs_diff > (ENCODER_PULSES_PER_STEP) / 2          // Passed half the threshold? Done! Call it a full step.
+            || (ABS(encoderDiff - prevDiff) >= (ENCODER_PULSES_PER_STEP)  // A big change when abs_diff is small implies reverse
+                && ABS(prevDiff) < (ENCODER_PULSES_PER_STEP)    // ...especially when starting from a partial or no step.
+               )
+             )
+        ) {
+          abs_diff = ENCODER_PULSES_PER_STEP;
+          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;  // Treat as full step
+        }
+      #endif
+
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
-              const float encoderMovementSteps = abs_diff / (ENCODER_PULSES_PER_STEP);
+              const float encoderMovementSteps = float(abs_diff) / (ENCODER_PULSES_PER_STEP);
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)

commit 0ddef5544a12847eff9163996844c5cd329cecc0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 18 18:54:44 2020 -0500

    Misc formatting, cleanup

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d9a18ba4eb..b8524e774c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1517,31 +1517,31 @@ void MarlinUI::update() {
     // Screen Click
     //  - On menu screens move directly to the touched item
     //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
     //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
       const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
                    ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
       if (on_edit_screen)
-        encoderDiff = ENCODER_PULSES_PER_STEP * ydir;
+        encoderDiff = (ENCODER_PULSES_PER_STEP) * ydir;
       else if (screen_items > 0) {
         // Last 3 cols act as a scroll :-)
         if (col > (LCD_WIDTH) - 5)
           // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
-          encoderDiff = ENCODER_PULSES_PER_STEP * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
+          encoderDiff = (ENCODER_PULSES_PER_STEP) * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
         else
-          encoderDiff = ENCODER_PULSES_PER_STEP * (row - encoderPosition + encoderTopLine);
+          encoderDiff = (ENCODER_PULSES_PER_STEP) * (row - encoderPosition + encoderTopLine);
       }
       else if (!on_status_screen())
-        encoderDiff = ENCODER_PULSES_PER_STEP * xdir;
+        encoderDiff = (ENCODER_PULSES_PER_STEP) * xdir;
     }
 
   #endif
 
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const message, const bool) {

commit b8807128893a0ccb2b4633e27a91024dad36ed4f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 16 21:02:52 2020 -0500

    Fix material_preset reference issue

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1848a56d2c..d9a18ba4eb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -13,21 +13,21 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
-#include "../inc/MarlinConfigPre.h"
+#include "../inc/MarlinConfig.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../feature/host_actions.h"
 #endif
 
 // All displays share the MarlinUI class
@@ -79,20 +79,46 @@ MarlinUI ui;
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
+#if PREHEAT_COUNT
+  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
+  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
+    #ifdef PREHEAT_1_LABEL
+      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
+    #endif
+    #ifdef PREHEAT_2_LABEL
+      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
+    #endif
+    #ifdef PREHEAT_3_LABEL
+      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
+    #endif
+    #ifdef PREHEAT_4_LABEL
+      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
+    #endif
+    #ifdef PREHEAT_5_LABEL
+      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
+    #endif
+
+    #define _PLBL(N) preheat_##N##_label,
+    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
+
+    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
+  }
+#endif
+
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/configuration_store.h"
@@ -142,47 +168,20 @@ millis_t MarlinUI::next_button_update_ms; // = 0
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
-#if PREHEAT_COUNT
-  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
-
-  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
-    #ifdef PREHEAT_1_LABEL
-      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
-    #endif
-    #ifdef PREHEAT_2_LABEL
-      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
-    #endif
-    #ifdef PREHEAT_3_LABEL
-      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
-    #endif
-    #ifdef PREHEAT_4_LABEL
-      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
-    #endif
-    #ifdef PREHEAT_5_LABEL
-      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
-    #endif
-
-    #define _PLBL(N) preheat_##N##_label,
-    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
-
-    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
-  }
-#endif
-
 #if ENABLED(SDSUPPORT)
 
   #include "../sd/cardreader.h"
 
   #if MARLINUI_SCROLL_NAME
     uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
   #endif
 
   const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
     const char *outstr = theCard.longest_filename();

commit b0c6cfb0511b8d71fec26ab91cd945f3d623b3c0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 9 10:11:57 2020 +0200

    MarlinUI support for up to 5 Material Presets (#18488)
    
    - Add `I` preset parameter to `G26`, `M106`, `M140`, and `M190`.
    - Extend menu items to permit a string interpolation.
    - Keep material names in a list and interpolate in menu items.
    - Extend material presets to support up to 5 predefined materials.
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d2033018a6..1848a56d2c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -79,24 +79,20 @@ MarlinUI ui;
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
-#if PREHEAT_COUNT
-  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
-#endif
-
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/configuration_store.h"
@@ -146,20 +142,47 @@ millis_t MarlinUI::next_button_update_ms; // = 0
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
+#if PREHEAT_COUNT
+  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
+
+  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
+    #ifdef PREHEAT_1_LABEL
+      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
+    #endif
+    #ifdef PREHEAT_2_LABEL
+      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
+    #endif
+    #ifdef PREHEAT_3_LABEL
+      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
+    #endif
+    #ifdef PREHEAT_4_LABEL
+      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
+    #endif
+    #ifdef PREHEAT_5_LABEL
+      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
+    #endif
+
+    #define _PLBL(N) preheat_##N##_label,
+    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
+
+    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
+  }
+#endif
+
 #if ENABLED(SDSUPPORT)
 
   #include "../sd/cardreader.h"
 
   #if MARLINUI_SCROLL_NAME
     uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
   #endif
 
   const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
     const char *outstr = theCard.longest_filename();

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 74924e1dd1..d2033018a6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -204,21 +204,20 @@ millis_t MarlinUI::next_button_update_ms; // = 0
   #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
     int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
   #if ENABLED(TOUCH_BUTTONS)
     uint8_t MarlinUI::touch_buttons;
     uint8_t MarlinUI::repeat_delay;
   #endif
 
   bool MarlinUI::lcd_clicked;
-  float move_menu_scale;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
   #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
 
     bool MarlinUI::external_control; // = false
@@ -381,21 +380,21 @@ bool MarlinUI::get_blink() {
 
   volatile uint8_t MarlinUI::keypad_buttons;
 
   #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
-      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
       ui.encoderPosition = dir;
       switch (axis) {
         case X_AXIS: lcd_move_x(); break;
         case Y_AXIS: lcd_move_y(); break;
         case Z_AXIS: lcd_move_z();
         default: break;
       }
     }
 
   #endif
@@ -630,81 +629,127 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
   #endif
 }
 
 ////////////////////////////////////////////
 /////////////// Manual Move ////////////////
 ////////////////////////////////////////////
 
 #if HAS_LCD_MENU
 
-  int8_t MarlinUI::manual_move_axis = (int8_t)NO_AXIS;
-  millis_t MarlinUI::manual_move_start_time = 0;
+  ManualMove MarlinUI::manual_move{};
 
-  #if IS_KINEMATIC
-    bool MarlinUI::processing_manual_move = false;
-    float MarlinUI::manual_move_offset = 0;
-  #endif
-
-  #if MULTI_MANUAL
-    int8_t MarlinUI::manual_move_e_index = 0;
-  #endif
+  millis_t ManualMove::start_time = 0;
+  float ManualMove::menu_scale = 1;
+  TERN_(IS_KINEMATIC, float ManualMove::offset = 0);
+  TERN_(IS_KINEMATIC, bool ManualMove::processing = false);
+  TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
+  uint8_t ManualMove::axis = (uint8_t)NO_AXIS;
 
   /**
-   * If the most recent manual move hasn't been fed to the planner yet,
-   * and the planner can accept one, send a move immediately.
+   * If a manual move has been posted and its time has arrived, and if the planner
+   * has a space for it, then add a linear move to current_position the planner.
+   *
+   * If any manual move needs to be interrupted, make sure to force a manual move
+   * by setting manual_move.start_time to millis() after updating current_position.
+   *
+   * To post a manual move:
+   *   - Update current_position to the new place you want to go.
+   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES for diagonal moves.
+   *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
+   *
+   * For kinematic machines:
+   *   - Set manual_move.offset to modify one axis and post the move.
+   *     This is used to achieve more rapid stepping on kinematic machines.
+   *
+   * Currently used by the _lcd_move_xyz function in menu_motion.cpp
+   * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
    */
-  void MarlinUI::manage_manual_move() {
+  void ManualMove::task() {
 
-    if (processing_manual_move) return;
+    if (processing) return;   // Prevent re-entry from idle() calls
 
-    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
+    // Add a manual move to the queue?
+    if (axis != (uint8_t)NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
+
+      const feedRate_t fr_mm_s = (uint8_t(axis) <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
-      const feedRate_t fr_mm_s = manual_feedrate_mm_s[manual_move_axis];
       #if IS_KINEMATIC
 
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
-          if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
+          if (axis == E_AXIS) active_extruder = e_index;
         #endif
 
-        // Set movement on a single axis
+        // Apply a linear offset to a single axis
         destination = current_position;
-        destination[manual_move_axis] += manual_move_offset;
+        if (axis <= XYZE) destination[axis] += offset;
 
         // Reset for the next move
-        manual_move_offset = 0;
-        manual_move_axis = (int8_t)NO_AXIS;
+        offset = 0;
+        axis = (uint8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
-        // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
-        // processing_manual_move is true or the planner will get out of sync.
-        processing_manual_move = true;
+        // previous invocation is being blocked. Modifications to offset shouldn't be made while
+        // processing is true or the planner will get out of sync.
+        processing = true;
         prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
-        processing_manual_move = false;
+        processing = false;
 
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
-        planner.buffer_line(current_position, fr_mm_s, manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
-        manual_move_axis = (int8_t)NO_AXIS;
+        // For Cartesian / Core motion simply move to the current_position
+        planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
+
+        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
+
+        axis = (uint8_t)NO_AXIS;
 
       #endif
     }
   }
 
+  //
+  // Tell ui.update() to start a move to current_position after a short delay.
+  //
+  void ManualMove::soon(AxisEnum move_axis
+    #if MULTI_MANUAL
+      , const int8_t eindex/*=-1*/
+    #endif
+  ) {
+    #if MULTI_MANUAL
+      if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
+    #endif
+    start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
+    axis = (uint8_t)move_axis;
+    //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
+  }
+
 #endif // HAS_LCD_MENU
 
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+
+  void MarlinUI::external_encoder() {
+    if (external_control && encoderDiff) {
+      ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+      encoderDiff = 0;                  // Hide encoder events from the screen handler
+      refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+    }
+  }
+
+#endif
+
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position
  *   - Apply acceleration to the encoder position
  *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
  *   - Reset the Info Screen timeout if there's any input
  *   - Update status indicators, if any
@@ -746,21 +791,21 @@ void MarlinUI::update() {
     #define RESET_STATUS_TIMEOUT() NOOP
   #endif
 
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
 
   #if HAS_LCD_MENU
 
     // Handle any queued Move Axis motion
-    manage_manual_move();
+    manual_move.task();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
     auto do_click = [&]{
       wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
@@ -769,21 +814,21 @@ void MarlinUI::update() {
       quick_feedback();                               //  - Always make a click sound
     };
 
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
-            TERN_(AUTO_BED_LEVELING_UBL, if (external_control) ubl.encoder_diff = encoderDiff);
+            TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               chirp();
             }
           }
         }
         else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
           do_click();
@@ -1189,24 +1234,21 @@ void MarlinUI::update() {
       uint8_t enc = 0;
       if (buttons & EN_A) enc |= B01;
       if (buttons & EN_B) enc |= B10;
       if (enc != lastEncoderBits) {
         switch (enc) {
           case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
           case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
           case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
           case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
         }
-        if (external_control) {
-          TERN_(AUTO_BED_LEVELING_UBL, ubl.encoder_diff = encoderDiff); // Make encoder rotation available to UBL G29 mesh editing.
-          encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
-        }
+        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 

commit 452072cc08efcfdcd01c712c69cc81a014ea3626
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 25 22:45:09 2020 -0500

    Fix typo in DWIN, preheat array

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2bdcb1915d..74924e1dd1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -79,21 +79,21 @@ MarlinUI ui;
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
-#if EITHER(HAS_LCD_MENU, DWIN_CREALITY_LCD)
+#if PREHEAT_COUNT
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"

commit f445bc26e52de36239e595ee3fbd2d25abc97258
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 25 16:39:22 2020 -0500

    Minor LCD cleanup, improvement

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 271de72722..2bdcb1915d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -630,26 +630,26 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
   #endif
 }
 
 ////////////////////////////////////////////
 /////////////// Manual Move ////////////////
 ////////////////////////////////////////////
 
 #if HAS_LCD_MENU
 
-  int8_t manual_move_axis = (int8_t)NO_AXIS;
-  millis_t manual_move_start_time = 0;
+  int8_t MarlinUI::manual_move_axis = (int8_t)NO_AXIS;
+  millis_t MarlinUI::manual_move_start_time = 0;
 
   #if IS_KINEMATIC
     bool MarlinUI::processing_manual_move = false;
-    float manual_move_offset = 0;
+    float MarlinUI::manual_move_offset = 0;
   #endif
 
   #if MULTI_MANUAL
     int8_t MarlinUI::manual_move_e_index = 0;
   #endif
 
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send a move immediately.
    */
@@ -898,22 +898,22 @@ void MarlinUI::update() {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
           filename_scroll_pos = 0;
           lcd_status_update_delay = 12;
         }
         refresh(LCDVIEW_REDRAW_NOW);
         RESET_STATUS_TIMEOUT();
       }
     #endif
 
-    // then we want to use 1/2 of the time only.
-    uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
+    // Then we want to use only 50% of the time
+    const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
 
       // Change state of drawing flag between screen updates
       if (!drawing_screen) switch (lcdDrawUpdate) {
         case LCDVIEW_CALL_NO_REDRAW:
           refresh(LCDVIEW_NONE);
           break;
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:

commit 4275466f4930ce554419f5f03f07119b8a9aec04
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 24 19:44:50 2020 -0500

    Fix issues with no hotend / bed / fan (#18395)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 98f29804c8..271de72722 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -79,20 +79,24 @@ MarlinUI ui;
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
+#if EITHER(HAS_LCD_MENU, DWIN_CREALITY_LCD)
+  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
+#endif
+
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/configuration_store.h"

commit 424569b4c4bf112a3939724b30bad528a76a2b08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 18 15:23:03 2020 -0500

    Power monitor and display (#17437)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9fa5f3a67a..98f29804c8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -105,20 +105,24 @@ MarlinUI ui;
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ADC_BUTTONS
   #include "../module/thermistor/thermistors.h"
 #endif
 
+#if HAS_POWER_MONITOR
+  #include "../feature/power_monitor.h"
+#endif
+
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
     bool MarlinUI::on_edit_screen = false;
   #endif
 #endif
@@ -526,21 +530,20 @@ void MarlinUI::status_screen() {
           // and during any pause (not just SD)
           expire_status_ms += LCD_UPDATE_INTERVAL;
         }
       }
 
     #endif // PROGRESS_MSG_EXPIRE
 
   #endif // LCD_PROGRESS_BAR
 
   #if HAS_LCD_MENU
-
     if (use_click()) {
       #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
       #if DISABLED(NO_LCD_REINIT)
         init_lcd(); // May revive the LCD if static electricity killed it
       #endif
       return;
     }

commit f4c258dc2355fee871bec6e11095c7c4777b160d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 16 01:45:27 2020 -0500

    Creality Ender 3 v2 (#17719)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6b52f64b90..9fa5f3a67a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -33,37 +33,37 @@
 // All displays share the MarlinUI class
 #include "ultralcd.h"
 MarlinUI ui;
 
 #if HAS_DISPLAY
   #include "../module/printcounter.h"
   #include "../MarlinCore.h"
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
-  #if ENABLED(EXTENSIBLE_UI)
+  #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
   bool MarlinUI::wait_for_move; // = false
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
-#elif ENABLED(EXTENSIBLE_UI)
+#elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
 #if EITHER(HAS_SPI_LCD, EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
@@ -138,54 +138,55 @@ millis_t MarlinUI::next_button_update_ms; // = 0
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
-#if HAS_LCD_MENU
-  #include "menu/menu.h"
-  #include "../sd/cardreader.h"
+#if ENABLED(SDSUPPORT)
 
-  #if ENABLED(SDSUPPORT)
+  #include "../sd/cardreader.h"
 
-    #if ENABLED(SCROLL_LONG_FILENAMES)
-      uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
-    #endif
+  #if MARLINUI_SCROLL_NAME
+    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+  #endif
 
-    const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
-      const char *outstr = theCard.longest_filename();
-      if (theCard.longFilename[0]) {
-        #if ENABLED(SCROLL_LONG_FILENAMES)
-          if (doScroll) {
-            for (uint8_t l = FILENAME_LENGTH; l--;)
-              hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
-            static uint8_t filename_scroll_hash;
-            if (filename_scroll_hash != hash) {                              // If the hash changed...
-              filename_scroll_hash = hash;                                   // Save the new hash
-              filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
-              filename_scroll_pos = 0;                                       // Reset scroll to the start
-              lcd_status_update_delay = 8;                                   // Don't scroll right away
-            }
-            outstr += filename_scroll_pos;
+  const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+    const char *outstr = theCard.longest_filename();
+    if (theCard.longFilename[0]) {
+      #if MARLINUI_SCROLL_NAME
+        if (doScroll) {
+          for (uint8_t l = FILENAME_LENGTH; l--;)
+            hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
+          static uint8_t filename_scroll_hash;
+          if (filename_scroll_hash != hash) {                              // If the hash changed...
+            filename_scroll_hash = hash;                                   // Save the new hash
+            filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
+            filename_scroll_pos = 0;                                       // Reset scroll to the start
+            lcd_status_update_delay = 8;                                   // Don't scroll right away
           }
-        #else
-          theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
-        #endif
-      }
-      return outstr;
+          outstr += filename_scroll_pos;
+        }
+      #else
+        theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
+      #endif
     }
+    return outstr;
+  }
 
-  #endif
+#endif
+
+#if HAS_LCD_MENU
+  #include "menu/menu.h"
 
   screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
   bool MarlinUI::screen_changed;
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
     bool MarlinUI::encoderRateMultiplierEnabled;
     millis_t MarlinUI::lastEncoderMovementMillis = 0;
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
@@ -1572,12 +1573,14 @@ void MarlinUI::update() {
           MenuItem_confirm::select_screen(
             GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
             init_eeprom, return_to_status,
             eeprom_err(editable.uint8), msg, PSTR("?")
           );
         });
       #else
         set_status_P(eeprom_err(msgid));
       #endif
     }
-  #endif
-#endif
+
+  #endif // EEPROM_AUTO_INIT
+
+#endif // EEPROM_SETTINGS

commit 6d571a547ccb0b67625bc2212b4fbf22de6bd3e5
Author: Victor <rhapsodyv@gmail.com>
Date:   Mon Jun 15 22:51:12 2020 -0300

    Clean up TFT / Touch code (#18296)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4c416093ae..6b52f64b90 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1448,21 +1448,21 @@ void MarlinUI::update() {
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
     //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
       const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
                    ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
       if (on_edit_screen)
         encoderDiff = ENCODER_PULSES_PER_STEP * ydir;
       else if (screen_items > 0) {
         // Last 3 cols act as a scroll :-)
-        if (col > (LCD_WIDTH) - 3)
+        if (col > (LCD_WIDTH) - 5)
           // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
           encoderDiff = ENCODER_PULSES_PER_STEP * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
         else
           encoderDiff = ENCODER_PULSES_PER_STEP * (row - encoderPosition + encoderTopLine);
       }
       else if (!on_status_screen())
         encoderDiff = ENCODER_PULSES_PER_STEP * xdir;
     }
 
   #endif

commit 1d504e596df79b0572de23f628af457a017b6be3
Author: Victor <rhapsodyv@gmail.com>
Date:   Thu Jun 11 23:21:18 2020 -0300

    Touch-to-jog on edit screens (#18266)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0869cbf5c5..4c416093ae 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -112,20 +112,21 @@ MarlinUI ui;
   #include "../module/thermistor/thermistors.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
+    bool MarlinUI::on_edit_screen = false;
   #endif
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
@@ -1438,32 +1439,37 @@ void MarlinUI::update() {
 
   #endif
 
   #if ENABLED(TOUCH_BUTTONS)
 
     //
     // Screen Click
     //  - On menu screens move directly to the touched item
     //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
     //  - On select screens (and others) touch the Right Half for +, Left Half for -
+    //  - On edit screens, touch Up Half for -,  Bottom Half to +
     //
-    void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t x, const uint8_t y) {
-      if (screen_items > 0) {
-        //last 3 cols act as a scroll :-)
+    void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
+      const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
+                   ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
+      if (on_edit_screen)
+        encoderDiff = ENCODER_PULSES_PER_STEP * ydir;
+      else if (screen_items > 0) {
+        // Last 3 cols act as a scroll :-)
         if (col > (LCD_WIDTH) - 3)
-          //2 * LCD_HEIGHT to scroll to bottom of next page. If we did 1 * LCD_HEIGHT, it just go 1 item down
-          encoderDiff = ENCODER_PULSES_PER_STEP * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * (row < (LCD_HEIGHT) / 2 ? -1 : 1);
+          // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
+          encoderDiff = ENCODER_PULSES_PER_STEP * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
         else
           encoderDiff = ENCODER_PULSES_PER_STEP * (row - encoderPosition + encoderTopLine);
       }
       else if (!on_status_screen())
-        encoderDiff = ENCODER_PULSES_PER_STEP * (col < (LCD_WIDTH) / 2 ? -1 : 1);
+        encoderDiff = ENCODER_PULSES_PER_STEP * xdir;
     }
 
   #endif
 
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const message, const bool) {

commit c6f3511d8492b54eac1829ec7a9cc39595b85d7b
Author: Victor <rhapsodyv@gmail.com>
Date:   Thu Jun 11 18:13:52 2020 -0300

    Touch-select MarlinUI menu items (#18239)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 15276fcb43..0869cbf5c5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1431,20 +1431,43 @@ void MarlinUI::update() {
       return (
         TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
         #if ENABLED(SDSUPPORT)
           ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
         #endif
       );
     }
 
   #endif
 
+  #if ENABLED(TOUCH_BUTTONS)
+
+    //
+    // Screen Click
+    //  - On menu screens move directly to the touched item
+    //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
+    //  - On select screens (and others) touch the Right Half for +, Left Half for -
+    //
+    void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t x, const uint8_t y) {
+      if (screen_items > 0) {
+        //last 3 cols act as a scroll :-)
+        if (col > (LCD_WIDTH) - 3)
+          //2 * LCD_HEIGHT to scroll to bottom of next page. If we did 1 * LCD_HEIGHT, it just go 1 item down
+          encoderDiff = ENCODER_PULSES_PER_STEP * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * (row < (LCD_HEIGHT) / 2 ? -1 : 1);
+        else
+          encoderDiff = ENCODER_PULSES_PER_STEP * (row - encoderPosition + encoderTopLine);
+      }
+      else if (!on_status_screen())
+        encoderDiff = ENCODER_PULSES_PER_STEP * (col < (LCD_WIDTH) / 2 ? -1 : 1);
+    }
+
+  #endif
+
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const message, const bool) {
     TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
   }
   void MarlinUI::set_status_P(PGM_P message, const int8_t) {
     TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));

commit 53cb2963dc3091828e6aedc2deec8a123b3634eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 1 19:42:56 2020 -0500

    Fix chirp with TOUCH_BUTTONS

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 753f8a5b48..15276fcb43 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -765,21 +765,21 @@ void MarlinUI::update() {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
             TERN_(AUTO_BED_LEVELING_UBL, if (external_control) ubl.encoder_diff = encoderDiff);
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
-              TERN_(HAS_BUZZER, buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ));
+              chirp();
             }
           }
         }
         else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
           do_click();
       }
       else // keep wait_for_unclick value
 
     #endif // TOUCH_BUTTONS
 

commit 3bf0d8d1617cd2cf088499963e49662a3fd9c2fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 27 13:12:08 2020 -0500

    Allow disable of LCD click

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 12c005a918..753f8a5b48 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -605,29 +605,26 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   TERN_(HAS_LCD_MENU, refresh());
 
   #if HAS_ENCODER_ACTION
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
-  #if HAS_BUZZER
-    // Buzz and wait. Is the delay needed for buttons to settle?
-    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-    #if HAS_LCD_MENU
-      #if USE_BEEPER
-        for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-      #else
-        delay(10);
-      #endif
+  #if HAS_CHIRP
+    chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #elif HAS_LCD_MENU
+      delay(10);
     #endif
   #endif
 }
 
 ////////////////////////////////////////////
 /////////////// Manual Move ////////////////
 ////////////////////////////////////////////
 
 #if HAS_LCD_MENU
 

commit 0b0ba7dcf612a5ae0f59d3e3697e2baff8ce4464
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed May 20 22:28:02 2020 +0200

    Fix LCD throttle issue (#18055)
    
    Fixes #18044

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 76aa773cd3..12c005a918 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -874,21 +874,21 @@ void MarlinUI::update() {
           leds.reset_timeout(ms);
         #endif
       }
 
     #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (on_status_screen() && !lcd_status_update_delay--) {
       lcd_status_update_delay = TERN(HAS_GRAPHICAL_LCD, 12, 9);
-      max_display_update_time--;
+      if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
           filename_scroll_pos = 0;

commit 00e7599c8caaf9d76024bcb000df169bfe3bfe8a
Author: Desuuuu <contact@desuuuu.com>
Date:   Mon May 11 02:19:23 2020 +0000

    Fix host_action_notify and string types (#17953)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5ed529df76..76aa773cd3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1296,21 +1296,21 @@ void MarlinUI::update() {
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
     finish_status(level > 0);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
     if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(message));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
 
     // Get a pointer to the null terminator
     PGM_P pend = message + strlen_P(message);
 
     // If length of supplied UTF8 string is greater than
     // the buffer size, start cutting whole UTF8 chars
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
@@ -1443,24 +1443,24 @@ void MarlinUI::update() {
 
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const message, const bool) {
     TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
   }
   void MarlinUI::set_status_P(PGM_P message, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
   }
   void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
   }
 
 #endif // !HAS_DISPLAY
 
 #if ENABLED(SDSUPPORT)
 
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
     if (old_status == status) {
       TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
       return;

commit 71b41c963b617204f45286cddd029d4c1a4c664c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 10 00:37:19 2020 -0500

    Better EEPROM alert message

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9e0a5580f7..5ed529df76 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1533,21 +1533,21 @@ void MarlinUI::update() {
         case 0: return GET_TEXT(MSG_ERR_EEPROM_CRC);
         case 1: return GET_TEXT(MSG_ERR_EEPROM_INDEX);
         case 2: return GET_TEXT(MSG_ERR_EEPROM_VERSION);
       }
     }
 
     void MarlinUI::eeprom_alert(const uint8_t msgid) {
       #if HAS_LCD_MENU
         editable.uint8 = msgid;
         goto_screen([]{
-          PGM_P const restore_msg = GET_TEXT(MSG_RESTORE_DEFAULTS);
+          PGM_P const restore_msg = GET_TEXT(MSG_INIT_EEPROM);
           char msg[utf8_strlen_P(restore_msg) + 1];
           strcpy_P(msg, restore_msg);
           MenuItem_confirm::select_screen(
             GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
             init_eeprom, return_to_status,
             eeprom_err(editable.uint8), msg, PSTR("?")
           );
         });
       #else
         set_status_P(eeprom_err(msgid));

commit 52aa459a2dc08a8f803ad9ffb7aa173dc449637f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 10 00:12:56 2020 -0500

    Improved EEPROM boot error (#17916)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1193a2fee7..9e0a5580f7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -88,20 +88,21 @@ MarlinUI ui;
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
+#include "../module/configuration_store.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../feature/tmc_util.h"
@@ -872,25 +873,21 @@ void MarlinUI::update() {
         #ifdef LED_BACKLIGHT_TIMEOUT
           leds.reset_timeout(ms);
         #endif
       }
 
     #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (on_status_screen() && !lcd_status_update_delay--) {
-      lcd_status_update_delay = 9
-        #if HAS_GRAPHICAL_LCD
-          + 3
-        #endif
-      ;
+      lcd_status_update_delay = TERN(HAS_GRAPHICAL_LCD, 12, 9);
       max_display_update_time--;
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
@@ -1160,25 +1157,21 @@ void MarlinUI::update() {
          */
         uint8_t val = 0;
         WRITE(SHIFT_LD, LOW);
         WRITE(SHIFT_LD, HIGH);
         LOOP_L_N(i, 8) {
           val >>= 1;
           if (READ(SHIFT_OUT)) SBI(val, 7);
           WRITE(SHIFT_CLK, HIGH);
           WRITE(SHIFT_CLK, LOW);
         }
-        #if ENABLED(REPRAPWORLD_KEYPAD)
-          keypad_buttons = ~val;
-        #else
-          buttons = ~val;
-        #endif
+        TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
       #endif
 
     } // next_button_update_ms
 
     #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3
@@ -1231,21 +1224,21 @@ void MarlinUI::update() {
     }
     char* MarlinUI::status_and_len(uint8_t &len) {
       char *out = status_message + status_scroll_offset;
       len = utf8_strlen(out);
       return out;
     }
   #endif
 
   void MarlinUI::finish_status(const bool persist) {
 
-    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
+    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
       UNUSED(persist);
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       const millis_t ms = millis();
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_ms = ms;
       #if PROGRESS_MSG_EXPIRE > 0
@@ -1431,66 +1424,43 @@ void MarlinUI::update() {
     if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
 
     MarlinUI::progress_t MarlinUI::_get_progress() {
-      #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-        const progress_t p = progress_override & PROGRESS_MASK;
-      #else
-        constexpr progress_t p = 0;
-      #endif
-      return (p
+      return (
+        TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
         #if ENABLED(SDSUPPORT)
-          #if HAS_PRINT_PROGRESS_PERMYRIAD
-            ?: card.permyriadDone()
-          #else
-            ?: card.percentDone()
-          #endif
+          ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
         #endif
       );
     }
 
   #endif
 
 #else // !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
   //
-
   void MarlinUI::set_status(const char * const message, const bool) {
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_action_notify(message);
-    #else
-      UNUSED(message);
-    #endif
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
   }
-
   void MarlinUI::set_status_P(PGM_P message, const int8_t) {
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_action_notify(message);
-    #else
-      UNUSED(message);
-    #endif
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
   }
-
   void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_action_notify(message);
-    #else
-      UNUSED(message);
-    #endif
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
   }
 
 #endif // !HAS_DISPLAY
 
 #if ENABLED(SDSUPPORT)
 
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
     if (old_status == status) {
       TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
       return;
@@ -1500,21 +1470,23 @@ void MarlinUI::update() {
       if (old_status < 2) {
         TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
         set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
       }
     }
     else {
       if (old_status < 2) {
         TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
         #if PIN_EXISTS(SD_DETECT)
           set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
-          TERN_(HAS_LCD_MENU, return_to_status());
+          #if HAS_LCD_MENU
+            if (!defer_return_to_status) return_to_status();
+          #endif
         #endif
       }
     }
 
     #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
       init_lcd(); // Revive a noisy shared SPI LCD
     #endif
 
     refresh();
 
@@ -1523,10 +1495,63 @@ void MarlinUI::update() {
     #endif
 
     TERN_(HAS_SPI_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
 
     #ifdef LED_BACKLIGHT_TIMEOUT
       leds.reset_timeout(ms);
     #endif
   }
 
 #endif // SDSUPPORT
+
+#if HAS_LCD_MENU
+  void MarlinUI::reset_settings() { settings.reset(); completion_feedback(); }
+#endif
+
+#if ENABLED(EEPROM_SETTINGS)
+
+  #if HAS_LCD_MENU
+    void MarlinUI::init_eeprom() {
+      const bool good = settings.init_eeprom();
+      completion_feedback(good);
+      return_to_status();
+    }
+    void MarlinUI::load_settings() {
+      const bool good = settings.load();
+      completion_feedback(good);
+    }
+    void MarlinUI::store_settings() {
+      const bool good = settings.save();
+      completion_feedback(good);
+    }
+  #endif
+
+  #if DISABLED(EEPROM_AUTO_INIT)
+
+    static inline PGM_P eeprom_err(const uint8_t msgid) {
+      switch (msgid) {
+        default:
+        case 0: return GET_TEXT(MSG_ERR_EEPROM_CRC);
+        case 1: return GET_TEXT(MSG_ERR_EEPROM_INDEX);
+        case 2: return GET_TEXT(MSG_ERR_EEPROM_VERSION);
+      }
+    }
+
+    void MarlinUI::eeprom_alert(const uint8_t msgid) {
+      #if HAS_LCD_MENU
+        editable.uint8 = msgid;
+        goto_screen([]{
+          PGM_P const restore_msg = GET_TEXT(MSG_RESTORE_DEFAULTS);
+          char msg[utf8_strlen_P(restore_msg) + 1];
+          strcpy_P(msg, restore_msg);
+          MenuItem_confirm::select_screen(
+            GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
+            init_eeprom, return_to_status,
+            eeprom_err(editable.uint8), msg, PSTR("?")
+          );
+        });
+      #else
+        set_status_P(eeprom_err(msgid));
+      #endif
+    }
+  #endif
+#endif

commit 7c26a54d3f2434c4d578f58af011a76dd298d4e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 6 03:34:05 2020 -0500

    Fix, clarify LCD_TIMEOUT_TO_STATUS
    
    Replaces #17887
    
    Co-Authored-By: Daniel Callander <knifa@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index deedbb4e14..1193a2fee7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -114,21 +114,21 @@ MarlinUI ui;
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
   #endif
 #endif
 
-#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
 millis_t MarlinUI::next_button_update_ms; // = 0
@@ -725,21 +725,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 millis_t next_lcd_update_ms;
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   millis_t ms = millis();
 
-  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
     static millis_t return_to_status_ms = 0;
     #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
   #else
     #define RESET_STATUS_TIMEOUT() NOOP
   #endif
 
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
 
@@ -960,21 +960,21 @@ void MarlinUI::update() {
       #endif
 
       TERN_(HAS_LCD_MENU, lcd_clicked = false);
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       if (on_status_screen())
         NOLESS(max_display_update_time, millis() - ms);
     }
 
-    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
       // Return to Status Screen after a timeout
       if (on_status_screen() || defer_return_to_status)
         RESET_STATUS_TIMEOUT();
       else if (ELAPSED(ms, return_to_status_ms))
         return_to_status();
     #endif
 
     // Change state of drawing flag between screen updates
     if (!drawing_screen) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:

commit a4c981469e317b30ff21fba109e1b126e5dcafcf
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Wed May 6 10:04:04 2020 +0530

    Extended reporting options (#16741)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 73f9cbaa29..deedbb4e14 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1340,27 +1340,27 @@ void MarlinUI::update() {
 
   PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status(const bool no_welcome) {
     PGM_P printing = GET_TEXT(MSG_PRINTING);
     PGM_P welcome  = GET_TEXT(WELCOME_MSG);
     #if SERVICE_INTERVAL_1 > 0
-      static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };
+      static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
     #endif
     #if SERVICE_INTERVAL_2 > 0
-      static const char service2[] PROGMEM = { "> " SERVICE_NAME_2 "!" };
+      static PGMSTR(service2, "> " SERVICE_NAME_2 "!");
     #endif
     #if SERVICE_INTERVAL_3 > 0
-      static const char service3[] PROGMEM = { "> " SERVICE_NAME_3 "!" };
+      static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
     #endif
     PGM_P msg;
     if (printingIsPaused())
       msg = print_paused;
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
       msg = printing;

commit c536b8de629807b489f054051bb120457f112a11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 25 17:53:06 2020 -0500

    Apply ternary macros

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 82b93092d7..73f9cbaa29 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -631,21 +631,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 #if HAS_LCD_MENU
 
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
 
   #if IS_KINEMATIC
     bool MarlinUI::processing_manual_move = false;
     float manual_move_offset = 0;
   #endif
 
-  #if E_MANUAL > 1
+  #if MULTI_MANUAL
     int8_t MarlinUI::manual_move_e_index = 0;
   #endif
 
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send a move immediately.
    */
   void MarlinUI::manage_manual_move() {
 
     if (processing_manual_move) return;

commit 2efbca55352c907e933ac31c6d4da9d1e54cedc0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 22:46:45 2020 -0500

    Composite test followup
    
    See ab2b98e425

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6991c681b1..82b93092d7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1128,21 +1128,21 @@ void MarlinUI::update() {
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
           #if BOTH(TOUCH_BUTTONS, HAS_ENCODER_ACTION)
-            | (touch_buttons & TERN_(HAS_ENCODER_WHEEL, & ~(EN_A | EN_B)))
+            | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
           #endif
         );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
       #if HAS_ADC_BUTTONS

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b427deba73..6991c681b1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -53,21 +53,21 @@ MarlinUI ui;
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
-#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+#if EITHER(HAS_SPI_LCD, EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
   #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
 #endif
@@ -359,21 +359,21 @@ bool MarlinUI::get_blink() {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
-#if ENABLED(REPRAPWORLD_KEYPAD) && HAS_ENCODER_ACTION
+#if BOTH(REPRAPWORLD_KEYPAD, HAS_ENCODER_ACTION)
 
   volatile uint8_t MarlinUI::keypad_buttons;
 
   #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
@@ -559,21 +559,21 @@ void MarlinUI::status_screen() {
         new_frm = old_frm;
     }
     else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
       new_frm = 100;
 
     LIMIT(new_frm, 10, 999);
 
     if (old_frm != new_frm) {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
-      #if HAS_BUZZER && ENABLED(BEEP_ON_FEEDRATE_CHANGE)
+      #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
         static millis_t next_beep;
         #ifndef GOT_MS
           const millis_t ms = millis();
         #endif
         if (ELAPSED(ms, next_beep)) {
           buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
           next_beep = ms + 500UL;
         }
       #endif
     }
@@ -820,21 +820,21 @@ void MarlinUI::update() {
       TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
       if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
         RESET_STATUS_TIMEOUT();
 
       const float abs_diff = ABS(encoderDiff);
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
-          #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
+          #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
               const float encoderMovementSteps = abs_diff / (ENCODER_PULSES_PER_STEP);
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
@@ -881,21 +881,21 @@ void MarlinUI::update() {
     if (on_status_screen() && !lcd_status_update_delay--) {
       lcd_status_update_delay = 9
         #if HAS_GRAPHICAL_LCD
           + 3
         #endif
       ;
       max_display_update_time--;
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
-    #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
+    #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
           filename_scroll_pos = 0;
           lcd_status_update_delay = 12;
         }
         refresh(LCDVIEW_REDRAW_NOW);
         RESET_STATUS_TIMEOUT();
@@ -1127,26 +1127,22 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
-          #if ENABLED(TOUCH_BUTTONS) && HAS_ENCODER_ACTION
-            | (touch_buttons
-              #if HAS_ENCODER_WHEEL
-                & (~(EN_A | EN_B))
-              #endif
-            )
+          #if BOTH(TOUCH_BUTTONS, HAS_ENCODER_ACTION)
+            | (touch_buttons & TERN_(HAS_ENCODER_WHEEL, & ~(EN_A | EN_B)))
           #endif
         );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
       #if HAS_ADC_BUTTONS
@@ -1254,21 +1250,21 @@ void MarlinUI::update() {
       progress_bar_ms = ms;
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = ms + 5000UL; // Show status message for 5s
     #endif
 
-    #if HAS_SPI_LCD && ENABLED(STATUS_MESSAGE_SCROLLING)
+    #if BOTH(HAS_SPI_LCD, STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
     if (alert_level) return;

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 980c561a7e..b427deba73 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -341,23 +341,21 @@ void MarlinUI::init() {
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
-  #if HAS_ENCODER_ACTION
-    encoderDiff = 0;
-  #endif
+  TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
@@ -480,23 +478,21 @@ bool MarlinUI::get_blink() {
 
 #if ENABLED(LCD_PROGRESS_BAR)
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
     millis_t MarlinUI::expire_status_ms; // = 0
   #endif
 #endif
 
 void MarlinUI::status_screen() {
 
-  #if HAS_LCD_MENU
-    ENCODER_RATE_MULTIPLY(false);
-  #endif
+  TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
     #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
@@ -583,41 +579,37 @@ void MarlinUI::status_screen() {
     }
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
 void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
   init();
   status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
-  #if HAS_LCD_MENU
-    return_to_status();
-  #endif
+  TERN_(HAS_LCD_MENU, return_to_status());
 
   // RED ALERT. RED ALERT.
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.set_color(LEDColorRed());
     #ifdef NEOPIXEL_BKGD_LED_INDEX
       neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
       neo.show();
     #endif
   #endif
 
   draw_kill_screen();
 }
 
 void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
-  #if HAS_LCD_MENU
-    refresh();
-  #endif
+  TERN_(HAS_LCD_MENU, refresh());
 
   #if HAS_ENCODER_ACTION
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
   #if HAS_BUZZER
     // Buzz and wait. Is the delay needed for buttons to settle?
@@ -770,30 +762,26 @@ void MarlinUI::update() {
       quick_feedback();                               //  - Always make a click sound
     };
 
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
-            #if ENABLED(AUTO_BED_LEVELING_UBL)
-              if (external_control) ubl.encoder_diff = encoderDiff;
-            #endif
+            TERN_(AUTO_BED_LEVELING_UBL, if (external_control) ubl.encoder_diff = encoderDiff);
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
-              #if HAS_BUZZER
-                buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-              #endif
+              TERN_(HAS_BUZZER, buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ));
             }
           }
         }
         else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
           do_click();
       }
       else // keep wait_for_unclick value
 
     #endif // TOUCH_BUTTONS
 
@@ -806,51 +794,40 @@ void MarlinUI::update() {
           wait_for_unclick = false;
       }
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
       goto_previous_screen();
     }
 
   #endif // HAS_LCD_MENU
 
-  if (ELAPSED(ms, next_lcd_update_ms)
-    #if HAS_GRAPHICAL_LCD
-      || drawing_screen
-    #endif
-  ) {
+  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_GRAPHICAL_LCD, drawing_screen)) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(TOUCH_BUTTONS)
 
       if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
-      #if HAS_ENCODER_ACTION
-        touch_buttons = touch.read_buttons();
-      #endif
+      TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
 
     #endif
 
-    #if ENABLED(LCD_HAS_STATUS_INDICATORS)
-      update_indicators();
-    #endif
+    TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
 
     #if HAS_ENCODER_ACTION
 
-      #if HAS_SLOW_BUTTONS
-        slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
-      #endif
+      TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
-      #if ENABLED(REPRAPWORLD_KEYPAD)
-        if (handle_keypad()) RESET_STATUS_TIMEOUT();
-      #endif
+      if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
+        RESET_STATUS_TIMEOUT();
 
       const float abs_diff = ABS(encoderDiff);
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
@@ -936,23 +913,21 @@ void MarlinUI::update() {
           refresh(LCDVIEW_NONE);
           break;
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:
           refresh(LCDVIEW_REDRAW_NOW);
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
-      #if HAS_ADC_BUTTONS
-        keypad_buttons = 0;
-      #endif
+      TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
 
       #if HAS_GRAPHICAL_LCD
 
         #if ENABLED(LIGHTWEIGHT_UI)
           const bool in_status = on_status_screen(),
                      do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) status_screen();
         #else
           constexpr bool do_u8g_loop = true;
@@ -977,23 +952,21 @@ void MarlinUI::update() {
             return;
           }
         }
 
       #else
 
         run_current_screen();
 
       #endif
 
-      #if HAS_LCD_MENU
-        lcd_clicked = false;
-      #endif
+      TERN_(HAS_LCD_MENU, lcd_clicked = false);
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       if (on_status_screen())
         NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
       // Return to Status Screen after a timeout
       if (on_status_screen() || defer_return_to_status)
@@ -1222,23 +1195,21 @@ void MarlinUI::update() {
       if (buttons & EN_A) enc |= B01;
       if (buttons & EN_B) enc |= B10;
       if (enc != lastEncoderBits) {
         switch (enc) {
           case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
           case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
           case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
           case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
         }
         if (external_control) {
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-            ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
-          #endif
+          TERN_(AUTO_BED_LEVELING_UBL, ubl.encoder_diff = encoderDiff); // Make encoder rotation available to UBL G29 mesh editing.
           encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
         }
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
 #endif // HAS_ENCODER_ACTION
 
@@ -1287,33 +1258,29 @@ void MarlinUI::update() {
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = ms + 5000UL; // Show status message for 5s
     #endif
 
     #if HAS_SPI_LCD && ENABLED(STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
-    #if ENABLED(EXTENSIBLE_UI)
-      ExtUI::onStatusChanged(status_message);
-    #endif
+    TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
     if (alert_level) return;
 
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_action_notify(message);
-    #endif
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!
 
     // Get a pointer to the null terminator
     const char* pend = message + strlen(message);
 
     //  If length of supplied UTF8 string is greater than
     // our buffer size, start cutting whole UTF8 chars
@@ -1340,23 +1307,21 @@ void MarlinUI::update() {
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
     finish_status(level > 0);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
     if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
 
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_action_notify(message);
-    #endif
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
 
     // Get a pointer to the null terminator
     PGM_P pend = message + strlen_P(message);
 
     // If length of supplied UTF8 string is greater than
     // the buffer size, start cutting whole UTF8 chars
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
@@ -1367,23 +1332,21 @@ void MarlinUI::update() {
     // At this point, we have the proper cut point. Use it
     uint8_t maxLen = pend - message;
     strncpy_P(status_message, message, maxLen);
     status_message[maxLen] = '\0';
 
     finish_status(level > 0);
   }
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
-    #if HAS_LCD_MENU
-      return_to_status();
-    #endif
+    TERN_(HAS_LCD_MENU, return_to_status());
   }
 
   PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status(const bool no_welcome) {
     PGM_P printing = GET_TEXT(MSG_PRINTING);
     PGM_P welcome  = GET_TEXT(WELCOME_MSG);
@@ -1429,63 +1392,53 @@ void MarlinUI::update() {
   #endif
 
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR);
-    #endif
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
     print_job_timer.stop();
     set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
-    #if HAS_LCD_MENU
-      return_to_status();
-    #endif
+    TERN_(HAS_LCD_MENU, return_to_status());
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
       synchronize(GET_TEXT(MSG_PAUSING));
       defer_status_screen();
     #endif
 
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
-    #endif
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
 
     set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
-      #if HAS_SPI_LCD
-        lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
-      #endif
+      TERN_(HAS_SPI_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      wait_for_heatup = wait_for_user = false;
-    #endif
+    TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
     if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
 
     MarlinUI::progress_t MarlinUI::_get_progress() {
@@ -1536,58 +1489,48 @@ void MarlinUI::update() {
       UNUSED(message);
     #endif
   }
 
 #endif // !HAS_DISPLAY
 
 #if ENABLED(SDSUPPORT)
 
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
     if (old_status == status) {
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onMediaError();      // Failed to mount/unmount
-      #endif
+      TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
       return;
     }
 
     if (status) {
       if (old_status < 2) {
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMediaInserted(); // ExtUI response
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
         set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
       }
     }
     else {
       if (old_status < 2) {
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMediaRemoved();  // ExtUI response
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
         #if PIN_EXISTS(SD_DETECT)
           set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
-          #if HAS_LCD_MENU
-            return_to_status();
-          #endif
+          TERN_(HAS_LCD_MENU, return_to_status());
         #endif
       }
     }
 
     #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
       init_lcd(); // Revive a noisy shared SPI LCD
     #endif
 
     refresh();
 
     #if HAS_SPI_LCD || defined(LED_BACKLIGHT_TIMEOUT)
       const millis_t ms = millis();
     #endif
 
-    #if HAS_SPI_LCD
-      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // Delay LCD update for SD activity
-    #endif
+    TERN_(HAS_SPI_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
 
     #ifdef LED_BACKLIGHT_TIMEOUT
       leds.reset_timeout(ms);
     #endif
   }
 
 #endif // SDSUPPORT

commit e4903396d4ac2fa9b89dd535dae9c3e8a68b3526
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 11 20:36:17 2020 -0500

    Fix up pausing / parking display (#17460)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7aac51ee81..980c561a7e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -631,22 +631,20 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
   #endif
 }
 
 ////////////////////////////////////////////
 /////////////// Manual Move ////////////////
 ////////////////////////////////////////////
 
 #if HAS_LCD_MENU
 
-  extern bool no_reentry; // Flag to prevent recursion into menu handlers
-
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
 
   #if IS_KINEMATIC
     bool MarlinUI::processing_manual_move = false;
     float manual_move_offset = 0;
   #endif
 
   #if E_MANUAL > 1
     int8_t MarlinUI::manual_move_e_index = 0;
@@ -760,21 +758,21 @@ void MarlinUI::update() {
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
     auto do_click = [&]{
       wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
-      lcd_clicked = !wait_for_user && !no_reentry;    //  - Keep the click if not waiting for a user-click
+      lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
       wait_for_user = false;                          //  - Any click clears wait for user
       quick_feedback();                               //  - Always make a click sound
     };
 
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
@@ -1448,31 +1446,32 @@ void MarlinUI::update() {
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
       synchronize(GET_TEXT(MSG_PAUSING));
+      defer_status_screen();
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
-        lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
+        lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {

commit c2bd9dd4f50a7d501adf31453b348c4c3b70888e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 9 18:09:36 2020 -0500

    Show "Pausing…" during pause

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 08597451a0..7aac51ee81 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1447,21 +1447,21 @@ void MarlinUI::update() {
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
-      synchronize(GET_TEXT(MSG_PAUSE_PRINT));
+      synchronize(GET_TEXT(MSG_PAUSING));
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD

commit 07b3f38269c605fb79eab53516ddaef33155fb05
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 4 23:51:11 2020 -0500

    First SD status change is silent

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 10a717b6fe..08597451a0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1544,31 +1544,32 @@ void MarlinUI::update() {
 
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
     if (old_status == status) {
       #if ENABLED(EXTENSIBLE_UI)
         ExtUI::onMediaError();      // Failed to mount/unmount
       #endif
       return;
     }
 
     if (status) {
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onMediaInserted();   // ExtUI response
-      #endif
-      if (old_status < 2)
+      if (old_status < 2) {
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMediaInserted(); // ExtUI response
+        #endif
         set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+      }
     }
     else {
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onMediaRemoved();    // ExtUI response
-      #endif
       if (old_status < 2) {
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMediaRemoved();  // ExtUI response
+        #endif
         #if PIN_EXISTS(SD_DETECT)
           set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
           #if HAS_LCD_MENU
             return_to_status();
           #endif
         #endif
       }
     }
 
     #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)

commit 65f6a373b0a77da23f0758d5d1520e404436cec0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 4 00:08:25 2020 -0500

    Refactor SD detect handler (#17380)
    
    Co-Authored-By: Eric Ptak <trouch@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ff0331eb20..10a717b6fe 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -114,24 +114,20 @@ MarlinUI ui;
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
   #endif
 #endif
 
-#if ENABLED(INIT_SDCARD_ON_BOOT)
-  uint8_t lcd_sd_status;
-#endif
-
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
@@ -335,27 +331,22 @@ void MarlinUI::init() {
       OUT_WRITE(SHIFT_LD, HIGH);
       #if defined(SHIFT_EN) && SHIFT_EN >= 0
         OUT_WRITE(SHIFT_EN, LOW);
       #endif
       SET_INPUT_PULLUP(SHIFT_OUT);
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
-  #if ENABLED(SDSUPPORT)
-    #if PIN_EXISTS(SD_DETECT)
-      SET_INPUT_PULLUP(SD_DETECT_PIN);
-    #endif
-    #if ENABLED(INIT_SDCARD_ON_BOOT)
-      lcd_sd_status = 2; // UNKNOWN
-    #endif
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+    SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
@@ -737,25 +728,25 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  *             so don't change lcdDrawUpdate without considering this.
  *
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * This function is only called from the main thread.
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+millis_t next_lcd_update_ms;
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
-  static millis_t next_lcd_update_ms;
   millis_t ms = millis();
 
   #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
     static millis_t return_to_status_ms = 0;
     #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
   #else
     #define RESET_STATUS_TIMEOUT() NOOP
   #endif
 
   #ifdef LED_BACKLIGHT_TIMEOUT
@@ -817,67 +808,20 @@ void MarlinUI::update() {
           wait_for_unclick = false;
       }
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
       goto_previous_screen();
     }
 
   #endif // HAS_LCD_MENU
 
-  #if ENABLED(INIT_SDCARD_ON_BOOT)
-    //
-    // SPI SD Card detection (and first card init when the LCD is present)
-    //
-    const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
-    if (sd_status != lcd_sd_status && detected()) {
-
-      uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
-      lcd_sd_status = sd_status;
-
-      if (sd_status) {
-        safe_delay(500); // Some boards need a delay to get settled
-        card.mount();
-        if (old_sd_status == 2)
-          card.beginautostart();  // Initial boot
-        else
-          set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
-      }
-      #if PIN_EXISTS(SD_DETECT)
-        else {
-          card.release();
-          if (old_sd_status != 2) {
-            set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
-            #if HAS_LCD_MENU
-              return_to_status();
-            #endif
-          }
-        }
-
-        #if DISABLED(NO_LCD_REINIT)
-          init_lcd(); // May revive the LCD if static electricity killed it
-        #endif
-
-      #endif
-
-      refresh();
-
-      ms = millis();
-      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
-
-      #ifdef LED_BACKLIGHT_TIMEOUT
-        leds.reset_timeout(ms);
-      #endif
-    }
-
-  #endif // INIT_SDCARD_ON_BOOT
-
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(TOUCH_BUTTONS)
 
@@ -1588,10 +1532,62 @@ void MarlinUI::update() {
 
   void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_action_notify(message);
     #else
       UNUSED(message);
     #endif
   }
 
 #endif // !HAS_DISPLAY
+
+#if ENABLED(SDSUPPORT)
+
+  void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
+    if (old_status == status) {
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onMediaError();      // Failed to mount/unmount
+      #endif
+      return;
+    }
+
+    if (status) {
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onMediaInserted();   // ExtUI response
+      #endif
+      if (old_status < 2)
+        set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+    }
+    else {
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onMediaRemoved();    // ExtUI response
+      #endif
+      if (old_status < 2) {
+        #if PIN_EXISTS(SD_DETECT)
+          set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
+          #if HAS_LCD_MENU
+            return_to_status();
+          #endif
+        #endif
+      }
+    }
+
+    #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
+      init_lcd(); // Revive a noisy shared SPI LCD
+    #endif
+
+    refresh();
+
+    #if HAS_SPI_LCD || defined(LED_BACKLIGHT_TIMEOUT)
+      const millis_t ms = millis();
+    #endif
+
+    #if HAS_SPI_LCD
+      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // Delay LCD update for SD activity
+    #endif
+
+    #ifdef LED_BACKLIGHT_TIMEOUT
+      leds.reset_timeout(ms);
+    #endif
+  }
+
+#endif // SDSUPPORT

commit 514afddeb4b3a7ede9ff481504aae69219a95f68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 18:53:58 2020 -0500

    Minor code cleanup

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bbcb678dd8..ff0331eb20 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -344,24 +344,22 @@ void MarlinUI::init() {
 
   #if ENABLED(SDSUPPORT)
     #if PIN_EXISTS(SD_DETECT)
       SET_INPUT_PULLUP(SD_DETECT_PIN);
     #endif
     #if ENABLED(INIT_SDCARD_ON_BOOT)
       lcd_sd_status = 2; // UNKNOWN
     #endif
   #endif
 
-  #if HAS_ENCODER_ACTION
-    #if HAS_SLOW_BUTTONS
-      slow_buttons = 0;
-    #endif
+  #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
+    slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
 bool MarlinUI::get_blink() {

commit 747b964295118d425ad41cd7593dae48ccf9f14f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 28 03:18:53 2020 -0500

    Clean up user-wait, SD completion (#17315)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7ff1440559..bbcb678dd8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -769,60 +769,58 @@ void MarlinUI::update() {
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
+    auto do_click = [&]{
+      wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
+      lcd_clicked = !wait_for_user && !no_reentry;    //  - Keep the click if not waiting for a user-click
+      wait_for_user = false;                          //  - Any click clears wait for user
+      quick_feedback();                               //  - Always make a click sound
+    };
+
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               if (external_control) ubl.encoder_diff = encoderDiff;
             #endif
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
             }
           }
         }
-        else if (!wait_for_unclick && (buttons & EN_C)) { // OK button, if not waiting for a debounce release:
-          wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
-          lcd_clicked = !wait_for_user && !no_reentry;    //  - Keep the click if not waiting for a user-click
-          wait_for_user = false;                          //  - Any click clears wait for user
-          quick_feedback();                               //  - Always make a click sound
-        }
+        else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
+          do_click();
       }
       else // keep wait_for_unclick value
 
     #endif // TOUCH_BUTTONS
 
       {
         // Integrated LCD click handling via button_pressed
         if (!external_control && button_pressed()) {
-          if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-            wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-            lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-            wait_for_user = false;                        //  - Any click clears wait for user
-            quick_feedback();                             //  - Always make a click sound
-          }
+          if (!wait_for_unclick) do_click();              // Handle the click
         }
         else
           wait_for_unclick = false;
       }
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
       goto_previous_screen();
     }
 

commit d6a4c3079dc261b94aeccfc5f2031b589744bc67
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 20:47:27 2020 -0500

    Tweak ui.finish_status

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1cb23baa25..7ff1440559 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -517,21 +517,21 @@ void MarlinUI::status_screen() {
 
     // If the message will blink rather than expire...
     #if DISABLED(PROGRESS_MSG_ONCE)
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 
       // Handle message expire
-      if (expire_status_ms > 0) {
+      if (expire_status_ms) {
 
         // Expire the message if a job is active and the bar has ticks
         if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
           if (ELAPSED(ms, expire_status_ms)) {
             status_message[0] = '\0';
             expire_status_ms = 0;
           }
         }
         else {
           // Defer message expiration before bar appears
@@ -1330,29 +1330,33 @@ void MarlinUI::update() {
       return out;
     }
   #endif
 
   void MarlinUI::finish_status(const bool persist) {
 
     #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
       UNUSED(persist);
     #endif
 
+    #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      const millis_t ms = millis();
+    #endif
+
     #if ENABLED(LCD_PROGRESS_BAR)
-      progress_bar_ms = millis();
+      progress_bar_ms = ms;
       #if PROGRESS_MSG_EXPIRE > 0
-        expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
+        expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-      next_filament_display = millis() + 5000UL; // Show status message for 5s
+      next_filament_display = ms + 5000UL; // Show status message for 5s
     #endif
 
     #if HAS_SPI_LCD && ENABLED(STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif
   }

commit abea6d5787654dc67bc86ac75207a997da9a7219
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 18 10:30:19 2020 -0500

    Tweak some lambdas

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 48129b61ae..1cb23baa25 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -220,21 +220,21 @@ millis_t MarlinUI::next_button_update_ms; // = 0
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
   void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
     SETCURSOR(col, row);
     if (!string) return;
 
-    auto _newline = [&col, &row]() {
+    auto _newline = [&col, &row]{
       col = 0; row++;                 // Move col to string len (plus space)
       SETCURSOR(0, row);              // Simulate carriage return
     };
 
     uint8_t *p = (uint8_t*)string;
     wchar_t ch;
     if (wordwrap) {
       uint8_t *wrd = nullptr, c = 0;
       // find the end of the part
       for (;;) {

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b929acbd85..48129b61ae 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1129,21 +1129,21 @@ void MarlinUI::update() {
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
        ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
   };
 
   uint8_t get_ADC_keyValue() {
     if (thermalManager.ADCKey_count >= 16) {
       const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
       thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < adc_other_button)
-        for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
+        LOOP_L_N(i, ADC_KEY_NUM) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 
 #endif // HAS_ADC_BUTTONS
 

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b67ec0ab4e..b929acbd85 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1302,21 +1302,21 @@ void MarlinUI::update() {
     #endif // HAS_ENCODER_WHEEL
   }
 
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 
 #if HAS_DISPLAY
 
   #if ENABLED(EXTENSIBLE_UI)
-    #include "extensible_ui/ui_api.h"
+    #include "extui/ui_api.h"
   #endif
 
   ////////////////////////////////////////////
   /////////////// Status Line ////////////////
   ////////////////////////////////////////////
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     void MarlinUI::advance_status_scroll() {
       // Advance by one UTF8 code-word
       if (status_scroll_offset < utf8_strlen(status_message))

commit c083728e4cf426b9d1c5da8881ea562afa7de5a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 17:43:37 2020 -0600

    General code cleanup

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 47cd8df80e..b67ec0ab4e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1238,21 +1238,21 @@ void MarlinUI::update() {
 
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }
       #endif
 
-      #if HAS_SHIFT_ENCODER      
+      #if HAS_SHIFT_ENCODER
         /**
          * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
          * These values are independent of which pins are used for EN_A / EN_B indications.
          * The rotary encoder part is also independent of the LCD chipset.
          */
         uint8_t val = 0;
         WRITE(SHIFT_LD, LOW);
         WRITE(SHIFT_LD, HIGH);
         LOOP_L_N(i, 8) {
           val >>= 1;

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 87d061c908..47cd8df80e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -96,21 +96,21 @@ MarlinUI ui;
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ADC_BUTTONS
   #include "../module/thermistor/thermistors.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS

commit 5da6819277951aaf12a10f36ef5b99444a4dab3a
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Mar 1 17:54:22 2020 -0800

    Fix build issues with REPRAPWORLD_KEYPAD (#17038)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 422c8b0b81..87d061c908 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -384,21 +384,21 @@ bool MarlinUI::get_blink() {
   volatile uint8_t MarlinUI::keypad_buttons;
 
   #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
       move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-      encoderPosition = dir;
+      ui.encoderPosition = dir;
       switch (axis) {
         case X_AXIS: lcd_move_x(); break;
         case Y_AXIS: lcd_move_y(); break;
         case Z_AXIS: lcd_move_z();
         default: break;
       }
     }
 
   #endif
 
@@ -1142,41 +1142,20 @@ void MarlinUI::update() {
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 
 #endif // HAS_ADC_BUTTONS
 
 #if HAS_ENCODER_ACTION
 
-  #if DISABLED(ADC_KEYPAD) && (ENABLED(REPRAPWORLD_KEYPAD) || !HAS_DIGITAL_BUTTONS)
-
-    /**
-     * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
-     * These values are independent of which pins are used for EN_A and EN_B indications
-     * The rotary encoder part is also independent to the chipset used for the LCD
-     */
-    #define GET_SHIFT_BUTTON_STATES(DST) \
-      uint8_t new_##DST = 0; \
-      WRITE(SHIFT_LD, LOW); \
-      WRITE(SHIFT_LD, HIGH); \
-      for (int8_t i = 0; i < 8; i++) { \
-        new_##DST >>= 1; \
-        if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
-        WRITE(SHIFT_CLK, HIGH); \
-        WRITE(SHIFT_CLK, LOW); \
-      } \
-      DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
-
-  #endif
-
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void MarlinUI::update_buttons() {
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if HAS_DIGITAL_BUTTONS
 
@@ -1259,30 +1238,40 @@ void MarlinUI::update() {
 
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }
       #endif
 
-      #if HAS_SHIFT_ENCODER
-
-        GET_SHIFT_BUTTON_STATES((
-          #if ENABLED(REPRAPWORLD_KEYPAD)
-            keypad_buttons
-          #else
-            buttons
-          #endif
-        ));
-
+      #if HAS_SHIFT_ENCODER      
+        /**
+         * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
+         * These values are independent of which pins are used for EN_A / EN_B indications.
+         * The rotary encoder part is also independent of the LCD chipset.
+         */
+        uint8_t val = 0;
+        WRITE(SHIFT_LD, LOW);
+        WRITE(SHIFT_LD, HIGH);
+        LOOP_L_N(i, 8) {
+          val >>= 1;
+          if (READ(SHIFT_OUT)) SBI(val, 7);
+          WRITE(SHIFT_CLK, HIGH);
+          WRITE(SHIFT_CLK, LOW);
+        }
+        #if ENABLED(REPRAPWORLD_KEYPAD)
+          keypad_buttons = ~val;
+        #else
+          buttons = ~val;
+        #endif
       #endif
 
     } // next_button_update_ms
 
     #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3

commit cdcd45d651adb4b8997ea27d8815fa59b3efea14
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 26 04:04:02 2020 -0500

    Set LCD status for EEPROM errors (#16977)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8ad02acfba..422c8b0b81 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1446,21 +1446,21 @@ void MarlinUI::update() {
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
 
   /**
    * Reset the status message
    */
-  void MarlinUI::reset_status() {
+  void MarlinUI::reset_status(const bool no_welcome) {
     PGM_P printing = GET_TEXT(MSG_PRINTING);
     PGM_P welcome  = GET_TEXT(WELCOME_MSG);
     #if SERVICE_INTERVAL_1 > 0
       static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };
     #endif
     #if SERVICE_INTERVAL_2 > 0
       static const char service2[] PROGMEM = { "> " SERVICE_NAME_2 "!" };
     #endif
     #if SERVICE_INTERVAL_3 > 0
       static const char service3[] PROGMEM = { "> " SERVICE_NAME_3 "!" };
@@ -1478,22 +1478,24 @@ void MarlinUI::update() {
     #if SERVICE_INTERVAL_1 > 0
       else if (print_job_timer.needsService(1)) msg = service1;
     #endif
     #if SERVICE_INTERVAL_2 > 0
       else if (print_job_timer.needsService(2)) msg = service2;
     #endif
     #if SERVICE_INTERVAL_3 > 0
       else if (print_job_timer.needsService(3)) msg = service3;
     #endif
 
-    else
+    else if (!no_welcome)
       msg = welcome;
+    else
+      return;
 
     set_status_P(msg, -1);
   }
 
   #if ENABLED(SDSUPPORT)
     extern bool wait_for_user, wait_for_heatup;
   #endif
 
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)

commit 073e4443e8b8624078138a0c6f422cccc2959a86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 14 00:05:06 2020 -0600

    Optimize "Dismiss" string

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 717a3f05d8..8ad02acfba 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1497,21 +1497,21 @@ void MarlinUI::update() {
 
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
     #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), PSTR("Dismiss"));
+      host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR);
     #endif
     print_job_timer.stop();
     set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index eaeddcd106..717a3f05d8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 7f9c62437e5c72947acc3310d94829f132697c81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 3 00:00:35 2020 -0600

    Corner Leveling: Add inset for each side (#16759)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 35366d761c..eaeddcd106 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -666,21 +666,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send a move immediately.
    */
   void MarlinUI::manage_manual_move() {
 
     if (processing_manual_move) return;
 
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
 
-      const feedRate_t fr_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
+      const feedRate_t fr_mm_s = manual_feedrate_mm_s[manual_move_axis];
       #if IS_KINEMATIC
 
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
           if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
         destination = current_position;
         destination[manual_move_axis] += manual_move_offset;

commit c45d6b2017fa45cbb0f417dc6aaf06828b2b4671
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jan 30 21:29:30 2020 +0300

    Simultaneous use of rotary encoder and touch buttons (#16729)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 04ebd5079f..35366d761c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -770,27 +770,26 @@ void MarlinUI::update() {
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
     #if ENABLED(TOUCH_BUTTONS)
-
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
-        if (buttons & (EN_A | EN_B)) {                    // Menu arrows, in priority
+        if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
-            if (buttons & EN_A) encoderDiff *= -1;
+            if (touch_buttons & EN_A) encoderDiff *= -1;
             #if ENABLED(AUTO_BED_LEVELING_UBL)
               if (external_control) ubl.encoder_diff = encoderDiff;
             #endif
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
@@ -1239,21 +1238,25 @@ void MarlinUI::update() {
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
           #if ENABLED(TOUCH_BUTTONS) && HAS_ENCODER_ACTION
-            | touch_buttons
+            | (touch_buttons
+              #if HAS_ENCODER_WHEEL
+                & (~(EN_A | EN_B))
+              #endif
+            )
           #endif
         );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
       #if HAS_ADC_BUTTONS
@@ -1270,21 +1273,21 @@ void MarlinUI::update() {
             keypad_buttons
           #else
             buttons
           #endif
         ));
 
       #endif
 
     } // next_button_update_ms
 
-    #if HAS_ENCODER_WHEEL && DISABLED(TOUCH_BUTTONS)
+    #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3
       #define encrot3 1
 
       // Manage encoder rotation
       #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 

commit 95d5a0c480d655bf96a6989ad3df0f240ae343b2
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Jan 25 22:02:06 2020 -0800

    Fix DELTA_CALIBRATION_MENU recursive call (#16656)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 380b18a07c..04ebd5079f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -38,20 +38,24 @@ MarlinUI ui;
   #include "../module/printcounter.h"
   #include "../MarlinCore.h"
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
+#if LCD_HAS_WAIT_FOR_MOVE
+  bool MarlinUI::wait_for_move; // = false
+#endif
+
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif

commit ffd8b595d16dde892e0a48f2afd9b4e79bce47fa
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 13 21:52:24 2020 -0500

    Fix PLR cancel with ExtUI (#16556)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index edd14dcf12..380b18a07c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -88,24 +88,20 @@ MarlinUI ui;
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/motion.h"
 
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
-#endif
-
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ADC_BUTTONS
   #include "../module/thermistor/thermistors.h"
@@ -1512,24 +1508,20 @@ void MarlinUI::update() {
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
       synchronize(GET_TEXT(MSG_PAUSE_PRINT));
     #endif
 
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      if (recovery.enabled) recovery.save(true, false);
-    #endif
-
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
         lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif

commit cda363a15e03c34825ae4ba39e088d460fff3b9d
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Jan 3 04:26:03 2020 +0100

    Touch UI: Fix UBL mesh value editing (#16432)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0b562197f2..edd14dcf12 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -777,20 +777,23 @@ void MarlinUI::update() {
     static bool wait_for_unclick; // = false
 
     #if ENABLED(TOUCH_BUTTONS)
 
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (buttons & (EN_A | EN_B)) {                    // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (buttons & EN_A) encoderDiff *= -1;
+            #if ENABLED(AUTO_BED_LEVELING_UBL)
+              if (external_control) ubl.encoder_diff = encoderDiff;
+            #endif
             next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
             if (!wait_for_unclick) {
               next_button_update_ms += 250;               // Longer delay on first press
               wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
             }
           }
         }
@@ -1267,21 +1270,21 @@ void MarlinUI::update() {
             keypad_buttons
           #else
             buttons
           #endif
         ));
 
       #endif
 
     } // next_button_update_ms
 
-    #if HAS_ENCODER_WHEEL
+    #if HAS_ENCODER_WHEEL && DISABLED(TOUCH_BUTTONS)
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3
       #define encrot3 1
 
       // Manage encoder rotation
       #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e8176c1b1b..0b562197f2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -23,25 +23,27 @@
 #include "../inc/MarlinConfigPre.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../feature/host_actions.h"
 #endif
 
+// All displays share the MarlinUI class
 #include "ultralcd.h"
 MarlinUI ui;
 
-// All displays share the MarlinUI class
 #if HAS_DISPLAY
+  #include "../module/printcounter.h"
+  #include "../MarlinCore.h"
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
@@ -84,25 +86,22 @@ MarlinUI ui;
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
-#include "../module/printcounter.h"
 #include "../module/motion.h"
 
-#include "../Marlin.h"
-
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
@@ -1436,23 +1435,20 @@ void MarlinUI::update() {
     finish_status(level > 0);
   }
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
-  #include "../Marlin.h"
-  #include "../module/printcounter.h"
-
   PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
     PGM_P printing = GET_TEXT(MSG_PRINTING);
     PGM_P welcome  = GET_TEXT(WELCOME_MSG);
     #if SERVICE_INTERVAL_1 > 0
       static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };

commit ab61c09bffd8d9fa0bf696e9fbd057a85185dcad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Dec 6 07:47:50 2019 +0100

    Improve touch buttons behavior (#16109)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c2e00fcce6..e8176c1b1b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -193,20 +193,21 @@ millis_t MarlinUI::next_button_update_ms; // = 0
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
     }
   #endif
 
   #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
     int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
   #if ENABLED(TOUCH_BUTTONS)
+    uint8_t MarlinUI::touch_buttons;
     uint8_t MarlinUI::repeat_delay;
   #endif
 
   bool MarlinUI::lcd_clicked;
   float move_menu_scale;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
@@ -771,72 +772,60 @@ void MarlinUI::update() {
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = false
 
     #if ENABLED(TOUCH_BUTTONS)
 
-      #define TOUCH_MENU_MASK 0x80
-
-      static bool arrow_pressed; // = false
-
-      // Handle touch events which are slow to read
-      if (ELAPSED(ms, next_button_update_ms)) {
-        uint8_t touch_buttons = touch.read_buttons();
-        if (touch_buttons) {
-          RESET_STATUS_TIMEOUT();
-          if (touch_buttons & TOUCH_MENU_MASK) {        // Processing Menu Area touch?
-            if (!wait_for_unclick) {                    // If not waiting for a debounce release:
-              wait_for_unclick = true;                  //  - Set debounce flag to ignore continous clicks
-              wait_for_user = false;                    //  - Any click clears wait for user
-              // TODO for next PR.
-              //uint8_t tpos = touch_buttons & ~(TOUCH_MENU_MASK);  // Safe 7bit touched screen coordinate
-              next_button_update_ms = ms + 500;         // Defer next check for 1/2 second
-              #if HAS_LCD_MENU
-                refresh();
-              #endif
-            }
-            touch_buttons = 0;                          // Swallow the touch
-          }
-          buttons |= (touch_buttons & (EN_C | EN_D));   // Pass on Click and Back buttons
-          if (touch_buttons & (EN_A | EN_B)) {          // A and/or B button?
+      if (touch_buttons) {
+        RESET_STATUS_TIMEOUT();
+        if (buttons & (EN_A | EN_B)) {                    // Menu arrows, in priority
+          if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
-            if (touch_buttons & EN_A) encoderDiff *= -1;
-            next_button_update_ms = ms + repeat_delay;  // Assume the repeat delay
-            if (!wait_for_unclick && !arrow_pressed) {  // On click prepare for repeat
-              next_button_update_ms += 250;             // Longer delay on first press
-              arrow_pressed = true;                     // Mark arrow as pressed
+            if (buttons & EN_A) encoderDiff *= -1;
+            next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
+            if (!wait_for_unclick) {
+              next_button_update_ms += 250;               // Longer delay on first press
+              wait_for_unclick = true;                    // Avoid Back/Select click while repeating
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
             }
           }
         }
-        if (!(touch_buttons & (EN_A | EN_B))) arrow_pressed = false;
+        else if (!wait_for_unclick && (buttons & EN_C)) { // OK button, if not waiting for a debounce release:
+          wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
+          lcd_clicked = !wait_for_user && !no_reentry;    //  - Keep the click if not waiting for a user-click
+          wait_for_user = false;                          //  - Any click clears wait for user
+          quick_feedback();                               //  - Always make a click sound
+        }
       }
+      else // keep wait_for_unclick value
 
     #endif // TOUCH_BUTTONS
 
-    // Integrated LCD click handling via button_pressed
-    if (!external_control && button_pressed()) {
-      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-        wait_for_user = false;                        //  - Any click clears wait for user
-        quick_feedback();                             //  - Always make a click sound
+      {
+        // Integrated LCD click handling via button_pressed
+        if (!external_control && button_pressed()) {
+          if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+            wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+            lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+            wait_for_user = false;                        //  - Any click clears wait for user
+            quick_feedback();                             //  - Always make a click sound
+          }
+        }
+        else
+          wait_for_unclick = false;
       }
-    }
-    else
-      wait_for_unclick = false;
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
       goto_previous_screen();
     }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(INIT_SDCARD_ON_BOOT)
     //
@@ -887,22 +876,27 @@ void MarlinUI::update() {
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(TOUCH_BUTTONS)
-      if (on_status_screen())
-        next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
+
+      if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
+
+      #if HAS_ENCODER_ACTION
+        touch_buttons = touch.read_buttons();
+      #endif
+
     #endif
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if HAS_SLOW_BUTTONS
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
@@ -1242,20 +1236,23 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
+          #if ENABLED(TOUCH_BUTTONS) && HAS_ENCODER_ACTION
+            | touch_buttons
+          #endif
         );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {

commit 7126a5e5a7f2bcab61fd4ae89224fdb0cac9502e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Dec 1 18:39:28 2019 -0500

    Add Host Prompt Notification Method (#15942)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3b69807b75..c2e00fcce6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -19,33 +19,35 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../feature/host_actions.h"
+#endif
+
+#include "ultralcd.h"
+MarlinUI ui;
+
 // All displays share the MarlinUI class
 #if HAS_DISPLAY
   #include "../gcode/queue.h"
-  #include "ultralcd.h"
   #include "fontutils.h"
-  MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
-  #if ENABLED(HOST_ACTION_COMMANDS)
-    #include "../feature/host_actions.h"
-  #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
@@ -1362,20 +1364,24 @@ void MarlinUI::update() {
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
     if (alert_level) return;
 
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_action_notify(message);
+    #endif
+
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!
 
     // Get a pointer to the null terminator
     const char* pend = message + strlen(message);
 
     //  If length of supplied UTF8 string is greater than
     // our buffer size, start cutting whole UTF8 chars
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
@@ -1401,20 +1407,24 @@ void MarlinUI::update() {
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
     finish_status(level > 0);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
     if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
 
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_action_notify(message);
+    #endif
+
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
 
     // Get a pointer to the null terminator
     PGM_P pend = message + strlen_P(message);
 
     // If length of supplied UTF8 string is greater than
     // the buffer size, start cutting whole UTF8 chars
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
       --pend;
@@ -1561,11 +1571,41 @@ void MarlinUI::update() {
             ?: card.permyriadDone()
           #else
             ?: card.percentDone()
           #endif
         #endif
       );
     }
 
   #endif
 
-#endif // HAS_DISPLAY
+#else // !HAS_DISPLAY
+
+  //
+  // Send the status line as a host notification
+  //
+
+  void MarlinUI::set_status(const char * const message, const bool) {
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_action_notify(message);
+    #else
+      UNUSED(message);
+    #endif
+  }
+
+  void MarlinUI::set_status_P(PGM_P message, const int8_t) {
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_action_notify(message);
+    #else
+      UNUSED(message);
+    #endif
+  }
+
+  void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_action_notify(message);
+    #else
+      UNUSED(message);
+    #endif
+  }
+
+#endif // !HAS_DISPLAY

commit 27cb4db80eae73eb842f1a944260517bb8783eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 14 20:30:30 2019 -0600

    Reduced string storage using tokens (#15593)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 43e58e7ffa..3b69807b75 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -175,20 +175,21 @@ millis_t MarlinUI::next_button_update_ms; // = 0
         #else
           theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
         #endif
       }
       return outstr;
     }
 
   #endif
 
   screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
+  bool MarlinUI::screen_changed;
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
     bool MarlinUI::encoderRateMultiplierEnabled;
     millis_t MarlinUI::lastEncoderMovementMillis = 0;
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
     }
   #endif
 

commit 602ca5dea6b613af44629023bd438285abd0fe45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 13 02:07:09 2019 -0600

    No USE_M73_REMAINING_TIME without LCD_SET_PROGRESS_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d21c3649e5..43e58e7ffa 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -52,21 +52,21 @@
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
-  #if ENABLED(USE_M73_REMAINING_TIME)
+  #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
 #endif
 
 #if ENABLED(PCA9632_BUZZER) || USE_BEEPER
   #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {

commit e110f5abce90d139a768242780780832b09aa297
Author: Roman Moravčík <roman.moravcik@gmail.com>
Date:   Wed Nov 13 02:36:54 2019 +0100

    M73 R : Set Remaining Time (#15549)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index faee6149e0..d21c3649e5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -52,20 +52,23 @@
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
+  #if ENABLED(USE_M73_REMAINING_TIME)
+    uint32_t MarlinUI::remaining_time;
+  #endif
 #endif
 
 #if ENABLED(PCA9632_BUZZER) || USE_BEEPER
   #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);

commit 4db68d704f560d8450bfb4d1ee3127b34623c319
Author: AnHardt <github@kitelab.de>
Date:   Fri Nov 8 02:04:19 2019 +0100

    Update Display Throttling (#15837)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b4b1483e30..faee6149e0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1026,38 +1026,40 @@ void MarlinUI::update() {
           }
           set_font(FONT_MENU);                  // Setup font for every page draw
           u8g.setColorIndex(1);                 // And reset the color
           run_current_screen();                 // Draw and process the current screen
           first_page = false;
 
           // The screen handler can clear drawing_screen for an action that changes the screen.
           // If still drawing and there's another page, update max-time and return now.
           // The nextPage will already be set up on the next call.
           if (drawing_screen && (drawing_screen = u8g.nextPage())) {
-            NOLESS(max_display_update_time, millis() - ms);
+            if (on_status_screen())
+              NOLESS(max_display_update_time, millis() - ms);
             return;
           }
         }
 
       #else
 
         run_current_screen();
 
       #endif
 
       #if HAS_LCD_MENU
         lcd_clicked = false;
       #endif
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
-      NOLESS(max_display_update_time, millis() - ms);
+      if (on_status_screen())
+        NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
       // Return to Status Screen after a timeout
       if (on_status_screen() || defer_return_to_status)
         RESET_STATUS_TIMEOUT();
       else if (ELAPSED(ms, return_to_status_ms))
         return_to_status();
     #endif
 

commit a84e3d1b8049653345d694c1171d6d3491ebf618
Author: LinFor <linfor@gmail.com>
Date:   Thu Nov 7 02:49:17 2019 +0300

    Use native ADC resolution where possible (#15719)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f999c89853..b4b1483e30 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -96,20 +96,24 @@
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
 #endif
 
+#if HAS_ADC_BUTTONS
+  #include "../module/thermistor/thermistors.h"
+#endif
+
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
   #endif
 #endif
 
@@ -1095,45 +1099,47 @@ void MarlinUI::update() {
     #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
   #endif
   #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
     #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
   #endif
   #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
     #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
   #endif
 
   // Calculate the ADC value for the voltage divider with specified pull-down resistor value
-  #define ADC_BUTTON_VALUE(r)  (int(4096.0 * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP)))
+  #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
 
+  static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
+                                adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
-    { 4000, 4096, 1 + BLEN_KEYPAD_F1     }, // F1
-    { 4000, 4096, 1 + BLEN_KEYPAD_F2     }, // F2
-    { 4000, 4096, 1 + BLEN_KEYPAD_F3     }, // F3
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - 100,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - 100,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + 100, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - 100,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + 100, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - 100,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - 100,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + 100, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F2     }, // F2
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F3     }, // F3
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + adc_button_tolerance, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + adc_button_tolerance, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
   };
 
   uint8_t get_ADC_keyValue() {
     if (thermalManager.ADCKey_count >= 16) {
-      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw << 2;
-      thermalManager.current_ADCKey_raw = 1024;
+      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
+      thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
       thermalManager.ADCKey_count = 0;
-      if (currentkpADCValue < 4000)
+      if (currentkpADCValue < adc_other_button)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 
 #endif // HAS_ADC_BUTTONS

commit 786617e3754d704c201e7231ea647dbb90a5450a
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Nov 6 19:52:28 2019 -0300

    Fix RAMPS + VIKI i2c (#15811)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b754e7e901..f999c89853 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -54,29 +54,27 @@
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
 #endif
 
-#if HAS_BUZZER
-  #include "../libs/buzzer.h"
+#if ENABLED(PCA9632_BUZZER) || USE_BEEPER
+  #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    #if ENABLED(LCD_USE_I2C_BUZZER)
-      lcd.buzz(duration, freq);
-    #elif ENABLED(PCA9632_BUZZER)
+    #if ENABLED(PCA9632_BUZZER)
       pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD

commit e6dfc991ae6907e03751e869dabfaa5176f834af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 6 16:28:36 2019 -0600

    Patch tabs, heater led tests

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9f7b19817f..b754e7e901 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1226,48 +1226,48 @@ void MarlinUI::update() {
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
-        buttons = newbutton
+        buttons = (newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
-        ;
+        );
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
 
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }
       #endif
 
       #if HAS_SHIFT_ENCODER
 
-        GET_SHIFT_BUTTON_STATES(
+        GET_SHIFT_BUTTON_STATES((
           #if ENABLED(REPRAPWORLD_KEYPAD)
             keypad_buttons
           #else
             buttons
           #endif
-        );
+        ));
 
       #endif
 
     } // next_button_update_ms
 
     #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2

commit ca6d00b862049773135a9ef8d04d042f0af7f9d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 1 23:51:25 2019 -0500

    Save some string flash

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 54d13c29c1..9f7b19817f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -457,21 +457,21 @@ bool MarlinUI::get_blink() {
             #endif
             if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
             if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
             if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
             if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
             if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
           }
 
         #endif // HAS_LCD_MENU
 
-        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(PSTR("G28"));
+        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
         return true;
       }
 
     #endif // !ADC_KEYPAD
 
     return false;
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
@@ -1523,21 +1523,21 @@ void MarlinUI::update() {
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       wait_for_heatup = wait_for_user = false;
     #endif
-    if (IS_SD_PAUSED()) queue.inject_P(PSTR("M24"));
+    if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
 
     MarlinUI::progress_t MarlinUI::_get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)

commit efeb6efe773ed137f3a1d225f98b0f0b929c320b
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Thu Oct 24 12:04:45 2019 -0500

    Set pullup on BTN_BACK pin (#15654)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e67a7812f9..54d13c29c1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -288,20 +288,24 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
+    #if BUTTON_EXISTS(BACK)
+      SET_INPUT_PULLUP(BTN_BACK);
+    #endif
+
     #if BUTTON_EXISTS(UP)
       SET_INPUT(BTN_UP);
     #endif
     #if BUTTON_EXISTS(DWN)
       SET_INPUT(BTN_DWN);
     #endif
     #if BUTTON_EXISTS(LFT)
       SET_INPUT(BTN_LFT);
     #endif
     #if BUTTON_EXISTS(RT)

commit f00b48f9a8da77d0d603b74c843359b82ee306e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 21 18:34:29 2019 -0500

    Expand encoder value range

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 229b79f1dd..e67a7812f9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -130,21 +130,21 @@ uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 #endif
 
 millis_t MarlinUI::next_button_update_ms; // = 0
 
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
-  uint16_t MarlinUI::encoderPosition;
+  uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
 #if HAS_LCD_MENU
   #include "menu/menu.h"
   #include "../sd/cardreader.h"
 
   #if ENABLED(SDSUPPORT)
 
     #if ENABLED(SCROLL_LONG_FILENAMES)

commit ee20f21a2455a0902970bc2054c63bcdecb3ca8e
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Oct 14 00:30:37 2019 +0200

    Fix undefined max in multi-language (#15521)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 627e5ceff0..229b79f1dd 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -37,21 +37,21 @@
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
   #if ENABLED(HOST_ACTION_COMMANDS)
     #include "../feature/host_actions.h"
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
-    constexpr uint8_t MAX_MESSAGE_LENGTH = max(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
+    constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
     constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];

commit b20d5a7cc627164877c95859baaa614f8afc7b99
Author: LinFor <linfor@gmail.com>
Date:   Fri Oct 11 05:03:33 2019 +0300

    Estimate Remaining Time (graphical display) (#15497)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e9df8add24..627e5ceff0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -51,21 +51,21 @@
 #elif ENABLED(EXTENSIBLE_UI)
   constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  uint8_t MarlinUI::progress_override; // = 0
+  MarlinUI::progress_t MarlinUI::progress_override; // = 0
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
@@ -508,21 +508,21 @@ void MarlinUI::status_screen() {
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 
       // Handle message expire
       if (expire_status_ms > 0) {
 
         // Expire the message if a job is active and the bar has ticks
-        if (get_progress() > 2 && !print_job_timer.isPaused()) {
+        if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
           if (ELAPSED(ms, expire_status_ms)) {
             status_message[0] = '\0';
             expire_status_ms = 0;
           }
         }
         else {
           // Defer message expiration before bar appears
           // and during any pause (not just SD)
           expire_status_ms += LCD_UPDATE_INTERVAL;
         }
@@ -1527,25 +1527,31 @@ void MarlinUI::update() {
       wait_for_heatup = wait_for_user = false;
     #endif
     if (IS_SD_PAUSED()) queue.inject_P(PSTR("M24"));
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
-    uint8_t MarlinUI::get_progress() {
+
+    MarlinUI::progress_t MarlinUI::_get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-        const uint8_t p = progress_override & 0x7F;
+        const progress_t p = progress_override & PROGRESS_MASK;
       #else
-        constexpr uint8_t p = 0;
+        constexpr progress_t p = 0;
       #endif
       return (p
         #if ENABLED(SDSUPPORT)
-          ?: card.percentDone()
+          #if HAS_PRINT_PROGRESS_PERMYRIAD
+            ?: card.permyriadDone()
+          #else
+            ?: card.percentDone()
+          #endif
         #endif
       );
     }
+
   #endif
 
 #endif // HAS_DISPLAY

commit 3664beec29491ed5f49824f874977527f6db942c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 10 19:28:12 2019 -0500

    Don't refresh on status line changes

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fd762450b9..e9df8add24 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1341,22 +1341,20 @@ void MarlinUI::update() {
       next_filament_display = millis() + 5000UL; // Show status message for 5s
     #endif
 
     #if HAS_SPI_LCD && ENABLED(STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif
-
-    refresh();
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
     if (alert_level) return;
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cb5d8ad8fd..fd762450b9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -37,33 +37,29 @@
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
   #if ENABLED(HOST_ACTION_COMMANDS)
     #include "../feature/host_actions.h"
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
-    #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
-      #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
-    #else
-      #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
-    #endif
+    constexpr uint8_t MAX_MESSAGE_LENGTH = max(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
   #else
-    #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
+    constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
-  #define MAX_MESSAGE_LENGTH 63
+  constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
 #endif
 
-#ifdef MAX_MESSAGE_LENGTH
+#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t MarlinUI::progress_override; // = 0
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
@@ -583,23 +579,26 @@ void MarlinUI::status_screen() {
           next_beep = ms + 500UL;
         }
       #endif
     }
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
-void MarlinUI::kill_screen(PGM_P lcd_msg) {
+void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
   init();
-  set_alert_status_P(lcd_msg);
+  status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
+  #if HAS_LCD_MENU
+    return_to_status();
+  #endif
 
   // RED ALERT. RED ALERT.
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.set_color(LEDColorRed());
     #ifdef NEOPIXEL_BKGD_LED_INDEX
       neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
       neo.show();
     #endif
   #endif
 
@@ -836,27 +835,27 @@ void MarlinUI::update() {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.mount();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
-          set_status_P(PSTR(MSG_MEDIA_INSERTED));
+          set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
-            set_status_P(PSTR(MSG_MEDIA_REMOVED));
+            set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
             #if HAS_LCD_MENU
               return_to_status();
             #endif
           }
         }
 
         #if DISABLED(NO_LCD_REINIT)
           init_lcd(); // May revive the LCD if static electricity killed it
         #endif
 
@@ -1421,28 +1420,28 @@ void MarlinUI::update() {
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #include "../Marlin.h"
   #include "../module/printcounter.h"
 
-  static const char print_paused[] PROGMEM = MSG_PRINT_PAUSED;
+  PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
-    static const char printing[] PROGMEM = MSG_PRINTING;
-    static const char welcome[] PROGMEM = WELCOME_MSG;
+    PGM_P printing = GET_TEXT(MSG_PRINTING);
+    PGM_P welcome  = GET_TEXT(WELCOME_MSG);
     #if SERVICE_INTERVAL_1 > 0
       static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };
     #endif
     #if SERVICE_INTERVAL_2 > 0
       static const char service2[] PROGMEM = { "> " SERVICE_NAME_2 "!" };
     #endif
     #if SERVICE_INTERVAL_3 > 0
       static const char service3[] PROGMEM = { "> " SERVICE_NAME_3 "!" };
     #endif
     PGM_P msg;
@@ -1480,44 +1479,44 @@ void MarlinUI::update() {
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), PSTR("Dismiss"));
     #endif
     print_job_timer.stop();
-    set_status_P(PSTR(MSG_PRINT_ABORTED));
+    set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
-      synchronize(PSTR(MSG_PAUSE_PRINT));
+      synchronize(GET_TEXT(MSG_PAUSE_PRINT));
     #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       if (recovery.enabled) recovery.save(true, false);
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
-    set_status_P(print_paused); // MSG_PRINT_PAUSED
+    set_status_P(print_paused);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
         lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();

commit dc14d4a13c1eb80a76237ebcab6d8a512d960391
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:44:49 2019 -0600

    Improvements and fixes to Lulzbot UI (#15490)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9ad92add0d..cb5d8ad8fd 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -21,20 +21,21 @@
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
 // All displays share the MarlinUI class
 #if HAS_DISPLAY
+  #include "../gcode/queue.h"
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
   #if ENABLED(HOST_ACTION_COMMANDS)
     #include "../feature/host_actions.h"
   #endif
@@ -86,21 +87,20 @@
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/printcounter.h"
 #include "../module/motion.h"
-#include "../gcode/queue.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif

commit 58f81f8e7ed43091d8589d6e1e972d750c6de987
Author: LinFor <linfor@gmail.com>
Date:   Tue Oct 8 23:24:14 2019 +0300

    Followup to progress override (#15488)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9b6b475115..9ad92add0d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -54,21 +54,21 @@
 #elif ENABLED(EXTENSIBLE_UI)
   #define MAX_MESSAGE_LENGTH 63
 #endif
 
 #ifdef MAX_MESSAGE_LENGTH
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  uint8_t MarlinUI::progress_bar_percent; // = 0
+  uint8_t MarlinUI::progress_override; // = 0
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
@@ -1532,24 +1532,23 @@ void MarlinUI::update() {
     if (IS_SD_PAUSED()) queue.inject_P(PSTR("M24"));
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-        uint8_t &progress = progress_bar_percent;
-        #define _PLIMIT(P) ((P) & 0x7F)
+        const uint8_t p = progress_override & 0x7F;
       #else
-        #define _PLIMIT(P) P
-        uint8_t progress = 0;
+        constexpr uint8_t p = 0;
       #endif
-      #if ENABLED(SDSUPPORT)
-        if (!_PLIMIT(progress)) progress = card.percentDone();
-      #endif
-      return _PLIMIT(progress);
+      return (p
+        #if ENABLED(SDSUPPORT)
+          ?: card.percentDone()
+        #endif
+      );
     }
   #endif
 
 #endif // HAS_DISPLAY

commit 19b7be067c02f138a48d208fa2cc5d16f63b9dba
Author: LinFor <linfor@gmail.com>
Date:   Tue Oct 8 00:38:58 2019 +0300

    Allow M73 to override SD position (#15449)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 10864da1c2..9b6b475115 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1539,17 +1539,17 @@ void MarlinUI::update() {
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
         uint8_t &progress = progress_bar_percent;
         #define _PLIMIT(P) ((P) & 0x7F)
       #else
         #define _PLIMIT(P) P
         uint8_t progress = 0;
       #endif
       #if ENABLED(SDSUPPORT)
-        if (IS_SD_PRINTING()) progress = card.percentDone();
+        if (!_PLIMIT(progress)) progress = card.percentDone();
       #endif
       return _PLIMIT(progress);
     }
   #endif
 
 #endif // HAS_DISPLAY

commit c83c2a50228be867b1188b80969c5e828b15c740
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 3 15:37:04 2019 -0500

    Patch compile glitches

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d8278e4b48..10864da1c2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1418,20 +1418,21 @@ void MarlinUI::update() {
     finish_status(level > 0);
   }
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
+  #include "../Marlin.h"
   #include "../module/printcounter.h"
 
   static const char print_paused[] PROGMEM = MSG_PRINT_PAUSED;
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
     static const char printing[] PROGMEM = MSG_PRINTING;
     static const char welcome[] PROGMEM = WELCOME_MSG;

commit 72d791a73682fa676959189c89dbf34e85bbfe61
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 2 18:54:20 2019 -0500

    Standardize active/paused functions

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 63d1629f8e..d8278e4b48 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1420,39 +1420,40 @@ void MarlinUI::update() {
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #include "../module/printcounter.h"
 
+  static const char print_paused[] PROGMEM = MSG_PRINT_PAUSED;
+
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
-    static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
     static const char printing[] PROGMEM = MSG_PRINTING;
     static const char welcome[] PROGMEM = WELCOME_MSG;
     #if SERVICE_INTERVAL_1 > 0
       static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };
     #endif
     #if SERVICE_INTERVAL_2 > 0
       static const char service2[] PROGMEM = { "> " SERVICE_NAME_2 "!" };
     #endif
     #if SERVICE_INTERVAL_3 > 0
       static const char service3[] PROGMEM = { "> " SERVICE_NAME_3 "!" };
     #endif
     PGM_P msg;
-    if (!IS_SD_PRINTING() && print_job_timer.isPaused())
-      msg = paused;
+    if (printingIsPaused())
+      msg = print_paused;
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
       msg = printing;
 
     #if SERVICE_INTERVAL_1 > 0
       else if (print_job_timer.needsService(1)) msg = service1;
     #endif
@@ -1501,42 +1502,40 @@ void MarlinUI::update() {
     #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       if (recovery.enabled) recovery.save(true, false);
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
-    set_status_P(PSTR(MSG_PRINT_PAUSED));
+    set_status_P(print_paused); // MSG_PRINT_PAUSED
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
         lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       wait_for_heatup = wait_for_user = false;
     #endif
-    #if ENABLED(SDSUPPORT)
-      if (card.isPaused()) queue.inject_P(PSTR("M24"));
-    #endif
+    if (IS_SD_PAUSED()) queue.inject_P(PSTR("M24"));
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
         uint8_t &progress = progress_bar_percent;

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 389a58f2dc..63d1629f8e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -664,21 +664,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
       const feedRate_t fr_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
       #if IS_KINEMATIC
 
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
           if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
-        set_destination_from_current();
+        destination = current_position;
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
         manual_move_offset = 0;
         manual_move_axis = (int8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
         // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
         // processing_manual_move is true or the planner will get out of sync.

commit 5221e2d991ccae7ff4283a60afb240165c8f0199
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Sep 27 18:06:26 2019 -0400

    Restore Host Prompt Info (#15387)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 390e0f17fa..389a58f2dc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1474,20 +1474,23 @@ void MarlinUI::update() {
   #endif
 
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), PSTR("Dismiss"));
+    #endif
     print_job_timer.stop();
     set_status_P(PSTR(MSG_PRINT_ABORTED));
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 79f6baf479..390e0f17fa 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -655,54 +655,51 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send a move immediately.
    */
   void MarlinUI::manage_manual_move() {
 
     if (processing_manual_move) return;
 
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
 
+      const feedRate_t fr_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
       #if IS_KINEMATIC
 
-        const float old_feedrate = feedrate_mm_s;
-        feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
-
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
           if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
         set_destination_from_current();
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
         manual_move_offset = 0;
         manual_move_axis = (int8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
         // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
         // processing_manual_move is true or the planner will get out of sync.
         processing_manual_move = true;
-        prepare_move_to_destination(); // will set current_position from destination
+        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
         processing_manual_move = false;
 
-        feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
-        planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
+        planner.buffer_line(current_position, fr_mm_s, manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
         manual_move_axis = (int8_t)NO_AXIS;
 
       #endif
     }
   }
 
 #endif // HAS_LCD_MENU
 
 /**
  * Update the LCD, read encoder buttons, etc.

commit f01f0d1956bb5cf0a9efb538b334ed6165a3e20f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 20:31:08 2019 -0500

    Drop C-style 'void' argument

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1f42696bd3..79f6baf479 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1116,21 +1116,21 @@ void MarlinUI::update() {
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + 100, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + 100, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + 100, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
   };
 
-  uint8_t get_ADC_keyValue(void) {
+  uint8_t get_ADC_keyValue() {
     if (thermalManager.ADCKey_count >= 16) {
       const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw << 2;
       thermalManager.current_ADCKey_raw = 1024;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < 4000)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }

commit d5f520388077e697209b02f64e5ade61599df970
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 15 03:10:59 2019 -0500

    Use "mount" as card verb

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0e397f3685..1f42696bd3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -835,21 +835,21 @@ void MarlinUI::update() {
     // SPI SD Card detection (and first card init when the LCD is present)
     //
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
-        card.initsd();
+        card.mount();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
           set_status_P(PSTR(MSG_MEDIA_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
             set_status_P(PSTR(MSG_MEDIA_REMOVED));

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d8db1a823e..0e397f3685 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -678,21 +678,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         // Reset for the next move
         manual_move_offset = 0;
         manual_move_axis = (int8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
         // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
         // processing_manual_move is true or the planner will get out of sync.
         processing_manual_move = true;
-        prepare_move_to_destination(); // will call set_current_from_destination()
+        prepare_move_to_destination(); // will set current_position from destination
         processing_manual_move = false;
 
         feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
         planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);

commit 3f129b657466d31757ed41369015a772ca9f09f7
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Fri Sep 13 10:14:24 2019 +0700

    Touch Buttons variable repeat delay (#15236)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 797abe006c..d8db1a823e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -188,20 +188,24 @@ millis_t MarlinUI::next_button_update_ms; // = 0
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
     }
   #endif
 
   #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
     int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
+  #if ENABLED(TOUCH_BUTTONS)
+    uint8_t MarlinUI::repeat_delay;
+  #endif
+
   bool MarlinUI::lcd_clicked;
   float move_menu_scale;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
   #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
@@ -785,21 +789,21 @@ void MarlinUI::update() {
               #if HAS_LCD_MENU
                 refresh();
               #endif
             }
             touch_buttons = 0;                          // Swallow the touch
           }
           buttons |= (touch_buttons & (EN_C | EN_D));   // Pass on Click and Back buttons
           if (touch_buttons & (EN_A | EN_B)) {          // A and/or B button?
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
             if (touch_buttons & EN_A) encoderDiff *= -1;
-            next_button_update_ms = ms + 50;            // Assume the repeat delay
+            next_button_update_ms = ms + repeat_delay;  // Assume the repeat delay
             if (!wait_for_unclick && !arrow_pressed) {  // On click prepare for repeat
               next_button_update_ms += 250;             // Longer delay on first press
               arrow_pressed = true;                     // Mark arrow as pressed
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
             }
           }
         }
         if (!(touch_buttons & (EN_A | EN_B))) arrow_pressed = false;

commit 841c8ce0d9bdc67af010692014800431a278dd46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 9 15:43:06 2019 -0500

    Remove PROMPT_INFO / PROMPT_GCODE_INFO (#15210)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ba2de995e4..797abe006c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1473,23 +1473,20 @@ void MarlinUI::update() {
   #endif
 
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_open(PROMPT_INFO, PSTR("UI Abort"));
-    #endif
     print_job_timer.stop();
     set_status_P(PSTR(MSG_PRINT_ABORTED));
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif

commit 6b05d5d65d0b4f557021c0ed5c47ec4e5e97b43c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Sep 5 01:13:05 2019 +0700

    Allow TOUCH_BUTTONS to be swapped (#15100)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5228292b70..ba2de995e4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -109,40 +109,38 @@
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
     #include "../feature/touch/xpt2046.h"
-    volatile uint8_t MarlinUI::touch_buttons;
-    uint8_t MarlinUI::read_touch_buttons() { return touch.read_buttons(); }
   #endif
 #endif
 
 #if ENABLED(INIT_SDCARD_ON_BOOT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
-millis_t next_button_update_ms;
+millis_t MarlinUI::next_button_update_ms; // = 0
 
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint16_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
@@ -338,23 +336,20 @@ void MarlinUI::init() {
     #endif
     #if ENABLED(INIT_SDCARD_ON_BOOT)
       lcd_sd_status = 2; // UNKNOWN
     #endif
   #endif
 
   #if HAS_ENCODER_ACTION
     #if HAS_SLOW_BUTTONS
       slow_buttons = 0;
     #endif
-    #if ENABLED(TOUCH_BUTTONS)
-      touch_buttons = 0;
-    #endif
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
 bool MarlinUI::get_blink() {
@@ -739,86 +734,102 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
   millis_t ms = millis();
 
+  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+    static millis_t return_to_status_ms = 0;
+    #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
+  #else
+    #define RESET_STATUS_TIMEOUT() NOOP
+  #endif
+
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
 
   #if HAS_LCD_MENU
 
-    #if LCD_TIMEOUT_TO_STATUS
-      static millis_t return_to_status_ms = 0;
-    #endif
-
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
-    static bool wait_for_unclick; // = 0
-    auto generate_click = [&]() {
-      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-        wait_for_user = false;                        //  - Any click clears wait for user
-        quick_feedback();                             //  - Always make a click sound
-      }
-    };
+    static bool wait_for_unclick; // = false
 
     #if ENABLED(TOUCH_BUTTONS)
-      if (touch_buttons) {
-        if (buttons & EN_C)
-          generate_click();
-        else if (buttons & (EN_A | EN_B)) {             // Ignore the encoder if clicked, to prevent "slippage"
-          const millis_t ms = millis();
-          if (ELAPSED(ms, next_button_update_ms)) {
-            next_button_update_ms = ms + 50;
-            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP);
-            if (buttons & EN_A) encoderDiff *= -1;
-            if (!wait_for_unclick) {
-              next_button_update_ms += 250;
+
+      #define TOUCH_MENU_MASK 0x80
+
+      static bool arrow_pressed; // = false
+
+      // Handle touch events which are slow to read
+      if (ELAPSED(ms, next_button_update_ms)) {
+        uint8_t touch_buttons = touch.read_buttons();
+        if (touch_buttons) {
+          RESET_STATUS_TIMEOUT();
+          if (touch_buttons & TOUCH_MENU_MASK) {        // Processing Menu Area touch?
+            if (!wait_for_unclick) {                    // If not waiting for a debounce release:
+              wait_for_unclick = true;                  //  - Set debounce flag to ignore continous clicks
+              wait_for_user = false;                    //  - Any click clears wait for user
+              // TODO for next PR.
+              //uint8_t tpos = touch_buttons & ~(TOUCH_MENU_MASK);  // Safe 7bit touched screen coordinate
+              next_button_update_ms = ms + 500;         // Defer next check for 1/2 second
+              #if HAS_LCD_MENU
+                refresh();
+              #endif
+            }
+            touch_buttons = 0;                          // Swallow the touch
+          }
+          buttons |= (touch_buttons & (EN_C | EN_D));   // Pass on Click and Back buttons
+          if (touch_buttons & (EN_A | EN_B)) {          // A and/or B button?
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP) * encoderDirection;
+            if (touch_buttons & EN_A) encoderDiff *= -1;
+            next_button_update_ms = ms + 50;            // Assume the repeat delay
+            if (!wait_for_unclick && !arrow_pressed) {  // On click prepare for repeat
+              next_button_update_ms += 250;             // Longer delay on first press
+              arrow_pressed = true;                     // Mark arrow as pressed
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
-              wait_for_unclick = true;                  //  - Set debounce flag to ignore continous clicks
             }
           }
         }
+        if (!(touch_buttons & (EN_A | EN_B))) arrow_pressed = false;
       }
-      else
+
     #endif // TOUCH_BUTTONS
-      {
-        //
-        // Integrated LCD click handling via button_pressed()
-        //
-        if (!external_control && button_pressed())
-          generate_click();
-        else
-          wait_for_unclick = false;
-      }
 
-    #if HAS_DIGITAL_BUTTONS && (BUTTON_EXISTS(BACK) || ENABLED(TOUCH_BUTTONS))
-      if (LCD_BACK_CLICKED()) {
-        quick_feedback();
-        goto_previous_screen();
+    // Integrated LCD click handling via button_pressed
+    if (!external_control && button_pressed()) {
+      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+        wait_for_user = false;                        //  - Any click clears wait for user
+        quick_feedback();                             //  - Always make a click sound
       }
-    #endif
+    }
+    else
+      wait_for_unclick = false;
+
+    if (LCD_BACK_CLICKED()) {
+      quick_feedback();
+      goto_previous_screen();
+    }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(INIT_SDCARD_ON_BOOT)
     //
     // SPI SD Card detection (and first card init when the LCD is present)
     //
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
@@ -878,37 +889,22 @@ void MarlinUI::update() {
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if HAS_SLOW_BUTTONS
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
-      #if ENABLED(TOUCH_BUTTONS)
-        touch_buttons = read_touch_buttons();
-        if (touch_buttons) {
-          #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
-            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-          #endif
-        }
-      #endif
-
       #if ENABLED(REPRAPWORLD_KEYPAD)
-
-        if (handle_keypad()) {
-          #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
-            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-          #endif
-        }
-
+        if (handle_keypad()) RESET_STATUS_TIMEOUT();
       #endif
 
       const float abs_diff = ABS(encoderDiff);
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
@@ -940,23 +936,21 @@ void MarlinUI::update() {
           #else
 
             constexpr int32_t encoderMultiplier = 1;
 
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / (ENCODER_PULSES_PER_STEP);
           encoderDiff = 0;
         }
 
-        #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
-          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-        #endif
+        RESET_STATUS_TIMEOUT();
 
         refresh(LCDVIEW_REDRAW_NOW);
 
         #ifdef LED_BACKLIGHT_TIMEOUT
           leds.reset_timeout(ms);
         #endif
       }
 
     #endif
 
@@ -975,23 +969,21 @@ void MarlinUI::update() {
     #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
           filename_scroll_pos = 0;
           lcd_status_update_delay = 12;
         }
         refresh(LCDVIEW_REDRAW_NOW);
-        #if LCD_TIMEOUT_TO_STATUS
-          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-        #endif
+        RESET_STATUS_TIMEOUT();
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
 
       // Change state of drawing flag between screen updates
       if (!drawing_screen) switch (lcdDrawUpdate) {
@@ -1051,21 +1043,21 @@ void MarlinUI::update() {
       #endif
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
       // Return to Status Screen after a timeout
       if (on_status_screen() || defer_return_to_status)
-        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        RESET_STATUS_TIMEOUT();
       else if (ELAPSED(ms, return_to_status_ms))
         return_to_status();
     #endif
 
     // Change state of drawing flag between screen updates
     if (!drawing_screen) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
         clear_lcd(); break;
       case LCDVIEW_REDRAW_NOW:
         refresh(LCDVIEW_NONE);
@@ -1234,26 +1226,26 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
-          #if ENABLED(TOUCH_BUTTONS)
-            | touch_buttons
-          #endif
         ;
+
       #elif HAS_ADC_BUTTONS
+
         buttons = 0;
+
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }
       #endif
 
       #if HAS_SHIFT_ENCODER

commit 1eeef30097f2b20e4a8212110f88adbd481413b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 30 19:14:43 2019 -0500

    A single generate_click lambda

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b8d87d39ea..5228292b70 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -758,58 +758,60 @@ void MarlinUI::update() {
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = 0
+    auto generate_click = [&]() {
+      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+        wait_for_user = false;                        //  - Any click clears wait for user
+        quick_feedback();                             //  - Always make a click sound
+      }
+    };
+
     #if ENABLED(TOUCH_BUTTONS)
       if (touch_buttons) {
-        if (!wait_for_unclick && (buttons & EN_C)) {    // If not waiting for a debounce release:
-          wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-          lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-          wait_for_user = false;                        //  - Any click clears wait for user
-          quick_feedback();                             //  - Always make a click sound
-        }
+        if (buttons & EN_C)
+          generate_click();
         else if (buttons & (EN_A | EN_B)) {             // Ignore the encoder if clicked, to prevent "slippage"
           const millis_t ms = millis();
           if (ELAPSED(ms, next_button_update_ms)) {
             next_button_update_ms = ms + 50;
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP);
             if (buttons & EN_A) encoderDiff *= -1;
             if (!wait_for_unclick) {
               next_button_update_ms += 250;
               #if HAS_BUZZER
                 buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
               #endif
               wait_for_unclick = true;                  //  - Set debounce flag to ignore continous clicks
             }
           }
         }
       }
       else
-    #endif //TOUCH_BUTTONS
-    //
-    // Integrated LCD click handling via button_pressed()
-    //
-    if (!external_control && button_pressed()) {
-      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-        wait_for_user = false;                        //  - Any click clears wait for user
-        quick_feedback();                             //  - Always make a click sound
+    #endif // TOUCH_BUTTONS
+      {
+        //
+        // Integrated LCD click handling via button_pressed()
+        //
+        if (!external_control && button_pressed())
+          generate_click();
+        else
+          wait_for_unclick = false;
       }
-    }
-    else wait_for_unclick = false;
 
     #if HAS_DIGITAL_BUTTONS && (BUTTON_EXISTS(BACK) || ENABLED(TOUCH_BUTTONS))
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 

commit 38983fdfa9773faf7006ef392110aca01ad006d5
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Aug 29 13:19:07 2019 +0700

    Add 'Back' Button for Touch TFT 320x240 (#15060)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a6078e0f5b..b8d87d39ea 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -797,21 +797,21 @@ void MarlinUI::update() {
     if (!external_control && button_pressed()) {
       if (!wait_for_unclick) {                        // If not waiting for a debounce release:
         wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
         wait_for_user = false;                        //  - Any click clears wait for user
         quick_feedback();                             //  - Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
-    #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
+    #if HAS_DIGITAL_BUTTONS && (BUTTON_EXISTS(BACK) || ENABLED(TOUCH_BUTTONS))
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(INIT_SDCARD_ON_BOOT)
     //
@@ -878,20 +878,25 @@ void MarlinUI::update() {
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if HAS_SLOW_BUTTONS
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
       #if ENABLED(TOUCH_BUTTONS)
         touch_buttons = read_touch_buttons();
+        if (touch_buttons) {
+          #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+          #endif
+        }
       #endif
 
       #if ENABLED(REPRAPWORLD_KEYPAD)
 
         if (handle_keypad()) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
 

commit ca084dcfe8d33487c0a5389a740b56987d4f7876
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Aug 28 14:49:21 2019 +0700

    Switch col vs row variable name (#15072)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b25907a622..a6078e0f5b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -259,31 +259,31 @@ millis_t next_button_update_ms;
         if (!ch) break;
         lcd_put_wchar(ch);
         col++;
         if (col >= LCD_WIDTH) _newline();
       }
     }
   }
 
   void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
-    uint8_t row = 0, col = 0;
+    uint8_t col = 0, row = 0;
     if (!string && plen + slen <= LCD_WIDTH) {
-      row = (LCD_WIDTH - plen - slen) / 2;
-      col = LCD_HEIGHT > 3 ? 1 : 0;
+      col = (LCD_WIDTH - plen - slen) / 2;
+      row = LCD_HEIGHT > 3 ? 1 : 0;
     }
-    wrap_string_P(row, col, pref, true);
+    wrap_string_P(col, row, pref, true);
     if (string) {
-      if (row) { row = 0; col++; } // Move to the start of the next line
-      wrap_string(row, col, string);
+      if (col) { col = 0; row++; } // Move to the start of the next line
+      wrap_string(col, row, string);
     }
-    if (suff) wrap_string_P(row, col, suff);
+    if (suff) wrap_string_P(col, row, suff);
   }
 
 #endif // HAS_LCD_MENU
 
 void MarlinUI::init() {
 
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
 

commit efeea9bccf7c2e5414e35e5dd213d164fc0ef32e
Author: Tim Moore <tim@youngmoores.com>
Date:   Fri Aug 23 20:30:11 2019 -0700

    pca9632_buzz fix (#15020)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f201c1b2a0..b25907a622 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -59,25 +59,28 @@
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t MarlinUI::progress_bar_percent; // = 0
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
+  #if ENABLED(PCA9632_BUZZER)
+    #include "../feature/leds/pca9632.h"
+  #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif ENABLED(PCA9632_BUZZER)
-      pca9632_buzz(const long duration, const uint16_t freq) {
+      pca9632_buzz(duration, freq);
     #elif USE_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"

commit 05995d1fd6c3b85717d428ff5c0c269f7872857b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Aug 20 09:01:37 2019 +0200

    Unify buzz methods as MarlinUI::buzz (#14803)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8fc66dddf9..f201c1b2a0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -57,20 +57,33 @@
 
 #ifdef MAX_MESSAGE_LENGTH
   uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t MarlinUI::progress_bar_percent; // = 0
 #endif
 
+#if HAS_BUZZER
+  #include "../libs/buzzer.h"
+  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    #if ENABLED(LCD_USE_I2C_BUZZER)
+      lcd.buzz(duration, freq);
+    #elif ENABLED(PCA9632_BUZZER)
+      pca9632_buzz(const long duration, const uint16_t freq) {
+    #elif USE_BEEPER
+      buzzer.tone(duration, freq);
+    #endif
+  }
+#endif
+
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
@@ -82,24 +95,20 @@
 #include "../Marlin.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if HAS_BUZZER
-  #include "../libs/buzzer.h"
-#endif
-
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
   #if ENABLED(TOUCH_BUTTONS)
@@ -561,21 +570,21 @@ void MarlinUI::status_screen() {
 
     if (old_frm != new_frm) {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
       #if HAS_BUZZER && ENABLED(BEEP_ON_FEEDRATE_CHANGE)
         static millis_t next_beep;
         #ifndef GOT_MS
           const millis_t ms = millis();
         #endif
         if (ELAPSED(ms, next_beep)) {
-          BUZZ(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
+          buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
           next_beep = ms + 500UL;
         }
       #endif
     }
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
@@ -604,27 +613,26 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   #if HAS_ENCODER_ACTION
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
   #if HAS_BUZZER
     // Buzz and wait. Is the delay needed for buttons to settle?
     buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-  #endif
-
-  #if HAS_LCD_MENU
-    #if ENABLED(LCD_USE_I2C_BUZZER)
-      delay(10);
-    #elif PIN_EXISTS(BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #if HAS_LCD_MENU
+      #if USE_BEEPER
+        for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+      #else
+        delay(10);
+      #endif
     #endif
   #endif
 }
 
 ////////////////////////////////////////////
 /////////////// Manual Move ////////////////
 ////////////////////////////////////////////
 
 #if HAS_LCD_MENU
 
@@ -722,30 +730,20 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  *
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * This function is only called from the main thread.
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
-bool MarlinUI::detected() {
-  return
-    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
-      lcd.LcdDetected() == 1
-    #else
-      true
-    #endif
-  ;
-}
-
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
   millis_t ms = millis();
 
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
 
@@ -1288,37 +1286,20 @@ void MarlinUI::update() {
             ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
           #endif
           encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
         }
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
-  #if HAS_SLOW_BUTTONS
-
-    uint8_t MarlinUI::read_slow_buttons() {
-      #if ENABLED(LCD_I2C_TYPE_MCP23017)
-        // Reading these buttons this is likely to be too slow to call inside interrupt context
-        // so they are called during normal lcd_update
-        uint8_t slow_bits = lcd.readButtons() << B_I2C_BTN_OFFSET;
-        #if ENABLED(LCD_I2C_VIKI)
-          if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
-            slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
-        #endif // LCD_I2C_VIKI
-        return slow_bits;
-      #endif // LCD_I2C_TYPE_MCP23017
-    }
-
-  #endif
-
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 
 #if HAS_DISPLAY
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extensible_ui/ui_api.h"
   #endif
 

commit 823178c272b06f2cdcdb087e8f6c7b2ef0e3e6ed
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sun Aug 18 07:58:38 2019 +0700

    Use u8g int type for screen coordinates (#14965)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ce9d9d7032..8fc66dddf9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -198,80 +198,80 @@ millis_t next_button_update_ms;
 
     bool MarlinUI::external_control; // = false
 
     void MarlinUI::wait_for_release() {
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
-  void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
-    SETCURSOR(x, y);
+  void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
+    SETCURSOR(col, row);
     if (!string) return;
 
-    auto _newline = [&x, &y]() {
-      x = 0; y++;               // move x to string len (plus space)
-      SETCURSOR(0, y);          // simulate carriage return
+    auto _newline = [&col, &row]() {
+      col = 0; row++;                 // Move col to string len (plus space)
+      SETCURSOR(0, row);              // Simulate carriage return
     };
 
     uint8_t *p = (uint8_t*)string;
     wchar_t ch;
     if (wordwrap) {
       uint8_t *wrd = nullptr, c = 0;
       // find the end of the part
       for (;;) {
         if (!wrd) wrd = p;            // Get word start /before/ advancing
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         const bool eol = !ch;         // zero ends the string
         // End or a break between phrases?
         if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
           if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
           // Past the right and the word is not too long?
-          if (x + c > LCD_WIDTH && x >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
+          if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
           c += !eol;                  // +1 so the space will be printed
-          x += c;                     // advance x to new position
+          col += c;                   // advance col to new position
           while (c) {                 // character countdown
             --c;                      // count down to zero
             wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
             lcd_put_wchar(ch);        // character to the LCD
           }
           if (eol) break;             // all done!
           wrd = nullptr;              // set up for next word
         }
         else c++;                     // count word characters
       }
     }
     else {
       for (;;) {
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         if (!ch) break;
         lcd_put_wchar(ch);
-        x++;
-        if (x >= LCD_WIDTH) _newline();
+        col++;
+        if (col >= LCD_WIDTH) _newline();
       }
     }
   }
 
   void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
-    uint8_t x = 0, y = 0;
+    uint8_t row = 0, col = 0;
     if (!string && plen + slen <= LCD_WIDTH) {
-      x = (LCD_WIDTH - plen - slen) / 2;
-      y = LCD_HEIGHT > 3 ? 1 : 0;
+      row = (LCD_WIDTH - plen - slen) / 2;
+      col = LCD_HEIGHT > 3 ? 1 : 0;
     }
-    wrap_string_P(x, y, pref, true);
+    wrap_string_P(row, col, pref, true);
     if (string) {
-      if (x) { x = 0; y++; } // Move to the start of the next line
-      wrap_string(x, y, string);
+      if (row) { row = 0; col++; } // Move to the start of the next line
+      wrap_string(row, col, string);
     }
-    if (suff) wrap_string_P(x, y, suff);
+    if (suff) wrap_string_P(row, col, suff);
   }
 
 #endif // HAS_LCD_MENU
 
 void MarlinUI::init() {
 
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
 

commit 263d7d37af4341b579f7fd630173e2ecee3b4e3f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Aug 14 16:52:14 2019 -0600

    "SD card" => "Media" (#14951)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b1464befc1..ce9d9d7032 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -821,27 +821,27 @@ void MarlinUI::update() {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
-          set_status_P(PSTR(MSG_SD_INSERTED));
+          set_status_P(PSTR(MSG_MEDIA_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
-            set_status_P(PSTR(MSG_SD_REMOVED));
+            set_status_P(PSTR(MSG_MEDIA_REMOVED));
             #if HAS_LCD_MENU
               return_to_status();
             #endif
           }
         }
 
         #if DISABLED(NO_LCD_REINIT)
           init_lcd(); // May revive the LCD if static electricity killed it
         #endif
 
@@ -960,21 +960,21 @@ void MarlinUI::update() {
           + 3
         #endif
       ;
       max_display_update_time--;
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
-      if (currentScreen == menu_sdcard && !lcd_status_update_delay--) {
+      if (currentScreen == menu_media && !lcd_status_update_delay--) {
         lcd_status_update_delay = 4;
         if (++filename_scroll_pos > filename_scroll_max) {
           filename_scroll_pos = 0;
           lcd_status_update_delay = 12;
         }
         refresh(LCDVIEW_REDRAW_NOW);
         #if LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
       }

commit 0745d489938346cf97495ba61a53984f850bd350
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun Aug 11 01:22:11 2019 +0200

    Fix build with and without TOUCH_BUTTONS (#14912)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a54bb9b368..b1464befc1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -757,56 +757,55 @@ void MarlinUI::update() {
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = 0
-    if (touch_buttons) {
-      if (buttons & EN_C) {
-        if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+    #if ENABLED(TOUCH_BUTTONS)
+      if (touch_buttons) {
+        if (!wait_for_unclick && (buttons & EN_C)) {    // If not waiting for a debounce release:
           wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
           lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
           wait_for_user = false;                        //  - Any click clears wait for user
           quick_feedback();                             //  - Always make a click sound
         }
-      }
-      else if (buttons & (EN_A | EN_B)) {               // Ignore the encoder if clicked, to prevent "slippage"
-        const millis_t ms = millis();
-        if (ELAPSED(ms, next_button_update_ms)) {
-          next_button_update_ms = ms + 50;
-          encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP);
-          if (buttons & EN_A) encoderDiff *= -1;
-          if (!wait_for_unclick) {
-            next_button_update_ms += 250;
-            #if HAS_BUZZER
-              buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-            #endif
-            wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+        else if (buttons & (EN_A | EN_B)) {             // Ignore the encoder if clicked, to prevent "slippage"
+          const millis_t ms = millis();
+          if (ELAPSED(ms, next_button_update_ms)) {
+            next_button_update_ms = ms + 50;
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP);
+            if (buttons & EN_A) encoderDiff *= -1;
+            if (!wait_for_unclick) {
+              next_button_update_ms += 250;
+              #if HAS_BUZZER
+                buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+              #endif
+              wait_for_unclick = true;                  //  - Set debounce flag to ignore continous clicks
+            }
           }
         }
       }
-    }
-    else {
-      //
-      // Integrated LCD click handling via button_pressed()
-      //
-      if (!external_control && button_pressed()) {
-        if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-          wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-          lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-          wait_for_user = false;                        //  - Any click clears wait for user
-          quick_feedback();                             //  - Always make a click sound
-        }
+      else
+    #endif //TOUCH_BUTTONS
+    //
+    // Integrated LCD click handling via button_pressed()
+    //
+    if (!external_control && button_pressed()) {
+      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+        wait_for_user = false;                        //  - Any click clears wait for user
+        quick_feedback();                             //  - Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
     #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif

commit d2d71caa3bfef08fb422f09d5088709313c6757c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sat Aug 10 13:42:52 2019 +0700

    Clean up Touch pins. Better up/down touch response. (#14900)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cc196095d1..a54bb9b368 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -757,41 +757,73 @@ void MarlinUI::update() {
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
     // If the state changes the next update may be delayed 300-500ms.
     update_buttons();
 
     // If the action button is pressed...
     static bool wait_for_unclick; // = 0
-    if (!external_control && button_pressed()) {
-      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
-        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
-        wait_for_user = false;                        //  - Any click clears wait for user
-        quick_feedback();                             //  - Always make a click sound
+    if (touch_buttons) {
+      if (buttons & EN_C) {
+        if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+          wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+          lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+          wait_for_user = false;                        //  - Any click clears wait for user
+          quick_feedback();                             //  - Always make a click sound
+        }
+      }
+      else if (buttons & (EN_A | EN_B)) {               // Ignore the encoder if clicked, to prevent "slippage"
+        const millis_t ms = millis();
+        if (ELAPSED(ms, next_button_update_ms)) {
+          next_button_update_ms = ms + 50;
+          encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * (ENCODER_PULSES_PER_STEP);
+          if (buttons & EN_A) encoderDiff *= -1;
+          if (!wait_for_unclick) {
+            next_button_update_ms += 250;
+            #if HAS_BUZZER
+              buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+            #endif
+            wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+          }
+        }
+      }
+    }
+    else {
+      //
+      // Integrated LCD click handling via button_pressed()
+      //
+      if (!external_control && button_pressed()) {
+        if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+          wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+          lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+          wait_for_user = false;                        //  - Any click clears wait for user
+          quick_feedback();                             //  - Always make a click sound
+        }
       }
     }
     else wait_for_unclick = false;
 
     #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(INIT_SDCARD_ON_BOOT)
-
+    //
+    // SPI SD Card detection (and first card init when the LCD is present)
+    //
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)

commit 128eed6b57a8dd67d0fe02511e9437755e326c31
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Jul 31 05:42:57 2019 +0700

    Option to reverse select direction/buttons (#14693)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index efc424dc9a..cc196095d1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -174,22 +174,22 @@ millis_t next_button_update_ms;
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
     bool MarlinUI::encoderRateMultiplierEnabled;
     millis_t MarlinUI::lastEncoderMovementMillis = 0;
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;
     }
   #endif
 
-  #if ENABLED(REVERSE_MENU_DIRECTION)
-    int8_t MarlinUI::encoderDirection = 1;
+  #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
+    int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
   bool MarlinUI::lcd_clicked;
   float move_menu_scale;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }

commit c4bb458763c810f29025fc6b2c5829022ed509c7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 29 02:14:50 2019 +0200

    BUZZ cleanup (#14760)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 379f41646f..efc424dc9a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -555,21 +555,21 @@ void MarlinUI::status_screen() {
         new_frm = old_frm;
     }
     else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
       new_frm = 100;
 
     LIMIT(new_frm, 10, 999);
 
     if (old_frm != new_frm) {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
-      #if ENABLED(BEEP_ON_FEEDRATE_CHANGE)
+      #if HAS_BUZZER && ENABLED(BEEP_ON_FEEDRATE_CHANGE)
         static millis_t next_beep;
         #ifndef GOT_MS
           const millis_t ms = millis();
         #endif
         if (ELAPSED(ms, next_beep)) {
           BUZZ(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
           next_beep = ms + 500UL;
         }
       #endif
     }
@@ -601,22 +601,24 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     refresh();
   #endif
 
   #if HAS_ENCODER_ACTION
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
-  // Buzz and wait. The delay is needed for buttons to settle!
-  buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+  #if HAS_BUZZER
+    // Buzz and wait. Is the delay needed for buttons to settle?
+    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+  #endif
 
   #if HAS_LCD_MENU
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   #endif
 }
 

commit 369fb2806dfae1be57a3aaee205cd417e3a5f624
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Jul 22 19:08:54 2019 -0600

    Fix compilation warnings, errors (#14704)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f491570720..379f41646f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -531,21 +531,21 @@ void MarlinUI::status_screen() {
       #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
       #if DISABLED(NO_LCD_REINIT)
         init_lcd(); // May revive the LCD if static electricity killed it
       #endif
       return;
     }
 
-  #endif // HAS_LCD_MENU
+  #endif
 
   #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
 
     const int16_t old_frm = feedrate_percentage;
           int16_t new_frm = old_frm + int16_t(encoderPosition);
 
     // Dead zone at 100% feedrate
     if (old_frm == 100) {
       if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
         new_frm -= ENCODER_FEEDRATE_DEADZONE;
@@ -795,21 +795,23 @@ void MarlinUI::update() {
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
           set_status_P(PSTR(MSG_SD_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
             set_status_P(PSTR(MSG_SD_REMOVED));
-            if (!on_status_screen()) return_to_status();
+            #if HAS_LCD_MENU
+              return_to_status();
+            #endif
           }
         }
 
         #if DISABLED(NO_LCD_REINIT)
           init_lcd(); // May revive the LCD if static electricity killed it
         #endif
 
       #endif
 
       refresh();

commit e5aa45329305be8ac5e277305d52a449a41bfc98
Author: Tim Moore <tim@youngmoores.com>
Date:   Sat Jul 20 21:14:09 2019 -0700

    Add support for 2 Neopixel strips (#14667)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 719609a9a8..f491570720 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -580,22 +580,22 @@ void MarlinUI::status_screen() {
 }
 
 void MarlinUI::kill_screen(PGM_P lcd_msg) {
   init();
   set_alert_status_P(lcd_msg);
 
   // RED ALERT. RED ALERT.
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.set_color(LEDColorRed());
     #ifdef NEOPIXEL_BKGD_LED_INDEX
-      pixels.setPixelColor(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
-      pixels.show();
+      neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
+      neo.show();
     #endif
   #endif
 
   draw_kill_screen();
 }
 
 void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     refresh();

commit 39e1726498a79d99fc15728cdebde5a41f4cfc19
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Jul 20 08:41:34 2019 +0200

    Comments, includes (#14671)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cf16395854..719609a9a8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1460,21 +1460,21 @@ void MarlinUI::update() {
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_INFO, PSTR("UI Abort"));
     #endif
     print_job_timer.stop();
     set_status_P(PSTR(MSG_PRINT_ABORTED));
-    #if HAS_SPI_LCD
+    #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif
 
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU

commit c9aa68ef7aa358bb633b6d87232a94bfa6b7d7c8
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Jul 18 07:41:15 2019 +0700

    Encoder direction: Wrangle, Revert select screen change (#14628)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b932b4b4c5..cf16395854 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -385,21 +385,21 @@ bool MarlinUI::get_blink() {
 
   bool MarlinUI::handle_keypad() {
 
     #if HAS_ADC_BUTTONS
 
       #define ADC_MIN_KEY_DELAY 100
       if (keypad_buttons) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           #if HAS_LCD_MENU
-            if (encoderDirection == -1) {     // ADC_KEYPAD forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
+            if (encoderDirection == -(ENCODERBASE)) { // ADC_KEYPAD forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
                    if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             }
             else
           #endif
           {
             #if HAS_LCD_MENU
                    if (RRK(EN_KEYPAD_UP))     encoderPosition -= ENCODER_PULSES_PER_STEP;
@@ -473,21 +473,20 @@ bool MarlinUI::get_blink() {
 #if ENABLED(LCD_PROGRESS_BAR)
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
     millis_t MarlinUI::expire_status_ms; // = 0
   #endif
 #endif
 
 void MarlinUI::status_screen() {
 
   #if HAS_LCD_MENU
-    encoder_direction_normal();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 169aa2f6f6..b932b4b4c5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1515,21 +1515,23 @@ void MarlinUI::update() {
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
         uint8_t &progress = progress_bar_percent;
+        #define _PLIMIT(P) ((P) & 0x7F)
       #else
+        #define _PLIMIT(P) P
         uint8_t progress = 0;
       #endif
       #if ENABLED(SDSUPPORT)
         if (IS_SD_PRINTING()) progress = card.percentDone();
       #endif
-      return progress;
+      return _PLIMIT(progress);
     }
   #endif
 
 #endif // HAS_DISPLAY

commit 81d629bc471dcf926337836d1dd76910d9ff4bfe
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 15 01:16:26 2019 +0200

    Robin & Longer3D SPI TFT driver (#14595)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2fb2b209e9..169aa2f6f6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -95,20 +95,25 @@
 
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
+  #if ENABLED(TOUCH_BUTTONS)
+    #include "../feature/touch/xpt2046.h"
+    volatile uint8_t MarlinUI::touch_buttons;
+    uint8_t MarlinUI::read_touch_buttons() { return touch.read_buttons(); }
+  #endif
 #endif
 
 #if ENABLED(INIT_SDCARD_ON_BOOT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
@@ -317,22 +322,27 @@ void MarlinUI::init() {
 
   #if ENABLED(SDSUPPORT)
     #if PIN_EXISTS(SD_DETECT)
       SET_INPUT_PULLUP(SD_DETECT_PIN);
     #endif
     #if ENABLED(INIT_SDCARD_ON_BOOT)
       lcd_sd_status = 2; // UNKNOWN
     #endif
   #endif
 
-  #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
-    slow_buttons = 0;
+  #if HAS_ENCODER_ACTION
+    #if HAS_SLOW_BUTTONS
+      slow_buttons = 0;
+    #endif
+    #if ENABLED(TOUCH_BUTTONS)
+      touch_buttons = 0;
+    #endif
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
 bool MarlinUI::get_blink() {
@@ -816,30 +826,39 @@ void MarlinUI::update() {
   #endif // INIT_SDCARD_ON_BOOT
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
+    #if ENABLED(TOUCH_BUTTONS)
+      if (on_status_screen())
+        next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
+    #endif
+
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if HAS_SLOW_BUTTONS
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
+      #if ENABLED(TOUCH_BUTTONS)
+        touch_buttons = read_touch_buttons();
+      #endif
+
       #if ENABLED(REPRAPWORLD_KEYPAD)
 
         if (handle_keypad()) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
 
       #endif
 
@@ -1173,20 +1192,23 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
+          #if ENABLED(TOUCH_BUTTONS)
+            | touch_buttons
+          #endif
         ;
       #elif HAS_ADC_BUTTONS
         buttons = 0;
       #endif
 
       #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d652d90abf..2fb2b209e9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -541,21 +541,21 @@ void MarlinUI::status_screen() {
       if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
         new_frm -= ENCODER_FEEDRATE_DEADZONE;
       else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
         new_frm += ENCODER_FEEDRATE_DEADZONE;
       else
         new_frm = old_frm;
     }
     else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
       new_frm = 100;
 
-    new_frm = constrain(new_frm, 10, 999);
+    LIMIT(new_frm, 10, 999);
 
     if (old_frm != new_frm) {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
       #if ENABLED(BEEP_ON_FEEDRATE_CHANGE)
         static millis_t next_beep;
         #ifndef GOT_MS
           const millis_t ms = millis();
         #endif
         if (ELAPSED(ms, next_beep)) {

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fb4975585d..d652d90abf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -143,21 +143,21 @@ millis_t next_button_update_ms;
     const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
       const char *outstr = theCard.longest_filename();
       if (theCard.longFilename[0]) {
         #if ENABLED(SCROLL_LONG_FILENAMES)
           if (doScroll) {
             for (uint8_t l = FILENAME_LENGTH; l--;)
               hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
             static uint8_t filename_scroll_hash;
             if (filename_scroll_hash != hash) {                              // If the hash changed...
               filename_scroll_hash = hash;                                   // Save the new hash
-              filename_scroll_max = MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
+              filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
               filename_scroll_pos = 0;                                       // Reset scroll to the start
               lcd_status_update_delay = 8;                                   // Don't scroll right away
             }
             outstr += filename_scroll_pos;
           }
         #else
           theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
         #endif
       }
       return outstr;

commit de462f2b8a72716bf6e6558e63a1002658da7907
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 3 19:11:30 2019 -0500

    Revert "Sort out settings.load with SD EEPROM emulation (#14458)"
    
    This reverts commit 108d0df56532e4eb30467d36b0fb2aa5bf4f50be.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9dc9ca1cdf..fb4975585d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -74,24 +74,20 @@
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/printcounter.h"
 #include "../module/motion.h"
 #include "../gcode/queue.h"
 
 #include "../Marlin.h"
 
-#if ENABLED(SD_EEPROM_EMULATION)
-  #include "../module/configuration_store.h"
-#endif
-
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
@@ -780,27 +776,22 @@ void MarlinUI::update() {
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
-        if (old_sd_status == 2) {
-          #if ENABLED(SD_EEPROM_EMULATION)
-            SERIAL_ECHOLNPGM("Loading settings from SD");
-            (void)settings.load();
-          #endif
+        if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
-        }
         else
           set_status_P(PSTR(MSG_SD_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
             set_status_P(PSTR(MSG_SD_REMOVED));
             if (!on_status_screen()) return_to_status();
           }

commit 1620738701abbbc349e4f48fb2a0e415bda0bcd1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 09:38:29 2019 -0500

    Home dir use < or >

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 37e63cdae8..9dc9ca1cdf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -423,21 +423,21 @@ bool MarlinUI::get_blink() {
       }
       else if (!keypad_debounce) {
         keypad_debounce = 2;
 
         const bool homed = all_axes_homed();
 
         #if HAS_LCD_MENU
 
           if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
 
-          #if DISABLED(DELTA) && Z_HOME_DIR == -1
+          #if DISABLED(DELTA) && Z_HOME_DIR < 0
             if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
           #endif
 
           if (homed) {
             #if ENABLED(DELTA) || Z_HOME_DIR != -1
               if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
             #endif
             if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
             if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
             if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);

commit 108d0df56532e4eb30467d36b0fb2aa5bf4f50be
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 1 16:10:17 2019 +0200

    Sort out settings.load with SD EEPROM emulation (#14458)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 77a56f8482..37e63cdae8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -74,20 +74,24 @@
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/printcounter.h"
 #include "../module/motion.h"
 #include "../gcode/queue.h"
 
 #include "../Marlin.h"
 
+#if ENABLED(SD_EEPROM_EMULATION)
+  #include "../module/configuration_store.h"
+#endif
+
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
@@ -776,22 +780,27 @@ void MarlinUI::update() {
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
-        if (old_sd_status == 2)
+        if (old_sd_status == 2) {
+          #if ENABLED(SD_EEPROM_EMULATION)
+            SERIAL_ECHOLNPGM("Loading settings from SD");
+            (void)settings.load();
+          #endif
           card.beginautostart();  // Initial boot
+        }
         else
           set_status_P(PSTR(MSG_SD_INSERTED));
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
             set_status_P(PSTR(MSG_SD_REMOVED));
             if (!on_status_screen()) return_to_status();
           }

commit 10b85be4055aee35ef649f6bc5444a67082a6024
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 1 00:44:39 2019 -0500

    status_message_level => alert_level

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fb507bf12b..77a56f8482 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
 
-// These displays all share the MarlinUI class
+// All displays share the MarlinUI class
 #if HAS_DISPLAY
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
   #if ENABLED(HOST_ACTION_COMMANDS)
     #include "../feature/host_actions.h"
@@ -49,21 +49,21 @@
       #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
     #endif
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
   #define MAX_MESSAGE_LENGTH 63
 #endif
 
 #ifdef MAX_MESSAGE_LENGTH
-  uint8_t MarlinUI::status_message_level; // = 0
+  uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t MarlinUI::progress_bar_percent; // = 0
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
@@ -75,25 +75,25 @@
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/printcounter.h"
 #include "../module/motion.h"
 #include "../gcode/queue.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
- #include "../feature/power_loss_recovery.h"
+  #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
- #include "../feature/bedlevel/bedlevel.h"
+  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_TRINAMIC
   #include "../feature/tmc_util.h"
 #endif
 
@@ -1309,21 +1309,21 @@ void MarlinUI::update() {
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif
 
     refresh();
   }
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
-    if (status_message_level > 0) return;
+    if (alert_level) return;
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!
 
     // Get a pointer to the null terminator
     const char* pend = message + strlen(message);
 
     //  If length of supplied UTF8 string is greater than
     // our buffer size, start cutting whole UTF8 chars
@@ -1336,43 +1336,42 @@ void MarlinUI::update() {
     uint8_t maxLen = pend - message;
     strncpy(status_message, message, maxLen);
     status_message[maxLen] = '\0';
 
     finish_status(persist);
   }
 
   #include <stdarg.h>
 
   void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-    if (level < status_message_level) return;
-    status_message_level = level;
+    if (level < alert_level) return;
+    alert_level = level;
     va_list args;
     va_start(args, fmt);
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
     finish_status(level > 0);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
-    if (level < 0) level = status_message_level = 0;
-    if (level < status_message_level) return;
-    status_message_level = level;
+    if (level < 0) level = alert_level = 0;
+    if (level < alert_level) return;
+    alert_level = level;
 
-    // Here we have a problem. The message is encoded in UTF8, so
-    // arbitrarily cutting it will be a problem. We MUST be sure
-    // that there is no cutting in the middle of a multibyte character!
+    // Since the message is encoded in UTF8 it must
+    // only be cut on a character boundary.
 
     // Get a pointer to the null terminator
     PGM_P pend = message + strlen_P(message);
 
-    //  If length of supplied UTF8 string is greater than
-    // our buffer size, start cutting whole UTF8 chars
+    // If length of supplied UTF8 string is greater than
+    // the buffer size, start cutting whole UTF8 chars
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
       --pend;
       while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
     };
 
     // At this point, we have the proper cut point. Use it
     uint8_t maxLen = pend - message;
     strncpy_P(status_message, message, maxLen);
     status_message[maxLen] = '\0';
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fd99db7882..fb507bf12b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 064177154ce7912293efa67c7e0dfcaa4a7301ec
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 26 09:55:57 2019 +0100

    Update SD card connection / sharing options (#14325)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 998541cc23..fd99db7882 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -97,21 +97,21 @@
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
 #endif
 
-#if ENABLED(SDSUPPORT)
+#if ENABLED(INIT_SDCARD_ON_BOOT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
@@ -312,21 +312,23 @@ void MarlinUI::init() {
       SET_INPUT_PULLUP(SHIFT_OUT);
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
   #if ENABLED(SDSUPPORT)
     #if PIN_EXISTS(SD_DETECT)
       SET_INPUT_PULLUP(SD_DETECT_PIN);
     #endif
-    lcd_sd_status = 2; // UNKNOWN
+    #if ENABLED(INIT_SDCARD_ON_BOOT)
+      lcd_sd_status = 2; // UNKNOWN
+    #endif
   #endif
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
@@ -763,21 +765,21 @@ void MarlinUI::update() {
 
     #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
-  #if ENABLED(SDSUPPORT)
+  #if ENABLED(INIT_SDCARD_ON_BOOT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
@@ -804,21 +806,21 @@ void MarlinUI::update() {
       refresh();
 
       ms = millis();
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
 
       #ifdef LED_BACKLIGHT_TIMEOUT
         leds.reset_timeout(ms);
       #endif
     }
 
-  #endif // SDSUPPORT
+  #endif // INIT_SDCARD_ON_BOOT
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)

commit a4aa3621c087667ced39b796dfb9b8fdd4680a36
Author: thisiskeithb <13375512+thisiskeithb@users.noreply.github.com>
Date:   Mon Jun 24 01:42:22 2019 -0700

    MKS Robin Mini Board Support (#14366)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3d2c25f267..998541cc23 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -514,21 +514,23 @@ void MarlinUI::status_screen() {
 
   #endif // LCD_PROGRESS_BAR
 
   #if HAS_LCD_MENU
 
     if (use_click()) {
       #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
-      init_lcd(); // May revive the LCD if static electricity killed it
+      #if DISABLED(NO_LCD_REINIT)
+        init_lcd(); // May revive the LCD if static electricity killed it
+      #endif
       return;
     }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
 
     const int16_t old_frm = feedrate_percentage;
           int16_t new_frm = old_frm + int16_t(encoderPosition);
 
@@ -786,21 +788,23 @@ void MarlinUI::update() {
       }
       #if PIN_EXISTS(SD_DETECT)
         else {
           card.release();
           if (old_sd_status != 2) {
             set_status_P(PSTR(MSG_SD_REMOVED));
             if (!on_status_screen()) return_to_status();
           }
         }
 
-        init_lcd(); // May revive the LCD if static electricity killed it
+        #if DISABLED(NO_LCD_REINIT)
+          init_lcd(); // May revive the LCD if static electricity killed it
+        #endif
 
       #endif
 
       refresh();
 
       ms = millis();
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
 
       #ifdef LED_BACKLIGHT_TIMEOUT
         leds.reset_timeout(ms);

commit 49ea1c635ac845aa875b22a939b1b96d89154ba8
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Jun 20 15:37:20 2019 -0600

    Fix missing dependencies (#14339)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6dba900cb7..3d2c25f267 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1417,38 +1417,46 @@ void MarlinUI::update() {
     #if SERVICE_INTERVAL_3 > 0
       else if (print_job_timer.needsService(3)) msg = service3;
     #endif
 
     else
       msg = welcome;
 
     set_status_P(msg, -1);
   }
 
+  #if ENABLED(SDSUPPORT)
+    extern bool wait_for_user, wait_for_heatup;
+  #endif
+
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
       card.flag.abort_sd_printing = true;
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_INFO, PSTR("UI Abort"));
     #endif
     print_job_timer.stop();
     set_status_P(PSTR(MSG_PRINT_ABORTED));
     #if HAS_SPI_LCD
       return_to_status();
     #endif
   }
 
+  #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
+    #include "../gcode/queue.h"
+  #endif
+
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
       synchronize(PSTR(MSG_PAUSE_PRINT));
     #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       if (recovery.enabled) recovery.save(true, false);
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7a3ea4538f..6dba900cb7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -434,21 +434,21 @@ bool MarlinUI::get_blink() {
             #endif
             if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
             if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
             if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
             if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
             if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
           }
 
         #endif // HAS_LCD_MENU
 
-        if (!homed && RRK(EN_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
+        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(PSTR("G28"));
         return true;
       }
 
     #endif // !ADC_KEYPAD
 
     return false;
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
@@ -1454,35 +1454,35 @@ void MarlinUI::update() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(PSTR(MSG_PRINT_PAUSED));
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
         lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif
-      enqueue_and_echo_commands_front_P(PSTR("M25 P\nM24"));
+      queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
-      enqueue_and_echo_commands_P(PSTR("M25"));
+      queue.inject_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       wait_for_heatup = wait_for_user = false;
     #endif
     #if ENABLED(SDSUPPORT)
-      if (card.isPaused()) enqueue_and_echo_commands_P(PSTR("M24"));
+      if (card.isPaused()) queue.inject_P(PSTR("M24"));
     #endif
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
 
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)

commit eb1c9113c23869b839abb63b7a43f84d13ed603c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 15 15:32:09 2019 -0500

    Try to init SD with no detect pin

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 13f5f5fb00..7a3ea4538f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -97,21 +97,21 @@
   #include "../feature/tmc_util.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
 #endif
 
-#if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+#if ENABLED(SDSUPPORT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
@@ -308,22 +308,24 @@ void MarlinUI::init() {
       OUT_WRITE(SHIFT_LD, HIGH);
       #if defined(SHIFT_EN) && SHIFT_EN >= 0
         OUT_WRITE(SHIFT_EN, LOW);
       #endif
       SET_INPUT_PULLUP(SHIFT_OUT);
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
-    SET_INPUT_PULLUP(SD_DETECT_PIN);
+  #if ENABLED(SDSUPPORT)
+    #if PIN_EXISTS(SD_DETECT)
+      SET_INPUT_PULLUP(SD_DETECT_PIN);
+    #endif
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
@@ -759,56 +761,60 @@ void MarlinUI::update() {
 
     #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+  #if ENABLED(SDSUPPORT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
           set_status_P(PSTR(MSG_SD_INSERTED));
       }
-      else {
-        card.release();
-        if (old_sd_status != 2) {
-          set_status_P(PSTR(MSG_SD_REMOVED));
-          if (!on_status_screen()) return_to_status();
+      #if PIN_EXISTS(SD_DETECT)
+        else {
+          card.release();
+          if (old_sd_status != 2) {
+            set_status_P(PSTR(MSG_SD_REMOVED));
+            if (!on_status_screen()) return_to_status();
+          }
         }
-      }
+
+        init_lcd(); // May revive the LCD if static electricity killed it
+
+      #endif
 
       refresh();
-      init_lcd(); // May revive the LCD if static electricity killed it
 
       ms = millis();
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
 
       #ifdef LED_BACKLIGHT_TIMEOUT
         leds.reset_timeout(ms);
       #endif
     }
 
-  #endif // SDSUPPORT && SD_DETECT_PIN
+  #endif // SDSUPPORT
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)

commit 24c23b60fa96180a6237db45648d4732a095192f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 15 15:29:15 2019 -0500

    Use lambda, fix wrap pointer

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8ae2a897df..13f5f5fb00 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -197,59 +197,59 @@ millis_t next_button_update_ms;
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
   void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
     SETCURSOR(x, y);
     if (!string) return;
 
+    auto _newline = [&x, &y]() {
+      x = 0; y++;               // move x to string len (plus space)
+      SETCURSOR(0, y);          // simulate carriage return
+    };
+
     uint8_t *p = (uint8_t*)string;
     wchar_t ch;
     if (wordwrap) {
-      uint8_t *wrd = p, c = 0;
+      uint8_t *wrd = nullptr, c = 0;
+      // find the end of the part
       for (;;) {
+        if (!wrd) wrd = p;            // Get word start /before/ advancing
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
-        const bool eol = !ch;
+        const bool eol = !ch;         // zero ends the string
+        // End or a break between phrases?
         if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
-          if (!c && ch == ' ') continue; // collapse extra spaces
-          if (x + c > LCD_WIDTH && x >= (LCD_WIDTH) / 4) { // should it wrap?
-            x = 0; y++;               // move x to string len (plus space)
-            SETCURSOR(0, y);          // simulate carriage return
-          }
+          if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+          // Past the right and the word is not too long?
+          if (x + c > LCD_WIDTH && x >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
           c += !eol;                  // +1 so the space will be printed
           x += c;                     // advance x to new position
           while (c) {                 // character countdown
             --c;                      // count down to zero
             wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
-            lcd_put_wchar(ch);        // word (plus space) to the LCD
+            lcd_put_wchar(ch);        // character to the LCD
           }
-          if (eol) break;             // all done
+          if (eol) break;             // all done!
           wrd = nullptr;              // set up for next word
         }
-        else {
-          if (!wrd) wrd = p;          // starting a new word?
-          c++;                        // count word characters
-        }
+        else c++;                     // count word characters
       }
     }
     else {
       for (;;) {
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         if (!ch) break;
         lcd_put_wchar(ch);
         x++;
-        if (x >= LCD_WIDTH) {
-          x = 0; y++;
-          SETCURSOR(0, y);
-        }
+        if (x >= LCD_WIDTH) _newline();
       }
     }
   }
 
   void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
     uint8_t x = 0, y = 0;
     if (!string && plen + slen <= LCD_WIDTH) {
       x = (LCD_WIDTH - plen - slen) / 2;
       y = LCD_HEIGHT > 3 ? 1 : 0;

commit a17f057daaa14863406cc8854033f5a6d8a1e1c6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 15 14:06:23 2019 -0500

    Fix word wrapping on select screens

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cd501ef32c..8ae2a897df 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -198,50 +198,50 @@ millis_t next_button_update_ms;
       safe_delay(50);
     }
 
   #endif
 
   void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
     SETCURSOR(x, y);
     if (!string) return;
 
     uint8_t *p = (uint8_t*)string;
+    wchar_t ch;
     if (wordwrap) {
       uint8_t *wrd = p, c = 0;
       for (;;) {
-        wchar_t ch;
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         const bool eol = !ch;
         if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
           if (!c && ch == ' ') continue; // collapse extra spaces
-          if (x + c > LCD_WIDTH && c < (LCD_WIDTH) * 3 / 4) { // should it wrap?
+          if (x + c > LCD_WIDTH && x >= (LCD_WIDTH) / 4) { // should it wrap?
             x = 0; y++;               // move x to string len (plus space)
             SETCURSOR(0, y);          // simulate carriage return
           }
           c += !eol;                  // +1 so the space will be printed
           x += c;                     // advance x to new position
-          while (c--) {               // character countdown
+          while (c) {                 // character countdown
+            --c;                      // count down to zero
             wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
             lcd_put_wchar(ch);        // word (plus space) to the LCD
           }
           if (eol) break;             // all done
           wrd = nullptr;              // set up for next word
         }
         else {
           if (!wrd) wrd = p;          // starting a new word?
           c++;                        // count word characters
         }
       }
     }
     else {
       for (;;) {
-        wchar_t ch;
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         if (!ch) break;
         lcd_put_wchar(ch);
         x++;
         if (x >= LCD_WIDTH) {
           x = 0; y++;
           SETCURSOR(0, y);
         }
       }
     }

commit 18904c42f6081391c5ffc096c8acf2ce54dc4a34
Author: MastS <51464853+MastS@users.noreply.github.com>
Date:   Thu Jun 13 04:59:39 2019 +0200

    Fysetc LCD backlight timeout (#14265)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4822ebd2d7..cd501ef32c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -15,20 +15,24 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
+#ifdef LED_BACKLIGHT_TIMEOUT
+  #include "../feature/leds/leds.h"
+#endif
+
 // These displays all share the MarlinUI class
 #if HAS_DISPLAY
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
   #if ENABLED(HOST_ACTION_COMMANDS)
@@ -556,20 +560,30 @@ void MarlinUI::status_screen() {
     }
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
 void MarlinUI::kill_screen(PGM_P lcd_msg) {
   init();
   set_alert_status_P(lcd_msg);
+
+  // RED ALERT. RED ALERT.
+  #ifdef LED_BACKLIGHT_TIMEOUT
+    leds.set_color(LEDColorRed());
+    #ifdef NEOPIXEL_BKGD_LED_INDEX
+      pixels.setPixelColor(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
+      pixels.show();
+    #endif
+  #endif
+
   draw_kill_screen();
 }
 
 void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     refresh();
   #endif
 
   #if HAS_ENCODER_ACTION
@@ -707,20 +721,24 @@ bool MarlinUI::detected() {
     #endif
   ;
 }
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
   millis_t ms = millis();
 
+  #ifdef LED_BACKLIGHT_TIMEOUT
+    leds.update_timeout(powersupply_on);
+  #endif
+
   #if HAS_LCD_MENU
 
     #if LCD_TIMEOUT_TO_STATUS
       static millis_t return_to_status_ms = 0;
     #endif
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for button_pressed(), etc.
@@ -770,20 +788,24 @@ void MarlinUI::update() {
           set_status_P(PSTR(MSG_SD_REMOVED));
           if (!on_status_screen()) return_to_status();
         }
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
 
       ms = millis();
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
+
+      #ifdef LED_BACKLIGHT_TIMEOUT
+        leds.reset_timeout(ms);
+      #endif
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
@@ -844,24 +866,30 @@ void MarlinUI::update() {
 
           #else
 
             constexpr int32_t encoderMultiplier = 1;
 
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / (ENCODER_PULSES_PER_STEP);
           encoderDiff = 0;
         }
+
         #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
+
         refresh(LCDVIEW_REDRAW_NOW);
+
+        #ifdef LED_BACKLIGHT_TIMEOUT
+          leds.reset_timeout(ms);
+        #endif
       }
 
     #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (on_status_screen() && !lcd_status_update_delay--) {
       lcd_status_update_delay = 9
         #if HAS_GRAPHICAL_LCD
           + 3

commit b7eeb5b13b4f299b8e1b994d678e35262a1c09b0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jun 10 18:46:42 2019 -0400

    Move BLTouch options to adv config (#14131)
    
    Plus other BLTouch and menu enhancements.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 855be5bce2..4822ebd2d7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -189,24 +189,53 @@ millis_t next_button_update_ms;
 
     bool MarlinUI::external_control; // = false
 
     void MarlinUI::wait_for_release() {
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
-  void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte) {
+  void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
     SETCURSOR(x, y);
-    if (string) {
-      uint8_t *p = (uint8_t*)string;
+    if (!string) return;
+
+    uint8_t *p = (uint8_t*)string;
+    if (wordwrap) {
+      uint8_t *wrd = p, c = 0;
+      for (;;) {
+        wchar_t ch;
+        p = get_utf8_value_cb(p, cb_read_byte, &ch);
+        const bool eol = !ch;
+        if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
+          if (!c && ch == ' ') continue; // collapse extra spaces
+          if (x + c > LCD_WIDTH && c < (LCD_WIDTH) * 3 / 4) { // should it wrap?
+            x = 0; y++;               // move x to string len (plus space)
+            SETCURSOR(0, y);          // simulate carriage return
+          }
+          c += !eol;                  // +1 so the space will be printed
+          x += c;                     // advance x to new position
+          while (c--) {               // character countdown
+            wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
+            lcd_put_wchar(ch);        // word (plus space) to the LCD
+          }
+          if (eol) break;             // all done
+          wrd = nullptr;              // set up for next word
+        }
+        else {
+          if (!wrd) wrd = p;          // starting a new word?
+          c++;                        // count word characters
+        }
+      }
+    }
+    else {
       for (;;) {
         wchar_t ch;
         p = get_utf8_value_cb(p, cb_read_byte, &ch);
         if (!ch) break;
         lcd_put_wchar(ch);
         x++;
         if (x >= LCD_WIDTH) {
           x = 0; y++;
           SETCURSOR(0, y);
         }
@@ -214,21 +243,21 @@ millis_t next_button_update_ms;
     }
   }
 
   void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
     uint8_t x = 0, y = 0;
     if (!string && plen + slen <= LCD_WIDTH) {
       x = (LCD_WIDTH - plen - slen) / 2;
       y = LCD_HEIGHT > 3 ? 1 : 0;
     }
-    wrap_string_P(x, y, pref);
+    wrap_string_P(x, y, pref, true);
     if (string) {
       if (x) { x = 0; y++; } // Move to the start of the next line
       wrap_string(x, y, string);
     }
     if (suff) wrap_string_P(x, y, suff);
   }
 
 #endif // HAS_LCD_MENU
 
 void MarlinUI::init() {

commit 5ca8d51e123463004626e853a930e2f88febd66d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sat Jun 8 17:23:53 2019 +0700

    Ability to insert G-code in front of queue (#14229)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9cdcfbace6..855be5bce2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1391,21 +1391,21 @@ void MarlinUI::update() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(PSTR(MSG_PRINT_PAUSED));
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       #if HAS_SPI_LCD
         lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
       #endif
-      enqueue_and_echo_commands_P(PSTR("M25 P\nM24"));
+      enqueue_and_echo_commands_front_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       enqueue_and_echo_commands_P(PSTR("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif
   }
 
   void MarlinUI::resume_print() {
     reset_status();
     #if ENABLED(PARK_HEAD_ON_PAUSE)

commit 66e22d9f5a9fe8c9a5076f67099be413c99cd9e8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Jun 7 08:08:41 2019 -0400

    ExtUI Heated Chamber support (#14198)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f0ebcefbb3..9cdcfbace6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1373,21 +1373,23 @@ void MarlinUI::update() {
       host_prompt_open(PROMPT_INFO, PSTR("UI Abort"));
     #endif
     print_job_timer.stop();
     set_status_P(PSTR(MSG_PRINT_ABORTED));
     #if HAS_SPI_LCD
       return_to_status();
     #endif
   }
 
   void MarlinUI::pause_print() {
-    synchronize(PSTR(MSG_PAUSE_PRINT));
+    #if HAS_LCD_MENU
+      synchronize(PSTR(MSG_PAUSE_PRINT));
+    #endif
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       if (recovery.enabled) recovery.save(true, false);
     #endif
 
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
     #endif
 
     set_status_P(PSTR(MSG_PRINT_PAUSED));

commit f889cc6ea62ff07cf2d61de400f403cd55676630
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu May 30 17:24:13 2019 -0400

    ExtUI parity with SPI LCDs (#14172)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a044886793..f0ebcefbb3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -24,20 +24,23 @@
 
 // These displays all share the MarlinUI class
 #if HAS_DISPLAY
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
+  #if ENABLED(HOST_ACTION_COMMANDS)
+    #include "../feature/host_actions.h"
+  #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
       #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
     #else
       #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
     #endif
@@ -1351,20 +1354,77 @@ void MarlinUI::update() {
     #if SERVICE_INTERVAL_3 > 0
       else if (print_job_timer.needsService(3)) msg = service3;
     #endif
 
     else
       msg = welcome;
 
     set_status_P(msg, -1);
   }
 
+  void MarlinUI::abort_print() {
+    #if ENABLED(SDSUPPORT)
+      wait_for_heatup = wait_for_user = false;
+      card.flag.abort_sd_printing = true;
+    #endif
+    #ifdef ACTION_ON_CANCEL
+      host_action_cancel();
+    #endif
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_open(PROMPT_INFO, PSTR("UI Abort"));
+    #endif
+    print_job_timer.stop();
+    set_status_P(PSTR(MSG_PRINT_ABORTED));
+    #if HAS_SPI_LCD
+      return_to_status();
+    #endif
+  }
+
+  void MarlinUI::pause_print() {
+    synchronize(PSTR(MSG_PAUSE_PRINT));
+
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      if (recovery.enabled) recovery.save(true, false);
+    #endif
+
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume"));
+    #endif
+
+    set_status_P(PSTR(MSG_PRINT_PAUSED));
+
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      #if HAS_SPI_LCD
+        lcd_pause_show_message(PAUSE_MESSAGE_PAUSING, PAUSE_MODE_PAUSE_PRINT);  // Show message immediately to let user know about pause in progress
+      #endif
+      enqueue_and_echo_commands_P(PSTR("M25 P\nM24"));
+    #elif ENABLED(SDSUPPORT)
+      enqueue_and_echo_commands_P(PSTR("M25"));
+    #elif defined(ACTION_ON_PAUSE)
+      host_action_pause();
+    #endif
+  }
+
+  void MarlinUI::resume_print() {
+    reset_status();
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      wait_for_heatup = wait_for_user = false;
+    #endif
+    #if ENABLED(SDSUPPORT)
+      if (card.isPaused()) enqueue_and_echo_commands_P(PSTR("M24"));
+    #endif
+    #ifdef ACTION_ON_RESUME
+      host_action_resume();
+    #endif
+    print_job_timer.start(); // Also called by M24
+  }
+
   #if HAS_PRINT_PROGRESS
     uint8_t MarlinUI::get_progress() {
       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
         uint8_t &progress = progress_bar_percent;
       #else
         uint8_t progress = 0;
       #endif
       #if ENABLED(SDSUPPORT)
         if (IS_SD_PRINTING()) progress = card.percentDone();
       #endif

commit 3cd19a8ec080dda75c6326886e90fc2f0972b499
Author: Pavel4e5 <50713272+Pavel4e5@users.noreply.github.com>
Date:   Sun May 19 06:52:55 2019 +0500

    Improve Zonestar keypad responsiveness (#14056)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4035bd34cd..a044886793 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -989,22 +989,22 @@ void MarlinUI::update() {
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + 100, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
     {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - 100,
        ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + 100, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
   };
 
   uint8_t get_ADC_keyValue(void) {
     if (thermalManager.ADCKey_count >= 16) {
-      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
-      thermalManager.current_ADCKey_raw = 0;
+      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw << 2;
+      thermalManager.current_ADCKey_raw = 1024;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < 4000)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }

commit 7ccbcf2eaad878daf139a5e52715c423229618d9
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu May 16 19:38:03 2019 -0600

    Fix TMC EEPROM regression (#14008)
    
    Partially undo 15357af to ensure TMC code is initialized in the proper order.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8dbec921e1..4035bd34cd 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -286,24 +286,20 @@ void MarlinUI::init() {
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
-
-  #if HAS_TRINAMIC && HAS_LCD_MENU
-    init_tmc_section();
-  #endif
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b17c4c6e03..8dbec921e1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -204,21 +204,21 @@ millis_t next_button_update_ms;
         lcd_put_wchar(ch);
         x++;
         if (x >= LCD_WIDTH) {
           x = 0; y++;
           SETCURSOR(0, y);
         }
       }
     }
   }
 
-  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=NULL*/, PGM_P const suff/*=NULL*/) {
+  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
     uint8_t x = 0, y = 0;
     if (!string && plen + slen <= LCD_WIDTH) {
       x = (LCD_WIDTH - plen - slen) / 2;
       y = LCD_HEIGHT > 3 ? 1 : 0;
     }
     wrap_string_P(x, y, pref);
     if (string) {
       if (x) { x = 0; y++; } // Move to the start of the next line
       wrap_string(x, y, string);

commit 23ec6504103a99a0d769346e2a503a1d1764cf7b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 7 20:32:50 2019 -0500

    Consolidate Malyan LCD and ExtUI

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2208b6b1bf..b17c4c6e03 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -16,21 +16,21 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
-#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+#if HAS_DISPLAY
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD
@@ -1185,21 +1185,21 @@ void MarlinUI::update() {
         return slow_bits;
       #endif // LCD_I2C_TYPE_MCP23017
     }
 
   #endif
 
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 
-#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+#if HAS_DISPLAY
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extensible_ui/ui_api.h"
   #endif
 
   ////////////////////////////////////////////
   /////////////// Status Line ////////////////
   ////////////////////////////////////////////
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
@@ -1369,11 +1369,11 @@ void MarlinUI::update() {
       #else
         uint8_t progress = 0;
       #endif
       #if ENABLED(SDSUPPORT)
         if (IS_SD_PRINTING()) progress = card.percentDone();
       #endif
       return progress;
     }
   #endif
 
-#endif // HAS_SPI_LCD || EXTENSIBLE_UI
+#endif // HAS_DISPLAY

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    …And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3fd483a79f..2208b6b1bf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -16,21 +16,21 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
-#if HAS_SPI_LCD || EITHER(MALYAN_LCD, EXTENSIBLE_UI)
+#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
   #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD

commit e7682eea425d2173e594b5cfdb5c2e4d6fc953c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 2 00:45:50 2019 -0500

    Use Arduino.h include wrapper (#13877)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f7381c1d14..3fd483a79f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -739,20 +739,21 @@ void MarlinUI::update() {
       else {
         card.release();
         if (old_sd_status != 2) {
           set_status_P(PSTR(MSG_SD_REMOVED));
           if (!on_status_screen()) return_to_status();
         }
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
+
       ms = millis();
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif

commit 610fb4668393265bbe2f18fe96a329b832ddc0c3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Apr 26 03:32:01 2019 -0400

    Fix some ExtUI issues (#13799)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0d4b88d2c3..f7381c1d14 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -18,20 +18,21 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || EITHER(MALYAN_LCD, EXTENSIBLE_UI)
   #include "ultralcd.h"
+  #include "fontutils.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0

commit 5051909c3c43ae42c14765d0adce4405b8e9a423
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 10:13:44 2019 -0500

    Update do_select_screen for general use (#13800)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cf1f8f98ea..0d4b88d2c3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -185,38 +185,53 @@ millis_t next_button_update_ms;
 
     bool MarlinUI::external_control; // = false
 
     void MarlinUI::wait_for_release() {
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
-  void wrap_string(uint8_t y, const char * const string) {
-    uint8_t x = LCD_WIDTH;
+  void _wrap_string(uint8_t &x, uint8_t &y, const char * const string, read_byte_cb_t cb_read_byte) {
+    SETCURSOR(x, y);
     if (string) {
       uint8_t *p = (uint8_t*)string;
       for (;;) {
-        if (x >= LCD_WIDTH) {
-          x = 0;
-          SETCURSOR(0, y++);
-        }
         wchar_t ch;
-        p = get_utf8_value_cb(p, read_byte_ram, &ch);
+        p = get_utf8_value_cb(p, cb_read_byte, &ch);
         if (!ch) break;
         lcd_put_wchar(ch);
         x++;
+        if (x >= LCD_WIDTH) {
+          x = 0; y++;
+          SETCURSOR(0, y);
+        }
       }
     }
   }
 
+  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=NULL*/, PGM_P const suff/*=NULL*/) {
+    const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
+    uint8_t x = 0, y = 0;
+    if (!string && plen + slen <= LCD_WIDTH) {
+      x = (LCD_WIDTH - plen - slen) / 2;
+      y = LCD_HEIGHT > 3 ? 1 : 0;
+    }
+    wrap_string_P(x, y, pref);
+    if (string) {
+      if (x) { x = 0; y++; } // Move to the start of the next line
+      wrap_string(x, y, string);
+    }
+    if (suff) wrap_string_P(x, y, suff);
+  }
+
 #endif // HAS_LCD_MENU
 
 void MarlinUI::init() {
 
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
 
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);

commit 81ca5a4cd43944bd7e9fffd740ce3abfb89a8687
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Apr 21 20:48:53 2019 -0500

    Fix and improve FYSETC LCD support (#13767)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cb8b308df3..cf1f8f98ea 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -661,20 +661,21 @@ bool MarlinUI::detected() {
     #else
       true
     #endif
   ;
 }
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
+  millis_t ms = millis();
 
   #if HAS_LCD_MENU
 
     #if LCD_TIMEOUT_TO_STATUS
       static millis_t return_to_status_ms = 0;
     #endif
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
@@ -722,25 +723,26 @@ void MarlinUI::update() {
       else {
         card.release();
         if (old_sd_status != 2) {
           set_status_P(PSTR(MSG_SD_REMOVED));
           if (!on_status_screen()) return_to_status();
         }
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
+      ms = millis();
+      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;  // delay LCD update until after SD activity completes
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
-  const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();

commit 321a5e65805f51e6817ff51db448dc5d8f28c900
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 21:10:41 2019 -0500

    Fix SD card reselect when scrolled (#13624)
    
    - Change encoder position to 16-bit integer.
    - Fix `SD_REPRINT_LAST_SELECTED_FILE` when the screen is scrolled.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 49970ecb1d..cb8b308df3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -111,21 +111,21 @@ uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
-  uint32_t MarlinUI::encoderPosition;
+  uint16_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
 #if HAS_LCD_MENU
   #include "menu/menu.h"
   #include "../sd/cardreader.h"
 
   #if ENABLED(SDSUPPORT)
 
     #if ENABLED(SCROLL_LONG_FILENAMES)
@@ -473,27 +473,27 @@ void MarlinUI::status_screen() {
       goto_screen(menu_main);
       init_lcd(); // May revive the LCD if static electricity killed it
       return;
     }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
 
     const int16_t old_frm = feedrate_percentage;
-          int16_t new_frm = old_frm + (int32_t)encoderPosition;
+          int16_t new_frm = old_frm + int16_t(encoderPosition);
 
     // Dead zone at 100% feedrate
     if (old_frm == 100) {
-      if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE)
+      if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
         new_frm -= ENCODER_FEEDRATE_DEADZONE;
-      else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE))
+      else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
         new_frm += ENCODER_FEEDRATE_DEADZONE;
       else
         new_frm = old_frm;
     }
     else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
       new_frm = 100;
 
     new_frm = constrain(new_frm, 10, 999);
 
     if (old_frm != new_frm) {

commit 9abe9aff56d44d42c9dc52679cc9f17592cd0bd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 13:44:35 2019 -0500

    Confirm before starting SD print (#13616)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 07a3910cd0..49970ecb1d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -185,21 +185,39 @@ millis_t next_button_update_ms;
 
     bool MarlinUI::external_control; // = false
 
     void MarlinUI::wait_for_release() {
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
-#endif
+  void wrap_string(uint8_t y, const char * const string) {
+    uint8_t x = LCD_WIDTH;
+    if (string) {
+      uint8_t *p = (uint8_t*)string;
+      for (;;) {
+        if (x >= LCD_WIDTH) {
+          x = 0;
+          SETCURSOR(0, y++);
+        }
+        wchar_t ch;
+        p = get_utf8_value_cb(p, read_byte_ram, &ch);
+        if (!ch) break;
+        lcd_put_wchar(ch);
+        x++;
+      }
+    }
+  }
+
+#endif // HAS_LCD_MENU
 
 void MarlinUI::init() {
 
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
 
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif

commit 81c2c3ec1123c1b16225ba58d905b592a417a3fb
Author: Robby Candra <bytegator@gmail.com>
Date:   Mon Apr 8 04:58:32 2019 +0700

    Continuous filename scrolling (#13609)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5b18ebc368..07a3910cd0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -802,24 +802,27 @@ void MarlinUI::update() {
           + 3
         #endif
       ;
       max_display_update_time--;
       refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
-      if (currentScreen == menu_sdcard && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
-        lcd_status_update_delay = 6;
+      if (currentScreen == menu_sdcard && !lcd_status_update_delay--) {
+        lcd_status_update_delay = 4;
+        if (++filename_scroll_pos > filename_scroll_max) {
+          filename_scroll_pos = 0;
+          lcd_status_update_delay = 12;
+        }
         refresh(LCDVIEW_REDRAW_NOW);
-        filename_scroll_pos++;
         #if LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {

commit 58bca6788374e6a0fcd8b3a5c513e1ad520b9a10
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:32:12 2019 -0500

    Unify status scrolling further

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ac8cf6592f..5b18ebc368 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1155,38 +1155,53 @@ void MarlinUI::update() {
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extensible_ui/ui_api.h"
   #endif
 
   ////////////////////////////////////////////
   /////////////// Status Line ////////////////
   ////////////////////////////////////////////
 
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    void MarlinUI::advance_status_scroll() {
+      // Advance by one UTF8 code-word
+      if (status_scroll_offset < utf8_strlen(status_message))
+        while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
+      else
+        status_scroll_offset = 0;
+    }
+    char* MarlinUI::status_and_len(uint8_t &len) {
+      char *out = status_message + status_scroll_offset;
+      len = utf8_strlen(out);
+      return out;
+    }
+  #endif
+
   void MarlinUI::finish_status(const bool persist) {
 
     #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
       UNUSED(persist);
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_ms = millis();
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
     #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = millis() + 5000UL; // Show status message for 5s
     #endif
 
-    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    #if HAS_SPI_LCD && ENABLED(STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif
 
     refresh();
   }
 

commit c4443f885e09291147c10b7e3062847a365feefd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:32:28 2019 -0500

    finishstatus => finish_status

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 44ba8df0a7..ac8cf6592f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1155,21 +1155,21 @@ void MarlinUI::update() {
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extensible_ui/ui_api.h"
   #endif
 
   ////////////////////////////////////////////
   /////////////// Status Line ////////////////
   ////////////////////////////////////////////
 
-  void MarlinUI::finishstatus(const bool persist) {
+  void MarlinUI::finish_status(const bool persist) {
 
     #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
       UNUSED(persist);
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_ms = millis();
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
       #endif
@@ -1207,33 +1207,33 @@ void MarlinUI::update() {
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
       --pend;
       while (!START_OF_UTF8_CHAR(*pend)) --pend;
     };
 
     // At this point, we have the proper cut point. Use it
     uint8_t maxLen = pend - message;
     strncpy(status_message, message, maxLen);
     status_message[maxLen] = '\0';
 
-    finishstatus(persist);
+    finish_status(persist);
   }
 
   #include <stdarg.h>
 
   void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
     if (level < status_message_level) return;
     status_message_level = level;
     va_list args;
     va_start(args, fmt);
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
-    finishstatus(level > 0);
+    finish_status(level > 0);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
     if (level < 0) level = status_message_level = 0;
     if (level < status_message_level) return;
     status_message_level = level;
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!
@@ -1246,21 +1246,21 @@ void MarlinUI::update() {
     while ((pend - message) > MAX_MESSAGE_LENGTH) {
       --pend;
       while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
     };
 
     // At this point, we have the proper cut point. Use it
     uint8_t maxLen = pend - message;
     strncpy_P(status_message, message, maxLen);
     status_message[maxLen] = '\0';
 
-    finishstatus(level > 0);
+    finish_status(level > 0);
   }
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
     #if HAS_LCD_MENU
       return_to_status();
     #endif
   }
 
   #include "../module/printcounter.h"

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3a2bc3d3c2..44ba8df0a7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -16,21 +16,21 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
-#if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
+#if HAS_SPI_LCD || EITHER(MALYAN_LCD, EXTENSIBLE_UI)
   #include "ultralcd.h"
   MarlinUI ui;
   #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
@@ -99,21 +99,21 @@
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
-#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+#if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
@@ -174,21 +174,21 @@ millis_t next_button_update_ms;
 
   bool MarlinUI::lcd_clicked;
   float move_menu_scale;
 
   bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+  #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
 
     bool MarlinUI::external_control; // = false
 
     void MarlinUI::wait_for_release() {
       while (button_pressed()) safe_delay(50);
       safe_delay(50);
     }
 
   #endif
 
@@ -442,21 +442,21 @@ void MarlinUI::status_screen() {
         }
       }
 
     #endif // PROGRESS_MSG_EXPIRE
 
   #endif // LCD_PROGRESS_BAR
 
   #if HAS_LCD_MENU
 
     if (use_click()) {
-      #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
       init_lcd(); // May revive the LCD if static electricity killed it
       return;
     }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
@@ -631,21 +631,21 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * This function is only called from the main thread.
  */
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
 bool MarlinUI::detected() {
   return
-    #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
+    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
       lcd.LcdDetected() == 1
     #else
       true
     #endif
   ;
 }
 
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
@@ -1001,21 +1001,21 @@ void MarlinUI::update() {
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void MarlinUI::update_buttons() {
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if HAS_DIGITAL_BUTTONS
 
-        #if BUTTON_EXISTS(EN1) || BUTTON_EXISTS(EN2) || BUTTON_EXISTS(ENC) || BUTTON_EXISTS(BACK)
+        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
 
           uint8_t newbutton = 0;
 
           #if BUTTON_EXISTS(EN1)
             if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
           #endif
           #if BUTTON_EXISTS(EN2)
             if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
           #endif
           #if BUTTON_EXISTS(ENC)
@@ -1027,21 +1027,21 @@ void MarlinUI::update() {
 
         #else
 
           constexpr uint8_t newbutton = 0;
 
         #endif
 
         //
         // Directional buttons
         //
-        #if BUTTON_EXISTS(UP) || BUTTON_EXISTS(DWN) || BUTTON_EXISTS(LFT) || BUTTON_EXISTS(RT)
+        #if ANY_BUTTON(UP, DWN, LFT, RT)
 
           const int8_t pulses = (ENCODER_PULSES_PER_STEP) * encoderDirection;
 
           if (false) {
             // for the else-ifs below
           }
           #if BUTTON_EXISTS(UP)
             else if (BUTTON_PRESSED(UP)) {
               encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
@@ -1168,21 +1168,21 @@ void MarlinUI::update() {
       UNUSED(persist);
     #endif
 
     #if ENABLED(LCD_PROGRESS_BAR)
       progress_bar_ms = millis();
       #if PROGRESS_MSG_EXPIRE > 0
         expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
       #endif
     #endif
 
-    #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+    #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
       next_filament_display = millis() + 5000UL; // Show status message for 5s
     #endif
 
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
       status_scroll_offset = 0;
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onStatusChanged(status_message);
     #endif

commit 10c8c034bdc529ced1d0b70b5f8a1079cccc5f66
Author: 7eggert <7eggert@gmx.de>
Date:   Tue Mar 12 00:10:56 2019 +0100

    Allow both encoder and ADC keypad (#13355)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ab973e9e2c..3a2bc3d3c2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1066,29 +1066,29 @@ void MarlinUI::update() {
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = newbutton
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
         ;
-
       #elif HAS_ADC_BUTTONS
-
         buttons = 0;
+      #endif
+
+      #if HAS_ADC_BUTTONS
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
         }
-
       #endif
 
       #if HAS_SHIFT_ENCODER
 
         GET_SHIFT_BUTTON_STATES(
           #if ENABLED(REPRAPWORLD_KEYPAD)
             keypad_buttons
           #else
             buttons
           #endif

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6995fa57d3..ab973e9e2c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -390,34 +390,20 @@ bool MarlinUI::get_blink() {
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 #if ENABLED(LCD_PROGRESS_BAR)
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
     millis_t MarlinUI::expire_status_ms; // = 0
   #endif
 #endif
 
-#if HAS_PRINT_PROGRESS
-  uint8_t MarlinUI::get_progress() {
-    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-      uint8_t &progress = progress_bar_percent;
-    #else
-      uint8_t progress = 0;
-    #endif
-    #if ENABLED(SDSUPPORT)
-      if (IS_SD_PRINTING()) progress = card.percentDone();
-    #endif
-    return progress;
-  }
-#endif
-
 void MarlinUI::status_screen() {
 
   #if HAS_LCD_MENU
     encoder_direction_normal();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
@@ -1314,11 +1300,25 @@ void MarlinUI::update() {
     #if SERVICE_INTERVAL_3 > 0
       else if (print_job_timer.needsService(3)) msg = service3;
     #endif
 
     else
       msg = welcome;
 
     set_status_P(msg, -1);
   }
 
+  #if HAS_PRINT_PROGRESS
+    uint8_t MarlinUI::get_progress() {
+      #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+        uint8_t &progress = progress_bar_percent;
+      #else
+        uint8_t progress = 0;
+      #endif
+      #if ENABLED(SDSUPPORT)
+        if (IS_SD_PRINTING()) progress = card.percentDone();
+      #endif
+      return progress;
+    }
+  #endif
+
 #endif // HAS_SPI_LCD || EXTENSIBLE_UI

commit e56c13670d4ae40339c3a7af61aef3ca08b4128d
Author: revilor <oliver.rossmueller@web.de>
Date:   Tue Feb 12 22:58:56 2019 +0100

    Service interval watchdog (#13105)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 40a0a74cad..6995fa57d3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1279,26 +1279,46 @@ void MarlinUI::update() {
 
   #include "../module/printcounter.h"
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
     static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
     static const char printing[] PROGMEM = MSG_PRINTING;
     static const char welcome[] PROGMEM = WELCOME_MSG;
+    #if SERVICE_INTERVAL_1 > 0
+      static const char service1[] PROGMEM = { "> " SERVICE_NAME_1 "!" };
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      static const char service2[] PROGMEM = { "> " SERVICE_NAME_2 "!" };
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      static const char service3[] PROGMEM = { "> " SERVICE_NAME_3 "!" };
+    #endif
     PGM_P msg;
     if (!IS_SD_PRINTING() && print_job_timer.isPaused())
       msg = paused;
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
       msg = printing;
+
+    #if SERVICE_INTERVAL_1 > 0
+      else if (print_job_timer.needsService(1)) msg = service1;
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      else if (print_job_timer.needsService(2)) msg = service2;
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      else if (print_job_timer.needsService(3)) msg = service3;
+    #endif
+
     else
       msg = welcome;
 
     set_status_P(msg, -1);
   }
 
 #endif // HAS_SPI_LCD || EXTENSIBLE_UI

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 643bdaf182..40a0a74cad 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 24fffb8d93e73cf6030f9dce2440981a9d8f6b1e
Author: Jiri <comps@users.noreply.github.com>
Date:   Thu Jan 24 23:34:40 2019 +0100

    Fix undefined lcd_tmpfan_speed on NO_LCD_MENUS (#13006)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 13dadcc581..643bdaf182 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -253,21 +253,21 @@ void MarlinUI::init() {
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 
-  #if HAS_TRINAMIC
+  #if HAS_TRINAMIC && HAS_LCD_MENU
     init_tmc_section();
   #endif
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;

commit c2cf8ffa8239f25c719b6bb03faf00bb94ddfbb1
Author: lanserge <lanserge@users.noreply.github.com>
Date:   Sun Jan 20 05:43:32 2019 +0000

    Add support for Arduino DUE Shield Kit (#12950)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7d11c9d977..13dadcc581 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -923,47 +923,78 @@ void MarlinUI::update() {
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
 #if HAS_ADC_BUTTONS
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
+  #ifndef ADC_BUTTONS_VALUE_SCALE
+    #define ADC_BUTTONS_VALUE_SCALE       1.0  // for the power voltage equal to the reference voltage
+  #endif
+  #ifndef ADC_BUTTONS_R_PULLUP
+    #define ADC_BUTTONS_R_PULLUP          4.7  // common pull-up resistor in the voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_LEFT_R_PULLDOWN
+    #define ADC_BUTTONS_LEFT_R_PULLDOWN   0.47 // pull-down resistor for LEFT button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_RIGHT_R_PULLDOWN
+    #define ADC_BUTTONS_RIGHT_R_PULLDOWN  4.7  // pull-down resistor for RIGHT button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_UP_R_PULLDOWN
+    #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
+    #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
+    #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
+  #endif
+
+  // Calculate the ADC value for the voltage divider with specified pull-down resistor value
+  #define ADC_BUTTON_VALUE(r)  (int(4096.0 * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP)))
+
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
     { 4000, 4096, 1 + BLEN_KEYPAD_F1     }, // F1
     { 4000, 4096, 1 + BLEN_KEYPAD_F2     }, // F2
     { 4000, 4096, 1 + BLEN_KEYPAD_F3     }, // F3
-    {  300,  500, 1 + BLEN_KEYPAD_LEFT   }, // LEFT
-    { 1900, 2200, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT
-    {  570,  870, 1 + BLEN_KEYPAD_UP     }, // UP
-    { 2670, 2870, 1 + BLEN_KEYPAD_DOWN   }, // DOWN
-    { 1150, 1450, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - 100,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - 100,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + 100, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - 100,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + 100, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - 100,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + 100, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - 100,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + 100, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
   };
 
   uint8_t get_ADC_keyValue(void) {
     if (thermalManager.ADCKey_count >= 16) {
       const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
       thermalManager.current_ADCKey_raw = 0;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < 4000)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
-#endif
+
+#endif // HAS_ADC_BUTTONS
 
 #if HAS_ENCODER_ACTION
 
   #if DISABLED(ADC_KEYPAD) && (ENABLED(REPRAPWORLD_KEYPAD) || !HAS_DIGITAL_BUTTONS)
 
     /**
      * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
      * These values are independent of which pins are used for EN_A and EN_B indications
      * The rotary encoder part is also independent to the chipset used for the LCD
      */

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2c55c9d425..7d11c9d977 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -78,20 +78,24 @@
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BUZZER
   #include "../libs/buzzer.h"
 #endif
 
+#if HAS_TRINAMIC
+  #include "../feature/tmc_util.h"
+#endif
+
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
 #endif
 
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
@@ -248,20 +252,24 @@ void MarlinUI::init() {
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
+
+  #if HAS_TRINAMIC
+    init_tmc_section();
+  #endif
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }

commit e6484d9dab9f9468fd59ce06bae3049f7bb39228
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 8 23:08:20 2019 -0600

    Return to status when SD card is removed

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index af43114872..2c55c9d425 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -702,21 +702,24 @@ void MarlinUI::update() {
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
           set_status_P(PSTR(MSG_SD_INSERTED));
       }
       else {
         card.release();
-        if (old_sd_status != 2) set_status_P(PSTR(MSG_SD_REMOVED));
+        if (old_sd_status != 2) {
+          set_status_P(PSTR(MSG_SD_REMOVED));
+          if (!on_status_screen()) return_to_status();
+        }
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)

commit ba7e35cbab8645497b1feddb29d1d02be5dc763d
Author: Kaushik Vemparala <kaushikny13@gmail.com>
Date:   Fri Jan 4 20:30:08 2019 -0500

    Add LCD option BEEP_ON_FEEDRATE_CHANGE (#12774)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 20eae21ea3..af43114872 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -412,21 +412,22 @@ void MarlinUI::status_screen() {
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
     #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
-      millis_t ms = millis();
+      #define GOT_MS
+      const millis_t ms = millis();
     #endif
 
     // If the message will blink rather than expire...
     #if DISABLED(PROGRESS_MSG_ONCE)
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 
@@ -457,45 +458,54 @@ void MarlinUI::status_screen() {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
       init_lcd(); // May revive the LCD if static electricity killed it
       return;
     }
 
   #endif // HAS_LCD_MENU
 
-  #if ENABLED(ULTIPANEL_FEEDMULTIPLY) && HAS_ENCODER_ACTION
+  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+
+    const int16_t old_frm = feedrate_percentage;
+          int16_t new_frm = old_frm + (int32_t)encoderPosition;
 
-    const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
     // Dead zone at 100% feedrate
-    if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
-      feedrate_percentage = 100;
-      encoderPosition = 0;
-    }
-    else if (feedrate_percentage == 100) {
-      if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
-        feedrate_percentage += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
-        encoderPosition = 0;
-      }
-      else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE)) {
-        feedrate_percentage += (int32_t)encoderPosition + ENCODER_FEEDRATE_DEADZONE;
-        encoderPosition = 0;
-      }
+    if (old_frm == 100) {
+      if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE)
+        new_frm -= ENCODER_FEEDRATE_DEADZONE;
+      else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE))
+        new_frm += ENCODER_FEEDRATE_DEADZONE;
+      else
+        new_frm = old_frm;
     }
-    else {
+    else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
+      new_frm = 100;
+
+    new_frm = constrain(new_frm, 10, 999);
+
+    if (old_frm != new_frm) {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
+      #if ENABLED(BEEP_ON_FEEDRATE_CHANGE)
+        static millis_t next_beep;
+        #ifndef GOT_MS
+          const millis_t ms = millis();
+        #endif
+        if (ELAPSED(ms, next_beep)) {
+          BUZZ(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
+          next_beep = ms + 500UL;
+        }
+      #endif
     }
 
-    feedrate_percentage = constrain(feedrate_percentage, 10, 999);
-
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
 void MarlinUI::kill_screen(PGM_P lcd_msg) {
   init();
   set_alert_status_P(lcd_msg);
   draw_kill_screen();
 }

commit 902d5b0f8ba2f46f30fa063b7d2ab8b6193339cc
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Dec 12 16:21:37 2018 -0700

    Allow ExtUI to use LCD_SET_PROGRESS_MANUALLY (#12628)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f5ba174df0..20eae21ea3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -45,20 +45,24 @@
   #endif
 #elif ENABLED(EXTENSIBLE_UI)
   #define MAX_MESSAGE_LENGTH 63
 #endif
 
 #ifdef MAX_MESSAGE_LENGTH
   uint8_t MarlinUI::status_message_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
+#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+  uint8_t MarlinUI::progress_bar_percent; // = 0
+#endif
+
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
@@ -95,24 +99,20 @@
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
-#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  uint8_t MarlinUI::progress_bar_percent; // = 0
-#endif
-
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
   bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update

commit 2224a4d61aea4c282bc6c7cc56071da0866a1afe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 30 17:09:18 2018 -0600

    Remove AVR-only MARLIN_DEV_MODE code

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6aba70e399..f5ba174df0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -248,26 +248,20 @@ void MarlinUI::init() {
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
-
-  #if ENABLED(MARLIN_DEV_MODE)
-    // Start timer 5 at full speed
-    SET_CS(5, PRESCALER_1);
-    SET_COM(5, A, NORMAL);
-  #endif
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }

commit 03ef2d6c82048564db284bc3965595c561bf5840
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 28 19:28:31 2018 -0600

    Fix "paused" message and M125 called by M25 (#12551)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 640dc74ae7..6aba70e399 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -19,23 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
   MarlinUI ui;
-  #if ENABLED(SDSUPPORT)
-    #include "../sd/cardreader.h"
-  #endif
+  #include "../sd/cardreader.h"
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
 #if HAS_SPI_LCD
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
     #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
       #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
@@ -1236,25 +1234,25 @@ void MarlinUI::update() {
   #include "../module/printcounter.h"
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
     static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
     static const char printing[] PROGMEM = MSG_PRINTING;
     static const char welcome[] PROGMEM = WELCOME_MSG;
     PGM_P msg;
-    if (print_job_timer.isPaused())
+    if (!IS_SD_PRINTING() && print_job_timer.isPaused())
       msg = paused;
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
       msg = printing;
     else
       msg = welcome;
 
     set_status_P(msg, -1);
   }
 
-#endif
+#endif // HAS_SPI_LCD || EXTENSIBLE_UI

commit 4f9ec9ab4518c74e34daa1164eb2587e7e39d7a6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 27 21:15:52 2018 -0600

    Add heating progress bars (#12543)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index afbcdfb4d9..640dc74ae7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -250,20 +250,26 @@ void MarlinUI::init() {
 
   #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
+
+  #if ENABLED(MARLIN_DEV_MODE)
+    // Start timer 5 at full speed
+    SET_CS(5, PRESCALER_1);
+    SET_COM(5, A, NORMAL);
+  #endif
 }
 
 bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }

commit fd2998efd5fb888eb1deb432c6790c3d506060c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 22 06:00:00 2018 -0600

    Revert ADC_KEYPAD direction behavior (#12508)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 850685b9bc..afbcdfb4d9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -298,32 +298,40 @@ bool MarlinUI::get_blink() {
   #endif
 
   bool MarlinUI::handle_keypad() {
 
     #if HAS_ADC_BUTTONS
 
       #define ADC_MIN_KEY_DELAY 100
       if (keypad_buttons) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
-          if (encoderDirection == -1) { // side effect which signals we are inside a menu
-            #if HAS_LCD_MENU
-              if      (RRK(EN_KEYPAD_DOWN))   encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_KEYPAD_UP))     encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+          #if HAS_LCD_MENU
+            if (encoderDirection == -1) {     // ADC_KEYPAD forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
+                   if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
+            }
+            else
+          #endif
+          {
+            #if HAS_LCD_MENU
+                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= ENCODER_PULSES_PER_STEP;
+              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += ENCODER_PULSES_PER_STEP;
+              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+              else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
+            #else
+                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= ENCODER_PULSES_PER_STEP;
+              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += ENCODER_PULSES_PER_STEP;
             #endif
           }
-          else if (RRK(EN_KEYPAD_DOWN))     encoderPosition -= ENCODER_PULSES_PER_STEP;
-          else if (RRK(EN_KEYPAD_UP))       encoderPosition += ENCODER_PULSES_PER_STEP;
-          else if (RRK(EN_KEYPAD_LEFT))     { MenuItem_back::action(); quick_feedback(); }
-          else if (RRK(EN_KEYPAD_RIGHT))    encoderPosition = 0;
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
 
     #else // !HAS_ADC_BUTTONS
 
       static uint8_t keypad_debounce = 0;
 
       if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2

commit c5642a894fb3e9bb16433d40b9ae152bfe204a6f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 20 21:39:30 2018 -0600

    Fix ADC_KEYPAD middle button (#12493)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3df64bae66..850685b9bc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -72,27 +72,27 @@
 #include "../Marlin.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
  #include "../feature/power_loss_recovery.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if DISABLED(LCD_USE_I2C_BUZZER)
+#if HAS_BUZZER
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
-  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+  #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
 #endif
 
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
@@ -241,21 +241,21 @@ void MarlinUI::init() {
 
     #endif
 
   #endif // HAS_SHIFT_ENCODER
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
-  #if HAS_ENCODER_ACTION && ENABLED(LCD_HAS_SLOW_BUTTONS)
+  #if HAS_ENCODER_ACTION && HAS_SLOW_BUTTONS
     slow_buttons = 0;
   #endif
 
   update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
@@ -300,73 +300,73 @@ bool MarlinUI::get_blink() {
   bool MarlinUI::handle_keypad() {
 
     #if HAS_ADC_BUTTONS
 
       #define ADC_MIN_KEY_DELAY 100
       if (keypad_buttons) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           if (encoderDirection == -1) { // side effect which signals we are inside a menu
             #if HAS_LCD_MENU
-              if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
-              else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
+              if      (RRK(EN_KEYPAD_DOWN))   encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_KEYPAD_UP))     encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+              else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             #endif
           }
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition -= ENCODER_PULSES_PER_STEP;
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition += ENCODER_PULSES_PER_STEP;
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))     { MenuItem_back::action(); quick_feedback(); }
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
+          else if (RRK(EN_KEYPAD_DOWN))     encoderPosition -= ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_KEYPAD_UP))       encoderPosition += ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_KEYPAD_LEFT))     { MenuItem_back::action(); quick_feedback(); }
+          else if (RRK(EN_KEYPAD_RIGHT))    encoderPosition = 0;
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
 
     #else // !HAS_ADC_BUTTONS
 
       static uint8_t keypad_debounce = 0;
 
-      if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
-              | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
-              | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
-              | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
+      if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2
+              | EN_KEYPAD_F3    | EN_KEYPAD_DOWN
+              | EN_KEYPAD_RIGHT | EN_KEYPAD_MIDDLE
+              | EN_KEYPAD_UP    | EN_KEYPAD_LEFT )
       ) {
         if (keypad_debounce > 0) keypad_debounce--;
       }
       else if (!keypad_debounce) {
         keypad_debounce = 2;
 
         const bool homed = all_axes_homed();
 
         #if HAS_LCD_MENU
 
-          if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  goto_screen(menu_move);
+          if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
 
           #if DISABLED(DELTA) && Z_HOME_DIR == -1
-            if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
+            if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
           #endif
 
           if (homed) {
             #if ENABLED(DELTA) || Z_HOME_DIR != -1
-              if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+              if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
             #endif
-            if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
-            if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
-            if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
-            if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
-            if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
+            if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+            if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+            if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+            if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+            if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
           }
 
         #endif // HAS_LCD_MENU
 
-        if (!homed && RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
+        if (!homed && RRK(EN_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
         return true;
       }
 
     #endif // !ADC_KEYPAD
 
     return false;
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
@@ -659,21 +659,21 @@ void MarlinUI::update() {
     if (!external_control && button_pressed()) {
       if (!wait_for_unclick) {                        // If not waiting for a debounce release:
         wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
         wait_for_user = false;                        //  - Any click clears wait for user
         quick_feedback();                             //  - Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
-    #if BUTTON_EXISTS(BACK)
+    #if HAS_DIGITAL_BUTTONS && BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED()) {
         quick_feedback();
         goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
@@ -710,21 +710,21 @@ void MarlinUI::update() {
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();
     #endif
 
     #if HAS_ENCODER_ACTION
 
-      #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+      #if HAS_SLOW_BUTTONS
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
       #if ENABLED(REPRAPWORLD_KEYPAD)
 
         if (handle_keypad()) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
@@ -898,28 +898,28 @@ void MarlinUI::update() {
 
 #if HAS_ADC_BUTTONS
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
-    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F1     }, // F1
-    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F2     }, // F2
-    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F3     }, // F3
-    {  300,  500, 1 + BLEN_REPRAPWORLD_KEYPAD_LEFT   }, // LEFT
-    { 1900, 2200, 1 + BLEN_REPRAPWORLD_KEYPAD_RIGHT  }, // RIGHT
-    {  570,  870, 1 + BLEN_REPRAPWORLD_KEYPAD_UP     }, // UP
-    { 2670, 2870, 1 + BLEN_REPRAPWORLD_KEYPAD_DOWN   }, // DOWN
-    { 1150, 1450, 1 + BLEN_REPRAPWORLD_KEYPAD_MIDDLE }, // ENTER
+    { 4000, 4096, 1 + BLEN_KEYPAD_F1     }, // F1
+    { 4000, 4096, 1 + BLEN_KEYPAD_F2     }, // F2
+    { 4000, 4096, 1 + BLEN_KEYPAD_F3     }, // F3
+    {  300,  500, 1 + BLEN_KEYPAD_LEFT   }, // LEFT
+    { 1900, 2200, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT
+    {  570,  870, 1 + BLEN_KEYPAD_UP     }, // UP
+    { 2670, 2870, 1 + BLEN_KEYPAD_DOWN   }, // DOWN
+    { 1150, 1450, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER
   };
 
   uint8_t get_ADC_keyValue(void) {
     if (thermalManager.ADCKey_count >= 16) {
       const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
       thermalManager.current_ADCKey_raw = 0;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < 4000)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
@@ -1018,21 +1018,21 @@ void MarlinUI::update() {
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // UP || DWN || LFT || RT
 
         buttons = newbutton
-          #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+          #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
         ;
 
       #elif HAS_ADC_BUTTONS
 
         buttons = 0;
         if (keypad_buttons == 0) {
           const uint8_t b = get_ADC_keyValue();
           if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
@@ -1080,36 +1080,36 @@ void MarlinUI::update() {
             ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
           #endif
           encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
         }
         lastEncoderBits = enc;
       }
 
     #endif // HAS_ENCODER_WHEEL
   }
 
-  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+  #if HAS_SLOW_BUTTONS
 
     uint8_t MarlinUI::read_slow_buttons() {
       #if ENABLED(LCD_I2C_TYPE_MCP23017)
         // Reading these buttons this is likely to be too slow to call inside interrupt context
         // so they are called during normal lcd_update
         uint8_t slow_bits = lcd.readButtons() << B_I2C_BTN_OFFSET;
         #if ENABLED(LCD_I2C_VIKI)
           if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
             slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
         #endif // LCD_I2C_VIKI
         return slow_bits;
       #endif // LCD_I2C_TYPE_MCP23017
     }
 
-  #endif // LCD_HAS_SLOW_BUTTONS
+  #endif
 
 #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_SPI_LCD
 
 #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extensible_ui/ui_api.h"
   #endif

commit 4def8b3b5e01498d0a4358898784b08b886c3202
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 20 07:36:37 2018 -0600

    Expanded options for _Statusscreen.h (#12455)
    
    See the PR for full details. The updated system will be documented on the website in the near future.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8d11dabaec..3df64bae66 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -833,27 +833,27 @@ void MarlinUI::update() {
         #if ENABLED(LIGHTWEIGHT_UI)
           const bool in_status = on_status_screen(),
                      do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) status_screen();
         #else
           constexpr bool do_u8g_loop = true;
         #endif
 
         if (do_u8g_loop) {
-          if (!drawing_screen) {                        // If not already drawing pages
-            u8g.firstPage();                            // Start the first page
-            drawing_screen = first_page = true;         // Flag as drawing pages
+          if (!drawing_screen) {                // If not already drawing pages
+            u8g.firstPage();                    // Start the first page
+            drawing_screen = first_page = true; // Flag as drawing pages
           }
-          set_font(FONT_MENU);                       // Setup font for every page draw
-          u8g.setColorIndex(1);                         // And reset the color
-          run_current_screen();                         // Draw and process the current screen
+          set_font(FONT_MENU);                  // Setup font for every page draw
+          u8g.setColorIndex(1);                 // And reset the color
+          run_current_screen();                 // Draw and process the current screen
           first_page = false;
 
           // The screen handler can clear drawing_screen for an action that changes the screen.
           // If still drawing and there's another page, update max-time and return now.
           // The nextPage will already be set up on the next call.
           if (drawing_screen && (drawing_screen = u8g.nextPage())) {
             NOLESS(max_display_update_time, millis() - ms);
             return;
           }
         }

commit 817a37169a0ef397a82209d981d59db6b7f75146
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 20 06:44:11 2018 -0600

    Apply/unapply const here and there

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8cecbd9182..8d11dabaec 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -123,21 +123,21 @@ millis_t next_button_update_ms;
 #if HAS_LCD_MENU
   #include "menu/menu.h"
   #include "../sd/cardreader.h"
 
   #if ENABLED(SDSUPPORT)
 
     #if ENABLED(SCROLL_LONG_FILENAMES)
       uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
     #endif
 
-    const char * const MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+    const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
       const char *outstr = theCard.longest_filename();
       if (theCard.longFilename[0]) {
         #if ENABLED(SCROLL_LONG_FILENAMES)
           if (doScroll) {
             for (uint8_t l = FILENAME_LENGTH; l--;)
               hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
             static uint8_t filename_scroll_hash;
             if (filename_scroll_hash != hash) {                              // If the hash changed...
               filename_scroll_hash = hash;                                   // Save the new hash
               filename_scroll_max = MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit

commit 50ee747787d395b8d0312a0b43369a160c02e8fc
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Nov 19 23:02:13 2018 -0700

    Fix compilation errors. Followup to #12439 (#12481)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8fbc75774b..8cecbd9182 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -22,26 +22,45 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
   MarlinUI ui;
   #if ENABLED(SDSUPPORT)
     #include "../sd/cardreader.h"
   #endif
-
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 #endif
 
+#if HAS_SPI_LCD
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    uint8_t MarlinUI::status_scroll_offset; // = 0
+    #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
+      #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
+    #else
+      #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
+    #endif
+  #else
+    #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
+  #endif
+#elif ENABLED(EXTENSIBLE_UI)
+  #define MAX_MESSAGE_LENGTH 63
+#endif
+
+#ifdef MAX_MESSAGE_LENGTH
+  uint8_t MarlinUI::status_message_level; // = 0
+  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+#endif
+
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
@@ -68,38 +87,20 @@
   volatile uint8_t MarlinUI::buttons;
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
 #endif
 
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
 
-#if ENABLED(STATUS_MESSAGE_SCROLLING)
-  uint8_t MarlinUI::status_scroll_offset; // = 0
-  #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
-    #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
-  #else
-    #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
-  #endif
-#elif ENABLED(EXTENSIBLE_UI)
-  #define MAX_MESSAGE_LENGTH 63
-#else
-  #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
-#endif
-
-#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
-  uint8_t MarlinUI::status_message_level; // = 0
-  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
-#endif
-
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 

commit 1f93d2bcf70f1cbe63ac9f21892543663723c8f3
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Nov 19 03:39:49 2018 +0100

    Fix LCD compile error, etc. (#12472)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4650b759c2..8fbc75774b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -200,52 +200,54 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
-    #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
-      SET_OUTPUT(SHIFT_CLK);
-      OUT_WRITE(SHIFT_LD, HIGH);
-      SET_INPUT_PULLUP(SHIFT_OUT);
-    #endif
-
     #if BUTTON_EXISTS(UP)
       SET_INPUT(BTN_UP);
     #endif
     #if BUTTON_EXISTS(DWN)
       SET_INPUT(BTN_DWN);
     #endif
     #if BUTTON_EXISTS(LFT)
       SET_INPUT(BTN_LFT);
     #endif
     #if BUTTON_EXISTS(RT)
       SET_INPUT(BTN_RT);
     #endif
 
-  #else // !HAS_DIGITAL_BUTTONS
+  #endif // !HAS_DIGITAL_BUTTONS
+
+  #if HAS_SHIFT_ENCODER
 
     #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+
       SET_OUTPUT(SR_DATA_PIN);
       SET_OUTPUT(SR_CLK_PIN);
+
     #elif defined(SHIFT_CLK)
+
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
-      OUT_WRITE(SHIFT_EN, LOW);
+      #if defined(SHIFT_EN) && SHIFT_EN >= 0
+        OUT_WRITE(SHIFT_EN, LOW);
+      #endif
       SET_INPUT_PULLUP(SHIFT_OUT);
-    #endif // SR_LCD_2W_NL
 
-  #endif // !HAS_DIGITAL_BUTTONS
+    #endif
+
+  #endif // HAS_SHIFT_ENCODER
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
   #if HAS_ENCODER_ACTION && ENABLED(LCD_HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
@@ -266,66 +268,67 @@ bool MarlinUI::get_blink() {
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
 #if ENABLED(REPRAPWORLD_KEYPAD) && HAS_ENCODER_ACTION
 
-  volatile uint8_t MarlinUI::buttons_reprapworld_keypad;
+  volatile uint8_t MarlinUI::keypad_buttons;
 
-  #if DISABLED(ADC_KEYPAD) && HAS_LCD_MENU
+  #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
       move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
       encoderPosition = dir;
       switch (axis) {
         case X_AXIS: lcd_move_x(); break;
         case Y_AXIS: lcd_move_y(); break;
         case Z_AXIS: lcd_move_z();
         default: break;
       }
     }
 
   #endif
 
   bool MarlinUI::handle_keypad() {
 
-    #if ENABLED(ADC_KEYPAD)
+    #if HAS_ADC_BUTTONS
 
       #define ADC_MIN_KEY_DELAY 100
-      if (buttons_reprapworld_keypad) {
+      if (keypad_buttons) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           if (encoderDirection == -1) { // side effect which signals we are inside a menu
             #if HAS_LCD_MENU
               if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             #endif
           }
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
-          else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition -= ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition += ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))     { MenuItem_back::action(); quick_feedback(); }
           else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
 
-    #else // !ADC_KEYPAD
+    #else // !HAS_ADC_BUTTONS
 
       static uint8_t keypad_debounce = 0;
 
       if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
               | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
               | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
               | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
       ) {
         if (keypad_debounce > 0) keypad_debounce--;
       }
@@ -401,21 +404,23 @@ void MarlinUI::status_screen() {
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
-    millis_t ms = millis();
+    #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
+      millis_t ms = millis();
+    #endif
 
     // If the message will blink rather than expire...
     #if DISABLED(PROGRESS_MSG_ONCE)
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 
       // Handle message expire
@@ -811,22 +816,22 @@ void MarlinUI::update() {
           refresh(LCDVIEW_NONE);
           break;
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:
           refresh(LCDVIEW_REDRAW_NOW);
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
-      #if ENABLED(ADC_KEYPAD)
-        buttons_reprapworld_keypad = 0;
+      #if HAS_ADC_BUTTONS
+        keypad_buttons = 0;
       #endif
 
       #if HAS_GRAPHICAL_LCD
 
         #if ENABLED(LIGHTWEIGHT_UI)
           const bool in_status = on_status_screen(),
                      do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) status_screen();
         #else
@@ -883,21 +888,21 @@ void MarlinUI::update() {
         refresh(LCDVIEW_NONE);
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
-#if ENABLED(ADC_KEYPAD)
+#if HAS_ADC_BUTTONS
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
     { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F1     }, // F1
     { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F2     }, // F2
@@ -946,44 +951,52 @@ void MarlinUI::update() {
       } \
       DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
 
   #endif
 
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void MarlinUI::update_buttons() {
-    static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if HAS_DIGITAL_BUTTONS
-        uint8_t newbutton = 0;
 
-        #if BUTTON_EXISTS(EN1)
-          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-        #endif
-        #if BUTTON_EXISTS(EN2)
-          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-        #endif
-        #if BUTTON_EXISTS(ENC)
-          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-        #endif
-        #if BUTTON_EXISTS(BACK)
-          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+        #if BUTTON_EXISTS(EN1) || BUTTON_EXISTS(EN2) || BUTTON_EXISTS(ENC) || BUTTON_EXISTS(BACK)
+
+          uint8_t newbutton = 0;
+
+          #if BUTTON_EXISTS(EN1)
+            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+          #endif
+          #if BUTTON_EXISTS(EN2)
+            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+          #endif
+          #if BUTTON_EXISTS(ENC)
+            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+          #endif
+          #if BUTTON_EXISTS(BACK)
+            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+          #endif
+
+        #else
+
+          constexpr uint8_t newbutton = 0;
+
         #endif
 
         //
         // Directional buttons
         //
-        #if LCD_HAS_DIRECTIONAL_BUTTONS
+        #if BUTTON_EXISTS(UP) || BUTTON_EXISTS(DWN) || BUTTON_EXISTS(LFT) || BUTTON_EXISTS(RT)
 
           const int8_t pulses = (ENCODER_PULSES_PER_STEP) * encoderDirection;
 
           if (false) {
             // for the else-ifs below
           }
           #if BUTTON_EXISTS(UP)
             else if (BUTTON_PRESSED(UP)) {
               encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
@@ -1001,54 +1014,54 @@ void MarlinUI::update() {
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
           #endif
 
-        #endif // LCD_HAS_DIRECTIONAL_BUTTONS
+        #endif // UP || DWN || LFT || RT
 
-        #if ENABLED(ADC_KEYPAD)
+        buttons = newbutton
+          #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+            | slow_buttons
+          #endif
+        ;
 
-          buttons = 0;
-          if (buttons_reprapworld_keypad == 0) {
-            uint8_t newbutton_reprapworld_keypad = get_ADC_keyValue();
-            if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
-              buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
-          }
+      #elif HAS_ADC_BUTTONS
 
-        #else
+        buttons = 0;
+        if (keypad_buttons == 0) {
+          const uint8_t b = get_ADC_keyValue();
+          if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
+        }
 
-          buttons = newbutton
-            #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-              | slow_buttons
-            #endif
-          ;
+      #endif
+
+      #if HAS_SHIFT_ENCODER
 
+        GET_SHIFT_BUTTON_STATES(
           #if ENABLED(REPRAPWORLD_KEYPAD)
-            GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
+            keypad_buttons
+          #else
+            buttons
           #endif
-
-        #endif
-
-      #else // !HAS_DIGITAL_BUTTONS
-
-        GET_SHIFT_BUTTON_STATES(buttons);
+        );
 
       #endif
 
     } // next_button_update_ms
 
     #if HAS_ENCODER_WHEEL
+      static uint8_t lastEncoderBits;
 
       #define encrot0 0
       #define encrot1 2
       #define encrot2 3
       #define encrot3 1
 
       // Manage encoder rotation
       #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 
       uint8_t enc = 0;

commit 7f225b94210c02b5939652b5068cccaca1488b8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 18 01:08:57 2018 -0600

    Fix MAX_MESSAGE_LENGTH

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9bb7c06720..4650b759c2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -22,27 +22,24 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
   MarlinUI ui;
   #if ENABLED(SDSUPPORT)
     #include "../sd/cardreader.h"
   #endif
+
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
-
-  #define MAX_MESSAGE_LENGTH 63
-  uint8_t MarlinUI::status_message_level; // = 0
-  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
@@ -78,24 +75,31 @@
   uint8_t lcd_sd_status;
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   uint8_t MarlinUI::status_scroll_offset; // = 0
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
+#elif ENABLED(EXTENSIBLE_UI)
+  #define MAX_MESSAGE_LENGTH 63
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
+#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+  uint8_t MarlinUI::status_message_level; // = 0
+  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+#endif
+
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 

commit 06674a321a128b563ea25ec107267bfba79cc8dc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 18 00:33:50 2018 -0600

    Remove extra include

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 611bdfed18..9bb7c06720 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -18,23 +18,20 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
-  #if ENABLED(SDSUPPORT)
-    #include "../sd/cardreader.h"
-  #endif
   MarlinUI ui;
   #if ENABLED(SDSUPPORT)
     #include "../sd/cardreader.h"
   #endif
   #if ENABLED(EXTENSIBLE_UI)
     #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
   #endif
 
   #define MAX_MESSAGE_LENGTH 63
   uint8_t MarlinUI::status_message_level; // = 0

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0f290eac25..611bdfed18 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -22,20 +22,30 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
   #if ENABLED(SDSUPPORT)
     #include "../sd/cardreader.h"
   #endif
   MarlinUI ui;
+  #if ENABLED(SDSUPPORT)
+    #include "../sd/cardreader.h"
+  #endif
+  #if ENABLED(EXTENSIBLE_UI)
+    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80u)
+  #endif
+
+  #define MAX_MESSAGE_LENGTH 63
+  uint8_t MarlinUI::status_message_level; // = 0
+  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"
 
@@ -79,23 +89,21 @@
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
   bool MarlinUI::defer_return_to_status;
 #endif
 
-char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
-uint8_t MarlinUI::status_message_level; // = 0
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t MarlinUI::progress_bar_percent; // = 0
 #endif
 
 millis_t next_button_update_ms;
@@ -468,21 +476,21 @@ void MarlinUI::status_screen() {
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
 void MarlinUI::kill_screen(PGM_P lcd_msg) {
   init();
-  setalertstatusPGM(lcd_msg);
+  set_alert_status_P(lcd_msg);
   draw_kill_screen();
 }
 
 void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     refresh();
   #endif
 
   #if HAS_ENCODER_ACTION
@@ -667,25 +675,25 @@ void MarlinUI::update() {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
-          setstatusPGM(PSTR(MSG_SD_INSERTED));
+          set_status_P(PSTR(MSG_SD_INSERTED));
       }
       else {
         card.release();
-        if (old_sd_status != 2) setstatusPGM(PSTR(MSG_SD_REMOVED));
+        if (old_sd_status != 2) set_status_P(PSTR(MSG_SD_REMOVED));
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
@@ -1076,140 +1084,148 @@ void MarlinUI::update() {
             slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
         #endif // LCD_I2C_VIKI
         return slow_bits;
       #endif // LCD_I2C_TYPE_MCP23017
     }
 
   #endif // LCD_HAS_SLOW_BUTTONS
 
 #endif // HAS_ENCODER_ACTION
 
-////////////////////////////////////////////
-/////////////// Status Line ////////////////
-////////////////////////////////////////////
+#endif // HAS_SPI_LCD
 
-void MarlinUI::finishstatus(const bool persist) {
+#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
 
-  #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
-    UNUSED(persist);
+  #if ENABLED(EXTENSIBLE_UI)
+    #include "extensible_ui/ui_api.h"
   #endif
 
-  #if ENABLED(LCD_PROGRESS_BAR)
-    progress_bar_ms = millis();
-    #if PROGRESS_MSG_EXPIRE > 0
-      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
+  ////////////////////////////////////////////
+  /////////////// Status Line ////////////////
+  ////////////////////////////////////////////
+
+  void MarlinUI::finishstatus(const bool persist) {
+
+    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
+      UNUSED(persist);
     #endif
-  #endif
 
-  #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-    next_filament_display = millis() + 5000UL; // Show status message for 5s
-  #endif
+    #if ENABLED(LCD_PROGRESS_BAR)
+      progress_bar_ms = millis();
+      #if PROGRESS_MSG_EXPIRE > 0
+        expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
+      #endif
+    #endif
 
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    status_scroll_offset = 0;
-  #endif
+    #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+      next_filament_display = millis() + 5000UL; // Show status message for 5s
+    #endif
 
-  refresh();
-}
+    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+      status_scroll_offset = 0;
+    #endif
 
-bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
+    #if ENABLED(EXTENSIBLE_UI)
+      ExtUI::onStatusChanged(status_message);
+    #endif
 
-void MarlinUI::setstatus(const char * const message, const bool persist) {
-  if (status_message_level > 0) return;
+    refresh();
+  }
 
-  // Here we have a problem. The message is encoded in UTF8, so
-  // arbitrarily cutting it will be a problem. We MUST be sure
-  // that there is no cutting in the middle of a multibyte character!
+  bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
-  // Get a pointer to the null terminator
-  const char* pend = message + strlen(message);
+  void MarlinUI::set_status(const char * const message, const bool persist) {
+    if (status_message_level > 0) return;
 
-  //  If length of supplied UTF8 string is greater than
-  // our buffer size, start cutting whole UTF8 chars
-  while ((pend - message) > MAX_MESSAGE_LENGTH) {
-    --pend;
-    while (!START_OF_UTF8_CHAR(*pend)) --pend;
-  };
+    // Here we have a problem. The message is encoded in UTF8, so
+    // arbitrarily cutting it will be a problem. We MUST be sure
+    // that there is no cutting in the middle of a multibyte character!
 
-  // At this point, we have the proper cut point. Use it
-  uint8_t maxLen = pend - message;
-  strncpy(status_message, message, maxLen);
-  status_message[maxLen] = '\0';
+    // Get a pointer to the null terminator
+    const char* pend = message + strlen(message);
 
-  finishstatus(persist);
-}
+    //  If length of supplied UTF8 string is greater than
+    // our buffer size, start cutting whole UTF8 chars
+    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+      --pend;
+      while (!START_OF_UTF8_CHAR(*pend)) --pend;
+    };
 
-#include <stdarg.h>
+    // At this point, we have the proper cut point. Use it
+    uint8_t maxLen = pend - message;
+    strncpy(status_message, message, maxLen);
+    status_message[maxLen] = '\0';
 
-void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-  if (level < status_message_level) return;
-  status_message_level = level;
-  va_list args;
-  va_start(args, fmt);
-  vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
-  va_end(args);
-  finishstatus(level > 0);
-}
+    finishstatus(persist);
+  }
 
-void MarlinUI::setstatusPGM(PGM_P const message, int8_t level) {
-  if (level < 0) level = status_message_level = 0;
-  if (level < status_message_level) return;
-  status_message_level = level;
+  #include <stdarg.h>
 
-  // Here we have a problem. The message is encoded in UTF8, so
-  // arbitrarily cutting it will be a problem. We MUST be sure
-  // that there is no cutting in the middle of a multibyte character!
+  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+    if (level < status_message_level) return;
+    status_message_level = level;
+    va_list args;
+    va_start(args, fmt);
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+    va_end(args);
+    finishstatus(level > 0);
+  }
 
-  // Get a pointer to the null terminator
-  PGM_P pend = message + strlen_P(message);
+  void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
+    if (level < 0) level = status_message_level = 0;
+    if (level < status_message_level) return;
+    status_message_level = level;
 
-  //  If length of supplied UTF8 string is greater than
-  // our buffer size, start cutting whole UTF8 chars
-  while ((pend - message) > MAX_MESSAGE_LENGTH) {
-    --pend;
-    while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
-  };
+    // Here we have a problem. The message is encoded in UTF8, so
+    // arbitrarily cutting it will be a problem. We MUST be sure
+    // that there is no cutting in the middle of a multibyte character!
 
-  // At this point, we have the proper cut point. Use it
-  uint8_t maxLen = pend - message;
-  strncpy_P(status_message, message, maxLen);
-  status_message[maxLen] = '\0';
+    // Get a pointer to the null terminator
+    PGM_P pend = message + strlen_P(message);
 
-  finishstatus(level > 0);
-}
+    //  If length of supplied UTF8 string is greater than
+    // our buffer size, start cutting whole UTF8 chars
+    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+      --pend;
+      while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
+    };
 
-void MarlinUI::setalertstatusPGM(PGM_P const message) {
-  setstatusPGM(message, 1);
-  #if HAS_LCD_MENU
-    return_to_status();
-  #endif
-}
+    // At this point, we have the proper cut point. Use it
+    uint8_t maxLen = pend - message;
+    strncpy_P(status_message, message, maxLen);
+    status_message[maxLen] = '\0';
 
-#endif // HAS_SPI_LCD
+    finishstatus(level > 0);
+  }
 
-#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+  void MarlinUI::set_alert_status_P(PGM_P const message) {
+    set_status_P(message, 1);
+    #if HAS_LCD_MENU
+      return_to_status();
+    #endif
+  }
 
   #include "../module/printcounter.h"
 
   /**
    * Reset the status message
    */
   void MarlinUI::reset_status() {
     static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
     static const char printing[] PROGMEM = MSG_PRINTING;
     static const char welcome[] PROGMEM = WELCOME_MSG;
     PGM_P msg;
     if (print_job_timer.isPaused())
       msg = paused;
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
-        return setstatus(card.longest_filename(), true);
+        return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
       msg = printing;
     else
       msg = welcome;
 
-    setstatusPGM(msg, -1);
+    set_status_P(msg, -1);
   }
 
 #endif

commit 93e958f6958b85476eb60d9966f8299aea8464c4
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Nov 18 04:21:30 2018 +0100

    Fix compile error with ZONESTAR_LCD+NO_LCD_MENUS (#12466)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c100781087..0f290eac25 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -179,21 +179,21 @@ millis_t next_button_update_ms;
     }
 
   #endif
 
 #endif
 
 void MarlinUI::init() {
 
   init_lcd();
 
-  #if HAS_DIGITAL_ENCODER
+  #if HAS_DIGITAL_BUTTONS
 
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
@@ -210,33 +210,33 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(DWN)
       SET_INPUT(BTN_DWN);
     #endif
     #if BUTTON_EXISTS(LFT)
       SET_INPUT(BTN_LFT);
     #endif
     #if BUTTON_EXISTS(RT)
       SET_INPUT(BTN_RT);
     #endif
 
-  #else // !HAS_DIGITAL_ENCODER
+  #else // !HAS_DIGITAL_BUTTONS
 
     #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
       SET_OUTPUT(SR_DATA_PIN);
       SET_OUTPUT(SR_CLK_PIN);
     #elif defined(SHIFT_CLK)
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
       OUT_WRITE(SHIFT_EN, LOW);
       SET_INPUT_PULLUP(SHIFT_OUT);
     #endif // SR_LCD_2W_NL
 
-  #endif // !HAS_DIGITAL_ENCODER
+  #endif // !HAS_DIGITAL_BUTTONS
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
   #if HAS_ENCODER_ACTION && ENABLED(LCD_HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
@@ -255,21 +255,21 @@ bool MarlinUI::get_blink() {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
-#if ENABLED(REPRAPWORLD_KEYPAD)
+#if ENABLED(REPRAPWORLD_KEYPAD) && HAS_ENCODER_ACTION
 
   volatile uint8_t MarlinUI::buttons_reprapworld_keypad;
 
   #if DISABLED(ADC_KEYPAD) && HAS_LCD_MENU
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
@@ -288,22 +288,22 @@ bool MarlinUI::get_blink() {
   bool MarlinUI::handle_keypad() {
 
     #if ENABLED(ADC_KEYPAD)
 
       #define ADC_MIN_KEY_DELAY 100
       if (buttons_reprapworld_keypad) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           if (encoderDirection == -1) { // side effect which signals we are inside a menu
             #if HAS_LCD_MENU
-              if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             #endif
           }
           else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
           else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
           else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
@@ -436,21 +436,21 @@ void MarlinUI::status_screen() {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
       goto_screen(menu_main);
       init_lcd(); // May revive the LCD if static electricity killed it
       return;
     }
 
   #endif // HAS_LCD_MENU
 
-  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+  #if ENABLED(ULTIPANEL_FEEDMULTIPLY) && HAS_ENCODER_ACTION
 
     const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
     // Dead zone at 100% feedrate
     if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
       feedrate_percentage = 100;
       encoderPosition = 0;
     }
     else if (feedrate_percentage == 100) {
       if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
         feedrate_percentage += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
@@ -701,31 +701,26 @@ void MarlinUI::update() {
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
       #if ENABLED(REPRAPWORLD_KEYPAD)
 
-        if (
-          #if ENABLED(ADC_KEYPAD)
-            handle_keypad()
-          #else
-            handle_keypad()
-          #endif
-        ) {
+        if (handle_keypad()) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
+
       #endif
 
       const float abs_diff = ABS(encoderDiff);
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
@@ -916,58 +911,51 @@ void MarlinUI::update() {
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 #endif
 
 #if HAS_ENCODER_ACTION
 
-  #if DISABLED(ADC_KEYPAD) && (ENABLED(REPRAPWORLD_KEYPAD) || !HAS_DIGITAL_ENCODER)
+  #if DISABLED(ADC_KEYPAD) && (ENABLED(REPRAPWORLD_KEYPAD) || !HAS_DIGITAL_BUTTONS)
 
     /**
      * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
      * These values are independent of which pins are used for EN_A and EN_B indications
      * The rotary encoder part is also independent to the chipset used for the LCD
      */
     #define GET_SHIFT_BUTTON_STATES(DST) \
       uint8_t new_##DST = 0; \
       WRITE(SHIFT_LD, LOW); \
       WRITE(SHIFT_LD, HIGH); \
       for (int8_t i = 0; i < 8; i++) { \
         new_##DST >>= 1; \
         if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
         WRITE(SHIFT_CLK, HIGH); \
         WRITE(SHIFT_CLK, LOW); \
       } \
       DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
 
   #endif
 
-  #if defined(EN_A) && defined(EN_B)
-    #define encrot0 0
-    #define encrot1 2
-    #define encrot2 3
-    #define encrot3 1
-  #endif
-
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void MarlinUI::update_buttons() {
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
-      #if HAS_DIGITAL_ENCODER
+      #if HAS_DIGITAL_BUTTONS
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
@@ -1029,49 +1017,58 @@ void MarlinUI::update() {
               | slow_buttons
             #endif
           ;
 
           #if ENABLED(REPRAPWORLD_KEYPAD)
             GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
           #endif
 
         #endif
 
-      #else // !HAS_DIGITAL_ENCODER
+      #else // !HAS_DIGITAL_BUTTONS
 
         GET_SHIFT_BUTTON_STATES(buttons);
 
       #endif
 
     } // next_button_update_ms
 
-    // Manage encoder rotation
-    #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
-
-    uint8_t enc = 0;
-    if (buttons & EN_A) enc |= B01;
-    if (buttons & EN_B) enc |= B10;
-    if (enc != lastEncoderBits) {
-      switch (enc) {
-        case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
-        case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
-        case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
-        case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
-      }
-      if (external_control) {
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
-        #endif
-        encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
+    #if HAS_ENCODER_WHEEL
+
+      #define encrot0 0
+      #define encrot1 2
+      #define encrot2 3
+      #define encrot3 1
+
+      // Manage encoder rotation
+      #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
+
+      uint8_t enc = 0;
+      if (buttons & EN_A) enc |= B01;
+      if (buttons & EN_B) enc |= B10;
+      if (enc != lastEncoderBits) {
+        switch (enc) {
+          case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
+          case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
+          case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
+          case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
+        }
+        if (external_control) {
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
+          #endif
+          encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
+        }
+        lastEncoderBits = enc;
       }
-      lastEncoderBits = enc;
-    }
+
+    #endif // HAS_ENCODER_WHEEL
   }
 
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
 
     uint8_t MarlinUI::read_slow_buttons() {
       #if ENABLED(LCD_I2C_TYPE_MCP23017)
         // Reading these buttons this is likely to be too slow to call inside interrupt context
         // so they are called during normal lcd_update
         uint8_t slow_bits = lcd.readButtons() << B_I2C_BTN_OFFSET;
         #if ENABLED(LCD_I2C_VIKI)

commit 3e9ffaddb679c6eadd37123fd2d6e1ec0bee4e44
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 21:44:48 2018 -0600

    Consolidate, optimize some LCD menu code (#12450)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5150264bc5..c100781087 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -105,23 +105,51 @@ millis_t next_button_update_ms;
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
 #if HAS_LCD_MENU
   #include "menu/menu.h"
+  #include "../sd/cardreader.h"
+
+  #if ENABLED(SDSUPPORT)
+
+    #if ENABLED(SCROLL_LONG_FILENAMES)
+      uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+    #endif
+
+    const char * const MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+      const char *outstr = theCard.longest_filename();
+      if (theCard.longFilename[0]) {
+        #if ENABLED(SCROLL_LONG_FILENAMES)
+          if (doScroll) {
+            for (uint8_t l = FILENAME_LENGTH; l--;)
+              hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
+            static uint8_t filename_scroll_hash;
+            if (filename_scroll_hash != hash) {                              // If the hash changed...
+              filename_scroll_hash = hash;                                   // Save the new hash
+              filename_scroll_max = MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
+              filename_scroll_pos = 0;                                       // Reset scroll to the start
+              lcd_status_update_delay = 8;                                   // Don't scroll right away
+            }
+            outstr += filename_scroll_pos;
+          }
+        #else
+          theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
+        #endif
+      }
+      return outstr;
+    }
 
-  #if ENABLED(SDSUPPORT) && ENABLED(SCROLL_LONG_FILENAMES)
-    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
   #endif
 
   screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
     bool MarlinUI::encoderRateMultiplierEnabled;
     millis_t MarlinUI::lastEncoderMovementMillis = 0;
     void MarlinUI::enable_encoder_multiplier(const bool onoff) {
       encoderRateMultiplierEnabled = onoff;
       lastEncoderMovementMillis = 0;

commit d97e31db4c2b8b27ab1c6fbbe05f11aa9d5e94e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 20:47:07 2018 -0600

    Optimize Power-Loss Recovery (#12440)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8baab7e912..5150264bc5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -652,27 +652,20 @@ void MarlinUI::update() {
         card.release();
         if (old_sd_status != 2) setstatusPGM(PSTR(MSG_SD_REMOVED));
       }
 
       refresh();
       init_lcd(); // May revive the LCD if static electricity killed it
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
-      goto_screen(menu_job_recovery);
-      job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
-    }
-  #endif
-
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9ee19730cf..8baab7e912 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -262,21 +262,21 @@ bool MarlinUI::get_blink() {
     #if ENABLED(ADC_KEYPAD)
 
       #define ADC_MIN_KEY_DELAY 100
       if (buttons_reprapworld_keypad) {
         #if HAS_ENCODER_ACTION
           refresh(LCDVIEW_REDRAW_NOW);
           if (encoderDirection == -1) { // side effect which signals we are inside a menu
             #if HAS_LCD_MENU
               if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
               else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); quick_feedback(); }
+              else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
               else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
             #endif
           }
           else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
           else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
           else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }

commit f4c128ecaa8f0355f6ecd359f06dbc2cfeed344b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 06:00:21 2018 -0600

    Move RRW keypad code to a common method (#12429)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 945fa427d2..9ee19730cf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -228,109 +228,110 @@ bool MarlinUI::get_blink() {
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
 #if ENABLED(REPRAPWORLD_KEYPAD)
-  volatile uint8_t buttons_reprapworld_keypad;
-#endif
 
-#if ENABLED(ADC_KEYPAD)
+  volatile uint8_t MarlinUI::buttons_reprapworld_keypad;
 
-  inline bool handle_adc_keypad() {
-    #define ADC_MIN_KEY_DELAY 100
-    if (buttons_reprapworld_keypad) {
-      #if HAS_ENCODER_ACTION
-        ui.refresh(LCDVIEW_REDRAW_NOW);
-        if (encoderDirection == -1) { // side effect which signals we are inside a menu
-          #if HAS_LCD_MENU
-            if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); ui.quick_feedback(); }
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { ui.return_to_status(); ui.quick_feedback(); }
-          #endif
-        }
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
-      #endif
-      next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
-      return true;
-    }
-
-    return false;
-  }
-
-#elif ENABLED(REPRAPWORLD_KEYPAD)
-
-  #if HAS_LCD_MENU
+  #if DISABLED(ADC_KEYPAD) && HAS_LCD_MENU
 
     void lcd_move_x();
     void lcd_move_y();
     void lcd_move_z();
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
       move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
       encoderPosition = dir;
       switch (axis) {
         case X_AXIS: lcd_move_x(); break;
         case Y_AXIS: lcd_move_y(); break;
         case Z_AXIS: lcd_move_z();
         default: break;
       }
     }
 
   #endif
 
-  inline void handle_reprapworld_keypad() {
+  bool MarlinUI::handle_keypad() {
 
-    static uint8_t keypad_debounce = 0;
+    #if ENABLED(ADC_KEYPAD)
 
-    if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
-            | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
-            | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
-            | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
-    ) {
-      if (keypad_debounce > 0) keypad_debounce--;
-    }
-    else if (!keypad_debounce) {
-      keypad_debounce = 2;
+      #define ADC_MIN_KEY_DELAY 100
+      if (buttons_reprapworld_keypad) {
+        #if HAS_ENCODER_ACTION
+          refresh(LCDVIEW_REDRAW_NOW);
+          if (encoderDirection == -1) { // side effect which signals we are inside a menu
+            #if HAS_LCD_MENU
+              if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); quick_feedback(); }
+              else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
+            #endif
+          }
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
+          else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
+        #endif
+        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
+        return true;
+      }
 
-      const bool homed = all_axes_homed();
+    #else // !ADC_KEYPAD
 
-      #if HAS_LCD_MENU
+      static uint8_t keypad_debounce = 0;
 
-        if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  ui.goto_screen(menu_move);
+      if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
+              | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
+              | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
+              | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
+      ) {
+        if (keypad_debounce > 0) keypad_debounce--;
+      }
+      else if (!keypad_debounce) {
+        keypad_debounce = 2;
 
-        #if DISABLED(DELTA) && Z_HOME_DIR == -1
-          if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
-        #endif
+        const bool homed = all_axes_homed();
+
+        #if HAS_LCD_MENU
 
-        if (homed) {
-          #if ENABLED(DELTA) || Z_HOME_DIR != -1
-            if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+          if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  goto_screen(menu_move);
+
+          #if DISABLED(DELTA) && Z_HOME_DIR == -1
+            if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
           #endif
-          if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
-          if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
-          if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
-          if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
-          if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
-        }
 
-      #endif // HAS_LCD_MENU
+          if (homed) {
+            #if ENABLED(DELTA) || Z_HOME_DIR != -1
+              if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+            #endif
+            if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+            if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+            if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+            if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+            if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
+          }
 
-      if (!homed && RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
-    }
+        #endif // HAS_LCD_MENU
+
+        if (!homed && RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
+        return true;
+      }
+
+    #endif // !ADC_KEYPAD
+
+    return false;
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
@@ -677,32 +678,33 @@ void MarlinUI::update() {
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       update_indicators();
     #endif
 
     #if HAS_ENCODER_ACTION
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
         slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
-      #if ENABLED(ADC_KEYPAD)
+      #if ENABLED(REPRAPWORLD_KEYPAD)
 
-        if (handle_adc_keypad()) {
+        if (
+          #if ENABLED(ADC_KEYPAD)
+            handle_keypad()
+          #else
+            handle_keypad()
+          #endif
+        ) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
-
-      #elif ENABLED(REPRAPWORLD_KEYPAD)
-
-        handle_reprapworld_keypad();
-
       #endif
 
       const float abs_diff = ABS(encoderDiff);
       const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
@@ -983,39 +985,40 @@ void MarlinUI::update() {
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // LCD_HAS_DIRECTIONAL_BUTTONS
 
-        buttons = newbutton
-          #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-            | slow_buttons
-          #endif
-        ;
-
         #if ENABLED(ADC_KEYPAD)
 
-          uint8_t newbutton_reprapworld_keypad = 0;
           buttons = 0;
           if (buttons_reprapworld_keypad == 0) {
-            newbutton_reprapworld_keypad = get_ADC_keyValue();
+            uint8_t newbutton_reprapworld_keypad = get_ADC_keyValue();
             if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
               buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
           }
 
-        #elif ENABLED(REPRAPWORLD_KEYPAD)
+        #else
 
-          GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
+          buttons = newbutton
+            #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+              | slow_buttons
+            #endif
+          ;
+
+          #if ENABLED(REPRAPWORLD_KEYPAD)
+            GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
+          #endif
 
         #endif
 
       #else // !HAS_DIGITAL_ENCODER
 
         GET_SHIFT_BUTTON_STATES(buttons);
 
       #endif
 
     } // next_button_update_ms

commit 54ec5528a0d8ebf4573af3ec78d8141d8a90dceb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 14 01:34:16 2018 -0600

    hasstatus => has_status

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ba02304410..945fa427d2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1083,21 +1083,21 @@ void MarlinUI::finishstatus(const bool persist) {
     next_filament_display = millis() + 5000UL; // Show status message for 5s
   #endif
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     status_scroll_offset = 0;
   #endif
 
   refresh();
 }
 
-bool MarlinUI::hasstatus() { return (status_message[0] != '\0'); }
+bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
 void MarlinUI::setstatus(const char * const message, const bool persist) {
   if (status_message_level > 0) return;
 
   // Here we have a problem. The message is encoded in UTF8, so
   // arbitrarily cutting it will be a problem. We MUST be sure
   // that there is no cutting in the middle of a multibyte character!
 
   // Get a pointer to the null terminator
   const char* pend = message + strlen(message);

commit 3ceab8474c044f45e0e10f882a0e8ea20c4a781b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Nov 13 16:12:44 2018 -0700

    Add required "cardreader.h" include (#12419)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 74b2e93690..ba02304410 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -18,20 +18,23 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 // These displays all share the MarlinUI class
 #if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
   #include "ultralcd.h"
+  #if ENABLED(SDSUPPORT)
+    #include "../sd/cardreader.h"
+  #endif
   MarlinUI ui;
 #endif
 
 #if HAS_SPI_LCD
 
 #if HAS_GRAPHICAL_LCD
   #include "dogm/ultralcd_DOGM.h"
 #endif
 
 #include "lcdprint.h"

commit 0ee1a92971bba0fe5ed290e2562bca71cfb5ea46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 13 01:47:45 2018 -0600

    Group status methods, share reset_status with Extensible UI (#12414)
    
    * Group status methods, share reset_status with Extensible UI
    * Move common DOGM code to headers

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5b639e18e9..74b2e93690 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -15,62 +15,49 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
-#if HAS_SPI_LCD
-
-#include <stdarg.h>
+// These displays all share the MarlinUI class
+#if HAS_SPI_LCD || ENABLED(MALYAN_LCD) || ENABLED(EXTENSIBLE_UI)
+  #include "ultralcd.h"
+  MarlinUI ui;
+#endif
 
-#include "ultralcd.h"
+#if HAS_SPI_LCD
 
-MarlinUI ui;
+#if HAS_GRAPHICAL_LCD
+  #include "dogm/ultralcd_DOGM.h"
+#endif
 
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
-#include "../module/stepper.h"
-#include "../module/motion.h"
-#include "../module/probe.h"
 #include "../module/printcounter.h"
-#include "../gcode/gcode.h"
+#include "../module/motion.h"
 #include "../gcode/queue.h"
-#include "../module/configuration_store.h"
-#include "../module/tool_change.h"
 
 #include "../Marlin.h"
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "../feature/pause.h"
-#endif
-
 #if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
-#endif
-
-#if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
-  #include "../libs/duration_t.h"
-#endif
-
-#if ENABLED(BLTOUCH)
-  #include "../module/endstops.h"
+ #include "../feature/power_loss_recovery.h"
 #endif
 
-#if HAS_LEVELING
-  #include "../feature/bedlevel/bedlevel.h"
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+ #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_ENCODER_ACTION
   volatile uint8_t MarlinUI::buttons;
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
     volatile uint8_t MarlinUI::slow_buttons;
@@ -447,42 +434,20 @@ void MarlinUI::status_screen() {
       encoderPosition = 0;
     }
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
   draw_status_screen();
 }
 
-/**
- * Reset the status message
- */
-void MarlinUI::reset_status() {
-  static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
-  static const char printing[] PROGMEM = MSG_PRINTING;
-  static const char welcome[] PROGMEM = WELCOME_MSG;
-  PGM_P msg;
-  if (print_job_timer.isPaused())
-    msg = paused;
-  #if ENABLED(SDSUPPORT)
-    else if (IS_SD_PRINTING())
-      return setstatus(card.longest_filename(), true);
-  #endif
-  else if (print_job_timer.isRunning())
-    msg = printing;
-  else
-    msg = welcome;
-
-  setstatusPGM(msg, -1);
-}
-
 void MarlinUI::kill_screen(PGM_P lcd_msg) {
   init();
   setalertstatusPGM(lcd_msg);
   draw_kill_screen();
 }
 
 void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     refresh();
@@ -500,20 +465,24 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   #endif
 }
 
+////////////////////////////////////////////
+/////////////// Manual Move ////////////////
+////////////////////////////////////////////
+
 #if HAS_LCD_MENU
 
   extern bool no_reentry; // Flag to prevent recursion into menu handlers
 
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
 
   #if IS_KINEMATIC
     bool MarlinUI::processing_manual_move = false;
     float manual_move_offset = 0;
@@ -884,115 +853,20 @@ void MarlinUI::update() {
         refresh(LCDVIEW_NONE);
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
-void MarlinUI::finishstatus(const bool persist) {
-
-  #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
-    UNUSED(persist);
-  #endif
-
-  #if ENABLED(LCD_PROGRESS_BAR)
-    progress_bar_ms = millis();
-    #if PROGRESS_MSG_EXPIRE > 0
-      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
-    #endif
-  #endif
-
-  #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-    next_filament_display = millis() + 5000UL; // Show status message for 5s
-  #endif
-
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    status_scroll_offset = 0;
-  #endif
-
-  refresh();
-}
-
-bool MarlinUI::hasstatus() { return (status_message[0] != '\0'); }
-
-void MarlinUI::setstatus(const char * const message, const bool persist) {
-  if (status_message_level > 0) return;
-
-  // Here we have a problem. The message is encoded in UTF8, so
-  // arbitrarily cutting it will be a problem. We MUST be sure
-  // that there is no cutting in the middle of a multibyte character!
-
-  // Get a pointer to the null terminator
-  const char* pend = message + strlen(message);
-
-  //  If length of supplied UTF8 string is greater than
-  // our buffer size, start cutting whole UTF8 chars
-  while ((pend - message) > MAX_MESSAGE_LENGTH) {
-    --pend;
-    while (!START_OF_UTF8_CHAR(*pend)) --pend;
-  };
-
-  // At this point, we have the proper cut point. Use it
-  uint8_t maxLen = pend - message;
-  strncpy(status_message, message, maxLen);
-  status_message[maxLen] = '\0';
-
-  finishstatus(persist);
-}
-
-void MarlinUI::setstatusPGM(PGM_P const message, int8_t level) {
-  if (level < 0) level = status_message_level = 0;
-  if (level < status_message_level) return;
-  status_message_level = level;
-
-  // Here we have a problem. The message is encoded in UTF8, so
-  // arbitrarily cutting it will be a problem. We MUST be sure
-  // that there is no cutting in the middle of a multibyte character!
-
-  // Get a pointer to the null terminator
-  PGM_P pend = message + strlen_P(message);
-
-  //  If length of supplied UTF8 string is greater than
-  // our buffer size, start cutting whole UTF8 chars
-  while ((pend - message) > MAX_MESSAGE_LENGTH) {
-    --pend;
-    while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
-  };
-
-  // At this point, we have the proper cut point. Use it
-  uint8_t maxLen = pend - message;
-  strncpy_P(status_message, message, maxLen);
-  status_message[maxLen] = '\0';
-
-  finishstatus(level > 0);
-}
-
-void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-  if (level < status_message_level) return;
-  status_message_level = level;
-  va_list args;
-  va_start(args, fmt);
-  vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
-  va_end(args);
-  finishstatus(level > 0);
-}
-
-void MarlinUI::setalertstatusPGM(PGM_P const message) {
-  setstatusPGM(message, 1);
-  #if HAS_LCD_MENU
-    return_to_status();
-  #endif
-}
-
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
     { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F1     }, // F1
@@ -1178,11 +1052,140 @@ void MarlinUI::setalertstatusPGM(PGM_P const message) {
             slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
         #endif // LCD_I2C_VIKI
         return slow_bits;
       #endif // LCD_I2C_TYPE_MCP23017
     }
 
   #endif // LCD_HAS_SLOW_BUTTONS
 
 #endif // HAS_ENCODER_ACTION
 
+////////////////////////////////////////////
+/////////////// Status Line ////////////////
+////////////////////////////////////////////
+
+void MarlinUI::finishstatus(const bool persist) {
+
+  #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
+    UNUSED(persist);
+  #endif
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+    progress_bar_ms = millis();
+    #if PROGRESS_MSG_EXPIRE > 0
+      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
+    #endif
+  #endif
+
+  #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+    next_filament_display = millis() + 5000UL; // Show status message for 5s
+  #endif
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    status_scroll_offset = 0;
+  #endif
+
+  refresh();
+}
+
+bool MarlinUI::hasstatus() { return (status_message[0] != '\0'); }
+
+void MarlinUI::setstatus(const char * const message, const bool persist) {
+  if (status_message_level > 0) return;
+
+  // Here we have a problem. The message is encoded in UTF8, so
+  // arbitrarily cutting it will be a problem. We MUST be sure
+  // that there is no cutting in the middle of a multibyte character!
+
+  // Get a pointer to the null terminator
+  const char* pend = message + strlen(message);
+
+  //  If length of supplied UTF8 string is greater than
+  // our buffer size, start cutting whole UTF8 chars
+  while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    --pend;
+    while (!START_OF_UTF8_CHAR(*pend)) --pend;
+  };
+
+  // At this point, we have the proper cut point. Use it
+  uint8_t maxLen = pend - message;
+  strncpy(status_message, message, maxLen);
+  status_message[maxLen] = '\0';
+
+  finishstatus(persist);
+}
+
+#include <stdarg.h>
+
+void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+  if (level < status_message_level) return;
+  status_message_level = level;
+  va_list args;
+  va_start(args, fmt);
+  vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+  va_end(args);
+  finishstatus(level > 0);
+}
+
+void MarlinUI::setstatusPGM(PGM_P const message, int8_t level) {
+  if (level < 0) level = status_message_level = 0;
+  if (level < status_message_level) return;
+  status_message_level = level;
+
+  // Here we have a problem. The message is encoded in UTF8, so
+  // arbitrarily cutting it will be a problem. We MUST be sure
+  // that there is no cutting in the middle of a multibyte character!
+
+  // Get a pointer to the null terminator
+  PGM_P pend = message + strlen_P(message);
+
+  //  If length of supplied UTF8 string is greater than
+  // our buffer size, start cutting whole UTF8 chars
+  while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    --pend;
+    while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
+  };
+
+  // At this point, we have the proper cut point. Use it
+  uint8_t maxLen = pend - message;
+  strncpy_P(status_message, message, maxLen);
+  status_message[maxLen] = '\0';
+
+  finishstatus(level > 0);
+}
+
+void MarlinUI::setalertstatusPGM(PGM_P const message) {
+  setstatusPGM(message, 1);
+  #if HAS_LCD_MENU
+    return_to_status();
+  #endif
+}
+
 #endif // HAS_SPI_LCD
+
+#if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+
+  #include "../module/printcounter.h"
+
+  /**
+   * Reset the status message
+   */
+  void MarlinUI::reset_status() {
+    static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
+    static const char printing[] PROGMEM = MSG_PRINTING;
+    static const char welcome[] PROGMEM = WELCOME_MSG;
+    PGM_P msg;
+    if (print_job_timer.isPaused())
+      msg = paused;
+    #if ENABLED(SDSUPPORT)
+      else if (IS_SD_PRINTING())
+        return setstatus(card.longest_filename(), true);
+    #endif
+    else if (print_job_timer.isRunning())
+      msg = printing;
+    else
+      msg = welcome;
+
+    setstatusPGM(msg, -1);
+  }
+
+#endif

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 14b8e0d1a4..5b639e18e9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -15,25 +15,28 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
-#if ENABLED(ULTRA_LCD)
+#if HAS_SPI_LCD
 
 #include <stdarg.h>
 
 #include "ultralcd.h"
+
+MarlinUI ui;
+
 #include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
 #include "../module/printcounter.h"
 #include "../gcode/gcode.h"
@@ -42,126 +45,138 @@
 #include "../module/tool_change.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
-  #if HAS_LCD_MENU
-    void menu_job_recovery();
-  #endif
 #endif
 
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
-#if ENABLED(FILAMENT_LCD_DISPLAY)
-  #include "../feature/filwidth.h"
-#endif
-
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
-// Buttons
-volatile uint8_t buttons;
+#if HAS_ENCODER_ACTION
+  volatile uint8_t MarlinUI::buttons;
+  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+    volatile uint8_t MarlinUI::slow_buttons;
+  #endif
+#endif
 
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
-  uint8_t status_scroll_offset = 0;
+  uint8_t MarlinUI::status_scroll_offset; // = 0
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
-char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
-uint8_t lcd_status_update_delay = 1, // First update one loop delayed
-        lcd_status_message_level;    // Higher level blocks lower level
-
-#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-  millis_t previous_lcd_status_ms = 0;
+#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+  bool MarlinUI::defer_return_to_status;
 #endif
 
-#if HAS_LCD_MENU && ENABLED(SDSUPPORT) && ENABLED(SCROLL_LONG_FILENAMES)
-  uint8_t filename_scroll_pos, filename_scroll_max;
+char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
+uint8_t MarlinUI::status_message_level; // = 0
+
+#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+  millis_t MarlinUI::next_filament_display; // = 0
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  uint8_t progress_bar_percent;
+  uint8_t MarlinUI::progress_bar_percent; // = 0
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
-  bool drawing_screen, first_page; // = false
+  bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
 #endif
 
 // Encoder Handling
 #if HAS_ENCODER_ACTION
-  uint32_t encoderPosition;
-  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
-  #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    bool encoderRateMultiplierEnabled;
-  #endif
-  #if ENABLED(REVERSE_MENU_DIRECTION)
-    int8_t encoderDirection = 1;
-  #endif
+  uint32_t MarlinUI::encoderPosition;
+  volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
-  screenFunc_t currentScreen = lcd_status_screen;
+  #if ENABLED(SDSUPPORT) && ENABLED(SCROLL_LONG_FILENAMES)
+    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+  #endif
+
+  screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    millis_t lastEncoderMovementMillis = 0;
+    bool MarlinUI::encoderRateMultiplierEnabled;
+    millis_t MarlinUI::lastEncoderMovementMillis = 0;
+    void MarlinUI::enable_encoder_multiplier(const bool onoff) {
+      encoderRateMultiplierEnabled = onoff;
+      lastEncoderMovementMillis = 0;
+    }
   #endif
 
-  bool lcd_clicked, wait_for_unclick;
+  #if ENABLED(REVERSE_MENU_DIRECTION)
+    int8_t MarlinUI::encoderDirection = 1;
+  #endif
+
+  bool MarlinUI::lcd_clicked;
   float move_menu_scale;
 
-  bool use_click() {
+  bool MarlinUI::use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
-#else
+  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
 
-  constexpr bool lcd_clicked = false;
+    bool MarlinUI::external_control; // = false
+
+    void MarlinUI::wait_for_release() {
+      while (button_pressed()) safe_delay(50);
+      safe_delay(50);
+    }
+
+  #endif
 
 #endif
 
-void lcd_init() {
+void MarlinUI::init() {
+
+  init_lcd();
 
-  lcd_implementation_init();
+  #if HAS_DIGITAL_ENCODER
 
-  #if ENABLED(NEWPANEL)
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
@@ -177,51 +192,51 @@ void lcd_init() {
     #if BUTTON_EXISTS(DWN)
       SET_INPUT(BTN_DWN);
     #endif
     #if BUTTON_EXISTS(LFT)
       SET_INPUT(BTN_LFT);
     #endif
     #if BUTTON_EXISTS(RT)
       SET_INPUT(BTN_RT);
     #endif
 
-  #else // !NEWPANEL
+  #else // !HAS_DIGITAL_ENCODER
 
     #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
       SET_OUTPUT(SR_DATA_PIN);
       SET_OUTPUT(SR_CLK_PIN);
     #elif defined(SHIFT_CLK)
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
       OUT_WRITE(SHIFT_EN, LOW);
       SET_INPUT_PULLUP(SHIFT_OUT);
     #endif // SR_LCD_2W_NL
 
-  #endif // !NEWPANEL
+  #endif // !HAS_DIGITAL_ENCODER
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
-  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+  #if HAS_ENCODER_ACTION && ENABLED(LCD_HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
-  lcd_buttons_update();
+  update_buttons();
 
   #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
-bool lcd_blink() {
+bool MarlinUI::get_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
@@ -232,27 +247,27 @@ bool lcd_blink() {
 #if ENABLED(REPRAPWORLD_KEYPAD)
   volatile uint8_t buttons_reprapworld_keypad;
 #endif
 
 #if ENABLED(ADC_KEYPAD)
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
       #if HAS_ENCODER_ACTION
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        ui.refresh(LCDVIEW_REDRAW_NOW);
         if (encoderDirection == -1) { // side effect which signals we are inside a menu
           #if HAS_LCD_MENU
             if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
             else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); lcd_quick_feedback(); }
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(); }
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); ui.quick_feedback(); }
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { ui.return_to_status(); ui.quick_feedback(); }
           #endif
         }
         else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
         else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
         else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
       #endif
       next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
       return true;
     }
 
@@ -291,21 +306,21 @@ bool lcd_blink() {
     ) {
       if (keypad_debounce > 0) keypad_debounce--;
     }
     else if (!keypad_debounce) {
       keypad_debounce = 2;
 
       const bool homed = all_axes_homed();
 
       #if HAS_LCD_MENU
 
-        if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  lcd_goto_screen(menu_move);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  ui.goto_screen(menu_move);
 
         #if DISABLED(DELTA) && Z_HOME_DIR == -1
           if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
         #endif
 
         if (homed) {
           #if ENABLED(DELTA) || Z_HOME_DIR != -1
             if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
           #endif
           if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
@@ -323,46 +338,47 @@ bool lcd_blink() {
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 #if ENABLED(LCD_PROGRESS_BAR)
-  millis_t progress_bar_ms = 0;     // Start millis of the current progress bar cycle
+  millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
-    static millis_t expire_status_ms = 0;
-    void dontExpireStatus() { expire_status_ms = 0; }
+    millis_t MarlinUI::expire_status_ms; // = 0
   #endif
 #endif
 
-#if LCD_INFO_SCREEN_STYLE == 0
-  void lcd_impl_status_screen_0();
-#elif LCD_INFO_SCREEN_STYLE == 1
-  void lcd_impl_status_screen_1();
+#if HAS_PRINT_PROGRESS
+  uint8_t MarlinUI::get_progress() {
+    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+      uint8_t &progress = progress_bar_percent;
+    #else
+      uint8_t progress = 0;
+    #endif
+    #if ENABLED(SDSUPPORT)
+      if (IS_SD_PRINTING()) progress = card.percentDone();
+    #endif
+    return progress;
+  }
 #endif
 
-void lcd_status_screen() {
+void MarlinUI::status_screen() {
 
   #if HAS_LCD_MENU
-    ENCODER_DIRECTION_NORMAL();
+    encoder_direction_normal();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
-  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || HAS_GRAPHICAL_LCD)
-    // Progress bar % comes from SD when actively printing
-    if (IS_SD_PRINTING())
-      progress_bar_percent = card.percentDone();
-  #endif
-
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
     millis_t ms = millis();
 
@@ -370,50 +386,46 @@ void lcd_status_screen() {
     #if DISABLED(PROGRESS_MSG_ONCE)
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 
       // Handle message expire
       if (expire_status_ms > 0) {
 
-        #if DISABLED(LCD_SET_PROGRESS_MANUALLY)
-          const uint8_t progress_bar_percent = card.percentDone();
-        #endif
-
         // Expire the message if a job is active and the bar has ticks
-        if (progress_bar_percent > 2 && !print_job_timer.isPaused()) {
+        if (get_progress() > 2 && !print_job_timer.isPaused()) {
           if (ELAPSED(ms, expire_status_ms)) {
-            lcd_status_message[0] = '\0';
+            status_message[0] = '\0';
             expire_status_ms = 0;
           }
         }
         else {
           // Defer message expiration before bar appears
           // and during any pause (not just SD)
           expire_status_ms += LCD_UPDATE_INTERVAL;
         }
       }
 
     #endif // PROGRESS_MSG_EXPIRE
 
   #endif // LCD_PROGRESS_BAR
 
   #if HAS_LCD_MENU
 
     if (use_click()) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-        previous_lcd_status_ms = millis();  // get status message to show up for a while
+        next_filament_display = millis() + 5000UL;  // Show status message for 5s
       #endif
-      lcd_goto_screen(menu_main);
-      lcd_implementation_init(); // May revive the LCD if static electricity killed it
+      goto_screen(menu_main);
+      init_lcd(); // May revive the LCD if static electricity killed it
       return;
     }
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
 
     const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
     // Dead zone at 100% feedrate
     if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
@@ -432,110 +444,97 @@ void lcd_status_screen() {
     }
     else {
       feedrate_percentage = new_frm;
       encoderPosition = 0;
     }
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
   #endif // ULTIPANEL_FEEDMULTIPLY
 
-  #if LCD_INFO_SCREEN_STYLE == 0
-    lcd_impl_status_screen_0();
-  #elif LCD_INFO_SCREEN_STYLE == 1
-    lcd_impl_status_screen_1();
-  #endif
+  draw_status_screen();
 }
 
 /**
  * Reset the status message
  */
-void lcd_reset_status() {
+void MarlinUI::reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   PGM_P msg;
   if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (IS_SD_PRINTING())
-      return lcd_setstatus(card.longest_filename(), true);
+      return setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
-  lcd_setstatusPGM(msg, -1);
+  setstatusPGM(msg, -1);
 }
 
-void kill_screen(PGM_P lcd_msg) {
-  lcd_init();
-  lcd_setalertstatusPGM(lcd_msg);
-  lcd_kill_screen();
+void MarlinUI::kill_screen(PGM_P lcd_msg) {
+  init();
+  setalertstatusPGM(lcd_msg);
+  draw_kill_screen();
 }
 
-#if HAS_BUZZER
-  void lcd_buzz(const long duration, const uint16_t freq) {
-    #if ENABLED(LCD_USE_I2C_BUZZER)
-      lcd.buzz(duration, freq);
-    #elif PIN_EXISTS(BEEPER)
-      buzzer.tone(duration, freq);
-    #endif
-  }
-#endif
-
-void lcd_quick_feedback(const bool clear_buttons/*=true*/) {
+void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
-    lcd_refresh();
+    refresh();
+  #endif
+
+  #if HAS_ENCODER_ACTION
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
   // Buzz and wait. The delay is needed for buttons to settle!
-  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+  buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
 
   #if HAS_LCD_MENU
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   #endif
 }
 
 #if HAS_LCD_MENU
 
   extern bool no_reentry; // Flag to prevent recursion into menu handlers
 
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
 
   #if IS_KINEMATIC
-    bool processing_manual_move = false;
+    bool MarlinUI::processing_manual_move = false;
     float manual_move_offset = 0;
   #endif
 
-  #if !IS_KINEMATIC || (IS_KINEMATIC && EXTRUDERS > 1)
-    int8_t manual_move_e_index = 0;
-  #else
-    constexpr int8_t manual_move_e_index = 0;
+  #if E_MANUAL > 1
+    int8_t MarlinUI::manual_move_e_index = 0;
   #endif
 
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send a move immediately.
    */
-  void manage_manual_move() {
+  void MarlinUI::manage_manual_move() {
 
     if (processing_manual_move) return;
 
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
 
       #if IS_KINEMATIC
 
         const float old_feedrate = feedrate_mm_s;
         feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
 
@@ -576,198 +575,180 @@ void lcd_quick_feedback(const bool clear_buttons/*=true*/) {
 
 #endif // HAS_LCD_MENU
 
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position
  *   - Apply acceleration to the encoder position
- *   - Set lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NOW on controller events
+ *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
  *   - Reset the Info Screen timeout if there's any input
  *   - Update status indicators, if any
  *
  *   Run the current LCD menu handler callback function:
  *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
  *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
  *   - Call the menu handler. Menu handlers should do the following:
  *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
  *       (Encoder events automatically set lcdDrawUpdate for you.)
- *     - if (lcdDrawUpdate) { redraw }
+ *     - if (should_draw()) { redraw }
  *     - Before exiting the handler set lcdDrawUpdate to:
  *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
  *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
  *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
  *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
  *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
  *             so don't change lcdDrawUpdate without considering this.
  *
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * This function is only called from the main thread.
  */
 
-LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
-#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-  bool lcd_external_control; // = false
-#endif
-
-#if ENABLED(LCD_HAS_SLOW_BUTTONS)
-  volatile uint8_t slow_buttons;
-#endif
-
-bool lcd_detected() {
+bool MarlinUI::detected() {
   return
     #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
       lcd.LcdDetected() == 1
     #else
       true
     #endif
   ;
 }
 
-void lcd_update() {
+void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
 
   #if HAS_LCD_MENU
 
     #if LCD_TIMEOUT_TO_STATUS
       static millis_t return_to_status_ms = 0;
     #endif
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
-    // Update button states for LCD_CLICKED(), etc.
-    // After state changes the next button update
-    // may be delayed 300-500ms.
-    lcd_buttons_update();
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      // Don't run the debouncer if UBL owns the display
-      #define UBL_CONDITION !lcd_external_control
-    #else
-      #define UBL_CONDITION true
-    #endif
+    // Update button states for button_pressed(), etc.
+    // If the state changes the next update may be delayed 300-500ms.
+    update_buttons();
 
     // If the action button is pressed...
-    if (UBL_CONDITION && LCD_CLICKED()) {
-      if (!wait_for_unclick) {           // If not waiting for a debounce release:
-        wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
-        wait_for_user = false;           //  Any click clears wait for user
-        lcd_quick_feedback();        //  Always make a click sound
+    static bool wait_for_unclick; // = 0
+    if (!external_control && button_pressed()) {
+      if (!wait_for_unclick) {                        // If not waiting for a debounce release:
+        wait_for_unclick = true;                      //  - Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user && !no_reentry;  //  - Keep the click if not waiting for a user-click
+        wait_for_user = false;                        //  - Any click clears wait for user
+        quick_feedback();                             //  - Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
-      if (LCD_BACK_CLICKED) {
-        lcd_quick_feedback();
-        lcd_goto_previous_menu();
+      if (LCD_BACK_CLICKED()) {
+        quick_feedback();
+        goto_previous_screen();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
-    if (sd_status != lcd_sd_status && lcd_detected()) {
+    if (sd_status != lcd_sd_status && detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot
         else
-          LCD_MESSAGEPGM(MSG_SD_INSERTED);
+          setstatusPGM(PSTR(MSG_SD_INSERTED));
       }
       else {
         card.release();
-        if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
+        if (old_sd_status != 2) setstatusPGM(PSTR(MSG_SD_REMOVED));
       }
 
-      lcd_refresh();
-      lcd_implementation_init(); // May revive the LCD if static electricity killed it
+      refresh();
+      init_lcd(); // May revive the LCD if static electricity killed it
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
-      lcd_goto_screen(menu_job_recovery);
+      goto_screen(menu_job_recovery);
       job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
     }
   #endif
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
-      lcd_implementation_update_indicators();
+      update_indicators();
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_ENCODER_ACTION
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-        slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
+        slow_buttons = read_slow_buttons(); // Buttons that take too long to read in interrupt context
       #endif
 
-    #endif // HAS_LCD_MENU
-
-    #if HAS_ENCODER_ACTION
-
       #if ENABLED(ADC_KEYPAD)
 
         if (handle_adc_keypad()) {
           #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
 
       #elif ENABLED(REPRAPWORLD_KEYPAD)
 
         handle_reprapworld_keypad();
 
       #endif
 
-      const bool encoderPastThreshold = (ABS(encoderDiff) >= ENCODER_PULSES_PER_STEP);
+      const float abs_diff = ABS(encoderDiff);
+      const bool encoderPastThreshold = (abs_diff >= (ENCODER_PULSES_PER_STEP));
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
 
           #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
 
             int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
-              int32_t encoderMovementSteps = ABS(encoderDiff) / ENCODER_PULSES_PER_STEP;
+              const float encoderMovementSteps = abs_diff / (ENCODER_PULSES_PER_STEP);
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
-                float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000;
+                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
                   SERIAL_ECHO_START();
                   SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
                   SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
                   SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
                   SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
@@ -777,259 +758,241 @@ void lcd_update() {
 
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
 
           #else
 
             constexpr int32_t encoderMultiplier = 1;
 
           #endif // ENCODER_RATE_MULTIPLIER
 
-          encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
+          encoderPosition += (encoderDiff * encoderMultiplier) / (ENCODER_PULSES_PER_STEP);
           encoderDiff = 0;
         }
         #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        refresh(LCDVIEW_REDRAW_NOW);
       }
 
     #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
-    if (
-      #if HAS_LCD_MENU
-        currentScreen == lcd_status_screen &&
-      #endif
-      !lcd_status_update_delay--
-    ) {
+    if (on_status_screen() && !lcd_status_update_delay--) {
       lcd_status_update_delay = 9
         #if HAS_GRAPHICAL_LCD
           + 3
         #endif
       ;
       max_display_update_time--;
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      refresh(LCDVIEW_REDRAW_NOW);
     }
 
     #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_sdcard && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
         lcd_status_update_delay = 6;
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        refresh(LCDVIEW_REDRAW_NOW);
         filename_scroll_pos++;
         #if LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
-    #if HAS_GRAPHICAL_LCD
-      const bool &is_drawing = drawing_screen;
-    #else
-      constexpr bool is_drawing = false;
-    #endif
-
-    if ((lcdDrawUpdate || is_drawing) && (!bbr2 || bbr2 > max_display_update_time)) {
+    if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
 
       // Change state of drawing flag between screen updates
-      if (!is_drawing) switch (lcdDrawUpdate) {
+      if (!drawing_screen) switch (lcdDrawUpdate) {
         case LCDVIEW_CALL_NO_REDRAW:
-          lcdDrawUpdate = LCDVIEW_NONE;
+          refresh(LCDVIEW_NONE);
           break;
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:
-          lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+          refresh(LCDVIEW_REDRAW_NOW);
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
       #if ENABLED(ADC_KEYPAD)
         buttons_reprapworld_keypad = 0;
       #endif
 
-      #if HAS_LCD_MENU
-        #define CURRENTSCREEN() (*currentScreen)()
-      #else
-        #define CURRENTSCREEN() lcd_status_screen()
-      #endif
-
       #if HAS_GRAPHICAL_LCD
+
         #if ENABLED(LIGHTWEIGHT_UI)
-          #if HAS_LCD_MENU
-            const bool in_status = currentScreen == lcd_status_screen;
-          #else
-            constexpr bool in_status = true;
-          #endif
-          const bool do_u8g_loop = !in_status;
+          const bool in_status = on_status_screen(),
+                     do_u8g_loop = !in_status;
           lcd_in_status(in_status);
-          if (in_status) lcd_status_screen();
+          if (in_status) status_screen();
         #else
           constexpr bool do_u8g_loop = true;
         #endif
+
         if (do_u8g_loop) {
           if (!drawing_screen) {                        // If not already drawing pages
             u8g.firstPage();                            // Start the first page
             drawing_screen = first_page = true;         // Flag as drawing pages
           }
-          lcd_setFont(FONT_MENU);                       // Setup font for every page draw
+          set_font(FONT_MENU);                       // Setup font for every page draw
           u8g.setColorIndex(1);                         // And reset the color
-          CURRENTSCREEN();                              // Draw and process the current screen
+          run_current_screen();                         // Draw and process the current screen
           first_page = false;
 
           // The screen handler can clear drawing_screen for an action that changes the screen.
           // If still drawing and there's another page, update max-time and return now.
           // The nextPage will already be set up on the next call.
           if (drawing_screen && (drawing_screen = u8g.nextPage())) {
             NOLESS(max_display_update_time, millis() - ms);
             return;
           }
         }
+
       #else
-        CURRENTSCREEN();
+
+        run_current_screen();
+
       #endif
 
       #if HAS_LCD_MENU
         lcd_clicked = false;
       #endif
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
       // Return to Status Screen after a timeout
-      if (currentScreen == lcd_status_screen || defer_return_to_status)
+      if (on_status_screen() || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
-        lcd_return_to_status();
+        return_to_status();
     #endif
 
     // Change state of drawing flag between screen updates
-    if (!is_drawing) switch (lcdDrawUpdate) {
+    if (!drawing_screen) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
-        lcd_implementation_clear(); break;
+        clear_lcd(); break;
       case LCDVIEW_REDRAW_NOW:
-        lcdDrawUpdate = LCDVIEW_NONE;
+        refresh(LCDVIEW_NONE);
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
-void lcd_finishstatus(const bool persist=false) {
+void MarlinUI::finishstatus(const bool persist) {
 
   #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
     UNUSED(persist);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
     progress_bar_ms = millis();
     #if PROGRESS_MSG_EXPIRE > 0
       expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
     #endif
   #endif
 
-  lcd_refresh();
-
   #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-    previous_lcd_status_ms = millis();  //get status message to show up for a while
+    next_filament_display = millis() + 5000UL; // Show status message for 5s
   #endif
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     status_scroll_offset = 0;
   #endif
+
+  refresh();
 }
 
-bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
+bool MarlinUI::hasstatus() { return (status_message[0] != '\0'); }
 
-void lcd_setstatus(const char * const message, const bool persist) {
-  if (lcd_status_message_level > 0) return;
+void MarlinUI::setstatus(const char * const message, const bool persist) {
+  if (status_message_level > 0) return;
 
   // Here we have a problem. The message is encoded in UTF8, so
   // arbitrarily cutting it will be a problem. We MUST be sure
   // that there is no cutting in the middle of a multibyte character!
 
   // Get a pointer to the null terminator
   const char* pend = message + strlen(message);
 
   //  If length of supplied UTF8 string is greater than
   // our buffer size, start cutting whole UTF8 chars
   while ((pend - message) > MAX_MESSAGE_LENGTH) {
     --pend;
     while (!START_OF_UTF8_CHAR(*pend)) --pend;
   };
 
   // At this point, we have the proper cut point. Use it
   uint8_t maxLen = pend - message;
-  strncpy(lcd_status_message, message, maxLen);
-  lcd_status_message[maxLen] = '\0';
+  strncpy(status_message, message, maxLen);
+  status_message[maxLen] = '\0';
 
-  lcd_finishstatus(persist);
+  finishstatus(persist);
 }
 
-void lcd_setstatusPGM(PGM_P const message, int8_t level) {
-  if (level < 0) level = lcd_status_message_level = 0;
-  if (level < lcd_status_message_level) return;
-  lcd_status_message_level = level;
+void MarlinUI::setstatusPGM(PGM_P const message, int8_t level) {
+  if (level < 0) level = status_message_level = 0;
+  if (level < status_message_level) return;
+  status_message_level = level;
 
   // Here we have a problem. The message is encoded in UTF8, so
   // arbitrarily cutting it will be a problem. We MUST be sure
   // that there is no cutting in the middle of a multibyte character!
 
   // Get a pointer to the null terminator
   PGM_P pend = message + strlen_P(message);
 
   //  If length of supplied UTF8 string is greater than
   // our buffer size, start cutting whole UTF8 chars
   while ((pend - message) > MAX_MESSAGE_LENGTH) {
     --pend;
     while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
   };
 
   // At this point, we have the proper cut point. Use it
   uint8_t maxLen = pend - message;
-  strncpy_P(lcd_status_message, message, maxLen);
-  lcd_status_message[maxLen] = '\0';
+  strncpy_P(status_message, message, maxLen);
+  status_message[maxLen] = '\0';
 
-  lcd_finishstatus(level > 0);
+  finishstatus(level > 0);
 }
 
-void lcd_status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-  if (level < lcd_status_message_level) return;
-  lcd_status_message_level = level;
+void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+  if (level < status_message_level) return;
+  status_message_level = level;
   va_list args;
   va_start(args, fmt);
-  vsnprintf_P(lcd_status_message, MAX_MESSAGE_LENGTH, fmt, args);
+  vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
   va_end(args);
-  lcd_finishstatus(level > 0);
+  finishstatus(level > 0);
 }
 
-void lcd_setalertstatusPGM(PGM_P const message) {
-  lcd_setstatusPGM(message, 1);
+void MarlinUI::setalertstatusPGM(PGM_P const message) {
+  setstatusPGM(message, 1);
   #if HAS_LCD_MENU
-    lcd_return_to_status();
+    return_to_status();
   #endif
 }
 
-void lcd_reset_alert_level() { lcd_status_message_level = 0; }
-
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
     { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F1     }, // F1
@@ -1051,191 +1014,175 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 #endif
 
-#if HAS_LCD_MENU
+#if HAS_ENCODER_ACTION
+
+  #if DISABLED(ADC_KEYPAD) && (ENABLED(REPRAPWORLD_KEYPAD) || !HAS_DIGITAL_ENCODER)
+
+    /**
+     * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
+     * These values are independent of which pins are used for EN_A and EN_B indications
+     * The rotary encoder part is also independent to the chipset used for the LCD
+     */
+    #define GET_SHIFT_BUTTON_STATES(DST) \
+      uint8_t new_##DST = 0; \
+      WRITE(SHIFT_LD, LOW); \
+      WRITE(SHIFT_LD, HIGH); \
+      for (int8_t i = 0; i < 8; i++) { \
+        new_##DST >>= 1; \
+        if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
+        WRITE(SHIFT_CLK, HIGH); \
+        WRITE(SHIFT_CLK, LOW); \
+      } \
+      DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
+
+  #endif
 
-  /**
-   * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
-   * These values are independent of which pins are used for EN_A and EN_B indications
-   * The rotary encoder part is also independent to the chipset used for the LCD
-   */
   #if defined(EN_A) && defined(EN_B)
     #define encrot0 0
     #define encrot1 2
     #define encrot2 3
     #define encrot3 1
   #endif
 
-  #define GET_SHIFT_BUTTON_STATES(DST) \
-    uint8_t new_##DST = 0; \
-    WRITE(SHIFT_LD, LOW); \
-    WRITE(SHIFT_LD, HIGH); \
-    for (int8_t i = 0; i < 8; i++) { \
-      new_##DST >>= 1; \
-      if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
-      WRITE(SHIFT_CLK, HIGH); \
-      WRITE(SHIFT_CLK, LOW); \
-    } \
-    DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
-
-  #if ENABLED(G26_MESH_VALIDATION)
-    void lcd_chirp() {
-      lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-    }
-  #endif
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-    bool is_lcd_clicked() { return LCD_CLICKED(); }
-    void wait_for_release() {
-      while (is_lcd_clicked()) safe_delay(50);
-      safe_delay(50);
-    }
-  #endif
-
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
-  void lcd_buttons_update() {
+  void MarlinUI::update_buttons() {
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
-      #if ENABLED(NEWPANEL)
+      #if HAS_DIGITAL_ENCODER
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
         #if BUTTON_EXISTS(BACK)
           if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
         #endif
 
         //
         // Directional buttons
         //
         #if LCD_HAS_DIRECTIONAL_BUTTONS
 
-          #if ENABLED(REVERSE_MENU_DIRECTION)
-            #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
-          #else
-            #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM
-          #endif
-          #if ENABLED(REVERSE_ENCODER_DIRECTION)
-            #define ENCODER_UD_STEPS _ENCODER_UD_STEPS
-            #define ENCODER_LR_PULSES ENCODER_PULSES_PER_STEP
-          #else
-            #define ENCODER_UD_STEPS -(_ENCODER_UD_STEPS)
-            #define ENCODER_LR_PULSES -(ENCODER_PULSES_PER_STEP)
-          #endif
+          const int8_t pulses = (ENCODER_PULSES_PER_STEP) * encoderDirection;
 
           if (false) {
             // for the else-ifs below
           }
           #if BUTTON_EXISTS(UP)
             else if (BUTTON_PRESSED(UP)) {
-              encoderDiff = -(ENCODER_UD_STEPS);
+              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(DWN)
             else if (BUTTON_PRESSED(DWN)) {
-              encoderDiff = ENCODER_UD_STEPS;
+              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(LFT)
             else if (BUTTON_PRESSED(LFT)) {
-              encoderDiff = -(ENCODER_LR_PULSES);
+              encoderDiff = -pulses;
               next_button_update_ms = now + 300;
             }
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
-              encoderDiff = ENCODER_LR_PULSES;
+              encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // LCD_HAS_DIRECTIONAL_BUTTONS
 
-        buttons = newbutton;
-        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-          buttons |= slow_buttons;
-        #endif
+        buttons = newbutton
+          #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+            | slow_buttons
+          #endif
+        ;
 
         #if ENABLED(ADC_KEYPAD)
 
           uint8_t newbutton_reprapworld_keypad = 0;
           buttons = 0;
           if (buttons_reprapworld_keypad == 0) {
             newbutton_reprapworld_keypad = get_ADC_keyValue();
             if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
               buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
           }
 
         #elif ENABLED(REPRAPWORLD_KEYPAD)
 
           GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
 
         #endif
 
-      #else // !NEWPANEL
+      #else // !HAS_DIGITAL_ENCODER
 
         GET_SHIFT_BUTTON_STATES(buttons);
 
       #endif
 
     } // next_button_update_ms
 
     // Manage encoder rotation
-    #if ENABLED(REVERSE_MENU_DIRECTION) && ENABLED(REVERSE_ENCODER_DIRECTION)
-      #define ENCODER_DIFF_CW  (encoderDiff -= encoderDirection)
-      #define ENCODER_DIFF_CCW (encoderDiff += encoderDirection)
-    #elif ENABLED(REVERSE_MENU_DIRECTION)
-      #define ENCODER_DIFF_CW  (encoderDiff += encoderDirection)
-      #define ENCODER_DIFF_CCW (encoderDiff -= encoderDirection)
-    #elif ENABLED(REVERSE_ENCODER_DIRECTION)
-      #define ENCODER_DIFF_CW  (encoderDiff--)
-      #define ENCODER_DIFF_CCW (encoderDiff++)
-    #else
-      #define ENCODER_DIFF_CW  (encoderDiff++)
-      #define ENCODER_DIFF_CCW (encoderDiff--)
-    #endif
-    #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: ENCODER_DIFF_CW; break; case _E2: ENCODER_DIFF_CCW; }
+    #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 
     uint8_t enc = 0;
     if (buttons & EN_A) enc |= B01;
     if (buttons & EN_B) enc |= B10;
     if (enc != lastEncoderBits) {
       switch (enc) {
         case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
         case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
         case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
         case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
       }
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        if (lcd_external_control) {
+      if (external_control) {
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
-          encoderDiff = 0;                  // Hide the encoder event from the current screen handler.
-        }
-      #endif
+        #endif
+        encoderDiff = 0;                    // Hide the encoder event from the current screen handler.
+      }
       lastEncoderBits = enc;
     }
   }
 
-#endif // HAS_LCD_MENU
+  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+
+    uint8_t MarlinUI::read_slow_buttons() {
+      #if ENABLED(LCD_I2C_TYPE_MCP23017)
+        // Reading these buttons this is likely to be too slow to call inside interrupt context
+        // so they are called during normal lcd_update
+        uint8_t slow_bits = lcd.readButtons() << B_I2C_BTN_OFFSET;
+        #if ENABLED(LCD_I2C_VIKI)
+          if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
+            slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
+        #endif // LCD_I2C_VIKI
+        return slow_bits;
+      #endif // LCD_I2C_TYPE_MCP23017
+    }
+
+  #endif // LCD_HAS_SLOW_BUTTONS
+
+#endif // HAS_ENCODER_ACTION
 
-#endif // ULTRA_LCD
+#endif // HAS_SPI_LCD

commit 6093df11dc91273764d0bf5607fa4314391793a2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 10 18:07:38 2018 -0600

    Allow G26 to use the active extruder (#12387)
    
    * Make lcd_quick_feedback argument optional
    * Add click_to_cancel option to wait_for_hotend/bed
    * Have G26 use the active nozzle and wait_for_hotend/bed
    * Use wait_for_release in UBL G29
    * Add 'T' parameter to G26 for an initial tool-change

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7cb7eaec9a..14b8e0d1a4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -237,22 +237,22 @@ bool lcd_blink() {
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
       #if HAS_ENCODER_ACTION
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         if (encoderDirection == -1) { // side effect which signals we are inside a menu
           #if HAS_LCD_MENU
             if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
             else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); lcd_quick_feedback(true); }
-            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(true); }
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); lcd_quick_feedback(); }
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(); }
           #endif
         }
         else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
         else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
         else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
       #endif
       next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
       return true;
     }
 
@@ -477,21 +477,21 @@ void kill_screen(PGM_P lcd_msg) {
 #if HAS_BUZZER
   void lcd_buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
-void lcd_quick_feedback(const bool clear_buttons) {
+void lcd_quick_feedback(const bool clear_buttons/*=true*/) {
 
   #if HAS_LCD_MENU
     lcd_refresh();
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
   // Buzz and wait. The delay is needed for buttons to settle!
@@ -654,28 +654,28 @@ void lcd_update() {
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED()) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
-        lcd_quick_feedback(true);        //  Always make a click sound
+        lcd_quick_feedback();        //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED) {
-        lcd_quick_feedback(true);
+        lcd_quick_feedback();
         lcd_goto_previous_menu();
       }
     #endif
 
   #endif // HAS_LCD_MENU
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && lcd_detected()) {

commit 4ed6397e5df428c1b6881fe0780e098362f40b0f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 9 00:07:16 2018 -0600

    More comprehensive NO_LCD_MENUS (#12367)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 572e55ff9a..7cb7eaec9a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -107,45 +107,54 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
   bool drawing_screen, first_page; // = false
 #endif
 
-#if ENABLED(ENCODER_RATE_MULTIPLIER)
-  bool encoderRateMultiplierEnabled;
-#endif
-
-#if ENABLED(REVERSE_MENU_DIRECTION)
-  int8_t encoderDirection = 1;
+// Encoder Handling
+#if HAS_ENCODER_ACTION
+  uint32_t encoderPosition;
+  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
+  #if ENABLED(ENCODER_RATE_MULTIPLIER)
+    bool encoderRateMultiplierEnabled;
+  #endif
+  #if ENABLED(REVERSE_MENU_DIRECTION)
+    int8_t encoderDirection = 1;
+  #endif
 #endif
 
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
   screenFunc_t currentScreen = lcd_status_screen;
 
-  // Encoder Handling
-  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
-  uint32_t encoderPosition;
-  millis_t lastEncoderMovementMillis = 0;
+  #if ENABLED(ENCODER_RATE_MULTIPLIER)
+    millis_t lastEncoderMovementMillis = 0;
+  #endif
+
   bool lcd_clicked, wait_for_unclick;
   float move_menu_scale;
 
   bool use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
+
+#else
+
+  constexpr bool lcd_clicked = false;
+
 #endif
 
 void lcd_init() {
 
   lcd_implementation_init();
 
   #if ENABLED(NEWPANEL)
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
@@ -193,21 +202,21 @@ void lcd_init() {
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
   lcd_buttons_update();
 
-  #if HAS_LCD_MENU
+  #if HAS_ENCODER_ACTION
     encoderDiff = 0;
   #endif
 }
 
 bool lcd_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
@@ -222,86 +231,100 @@ bool lcd_blink() {
 
 #if ENABLED(REPRAPWORLD_KEYPAD)
   volatile uint8_t buttons_reprapworld_keypad;
 #endif
 
 #if ENABLED(ADC_KEYPAD)
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      if (encoderDirection == -1) { // side effect which signals we are inside a menu
-        if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_action_back();     lcd_quick_feedback(true); }
-        else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(true); }
-      }
-      else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
-      else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
-      else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
-
+      #if HAS_ENCODER_ACTION
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        if (encoderDirection == -1) { // side effect which signals we are inside a menu
+          #if HAS_LCD_MENU
+            if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_item_back::action(); lcd_quick_feedback(true); }
+            else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(true); }
+          #endif
+        }
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
+      #endif
       next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
       return true;
     }
 
     return false;
   }
 
 #elif ENABLED(REPRAPWORLD_KEYPAD)
 
-  void lcd_move_x();
-  void lcd_move_y();
-  void lcd_move_z();
-
-  void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
-    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-    encoderPosition = dir;
-    switch (axis) {
-      case X_AXIS: lcd_move_x(); break;
-      case Y_AXIS: lcd_move_y(); break;
-      case Z_AXIS: lcd_move_z();
-      default: break;
+  #if HAS_LCD_MENU
+
+    void lcd_move_x();
+    void lcd_move_y();
+    void lcd_move_z();
+
+    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      encoderPosition = dir;
+      switch (axis) {
+        case X_AXIS: lcd_move_x(); break;
+        case Y_AXIS: lcd_move_y(); break;
+        case Z_AXIS: lcd_move_z();
+        default: break;
+      }
     }
-  }
+
+  #endif
 
   inline void handle_reprapworld_keypad() {
 
     static uint8_t keypad_debounce = 0;
 
     if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
             | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
             | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
             | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
     ) {
       if (keypad_debounce > 0) keypad_debounce--;
     }
     else if (!keypad_debounce) {
       keypad_debounce = 2;
 
-      if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  lcd_goto_screen(menu_move);
+      const bool homed = all_axes_homed();
 
-      #if DISABLED(DELTA) && Z_HOME_DIR == -1
-        if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
-      #endif
+      #if HAS_LCD_MENU
 
-      if (all_axes_homed()) {
-        #if ENABLED(DELTA) || Z_HOME_DIR != -1
-          if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  lcd_goto_screen(menu_move);
+
+        #if DISABLED(DELTA) && Z_HOME_DIR == -1
+          if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
         #endif
-        if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
-        if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
-        if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
-        if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
-        if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
-      }
-      else if (RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
+
+        if (homed) {
+          #if ENABLED(DELTA) || Z_HOME_DIR != -1
+            if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+          #endif
+          if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+          if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+          if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+          if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+          if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
+        }
+
+      #endif // HAS_LCD_MENU
+
+      if (!homed && RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
     }
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
@@ -380,46 +403,48 @@ void lcd_status_screen() {
 
     if (use_click()) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
       lcd_goto_screen(menu_main);
       lcd_implementation_init(); // May revive the LCD if static electricity killed it
       return;
     }
 
-    #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
-      const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
-      // Dead zone at 100% feedrate
-      if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
-        feedrate_percentage = 100;
+  #endif // HAS_LCD_MENU
+
+  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+
+    const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
+    // Dead zone at 100% feedrate
+    if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
+      feedrate_percentage = 100;
+      encoderPosition = 0;
+    }
+    else if (feedrate_percentage == 100) {
+      if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
+        feedrate_percentage += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
         encoderPosition = 0;
       }
-      else if (feedrate_percentage == 100) {
-        if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
-          feedrate_percentage += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
-          encoderPosition = 0;
-        }
-        else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE)) {
-          feedrate_percentage += (int32_t)encoderPosition + ENCODER_FEEDRATE_DEADZONE;
-          encoderPosition = 0;
-        }
-      }
-      else {
-        feedrate_percentage = new_frm;
+      else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE)) {
+        feedrate_percentage += (int32_t)encoderPosition + ENCODER_FEEDRATE_DEADZONE;
         encoderPosition = 0;
       }
-    #endif // ULTIPANEL_FEEDMULTIPLY
+    }
+    else {
+      feedrate_percentage = new_frm;
+      encoderPosition = 0;
+    }
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
-  #endif // HAS_LCD_MENU
+  #endif // ULTIPANEL_FEEDMULTIPLY
 
   #if LCD_INFO_SCREEN_STYLE == 0
     lcd_impl_status_screen_0();
   #elif LCD_INFO_SCREEN_STYLE == 1
     lcd_impl_status_screen_1();
   #endif
 }
 
 /**
  * Reset the status message
@@ -587,20 +612,30 @@ void lcd_quick_feedback(const bool clear_buttons) {
 LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
 #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
   bool lcd_external_control; // = false
 #endif
 
 #if ENABLED(LCD_HAS_SLOW_BUTTONS)
   volatile uint8_t slow_buttons;
 #endif
 
+bool lcd_detected() {
+  return
+    #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
+      lcd.LcdDetected() == 1
+    #else
+      true
+    #endif
+  ;
+}
+
 void lcd_update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
 
   #if HAS_LCD_MENU
 
     #if LCD_TIMEOUT_TO_STATUS
       static millis_t return_to_status_ms = 0;
     #endif
@@ -686,40 +721,45 @@ void lcd_update() {
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       lcd_implementation_update_indicators();
     #endif
 
     #if HAS_LCD_MENU
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
         slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
       #endif
 
+    #endif // HAS_LCD_MENU
+
+    #if HAS_ENCODER_ACTION
+
       #if ENABLED(ADC_KEYPAD)
 
         if (handle_adc_keypad()) {
-          #if LCD_TIMEOUT_TO_STATUS
+          #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
             return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
           #endif
         }
 
       #elif ENABLED(REPRAPWORLD_KEYPAD)
 
         handle_reprapworld_keypad();
 
       #endif
 
       const bool encoderPastThreshold = (ABS(encoderDiff) >= ENCODER_PULSES_PER_STEP);
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
-          int32_t encoderMultiplier = 1;
 
-          #if ENABLED(ENCODER_RATE_MULTIPLIER)
+          #if HAS_LCD_MENU && ENABLED(ENCODER_RATE_MULTIPLIER)
+
+            int32_t encoderMultiplier = 1;
 
             if (encoderRateMultiplierEnabled) {
               int32_t encoderMovementSteps = ABS(encoderDiff) / ENCODER_PULSES_PER_STEP;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
@@ -730,32 +770,37 @@ void lcd_update() {
                   SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
                   SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
                   SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
                   SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
                   SERIAL_EOL();
                 #endif
               }
 
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
+
+          #else
+
+            constexpr int32_t encoderMultiplier = 1;
+
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
-        #if LCD_TIMEOUT_TO_STATUS
+        #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
-    #endif // HAS_LCD_MENU
+    #endif
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (
       #if HAS_LCD_MENU
         currentScreen == lcd_status_screen &&
       #endif
       !lcd_status_update_delay--
     ) {
       lcd_status_update_delay = 9
@@ -1032,26 +1077,20 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     WRITE(SHIFT_LD, LOW); \
     WRITE(SHIFT_LD, HIGH); \
     for (int8_t i = 0; i < 8; i++) { \
       new_##DST >>= 1; \
       if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
       WRITE(SHIFT_CLK, HIGH); \
       WRITE(SHIFT_CLK, LOW); \
     } \
     DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
 
-  #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
-    bool lcd_detected() { return lcd.LcdDetected() == 1; }
-  #else
-    bool lcd_detected() { return true; }
-  #endif
-
   #if ENABLED(G26_MESH_VALIDATION)
     void lcd_chirp() {
       lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     }
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
     bool is_lcd_clicked() { return LCD_CLICKED(); }
     void wait_for_release() {
       while (is_lcd_clicked()) safe_delay(50);

commit 488a17b3f5224ccd50f0cbc916a1e7c7ccf1ad6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 20:52:39 2018 -0600

    Use IS_SD_PRINTING() more

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f0e5b88f84..572e55ff9a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -425,21 +425,21 @@ void lcd_status_screen() {
  * Reset the status message
  */
 void lcd_reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   PGM_P msg;
   if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
-    else if (card.sdprinting)
+    else if (IS_SD_PRINTING())
       return lcd_setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
   lcd_setstatusPGM(msg, -1);
 }
 

commit 3866aeac5290eda03b7f4847e7ec69e5b39bb7d0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 01:23:23 2018 -0600

    Clean up ENCODER_RATE_MULTIPLIER config

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 01b25d8ceb..f0e5b88f84 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -725,21 +725,21 @@ void lcd_update() {
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
                   SERIAL_ECHO_START();
                   SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
                   SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
                   SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
                   SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
                   SERIAL_EOL();
-                #endif // ENCODER_RATE_MULTIPLIER_DEBUG
+                #endif
               }
 
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
         #if LCD_TIMEOUT_TO_STATUS

commit 8014e1cc9d50f06862bc0dfb669a128a9d3f5b60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 18:06:00 2018 -0600

    Allow disable of LCD_TIMEOUT_TO_STATUS (when 0)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2006ab37c9..01b25d8ceb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -593,21 +593,24 @@ LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 #if ENABLED(LCD_HAS_SLOW_BUTTONS)
   volatile uint8_t slow_buttons;
 #endif
 
 void lcd_update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
 
   #if HAS_LCD_MENU
-    static millis_t return_to_status_ms = 0;
+
+    #if LCD_TIMEOUT_TO_STATUS
+      static millis_t return_to_status_ms = 0;
+    #endif
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for LCD_CLICKED(), etc.
     // After state changes the next button update
     // may be delayed 300-500ms.
     lcd_buttons_update();
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -685,22 +688,25 @@ void lcd_update() {
     #endif
 
     #if HAS_LCD_MENU
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
         slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
       #endif
 
       #if ENABLED(ADC_KEYPAD)
 
-        if (handle_adc_keypad())
-          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        if (handle_adc_keypad()) {
+          #if LCD_TIMEOUT_TO_STATUS
+            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+          #endif
+        }
 
       #elif ENABLED(REPRAPWORLD_KEYPAD)
 
         handle_reprapworld_keypad();
 
       #endif
 
       const bool encoderPastThreshold = (ABS(encoderDiff) >= ENCODER_PULSES_PER_STEP);
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
@@ -729,21 +735,23 @@ void lcd_update() {
                 #endif // ENCODER_RATE_MULTIPLIER_DEBUG
               }
 
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
-        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        #if LCD_TIMEOUT_TO_STATUS
+          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        #endif
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
     #endif // HAS_LCD_MENU
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (
       #if HAS_LCD_MENU
         currentScreen == lcd_status_screen &&
@@ -759,21 +767,23 @@ void lcd_update() {
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
 
     #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_sdcard && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
-        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        #if LCD_TIMEOUT_TO_STATUS
+          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        #endif
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if HAS_GRAPHICAL_LCD
       const bool &is_drawing = drawing_screen;
     #else
       constexpr bool is_drawing = false;
@@ -841,29 +851,27 @@ void lcd_update() {
 
       #if HAS_LCD_MENU
         lcd_clicked = false;
       #endif
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
-    #if HAS_LCD_MENU
-
+    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
-
-    #endif // HAS_LCD_MENU
+    #endif
 
     // Change state of drawing flag between screen updates
     if (!is_drawing) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
         lcd_implementation_clear(); break;
       case LCDVIEW_REDRAW_NOW:
         lcdDrawUpdate = LCDVIEW_NONE;
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:

commit 5ba6607181470006c5903e414c678506ca81b22d
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Nov 3 04:29:32 2018 +0100

    Fix keypad-related compile error (#12306)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6f706d36ce..2006ab37c9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -217,150 +217,91 @@ bool lcd_blink() {
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
 #if ENABLED(REPRAPWORLD_KEYPAD)
   volatile uint8_t buttons_reprapworld_keypad;
 #endif
 
-#if ENABLED(REPRAPWORLD_KEYPAD) || ENABLED(ADC_KEYPAD)
-  #define REPRAPWORLD_BTN_OFFSET         0 // bit offset into buttons for shift register values
-
-  #define BLEN_REPRAPWORLD_KEYPAD_F3     0
-  #define BLEN_REPRAPWORLD_KEYPAD_F2     1
-  #define BLEN_REPRAPWORLD_KEYPAD_F1     2
-
-  #define BLEN_REPRAPWORLD_KEYPAD_DOWN   3
-  #define BLEN_REPRAPWORLD_KEYPAD_RIGHT  4
-  #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
-  #define BLEN_REPRAPWORLD_KEYPAD_UP     6
-  #define BLEN_REPRAPWORLD_KEYPAD_LEFT   7
-  #define EN_REPRAPWORLD_KEYPAD_DOWN     (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_DOWN))
-  #define EN_REPRAPWORLD_KEYPAD_RIGHT    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_RIGHT))
-  #define EN_REPRAPWORLD_KEYPAD_MIDDLE   (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
-  #define EN_REPRAPWORLD_KEYPAD_UP       (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_UP))
-  #define EN_REPRAPWORLD_KEYPAD_LEFT     (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_LEFT))
-  
-#endif // REPRAPWORLD_KEYPAD || ADC_KEYPAD
-
 #if ENABLED(ADC_KEYPAD)
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       if (encoderDirection == -1) { // side effect which signals we are inside a menu
-        if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(true); }
-        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(true); }
+        if      (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))   { menu_action_back();     lcd_quick_feedback(true); }
+        else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))  { lcd_return_to_status(); lcd_quick_feedback(true); }
       }
-      else {
-        if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
-               if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
-        }
-      }
-      #if ENABLED(ADC_KEYPAD_DEBUG)
-        SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
-        SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
-      #endif
+      else if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))     encoderPosition += ENCODER_PULSES_PER_STEP;
+      else if (RRK(EN_REPRAPWORLD_KEYPAD_UP))       encoderPosition -= ENCODER_PULSES_PER_STEP;
+      else if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT))    encoderPosition = 0;
+
       next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
       return true;
     }
 
     return false;
   }
 
 #elif ENABLED(REPRAPWORLD_KEYPAD)
 
-  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_F1
-  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_MIDDLE
-
-  #define EN_REPRAPWORLD_KEYPAD_F1        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F1))
-  #define EN_REPRAPWORLD_KEYPAD_F2        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F2))
-  #define EN_REPRAPWORLD_KEYPAD_F3        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F3))
-  
-  #define REPRAPWORLD_KEYPAD_MOVE_Z_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F2)
-  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F3)
-  #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)
-  #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT)
-  #define REPRAPWORLD_KEYPAD_MOVE_Y_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)
-  #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)
-
-  #define REPRAPWORLD_KEYPAD_MOVE_HOME    (buttons_reprapworld_keypad & KEYPAD_HOME)
-  #define REPRAPWORLD_KEYPAD_MOVE_MENU    (buttons_reprapworld_keypad & KEYPAD_EN_C)
-
-  #define REPRAPWORLD_KEYPAD_PRESSED      (buttons_reprapworld_keypad & ( \
-                                            EN_REPRAPWORLD_KEYPAD_F1 | \
-                                            EN_REPRAPWORLD_KEYPAD_F2 | \
-                                            EN_REPRAPWORLD_KEYPAD_F3 | \
-                                            EN_REPRAPWORLD_KEYPAD_DOWN | \
-                                            EN_REPRAPWORLD_KEYPAD_RIGHT | \
-                                            EN_REPRAPWORLD_KEYPAD_MIDDLE | \
-                                            EN_REPRAPWORLD_KEYPAD_UP | \
-                                            EN_REPRAPWORLD_KEYPAD_LEFT) \
-                                          )
-
   void lcd_move_x();
   void lcd_move_y();
   void lcd_move_z();
 
   void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
     encoderPosition = dir;
     switch (axis) {
       case X_AXIS: lcd_move_x(); break;
       case Y_AXIS: lcd_move_y(); break;
       case Z_AXIS: lcd_move_z();
       default: break;
     }
   }
-  inline void reprapworld_keypad_move_z_up()    { _reprapworld_keypad_move(Z_AXIS,  1); }
-  inline void reprapworld_keypad_move_z_down()  { _reprapworld_keypad_move(Z_AXIS, -1); }
-  inline void reprapworld_keypad_move_x_left()  { _reprapworld_keypad_move(X_AXIS, -1); }
-  inline void reprapworld_keypad_move_x_right() { _reprapworld_keypad_move(X_AXIS,  1); }
-  inline void reprapworld_keypad_move_y_up()    { _reprapworld_keypad_move(Y_AXIS, -1); }
-  inline void reprapworld_keypad_move_y_down()  { _reprapworld_keypad_move(Y_AXIS,  1); }
-  inline void reprapworld_keypad_move_home()    { enqueue_and_echo_commands_P(PSTR("G28")); } // move all axes home and wait
-  inline void reprapworld_keypad_move_menu()    { lcd_goto_screen(menu_move); }
 
   inline void handle_reprapworld_keypad() {
 
     static uint8_t keypad_debounce = 0;
 
-    if (!REPRAPWORLD_KEYPAD_PRESSED) {
+    if (!RRK( EN_REPRAPWORLD_KEYPAD_F1    | EN_REPRAPWORLD_KEYPAD_F2
+            | EN_REPRAPWORLD_KEYPAD_F3    | EN_REPRAPWORLD_KEYPAD_DOWN
+            | EN_REPRAPWORLD_KEYPAD_RIGHT | EN_REPRAPWORLD_KEYPAD_MIDDLE
+            | EN_REPRAPWORLD_KEYPAD_UP    | EN_REPRAPWORLD_KEYPAD_LEFT )
+    ) {
       if (keypad_debounce > 0) keypad_debounce--;
     }
     else if (!keypad_debounce) {
       keypad_debounce = 2;
 
-      if (REPRAPWORLD_KEYPAD_MOVE_MENU)       reprapworld_keypad_move_menu();
+      if (RRK(EN_REPRAPWORLD_KEYPAD_MIDDLE))  lcd_goto_screen(menu_move);
 
       #if DISABLED(DELTA) && Z_HOME_DIR == -1
-        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
+        if (RRK(EN_REPRAPWORLD_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
       #endif
 
       if (all_axes_homed()) {
         #if ENABLED(DELTA) || Z_HOME_DIR != -1
-          if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
+          if (RRK(EN_REPRAPWORLD_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
         #endif
-        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
-        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
-        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
-        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
-        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
+        if (RRK(EN_REPRAPWORLD_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+        if (RRK(EN_REPRAPWORLD_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
       }
-      else if (REPRAPWORLD_KEYPAD_MOVE_HOME)  reprapworld_keypad_move_home();
+      else if (RRK(EN_REPRAPWORLD_KEYPAD_F1)) enqueue_and_echo_commands_P(PSTR("G28"));
     }
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
@@ -1031,36 +972,33 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;
 
   static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
     // VALUE_MIN, VALUE_MAX, KEY
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F1 + 1 },     // F1
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F2 + 1 },     // F2
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F3 + 1 },     // F3
-    {  300,  500, BLEN_REPRAPWORLD_KEYPAD_LEFT + 1 },   // LEFT
-    { 1900, 2200, BLEN_REPRAPWORLD_KEYPAD_RIGHT + 1 },  // RIGHT
-    {  570,  870, BLEN_REPRAPWORLD_KEYPAD_UP + 1 },     // UP
-    { 2670, 2870, BLEN_REPRAPWORLD_KEYPAD_DOWN + 1 },   // DOWN
-    { 1150, 1450, BLEN_REPRAPWORLD_KEYPAD_MIDDLE + 1 }, // ENTER
+    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F1     }, // F1
+    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F2     }, // F2
+    { 4000, 4096, 1 + BLEN_REPRAPWORLD_KEYPAD_F3     }, // F3
+    {  300,  500, 1 + BLEN_REPRAPWORLD_KEYPAD_LEFT   }, // LEFT
+    { 1900, 2200, 1 + BLEN_REPRAPWORLD_KEYPAD_RIGHT  }, // RIGHT
+    {  570,  870, 1 + BLEN_REPRAPWORLD_KEYPAD_UP     }, // UP
+    { 2670, 2870, 1 + BLEN_REPRAPWORLD_KEYPAD_DOWN   }, // DOWN
+    { 1150, 1450, 1 + BLEN_REPRAPWORLD_KEYPAD_MIDDLE }, // ENTER
   };
 
   uint8_t get_ADC_keyValue(void) {
     if (thermalManager.ADCKey_count >= 16) {
       const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
-      #if ENABLED(ADC_KEYPAD_DEBUG)
-        SERIAL_PROTOCOLLN(currentkpADCValue);
-      #endif
       thermalManager.current_ADCKey_raw = 0;
       thermalManager.ADCKey_count = 0;
       if (currentkpADCValue < 4000)
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;

commit 9f77df25900c22181de1170c4c81f10b4c1b885e
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Thu Nov 1 22:13:33 2018 +0100

    Followup to menu refactor. TMC warnings, sanity. (#12288)
    
    - Followup fixes for menu refactor
    - Fix TMC sanity checks, unused var warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4c246b7ae0..6f706d36ce 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -217,24 +217,41 @@ bool lcd_blink() {
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
 #if ENABLED(REPRAPWORLD_KEYPAD)
   volatile uint8_t buttons_reprapworld_keypad;
 #endif
 
-#if ENABLED(ADC_KEYPAD)
+#if ENABLED(REPRAPWORLD_KEYPAD) || ENABLED(ADC_KEYPAD)
+  #define REPRAPWORLD_BTN_OFFSET         0 // bit offset into buttons for shift register values
 
-  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_F1
-  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_MIDDLE
+  #define BLEN_REPRAPWORLD_KEYPAD_F3     0
+  #define BLEN_REPRAPWORLD_KEYPAD_F2     1
+  #define BLEN_REPRAPWORLD_KEYPAD_F1     2
+
+  #define BLEN_REPRAPWORLD_KEYPAD_DOWN   3
+  #define BLEN_REPRAPWORLD_KEYPAD_RIGHT  4
+  #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
+  #define BLEN_REPRAPWORLD_KEYPAD_UP     6
+  #define BLEN_REPRAPWORLD_KEYPAD_LEFT   7
+  #define EN_REPRAPWORLD_KEYPAD_DOWN     (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_DOWN))
+  #define EN_REPRAPWORLD_KEYPAD_RIGHT    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_RIGHT))
+  #define EN_REPRAPWORLD_KEYPAD_MIDDLE   (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
+  #define EN_REPRAPWORLD_KEYPAD_UP       (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_UP))
+  #define EN_REPRAPWORLD_KEYPAD_LEFT     (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_LEFT))
+  
+#endif // REPRAPWORLD_KEYPAD || ADC_KEYPAD
+
+#if ENABLED(ADC_KEYPAD)
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       if (encoderDirection == -1) { // side effect which signals we are inside a menu
         if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
         else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
         else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(true); }
         else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(true); }
@@ -252,63 +269,52 @@ bool lcd_blink() {
       #endif
       next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
       return true;
     }
 
     return false;
   }
 
 #elif ENABLED(REPRAPWORLD_KEYPAD)
 
-  #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
-
-  #define BLEN_REPRAPWORLD_KEYPAD_F3     0
-  #define BLEN_REPRAPWORLD_KEYPAD_F2     1
-  #define BLEN_REPRAPWORLD_KEYPAD_F1     2
-  #define BLEN_REPRAPWORLD_KEYPAD_DOWN   3
-  #define BLEN_REPRAPWORLD_KEYPAD_RIGHT  4
-  #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
-  #define BLEN_REPRAPWORLD_KEYPAD_UP     6
-  #define BLEN_REPRAPWORLD_KEYPAD_LEFT   7
-
-  #define EN_REPRAPWORLD_KEYPAD_F3      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F3))
-  #define EN_REPRAPWORLD_KEYPAD_F2      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F2))
-  #define EN_REPRAPWORLD_KEYPAD_F1      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F1))
-  #define EN_REPRAPWORLD_KEYPAD_DOWN    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_DOWN))
-  #define EN_REPRAPWORLD_KEYPAD_RIGHT   (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_RIGHT))
-  #define EN_REPRAPWORLD_KEYPAD_MIDDLE  (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
-  #define EN_REPRAPWORLD_KEYPAD_UP      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_UP))
-  #define EN_REPRAPWORLD_KEYPAD_LEFT    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_LEFT))
+  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_F1
+  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_MIDDLE
 
-  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F3)
+  #define EN_REPRAPWORLD_KEYPAD_F1        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F1))
+  #define EN_REPRAPWORLD_KEYPAD_F2        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F2))
+  #define EN_REPRAPWORLD_KEYPAD_F3        (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F3))
+  
   #define REPRAPWORLD_KEYPAD_MOVE_Z_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F2)
+  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F3)
   #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)
   #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT)
   #define REPRAPWORLD_KEYPAD_MOVE_Y_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)
   #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)
 
-  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_MIDDLE
-  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_F1
   #define REPRAPWORLD_KEYPAD_MOVE_HOME    (buttons_reprapworld_keypad & KEYPAD_HOME)
   #define REPRAPWORLD_KEYPAD_MOVE_MENU    (buttons_reprapworld_keypad & KEYPAD_EN_C)
 
   #define REPRAPWORLD_KEYPAD_PRESSED      (buttons_reprapworld_keypad & ( \
-                                            EN_REPRAPWORLD_KEYPAD_F3 | \
-                                            EN_REPRAPWORLD_KEYPAD_F2 | \
                                             EN_REPRAPWORLD_KEYPAD_F1 | \
+                                            EN_REPRAPWORLD_KEYPAD_F2 | \
+                                            EN_REPRAPWORLD_KEYPAD_F3 | \
                                             EN_REPRAPWORLD_KEYPAD_DOWN | \
                                             EN_REPRAPWORLD_KEYPAD_RIGHT | \
                                             EN_REPRAPWORLD_KEYPAD_MIDDLE | \
                                             EN_REPRAPWORLD_KEYPAD_UP | \
                                             EN_REPRAPWORLD_KEYPAD_LEFT) \
                                           )
 
+  void lcd_move_x();
+  void lcd_move_y();
+  void lcd_move_z();
+
   void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
     move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
     encoderPosition = dir;
     switch (axis) {
       case X_AXIS: lcd_move_x(); break;
       case Y_AXIS: lcd_move_y(); break;
       case Z_AXIS: lcd_move_z();
       default: break;
     }
   }
@@ -340,23 +346,21 @@ bool lcd_blink() {
       if (all_axes_homed()) {
         #if ENABLED(DELTA) || Z_HOME_DIR != -1
           if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
         #endif
         if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
         if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
         if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
         if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
         if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
       }
-      else {
-        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
-      }
+      else if (REPRAPWORLD_KEYPAD_MOVE_HOME)  reprapworld_keypad_move_home();
     }
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */

commit eb5600acd2bfcd141022fb49c0b43e3eb46dcdfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 1 15:05:59 2018 -0500

    Add parentheses to LCD_CLICKED

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e6452b2acf..4c246b7ae0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -653,34 +653,34 @@ void lcd_update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
 
   #if HAS_LCD_MENU
     static millis_t return_to_status_ms = 0;
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
-    // Update button states for LCD_CLICKED, etc.
+    // Update button states for LCD_CLICKED(), etc.
     // After state changes the next button update
     // may be delayed 300-500ms.
     lcd_buttons_update();
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       // Don't run the debouncer if UBL owns the display
       #define UBL_CONDITION !lcd_external_control
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
-    if (UBL_CONDITION && LCD_CLICKED) {
+    if (UBL_CONDITION && LCD_CLICKED()) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback(true);        //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
@@ -1095,21 +1095,21 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     bool lcd_detected() { return true; }
   #endif
 
   #if ENABLED(G26_MESH_VALIDATION)
     void lcd_chirp() {
       lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     }
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-    bool is_lcd_clicked() { return LCD_CLICKED; }
+    bool is_lcd_clicked() { return LCD_CLICKED(); }
     void wait_for_release() {
       while (is_lcd_clicked()) safe_delay(50);
       safe_delay(50);
     }
   #endif
 
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6d67683bcb..e6452b2acf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -42,21 +42,21 @@
 #include "../module/tool_change.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     void menu_job_recovery();
   #endif
 #endif
 
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
@@ -93,21 +93,21 @@ volatile uint8_t buttons;
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
 #endif
 
-#if ENABLED(SDSUPPORT) && ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
+#if HAS_LCD_MENU && ENABLED(SDSUPPORT) && ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
@@ -115,22 +115,20 @@ millis_t next_button_update_ms;
 #endif
 
 #if ENABLED(ENCODER_RATE_MULTIPLIER)
   bool encoderRateMultiplierEnabled;
 #endif
 
 #if ENABLED(REVERSE_MENU_DIRECTION)
   int8_t encoderDirection = 1;
 #endif
 
-void lcd_status_screen();
-
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
   screenFunc_t currentScreen = lcd_status_screen;
 
   // Encoder Handling
   volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
   uint32_t encoderPosition;
   millis_t lastEncoderMovementMillis = 0;
   bool lcd_clicked, wait_for_unclick;
@@ -195,21 +193,21 @@ void lcd_init() {
     SET_INPUT_PULLUP(SD_DETECT_PIN);
     lcd_sd_status = 2; // UNKNOWN
   #endif
 
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
   lcd_buttons_update();
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     encoderDiff = 0;
   #endif
 }
 
 bool lcd_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
@@ -356,34 +354,42 @@ bool lcd_blink() {
   }
 
 #endif // REPRAPWORLD_KEYPAD
 
 /**
  * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
+#if ENABLED(LCD_PROGRESS_BAR)
+  millis_t progress_bar_ms = 0;     // Start millis of the current progress bar cycle
+  #if PROGRESS_MSG_EXPIRE > 0
+    static millis_t expire_status_ms = 0;
+    void dontExpireStatus() { expire_status_ms = 0; }
+  #endif
+#endif
+
 #if LCD_INFO_SCREEN_STYLE == 0
   void lcd_impl_status_screen_0();
 #elif LCD_INFO_SCREEN_STYLE == 1
   void lcd_impl_status_screen_1();
 #endif
 
 void lcd_status_screen() {
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
-  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
+  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || HAS_GRAPHICAL_LCD)
     // Progress bar % comes from SD when actively printing
     if (IS_SD_PRINTING())
       progress_bar_percent = card.percentDone();
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
@@ -418,32 +424,28 @@ void lcd_status_screen() {
           // Defer message expiration before bar appears
           // and during any pause (not just SD)
           expire_status_ms += LCD_UPDATE_INTERVAL;
         }
       }
 
     #endif // PROGRESS_MSG_EXPIRE
 
   #endif // LCD_PROGRESS_BAR
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
 
     if (use_click()) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
-      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
-        #if ENABLED(LCD_PROGRESS_BAR)
-          CHARSET_MENU
-        #endif
-      );
       lcd_goto_screen(menu_main);
+      lcd_implementation_init(); // May revive the LCD if static electricity killed it
       return;
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
       const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
       // Dead zone at 100% feedrate
       if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
         feedrate_percentage = 100;
         encoderPosition = 0;
       }
@@ -458,21 +460,21 @@ void lcd_status_screen() {
         }
       }
       else {
         feedrate_percentage = new_frm;
         encoderPosition = 0;
       }
     #endif // ULTIPANEL_FEEDMULTIPLY
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
-  #endif // ULTIPANEL
+  #endif // HAS_LCD_MENU
 
   #if LCD_INFO_SCREEN_STYLE == 0
     lcd_impl_status_screen_0();
   #elif LCD_INFO_SCREEN_STYLE == 1
     lcd_impl_status_screen_1();
   #endif
 }
 
 /**
  * Reset the status message
@@ -507,41 +509,41 @@ void kill_screen(PGM_P lcd_msg) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #endif
   }
 #endif
 
 void lcd_quick_feedback(const bool clear_buttons) {
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     lcd_refresh();
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
   #else
     UNUSED(clear_buttons);
   #endif
 
   // Buzz and wait. The delay is needed for buttons to settle!
   lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   #endif
 }
 
-#if ENABLED(ULTIPANEL)
+#if HAS_LCD_MENU
 
   extern bool no_reentry; // Flag to prevent recursion into menu handlers
 
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   millis_t manual_move_start_time = 0;
 
   #if IS_KINEMATIC
     bool processing_manual_move = false;
     float manual_move_offset = 0;
   #endif
@@ -595,21 +597,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #else
 
         planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
         manual_move_axis = (int8_t)NO_AXIS;
 
       #endif
     }
   }
 
-#endif // ULTIPANEL
+#endif // HAS_LCD_MENU
 
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position
  *   - Apply acceleration to the encoder position
  *   - Set lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NOW on controller events
  *   - Reset the Info Screen timeout if there's any input
@@ -645,21 +647,21 @@ LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 
 #if ENABLED(LCD_HAS_SLOW_BUTTONS)
   volatile uint8_t slow_buttons;
 #endif
 
 void lcd_update() {
 
   static uint16_t max_display_update_time = 0;
   static millis_t next_lcd_update_ms;
 
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     static millis_t return_to_status_ms = 0;
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for LCD_CLICKED, etc.
     // After state changes the next button update
     // may be delayed 300-500ms.
     lcd_buttons_update();
 
@@ -681,21 +683,21 @@ void lcd_update() {
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED) {
         lcd_quick_feedback(true);
         lcd_goto_previous_menu();
       }
     #endif
 
-  #endif // ULTIPANEL
+  #endif // HAS_LCD_MENU
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
@@ -705,50 +707,46 @@ void lcd_update() {
           card.beginautostart();  // Initial boot
         else
           LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
       lcd_refresh();
-      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
-        #if ENABLED(LCD_PROGRESS_BAR)
-          currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
-        #endif
-      );
+      lcd_implementation_init(); // May revive the LCD if static electricity killed it
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
       lcd_goto_screen(menu_job_recovery);
       job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
     }
   #endif
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
-    #if ENABLED(DOGLCD)
+    #if HAS_GRAPHICAL_LCD
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       lcd_implementation_update_indicators();
     #endif
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
         slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
       #endif
 
       #if ENABLED(ADC_KEYPAD)
 
         if (handle_adc_keypad())
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
 
@@ -790,54 +788,54 @@ void lcd_update() {
             } // encoderRateMultiplierEnabled
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
-    #endif // ULTIPANEL
+    #endif // HAS_LCD_MENU
 
     // This runs every ~100ms when idling often enough.
     // Instead of tracking changes just redraw the Status Screen once per second.
     if (
-      #if ENABLED(ULTIPANEL)
+      #if HAS_LCD_MENU
         currentScreen == lcd_status_screen &&
       #endif
       !lcd_status_update_delay--
     ) {
       lcd_status_update_delay = 9
-        #if ENABLED(DOGLCD)
+        #if HAS_GRAPHICAL_LCD
           + 3
         #endif
       ;
       max_display_update_time--;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
 
-    #if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
+    #if HAS_LCD_MENU && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_sdcard && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
-    #if ENABLED(DOGLCD)
+    #if HAS_GRAPHICAL_LCD
       const bool &is_drawing = drawing_screen;
     #else
       constexpr bool is_drawing = false;
     #endif
 
     if ((lcdDrawUpdate || is_drawing) && (!bbr2 || bbr2 > max_display_update_time)) {
 
       // Change state of drawing flag between screen updates
       if (!is_drawing) switch (lcdDrawUpdate) {
         case LCDVIEW_CALL_NO_REDRAW:
@@ -848,29 +846,29 @@ void lcd_update() {
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
       #if ENABLED(ADC_KEYPAD)
         buttons_reprapworld_keypad = 0;
       #endif
 
-      #if ENABLED(ULTIPANEL)
+      #if HAS_LCD_MENU
         #define CURRENTSCREEN() (*currentScreen)()
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
 
-      #if ENABLED(DOGLCD)
+      #if HAS_GRAPHICAL_LCD
         #if ENABLED(LIGHTWEIGHT_UI)
-          #if ENABLED(ULTIPANEL)
+          #if HAS_LCD_MENU
             const bool in_status = currentScreen == lcd_status_screen;
           #else
             constexpr bool in_status = true;
           #endif
           const bool do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) lcd_status_screen();
         #else
           constexpr bool do_u8g_loop = true;
         #endif
@@ -889,38 +887,38 @@ void lcd_update() {
           // The nextPage will already be set up on the next call.
           if (drawing_screen && (drawing_screen = u8g.nextPage())) {
             NOLESS(max_display_update_time, millis() - ms);
             return;
           }
         }
       #else
         CURRENTSCREEN();
       #endif
 
-      #if ENABLED(ULTIPANEL)
+      #if HAS_LCD_MENU
         lcd_clicked = false;
       #endif
 
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
-    #endif // ULTIPANEL
+    #endif // HAS_LCD_MENU
 
     // Change state of drawing flag between screen updates
     if (!is_drawing) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
         lcd_implementation_clear(); break;
       case LCDVIEW_REDRAW_NOW:
         lcdDrawUpdate = LCDVIEW_NONE;
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
@@ -935,35 +933,32 @@ void lcd_finishstatus(const bool persist=false) {
   #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
     UNUSED(persist);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
     progress_bar_ms = millis();
     #if PROGRESS_MSG_EXPIRE > 0
       expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
     #endif
   #endif
+
   lcd_refresh();
 
   #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
     previous_lcd_status_ms = millis();  //get status message to show up for a while
   #endif
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     status_scroll_offset = 0;
   #endif
 }
 
-#if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
-  void dontExpireStatus() { expire_status_ms = 0; }
-#endif
-
 bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
 
 void lcd_setstatus(const char * const message, const bool persist) {
   if (lcd_status_message_level > 0) return;
 
   // Here we have a problem. The message is encoded in UTF8, so
   // arbitrarily cutting it will be a problem. We MUST be sure
   // that there is no cutting in the middle of a multibyte character!
 
   // Get a pointer to the null terminator
@@ -1016,21 +1011,21 @@ void lcd_status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
   lcd_status_message_level = level;
   va_list args;
   va_start(args, fmt);
   vsnprintf_P(lcd_status_message, MAX_MESSAGE_LENGTH, fmt, args);
   va_end(args);
   lcd_finishstatus(level > 0);
 }
 
 void lcd_setalertstatusPGM(PGM_P const message) {
   lcd_setstatusPGM(message, 1);
-  #if ENABLED(ULTIPANEL)
+  #if HAS_LCD_MENU
     lcd_return_to_status();
   #endif
 }
 
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
@@ -1061,21 +1056,21 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
         for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
           const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                          hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
           if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
         }
     }
     return 0;
   }
 #endif
 
-#if ENABLED(ULTIPANEL)
+#if HAS_LCD_MENU
 
   /**
    * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
    * These values are independent of which pins are used for EN_A and EN_B indications
    * The rotary encoder part is also independent to the chipset used for the LCD
    */
   #if defined(EN_A) && defined(EN_B)
     #define encrot0 0
     #define encrot1 2
     #define encrot2 3
@@ -1245,13 +1240,13 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (lcd_external_control) {
           ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
           encoderDiff = 0;                  // Hide the encoder event from the current screen handler.
         }
       #endif
       lastEncoderBits = enc;
     }
   }
 
-#endif // ULTIPANEL
+#endif // HAS_LCD_MENU
 
 #endif // ULTRA_LCD

commit b063b1b7229c1706690f167a99528e13d4ff371d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 02:59:21 2018 -0500

    Reorganize includes and declarations

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 679cd7bc3f..6d67683bcb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -67,20 +67,23 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
+// Buttons
+volatile uint8_t buttons;
+
 #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
   uint8_t lcd_sd_status;
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   uint8_t status_scroll_offset = 0;
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
@@ -212,20 +215,24 @@ bool lcd_blink() {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 ////////////////////////////////////////////
 ///////////// Keypad Handling //////////////
 ////////////////////////////////////////////
 
+#if ENABLED(REPRAPWORLD_KEYPAD)
+  volatile uint8_t buttons_reprapworld_keypad;
+#endif
+
 #if ENABLED(ADC_KEYPAD)
 
   #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_F1
   #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_MIDDLE
 
   inline bool handle_adc_keypad() {
     #define ADC_MIN_KEY_DELAY 100
     if (buttons_reprapworld_keypad) {
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       if (encoderDirection == -1) { // side effect which signals we are inside a menu

commit a489c9fa52261cd5836771f0f0c5f3dff20f696d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 16:45:37 2018 -0500

    Move Motion Menu to its own file

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 97d574c6a1..679cd7bc3f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -124,20 +124,21 @@ void lcd_status_screen();
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
   screenFunc_t currentScreen = lcd_status_screen;
 
   // Encoder Handling
   volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
   uint32_t encoderPosition;
   millis_t lastEncoderMovementMillis = 0;
   bool lcd_clicked, wait_for_unclick;
+  float move_menu_scale;
 
   bool use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 #endif
 
 void lcd_init() {
 

commit c825c419d4e1d10600148bd7c927bef0fc4c6baa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 24 02:27:19 2018 -0500

    Convert DOGM / HD44780 impl to CPP files

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3f22493b5a..97d574c6a1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -101,43 +101,33 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
   uint8_t filename_scroll_pos, filename_scroll_max;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 millis_t next_button_update_ms;
 
 #if HAS_GRAPHICAL_LCD
-  #include <U8glib.h>
-  #include "dogm/HAL_LCD_class_defines.h"
-  extern U8G_CLASS u8g;
   bool drawing_screen, first_page; // = false
 #endif
 
 #if ENABLED(ENCODER_RATE_MULTIPLIER)
   bool encoderRateMultiplierEnabled;
 #endif
 
 #if ENABLED(REVERSE_MENU_DIRECTION)
   int8_t encoderDirection = 1;
 #endif
 
 void lcd_status_screen();
 
-#if HAS_LCD_CONTRAST
-  void set_lcd_contrast(const int16_t value) {
-    lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
-    u8g.setContrast(lcd_contrast);
-  }
-#endif
-
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
   screenFunc_t currentScreen = lcd_status_screen;
 
   // Encoder Handling
   volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
   uint32_t encoderPosition;
   millis_t lastEncoderMovementMillis = 0;
   bool lcd_clicked, wait_for_unclick;

commit 2bf18950ab2070e842c91057d5812dcaa1bff9a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 16:00:34 2018 -0500

    Refactor LCD menus

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a55e179465..3f22493b5a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -20,686 +20,364 @@
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(ULTRA_LCD)
 
 #include <stdarg.h>
 
 #include "ultralcd.h"
+#include "lcdprint.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
 #include "../module/printcounter.h"
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 #include "../module/tool_change.h"
 
-
 #include "../Marlin.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
+  #if ENABLED(ULTIPANEL)
+    void menu_job_recovery();
+  #endif
 #endif
 
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(LED_CONTROL_MENU)
-  #include "../feature/leds/leds.h"
-#endif
-
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  #include "../feature/runout.h"
-#endif
-
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
+#if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+  uint8_t lcd_sd_status;
+#endif
+
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
+  uint8_t status_scroll_offset = 0;
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
-  uint8_t status_scroll_offset = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
 #endif
 
-#if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
-  uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
+#if ENABLED(SDSUPPORT) && ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
+  uint8_t filename_scroll_pos, filename_scroll_max;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
-#if ENABLED(DOGLCD)
-  #include "ultralcd_impl_DOGM.h"
+millis_t next_button_update_ms;
+
+#if HAS_GRAPHICAL_LCD
+  #include <U8glib.h>
+  #include "dogm/HAL_LCD_class_defines.h"
+  extern U8G_CLASS u8g;
   bool drawing_screen, first_page; // = false
-#else
-  #include "ultralcd_impl_HD44780.h"
-  constexpr bool first_page = true;
 #endif
 
-// The main status screen
-void lcd_status_screen();
+#if ENABLED(ENCODER_RATE_MULTIPLIER)
+  bool encoderRateMultiplierEnabled;
+#endif
 
-LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-uint16_t max_display_update_time = 0;
-millis_t next_lcd_update_ms;
+#if ENABLED(REVERSE_MENU_DIRECTION)
+  int8_t encoderDirection = 1;
+#endif
+
+void lcd_status_screen();
 
 #if HAS_LCD_CONTRAST
   void set_lcd_contrast(const int16_t value) {
     lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
     u8g.setContrast(lcd_contrast);
   }
 #endif
 
-#if ENABLED(ULTIPANEL)
-
-  #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
-    inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
-      UNUSED(pstr2); \
-      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
-    } \
-    inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
-      UNUSED(pstr2); \
-      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
-    } \
-    inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
-      UNUSED(pstr2); UNUSED(pset); \
-      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(pget())); \
-    } \
-    typedef void _name##_void
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int3, itostr3);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int4, itostr4sign);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint8_t, int8, i8tostr3);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float3, ftostr3);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float51, ftostr51sign);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52sign, ftostr52sign);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float62, ftostr62rj);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint32_t, long5, ftostr5rj);
-  #define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data)                    DRAW_BOOL_SETTING(sel, row, pstr, data)
-  #define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) DRAW_BOOL_SETTING(sel, row, pstr, data)
-  #define lcd_implementation_drawmenu_setting_edit_accessor_bool(sel, row, pstr, pstr2, pget, pset)     DRAW_BOOL_SETTING(sel, row, pstr, data)
-
-  #ifndef TALL_FONT_CORRECTION
-    #define TALL_FONT_CORRECTION 0
-  #endif
-
-  bool no_reentry = false;
-  constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
+#if HAS_LCD_MENU
+  #include "menu/menu.h"
 
-  // Initialized by settings.load()
-  int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
-  uint8_t lcd_preheat_fan_speed[2];
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-    bool lcd_external_control; // = false
-  #endif
+  screenFunc_t currentScreen = lcd_status_screen;
 
-  #if ENABLED(BABYSTEPPING)
-    long babysteps_done = 0;
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      static void lcd_babystep_zoffset();
-    #else
-      static void lcd_babystep_z();
-    #endif
-  #endif
+  // Encoder Handling
+  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
+  uint32_t encoderPosition;
+  millis_t lastEncoderMovementMillis = 0;
+  bool lcd_clicked, wait_for_unclick;
 
-  #if ENABLED(DAC_STEPPER_CURRENT)
-    #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
-    uint8_t driverPercent[XYZE];
-  #endif
+  bool use_click() {
+    const bool click = lcd_clicked;
+    lcd_clicked = false;
+    return click;
+  }
+#endif
 
-  ////////////////////////////////////////////
-  ///////////////// Menu Tree ////////////////
-  ////////////////////////////////////////////
-
-  void lcd_main_menu();
-  void lcd_tune_menu();
-  void lcd_movement_menu();
-  void lcd_move_menu();
-  void lcd_configuration_menu();
-  void lcd_temperature_menu();
-  void lcd_advanced_settings_menu();
-
-  #if DISABLED(SLIM_LCD_MENUS)
-    void lcd_configuration_temperature_preheat_material1_settings_menu();
-    void lcd_configuration_temperature_preheat_material2_settings_menu();
-  #endif
+void lcd_init() {
 
-  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-    void lcd_advanced_filament_menu();
-  #endif
+  lcd_implementation_init();
 
-  #if ENABLED(LCD_INFO_MENU)
-    #if ENABLED(PRINTCOUNTER)
-      void lcd_info_stats_menu();
+  #if ENABLED(NEWPANEL)
+    #if BUTTON_EXISTS(EN1)
+      SET_INPUT_PULLUP(BTN_EN1);
     #endif
-    void lcd_info_thermistors_menu();
-    void lcd_info_board_menu();
-    void lcd_info_menu();
-  #endif // LCD_INFO_MENU
-
-  #if ENABLED(LED_CONTROL_MENU)
-    void lcd_led_menu();
-  #endif
-
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      void lcd_change_filament_menu();
-    #else
-      void lcd_temp_menu_e0_filament_change();
+    #if BUTTON_EXISTS(EN2)
+      SET_INPUT_PULLUP(BTN_EN2);
+    #endif
+    #if BUTTON_EXISTS(ENC)
+      SET_INPUT_PULLUP(BTN_ENC);
     #endif
-  #endif
-
-  #if ENABLED(DAC_STEPPER_CURRENT)
-    void dac_driver_commit();
-    void dac_driver_getValues();
-    void lcd_dac_menu();
-    void lcd_dac_write_eeprom();
-  #endif
-
-  #if ENABLED(FWRETRACT)
-    #include "../feature/fwretract.h"
-    void lcd_config_retract_menu();
-  #endif
-
-  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-    void lcd_delta_calibrate_menu();
-  #endif
-
-  #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-    #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
-  #endif
-
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    static float new_z_fade_height;
-    void _lcd_set_z_fade_height() { set_z_fade_height(new_z_fade_height); }
-  #endif
-
-  ////////////////////////////////////////////
-  //////////// Menu System Actions ///////////
-  ////////////////////////////////////////////
-
-  #define menu_action_back(dummy) _menu_action_back()
-  void _menu_action_back();
-  void menu_action_submenu(screenFunc_t data);
-  void menu_action_gcode(PGM_P pgcode);
-  void menu_action_function(menuAction_t data);
-
-  #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
-    bool _menu_edit_ ## _name(); \
-    void menu_edit_ ## _name(); \
-    void menu_edit_callback_ ## _name(); \
-    void _menu_action_setting_edit_ ## _name(PGM_P const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
-    void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
-    void menu_action_setting_edit_callback_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback=NULL, const bool live=false); \
-    typedef void _name##_void
-
-  DECLARE_MENU_EDIT_TYPE(int16_t, int3);
-  DECLARE_MENU_EDIT_TYPE(int16_t, int4);
-  DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
-  DECLARE_MENU_EDIT_TYPE(float, float3);
-  DECLARE_MENU_EDIT_TYPE(float, float52);
-  DECLARE_MENU_EDIT_TYPE(float, float43);
-  DECLARE_MENU_EDIT_TYPE(float, float5);
-  DECLARE_MENU_EDIT_TYPE(float, float51);
-  DECLARE_MENU_EDIT_TYPE(float, float52sign);
-  DECLARE_MENU_EDIT_TYPE(float, float62);
-  DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
-
-  void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr);
-  void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callbackFunc);
-
-  #if ENABLED(SDSUPPORT)
-    void lcd_sdcard_menu();
-    void menu_action_sdfile(CardReader &theCard);
-    void menu_action_sddirectory(CardReader &theCard);
-  #endif
-
-  ////////////////////////////////////////////
-  //////////// Menu System Macros ////////////
-  ////////////////////////////////////////////
-
-  /**
-   * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
-   *
-   *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)
-   *   menu_action_[type](arg3...)
-   *
-   * Examples:
-   *   MENU_ITEM(back, MSG_WATCH, 0 [dummy parameter] )
-   *   or
-   *   MENU_BACK(MSG_WATCH)
-   *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH))
-   *     menu_action_back()
-   *
-   *   MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause)
-   *     lcd_implementation_drawmenu_function(sel, row, PSTR(MSG_PAUSE_PRINT), lcd_sdcard_pause)
-   *     menu_action_function(lcd_sdcard_pause)
-   *
-   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
-   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
-   *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
-   *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
-   *
-   */
-  #define _MENU_ITEM_PART_1(TYPE, ...) \
-    if (_menuLineNr == _thisItemNr) { \
-      if (encoderLine == _thisItemNr && lcd_clicked) { \
-        lcd_clicked = false
-
-  #define _MENU_ITEM_PART_2(TYPE, PLABEL, ...) \
-        menu_action_ ## TYPE(__VA_ARGS__); \
-        if (screen_changed) return; \
-      } \
-      if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PLABEL, ## __VA_ARGS__); \
-    } \
-    ++_thisItemNr
-
-  #define MENU_ITEM_P(TYPE, PLABEL, ...) do { \
-      _skipStatic = false; \
-      _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
-      _MENU_ITEM_PART_2(TYPE, PLABEL, ## __VA_ARGS__); \
-    }while(0)
-
-  #define MENU_ITEM(TYPE, LABEL, ...) MENU_ITEM_P(TYPE, PSTR(LABEL), ## __VA_ARGS__)
-
-  #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
-
-  #define MENU_ITEM_ADDON_START(X) \
-    if (lcdDrawUpdate && _menuLineNr == _thisItemNr - 1) { \
-      SETCURSOR(X, _lcdLineNr)
-
-  #define MENU_ITEM_ADDON_END() } (0)
-
-  // Used to print static text with no visible cursor.
-  // Parameters: label [, bool center [, bool invert [, char *value] ] ]
-  #define STATIC_ITEM_P(LABEL, ...) do{ \
-    if (_menuLineNr == _thisItemNr) { \
-      if (_skipStatic && encoderLine <= _thisItemNr) { \
-        encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
-        ++encoderLine; \
-      } \
-      if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_static(_lcdLineNr, LABEL, ## __VA_ARGS__); \
-    } \
-    ++_thisItemNr; } while(0)
-
-  #define STATIC_ITEM(LABEL, ...) STATIC_ITEM_P(PSTR(LABEL), ## __VA_ARGS__)
-
-  #if ENABLED(ENCODER_RATE_MULTIPLIER)
-
-    bool encoderRateMultiplierEnabled;
-    #define ENCODER_RATE_MULTIPLY(F) (encoderRateMultiplierEnabled = F)
-
-    //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
-
-    /**
-     * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item
-     */
-    #define MENU_MULTIPLIER_ITEM(TYPE, LABEL, ...) do { \
-        _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
-        encoderRateMultiplierEnabled = true; \
-        lastEncoderMovementMillis = 0; \
-        _MENU_ITEM_PART_2(TYPE, PSTR(LABEL), ## __VA_ARGS__); \
-      }while(0)
-
-  #else // !ENCODER_RATE_MULTIPLIER
-    #define ENCODER_RATE_MULTIPLY(F) NOOP
-  #endif // !ENCODER_RATE_MULTIPLIER
-
-  #define MENU_ITEM_DUMMY() do { _thisItemNr++; }while(0)
-  #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-  #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-  #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-  #else // !ENCODER_RATE_MULTIPLIER
-    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
-  #endif // !ENCODER_RATE_MULTIPLIER
-
-  #define SCREEN_OR_MENU_LOOP() \
-    int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
-    for (int8_t _lcdLineNr = 0; _lcdLineNr < menu_bottom; _lcdLineNr++, _menuLineNr++) { \
-      _thisItemNr = 0
 
-  /**
-   * START_SCREEN  Opening code for a screen having only static items.
-   *               Do simplified scrolling of the entire screen.
-   *
-   * START_MENU    Opening code for a screen with menu items.
-   *               Scroll as-needed to keep the selected line in view.
-   */
-  #define START_SCREEN() \
-    scroll_screen(menu_bottom, false); \
-    bool _skipStatic = false; \
-    SCREEN_OR_MENU_LOOP()
+    #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      SET_INPUT_PULLUP(SHIFT_OUT);
+    #endif
 
-  #define START_MENU() \
-    scroll_screen(1, true); \
-    bool _skipStatic = true; \
-    SCREEN_OR_MENU_LOOP()
+    #if BUTTON_EXISTS(UP)
+      SET_INPUT(BTN_UP);
+    #endif
+    #if BUTTON_EXISTS(DWN)
+      SET_INPUT(BTN_DWN);
+    #endif
+    #if BUTTON_EXISTS(LFT)
+      SET_INPUT(BTN_LFT);
+    #endif
+    #if BUTTON_EXISTS(RT)
+      SET_INPUT(BTN_RT);
+    #endif
 
-  #define END_SCREEN() \
-    } \
-    screen_items = _thisItemNr
+  #else // !NEWPANEL
 
-  #define END_MENU() \
-    } \
-    screen_items = _thisItemNr; \
-    UNUSED(_skipStatic)
+    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+      SET_OUTPUT(SR_DATA_PIN);
+      SET_OUTPUT(SR_CLK_PIN);
+    #elif defined(SHIFT_CLK)
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      OUT_WRITE(SHIFT_EN, LOW);
+      SET_INPUT_PULLUP(SHIFT_OUT);
+    #endif // SR_LCD_2W_NL
 
-  ////////////////////////////////////////////
-  ///////////// Global Variables /////////////
-  ////////////////////////////////////////////
+  #endif // !NEWPANEL
 
-  /**
-   * REVERSE_MENU_DIRECTION
-   *
-   * To reverse the menu direction we need a general way to reverse
-   * the direction of the encoder everywhere. So encoderDirection is
-   * added to allow the encoder to go the other way.
-   *
-   * This behavior is limited to scrolling Menus and SD card listings,
-   * and is disabled in other contexts.
-   */
-  #if ENABLED(REVERSE_MENU_DIRECTION)
-    int8_t encoderDirection = 1;
-    #define ENCODER_DIRECTION_NORMAL() (encoderDirection = 1)
-    #define ENCODER_DIRECTION_MENUS() (encoderDirection = -1)
-  #else
-    #define ENCODER_DIRECTION_NORMAL() ;
-    #define ENCODER_DIRECTION_MENUS() ;
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+    SET_INPUT_PULLUP(SD_DETECT_PIN);
+    lcd_sd_status = 2; // UNKNOWN
   #endif
 
-  // Encoder Movement
-  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
-  uint32_t encoderPosition;
-  millis_t lastEncoderMovementMillis = 0;
-
-  // Button States
-  bool lcd_clicked, wait_for_unclick;
-  volatile uint8_t buttons;
-  millis_t next_button_update_ms;
-  #if ENABLED(REPRAPWORLD_KEYPAD)
-    volatile uint8_t buttons_reprapworld_keypad;
-  #endif
   #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-    volatile uint8_t slow_buttons;
-  #endif
-
-  // Menu System Navigation
-  screenFunc_t currentScreen = lcd_status_screen;
-  int8_t encoderTopLine;
-  typedef struct {
-    screenFunc_t menu_function;
-    uint32_t encoder_position;
-  } menuPosition;
-  menuPosition screen_history[6];
-  uint8_t screen_history_depth = 0;
-  bool screen_changed, defer_return_to_status;
-
-  // Value Editing
-  PGM_P editLabel;
-  void *editValue;
-  int32_t minEditValue, maxEditValue;
-  screenFunc_t callbackFunc;
-  bool liveEdit;
-
-  // Manual Moves
-  const float manual_feedrate_mm_m[] = MANUAL_FEEDRATE;
-  millis_t manual_move_start_time = 0;
-  int8_t manual_move_axis = (int8_t)NO_AXIS;
-  #if EXTRUDERS > 1
-    int8_t manual_move_e_index = 0;
-  #else
-    #define manual_move_e_index 0
-  #endif
-
-  #if ENABLED(MANUAL_E_MOVES_RELATIVE)
-    float manual_move_e_origin = 0;
-  #endif
-
-  #if IS_KINEMATIC
-    bool processing_manual_move = false;
-    float manual_move_offset = 0;
-  #else
-    constexpr bool processing_manual_move = false;
+    slow_buttons = 0;
   #endif
 
-  #if PIN_EXISTS(SD_DETECT)
-    uint8_t lcd_sd_status;
-  #endif
+  lcd_buttons_update();
 
-  #if ENABLED(PIDTEMP)
-    float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
+  #if ENABLED(ULTIPANEL)
+    encoderDiff = 0;
   #endif
+}
 
-  inline bool use_click() {
-    const bool click = lcd_clicked;
-    lcd_clicked = false;
-    return click;
+bool lcd_blink() {
+  static uint8_t blink = 0;
+  static millis_t next_blink_ms = 0;
+  millis_t ms = millis();
+  if (ELAPSED(ms, next_blink_ms)) {
+    blink ^= 0xFF;
+    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
+  return blink != 0;
+}
 
-  inline bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
-
-  void lcd_move_z();
-  float move_menu_scale;
-
-  /**
-   * General function to go directly to a screen
-   */
-  void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
-    if (currentScreen != screen) {
+////////////////////////////////////////////
+///////////// Keypad Handling //////////////
+////////////////////////////////////////////
 
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        // Shadow for editing the fade height
-        new_z_fade_height = planner.z_fade_height;
-      #endif
+#if ENABLED(ADC_KEYPAD)
 
-      #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
-        static millis_t doubleclick_expire_ms = 0;
-        // Going to lcd_main_menu from status screen? Remember first click time.
-        // Going back to status screen within a very short time? Go to Z babystepping.
-        if (screen == lcd_main_menu) {
-          if (currentScreen == lcd_status_screen)
-            doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
-        }
-        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)) {
-          if (printer_busy()) {
-            screen =
-              #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-                lcd_babystep_zoffset
-              #else
-                lcd_babystep_z
-              #endif
-            ;
-          }
-          #if ENABLED(MOVE_Z_WHEN_IDLE)
-            else {
-              move_menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
-              screen = lcd_move_z;
-            }
-          #endif
-        }
-      #endif
+  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_F1
+  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_MIDDLE
 
-      currentScreen = screen;
-      encoderPosition = encoder;
-      if (screen == lcd_status_screen) {
-        defer_return_to_status = false;
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.lcd_map_control = false;
-        #endif
-        screen_history_depth = 0;
+  inline bool handle_adc_keypad() {
+    #define ADC_MIN_KEY_DELAY 100
+    if (buttons_reprapworld_keypad) {
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      if (encoderDirection == -1) { // side effect which signals we are inside a menu
+        if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(true); }
+        else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(true); }
       }
-      lcd_implementation_clear();
-      // Re-initialize custom characters that may be re-used
-      #if DISABLED(DOGLCD) && ENABLED(AUTO_BED_LEVELING_UBL)
-        if (!ubl.lcd_map_control) {
-          lcd_set_custom_characters(
-            #if ENABLED(LCD_PROGRESS_BAR)
-              screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
-            #endif
-          );
+      else {
+        if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
+               if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
         }
-      #elif ENABLED(LCD_PROGRESS_BAR)
-        lcd_set_custom_characters(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
-      #endif
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      screen_changed = true;
-      #if ENABLED(DOGLCD)
-        drawing_screen = false;
+      }
+      #if ENABLED(ADC_KEYPAD_DEBUG)
+        SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
+        SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
       #endif
+      next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
+      return true;
     }
-  }
 
-  /**
-   * Show "Moving..." till moves are done, then revert to previous display.
-   */
-  static const char moving[] PROGMEM = MSG_MOVING;
-  static PGM_P sync_message = moving;
-
-  //
-  // Display the synchronize screen until moves are
-  // finished, and don't return to the caller until
-  // done. ** This blocks the command queue! **
-  //
-  void _lcd_synchronize() {
-    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
-    if (no_reentry) return;
-    // Make this the current handler till all moves are done
-    no_reentry = true;
-    const screenFunc_t old_screen = currentScreen;
-    lcd_goto_screen(_lcd_synchronize);
-    planner.synchronize(); // idle() is called until moves complete
-    no_reentry = false;
-    lcd_goto_screen(old_screen);
+    return false;
   }
 
-  // Display the synchronize screen with a custom message
-  // ** This blocks the command queue! **
-  void lcd_synchronize(PGM_P const msg=NULL) {
-    sync_message = msg ? msg : moving;
-    _lcd_synchronize();
+#elif ENABLED(REPRAPWORLD_KEYPAD)
+
+  #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values
+
+  #define BLEN_REPRAPWORLD_KEYPAD_F3     0
+  #define BLEN_REPRAPWORLD_KEYPAD_F2     1
+  #define BLEN_REPRAPWORLD_KEYPAD_F1     2
+  #define BLEN_REPRAPWORLD_KEYPAD_DOWN   3
+  #define BLEN_REPRAPWORLD_KEYPAD_RIGHT  4
+  #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5
+  #define BLEN_REPRAPWORLD_KEYPAD_UP     6
+  #define BLEN_REPRAPWORLD_KEYPAD_LEFT   7
+
+  #define EN_REPRAPWORLD_KEYPAD_F3      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F3))
+  #define EN_REPRAPWORLD_KEYPAD_F2      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F2))
+  #define EN_REPRAPWORLD_KEYPAD_F1      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_F1))
+  #define EN_REPRAPWORLD_KEYPAD_DOWN    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_DOWN))
+  #define EN_REPRAPWORLD_KEYPAD_RIGHT   (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_RIGHT))
+  #define EN_REPRAPWORLD_KEYPAD_MIDDLE  (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_MIDDLE))
+  #define EN_REPRAPWORLD_KEYPAD_UP      (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_UP))
+  #define EN_REPRAPWORLD_KEYPAD_LEFT    (_BV(REPRAPWORLD_BTN_OFFSET + BLEN_REPRAPWORLD_KEYPAD_LEFT))
+
+  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F3)
+  #define REPRAPWORLD_KEYPAD_MOVE_Z_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_F2)
+  #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)
+  #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT)
+  #define REPRAPWORLD_KEYPAD_MOVE_Y_UP    (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)
+  #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT  (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)
+
+  #define KEYPAD_HOME EN_REPRAPWORLD_KEYPAD_MIDDLE
+  #define KEYPAD_EN_C EN_REPRAPWORLD_KEYPAD_F1
+  #define REPRAPWORLD_KEYPAD_MOVE_HOME    (buttons_reprapworld_keypad & KEYPAD_HOME)
+  #define REPRAPWORLD_KEYPAD_MOVE_MENU    (buttons_reprapworld_keypad & KEYPAD_EN_C)
+
+  #define REPRAPWORLD_KEYPAD_PRESSED      (buttons_reprapworld_keypad & ( \
+                                            EN_REPRAPWORLD_KEYPAD_F3 | \
+                                            EN_REPRAPWORLD_KEYPAD_F2 | \
+                                            EN_REPRAPWORLD_KEYPAD_F1 | \
+                                            EN_REPRAPWORLD_KEYPAD_DOWN | \
+                                            EN_REPRAPWORLD_KEYPAD_RIGHT | \
+                                            EN_REPRAPWORLD_KEYPAD_MIDDLE | \
+                                            EN_REPRAPWORLD_KEYPAD_UP | \
+                                            EN_REPRAPWORLD_KEYPAD_LEFT) \
+                                          )
+
+  void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
+    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+    encoderPosition = dir;
+    switch (axis) {
+      case X_AXIS: lcd_move_x(); break;
+      case Y_AXIS: lcd_move_y(); break;
+      case Z_AXIS: lcd_move_z();
+      default: break;
+    }
   }
+  inline void reprapworld_keypad_move_z_up()    { _reprapworld_keypad_move(Z_AXIS,  1); }
+  inline void reprapworld_keypad_move_z_down()  { _reprapworld_keypad_move(Z_AXIS, -1); }
+  inline void reprapworld_keypad_move_x_left()  { _reprapworld_keypad_move(X_AXIS, -1); }
+  inline void reprapworld_keypad_move_x_right() { _reprapworld_keypad_move(X_AXIS,  1); }
+  inline void reprapworld_keypad_move_y_up()    { _reprapworld_keypad_move(Y_AXIS, -1); }
+  inline void reprapworld_keypad_move_y_down()  { _reprapworld_keypad_move(Y_AXIS,  1); }
+  inline void reprapworld_keypad_move_home()    { enqueue_and_echo_commands_P(PSTR("G28")); } // move all axes home and wait
+  inline void reprapworld_keypad_move_menu()    { lcd_goto_screen(menu_move); }
 
-  void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
+  inline void handle_reprapworld_keypad() {
 
-  void lcd_save_previous_screen() {
-    if (screen_history_depth < COUNT(screen_history)) {
-      screen_history[screen_history_depth].menu_function = currentScreen;
-      screen_history[screen_history_depth].encoder_position = encoderPosition;
-      ++screen_history_depth;
-    }
-  }
+    static uint8_t keypad_debounce = 0;
 
-  void lcd_goto_previous_menu() {
-    if (screen_history_depth > 0) {
-      --screen_history_depth;
-      lcd_goto_screen(
-        screen_history[screen_history_depth].menu_function,
-        screen_history[screen_history_depth].encoder_position
-      );
+    if (!REPRAPWORLD_KEYPAD_PRESSED) {
+      if (keypad_debounce > 0) keypad_debounce--;
     }
-    else
-      lcd_return_to_status();
-  }
+    else if (!keypad_debounce) {
+      keypad_debounce = 2;
 
-  void lcd_goto_previous_menu_no_defer() {
-    defer_return_to_status = false;
-    lcd_goto_previous_menu();
-  }
+      if (REPRAPWORLD_KEYPAD_MOVE_MENU)       reprapworld_keypad_move_menu();
 
-  /**
-   * Scrolling for menus and other line-based screens
-   *
-   *   encoderLine is the position based on the encoder
-   *   encoderTopLine is the top menu line to display
-   *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
-   *   _menuLineNr is the menu item to draw and process
-   *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
-   *   screen_items is the total number of items in the menu (after one call)
-   */
-  int8_t encoderLine, screen_items;
-  void scroll_screen(const uint8_t limit, const bool is_menu) {
-    ENCODER_DIRECTION_MENUS();
-    ENCODER_RATE_MULTIPLY(false);
-    if (encoderPosition > 0x8000) encoderPosition = 0;
-    if (first_page) {
-      encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
-      screen_changed = false;
-    }
-    if (screen_items > 0 && encoderLine >= screen_items - limit) {
-      encoderLine = MAX(0, screen_items - limit);
-      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
-    }
-    if (is_menu) {
-      NOMORE(encoderTopLine, encoderLine);
-      if (encoderLine >= encoderTopLine + menu_bottom)
-        encoderTopLine = encoderLine - menu_bottom + 1;
+      #if DISABLED(DELTA) && Z_HOME_DIR == -1
+        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
+      #endif
+
+      if (all_axes_homed()) {
+        #if ENABLED(DELTA) || Z_HOME_DIR != -1
+          if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
+        #endif
+        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
+        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
+        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
+        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
+        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
+      }
+      else {
+        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
+      }
     }
-    else
-      encoderTopLine = encoderLine;
   }
 
-#endif // ULTIPANEL
+#endif // REPRAPWORLD_KEYPAD
 
 /**
- *
- * "Info Screen"
+ * Status Screen
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
+#if LCD_INFO_SCREEN_STYLE == 0
+  void lcd_impl_status_screen_0();
+#elif LCD_INFO_SCREEN_STYLE == 1
+  void lcd_impl_status_screen_1();
+#endif
+
 void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
   #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
     // Progress bar % comes from SD when actively printing
     if (IS_SD_PRINTING())
@@ -753,21 +431,21 @@ void lcd_status_screen() {
 
     if (use_click()) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           CHARSET_MENU
         #endif
       );
-      lcd_goto_screen(lcd_main_menu);
+      lcd_goto_screen(menu_main);
       return;
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
       const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
       // Dead zone at 100% feedrate
       if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
         feedrate_percentage = 100;
         encoderPosition = 0;
       }
@@ -813,4605 +491,127 @@ void lcd_reset_status() {
       return lcd_setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
   lcd_setstatusPGM(msg, -1);
 }
 
-/**
- *
- * draw the kill screen
- *
- */
 void kill_screen(PGM_P lcd_msg) {
   lcd_init();
   lcd_setalertstatusPGM(lcd_msg);
   lcd_kill_screen();
 }
 
-/**
- *
- * Audio feedback for controller clicks
- *
- */
-void lcd_buzz(const long duration, const uint16_t freq) {
-  #if ENABLED(LCD_USE_I2C_BUZZER)
-    lcd.buzz(duration, freq);
-  #elif PIN_EXISTS(BEEPER)
-    buzzer.tone(duration, freq);
-  #else
-    UNUSED(duration); UNUSED(freq);
-  #endif
-}
-
-void lcd_quick_feedback(const bool clear_buttons) {
-
-  #if ENABLED(ULTIPANEL)
-    lcd_refresh();
-    if (clear_buttons) buttons = 0;
-    next_button_update_ms = millis() + 500;
-  #else
-    UNUSED(clear_buttons);
-  #endif
-
-  // Buzz and wait. The delay is needed for buttons to settle!
-  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-
-  #if ENABLED(ULTIPANEL)
+#if HAS_BUZZER
+  void lcd_buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
-      delay(10);
+      lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+      buzzer.tone(duration, freq);
     #endif
-  #endif
-}
-
-#if ENABLED(ULTIPANEL)
-
-  void lcd_completion_feedback(const bool good/*=true*/) {
-    if (good) {
-      lcd_buzz(100, 659);
-      lcd_buzz(100, 698);
-    }
-    else lcd_buzz(20, 440);
-  }
-
-  inline void line_to_current_z() {
-    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
-  }
-
-  inline void line_to_z(const float &z) {
-    current_position[Z_AXIS] = z;
-    line_to_current_z();
   }
+#endif
 
-  #if ENABLED(SDSUPPORT)
-
-    void lcd_sdcard_pause() {
-      card.pauseSDPrint();
-      print_job_timer.pause();
-      #if ENABLED(PARK_HEAD_ON_PAUSE)
-        enqueue_and_echo_commands_P(PSTR("M125"));
-      #endif
-      lcd_reset_status();
-    }
-
-    void lcd_sdcard_resume() {
-      #if ENABLED(PARK_HEAD_ON_PAUSE)
-        enqueue_and_echo_commands_P(PSTR("M24"));
-      #else
-        card.startFileprint();
-        print_job_timer.start();
-      #endif
-      lcd_reset_status();
-    }
-
-    void lcd_sdcard_stop() {
-      wait_for_heatup = wait_for_user = false;
-      card.abort_sd_printing = true;
-      lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
-      lcd_return_to_status();
-    }
-
-  #endif // SDSUPPORT
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
+void lcd_quick_feedback(const bool clear_buttons) {
 
-    static void lcd_power_loss_recovery_resume() {
-      char cmd[20];
-
-      // Return to status now
-      lcd_return_to_status();
-
-      // Turn leveling off and home
-      enqueue_and_echo_commands_P(PSTR("M420 S0\nG28 R0"
-        #if ENABLED(MARLIN_DEV_MODE)
-          " S"
-        #elif !IS_KINEMATIC
-          " X Y"
-        #endif
-      ));
-
-      #if HAS_HEATED_BED
-        const int16_t bt = job_recovery_info.target_temperature_bed;
-        if (bt) {
-          // Restore the bed temperature
-          sprintf_P(cmd, PSTR("M190 S%i"), bt);
-          enqueue_and_echo_command(cmd);
-        }
-      #endif
-
-      // Restore all hotend temperatures
-      HOTEND_LOOP() {
-        const int16_t et = job_recovery_info.target_temperature[e];
-        if (et) {
-          #if HOTENDS > 1
-            sprintf_P(cmd, PSTR("T%i"), e);
-            enqueue_and_echo_command(cmd);
-          #endif
-          sprintf_P(cmd, PSTR("M109 S%i"), et);
-          enqueue_and_echo_command(cmd);
-        }
-      }
-
-      #if HOTENDS > 1
-        sprintf_P(cmd, PSTR("T%i"), job_recovery_info.active_hotend);
-        enqueue_and_echo_command(cmd);
-      #endif
-
-      // Restore print cooling fan speeds
-      for (uint8_t i = 0; i < FAN_COUNT; i++) {
-        uint8_t f = job_recovery_info.fan_speed[i];
-        if (f) {
-          sprintf_P(cmd, PSTR("M106 P%i S%i"), i, f);
-          enqueue_and_echo_command(cmd);
-        }
-      }
-
-      // Start draining the job recovery command queue
-      job_recovery_phase = JOB_RECOVERY_YES;
-    }
-
-    static void lcd_power_loss_recovery_cancel() {
-      card.removeJobRecoveryFile();
-      card.autostart_index = 0;
-      lcd_return_to_status();
-    }
-
-    static void lcd_job_recovery_menu() {
-      defer_return_to_status = true;
-      START_MENU();
-      STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
-      MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
-      MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
-      END_MENU();
-    }
-
-  #endif // POWER_LOSS_RECOVERY
-
-  #if EXTRUDERS > 1
-    void tool_change_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      #if ENABLED(SINGLENOZZLE)
-        MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &toolchange_settings.swap_length, 0, 200);
-        MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &toolchange_settings.retract_speed, 10, 5400);
-        MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &toolchange_settings.prime_speed, 10, 5400);
-      #endif
-      MENU_ITEM_EDIT(float3, MSG_TOOL_CHANGE_ZLIFT, &toolchange_settings.z_raise, 0, 10);
-      END_MENU();
-    }
-  #endif
-
-  #if ENABLED(MENU_ITEM_CASE_LIGHT)
-
-    #include "../feature/caselight.h"
-
-    void case_light_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
-      END_MENU();
-    }
-  #endif // MENU_ITEM_CASE_LIGHT
-
-  #if ENABLED(BLTOUCH)
-
-    /**
-     *
-     * "BLTouch" submenu
-     *
-     */
-    static void bltouch_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
-      END_MENU();
-    }
-
-  #endif // BLTOUCH
-
-  #if ENABLED(LCD_PROGRESS_BAR_TEST)
-
-    static void progress_bar_test() {
-      static int8_t bar_percent = 0;
-      if (use_click()) {
-        lcd_goto_previous_menu();
-        lcd_set_custom_characters(CHARSET_MENU);
-        return;
-      }
-      bar_percent += (int8_t)encoderPosition;
-      bar_percent = constrain(bar_percent, 0, 100);
-      encoderPosition = 0;
-      lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
-      lcd_moveto((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
-      lcd_put_u8str(int(bar_percent)); lcd_put_wchar('%');
-      lcd_moveto(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
-    }
-
-    void _progress_bar_test() {
-      lcd_goto_screen(progress_bar_test);
-      lcd_set_custom_characters();
-    }
-
-  #endif // LCD_PROGRESS_BAR_TEST
-
-  #if HAS_DEBUG_MENU
-
-    void lcd_debug_menu() {
-      START_MENU();
-
-      MENU_BACK(MSG_MAIN);
-
-      #if ENABLED(LCD_PROGRESS_BAR_TEST)
-        MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
-      #endif
-
-      END_MENU();
-    }
-
-  #endif // HAS_DEBUG_MENU
-
-  /**
-   * IDEX submenu
-   */
-  #if ENABLED(DUAL_X_CARRIAGE)
-    static void _recalc_IDEX_settings() {
-      if (active_extruder) {                      // For the 2nd extruder re-home so the next tool-change gets the new offsets.
-        enqueue_and_echo_commands_P(PSTR("G28")); // In future, we can babystep the 2nd extruder (if active), making homing unnecessary.
-        active_extruder = 0;
-      }
-    }
-
-    static void IDEX_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-
-      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
-      const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
-      MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
-        ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
-        : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
-      );
-      //MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
-      //  ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
-      //  : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
-      //);
-      MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
-      MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
-      END_MENU();
-    }
-  #endif // DUAL_X_CARRIAGE
-
-  #if ENABLED(CUSTOM_USER_MENUS)
-
-    #ifdef USER_SCRIPT_DONE
-      #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
-    #else
-      #define _DONE_SCRIPT ""
-    #endif
-
-    void _lcd_user_gcode(PGM_P const cmd) {
-      enqueue_and_echo_commands_P(cmd);
-      #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
-        lcd_completion_feedback();
-      #endif
-      #if ENABLED(USER_SCRIPT_RETURN)
-        lcd_return_to_status();
-      #endif
-    }
-
-    #if defined(USER_DESC_1) && defined(USER_GCODE_1)
-      void lcd_user_gcode_1() { _lcd_user_gcode(PSTR(USER_GCODE_1 _DONE_SCRIPT)); }
-    #endif
-    #if defined(USER_DESC_2) && defined(USER_GCODE_2)
-      void lcd_user_gcode_2() { _lcd_user_gcode(PSTR(USER_GCODE_2 _DONE_SCRIPT)); }
-    #endif
-    #if defined(USER_DESC_3) && defined(USER_GCODE_3)
-      void lcd_user_gcode_3() { _lcd_user_gcode(PSTR(USER_GCODE_3 _DONE_SCRIPT)); }
-    #endif
-    #if defined(USER_DESC_4) && defined(USER_GCODE_4)
-      void lcd_user_gcode_4() { _lcd_user_gcode(PSTR(USER_GCODE_4 _DONE_SCRIPT)); }
-    #endif
-    #if defined(USER_DESC_5) && defined(USER_GCODE_5)
-      void lcd_user_gcode_5() { _lcd_user_gcode(PSTR(USER_GCODE_5 _DONE_SCRIPT)); }
-    #endif
-
-    void _lcd_user_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      #if defined(USER_DESC_1) && defined(USER_GCODE_1)
-        MENU_ITEM(function, USER_DESC_1, lcd_user_gcode_1);
-      #endif
-      #if defined(USER_DESC_2) && defined(USER_GCODE_2)
-        MENU_ITEM(function, USER_DESC_2, lcd_user_gcode_2);
-      #endif
-      #if defined(USER_DESC_3) && defined(USER_GCODE_3)
-        MENU_ITEM(function, USER_DESC_3, lcd_user_gcode_3);
-      #endif
-      #if defined(USER_DESC_4) && defined(USER_GCODE_4)
-        MENU_ITEM(function, USER_DESC_4, lcd_user_gcode_4);
-      #endif
-      #if defined(USER_DESC_5) && defined(USER_GCODE_5)
-        MENU_ITEM(function, USER_DESC_5, lcd_user_gcode_5);
-      #endif
-      END_MENU();
-    }
-
-  #endif
-
-  /**
-   *
-   * "Main" menu
-   *
-   */
-
-  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-
-    void lcd_autostart_sd() { card.beginautostart(); }
-
-  #endif
-
-  void lcd_main_menu() {
-    START_MENU();
-    MENU_BACK(MSG_WATCH);
-
-    #if ENABLED(SDSUPPORT)
-      if (card.cardOK) {
-        if (card.isFileOpen()) {
-          if (card.sdprinting)
-            MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
-          else
-            MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
-          MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
-        }
-        else {
-          MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
-          #if !PIN_EXISTS(SD_DETECT)
-            MENU_ITEM(gcode, MSG_CHANGE_SDCARD, PSTR("M21"));  // SD-card changed by user
-          #endif
-        }
-      }
-      else {
-        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
-        #if !PIN_EXISTS(SD_DETECT)
-          MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
-        #endif
-      }
-    #endif // SDSUPPORT
-
-    const bool busy = printer_busy();
-    if (busy)
-      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
-    else {
-      MENU_ITEM(submenu, MSG_MOTION, lcd_movement_menu);
-      MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_temperature_menu);
-    }
-
-    MENU_ITEM(submenu, MSG_CONFIGURATION, lcd_configuration_menu);
-
-    #if ENABLED(CUSTOM_USER_MENUS)
-      MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
-    #endif
-
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-          MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
-        else
-          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
-      #else
-        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
-      #endif
-    #endif
-
-    #if ENABLED(LCD_INFO_MENU)
-      MENU_ITEM(submenu, MSG_INFO_MENU, lcd_info_menu);
-    #endif
-
-    #if ENABLED(LED_CONTROL_MENU)
-      MENU_ITEM(submenu, MSG_LED_CONTROL, lcd_led_menu);
-    #endif
-
-    //
-    // Switch power on/off
-    //
-    #if HAS_POWER_SWITCH
-      if (powersupply_on)
-        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
-      else
-        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
-    #endif
-
-    //
-    // Autostart
-    //
-    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-      if (!busy)
-        MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
-    #endif
-
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Tune" submenu items
-   *
-   */
-
-  #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY) || ENABLED(MESH_EDIT_GFX_OVERLAY)
-
-    void _lcd_zoffset_overlay_gfx(const float zvalue) {
-      // Determine whether the user is raising or lowering the nozzle.
-      static int8_t dir;
-      static float old_zvalue;
-      if (zvalue != old_zvalue) {
-        dir = zvalue ? zvalue < old_zvalue ? -1 : 1 : 0;
-        old_zvalue = zvalue;
-      }
-
-      #if ENABLED(OVERLAY_GFX_REVERSE)
-        const unsigned char *rot_up = ccw_bmp, *rot_down = cw_bmp;
-      #else
-        const unsigned char *rot_up = cw_bmp, *rot_down = ccw_bmp;
-      #endif
-
-      #if ENABLED(USE_BIG_EDIT_FONT)
-        const int left = 0, right = 45, nozzle = 95;
-      #else
-        const int left = 5, right = 90, nozzle = 60;
-      #endif
-
-      // Draw a representation of the nozzle
-      if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
-      if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
-
-      // Draw cw/ccw indicator and up/down arrows.
-      if (PAGE_CONTAINS(47, 62)) {
-        u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
-        u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
-        u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
-        u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
-      }
-    }
-
-  #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || MESH_EDIT_GFX_OVERLAY
-
-  #if ENABLED(BABYSTEPPING)
-
-    void _lcd_babystep(const AxisEnum axis, PGM_P msg) {
-      if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-      ENCODER_DIRECTION_NORMAL();
-      if (encoderPosition) {
-        const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
-        encoderPosition = 0;
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-        thermalManager.babystep_axis(axis, babystep_increment);
-        babysteps_done += babystep_increment;
-      }
-      if (lcdDrawUpdate)
-        lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
-    }
-
-    #if ENABLED(BABYSTEP_XY)
-      void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
-      void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
-      void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
-      void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
-    #endif
-
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-
-      void lcd_babystep_zoffset() {
-        if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-        defer_return_to_status = true;
-        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          const bool do_probe = (active_extruder == 0);
-        #else
-          constexpr bool do_probe = true;
-        #endif
-        ENCODER_DIRECTION_NORMAL();
-        if (encoderPosition) {
-          const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
-          encoderPosition = 0;
-
-          const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                      new_probe_offset = zprobe_zoffset + diff,
-                      new_offs =
-                        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-                          do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
-                        #else
-                          new_probe_offset
-                        #endif
-                      ;
-          if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-
-            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-
-            if (do_probe) zprobe_zoffset = new_offs;
-            #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-              else hotend_offset[Z_AXIS][active_extruder] = new_offs;
-            #endif
-
-            lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-          }
-        }
-        if (lcdDrawUpdate) {
-          #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-            if (!do_probe)
-              lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
-            else
-          #endif
-              lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
-
-          #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-            if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
-          #endif
-        }
-      }
-
-    #else // !BABYSTEP_ZPROBE_OFFSET
-
-      void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
-      void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
-
-    #endif // !BABYSTEP_ZPROBE_OFFSET
-
-  #endif // BABYSTEPPING
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
-                                                  // separate value that doesn't lose precision.
-    static int16_t ubl_encoderPosition = 0;
-
-    static void _lcd_mesh_fine_tune(PGM_P msg) {
-      defer_return_to_status = true;
-      if (ubl.encoder_diff) {
-        ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
-        ubl.encoder_diff = 0;
-
-        mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005f * 0.5f;
-        mesh_edit_value = mesh_edit_accumulator;
-        encoderPosition = 0;
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-
-        const int32_t rounded = (int32_t)(mesh_edit_value * 1000);
-        mesh_edit_value = float(rounded - (rounded % 5L)) / 1000;
-      }
-
-      if (lcdDrawUpdate) {
-        lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
-        #if ENABLED(MESH_EDIT_GFX_OVERLAY)
-          _lcd_zoffset_overlay_gfx(mesh_edit_value);
-        #endif
-      }
-    }
-
-    void _lcd_mesh_edit_NOP() {
-      defer_return_to_status = true;
-    }
-
-    float lcd_mesh_edit() {
-      lcd_goto_screen(_lcd_mesh_edit_NOP);
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
-      return mesh_edit_value;
-    }
-
-    void lcd_mesh_edit_setup(const float &initial) {
-      mesh_edit_value = mesh_edit_accumulator = initial;
-      lcd_goto_screen(_lcd_mesh_edit_NOP);
-    }
-
-    void _lcd_z_offset_edit() {
-      _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
-    }
-
-    float lcd_z_offset_edit() {
-      lcd_goto_screen(_lcd_z_offset_edit);
-      return mesh_edit_value;
-    }
-
-    void lcd_z_offset_edit_setup(const float &initial) {
-      mesh_edit_value = mesh_edit_accumulator = initial;
-      lcd_goto_screen(_lcd_z_offset_edit);
-    }
-
-  #endif // AUTO_BED_LEVELING_UBL
-
-
-  /**
-   * Watch temperature callbacks
-   */
-  #if HAS_TEMP_HOTEND
-    #if WATCH_HOTENDS
-      #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
-    #else
-      #define _WATCH_FUNC(N) NOOP
-    #endif
-    void watch_temp_callback_E0() { _WATCH_FUNC(0); }
-    #if HOTENDS > 1
-      void watch_temp_callback_E1() { _WATCH_FUNC(1); }
-      #if HOTENDS > 2
-        void watch_temp_callback_E2() { _WATCH_FUNC(2); }
-        #if HOTENDS > 3
-          void watch_temp_callback_E3() { _WATCH_FUNC(3); }
-          #if HOTENDS > 4
-            void watch_temp_callback_E4() { _WATCH_FUNC(4); }
-            #if HOTENDS > 5
-              void watch_temp_callback_E5() { _WATCH_FUNC(5); }
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-  #endif // HAS_TEMP_HOTEND
-
-  void watch_temp_callback_bed() {
-    #if WATCH_THE_BED
-      thermalManager.start_watching_bed();
-    #endif
-  }
-
-  // First Fan Speed title in "Tune" and "Control>Temperature" menus
-  #if FAN_COUNT > 0 && HAS_FAN0
-    #if FAN_COUNT > 1
-      #define FAN_SPEED_1_SUFFIX " 1"
-    #else
-      #define FAN_SPEED_1_SUFFIX ""
-    #endif
-  #endif
-
-  // Refresh the E factor after changing flow
-  inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
-  #if EXTRUDERS > 1
-    inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
-    inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
-    #if EXTRUDERS > 2
-      inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
-      #if EXTRUDERS > 3
-        inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
-        #if EXTRUDERS > 4
-          inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
-          #if EXTRUDERS > 5
-            inline void _lcd_refresh_e_factor_5() { planner.refresh_e_factor(5); }
-          #endif // EXTRUDERS > 5
-        #endif // EXTRUDERS > 4
-      #endif // EXTRUDERS > 3
-    #endif // EXTRUDERS > 2
-  #endif // EXTRUDERS > 1
-
-  /**
-   *
-   * "Tune" submenu
-   *
-   */
-  void lcd_tune_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-
-    //
-    // Speed:
-    //
-    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
-
-    //
-    // Manual bed leveling, Bed Z:
-    //
-    #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-    #endif
-
-    //
-    // Nozzle:
-    // Nozzle [1-4]:
-    //
-    #if HOTENDS == 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-    #else // HOTENDS > 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
-      #if HOTENDS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-        #if HOTENDS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-          #if HOTENDS > 4
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
-            #if HOTENDS > 5
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-
-    //
-    // Bed:
-    //
-    #if HAS_HEATED_BED
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
-    #endif
-
-    //
-    // Fan Speed:
-    //
-    #if FAN_COUNT > 0
-      #if HAS_FAN0
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
-        #endif
-      #endif
-      #if HAS_FAN1
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
-        #endif
-      #endif
-      #if HAS_FAN2
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
-        #endif
-      #endif
-    #endif // FAN_COUNT > 0
-
-    //
-    // Flow:
-    // Flow [1-5]:
-    //
-    #if EXTRUDERS == 1
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
-    #else // EXTRUDERS > 1
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
-      #if EXTRUDERS > 2
-        MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
-        #if EXTRUDERS > 3
-          MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
-          #if EXTRUDERS > 4
-            MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
-            #if EXTRUDERS > 5
-              MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N6, &planner.flow_percentage[5], 10, 999, _lcd_refresh_e_factor_5);
-            #endif // EXTRUDERS > 5
-          #endif // EXTRUDERS > 4
-        #endif // EXTRUDERS > 3
-      #endif // EXTRUDERS > 2
-    #endif // EXTRUDERS > 1
-
-    //
-    // Babystep X:
-    // Babystep Y:
-    // Babystep Z:
-    //
-    #if ENABLED(BABYSTEPPING)
-      #if ENABLED(BABYSTEP_XY)
-        MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
-        MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
-      #endif
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-      #else
-        MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
-      #endif
-    #endif
-
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Driver current control" submenu items
-   *
-   */
-  #if ENABLED(DAC_STEPPER_CURRENT)
-
-    void dac_driver_getValues() { LOOP_XYZE(i) driverPercent[i] = dac_current_get_percent((AxisEnum)i); }
-
-    void dac_driver_commit() { dac_current_set_percents(driverPercent); }
-
-    void dac_driver_eeprom_write() { dac_commit_eeprom(); }
-
-    void lcd_dac_menu() {
-      dac_driver_getValues();
-      START_MENU();
-      MENU_BACK(MSG_CONTROL);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_X " " MSG_DAC_PERCENT, &driverPercent[X_AXIS], 0, 100, dac_driver_commit);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_Y " " MSG_DAC_PERCENT, &driverPercent[Y_AXIS], 0, 100, dac_driver_commit);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_Z " " MSG_DAC_PERCENT, &driverPercent[Z_AXIS], 0, 100, dac_driver_commit);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_E " " MSG_DAC_PERCENT, &driverPercent[E_AXIS], 0, 100, dac_driver_commit);
-      MENU_ITEM(function, MSG_DAC_EEPROM_WRITE, dac_driver_eeprom_write);
-      END_MENU();
-    }
-
-  #endif // DAC_STEPPER_CURRENT
-
-  #if HAS_MOTOR_CURRENT_PWM
-
-    void lcd_pwm_menu() {
-      START_MENU();
-      MENU_BACK(MSG_CONTROL);
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_X MSG_Y, &stepper.motor_current_setting[0], 100, 2000, Stepper::refresh_motor_power);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_Z, &stepper.motor_current_setting[1], 100, 2000, Stepper::refresh_motor_power);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_E, &stepper.motor_current_setting[2], 100, 2000, Stepper::refresh_motor_power);
-      #endif
-      END_MENU();
-    }
-
-  #endif // HAS_MOTOR_CURRENT_PWM
-
-  constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
-
-  /**
-   *
-   * "Temperature" submenu items
-   *
-   */
-  void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const uint8_t fan) {
-    if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
-    #if HAS_HEATED_BED
-      if (tempb >= 0) thermalManager.setTargetBed(tempb);
-    #else
-      UNUSED(tempb);
-    #endif
-    #if FAN_COUNT > 0
-      #if FAN_COUNT > 1
-        fan_speed[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
-      #else
-        fan_speed[0] = fan;
-      #endif
-    #else
-      UNUSED(fan);
-    #endif
-    lcd_return_to_status();
-  }
-
-  #if HAS_TEMP_HOTEND
-    void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-    #if HAS_HEATED_BED
-      void lcd_preheat_m1_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-      void lcd_preheat_m2_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-    #endif
-  #endif
-
-  #if HOTENDS > 1
-    void lcd_preheat_m1_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-    #if HAS_HEATED_BED
-      void lcd_preheat_m1_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-      void lcd_preheat_m2_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-    #endif
-    #if HOTENDS > 2
-      void lcd_preheat_m1_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-      void lcd_preheat_m2_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-      #if HAS_HEATED_BED
-        void lcd_preheat_m1_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-        void lcd_preheat_m2_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-      #endif
-      #if HOTENDS > 3
-        void lcd_preheat_m1_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-        void lcd_preheat_m2_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-        #if HAS_HEATED_BED
-          void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-          void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-        #endif
-        #if HOTENDS > 4
-          void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-          void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-          #if HAS_HEATED_BED
-            void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-            void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-          #endif
-          #if HOTENDS > 5
-            void lcd_preheat_m1_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-            void lcd_preheat_m2_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-            #if HAS_HEATED_BED
-              void lcd_preheat_m1_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-              void lcd_preheat_m2_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-            #endif
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-
-    void lcd_preheat_m1_all() {
-      #if HOTENDS > 1
-        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
-        #if HOTENDS > 2
-          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
-          #if HOTENDS > 3
-            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
-            #if HOTENDS > 4
-              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
-              #if HOTENDS > 5
-                thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
-      #if HAS_HEATED_BED
-        lcd_preheat_m1_e0();
-      #else
-        lcd_preheat_m1_e0_only();
-      #endif
-    }
-    void lcd_preheat_m2_all() {
-      #if HOTENDS > 1
-        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
-        #if HOTENDS > 2
-          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
-          #if HOTENDS > 3
-            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
-            #if HOTENDS > 4
-              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
-              #if HOTENDS > 5
-                thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
-      #if HAS_HEATED_BED
-        lcd_preheat_m2_e0();
-      #else
-        lcd_preheat_m2_e0_only();
-      #endif
-    }
-
-  #endif // HOTENDS > 1
-
-  #if HAS_HEATED_BED
-    void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-  #endif
-
-  #if HAS_TEMP_HOTEND || HAS_HEATED_BED
-
-    void lcd_preheat_m1_menu() {
-      START_MENU();
-      MENU_BACK(MSG_TEMPERATURE);
-      #if HOTENDS == 1
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
-          MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
-        #endif
-      #elif HOTENDS > 1
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
-          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
-          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
-        #endif
-        #if HOTENDS > 2
-          #if HAS_HEATED_BED
-            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2);
-            MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E3, lcd_preheat_m1_e2_only);
-          #else
-            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2_only);
-          #endif
-          #if HOTENDS > 3
-            #if HAS_HEATED_BED
-              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3);
-              MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E4, lcd_preheat_m1_e3_only);
-            #else
-              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
-            #endif
-            #if HOTENDS > 4
-              #if HAS_HEATED_BED
-                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
-                MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
-              #else
-                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
-              #endif
-              #if HOTENDS > 5
-                #if HAS_HEATED_BED
-                  MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5);
-                  MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E6, lcd_preheat_m1_e5_only);
-                #else
-                  MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5_only);
-                #endif
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-        MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
-      #endif // HOTENDS > 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
-      #endif
-      END_MENU();
-    }
-
-    void lcd_preheat_m2_menu() {
-      START_MENU();
-      MENU_BACK(MSG_TEMPERATURE);
-      #if HOTENDS == 1
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
-          MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
-        #endif
-      #elif HOTENDS > 1
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
-          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
-          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
-        #endif
-        #if HOTENDS > 2
-          #if HAS_HEATED_BED
-            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2);
-            MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E3, lcd_preheat_m2_e2_only);
-          #else
-            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2_only);
-          #endif
-          #if HOTENDS > 3
-            #if HAS_HEATED_BED
-              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3);
-              MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E4, lcd_preheat_m2_e3_only);
-            #else
-              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
-            #endif
-            #if HOTENDS > 4
-              #if HAS_HEATED_BED
-                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
-                MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
-              #else
-                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
-              #endif
-              #if HOTENDS > 5
-                #if HAS_HEATED_BED
-                  MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5);
-                  MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E6, lcd_preheat_m2_e5_only);
-                #else
-                  MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5_only);
-                #endif
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-        MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
-      #endif // HOTENDS > 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
-      #endif
-      END_MENU();
-    }
-
-  #endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
-
-  void lcd_cooldown() {
-    zero_fan_speeds();
-    thermalManager.disable_all_heaters();
-    lcd_return_to_status();
-  }
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
-
-    /**
-     * If the queue is full, the command will fail, so we have to loop
-     * with idle() to make sure the command has been enqueued.
-     */
-    void lcd_enqueue_command(char * const cmd) {
-      no_reentry = true;
-      enqueue_and_echo_command_now(cmd);
-      no_reentry = false;
-    }
-
-    void lcd_enqueue_commands_P(PGM_P const cmd) {
-      no_reentry = true;
-      enqueue_and_echo_commands_now_P(cmd);
-      no_reentry = false;
-    }
-
-  #endif
-
-  #if ENABLED(EEPROM_SETTINGS)
-    static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
-    static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
-  #endif
-
-  inline void _lcd_draw_homing() {
-    constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(line, PSTR(MSG_LEVEL_BED_HOMING));
-    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-  }
-
-  #if ENABLED(LEVEL_BED_CORNERS)
-
-    /**
-     * Level corners, starting in the front-left corner.
-     */
-    static int8_t bed_corner;
-    void _lcd_goto_next_corner() {
-      line_to_z(4.0);
-      switch (bed_corner) {
-        case 0:
-          current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-          current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
-          break;
-        case 1:
-          current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
-          break;
-        case 2:
-          current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
-          break;
-        case 3:
-          current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-          break;
-        #if ENABLED(LEVEL_CENTER_TOO)
-          case 4:
-            current_position[X_AXIS] = X_CENTER;
-            current_position[Y_AXIS] = Y_CENTER;
-            break;
-        #endif
-      }
-      planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
-      line_to_z(0.0);
-      if (++bed_corner > 3
-        #if ENABLED(LEVEL_CENTER_TOO)
-          + 1
-        #endif
-      ) bed_corner = 0;
-    }
-
-    void _lcd_corner_submenu() {
-      START_MENU();
-      MENU_ITEM(function,
-        #if ENABLED(LEVEL_CENTER_TOO)
-          MSG_LEVEL_BED_NEXT_POINT
-        #else
-          MSG_NEXT_CORNER
-        #endif
-        , _lcd_goto_next_corner);
-      MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
-      END_MENU();
-    }
-
-    void _lcd_level_bed_corners_homing() {
-      _lcd_draw_homing();
-      if (all_axes_homed()) {
-        bed_corner = 0;
-        lcd_goto_screen(_lcd_corner_submenu);
-        _lcd_goto_next_corner();
-      }
-    }
-
-    void _lcd_level_bed_corners() {
-      defer_return_to_status = true;
-      if (!all_axes_known()) {
-        axis_homed = 0;
-        enqueue_and_echo_commands_P(PSTR("G28"));
-      }
-      lcd_goto_screen(_lcd_level_bed_corners_homing);
-    }
-
-  #endif // LEVEL_BED_CORNERS
-
-  #if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
-
-    /**
-     *
-     * "Motion" > "Level Bed" handlers
-     *
-     */
-
-    static uint8_t manual_probe_index;
-
-    // LCD probed points are from defaults
-    constexpr uint8_t total_probe_points = (
-      #if ENABLED(AUTO_BED_LEVELING_3POINT)
-        3
-      #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
-        GRID_MAX_POINTS
-      #endif
-    );
-
-    bool lcd_wait_for_move;
-
-    //
-    // Bed leveling is done. Wait for G29 to complete.
-    // A flag is used so that this can release control
-    // and allow the command queue to be processed.
-    //
-    // When G29 finishes the last move:
-    // - Raise Z to the "manual probe height"
-    // - Don't return until done.
-    //
-    // ** This blocks the command queue! **
-    //
-    void _lcd_level_bed_done() {
-      if (!lcd_wait_for_move) {
-        #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
-          // Display "Done" screen and wait for moves to complete
-          line_to_z(MANUAL_PROBE_HEIGHT);
-          lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
-        #endif
-        lcd_goto_previous_menu_no_defer();
-        lcd_completion_feedback();
-      }
-      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-    }
-
-    void _lcd_level_goto_next_point();
-
-    /**
-     * Step 7: Get the Z coordinate, click goes to the next point or exits
-     */
-    void _lcd_level_bed_get_z() {
-      ENCODER_DIRECTION_NORMAL();
-
-      if (use_click()) {
-
-        //
-        // Save the current Z position and move
-        //
-
-        // If done...
-        if (++manual_probe_index >= total_probe_points) {
-          //
-          // The last G29 records the point and enables bed leveling
-          //
-          lcd_wait_for_move = true;
-          lcd_goto_screen(_lcd_level_bed_done);
-          #if ENABLED(MESH_BED_LEVELING)
-            enqueue_and_echo_commands_P(PSTR("G29 S2"));
-          #elif ENABLED(PROBE_MANUALLY)
-            enqueue_and_echo_commands_P(PSTR("G29 V1"));
-          #endif
-        }
-        else
-          _lcd_level_goto_next_point();
-
-        return;
-      }
-
-      //
-      // Encoder knob or keypad buttons adjust the Z position
-      //
-      if (encoderPosition) {
-        const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
-        line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-        encoderPosition = 0;
-      }
-
-      //
-      // Draw on first display, then only on Z change
-      //
-      if (lcdDrawUpdate) {
-        const float v = current_position[Z_AXIS];
-        lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
-      }
-    }
-
-    /**
-     * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
-     */
-    void _lcd_level_bed_moving() {
-      if (lcdDrawUpdate) {
-        char msg[10];
-        sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
-        lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
-      }
-      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-      if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
-    }
-
-    /**
-     * Step 5: Initiate a move to the next point
-     */
-    void _lcd_level_goto_next_point() {
-      lcd_goto_screen(_lcd_level_bed_moving);
-
-      // G29 Records Z, moves, and signals when it pauses
-      lcd_wait_for_move = true;
-      #if ENABLED(MESH_BED_LEVELING)
-        enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
-      #elif ENABLED(PROBE_MANUALLY)
-        enqueue_and_echo_commands_P(PSTR("G29 V1"));
-      #endif
-    }
-
-    /**
-     * Step 4: Display "Click to Begin", wait for click
-     *         Move to the first probe position
-     */
-    void _lcd_level_bed_homing_done() {
-      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-      if (use_click()) {
-        manual_probe_index = 0;
-        _lcd_level_goto_next_point();
-      }
-    }
-
-    /**
-     * Step 3: Display "Homing XYZ" - Wait for homing to finish
-     */
-    void _lcd_level_bed_homing() {
-      _lcd_draw_homing();
-      if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
-    }
-
-    #if ENABLED(PROBE_MANUALLY)
-      extern bool g29_in_progress;
-    #endif
-
-    /**
-     * Step 2: Continue Bed Leveling...
-     */
-    void _lcd_level_bed_continue() {
-      defer_return_to_status = true;
-      axis_homed = 0;
-      lcd_goto_screen(_lcd_level_bed_homing);
-      enqueue_and_echo_commands_P(PSTR("G28"));
-    }
-
-  #elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-    void _lcd_ubl_level_bed();
-
-    static int16_t ubl_storage_slot = 0,
-               custom_hotend_temp = 190,
-               side_points = 3,
-               ubl_fillin_amount = 5,
-               ubl_height_amount = 1,
-               n_edit_pts = 1,
-               x_plot = 0,
-               y_plot = 0;
-
-    #if HAS_HEATED_BED
-      static int16_t custom_bed_temp = 50;
-    #endif
-
-    /**
-     * UBL Build Custom Mesh Command
-     */
-    void _lcd_ubl_build_custom_mesh() {
-      char UBL_LCD_GCODE[20];
-      enqueue_and_echo_commands_P(PSTR("G28"));
-      #if HAS_HEATED_BED
-        sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
-        lcd_enqueue_command(UBL_LCD_GCODE);
-      #endif
-      sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-      enqueue_and_echo_commands_P(PSTR("G29 P1"));
-    }
-
-    /**
-     * UBL Custom Mesh submenu
-     *
-     * << Build Mesh
-     *    Hotend Temp: ---
-     *    Bed Temp: ---
-     *    Build Custom Mesh
-     */
-    void _lcd_ubl_custom_mesh() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-      MENU_ITEM_EDIT(int3, MSG_UBL_HOTEND_TEMP_CUSTOM, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
-      #if HAS_HEATED_BED
-        MENU_ITEM_EDIT(int3, MSG_UBL_BED_TEMP_CUSTOM, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
-      #endif
-      MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
-      END_MENU();
-    }
-
-    /**
-     * UBL Adjust Mesh Height Command
-     */
-    void _lcd_ubl_adjust_height_cmd() {
-      char UBL_LCD_GCODE[16];
-      const int ind = ubl_height_amount > 0 ? 9 : 10;
-      strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
-      sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), ABS(ubl_height_amount));
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Adjust Mesh Height submenu
-     *
-     * << Edit Mesh
-     *    Height Amount: ---
-     *    Adjust Mesh Height
-     * << Info Screen
-     */
-    void _lcd_ubl_height_adjust_menu() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_EDIT_MESH_MENU);
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9, _lcd_ubl_adjust_height_cmd);
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    /**
-     * UBL Edit Mesh submenu
-     *
-     * << UBL Tools
-     *    Fine Tune All
-     *    Fine Tune Closest
-     *  - Adjust Mesh Height >>
-     * << Info Screen
-     */
-    void _lcd_ubl_edit_mesh() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_TOOLS);
-      MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-      MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_CLOSEST, PSTR("G29 P4 T"));
-      MENU_ITEM(submenu, MSG_UBL_MESH_HEIGHT_ADJUST, _lcd_ubl_height_adjust_menu);
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    /**
-     * UBL Validate Custom Mesh Command
-     */
-    void _lcd_ubl_validate_custom_mesh() {
-      char UBL_LCD_GCODE[24];
-      const int temp =
-        #if HAS_HEATED_BED
-          custom_bed_temp
-        #else
-          0
-        #endif
-      ;
-      sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
-      lcd_enqueue_commands_P(PSTR("G28"));
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Validate Mesh submenu
-     *
-     * << UBL Tools
-     *    Mesh Validation with Material 1
-     *    Mesh Validation with Material 2
-     *    Validate Custom Mesh
-     * << Info Screen
-     */
-    void _lcd_ubl_validate_mesh() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_TOOLS);
-      #if HAS_HEATED_BED
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
-      #else
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
-      #endif
-      MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    /**
-     * UBL Grid Leveling Command
-     */
-    void _lcd_ubl_grid_level_cmd() {
-      char UBL_LCD_GCODE[10];
-      sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Grid Leveling submenu
-     *
-     * << UBL Tools
-     *    Side points: ---
-     *    Level Mesh
-     */
-    void _lcd_ubl_grid_level() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_TOOLS);
-      MENU_ITEM_EDIT(int3, MSG_UBL_SIDE_POINTS, &side_points, 2, 6);
-      MENU_ITEM(function, MSG_UBL_MESH_LEVEL, _lcd_ubl_grid_level_cmd);
-      END_MENU();
-    }
-
-    /**
-     * UBL Mesh Leveling submenu
-     *
-     * << UBL Tools
-     *    3-Point Mesh Leveling
-     *  - Grid Mesh Leveling >>
-     * << Info Screen
-     */
-    void _lcd_ubl_mesh_leveling() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_TOOLS);
-      MENU_ITEM(gcode, MSG_UBL_3POINT_MESH_LEVELING, PSTR("G29 J0"));
-      MENU_ITEM(submenu, MSG_UBL_GRID_MESH_LEVELING, _lcd_ubl_grid_level);
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    /**
-     * UBL Fill-in Amount Mesh Command
-     */
-    void _lcd_ubl_fillin_amount_cmd() {
-      char UBL_LCD_GCODE[16];
-      sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Fill-in Mesh submenu
-     *
-     * << Build Mesh
-     *    Fill-in Amount: ---
-     *    Fill-in Mesh
-     *    Smart Fill-in
-     *    Manual Fill-in
-     * << Info Screen
-     */
-    void _lcd_ubl_fillin_menu() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9, _lcd_ubl_fillin_amount_cmd);
-      MENU_ITEM(gcode, MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
-      MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    void _lcd_ubl_invalidate() {
-      ubl.invalidate();
-      SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
-    }
-
-    /**
-     * UBL Build Mesh submenu
-     *
-     * << UBL Tools
-     *    Build Mesh with Material 1
-     *    Build Mesh with Material 2
-     *  - Build Custom Mesh >>
-     *    Build Cold Mesh
-     *  - Fill-in Mesh >>
-     *    Continue Bed Mesh
-     *    Invalidate All
-     *    Invalidate Closest
-     * << Info Screen
-     */
-    void _lcd_ubl_build_mesh() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_TOOLS);
-      #if HAS_HEATED_BED
-        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
-          "G28\n"
-          "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
-          "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
-          "G29 P1\n"
-          "M104 S0\n"
-          "M140 S0"
-        ));
-        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
-          "G28\n"
-          "M190 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\n"
-          "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
-          "G29 P1\n"
-          "M104 S0\n"
-          "M140 S0"
-        ));
-      #else
-        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
-          "G28\n"
-          "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
-          "G29 P1\n"
-          "M104 S0"
-        ));
-        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
-          "G28\n"
-          "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
-          "G29 P1\n"
-          "M104 S0"
-        ));
-      #endif
-      MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
-      MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
-      MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_menu);
-      MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
-      MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
-      MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
-      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-      END_MENU();
-    }
-
-    /**
-     * UBL Load Mesh Command
-     */
-    void _lcd_ubl_load_mesh_cmd() {
-      char UBL_LCD_GCODE[25];
-      sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED), ubl_storage_slot);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Save Mesh Command
-     */
-    void _lcd_ubl_save_mesh_cmd() {
-      char UBL_LCD_GCODE[25];
-      sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED), ubl_storage_slot);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Mesh Storage submenu
-     *
-     * << Unified Bed Leveling
-     *    Memory Slot: ---
-     *    Load Bed Mesh
-     *    Save Bed Mesh
-     */
-    void _lcd_ubl_storage_mesh() {
-      int16_t a = settings.calc_num_meshes();
-      START_MENU();
-      MENU_BACK(MSG_UBL_LEVEL_BED);
-      if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
-        STATIC_ITEM(MSG_NO_STORAGE);
-      }
-      else {
-        MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
-        MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
-        MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
-      }
-      END_MENU();
-    }
-
-    /**
-     * UBL LCD "radar" map homing
-     */
-    void _lcd_ubl_output_map_lcd();
-
-    void _lcd_ubl_map_homing() {
-      defer_return_to_status = true;
-      _lcd_draw_homing();
-      if (all_axes_homed()) {
-        ubl.lcd_map_control = true; // Return to the map screen
-        lcd_goto_screen(_lcd_ubl_output_map_lcd);
-      }
-    }
-
-    /**
-     * UBL LCD "radar" map point editing
-     */
-    void _lcd_ubl_map_lcd_edit_cmd() {
-      char UBL_LCD_GCODE[50], str[10], str2[10];
-      dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
-      dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
-      snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL LCD Map Movement
-     */
-    void ubl_map_move_to_xy() {
-      current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
-      current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
-      planner.buffer_line(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
-    }
-
-    /**
-     * UBL LCD "radar" map
-     */
-    void set_current_from_steppers_for_axis(const AxisEnum axis);
-    void sync_plan_position();
-
-    void _lcd_do_nothing() {}
-    void _lcd_hard_stop() {
-      const screenFunc_t old_screen = currentScreen;
-      currentScreen = _lcd_do_nothing;
-      planner.quick_stop();
-      currentScreen = old_screen;
-      set_current_from_steppers_for_axis(ALL_AXES);
-      sync_plan_position();
-    }
-
-    void _lcd_ubl_output_map_lcd() {
-      static int16_t step_scaler = 0;
-
-      if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
-      ENCODER_DIRECTION_NORMAL();
-
-      if (encoderPosition) {
-        step_scaler += (int32_t)encoderPosition;
-        x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
-        if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
-        encoderPosition = 0;
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      }
-
-      // Encoder to the right (++)
-      if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
-      if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
-
-      // Encoder to the left (--)
-      if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
-      if (y_plot <= GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1)) y_plot = GRID_MAX_POINTS_Y - 1;
-
-      // Prevent underrun/overrun of plot numbers
-      x_plot = constrain(x_plot, GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1), GRID_MAX_POINTS_X + 1);
-      y_plot = constrain(y_plot, GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1), GRID_MAX_POINTS_Y + 1);
-
-      // Determine number of points to edit
-      #if IS_KINEMATIC
-        n_edit_pts = 9; //TODO: Delta accessible edit points
-      #else
-        const bool xc = WITHIN(x_plot, 1, GRID_MAX_POINTS_X - 2),
-                   yc = WITHIN(y_plot, 1, GRID_MAX_POINTS_Y - 2);
-        n_edit_pts = yc ? (xc ? 9 : 6) : (xc ? 6 : 4); // Corners
-      #endif
-
-      if (lcdDrawUpdate) {
-        lcd_implementation_ubl_plot(x_plot, y_plot);
-
-        if (planner.movesplanned()) // If the nozzle is already moving, cancel the move.
-          _lcd_hard_stop();
-
-        ubl_map_move_to_xy();       // Move to new location
-      }
-    }
-
-    /**
-     * UBL Homing before LCD map
-     */
-    void _lcd_ubl_output_map_lcd_cmd() {
-      if (!all_axes_known()) {
-        axis_homed = 0;
-        enqueue_and_echo_commands_P(PSTR("G28"));
-      }
-      lcd_goto_screen(_lcd_ubl_map_homing);
-    }
-
-    /**
-     * UBL Output map submenu
-     *
-     * << Unified Bed Leveling
-     *  Output for Host
-     *  Output for CSV
-     *  Off Printer Backup
-     *  Output Mesh Map
-     */
-    void _lcd_ubl_output_map() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_LEVEL_BED);
-      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_HOST, PSTR("G29 T0"));
-      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_CSV, PSTR("G29 T1"));
-      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_BACKUP, PSTR("G29 S-1"));
-      MENU_ITEM(function, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map_lcd_cmd);
-      END_MENU();
-    }
-
-    /**
-     * UBL Tools submenu
-     *
-     * << Unified Bed Leveling
-     *  - Build Mesh >>
-     *  - Validate Mesh >>
-     *  - Edit Mesh >>
-     *  - Mesh Leveling >>
-     */
-    void _lcd_ubl_tools_menu() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_LEVEL_BED);
-      MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_MENU, _lcd_ubl_build_mesh);
-      MENU_ITEM(gcode, MSG_UBL_MANUAL_MESH, PSTR("G29 I999\nG29 P2 B T0"));
-      MENU_ITEM(submenu, MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-      MENU_ITEM(submenu, MSG_UBL_EDIT_MESH_MENU, _lcd_ubl_edit_mesh);
-      MENU_ITEM(submenu, MSG_UBL_MESH_LEVELING, _lcd_ubl_mesh_leveling);
-      END_MENU();
-    }
-
-    /**
-     * UBL Step-By-Step submenu
-     *
-     * << Unified Bed Leveling
-     *    1 Build Cold Mesh
-     *    2 Smart Fill-in
-     *  - 3 Validate Mesh >>
-     *    4 Fine Tune All
-     *  - 5 Validate Mesh >>
-     *    6 Fine Tune All
-     *    7 Save Bed Mesh
-     */
-    void _lcd_ubl_step_by_step() {
-      START_MENU();
-      MENU_BACK(MSG_UBL_LEVEL_BED);
-      MENU_ITEM(gcode, "1 " MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
-      MENU_ITEM(gcode, "2 " MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
-      MENU_ITEM(submenu, "3 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-      MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-      MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-      MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-      MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
-      END_MENU();
-    }
-
-    /**
-     * UBL System submenu
-     *
-     * << Motion
-     *  - Manually Build Mesh >>
-     *  - Activate UBL >>
-     *  - Deactivate UBL >>
-     *  - Step-By-Step UBL >>
-     *  - Mesh Storage >>
-     *  - Output Map >>
-     *  - UBL Tools >>
-     *  - Output UBL Info >>
-     */
-
-    void _lcd_ubl_level_bed() {
-      START_MENU();
-      MENU_BACK(MSG_MOTION);
-      MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
-      MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
-      MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
-      MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
-      MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
-      MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
-      MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
-      MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-      #endif
-      END_MENU();
-    }
-
-  #endif // AUTO_BED_LEVELING_UBL
-
-
-  #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
-    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
-  #endif
-
-  #if ENABLED(LCD_BED_LEVELING)
-
-    /**
-     * Step 1: Bed Level entry-point
-     *
-     * << Motion
-     *    Auto Home           (if homing needed)
-     *    Leveling On/Off     (if data exists, and homed)
-     *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
-     *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
-     *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
-     *    Level Bed >
-     *    Level Corners >     (if homed)
-     *    Load Settings       (Req: EEPROM_SETTINGS)
-     *    Save Settings       (Req: EEPROM_SETTINGS)
-     */
-    void lcd_bed_leveling_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MOTION);
-
-      const bool is_homed = all_axes_known();
-
-      // Auto Home if not using manual probing
-      #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
-        if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-      #endif
-
-      // Level Bed
-      #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
-        // Manual leveling uses a guided procedure
-        MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
-      #else
-        // Automatic leveling can just run the G-code
-        MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
-      #endif
-
-      // Homed and leveling is valid? Then leveling can be toggled.
-      if (is_homed && leveling_is_valid()) {
-        bool new_level_state = planner.leveling_active;
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-      }
-
-      // Z Fade Height
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-      #endif
-
-      //
-      // MBL Z Offset
-      //
-      #if ENABLED(MESH_BED_LEVELING)
-        MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-      #endif
-
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-      #elif HAS_BED_PROBE
-        MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-      #endif
-
-      #if ENABLED(LEVEL_BED_CORNERS)
-        // Move to the next corner for leveling
-        MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-      #endif
-
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-      #endif
-      END_MENU();
-    }
-
-  #endif // LCD_BED_LEVELING
-
-  /**
-   *
-   * "Movement" submenu
-   *
-   */
-
-  void lcd_movement_menu() {
-    START_MENU();
-
-    //
-    // ^ Main
-    //
-    MENU_BACK(MSG_MAIN);
-
-    //
-    // Move Axis
-    //
-    #if ENABLED(DELTA)
-      if (all_axes_homed())
-    #endif
-        MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
-
-    //
-    // Auto Home
-    //
-    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-    #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
-      MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
-      MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
-      MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
-    #endif
-
-    //
-    // TMC Z Calibration
-    //
-    #if ENABLED(TMC_Z_CALIBRATION)
-      MENU_ITEM(gcode, MSG_TMC_Z_CALIBRATION, PSTR("G28\nM915"));
-    #endif
-
-    //
-    // Level Bed
-    //
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
-
-    #elif ENABLED(LCD_BED_LEVELING)
-
-      #if ENABLED(PROBE_MANUALLY)
-        if (!g29_in_progress)
-      #endif
-          MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling_menu);
-
-    #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
-
-      #if DISABLED(PROBE_MANUALLY)
-        MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
-      #endif
-      if (leveling_is_valid()) {
-        bool new_level_state = planner.leveling_active;
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-      }
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-      #endif
-
-    #endif
-
-    #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
-        MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-    #endif
-
-    //
-    // Disable Steppers
-    //
-    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
-
-    END_MENU();
-  }
-
-  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-
-    void _man_probe_pt(const float &rx, const float &ry) {
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_xy(rx, ry);
-
-      lcd_synchronize();
-      move_menu_scale = MAX(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
-      lcd_goto_screen(lcd_move_z);
-    }
-
-  #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
-
-  #if ENABLED(DELTA_AUTO_CALIBRATION)
-
-    float lcd_probe_pt(const float &rx, const float &ry) {
-      _man_probe_pt(rx, ry);
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      defer_return_to_status = true;
-      wait_for_user = true;
-      while (wait_for_user) idle();
-      KEEPALIVE_STATE(IN_HANDLER);
-      lcd_goto_previous_menu_no_defer();
-      return current_position[Z_AXIS];
-    }
-
-  #endif // DELTA_AUTO_CALIBRATION
-
-  #if ENABLED(DELTA_CALIBRATION_MENU)
-
-    void _lcd_calibrate_homing() {
-      _lcd_draw_homing();
-      if (all_axes_homed()) lcd_goto_previous_menu();
-    }
-
-    void _lcd_delta_calibrate_home() {
-      enqueue_and_echo_commands_P(PSTR("G28"));
-      lcd_goto_screen(_lcd_calibrate_homing);
-    }
-
-    void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
-    void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
-    void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
-    void _goto_center()  { _man_probe_pt(0,0); }
-
-  #endif // DELTA_CALIBRATION_MENU
-
-  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-
-    void _recalc_delta_settings() {
-      #if HAS_LEVELING
-        reset_bed_level(); // After changing kinematics bed-level data is no longer valid
-      #endif
-      recalc_delta_settings();
-    }
-
-    void lcd_delta_settings() {
-      START_MENU();
-      MENU_BACK(MSG_DELTA_CALIBRATE);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10, delta_height + 10, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5, delta_radius + 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5, 5, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5, delta_diagonal_rod + 5, _recalc_delta_settings);
-      END_MENU();
-    }
-
-    void lcd_delta_calibrate_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      #if ENABLED(DELTA_AUTO_CALIBRATION)
-        MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
-        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 S P1"));
-        MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
-        #if ENABLED(EEPROM_SETTINGS)
-          MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-          MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-        #endif
-      #endif
-      MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
-      #if ENABLED(DELTA_CALIBRATION_MENU)
-        MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
-        if (all_axes_homed()) {
-          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
-          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
-          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
-          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
-        }
-      #endif
-      END_MENU();
-    }
-
-  #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
-
-  /**
-   * If the most recent manual move hasn't been fed to the planner yet,
-   * and the planner can accept one, send immediately
-   */
-  inline void manage_manual_move() {
-
-    if (processing_manual_move) return;
-
-    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
-
-      #if IS_KINEMATIC
-
-        const float old_feedrate = feedrate_mm_s;
-        feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
-
-        #if EXTRUDERS > 1
-          const int8_t old_extruder = active_extruder;
-          if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
-        #endif
-
-        // Set movement on a single axis
-        set_destination_from_current();
-        destination[manual_move_axis] += manual_move_offset;
-
-        // Reset for the next move
-        manual_move_offset = 0;
-        manual_move_axis = (int8_t)NO_AXIS;
-
-        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
-        // move_to_destination. This will cause idle() to be called, which can then call this function while the
-        // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
-        // processing_manual_move is true or the planner will get out of sync.
-        processing_manual_move = true;
-        prepare_move_to_destination(); // will call set_current_from_destination()
-        processing_manual_move = false;
-
-        feedrate_mm_s = old_feedrate;
-        #if EXTRUDERS > 1
-          active_extruder = old_extruder;
-        #endif
-
-      #else
-
-        planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
-        manual_move_axis = (int8_t)NO_AXIS;
-
-      #endif
-    }
-  }
-
-  /**
-   * Set a flag that lcd_update() should start a move
-   * to "current_position" after a short delay.
-   */
-  inline void manual_move_to_current(AxisEnum axis
-    #if E_MANUAL > 1
-      , const int8_t eindex=-1
-    #endif
-  ) {
-    #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
-      #if E_MANUAL > 1
-        if (axis == E_AXIS)
-      #endif
-          manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
-    #endif
-    manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
-    manual_move_axis = (int8_t)axis;
-  }
-
-  /**
-   *
-   * "Motion" > "Move Axis" submenu
-   *
-   */
-
-  void _lcd_move_xyz(PGM_P name, AxisEnum axis) {
-    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-    ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition && !processing_manual_move) {
-
-      // Start with no limits to movement
-      float min = current_position[axis] - 1000,
-            max = current_position[axis] + 1000;
-
-      // Limit to software endstops, if enabled
-      #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
-        if (soft_endstops_enabled) switch (axis) {
-          case X_AXIS:
-            #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-              min = soft_endstop_min[X_AXIS];
-            #endif
-            #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-              max = soft_endstop_max[X_AXIS];
-            #endif
-            break;
-          case Y_AXIS:
-            #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-              min = soft_endstop_min[Y_AXIS];
-            #endif
-            #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-              max = soft_endstop_max[Y_AXIS];
-            #endif
-            break;
-          case Z_AXIS:
-            #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-              min = soft_endstop_min[Z_AXIS];
-            #endif
-            #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-              max = soft_endstop_max[Z_AXIS];
-            #endif
-          default: break;
-        }
-      #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
-
-      // Delta limits XY based on the current offset from center
-      // This assumes the center is 0,0
-      #if ENABLED(DELTA)
-        if (axis != Z_AXIS) {
-          max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
-          min = -max;
-        }
-      #endif
-
-      // Get the new position
-      const float diff = float((int32_t)encoderPosition) * move_menu_scale;
-      #if IS_KINEMATIC
-        manual_move_offset += diff;
-        if ((int32_t)encoderPosition < 0)
-          NOLESS(manual_move_offset, min - current_position[axis]);
-        else
-          NOMORE(manual_move_offset, max - current_position[axis]);
-      #else
-        current_position[axis] += diff;
-        if ((int32_t)encoderPosition < 0)
-          NOLESS(current_position[axis], min);
-        else
-          NOMORE(current_position[axis], max);
-      #endif
-
-      manual_move_to_current(axis);
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-    }
-    encoderPosition = 0;
-    if (lcdDrawUpdate) {
-      const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
-        #if IS_KINEMATIC
-          + manual_move_offset
-        #endif
-      , axis);
-      lcd_implementation_drawedit(name, move_menu_scale >= 0.1f ? ftostr41sign(pos) : ftostr43sign(pos));
-    }
-  }
-  void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
-  void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
-  void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
-  void _lcd_move_e(
-    #if E_MANUAL > 1
-      const int8_t eindex=-1
-    #endif
-  ) {
-    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-    ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition) {
-      if (!processing_manual_move) {
-        const float diff = float((int32_t)encoderPosition) * move_menu_scale;
-        #if IS_KINEMATIC
-          manual_move_offset += diff;
-        #else
-          current_position[E_AXIS] += diff;
-        #endif
-        manual_move_to_current(E_AXIS
-          #if E_MANUAL > 1
-            , eindex
-          #endif
-        );
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      }
-      encoderPosition = 0;
-    }
-    if (lcdDrawUpdate) {
-      PGM_P pos_label;
-      #if E_MANUAL == 1
-        pos_label = PSTR(MSG_MOVE_E);
-      #else
-        switch (eindex) {
-          default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
-          case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
-          #if E_MANUAL > 2
-            case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
-            #if E_MANUAL > 3
-              case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
-              #if E_MANUAL > 4
-                case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
-                #if E_MANUAL > 5
-                  case 5: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E6); break;
-                #endif // E_MANUAL > 5
-              #endif // E_MANUAL > 4
-            #endif // E_MANUAL > 3
-          #endif // E_MANUAL > 2
-        }
-      #endif // E_MANUAL > 1
-      lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
-        #if IS_KINEMATIC
-          + manual_move_offset
-        #endif
-        #if ENABLED(MANUAL_E_MOVES_RELATIVE)
-          - manual_move_e_origin
-        #endif
-      ));
-    }
-  }
-
-  void lcd_move_e() { _lcd_move_e(); }
-  #if E_MANUAL > 1
-    void lcd_move_e0() { _lcd_move_e(0); }
-    void lcd_move_e1() { _lcd_move_e(1); }
-    #if E_MANUAL > 2
-      void lcd_move_e2() { _lcd_move_e(2); }
-      #if E_MANUAL > 3
-        void lcd_move_e3() { _lcd_move_e(3); }
-        #if E_MANUAL > 4
-          void lcd_move_e4() { _lcd_move_e(4); }
-          #if E_MANUAL > 5
-            void lcd_move_e5() { _lcd_move_e(5); }
-          #endif // E_MANUAL > 5
-        #endif // E_MANUAL > 4
-      #endif // E_MANUAL > 3
-    #endif // E_MANUAL > 2
-  #endif // E_MANUAL > 1
-
-  /**
-   *
-   * "Motion" > "Move Xmm" > "Move XYZ" submenu
-   *
-   */
-
-  screenFunc_t _manual_move_func_ptr;
-
-  void _goto_manual_move(const float scale) {
-    defer_return_to_status = true;
-    move_menu_scale = scale;
-    lcd_goto_screen(_manual_move_func_ptr);
-  }
-  void lcd_move_menu_10mm() { _goto_manual_move(10); }
-  void lcd_move_menu_1mm()  { _goto_manual_move( 1); }
-  void lcd_move_menu_01mm() { _goto_manual_move( 0.1f); }
-
-  void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func, const int8_t eindex=-1) {
-    _manual_move_func_ptr = func;
-    START_MENU();
-    if (LCD_HEIGHT >= 4) {
-      switch (axis) {
-        case X_AXIS:
-          STATIC_ITEM(MSG_MOVE_X, true, true); break;
-        case Y_AXIS:
-          STATIC_ITEM(MSG_MOVE_Y, true, true); break;
-        case Z_AXIS:
-          STATIC_ITEM(MSG_MOVE_Z, true, true); break;
-        default:
-          #if ENABLED(MANUAL_E_MOVES_RELATIVE)
-            manual_move_e_origin = current_position[E_AXIS];
-          #endif
-          STATIC_ITEM(MSG_MOVE_E, true, true);
-          break;
-      }
-    }
-    #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (axis == E_AXIS && thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
-        MENU_BACK(MSG_HOTEND_TOO_COLD);
-      else
-    #endif
-    {
-      MENU_BACK(MSG_MOVE_AXIS);
-      MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
-      MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
-      MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
-    }
-    END_MENU();
-  }
-  void lcd_move_get_x_amount()        { _lcd_move_distance_menu(X_AXIS, lcd_move_x); }
-  void lcd_move_get_y_amount()        { _lcd_move_distance_menu(Y_AXIS, lcd_move_y); }
-  void lcd_move_get_z_amount()        { _lcd_move_distance_menu(Z_AXIS, lcd_move_z); }
-  void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e, -1); }
-  #if E_MANUAL > 1
-    void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0, 0); }
-    void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1, 1); }
-    #if E_MANUAL > 2
-      void lcd_move_get_e2_amount()   { _lcd_move_distance_menu(E_AXIS, lcd_move_e2, 2); }
-      #if E_MANUAL > 3
-        void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3, 3); }
-        #if E_MANUAL > 4
-          void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4, 4); }
-          #if E_MANUAL > 5
-            void lcd_move_get_e5_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e5, 5); }
-          #endif // E_MANUAL > 5
-        #endif // E_MANUAL > 4
-      #endif // E_MANUAL > 3
-    #endif // E_MANUAL > 2
-  #endif // E_MANUAL > 1
-
-  /**
-   *
-   * "Motion" > "Move Axis" submenu
-   *
-   */
-  #if ENABLED(DELTA)
-    void lcd_lower_z_to_clip_height() {
-      line_to_z(delta_clip_start_height);
-      lcd_synchronize();
-    }
-  #endif
-
-  void lcd_move_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
-
-    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
-      MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
-    #endif
-
-    #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-      const bool do_move_xyz = all_axes_homed();
-    #else
-      constexpr bool do_move_xyz = true;
-    #endif
-    if (do_move_xyz) {
-      #if ENABLED(DELTA)
-        const bool do_move_xy = current_position[Z_AXIS] <= delta_clip_start_height;
-      #else
-        constexpr bool do_move_xy = true;
-      #endif
-      if (do_move_xy) {
-        MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
-        MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
-      }
-      #if ENABLED(DELTA)
-        else
-          MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
-      #endif
-
-      MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
-    }
-    else
-      MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-
-    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
-
-      #if EXTRUDERS == 6
-        switch (active_extruder) {
-          case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
-          case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
-          case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
-          case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
-          case 4: MENU_ITEM(gcode, MSG_SELECT " " MSG_E6, PSTR("T5")); break;
-          case 5: MENU_ITEM(gcode, MSG_SELECT " " MSG_E5, PSTR("T4")); break;
-        }
-      #elif EXTRUDERS == 5 || EXTRUDERS == 4
-        switch (active_extruder) {
-          case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
-          case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
-          case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
-          case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
-        }
-      #elif EXTRUDERS == 3
-        if (active_extruder < 2) {
-          if (active_extruder)
-            MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-          else
-            MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-        }
-      #else
-        if (active_extruder)
-          MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-        else
-          MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-      #endif
-
-    #elif ENABLED(DUAL_X_CARRIAGE)
-
-      if (active_extruder)
-        MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-      else
-        MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-
-    #endif
-
-    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
-
-      // Only the current...
-      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
-      // ...and the non-switching
-      #if E_MANUAL == 5
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
-      #elif E_MANUAL == 3
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
-      #endif
-
-    #else
-
-      // Independent extruders with one E-stepper per hotend
-      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
-      #if E_MANUAL > 1
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
-        #if E_MANUAL > 2
-          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
-          #if E_MANUAL > 3
-            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
-            #if E_MANUAL > 4
-              MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
-              #if E_MANUAL > 5
-                MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E6, lcd_move_get_e5_amount);
-              #endif // E_MANUAL > 5
-            #endif // E_MANUAL > 4
-          #endif // E_MANUAL > 3
-        #endif // E_MANUAL > 2
-      #endif // E_MANUAL > 1
-
-    #endif
-
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Configuration" submenu
-   *
-   */
-
-  #if HAS_LCD_CONTRAST
-    void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
-  #endif
-
-  static void lcd_factory_settings() {
-    settings.reset();
-    lcd_completion_feedback();
-  }
-
-  #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
-
-    static void lcd_init_eeprom() {
-      lcd_completion_feedback(settings.init_eeprom());
-      lcd_goto_previous_menu();
-    }
-
-    static void lcd_init_eeprom_confirm() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-      MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
-      END_MENU();
-    }
-
-  #endif
-
-  void lcd_configuration_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-
-    //
-    // Debug Menu when certain options are enabled
-    //
-    #if HAS_DEBUG_MENU
-      MENU_ITEM(submenu, MSG_DEBUG_MENU, lcd_debug_menu);
-    #endif
-
-    MENU_ITEM(submenu, MSG_ADVANCED_SETTINGS, lcd_advanced_settings_menu);
-
-    const bool busy = printer_busy();
-    if (!busy) {
-      //
-      // Delta Calibration
-      //
-      #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
-      #endif
-
-      #if ENABLED(DUAL_X_CARRIAGE)
-        MENU_ITEM(submenu, MSG_IDEX_MENU, IDEX_menu);
-      #endif
-
-      #if ENABLED(BLTOUCH)
-        MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
-      #endif
-    }
-
-    //
-    // Set single nozzle filament retract and prime length
-    //
-    #if EXTRUDERS > 1
-      MENU_ITEM(submenu, MSG_TOOL_CHANGE, tool_change_menu);
-    #endif
-
-    //
-    // Set Case light on/off/brightness
-    //
-    #if ENABLED(MENU_ITEM_CASE_LIGHT)
-      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
-        MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
-      else
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
-    #endif
-
-    #if HAS_LCD_CONTRAST
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
-    #endif
-    #if ENABLED(FWRETRACT)
-      MENU_ITEM(submenu, MSG_RETRACT, lcd_config_retract_menu);
-    #endif
-    #if ENABLED(DAC_STEPPER_CURRENT)
-      MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
-    #endif
-    #if HAS_MOTOR_CURRENT_PWM
-      MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
-    #endif
-
-    #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-      MENU_ITEM_EDIT(bool, MSG_RUNOUT_SENSOR_ENABLE, &runout.enabled);
-    #endif
-
-    #if DISABLED(SLIM_LCD_MENUS)
-      // Preheat configurations
-      MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_configuration_temperature_preheat_material1_settings_menu);
-      MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_configuration_temperature_preheat_material2_settings_menu);
-    #endif
-
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-      if (!busy)
-        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-    #endif
-
-    if (!busy)
-      MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
-
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Temperature" submenu
-   *
-   */
-
-  #if ENABLED(PID_AUTOTUNE_MENU)
-
-    #if ENABLED(PIDTEMP)
-      int16_t autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
-    #endif
-
-    #if ENABLED(PIDTEMPBED)
-      int16_t autotune_temp_bed = 70;
-    #endif
-
-    void _lcd_autotune(int16_t e) {
-      char cmd[30];
-      sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
-        #if HAS_PID_FOR_BOTH
-          e < 0 ? autotune_temp_bed : autotune_temp[e]
-        #elif ENABLED(PIDTEMPBED)
-          autotune_temp_bed
-        #else
-          autotune_temp[e]
-        #endif
-      );
-      lcd_enqueue_command(cmd);
-    }
-
-  #endif // PID_AUTOTUNE_MENU
-
-  #if ENABLED(PIDTEMP)
-
-    // Helpers for editing PID Ki & Kd values
-    // grab the PID value out of the temp variable; scale it; then update the PID driver
-    void copy_and_scalePID_i(int16_t e) {
-      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
-        UNUSED(e);
-      #endif
-      PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
-      thermalManager.updatePID();
-    }
-    void copy_and_scalePID_d(int16_t e) {
-      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
-        UNUSED(e);
-      #endif
-      PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
-      thermalManager.updatePID();
-    }
-    #define _DEFINE_PIDTEMP_BASE_FUNCS(N) \
-      void copy_and_scalePID_i_E ## N() { copy_and_scalePID_i(N); } \
-      void copy_and_scalePID_d_E ## N() { copy_and_scalePID_d(N); }
-
-    #if ENABLED(PID_AUTOTUNE_MENU)
-      #define DEFINE_PIDTEMP_FUNCS(N) \
-        _DEFINE_PIDTEMP_BASE_FUNCS(N); \
-        void lcd_autotune_callback_E ## N() { _lcd_autotune(N); } typedef void _pid_##N##_void
-    #else
-      #define DEFINE_PIDTEMP_FUNCS(N) _DEFINE_PIDTEMP_BASE_FUNCS(N) typedef void _pid_##N##_void
-    #endif
-
-    DEFINE_PIDTEMP_FUNCS(0);
-    #if ENABLED(PID_PARAMS_PER_HOTEND)
-      #if HOTENDS > 1
-        DEFINE_PIDTEMP_FUNCS(1);
-        #if HOTENDS > 2
-          DEFINE_PIDTEMP_FUNCS(2);
-          #if HOTENDS > 3
-            DEFINE_PIDTEMP_FUNCS(3);
-            #if HOTENDS > 4
-              DEFINE_PIDTEMP_FUNCS(4);
-              #if HOTENDS > 5
-                DEFINE_PIDTEMP_FUNCS(5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #endif // HOTENDS > 1
-    #endif // PID_PARAMS_PER_HOTEND
-
-  #endif // PIDTEMP
-
-  /**
-   *
-   * "Temperature" submenu
-   *
-   */
-  void lcd_temperature_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-
-    //
-    // Nozzle:
-    // Nozzle [1-5]:
-    //
-    #if HOTENDS == 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-    #else // HOTENDS > 1
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
-      #if HOTENDS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-        #if HOTENDS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-          #if HOTENDS > 4
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
-            #if HOTENDS > 5
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-
-    //
-    // Bed:
-    //
-    #if HAS_HEATED_BED
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
-    #endif
-
-    //
-    // Fan Speed:
-    //
-    #if FAN_COUNT > 0
-      #if HAS_FAN0
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
-        #endif
-      #endif
-      #if HAS_FAN1
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
-        #endif
-      #endif
-      #if HAS_FAN2
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
-        #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
-        #endif
-      #endif
-    #endif // FAN_COUNT > 0
-
-    #if HAS_TEMP_HOTEND
-
-      //
-      // Cooldown
-      //
-      bool has_heat = false;
-      HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
-      #if HAS_TEMP_BED
-        if (thermalManager.target_temperature_bed) has_heat = true;
-      #endif
-      if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
-
-      //
-      // Preheat for Material 1 and 2
-      //
-      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
-        MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
-        MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
-      #endif
-
-    #endif // HAS_TEMP_HOTEND
-
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Advanced Settings" -> "Temperature" submenu
-   *
-   */
-  void lcd_advanced_temperature_menu() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-    //
-    // Autotemp, Min, Max, Fact
-    //
-    #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
-      MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
-      MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, float(HEATER_0_MAXTEMP) - 15);
-      MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, float(HEATER_0_MAXTEMP) - 15);
-      MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0, 1);
-    #endif
-
-    //
-    // PID-P, PID-I, PID-D, PID-C, PID Autotune
-    // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
-    // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
-    // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
-    // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
-    // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
-    //
-    #if ENABLED(PIDTEMP)
-
-      #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
-        raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
-        raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
-        MENU_ITEM_EDIT(float52sign, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
-        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01f, 9990, copy_and_scalePID_i_E ## eindex); \
-        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
-
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        #define _PID_MENU_ITEMS(ELABEL, eindex) \
-          _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
-          MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
-      #else
-        #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
-      #endif
-
-      #if ENABLED(PID_AUTOTUNE_MENU)
-        #define PID_MENU_ITEMS(ELABEL, eindex) \
-          _PID_MENU_ITEMS(ELABEL, eindex); \
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
-      #else
-        #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
-      #endif
-
-      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-        PID_MENU_ITEMS(" " MSG_E1, 0);
-        PID_MENU_ITEMS(" " MSG_E2, 1);
-        #if HOTENDS > 2
-          PID_MENU_ITEMS(" " MSG_E3, 2);
-          #if HOTENDS > 3
-            PID_MENU_ITEMS(" " MSG_E4, 3);
-            #if HOTENDS > 4
-              PID_MENU_ITEMS(" " MSG_E5, 4);
-              #if HOTENDS > 5
-                PID_MENU_ITEMS(" " MSG_E6, 5);
-              #endif // HOTENDS > 5
-            #endif // HOTENDS > 4
-          #endif // HOTENDS > 3
-        #endif // HOTENDS > 2
-      #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
-        PID_MENU_ITEMS("", 0);
-      #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
-
-    #endif // PIDTEMP
-
-    END_MENU();
-  }
-
-  #if DISABLED(SLIM_LCD_MENUS)
-
-    void _lcd_configuration_temperature_preheat_settings_menu(const uint8_t material) {
-      #if HOTENDS > 5
-        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
-        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
-      #elif HOTENDS > 4
-        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
-        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
-      #elif HOTENDS > 3
-        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
-        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
-      #elif HOTENDS > 2
-        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
-        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
-      #elif HOTENDS > 1
-        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
-        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
-      #else
-        #define MINTEMP_ALL HEATER_0_MINTEMP
-        #define MAXTEMP_ALL HEATER_0_MAXTEMP
-      #endif
-      START_MENU();
-      MENU_BACK(MSG_CONFIGURATION);
-      MENU_ITEM_EDIT(int8, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
-      #if HAS_TEMP_HOTEND
-        MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
-      #endif
-      #if HAS_HEATED_BED
-        MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
-      #endif
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-      #endif
-      END_MENU();
-    }
-
-    /**
-     *
-     * "Temperature" > "Preheat Material 1 conf" submenu
-     *
-     */
-    void lcd_configuration_temperature_preheat_material1_settings_menu() { _lcd_configuration_temperature_preheat_settings_menu(0); }
-
-    /**
-     *
-     * "Temperature" > "Preheat Material 2 conf" submenu
-     *
-     */
-    void lcd_configuration_temperature_preheat_material2_settings_menu() { _lcd_configuration_temperature_preheat_settings_menu(1); }
-
-    void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
-    #if ENABLED(DISTINCT_E_FACTORS)
-      void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
-      void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
-      void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
-      #if E_STEPPERS > 2
-        void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
-        #if E_STEPPERS > 3
-          void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
-          #if E_STEPPERS > 4
-            void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
-            #if E_STEPPERS > 5
-              void _reset_e5_acceleration_rate() { _reset_e_acceleration_rate(5); }
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #endif
-
-    void _planner_refresh_positioning() { planner.refresh_positioning(); }
-    #if ENABLED(DISTINCT_E_FACTORS)
-      void _planner_refresh_e_positioning(const uint8_t e) {
-        if (e == active_extruder)
-          _planner_refresh_positioning();
-        else
-          planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.settings.axis_steps_per_mm[E_AXIS + e];
-      }
-      void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
-      void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
-      #if E_STEPPERS > 2
-        void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
-        #if E_STEPPERS > 3
-          void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
-          #if E_STEPPERS > 4
-            void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
-            #if E_STEPPERS > 5
-              void _planner_refresh_e5_positioning() { _planner_refresh_e_positioning(5); }
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #endif
-
-    // M203 / M205 Velocity options
-    void lcd_advanced_velocity_menu() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-      // M203 Max Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.settings.max_feedrate_mm_s[A_AXIS], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.settings.max_feedrate_mm_s[B_AXIS], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.settings.max_feedrate_mm_s[C_AXIS], 1, 999);
-
-      #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.settings.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
-        #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.settings.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
-          #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.settings.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
-            #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.settings.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
-              #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.settings.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
-              #endif // E_STEPPERS > 5
-            #endif // E_STEPPERS > 4
-          #endif // E_STEPPERS > 3
-        #endif // E_STEPPERS > 2
-      #else
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
-      #endif
-
-      // M205 S Min Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.settings.min_feedrate_mm_s, 0, 999);
-
-      // M205 T Min Travel Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.settings.min_travel_feedrate_mm_s, 0, 999);
-
-      END_MENU();
-    }
-
-    // M201 / M204 Accelerations
-    void lcd_advanced_acceleration_menu() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-      // M204 P Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.settings.acceleration, 10, 99000);
-
-      // M204 R Retract Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.settings.retract_acceleration, 100, 99000);
-
-      // M204 T Travel Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.settings.travel_acceleration, 100, 99000);
-
-      // M201 settings
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.settings.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.settings.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.settings.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
-
-      #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
-        #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
-          #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
-            #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
-              #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
-              #endif // E_STEPPERS > 5
-            #endif // E_STEPPERS > 4
-          #endif // E_STEPPERS > 3
-        #endif // E_STEPPERS > 2
-      #else
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
-      #endif
-
-      END_MENU();
-    }
-
-    // M205 Jerk
-    void lcd_advanced_jerk_menu() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-      #if ENABLED(JUNCTION_DEVIATION)
-        #if ENABLED(LIN_ADVANCE)
-          MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
-        #else
-          MENU_ITEM_EDIT(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f);
-        #endif
-      #endif
-      #if HAS_CLASSIC_JERK
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
-        #if ENABLED(DELTA)
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
-        #else
-          MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
-        #endif
-        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
-        #endif
-      #endif
-
-      END_MENU();
-    }
-
-    // M92 Steps-per-mm
-    void lcd_advanced_steps_per_mm_menu() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.settings.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.settings.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.settings.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
-
-      #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
-        #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
-          #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
-            #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
-              #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
-              #endif // E_STEPPERS > 5
-            #endif // E_STEPPERS > 4
-          #endif // E_STEPPERS > 3
-        #endif // E_STEPPERS > 2
-      #else
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
-      #endif
-
-      END_MENU();
-    }
-
-  #endif // !SLIM_LCD_MENUS
-
-  /**
-   *
-   * "Advanced Settings" submenu
-   *
-   */
-
-  #if HAS_M206_COMMAND
-    /**
-     * Set the home offset based on the current_position
-     */
-    void lcd_set_home_offsets() {
-      // M428 Command
-      enqueue_and_echo_commands_P(PSTR("M428"));
-      lcd_return_to_status();
-    }
-  #endif
-
-  #if ENABLED(SD_FIRMWARE_UPDATE)
-    /**
-     * Toggle the SD Firmware Update state in EEPROM
-     */
-    static void _lcd_toggle_sd_update() {
-      const bool new_state = !settings.sd_update_status();
-      lcd_completion_feedback(settings.set_sd_update_status(new_state));
-      lcd_return_to_status();
-      if (new_state) LCD_MESSAGEPGM(MSG_RESET_PRINTER); else lcd_reset_status();
-    }
-  #endif
-
-  void lcd_advanced_settings_menu() {
-    START_MENU();
-    MENU_BACK(MSG_CONFIGURATION);
-
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-    #elif HAS_BED_PROBE
-      MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-    #endif
-
-    #if DISABLED(SLIM_LCD_MENUS)
-
-      #if HAS_M206_COMMAND
-        //
-        // Set Home Offsets
-        //
-        MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-      #endif
-
-      // M203 / M205 - Feedrate items
-      MENU_ITEM(submenu, MSG_VELOCITY, lcd_advanced_velocity_menu);
-
-      // M201 - Acceleration items
-      MENU_ITEM(submenu, MSG_ACCELERATION, lcd_advanced_acceleration_menu);
-
-      // M205 - Max Jerk
-      MENU_ITEM(submenu, MSG_JERK, lcd_advanced_jerk_menu);
-
-      if (!printer_busy()) {
-        // M92 - Steps Per mm
-        MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
-      }
-
-    #endif // !SLIM_LCD_MENUS
-
-    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
-
-    #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);
-    #elif ENABLED(LIN_ADVANCE)
-      #if EXTRUDERS == 1
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
-      #elif EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
-        #if EXTRUDERS > 2
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
-          #if EXTRUDERS > 3
-            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
-            #if EXTRUDERS > 4
-              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
-              #if EXTRUDERS > 5
-                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-    #endif
-
-    // M540 S - Abort on endstop hit when SD printing
-    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-      MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
-    #endif
-
-    //
-    // BLTouch Self-Test and Reset
-    //
-    #if ENABLED(BLTOUCH)
-      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-      if (!endstops.z_probe_enabled && TEST_BLTOUCH())
-        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-    #endif
-
-    #if ENABLED(SD_FIRMWARE_UPDATE)
-      bool sd_update_state = settings.sd_update_status();
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_SD_UPDATE, &sd_update_state, _lcd_toggle_sd_update);
-    #endif
-
-    #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
-      MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
-    #endif
-
-    END_MENU();
-  }
-
-  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-    /**
-     *
-     * "Advanced Settings" > "Filament" submenu
-     *
-     */
-    void lcd_advanced_filament_menu() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-      #if ENABLED(LIN_ADVANCE)
-        #if EXTRUDERS == 1
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
-        #elif EXTRUDERS > 1
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
-          #if EXTRUDERS > 2
-            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
-            #if EXTRUDERS > 3
-              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
-              #if EXTRUDERS > 4
-                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
-                #if EXTRUDERS > 5
-                  MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
-                #endif // EXTRUDERS > 5
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      #endif
-
-      #if DISABLED(NO_VOLUMETRICS)
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
-
-        if (parser.volumetric_enabled) {
-          #if EXTRUDERS == 1
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-          #else // EXTRUDERS > 1
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-            #if EXTRUDERS > 2
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-              #if EXTRUDERS > 3
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-                #if EXTRUDERS > 4
-                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-                  #if EXTRUDERS > 5
-                    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E6, &planner.filament_size[5], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-                  #endif // EXTRUDERS > 5
-                #endif // EXTRUDERS > 4
-              #endif // EXTRUDERS > 3
-            #endif // EXTRUDERS > 2
-          #endif // EXTRUDERS > 1
-        }
-      #endif
-
-      #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        const float extrude_maxlength =
-          #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-            EXTRUDE_MAXLENGTH
-          #else
-            999
-          #endif
-        ;
-
-        #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[0].unload_length, 0, extrude_maxlength);
-        #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[active_extruder].unload_length, 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &fc_settings[0].unload_length, 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &fc_settings[1].unload_length, 0, extrude_maxlength);
-          #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &fc_settings[2].unload_length, 0, extrude_maxlength);
-            #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &fc_settings[3].unload_length, 0, extrude_maxlength);
-              #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &fc_settings[4].unload_length, 0, extrude_maxlength);
-                #if EXTRUDERS > 5
-                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &fc_settings[5].unload_length, 0, extrude_maxlength);
-                #endif // EXTRUDERS > 5
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-
-        #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[0].load_length, 0, extrude_maxlength);
-        #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[active_extruder].load_length, 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &fc_settings[0].load_length, 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &fc_settings[1].load_length, 0, extrude_maxlength);
-          #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &fc_settings[2].load_length, 0, extrude_maxlength);
-            #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &fc_settings[3].load_length, 0, extrude_maxlength);
-              #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &fc_settings[4].load_length, 0, extrude_maxlength);
-                #if EXTRUDERS > 5
-                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &fc_settings[5].load_length, 0, extrude_maxlength);
-                #endif // EXTRUDERS > 5
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      #endif
-
-      END_MENU();
-    }
-  #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
-
-  /**
-   *
-   * "Configuration" > "Retract" submenu
-   *
-   */
-  #if ENABLED(FWRETRACT)
-
-    void lcd_config_retract_menu() {
-      START_MENU();
-      MENU_BACK(MSG_CONTROL);
-      #if ENABLED(FWRETRACT_AUTORETRACT)
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
-      #endif
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.settings.retract_length, 0, 100);
-      #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.settings.swap_retract_length, 0, 100);
-      #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.settings.retract_feedrate_mm_s, 1, 999);
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZHOP, &fwretract.settings.retract_zraise, 0, 999);
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.settings.retract_recover_length, -100, 100);
-      #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.settings.swap_retract_recover_length, -100, 100);
-      #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.settings.retract_recover_feedrate_mm_s, 1, 999);
-      #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.settings.swap_retract_recover_feedrate_mm_s, 1, 999);
-      #endif
-      END_MENU();
-    }
-
-  #endif // FWRETRACT
-
-  #if ENABLED(SDSUPPORT)
-
-    #if !PIN_EXISTS(SD_DETECT)
-      void lcd_sd_refresh() {
-        card.initsd();
-        encoderTopLine = 0;
-      }
-    #endif
-
-    void lcd_sd_updir() {
-      encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
-      encoderTopLine = 0;
-      screen_changed = true;
-      lcd_refresh();
-    }
-
-    /**
-     *
-     * "Print from SD" submenu
-     *
-     */
-
-    #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-      uint32_t last_sdfile_encoderPosition = 0xFFFF;
-
-      void lcd_reselect_last_file() {
-        if (last_sdfile_encoderPosition == 0xFFFF) return;
-        #if ENABLED(DOGLCD)
-          // Some of this is a hack to force the screen update to work.
-          // TODO: Fix the real issue that causes this!
-          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-          _lcd_synchronize();
-          safe_delay(50);
-          _lcd_synchronize();
-          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-          drawing_screen = screen_changed = true;
-        #endif
-
-        lcd_goto_screen(lcd_sdcard_menu, last_sdfile_encoderPosition);
-        defer_return_to_status = true;
-        last_sdfile_encoderPosition = 0xFFFF;
-
-        #if ENABLED(DOGLCD)
-          lcd_update();
-        #endif
-      }
-    #endif
-
-    void lcd_sdcard_menu() {
-      ENCODER_DIRECTION_MENUS();
-
-      const uint16_t fileCnt = card.get_num_Files();
-
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      card.getWorkDirName();
-      if (card.filename[0] == '/') {
-        #if !PIN_EXISTS(SD_DETECT)
-          MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
-        #endif
-      }
-      else {
-        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
-      }
-
-      for (uint16_t i = 0; i < fileCnt; i++) {
-        if (_menuLineNr == _thisItemNr) {
-          const uint16_t nr =
-            #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
-              fileCnt - 1 -
-            #endif
-          i;
-
-          #if ENABLED(SDCARD_SORT_ALPHA)
-            card.getfilename_sorted(nr);
-          #else
-            card.getfilename(nr);
-          #endif
-
-          if (card.filenameIsDir)
-            MENU_ITEM(sddirectory, MSG_CARD_MENU, card);
-          else
-            MENU_ITEM(sdfile, MSG_CARD_MENU, card);
-        }
-        else {
-          MENU_ITEM_DUMMY();
-        }
-      }
-      END_MENU();
-    }
-
-  #endif // SDSUPPORT
-
-  #if ENABLED(LCD_INFO_MENU)
-
-    #if ENABLED(PRINTCOUNTER)
-      /**
-       *
-       * About Printer > Statistics submenu
-       *
-       */
-      void lcd_info_stats_menu() {
-        if (use_click()) { return lcd_goto_previous_menu(); }
-
-        char buffer[21];
-        printStatistics stats = print_job_timer.getStats();
-
-        START_SCREEN();                                                                                // 12345678901234567890
-        STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));          // Print Count: 999
-        STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints));   // Completed  : 666
-
-        duration_t elapsed = stats.printTime;
-        elapsed.toString(buffer);
-
-        STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", false, false);                                           // Total print Time:
-        STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
-
-        elapsed = stats.longestPrint;
-        elapsed.toString(buffer);
-
-        STATIC_ITEM(MSG_INFO_PRINT_LONGEST ": ", false, false);                                        // Longest job time:
-        STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
-
-        sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
-        STATIC_ITEM(MSG_INFO_PRINT_FILAMENT ": ", false, false);                                       // Extruded total:
-        STATIC_ITEM("", false, false, buffer);                                                         // 125m
-        END_SCREEN();
-      }
-    #endif // PRINTCOUNTER
-
-    /**
-     *
-     * About Printer > Thermistors
-     *
-     */
-    void lcd_info_thermistors_menu() {
-      if (use_click()) { return lcd_goto_previous_menu(); }
-      START_SCREEN();
-      #define THERMISTOR_ID TEMP_SENSOR_0
-      #include "thermistornames.h"
-      STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
-
-      #if TEMP_SENSOR_1 != 0
-        #undef THERMISTOR_ID
-        #define THERMISTOR_ID TEMP_SENSOR_1
-        #include "thermistornames.h"
-        STATIC_ITEM("T1: " THERMISTOR_NAME, false, true);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP), false);
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP), false);
-      #endif
-
-      #if TEMP_SENSOR_2 != 0
-        #undef THERMISTOR_ID
-        #define THERMISTOR_ID TEMP_SENSOR_2
-        #include "thermistornames.h"
-        STATIC_ITEM("T2: " THERMISTOR_NAME, false, true);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP), false);
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP), false);
-      #endif
-
-      #if TEMP_SENSOR_3 != 0
-        #undef THERMISTOR_ID
-        #define THERMISTOR_ID TEMP_SENSOR_3
-        #include "thermistornames.h"
-        STATIC_ITEM("T3: " THERMISTOR_NAME, false, true);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP), false);
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP), false);
-      #endif
-
-      #if TEMP_SENSOR_4 != 0
-        #undef THERMISTOR_ID
-        #define THERMISTOR_ID TEMP_SENSOR_4
-        #include "thermistornames.h"
-        STATIC_ITEM("T4: " THERMISTOR_NAME, false, true);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_4_MINTEMP), false);
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_4_MAXTEMP), false);
-      #endif
-
-      #if HAS_HEATED_BED
-        #undef THERMISTOR_ID
-        #define THERMISTOR_ID TEMP_SENSOR_BED
-        #include "thermistornames.h"
-        STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
-        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
-        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
-      #endif
-      END_SCREEN();
-    }
-
-    /**
-     *
-     * About Printer > Board Info
-     *
-     */
-    void lcd_info_board_menu() {
-      if (use_click()) { return lcd_goto_previous_menu(); }
-      START_SCREEN();
-      STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
-      STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
-      STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
-      #if POWER_SUPPLY == 0
-        STATIC_ITEM(MSG_INFO_PSU ": Generic", true);
-      #elif POWER_SUPPLY == 1
-        STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
-      #elif POWER_SUPPLY == 2
-        STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
-      #endif
-      END_SCREEN();
-    }
-
-    /**
-     *
-     * About Printer > Printer Info
-     *
-     */
-    void lcd_info_printer_menu() {
-      if (use_click()) { return lcd_goto_previous_menu(); }
-      START_SCREEN();
-      STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
-      STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
-      STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
-      STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
-      STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
-      STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
-      #if ENABLED(AUTO_BED_LEVELING_3POINT)
-        STATIC_ITEM(MSG_3POINT_LEVELING, true);                        // 3-Point Leveling
-      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
-        STATIC_ITEM(MSG_LINEAR_LEVELING, true);                        // Linear Leveling
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        STATIC_ITEM(MSG_BILINEAR_LEVELING, true);                      // Bi-linear Leveling
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        STATIC_ITEM(MSG_UBL_LEVELING, true);                           // Unified Bed Leveling
-      #elif ENABLED(MESH_BED_LEVELING)
-        STATIC_ITEM(MSG_MESH_LEVELING, true);                          // Mesh Leveling
-      #endif
-      END_SCREEN();
-    }
-
-    /**
-     *
-     * "About Printer" submenu
-     *
-     */
-    void lcd_info_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, lcd_info_printer_menu);        // Printer Info >
-      MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, lcd_info_board_menu);            // Board Info >
-      MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, lcd_info_thermistors_menu); // Thermistors >
-      #if ENABLED(PRINTCOUNTER)
-        MENU_ITEM(submenu, MSG_INFO_STATS_MENU, lcd_info_stats_menu);          // Printer Statistics >
-      #endif
-      END_MENU();
-    }
-  #endif // LCD_INFO_MENU
-
-  /**
-   *
-   * LED Menu
-   *
-   */
-
-  #if ENABLED(LED_CONTROL_MENU)
-
-    #if ENABLED(LED_COLOR_PRESETS)
-
-      void lcd_led_presets_menu() {
-        START_MENU();
-        #if LCD_HEIGHT > 2
-          STATIC_ITEM(MSG_LED_PRESETS, true, true);
-        #endif
-        MENU_BACK(MSG_LED_CONTROL);
-        MENU_ITEM(function, MSG_SET_LEDS_WHITE, leds.set_white);
-        MENU_ITEM(function, MSG_SET_LEDS_RED, leds.set_red);
-        MENU_ITEM(function, MSG_SET_LEDS_ORANGE, leds.set_orange);
-        MENU_ITEM(function, MSG_SET_LEDS_YELLOW,leds.set_yellow);
-        MENU_ITEM(function, MSG_SET_LEDS_GREEN, leds.set_green);
-        MENU_ITEM(function, MSG_SET_LEDS_BLUE, leds.set_blue);
-        MENU_ITEM(function, MSG_SET_LEDS_INDIGO, leds.set_indigo);
-        MENU_ITEM(function, MSG_SET_LEDS_VIOLET, leds.set_violet);
-        END_MENU();
-      }
-    #endif // LED_COLOR_PRESETS
-
-    void lcd_led_custom_menu() {
-      START_MENU();
-      MENU_BACK(MSG_LED_CONTROL);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_R, &leds.color.r, 0, 255, leds.update, true);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_G, &leds.color.g, 0, 255, leds.update, true);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_B, &leds.color.b, 0, 255, leds.update, true);
-      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
-        MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_W, &leds.color.w, 0, 255, leds.update, true);
-        #if ENABLED(NEOPIXEL_LED)
-          MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_BRIGHTNESS, &leds.color.i, 0, 255, leds.update, true);
-        #endif
-      #endif
-      END_MENU();
-    }
-
-    void lcd_led_menu() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-      bool led_on = leds.lights_on;
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_LEDS, &led_on, leds.toggle);
-      MENU_ITEM(function, MSG_SET_LEDS_DEFAULT, leds.set_default);
-      #if ENABLED(LED_COLOR_PRESETS)
-        MENU_ITEM(submenu, MSG_LED_PRESETS, lcd_led_presets_menu);
-      #endif
-      MENU_ITEM(submenu, MSG_CUSTOM_LEDS, lcd_led_custom_menu);
-      END_MENU();
-    }
-
-  #endif // LED_CONTROL_MENU
-
-  /**
-   *
-   * Filament Change Feature Screens
-   *
-   */
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-    /**
-     *
-     * "Change Filament" > "Change/Unload/Load Filament" submenu
-     *
-     */
-    static AdvancedPauseMode _change_filament_temp_mode;
-    static int8_t _change_filament_temp_extruder;
-
-    static PGM_P _change_filament_temp_command() {
-      switch (_change_filament_temp_mode) {
-        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-          return PSTR("M701 T%d");
-        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-          return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
-        case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
-        default:
-          return PSTR("M600 B0 T%d");
-      }
-      return PSTR(MSG_FILAMENTCHANGE);
-    }
-
-    void _change_filament_temp(const uint16_t temperature) {
-      char cmd[11];
-      sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
-      thermalManager.setTargetHotend(temperature, _change_filament_temp_extruder);
-      lcd_enqueue_command(cmd);
-    }
-    void _lcd_change_filament_temp_1_menu() { _change_filament_temp(PREHEAT_1_TEMP_HOTEND); }
-    void _lcd_change_filament_temp_2_menu() { _change_filament_temp(PREHEAT_2_TEMP_HOTEND); }
-    void _lcd_change_filament_temp_custom_menu() { _change_filament_temp(thermalManager.target_temperature[_change_filament_temp_extruder]); }
-
-    static PGM_P change_filament_header(const AdvancedPauseMode mode) {
-      switch (mode) {
-        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-          return PSTR(MSG_FILAMENTLOAD);
-        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-          return PSTR(MSG_FILAMENTUNLOAD);
-        default: break;
-      }
-      return PSTR(MSG_FILAMENTCHANGE);
-    }
-
-    void _lcd_temp_menu_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
-      _change_filament_temp_mode = mode;
-      _change_filament_temp_extruder = extruder;
-      START_MENU();
-      if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
-      MENU_BACK(MSG_BACK);
-      MENU_ITEM(submenu, MSG_PREHEAT_1, _lcd_change_filament_temp_1_menu);
-      MENU_ITEM(submenu, MSG_PREHEAT_2, _lcd_change_filament_temp_2_menu);
-      uint16_t max_temp;
-      switch (extruder) {
-        default: max_temp = HEATER_0_MAXTEMP;
-        #if HOTENDS > 1
-          case 1: max_temp = HEATER_1_MAXTEMP; break;
-          #if HOTENDS > 2
-            case 2: max_temp = HEATER_2_MAXTEMP; break;
-            #if HOTENDS > 3
-              case 3: max_temp = HEATER_3_MAXTEMP; break;
-              #if HOTENDS > 4
-                case 4: max_temp = HEATER_4_MAXTEMP; break;
-                #if HOTENDS > 5
-                  case 5: max_temp = HEATER_5_MAXTEMP; break;
-                #endif
-              #endif
-            #endif
-          #endif
-        #endif
-      }
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PREHEAT_CUSTOM, &thermalManager.target_temperature[_change_filament_temp_extruder], EXTRUDE_MINTEMP, max_temp - 15, _lcd_change_filament_temp_custom_menu);
-      END_MENU();
-    }
-    void lcd_temp_menu_e0_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
-    void lcd_temp_menu_e0_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
-    void lcd_temp_menu_e0_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
-    #if E_STEPPERS > 1
-      void lcd_temp_menu_e1_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
-      void lcd_temp_menu_e1_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
-      void lcd_temp_menu_e1_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
-      #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
-        void lcd_unload_filament_all_temp_menu() { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, -1); }
-      #endif
-      #if E_STEPPERS > 2
-        void lcd_temp_menu_e2_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 2); }
-        void lcd_temp_menu_e2_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 2); }
-        void lcd_temp_menu_e2_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 2); }
-        #if E_STEPPERS > 3
-          void lcd_temp_menu_e3_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 3); }
-          void lcd_temp_menu_e3_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 3); }
-          void lcd_temp_menu_e3_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 3); }
-          #if E_STEPPERS > 4
-            void lcd_temp_menu_e4_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 4); }
-            void lcd_temp_menu_e4_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 4); }
-            void lcd_temp_menu_e4_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 4); }
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #endif // E_STEPPERS > 1
-
-    /**
-     *
-     * "Change Filament" submenu
-     *
-     */
-    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      void lcd_change_filament_menu() {
-        START_MENU();
-        MENU_BACK(MSG_MAIN);
-
-        // Change filament
-        #if E_STEPPERS == 1
-          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
-          if (thermalManager.targetTooColdToExtrude(active_extruder))
-            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
-          else
-            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
-        #else
-          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);
-          PGM_P msg1 = PSTR(MSG_FILAMENTCHANGE " " MSG_E2);
-          if (thermalManager.targetTooColdToExtrude(0))
-            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
-          else
-            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0 T0"));
-          if (thermalManager.targetTooColdToExtrude(1))
-            MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_change);
-          else
-            MENU_ITEM_P(gcode, msg1, PSTR("M600 B0 T1"));
-          #if E_STEPPERS > 2
-            PGM_P msg2 = PSTR(MSG_FILAMENTCHANGE " " MSG_E3);
-            if (thermalManager.targetTooColdToExtrude(2))
-              MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_change);
-            else
-              MENU_ITEM_P(gcode, msg2, PSTR("M600 B0 T2"));
-            #if E_STEPPERS > 3
-              PGM_P msg3 = PSTR(MSG_FILAMENTCHANGE " " MSG_E4);
-              if (thermalManager.targetTooColdToExtrude(3))
-                MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_change);
-              else
-                MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
-              #if E_STEPPERS > 4
-                PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
-                if (thermalManager.targetTooColdToExtrude(4))
-                  MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_change);
-                else
-                  MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
-                #if E_STEPPERS > 5
-                  PGM_P msg5 = PSTR(MSG_FILAMENTCHANGE " " MSG_E6);
-                  if (thermalManager.targetTooColdToExtrude(5))
-                    MENU_ITEM_P(submenu, msg5, lcd_temp_menu_e5_filament_change);
-                  else
-                    MENU_ITEM_P(gcode, msg5, PSTR("M600 B0 T5"));
-                #endif // E_STEPPERS > 5
-              #endif // E_STEPPERS > 4
-            #endif // E_STEPPERS > 3
-          #endif // E_STEPPERS > 2
-        #endif // E_STEPPERS == 1
-
-        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-          if (!printer_busy()) {
-            // Load filament
-            #if E_STEPPERS == 1
-              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
-              if (thermalManager.targetTooColdToExtrude(active_extruder))
-                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
-              else
-                MENU_ITEM_P(gcode, msg0, PSTR("M701"));
-            #else
-              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
-              PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);
-              if (thermalManager.targetTooColdToExtrude(0))
-                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
-              else
-                MENU_ITEM_P(gcode, msg0, PSTR("M701 T0"));
-              if (thermalManager.targetTooColdToExtrude(1))
-                MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_load);
-              else
-                MENU_ITEM_P(gcode, msg1, PSTR("M701 T1"));
-              #if E_STEPPERS > 2
-                PGM_P msg2 = PSTR(MSG_FILAMENTLOAD " " MSG_E3);
-                if (thermalManager.targetTooColdToExtrude(2))
-                  MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_load);
-                else
-                  MENU_ITEM_P(gcode, msg2, PSTR("M701 T2"));
-                #if E_STEPPERS > 3
-                  PGM_P msg3 = PSTR(MSG_FILAMENTLOAD " " MSG_E4);
-                  if (thermalManager.targetTooColdToExtrude(3))
-                    MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_load);
-                  else
-                    MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
-                  #if E_STEPPERS > 4
-                    PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
-                    if (thermalManager.targetTooColdToExtrude(4))
-                      MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_load);
-                    else
-                      MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
-                    #if E_STEPPERS > 5
-                      PGM_P msg5 = PSTR(MSG_FILAMENTLOAD " " MSG_E6);
-                      if (thermalManager.targetTooColdToExtrude(5))
-                        MENU_ITEM_P(submenu, msg5, lcd_temp_menu_e5_filament_load);
-                      else
-                        MENU_ITEM_P(gcode, msg5, PSTR("M701 T5"));
-                    #endif // E_STEPPERS > 5
-                  #endif // E_STEPPERS > 4
-                #endif // E_STEPPERS > 3
-              #endif // E_STEPPERS > 2
-            #endif // E_STEPPERS == 1
-
-            // Unload filament
-            #if E_STEPPERS == 1
-              if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
-              else
-                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, lcd_temp_menu_e0_filament_unload);
-            #else
-              #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
-                if (thermalManager.targetHotEnoughToExtrude(0)
-                  #if E_STEPPERS > 1
-                    && thermalManager.targetHotEnoughToExtrude(1)
-                    #if E_STEPPERS > 2
-                      && thermalManager.targetHotEnoughToExtrude(2)
-                      #if E_STEPPERS > 3
-                        && thermalManager.targetHotEnoughToExtrude(3)
-                        #if E_STEPPERS > 4
-                          && thermalManager.targetHotEnoughToExtrude(4)
-                          #if E_STEPPERS > 5
-                            && thermalManager.targetHotEnoughToExtrude(5)
-                          #endif // E_STEPPERS > 5
-                        #endif // E_STEPPERS > 4
-                      #endif // E_STEPPERS > 3
-                    #endif // E_STEPPERS > 2
-                  #endif // E_STEPPERS > 1
-                )
-                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
-              else
-                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, lcd_unload_filament_all_temp_menu);
-              #endif
-              if (thermalManager.targetHotEnoughToExtrude(0))
-                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
-              else
-                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, lcd_temp_menu_e0_filament_unload);
-              if (thermalManager.targetHotEnoughToExtrude(1))
-                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
-              else
-                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, lcd_temp_menu_e1_filament_unload);
-              #if E_STEPPERS > 2
-                if (thermalManager.targetHotEnoughToExtrude(2))
-                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
-                else
-                  MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, lcd_temp_menu_e2_filament_unload);
-                #if E_STEPPERS > 3
-                  if (thermalManager.targetHotEnoughToExtrude(3))
-                    MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
-                  else
-                    MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, lcd_temp_menu_e3_filament_unload);
-                  #if E_STEPPERS > 4
-                    if (thermalManager.targetHotEnoughToExtrude(4))
-                      MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
-                    else
-                      MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, lcd_temp_menu_e4_filament_unload);
-                    #if E_STEPPERS > 5
-                      if (thermalManager.targetHotEnoughToExtrude(5))
-                        MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E6, PSTR("M702 T5"));
-                      else
-                        MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E6, lcd_temp_menu_e5_filament_unload);
-                    #endif // E_STEPPERS > 5
-                  #endif // E_STEPPERS > 4
-                #endif // E_STEPPERS > 3
-              #endif // E_STEPPERS > 2
-            #endif // E_STEPPERS == 1
-          }
-        #endif
-
-        END_MENU();
-      }
-    #endif
-
-    static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
-    static uint8_t hotend_status_extruder = 0;
-
-    static PGM_P advanced_pause_header() {
-      switch (advanced_pause_mode) {
-        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-          return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
-        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-          return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
-        default: break;
-      }
-      return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
-    }
-
-    // Portions from STATIC_ITEM...
-    #define HOTEND_STATUS_ITEM() do { \
-      if (_menuLineNr == _thisItemNr) { \
-        if (lcdDrawUpdate) { \
-          lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
-          lcd_implementation_hotend_status(_lcdLineNr, hotend_status_extruder); \
-        } \
-        if (_skipStatic && encoderLine <= _thisItemNr) { \
-          encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
-          ++encoderLine; \
-        } \
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-      } \
-      ++_thisItemNr; \
-    }while(0)
-
-    void lcd_advanced_pause_resume_print() {
-      advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
-    }
-
-    void lcd_advanced_pause_extrude_more() {
-      advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
-    }
-
-    void lcd_advanced_pause_option_menu() {
-      START_MENU();
-      #if LCD_HEIGHT > 2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
-      #endif
-      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
-      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_PURGE, lcd_advanced_pause_extrude_more);
-      END_MENU();
-    }
-
-    void lcd_advanced_pause_init_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
-      #ifdef MSG_FILAMENT_CHANGE_INIT_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
-        #define __FC_LINES_A 3
-      #else
-        #define __FC_LINES_A 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_INIT_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
-        #define _FC_LINES_A (__FC_LINES_A + 1)
-      #else
-        #define _FC_LINES_A __FC_LINES_A
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_A + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_unload_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
-      #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
-        #define __FC_LINES_B 3
-      #else
-        #define __FC_LINES_B 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
-        #define _FC_LINES_B (__FC_LINES_B + 1)
-      #else
-        #define _FC_LINES_B __FC_LINES_B
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_B + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_wait_for_nozzles_to_heat() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
-      #ifdef MSG_FILAMENT_CHANGE_HEATING_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
-        #define _FC_LINES_C 3
-      #else
-        #define _FC_LINES_C 2
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_C + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_heat_nozzle() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
-      #ifdef MSG_FILAMENT_CHANGE_INSERT_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
-        #define _FC_LINES_D 3
-      #else
-        #define _FC_LINES_D 2
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_D + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_insert_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
-      #ifdef MSG_FILAMENT_CHANGE_INSERT_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
-        #define __FC_LINES_E 3
-      #else
-        #define __FC_LINES_E 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_INSERT_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
-        #define _FC_LINES_E (__FC_LINES_E + 1)
-      #else
-        #define _FC_LINES_E __FC_LINES_E
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_E + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_load_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
-      #ifdef MSG_FILAMENT_CHANGE_LOAD_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
-        #define __FC_LINES_F 3
-      #else
-        #define __FC_LINES_F 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_LOAD_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
-        #define _FC_LINES_F (__FC_LINES_F + 1)
-      #else
-        #define _FC_LINES_F __FC_LINES_F
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_F + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    void lcd_advanced_pause_purge_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
-      #ifdef MSG_FILAMENT_CHANGE_PURGE_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
-        #define __FC_LINES_G 3
-      #else
-        #define __FC_LINES_G 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_PURGE_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
-        #define _FC_LINES_G (__FC_LINES_G + 1)
-      #else
-        #define _FC_LINES_G __FC_LINES_G
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_G + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_SCREEN();
-    }
-
-    #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-      void lcd_advanced_pause_continuous_purge_menu() {
-        START_SCREEN();
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
-        #ifdef MSG_FILAMENT_CHANGE_PURGE_2
-          STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
-          #define __FC_LINES_G 3
-        #else
-          #define __FC_LINES_G 2
-        #endif
-        #ifdef MSG_FILAMENT_CHANGE_PURGE_3
-          STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
-          #define _FC_LINES_G (__FC_LINES_G + 1)
-        #else
-          #define _FC_LINES_G __FC_LINES_G
-        #endif
-        #if LCD_HEIGHT > _FC_LINES_G + 1
-          STATIC_ITEM(" ");
-        #endif
-        HOTEND_STATUS_ITEM();
-        STATIC_ITEM(MSG_USERWAIT);
-        END_SCREEN();
-      }
-    #endif
-
-    void lcd_advanced_pause_resume_message() {
-      START_SCREEN();
-      STATIC_ITEM_P(advanced_pause_header(), true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
-      #ifdef MSG_FILAMENT_CHANGE_RESUME_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_RESUME_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
-      #endif
-      END_SCREEN();
-    }
-
-    FORCE_INLINE screenFunc_t ap_message_screen(const AdvancedPauseMessage message) {
-      switch (message) {
-        case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
-        case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
-        case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
-        case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
-        case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
-        case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
-        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
-        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
-        case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
-                                            return lcd_advanced_pause_option_menu;
-        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-          case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return lcd_advanced_pause_continuous_purge_menu;
-        #endif
-        case ADVANCED_PAUSE_MESSAGE_STATUS:
-        default: break;
-      }
-      return NULL;
-    }
-
-    void lcd_advanced_pause_show_message(
-      const AdvancedPauseMessage message,
-      const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
-      const uint8_t extruder/*=active_extruder*/
-    ) {
-      advanced_pause_mode = mode;
-      hotend_status_extruder = extruder;
-      const screenFunc_t next_screen = ap_message_screen(message);
-      if (next_screen) {
-        defer_return_to_status = true;
-        lcd_goto_screen(next_screen);
-      }
-      else
-        lcd_return_to_status();
-    }
-
-  #endif // ADVANCED_PAUSE_FEATURE
-
-  /**
-   *
-   * Functions for editing single values
-   *
-   * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
-   *
-   * For example, DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1) expands into these functions:
-   *
-   *   bool _menu_edit_int3();
-   *   void menu_edit_int3(); // edit int16_t (interactively)
-   *   void menu_edit_callback_int3(); // edit int16_t (interactively) with callback on completion
-   *   void _menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
-   *   void menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
-   *   void menu_action_setting_edit_callback_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
-   *
-   * You can then use one of the menu macros to present the edit interface:
-   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
-   *
-   * This expands into a more primitive menu item:
-   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
-   *
-   * ...which calls:
-   *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
-   */
-  #define DEFINE_MENU_EDIT_TYPE(_type, _name, _strFunc, _scale) \
-    bool _menu_edit_ ## _name() { \
-      ENCODER_DIRECTION_NORMAL(); \
-      if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
-      if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
-      if (lcdDrawUpdate) \
-        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale))); \
-      if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
-        _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale); \
-        if (editValue != NULL) *((_type*)editValue) = value; \
-        if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
-        if (lcd_clicked) lcd_goto_previous_menu(); \
-      } \
-      return use_click(); \
-    } \
-    void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
-    void _menu_action_setting_edit_ ## _name(PGM_P const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
-      lcd_save_previous_screen(); \
-      lcd_refresh(); \
-      \
-      editLabel = pstr; \
-      editValue = ptr; \
-      minEditValue = minValue * _scale; \
-      maxEditValue = maxValue * _scale - minEditValue; \
-      encoderPosition = (*ptr) * _scale - minEditValue; \
-    } \
-    void menu_action_setting_edit_callback_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
-      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
-      currentScreen = menu_edit_ ## _name; \
-      callbackFunc = callback; \
-      liveEdit = live; \
-    } \
-    FORCE_INLINE void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
-      menu_action_setting_edit_callback_ ## _name(pstr, ptr, minValue, maxValue); \
-    } \
-    typedef void _name##_void
-
-  DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
-  DEFINE_MENU_EDIT_TYPE(int16_t, int4, itostr4sign, 1);
-  DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
-  DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
-  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
-  DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
-  DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
-  DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10);
-  DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100);
-  DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100);
-  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01f);
-
-  /**
-   *
-   * Handlers for Keypad input
-   *
-   */
-  #if ENABLED(ADC_KEYPAD)
-
-    inline bool handle_adc_keypad() {
-      #define ADC_MIN_KEY_DELAY 100
-      if (buttons_reprapworld_keypad) {
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-        if (encoderDirection == -1) { // side effect which signals we are inside a menu
-          if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(true); }
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(true); }
-        }
-        else {
-          if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
-                 if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
-            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
-            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
-          }
-        }
-        #if ENABLED(ADC_KEYPAD_DEBUG)
-          SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
-          SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
-        #endif
-        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
-        return true;
-      }
-
-      return false;
-    }
-
-  #elif ENABLED(REPRAPWORLD_KEYPAD)
-
-    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
-      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-      encoderPosition = dir;
-      switch (axis) {
-        case X_AXIS: lcd_move_x(); break;
-        case Y_AXIS: lcd_move_y(); break;
-        case Z_AXIS: lcd_move_z();
-        default: break;
-      }
-    }
-    void reprapworld_keypad_move_z_up()    { _reprapworld_keypad_move(Z_AXIS,  1); }
-    void reprapworld_keypad_move_z_down()  { _reprapworld_keypad_move(Z_AXIS, -1); }
-    void reprapworld_keypad_move_x_left()  { _reprapworld_keypad_move(X_AXIS, -1); }
-    void reprapworld_keypad_move_x_right() { _reprapworld_keypad_move(X_AXIS,  1); }
-    void reprapworld_keypad_move_y_up()    { _reprapworld_keypad_move(Y_AXIS, -1); }
-    void reprapworld_keypad_move_y_down()  { _reprapworld_keypad_move(Y_AXIS,  1); }
-    void reprapworld_keypad_move_home()    { enqueue_and_echo_commands_P(PSTR("G28")); } // move all axes home and wait
-    void reprapworld_keypad_move_menu()    { lcd_goto_screen(lcd_move_menu); }
-
-    inline void handle_reprapworld_keypad() {
-
-      static uint8_t keypad_debounce = 0;
-
-      if (!REPRAPWORLD_KEYPAD_PRESSED) {
-        if (keypad_debounce > 0) keypad_debounce--;
-      }
-      else if (!keypad_debounce) {
-        keypad_debounce = 2;
-
-        if (REPRAPWORLD_KEYPAD_MOVE_MENU)       reprapworld_keypad_move_menu();
-
-        #if DISABLED(DELTA) && Z_HOME_DIR == -1
-          if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
-        #endif
-
-        if (all_axes_homed()) {
-          #if ENABLED(DELTA) || Z_HOME_DIR != -1
-            if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
-          #endif
-          if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
-          if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
-          if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
-          if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
-          if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
-        }
-        else {
-          if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
-        }
-      }
-    }
-
-  #endif // REPRAPWORLD_KEYPAD
+  #if ENABLED(ULTIPANEL)
+    lcd_refresh();
+    if (clear_buttons) buttons = 0;
+    next_button_update_ms = millis() + 500;
+  #else
+    UNUSED(clear_buttons);
+  #endif
 
-  /**
-   *
-   * Menu actions
-   *
-   */
-  void _menu_action_back() { lcd_goto_previous_menu(); }
-  void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
-  void menu_action_gcode(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
-  void menu_action_function(screenFunc_t func) { (*func)(); }
+  // Buzz and wait. The delay is needed for buttons to settle!
+  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
 
-  #if ENABLED(SDSUPPORT)
+  #if ENABLED(ULTIPANEL)
+    #if ENABLED(LCD_USE_I2C_BUZZER)
+      delay(10);
+    #elif PIN_EXISTS(BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #endif
+  #endif
+}
 
-    void menu_action_sdfile(CardReader &theCard) {
-      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-        last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
-      #endif
-      card.openAndPrintFile(theCard.filename);
-      lcd_return_to_status();
-      lcd_reset_status();
-    }
+#if ENABLED(ULTIPANEL)
 
-    void menu_action_sddirectory(CardReader &theCard) {
-      card.chdir(theCard.filename);
-      encoderTopLine = 0;
-      encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
-      screen_changed = true;
-      #if ENABLED(DOGLCD)
-        drawing_screen = false;
-      #endif
-      lcd_refresh();
-    }
+  extern bool no_reentry; // Flag to prevent recursion into menu handlers
 
-  #endif // SDSUPPORT
+  int8_t manual_move_axis = (int8_t)NO_AXIS;
+  millis_t manual_move_start_time = 0;
 
-  void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
-  void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callback) {
-    menu_action_setting_edit_bool(pstr, ptr);
-    (*callback)();
-  }
+  #if IS_KINEMATIC
+    bool processing_manual_move = false;
+    float manual_move_offset = 0;
+  #endif
 
-#endif // ULTIPANEL
+  #if !IS_KINEMATIC || (IS_KINEMATIC && EXTRUDERS > 1)
+    int8_t manual_move_e_index = 0;
+  #else
+    constexpr int8_t manual_move_e_index = 0;
+  #endif
 
-void lcd_init() {
+  /**
+   * If the most recent manual move hasn't been fed to the planner yet,
+   * and the planner can accept one, send a move immediately.
+   */
+  void manage_manual_move() {
 
-  lcd_implementation_init();
+    if (processing_manual_move) return;
 
-  #if ENABLED(NEWPANEL)
-    #if BUTTON_EXISTS(EN1)
-      SET_INPUT_PULLUP(BTN_EN1);
-    #endif
-    #if BUTTON_EXISTS(EN2)
-      SET_INPUT_PULLUP(BTN_EN2);
-    #endif
-    #if BUTTON_EXISTS(ENC)
-      SET_INPUT_PULLUP(BTN_ENC);
-    #endif
+    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
 
-    #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
-      SET_OUTPUT(SHIFT_CLK);
-      OUT_WRITE(SHIFT_LD, HIGH);
-      SET_INPUT_PULLUP(SHIFT_OUT);
-    #endif
+      #if IS_KINEMATIC
 
-    #if BUTTON_EXISTS(UP)
-      SET_INPUT(BTN_UP);
-    #endif
-    #if BUTTON_EXISTS(DWN)
-      SET_INPUT(BTN_DWN);
-    #endif
-    #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LFT);
-    #endif
-    #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RT);
-    #endif
+        const float old_feedrate = feedrate_mm_s;
+        feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
 
-  #else // !NEWPANEL
+        #if EXTRUDERS > 1
+          const int8_t old_extruder = active_extruder;
+          if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
+        #endif
 
-    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
-      SET_OUTPUT(SR_DATA_PIN);
-      SET_OUTPUT(SR_CLK_PIN);
-    #elif defined(SHIFT_CLK)
-      SET_OUTPUT(SHIFT_CLK);
-      OUT_WRITE(SHIFT_LD, HIGH);
-      OUT_WRITE(SHIFT_EN, LOW);
-      SET_INPUT_PULLUP(SHIFT_OUT);
-    #endif // SR_LCD_2W_NL
+        // Set movement on a single axis
+        set_destination_from_current();
+        destination[manual_move_axis] += manual_move_offset;
 
-  #endif // !NEWPANEL
+        // Reset for the next move
+        manual_move_offset = 0;
+        manual_move_axis = (int8_t)NO_AXIS;
 
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
-    SET_INPUT_PULLUP(SD_DETECT_PIN);
-    lcd_sd_status = 2; // UNKNOWN
-  #endif
+        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
+        // move_to_destination. This will cause idle() to be called, which can then call this function while the
+        // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
+        // processing_manual_move is true or the planner will get out of sync.
+        processing_manual_move = true;
+        prepare_move_to_destination(); // will call set_current_from_destination()
+        processing_manual_move = false;
 
-  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-    slow_buttons = 0;
-  #endif
+        feedrate_mm_s = old_feedrate;
+        #if EXTRUDERS > 1
+          active_extruder = old_extruder;
+        #endif
 
-  lcd_buttons_update();
+      #else
 
-  #if ENABLED(ULTIPANEL)
-    encoderDiff = 0;
-  #endif
-}
+        planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
+        manual_move_axis = (int8_t)NO_AXIS;
 
-bool lcd_blink() {
-  static uint8_t blink = 0;
-  static millis_t next_blink_ms = 0;
-  millis_t ms = millis();
-  if (ELAPSED(ms, next_blink_ms)) {
-    blink ^= 0xFF;
-    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
+      #endif
+    }
   }
-  return blink != 0;
-}
+
+#endif // ULTIPANEL
 
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position
  *   - Apply acceleration to the encoder position
  *   - Set lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NOW on controller events
  *   - Reset the Info Screen timeout if there's any input
@@ -5429,24 +629,38 @@ bool lcd_blink() {
  *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
  *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
  *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
  *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
  *             so don't change lcdDrawUpdate without considering this.
  *
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
- * No worries. This function is only called from the main thread.
+ * This function is only called from the main thread.
  */
+
+LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+
+#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+  bool lcd_external_control; // = false
+#endif
+
+#if ENABLED(LCD_HAS_SLOW_BUTTONS)
+  volatile uint8_t slow_buttons;
+#endif
+
 void lcd_update() {
 
+  static uint16_t max_display_update_time = 0;
+  static millis_t next_lcd_update_ms;
+
   #if ENABLED(ULTIPANEL)
     static millis_t return_to_status_ms = 0;
 
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for LCD_CLICKED, etc.
     // After state changes the next button update
     // may be delayed 300-500ms.
     lcd_buttons_update();
@@ -5504,21 +718,21 @@ void lcd_update() {
         #if ENABLED(LCD_PROGRESS_BAR)
           currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
         #endif
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
-      lcd_goto_screen(lcd_job_recovery_menu);
+      lcd_goto_screen(menu_job_recovery);
       job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
     }
   #endif
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if ENABLED(DOGLCD)
       || drawing_screen
     #endif
   ) {
@@ -5577,63 +791,64 @@ void lcd_update() {
               lastEncoderMovementMillis = ms;
             } // encoderRateMultiplierEnabled
           #endif // ENCODER_RATE_MULTIPLIER
 
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
+
     #endif // ULTIPANEL
 
-    // We arrive here every ~100ms when idling often enough.
-    // Instead of tracking the changes simply redraw the Info Screen ~1 time a second.
+    // This runs every ~100ms when idling often enough.
+    // Instead of tracking changes just redraw the Status Screen once per second.
     if (
       #if ENABLED(ULTIPANEL)
         currentScreen == lcd_status_screen &&
       #endif
       !lcd_status_update_delay--
     ) {
       lcd_status_update_delay = 9
         #if ENABLED(DOGLCD)
           + 3
         #endif
       ;
       max_display_update_time--;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
 
     #if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
-      if (currentScreen == lcd_sdcard_menu && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
+      if (currentScreen == menu_sdcard && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if ENABLED(DOGLCD)
-      #define IS_DRAWING drawing_screen
+      const bool &is_drawing = drawing_screen;
     #else
-      #define IS_DRAWING false
+      constexpr bool is_drawing = false;
     #endif
 
-    if ((lcdDrawUpdate || IS_DRAWING) && (!bbr2 || bbr2 > max_display_update_time)) {
+    if ((lcdDrawUpdate || is_drawing) && (!bbr2 || bbr2 > max_display_update_time)) {
 
       // Change state of drawing flag between screen updates
-      if (!IS_DRAWING) switch (lcdDrawUpdate) {
+      if (!is_drawing) switch (lcdDrawUpdate) {
         case LCDVIEW_CALL_NO_REDRAW:
           lcdDrawUpdate = LCDVIEW_NONE;
           break;
         case LCDVIEW_CLEAR_CALL_REDRAW:
         case LCDVIEW_CALL_REDRAW_NEXT:
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
@@ -5696,21 +911,21 @@ void lcd_update() {
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
     // Change state of drawing flag between screen updates
-    if (!IS_DRAWING) switch (lcdDrawUpdate) {
+    if (!is_drawing) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
         lcd_implementation_clear(); break;
       case LCDVIEW_REDRAW_NOW:
         lcdDrawUpdate = LCDVIEW_NONE;
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
@@ -5810,20 +1025,58 @@ void lcd_status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
 
 void lcd_setalertstatusPGM(PGM_P const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }
 
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
+#if ENABLED(ADC_KEYPAD)
+
+  typedef struct {
+    uint16_t ADCKeyValueMin, ADCKeyValueMax;
+    uint8_t  ADCKeyNo;
+  } _stADCKeypadTable_;
+
+  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
+    // VALUE_MIN, VALUE_MAX, KEY
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F1 + 1 },     // F1
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F2 + 1 },     // F2
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F3 + 1 },     // F3
+    {  300,  500, BLEN_REPRAPWORLD_KEYPAD_LEFT + 1 },   // LEFT
+    { 1900, 2200, BLEN_REPRAPWORLD_KEYPAD_RIGHT + 1 },  // RIGHT
+    {  570,  870, BLEN_REPRAPWORLD_KEYPAD_UP + 1 },     // UP
+    { 2670, 2870, BLEN_REPRAPWORLD_KEYPAD_DOWN + 1 },   // DOWN
+    { 1150, 1450, BLEN_REPRAPWORLD_KEYPAD_MIDDLE + 1 }, // ENTER
+  };
+
+  uint8_t get_ADC_keyValue(void) {
+    if (thermalManager.ADCKey_count >= 16) {
+      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
+      #if ENABLED(ADC_KEYPAD_DEBUG)
+        SERIAL_PROTOCOLLN(currentkpADCValue);
+      #endif
+      thermalManager.current_ADCKey_raw = 0;
+      thermalManager.ADCKey_count = 0;
+      if (currentkpADCValue < 4000)
+        for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
+          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
+                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
+          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
+        }
+    }
+    return 0;
+  }
+#endif
+
 #if ENABLED(ULTIPANEL)
 
   /**
    * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
    * These values are independent of which pins are used for EN_A and EN_B indications
    * The rotary encoder part is also independent to the chipset used for the LCD
    */
   #if defined(EN_A) && defined(EN_B)
     #define encrot0 0
     #define encrot1 2
@@ -5836,20 +1089,39 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     WRITE(SHIFT_LD, LOW); \
     WRITE(SHIFT_LD, HIGH); \
     for (int8_t i = 0; i < 8; i++) { \
       new_##DST >>= 1; \
       if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
       WRITE(SHIFT_CLK, HIGH); \
       WRITE(SHIFT_CLK, LOW); \
     } \
     DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
 
+  #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
+    bool lcd_detected() { return lcd.LcdDetected() == 1; }
+  #else
+    bool lcd_detected() { return true; }
+  #endif
+
+  #if ENABLED(G26_MESH_VALIDATION)
+    void lcd_chirp() {
+      lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+    }
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+    bool is_lcd_clicked() { return LCD_CLICKED; }
+    void wait_for_release() {
+      while (is_lcd_clicked()) safe_delay(50);
+      safe_delay(50);
+    }
+  #endif
 
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void lcd_buttons_update() {
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
@@ -5975,71 +1247,13 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (lcd_external_control) {
           ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
           encoderDiff = 0;                  // Hide the encoder event from the current screen handler.
         }
       #endif
       lastEncoderBits = enc;
     }
   }
 
-  #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
-    bool lcd_detected() { return lcd.LcdDetected() == 1; }
-  #else
-    bool lcd_detected() { return true; }
-  #endif
-
-  #if ENABLED(G26_MESH_VALIDATION)
-    void lcd_chirp() {
-      lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-    }
-  #endif
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-    bool is_lcd_clicked() { return LCD_CLICKED; }
-    void wait_for_release() {
-      while (is_lcd_clicked()) safe_delay(50);
-      safe_delay(50);
-    }
-  #endif
-
 #endif // ULTIPANEL
 
-#if ENABLED(ADC_KEYPAD)
-
-  typedef struct {
-    uint16_t ADCKeyValueMin, ADCKeyValueMax;
-    uint8_t  ADCKeyNo;
-  } _stADCKeypadTable_;
-
-  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
-    // VALUE_MIN, VALUE_MAX, KEY
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F1 + 1 },     // F1
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F2 + 1 },     // F2
-    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F3 + 1 },     // F3
-    {  300,  500, BLEN_REPRAPWORLD_KEYPAD_LEFT + 1 },   // LEFT
-    { 1900, 2200, BLEN_REPRAPWORLD_KEYPAD_RIGHT + 1 },  // RIGHT
-    {  570,  870, BLEN_REPRAPWORLD_KEYPAD_UP + 1 },     // UP
-    { 2670, 2870, BLEN_REPRAPWORLD_KEYPAD_DOWN + 1 },   // DOWN
-    { 1150, 1450, BLEN_REPRAPWORLD_KEYPAD_MIDDLE + 1 }, // ENTER
-  };
-
-  uint8_t get_ADC_keyValue(void) {
-    if (thermalManager.ADCKey_count >= 16) {
-      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
-      #if ENABLED(ADC_KEYPAD_DEBUG)
-        SERIAL_PROTOCOLLN(currentkpADCValue);
-      #endif
-      thermalManager.current_ADCKey_raw = 0;
-      thermalManager.ADCKey_count = 0;
-      if (currentkpADCValue < 4000)
-        for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
-          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
-                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
-          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
-        }
-    }
-    return 0;
-  }
-#endif
-
 #endif // ULTRA_LCD

commit 3c9daf322a3cda6e618d2f3e0c56a9cc6d68a835
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 13:22:15 2018 -0500

    MSG_CNG_SDCARD => MSG_CHANGE_SDCARD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f23bafd50d..a55e179465 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1190,21 +1190,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         if (card.isFileOpen()) {
           if (card.sdprinting)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
         }
         else {
           MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
           #if !PIN_EXISTS(SD_DETECT)
-            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+            MENU_ITEM(gcode, MSG_CHANGE_SDCARD, PSTR("M21"));  // SD-card changed by user
           #endif
         }
       }
       else {
         MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
     #endif // SDSUPPORT

commit bf9dd4f4cf67cdb925a9fbf455ddf49826f56fd1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 25 15:17:53 2018 -0500

    Add helpers for custom text in menu items (#12214)
    
    For some features it can be useful to write custom text in a menu item. This commit provides helpers to make this easier.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 317498abf7..f23bafd50d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -114,20 +114,27 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
   constexpr bool first_page = true;
 #endif
 
 // The main status screen
 void lcd_status_screen();
 
 LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 uint16_t max_display_update_time = 0;
 millis_t next_lcd_update_ms;
 
+#if HAS_LCD_CONTRAST
+  void set_lcd_contrast(const int16_t value) {
+    lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
+    u8g.setContrast(lcd_contrast);
+  }
+#endif
+
 #if ENABLED(ULTIPANEL)
 
   #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
     inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
@@ -332,20 +339,26 @@ millis_t next_lcd_update_ms;
   #define MENU_ITEM_P(TYPE, PLABEL, ...) do { \
       _skipStatic = false; \
       _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
       _MENU_ITEM_PART_2(TYPE, PLABEL, ## __VA_ARGS__); \
     }while(0)
 
   #define MENU_ITEM(TYPE, LABEL, ...) MENU_ITEM_P(TYPE, PSTR(LABEL), ## __VA_ARGS__)
 
   #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
 
+  #define MENU_ITEM_ADDON_START(X) \
+    if (lcdDrawUpdate && _menuLineNr == _thisItemNr - 1) { \
+      SETCURSOR(X, _lcdLineNr)
+
+  #define MENU_ITEM_ADDON_END() } (0)
+
   // Used to print static text with no visible cursor.
   // Parameters: label [, bool center [, bool invert [, char *value] ] ]
   #define STATIC_ITEM_P(LABEL, ...) do{ \
     if (_menuLineNr == _thisItemNr) { \
       if (_skipStatic && encoderLine <= _thisItemNr) { \
         encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
         ++encoderLine; \
       } \
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_static(_lcdLineNr, LABEL, ## __VA_ARGS__); \
@@ -3257,47 +3270,47 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Motion" > "Move Axis" submenu
    *
    */
-
-  #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-    #define _MOVE_XYZ_ALLOWED (all_axes_homed())
-  #else
-    #define _MOVE_XYZ_ALLOWED true
-  #endif
-
   #if ENABLED(DELTA)
-    #define _MOVE_XY_ALLOWED (current_position[Z_AXIS] <= delta_clip_start_height)
     void lcd_lower_z_to_clip_height() {
       line_to_z(delta_clip_start_height);
       lcd_synchronize();
     }
-  #else
-    #define _MOVE_XY_ALLOWED true
   #endif
 
   void lcd_move_menu() {
     START_MENU();
     MENU_BACK(MSG_MOTION);
 
     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
       MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
     #endif
 
-    if (_MOVE_XYZ_ALLOWED) {
-      if (_MOVE_XY_ALLOWED) {
+    #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
+      const bool do_move_xyz = all_axes_homed();
+    #else
+      constexpr bool do_move_xyz = true;
+    #endif
+    if (do_move_xyz) {
+      #if ENABLED(DELTA)
+        const bool do_move_xy = current_position[Z_AXIS] <= delta_clip_start_height;
+      #else
+        constexpr bool do_move_xy = true;
+      #endif
+      if (do_move_xy) {
         MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
         MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
       }
       #if ENABLED(DELTA)
         else
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 
       MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
     }
@@ -5797,29 +5810,20 @@ void lcd_status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
 
 void lcd_setalertstatusPGM(PGM_P const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }
 
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
-#if HAS_LCD_CONTRAST
-
-  void set_lcd_contrast(const int16_t value) {
-    lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
-    u8g.setContrast(lcd_contrast);
-  }
-
-#endif
-
 #if ENABLED(ULTIPANEL)
 
   /**
    * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
    * These values are independent of which pins are used for EN_A and EN_B indications
    * The rotary encoder part is also independent to the chipset used for the LCD
    */
   #if defined(EN_A) && defined(EN_B)
     #define encrot0 0
     #define encrot1 2

commit 55dec02ca188c670cc0dc32cd81898f2b73715c0
Author: Roman Moravčík <roman.moravcik@gmail.com>
Date:   Thu Oct 25 16:13:52 2018 +0200

    Allow X, Y, Z manual move when cold. (#12209)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4f710f9ea6..317498abf7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3219,21 +3219,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
           STATIC_ITEM(MSG_MOVE_Z, true, true); break;
         default:
           #if ENABLED(MANUAL_E_MOVES_RELATIVE)
             manual_move_e_origin = current_position[E_AXIS];
           #endif
           STATIC_ITEM(MSG_MOVE_E, true, true);
           break;
       }
     }
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
+      if (axis == E_AXIS && thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
         MENU_BACK(MSG_HOTEND_TOO_COLD);
       else
     #endif
     {
       MENU_BACK(MSG_MOVE_AXIS);
       MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
       MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
       MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
     }
     END_MENU();

commit 2f873a119f9de2a7f2e6b40dd08f8a51710ef1d1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 15:39:52 2018 -0500

    Revert some UBL strings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ea8cd8e61e..4f710f9ea6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2223,21 +2223,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
      *    Bed Temp: ---
      *    Build Custom Mesh
      */
     void _lcd_ubl_custom_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
       MENU_ITEM_EDIT(int3, MSG_UBL_HOTEND_TEMP_CUSTOM, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
       #if HAS_HEATED_BED
         MENU_ITEM_EDIT(int3, MSG_UBL_BED_TEMP_CUSTOM, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
       #endif
-      MENU_ITEM(function, MSG_UBL_BUILD_MESH_CUSTOM, _lcd_ubl_build_custom_mesh);
+      MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
       const int ind = ubl_height_amount > 0 ? 9 : 10;
       strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
@@ -2309,21 +2309,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void _lcd_ubl_validate_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_TOOLS);
       #if HAS_HEATED_BED
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #else
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #endif
-      MENU_ITEM(function, MSG_UBL_VALIDATE_MESH_CUSTOM, _lcd_ubl_validate_custom_mesh);
+      MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Grid Leveling Command
      */
     void _lcd_ubl_grid_level_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
@@ -2437,21 +2437,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
           "G29 P1\n"
           "M104 S0"
         ));
         MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
           "G28\n"
           "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0"
         ));
       #endif
-      MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_CUSTOM, _lcd_ubl_custom_mesh);
+      MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
       MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
       MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_menu);
       MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
       MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
       MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**

commit a93e9e6e9b96512e1dda6f9e1cfb836a4a4e0fde
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Oct 23 22:38:17 2018 +0200

    Use preheat labels in place of PLA/ABS (#12194)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6417def1e4..ea8cd8e61e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2219,25 +2219,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
      * UBL Custom Mesh submenu
      *
      * << Build Mesh
      *    Hotend Temp: ---
      *    Bed Temp: ---
      *    Build Custom Mesh
      */
     void _lcd_ubl_custom_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-      MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_HOTEND_TEMP, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
+      MENU_ITEM_EDIT(int3, MSG_UBL_HOTEND_TEMP_CUSTOM, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
       #if HAS_HEATED_BED
-        MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_BED_TEMP, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
+        MENU_ITEM_EDIT(int3, MSG_UBL_BED_TEMP_CUSTOM, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
       #endif
-      MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
+      MENU_ITEM(function, MSG_UBL_BUILD_MESH_CUSTOM, _lcd_ubl_build_custom_mesh);
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
       const int ind = ubl_height_amount > 0 ? 9 : 10;
       strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
@@ -2294,36 +2294,36 @@ void lcd_quick_feedback(const bool clear_buttons) {
       ;
       sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
       lcd_enqueue_commands_P(PSTR("G28"));
       lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Validate Mesh submenu
      *
      * << UBL Tools
-     *    PLA Mesh Validation
-     *    ABS Mesh Validation
+     *    Mesh Validation with Material 1
+     *    Mesh Validation with Material 2
      *    Validate Custom Mesh
      * << Info Screen
      */
     void _lcd_ubl_validate_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_TOOLS);
       #if HAS_HEATED_BED
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #else
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-        MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #endif
-      MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
+      MENU_ITEM(function, MSG_UBL_VALIDATE_MESH_CUSTOM, _lcd_ubl_validate_custom_mesh);
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Grid Leveling Command
      */
     void _lcd_ubl_grid_level_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
@@ -2393,65 +2393,65 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     void _lcd_ubl_invalidate() {
       ubl.invalidate();
       SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
     }
 
     /**
      * UBL Build Mesh submenu
      *
      * << UBL Tools
-     *    Build PLA Mesh
-     *    Build ABS Mesh
+     *    Build Mesh with Material 1
+     *    Build Mesh with Material 2
      *  - Build Custom Mesh >>
      *    Build Cold Mesh
      *  - Fill-in Mesh >>
      *    Continue Bed Mesh
      *    Invalidate All
      *    Invalidate Closest
      * << Info Screen
      */
     void _lcd_ubl_build_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_TOOLS);
       #if HAS_HEATED_BED
-        MENU_ITEM(gcode, MSG_UBL_BUILD_PLA_MESH, PSTR(
+        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
           "G28\n"
           "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
           "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0\n"
           "M140 S0"
         ));
-        MENU_ITEM(gcode, MSG_UBL_BUILD_ABS_MESH, PSTR(
+        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
           "G28\n"
           "M190 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\n"
           "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0\n"
           "M140 S0"
         ));
       #else
-        MENU_ITEM(gcode, MSG_UBL_BUILD_PLA_MESH, PSTR(
+        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
           "G28\n"
           "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0"
         ));
-        MENU_ITEM(gcode, MSG_UBL_BUILD_ABS_MESH, PSTR(
+        MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
           "G28\n"
           "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0"
         ));
       #endif
-      MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
+      MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_CUSTOM, _lcd_ubl_custom_mesh);
       MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
       MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_menu);
       MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
       MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
       MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**

commit a553ab82e0c21455abb3e0515222f55defe8c6ff
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 22 23:34:49 2018 -0500

    Add e index to _lcd_move_distance_menu

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7a86b4a9f7..6417def1e4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3199,67 +3199,67 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   void _goto_manual_move(const float scale) {
     defer_return_to_status = true;
     move_menu_scale = scale;
     lcd_goto_screen(_manual_move_func_ptr);
   }
   void lcd_move_menu_10mm() { _goto_manual_move(10); }
   void lcd_move_menu_1mm()  { _goto_manual_move( 1); }
   void lcd_move_menu_01mm() { _goto_manual_move( 0.1f); }
 
-  void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func) {
+  void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func, const int8_t eindex=-1) {
     _manual_move_func_ptr = func;
     START_MENU();
     if (LCD_HEIGHT >= 4) {
       switch (axis) {
         case X_AXIS:
           STATIC_ITEM(MSG_MOVE_X, true, true); break;
         case Y_AXIS:
           STATIC_ITEM(MSG_MOVE_Y, true, true); break;
         case Z_AXIS:
           STATIC_ITEM(MSG_MOVE_Z, true, true); break;
         default:
           #if ENABLED(MANUAL_E_MOVES_RELATIVE)
             manual_move_e_origin = current_position[E_AXIS];
           #endif
           STATIC_ITEM(MSG_MOVE_E, true, true);
           break;
       }
     }
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.tooColdToExtrude(active_extruder))
+      if (thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
         MENU_BACK(MSG_HOTEND_TOO_COLD);
       else
     #endif
     {
       MENU_BACK(MSG_MOVE_AXIS);
       MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
       MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
       MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
     }
     END_MENU();
   }
   void lcd_move_get_x_amount()        { _lcd_move_distance_menu(X_AXIS, lcd_move_x); }
   void lcd_move_get_y_amount()        { _lcd_move_distance_menu(Y_AXIS, lcd_move_y); }
   void lcd_move_get_z_amount()        { _lcd_move_distance_menu(Z_AXIS, lcd_move_z); }
-  void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e); }
+  void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e, -1); }
   #if E_MANUAL > 1
-    void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0); }
-    void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1); }
+    void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0, 0); }
+    void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1, 1); }
     #if E_MANUAL > 2
-      void lcd_move_get_e2_amount()   { _lcd_move_distance_menu(E_AXIS, lcd_move_e2); }
+      void lcd_move_get_e2_amount()   { _lcd_move_distance_menu(E_AXIS, lcd_move_e2, 2); }
       #if E_MANUAL > 3
-        void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3); }
+        void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3, 3); }
         #if E_MANUAL > 4
-          void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4); }
+          void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4, 4); }
           #if E_MANUAL > 5
-            void lcd_move_get_e5_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e5); }
+            void lcd_move_get_e5_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e5, 5); }
           #endif // E_MANUAL > 5
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Motion" > "Move Axis" submenu
    *

commit 3a46212dd84697d9b84ce59462f351785aedd3b3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 22 20:54:38 2018 -0500

    Better cold extrusion prevention in LCD menu (#12189)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 07fa3d1fee..7a86b4a9f7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -334,30 +334,30 @@ millis_t next_lcd_update_ms;
       _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
       _MENU_ITEM_PART_2(TYPE, PLABEL, ## __VA_ARGS__); \
     }while(0)
 
   #define MENU_ITEM(TYPE, LABEL, ...) MENU_ITEM_P(TYPE, PSTR(LABEL), ## __VA_ARGS__)
 
   #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
 
   // Used to print static text with no visible cursor.
   // Parameters: label [, bool center [, bool invert [, char *value] ] ]
-  #define STATIC_ITEM_P(LABEL, ...) \
+  #define STATIC_ITEM_P(LABEL, ...) do{ \
     if (_menuLineNr == _thisItemNr) { \
       if (_skipStatic && encoderLine <= _thisItemNr) { \
         encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
         ++encoderLine; \
       } \
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_static(_lcdLineNr, LABEL, ## __VA_ARGS__); \
     } \
-    ++_thisItemNr
+    ++_thisItemNr; } while(0)
 
   #define STATIC_ITEM(LABEL, ...) STATIC_ITEM_P(PSTR(LABEL), ## __VA_ARGS__)
 
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
     bool encoderRateMultiplierEnabled;
     #define ENCODER_RATE_MULTIPLY(F) (encoderRateMultiplierEnabled = F)
 
     //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
 
@@ -3218,24 +3218,31 @@ void lcd_quick_feedback(const bool clear_buttons) {
         case Z_AXIS:
           STATIC_ITEM(MSG_MOVE_Z, true, true); break;
         default:
           #if ENABLED(MANUAL_E_MOVES_RELATIVE)
             manual_move_e_origin = current_position[E_AXIS];
           #endif
           STATIC_ITEM(MSG_MOVE_E, true, true);
           break;
       }
     }
-    MENU_BACK(MSG_MOVE_AXIS);
-    MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
-    MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
-    MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      if (thermalManager.tooColdToExtrude(active_extruder))
+        MENU_BACK(MSG_HOTEND_TOO_COLD);
+      else
+    #endif
+    {
+      MENU_BACK(MSG_MOVE_AXIS);
+      MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
+      MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
+      MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
+    }
     END_MENU();
   }
   void lcd_move_get_x_amount()        { _lcd_move_distance_menu(X_AXIS, lcd_move_x); }
   void lcd_move_get_y_amount()        { _lcd_move_distance_menu(Y_AXIS, lcd_move_y); }
   void lcd_move_get_z_amount()        { _lcd_move_distance_menu(Z_AXIS, lcd_move_z); }
   void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e); }
   #if E_MANUAL > 1
     void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0); }
     void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1); }
     #if E_MANUAL > 2

commit 427c80119a0e19fe1687078a982c67b3afa70299
Author: Farkas Péter <fape88@gmail.com>
Date:   Sat Oct 20 22:55:31 2018 +0200

    Hide some menu items when busy: fix typo (#12164)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8da41adbb4..07fa3d1fee 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4025,21 +4025,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       // M203 / M205 - Feedrate items
       MENU_ITEM(submenu, MSG_VELOCITY, lcd_advanced_velocity_menu);
 
       // M201 - Acceleration items
       MENU_ITEM(submenu, MSG_ACCELERATION, lcd_advanced_acceleration_menu);
 
       // M205 - Max Jerk
       MENU_ITEM(submenu, MSG_JERK, lcd_advanced_jerk_menu);
 
-      if (!printer_busy) {
+      if (!printer_busy()) {
         // M92 - Steps Per mm
         MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
       }
 
     #endif // !SLIM_LCD_MENUS
 
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);

commit 1fb9b299d4d96276ff1fb6cd2ee5e73e753e2b23
Author: TheSFReader <TheSFReader@gmail.com>
Date:   Fri Oct 19 21:25:07 2018 +0200

    Add M524 to abort SD printing (#12155)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 85a2180bb1..8da41adbb4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -888,25 +888,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void lcd_sdcard_resume() {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
     }
 
-    bool abort_sd_printing; // =false
-
     void lcd_sdcard_stop() {
       wait_for_heatup = wait_for_user = false;
-      abort_sd_printing = true;
+      card.abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(POWER_LOSS_RECOVERY)
 
     static void lcd_power_loss_recovery_resume() {
       char cmd[20];

commit c6a5c7420895bbb32ac3c70f0382ed5622c3746e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:52:44 2018 -0500

    Add parentheses to SD macros

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7d9b587975..85a2180bb1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -502,21 +502,21 @@ millis_t next_lcd_update_ms;
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
   #endif
 
   inline bool use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
-  inline bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING; }
+  inline bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
 
   void lcd_move_z();
   float move_menu_scale;
 
   /**
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
@@ -682,21 +682,21 @@ millis_t next_lcd_update_ms;
 
 void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
   #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
     // Progress bar % comes from SD when actively printing
-    if (IS_SD_PRINTING)
+    if (IS_SD_PRINTING())
       progress_bar_percent = card.percentDone();
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
@@ -5455,21 +5455,21 @@ void lcd_update() {
       if (LCD_BACK_CLICKED) {
         lcd_quick_feedback(true);
         lcd_goto_previous_menu();
       }
     #endif
 
   #endif // ULTIPANEL
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
-    const uint8_t sd_status = (uint8_t)IS_SD_INSERTED;
+    const uint8_t sd_status = (uint8_t)IS_SD_INSERTED();
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
         if (old_sd_status == 2)
           card.beginautostart();  // Initial boot

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9fa8c11c94..7d9b587975 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1911,23 +1911,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
       #endif
       END_MENU();
     }
 
   #endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
 
   void lcd_cooldown() {
-    #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) fan_speed[i] = 0;
-    #endif
+    zero_fan_speeds();
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
 
     /**
      * If the queue is full, the command will fail, so we have to loop
      * with idle() to make sure the command has been enqueued.
      */

commit 67a3c5a16ad0c202352ef19b5993ac0c7f52862d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 18 11:34:52 2018 -0500

    Alternative info screen (Prusa-style) (#12132)
    
    * Fix Z value display
    * Add HAS_PRINT_PROGRESS
    * Alternative Info Screen option
    * Add LCD_INFO_SCREEN_STYLE to example configs

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e94a9264a0..9fa8c11c94 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -771,21 +771,25 @@ void lcd_status_screen() {
       else {
         feedrate_percentage = new_frm;
         encoderPosition = 0;
       }
     #endif // ULTIPANEL_FEEDMULTIPLY
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
   #endif // ULTIPANEL
 
-  lcd_implementation_status_screen();
+  #if LCD_INFO_SCREEN_STYLE == 0
+    lcd_impl_status_screen_0();
+  #elif LCD_INFO_SCREEN_STYLE == 1
+    lcd_impl_status_screen_1();
+  #endif
 }
 
 /**
  * Reset the status message
  */
 void lcd_reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   PGM_P msg;

commit 3ec38727305862c881f268e2fc27f8188b5bc767
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 17 12:11:41 2018 -0400

    Single Z raise value for all tool-changing / parking (#12090)
    
    * Universal tool-change Z lift
    * Add TOOLCHANGE_ZRAISE to example configs
    * Park/unpark changes to example configs
    * Implement DEBUG_DXC_MODE

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 84747743ce..e94a9264a0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -969,27 +969,30 @@ void lcd_quick_feedback(const bool clear_buttons) {
       defer_return_to_status = true;
       START_MENU();
       STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
       MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
       MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
       END_MENU();
     }
 
   #endif // POWER_LOSS_RECOVERY
 
-  #if ENABLED(SINGLENOZZLE)
-    void singlenozzle_swap_menu() {
+  #if EXTRUDERS > 1
+    void tool_change_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &sn_settings.swap_length, 0, 200);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &sn_settings.retract_speed, 10, 5400);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &sn_settings.prime_speed, 10, 5400);
+      #if ENABLED(SINGLENOZZLE)
+        MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &toolchange_settings.swap_length, 0, 200);
+        MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &toolchange_settings.retract_speed, 10, 5400);
+        MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &toolchange_settings.prime_speed, 10, 5400);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_TOOL_CHANGE_ZLIFT, &toolchange_settings.z_raise, 0, 10);
       END_MENU();
     }
   #endif
 
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
@@ -3430,22 +3433,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       #if ENABLED(BLTOUCH)
         MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
       #endif
     }
 
     //
     // Set single nozzle filament retract and prime length
     //
-    #if ENABLED(SINGLENOZZLE)
-      MENU_ITEM(submenu, MSG_SINGLENOZZLE_TOOL_CHANGE, singlenozzle_swap_menu);
+    #if EXTRUDERS > 1
+      MENU_ITEM(submenu, MSG_TOOL_CHANGE, tool_change_menu);
     #endif
 
     //
     // Set Case light on/off/brightness
     //
     #if ENABLED(MENU_ITEM_CASE_LIGHT)
       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
         MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
       else
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);

commit 8bf596bd4cb6879eb50994d497b30acf84082395
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 16 16:46:24 2018 -0500

    RETRACT_ZLIFT => RETRACT_ZRAISE

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 449d3cd5f1..84747743ce 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4209,21 +4209,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       #if ENABLED(FWRETRACT_AUTORETRACT)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
       #endif
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.settings.retract_length, 0, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.settings.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.settings.retract_feedrate_mm_s, 1, 999);
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.settings.retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZHOP, &fwretract.settings.retract_zraise, 0, 999);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.settings.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.settings.swap_retract_recover_length, -100, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.settings.retract_recover_feedrate_mm_s, 1, 999);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.settings.swap_retract_recover_feedrate_mm_s, 1, 999);
       #endif
       END_MENU();
     }

commit 50cbca4c55243f34c84ced3f264fdc76f9fcdc93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 9 23:00:20 2018 -0500

    Hide some menu items when busy

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7c4578a1fb..449d3cd5f1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1508,27 +1508,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
 
     //
     // Manual bed leveling, Bed Z:
     //
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
 
-    //
-    // Leveling Fade Height
-    //
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(SLIM_LCD_MENUS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-    #endif
-
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #if HOTENDS > 2
@@ -4029,22 +4022,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       // M203 / M205 - Feedrate items
       MENU_ITEM(submenu, MSG_VELOCITY, lcd_advanced_velocity_menu);
 
       // M201 - Acceleration items
       MENU_ITEM(submenu, MSG_ACCELERATION, lcd_advanced_acceleration_menu);
 
       // M205 - Max Jerk
       MENU_ITEM(submenu, MSG_JERK, lcd_advanced_jerk_menu);
 
-      // M92 - Steps Per mm
-      MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
+      if (!printer_busy) {
+        // M92 - Steps Per mm
+        MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
+      }
 
     #endif // !SLIM_LCD_MENUS
 
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
       #if EXTRUDERS == 1
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 07943c6e2d..7c4578a1fb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -973,23 +973,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
       END_MENU();
     }
 
   #endif // POWER_LOSS_RECOVERY
 
   #if ENABLED(SINGLENOZZLE)
     void singlenozzle_swap_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &singlenozzle_swap_length, 0, 200);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &singlenozzle_retract_speed, 10, 5400);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &singlenozzle_prime_speed, 10, 5400);
+      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &sn_settings.swap_length, 0, 200);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &sn_settings.retract_speed, 10, 5400);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &sn_settings.prime_speed, 10, 5400);
       END_MENU();
     }
   #endif
 
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
@@ -3811,21 +3811,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     void _planner_refresh_positioning() { planner.refresh_positioning(); }
     #if ENABLED(DISTINCT_E_FACTORS)
       void _planner_refresh_e_positioning(const uint8_t e) {
         if (e == active_extruder)
           _planner_refresh_positioning();
         else
-          planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.axis_steps_per_mm[E_AXIS + e];
+          planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.settings.axis_steps_per_mm[E_AXIS + e];
       }
       void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
       void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
       #if E_STEPPERS > 2
         void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
         #if E_STEPPERS > 3
           void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
           #if E_STEPPERS > 4
             void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
             #if E_STEPPERS > 5
@@ -3835,90 +3835,90 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     // M203 / M205 Velocity options
     void lcd_advanced_velocity_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       // M203 Max Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.max_feedrate_mm_s[A_AXIS], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.max_feedrate_mm_s[B_AXIS], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.max_feedrate_mm_s[C_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.settings.max_feedrate_mm_s[A_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.settings.max_feedrate_mm_s[B_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.settings.max_feedrate_mm_s[C_AXIS], 1, 999);
 
       #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.settings.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
         #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.settings.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
           #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.settings.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
             #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.settings.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
               #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.settings.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
               #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
       #endif
 
       // M205 S Min Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.settings.min_feedrate_mm_s, 0, 999);
 
       // M205 T Min Travel Feedrate
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.settings.min_travel_feedrate_mm_s, 0, 999);
 
       END_MENU();
     }
 
     // M201 / M204 Accelerations
     void lcd_advanced_acceleration_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       // M204 P Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.settings.acceleration, 10, 99000);
 
       // M204 R Retract Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.settings.retract_acceleration, 100, 99000);
 
       // M204 T Travel Acceleration
-      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.settings.travel_acceleration, 100, 99000);
 
       // M201 settings
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.settings.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.settings.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.settings.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
 
       #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
         #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
           #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
             #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
               #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
               #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
       #endif
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_advanced_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
@@ -3943,42 +3943,42 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_advanced_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.settings.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.settings.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.settings.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
 
       #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
         #if E_STEPPERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
           #if E_STEPPERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
             #if E_STEPPERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
               #if E_STEPPERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
               #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
       #endif
 
       END_MENU();
     }
 
   #endif // !SLIM_LCD_MENUS
 
   /**
    *
    * "Advanced Settings" submenu
@@ -4152,53 +4152,53 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         const float extrude_maxlength =
           #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
             EXTRUDE_MAXLENGTH
           #else
             999
           #endif
         ;
 
         #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[0].unload_length, 0, extrude_maxlength);
         #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[active_extruder].unload_length, 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &fc_settings[0].unload_length, 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &fc_settings[1].unload_length, 0, extrude_maxlength);
           #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &fc_settings[2].unload_length, 0, extrude_maxlength);
             #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0, extrude_maxlength);
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &fc_settings[3].unload_length, 0, extrude_maxlength);
               #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0, extrude_maxlength);
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &fc_settings[4].unload_length, 0, extrude_maxlength);
                 #if EXTRUDERS > 5
-                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &filament_change_unload_length[5], 0, extrude_maxlength);
+                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &fc_settings[5].unload_length, 0, extrude_maxlength);
                 #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
 
         #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[0].load_length, 0, extrude_maxlength);
         #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[active_extruder].load_length, 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &fc_settings[0].load_length, 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &fc_settings[1].load_length, 0, extrude_maxlength);
           #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &fc_settings[2].load_length, 0, extrude_maxlength);
             #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0, extrude_maxlength);
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &fc_settings[3].load_length, 0, extrude_maxlength);
               #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0, extrude_maxlength);
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &fc_settings[4].load_length, 0, extrude_maxlength);
                 #if EXTRUDERS > 5
-                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &filament_change_load_length[5], 0, extrude_maxlength);
+                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &fc_settings[5].load_length, 0, extrude_maxlength);
                 #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       #endif
 
       END_MENU();
     }
   #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
@@ -4209,33 +4209,33 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_config_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       #if ENABLED(FWRETRACT_AUTORETRACT)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
       #endif
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.settings.retract_length, 0, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
+        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.settings.swap_retract_length, 0, 100);
       #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.settings.retract_feedrate_mm_s, 1, 999);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.settings.retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.settings.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
+        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.settings.swap_retract_recover_length, -100, 100);
       #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.retract_recover_feedrate_mm_s, 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.settings.retract_recover_feedrate_mm_s, 1, 999);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.swap_retract_recover_feedrate_mm_s, 1, 999);
+        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.settings.swap_retract_recover_feedrate_mm_s, 1, 999);
       #endif
       END_MENU();
     }
 
   #endif // FWRETRACT
 
   #if ENABLED(SDSUPPORT)
 
     #if !PIN_EXISTS(SD_DETECT)
       void lcd_sd_refresh() {

commit cf5284cdf25f759ce1b64c87480b2cd47dfb1916
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 9 20:00:47 2018 -0500

    Add SD Firmware Update capability (#12043)
    
    Co-Authored-By: timoxd7 <timoxd7@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b8bbe1a176..07943c6e2d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3989,20 +3989,32 @@ void lcd_quick_feedback(const bool clear_buttons) {
     /**
      * Set the home offset based on the current_position
      */
     void lcd_set_home_offsets() {
       // M428 Command
       enqueue_and_echo_commands_P(PSTR("M428"));
       lcd_return_to_status();
     }
   #endif
 
+  #if ENABLED(SD_FIRMWARE_UPDATE)
+    /**
+     * Toggle the SD Firmware Update state in EEPROM
+     */
+    static void _lcd_toggle_sd_update() {
+      const bool new_state = !settings.sd_update_status();
+      lcd_completion_feedback(settings.set_sd_update_status(new_state));
+      lcd_return_to_status();
+      if (new_state) LCD_MESSAGEPGM(MSG_RESET_PRINTER); else lcd_reset_status();
+    }
+  #endif
+
   void lcd_advanced_settings_menu() {
     START_MENU();
     MENU_BACK(MSG_CONFIGURATION);
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
     #elif HAS_BED_PROBE
       MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
 
@@ -4061,20 +4073,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     //
     // BLTouch Self-Test and Reset
     //
     #if ENABLED(BLTOUCH)
       MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
       if (!endstops.z_probe_enabled && TEST_BLTOUCH())
         MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
     #endif
 
+    #if ENABLED(SD_FIRMWARE_UPDATE)
+      bool sd_update_state = settings.sd_update_status();
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_SD_UPDATE, &sd_update_state, _lcd_toggle_sd_update);
+    #endif
+
     #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
       MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
     #endif
 
     END_MENU();
   }
 
   #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
     /**
      *

commit d6d48e63fbc94b2ce954e0a4a2cdebe2310eedcc
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Oct 8 19:01:00 2018 -0600

    Allow #defined TYPE arg to ultralcd menu macros (#12041)
    
    Previously, it was not possible for the TYPE argument to ultralcd menu macros to itself be a #defined value. This made it difficult to create variables to set many related menu items to a common precision that could be easily changed.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9167bbe248..b8bbe1a176 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -369,28 +369,28 @@ millis_t next_lcd_update_ms;
         encoderRateMultiplierEnabled = true; \
         lastEncoderMovementMillis = 0; \
         _MENU_ITEM_PART_2(TYPE, PSTR(LABEL), ## __VA_ARGS__); \
       }while(0)
 
   #else // !ENCODER_RATE_MULTIPLIER
     #define ENCODER_RATE_MULTIPLY(F) NOOP
   #endif // !ENCODER_RATE_MULTIPLIER
 
   #define MENU_ITEM_DUMMY() do { _thisItemNr++; }while(0)
-  #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
-  #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #else // !ENCODER_RATE_MULTIPLIER
-    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(_CAT(setting_edit_callback_,TYPE), LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #endif // !ENCODER_RATE_MULTIPLIER
 
   #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
     for (int8_t _lcdLineNr = 0; _lcdLineNr < menu_bottom; _lcdLineNr++, _menuLineNr++) { \
       _thisItemNr = 0
 
   /**
    * START_SCREEN  Opening code for a screen having only static items.
    *               Do simplified scrolling of the entire screen.
@@ -979,21 +979,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #if ENABLED(SINGLENOZZLE)
     void singlenozzle_swap_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &singlenozzle_swap_length, 0, 200);
       MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &singlenozzle_retract_speed, 10, 5400);
       MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &singlenozzle_prime_speed, 10, 5400);
       END_MENU();
     }
   #endif
-  
+
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
       END_MENU();

commit 74cd6cb4fc90e4c483e7a97a313c0257790f1375
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 7 18:06:14 2018 -0400

    Single nozzle filament change (#11994)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6d8902a12a..9167bbe248 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -131,20 +131,21 @@ millis_t next_lcd_update_ms;
     inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
       UNUSED(pstr2); UNUSED(pset); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(pget())); \
     } \
     typedef void _name##_void
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int3, itostr3);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int4, itostr4sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint8_t, int8, i8tostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float3, ftostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float51, ftostr51sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52sign, ftostr52sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float62, ftostr62rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint32_t, long5, ftostr5rj);
   #define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data)                    DRAW_BOOL_SETTING(sel, row, pstr, data)
@@ -260,20 +261,21 @@ millis_t next_lcd_update_ms;
   #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
     bool _menu_edit_ ## _name(); \
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
     void _menu_action_setting_edit_ ## _name(PGM_P const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_callback_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback=NULL, const bool live=false); \
     typedef void _name##_void
 
   DECLARE_MENU_EDIT_TYPE(int16_t, int3);
+  DECLARE_MENU_EDIT_TYPE(int16_t, int4);
   DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
   DECLARE_MENU_EDIT_TYPE(float, float3);
   DECLARE_MENU_EDIT_TYPE(float, float52);
   DECLARE_MENU_EDIT_TYPE(float, float43);
   DECLARE_MENU_EDIT_TYPE(float, float5);
   DECLARE_MENU_EDIT_TYPE(float, float51);
   DECLARE_MENU_EDIT_TYPE(float, float52sign);
   DECLARE_MENU_EDIT_TYPE(float, float62);
   DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
 
@@ -967,48 +969,53 @@ void lcd_quick_feedback(const bool clear_buttons) {
       defer_return_to_status = true;
       START_MENU();
       STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
       MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
       MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
       END_MENU();
     }
 
   #endif // POWER_LOSS_RECOVERY
 
+  #if ENABLED(SINGLENOZZLE)
+    void singlenozzle_swap_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &singlenozzle_swap_length, 0, 200);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &singlenozzle_retract_speed, 10, 5400);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &singlenozzle_prime_speed, 10, 5400);
+      END_MENU();
+    }
+  #endif
+  
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
-      //
-      // ^ Main
-      //
       MENU_BACK(MSG_MAIN);
       MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
       END_MENU();
     }
   #endif // MENU_ITEM_CASE_LIGHT
 
   #if ENABLED(BLTOUCH)
 
     /**
      *
      * "BLTouch" submenu
      *
      */
     static void bltouch_menu() {
       START_MENU();
-      //
-      // ^ Main
-      //
       MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
       MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
       MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
       MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
       END_MENU();
     }
 
   #endif // BLTOUCH
 
@@ -1035,21 +1042,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       lcd_set_custom_characters();
     }
 
   #endif // LCD_PROGRESS_BAR_TEST
 
   #if HAS_DEBUG_MENU
 
     void lcd_debug_menu() {
       START_MENU();
 
-      MENU_BACK(MSG_MAIN); // ^ Main
+      MENU_BACK(MSG_MAIN);
 
       #if ENABLED(LCD_PROGRESS_BAR_TEST)
         MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
       #endif
 
       END_MENU();
     }
 
   #endif // HAS_DEBUG_MENU
 
@@ -1487,24 +1494,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif // EXTRUDERS > 2
   #endif // EXTRUDERS > 1
 
   /**
    *
    * "Tune" submenu
    *
    */
   void lcd_tune_menu() {
     START_MENU();
-
-    //
-    // ^ Main
-    //
     MENU_BACK(MSG_MAIN);
 
     //
     // Speed:
     //
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
 
     //
     // Manual bed leveling, Bed Z:
     //
@@ -3431,20 +3434,27 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
         MENU_ITEM(submenu, MSG_IDEX_MENU, IDEX_menu);
       #endif
 
       #if ENABLED(BLTOUCH)
         MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
       #endif
     }
 
+    //
+    // Set single nozzle filament retract and prime length
+    //
+    #if ENABLED(SINGLENOZZLE)
+      MENU_ITEM(submenu, MSG_SINGLENOZZLE_TOOL_CHANGE, singlenozzle_swap_menu);
+    #endif
+
     //
     // Set Case light on/off/brightness
     //
     #if ENABLED(MENU_ITEM_CASE_LIGHT)
       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
         MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
       else
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
     #endif
 
@@ -5136,20 +5146,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       currentScreen = menu_edit_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
     FORCE_INLINE void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
       menu_action_setting_edit_callback_ ## _name(pstr, ptr, minValue, maxValue); \
     } \
     typedef void _name##_void
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
+  DEFINE_MENU_EDIT_TYPE(int16_t, int4, itostr4sign, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
   DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10);
   DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100);
   DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100);
   DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01f);
 

commit c0d9058e252b1fb9fd4ff09081eb6d71267fca05
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Oct 7 23:43:48 2018 +0200

    Shorten an Italian menu title (#12034)
    
    …and change a multi-use "back" menu item.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1b381f1a02..6d8902a12a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4571,21 +4571,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         default: break;
       }
       return PSTR(MSG_FILAMENTCHANGE);
     }
 
     void _lcd_temp_menu_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
       _change_filament_temp_mode = mode;
       _change_filament_temp_extruder = extruder;
       START_MENU();
       if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
-      MENU_BACK(MSG_FILAMENTCHANGE);
+      MENU_BACK(MSG_BACK);
       MENU_ITEM(submenu, MSG_PREHEAT_1, _lcd_change_filament_temp_1_menu);
       MENU_ITEM(submenu, MSG_PREHEAT_2, _lcd_change_filament_temp_2_menu);
       uint16_t max_temp;
       switch (extruder) {
         default: max_temp = HEATER_0_MAXTEMP;
         #if HOTENDS > 1
           case 1: max_temp = HEATER_1_MAXTEMP; break;
           #if HOTENDS > 2
             case 2: max_temp = HEATER_2_MAXTEMP; break;
             #if HOTENDS > 3

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c6409ad07c..1b381f1a02 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -152,21 +152,22 @@ millis_t next_lcd_update_ms;
   #define lcd_implementation_drawmenu_setting_edit_accessor_bool(sel, row, pstr, pstr2, pget, pset)     DRAW_BOOL_SETTING(sel, row, pstr, data)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   bool no_reentry = false;
   constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
 
   // Initialized by settings.load()
-  int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+  int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
+  uint8_t lcd_preheat_fan_speed[2];
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
     bool lcd_external_control; // = false
   #endif
 
   #if ENABLED(BABYSTEPPING)
     long babysteps_done = 0;
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       static void lcd_babystep_zoffset();
     #else
@@ -938,21 +939,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         }
       }
 
       #if HOTENDS > 1
         sprintf_P(cmd, PSTR("T%i"), job_recovery_info.active_hotend);
         enqueue_and_echo_command(cmd);
       #endif
 
       // Restore print cooling fan speeds
       for (uint8_t i = 0; i < FAN_COUNT; i++) {
-        int16_t f = job_recovery_info.fanSpeeds[i];
+        uint8_t f = job_recovery_info.fan_speed[i];
         if (f) {
           sprintf_P(cmd, PSTR("M106 P%i S%i"), i, f);
           enqueue_and_echo_command(cmd);
         }
       }
 
       // Start draining the job recovery command queue
       job_recovery_phase = JOB_RECOVERY_YES;
     }
 
@@ -1546,35 +1547,35 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fanSpeeds[0], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
         #endif
       #endif
       #if HAS_FAN1
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 2", &new_fanSpeeds[1], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
         #endif
       #endif
       #if HAS_FAN2
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Flow:
     // Flow [1-5]:
     //
     #if EXTRUDERS == 1
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
@@ -1662,32 +1663,32 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #endif // HAS_MOTOR_CURRENT_PWM
 
   constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
 
   /**
    *
    * "Temperature" submenu items
    *
    */
-  void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const int16_t fan) {
+  void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const uint8_t fan) {
     if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
     #if HAS_HEATED_BED
       if (tempb >= 0) thermalManager.setTargetBed(tempb);
     #else
       UNUSED(tempb);
     #endif
     #if FAN_COUNT > 0
       #if FAN_COUNT > 1
-        fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
+        fan_speed[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
       #else
-        fanSpeeds[0] = fan;
+        fan_speed[0] = fan;
       #endif
     #else
       UNUSED(fan);
     #endif
     lcd_return_to_status();
   }
 
   #if HAS_TEMP_HOTEND
     void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
@@ -1908,21 +1909,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
       #endif
       END_MENU();
     }
 
   #endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
 
   void lcd_cooldown() {
     #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+      for (uint8_t i = 0; i < FAN_COUNT; i++) fan_speed[i] = 0;
     #endif
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
 
     /**
      * If the queue is full, the command will fail, so we have to loop
      * with idle() to make sure the command has been enqueued.
@@ -3602,35 +3603,35 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fanSpeeds[0], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
         #endif
       #endif
       #if HAS_FAN1
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 2", &new_fanSpeeds[1], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
         #endif
       #endif
       #if HAS_FAN2
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
-          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
+          MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     #if HAS_TEMP_HOTEND
 
       //
       // Cooldown
       //
       bool has_heat = false;
@@ -3748,21 +3749,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
         #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
         #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
       #else
         #define MINTEMP_ALL HEATER_0_MINTEMP
         #define MAXTEMP_ALL HEATER_0_MAXTEMP
       #endif
       START_MENU();
       MENU_BACK(MSG_CONFIGURATION);
-      MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
+      MENU_ITEM_EDIT(int8, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
       #if HAS_TEMP_HOTEND
         MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
       #endif
       #if HAS_HEATED_BED
         MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();

commit 30197134027d0b831fe370c9d0a047b8e8a333f8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 1 05:19:35 2018 -0500

    Reorganize some enums

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 97632e8cd4..c6409ad07c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -110,24 +110,23 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
   #include "ultralcd_impl_DOGM.h"
   bool drawing_screen, first_page; // = false
 #else
   #include "ultralcd_impl_HD44780.h"
   constexpr bool first_page = true;
 #endif
 
 // The main status screen
 void lcd_status_screen();
 
-millis_t next_lcd_update_ms;
-
-uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
+LCDViewAction lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 uint16_t max_display_update_time = 0;
+millis_t next_lcd_update_ms;
 
 #if ENABLED(ULTIPANEL)
 
   #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
     inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \

commit b0fd8f2d746e5eb38a1d555fd5d6f6a22806a3a8
Author: dot-bob <robfrommendon@gmail.com>
Date:   Mon Jul 2 23:23:44 2018 -0600

    Add option to move Z on double-click when idle

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3fd754cb2e..97632e8cd4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -502,47 +502,59 @@ uint16_t max_display_update_time = 0;
   #endif
 
   inline bool use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
   inline bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING; }
 
+  void lcd_move_z();
+  float move_menu_scale;
+
   /**
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // Shadow for editing the fade height
         new_z_fade_height = planner.z_fade_height;
       #endif
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
-        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)/* && printer_busy()*/)
-          screen =
-            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-              lcd_babystep_zoffset
-            #else
-              lcd_babystep_z
-            #endif
-          ;
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)) {
+          if (printer_busy()) {
+            screen =
+              #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+                lcd_babystep_zoffset
+              #else
+                lcd_babystep_z
+              #endif
+            ;
+          }
+          #if ENABLED(MOVE_Z_WHEN_IDLE)
+            else {
+              move_menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
+              screen = lcd_move_z;
+            }
+          #endif
+        }
       #endif
 
       currentScreen = screen;
       encoderPosition = encoder;
       if (screen == lcd_status_screen) {
         defer_return_to_status = false;
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.lcd_map_control = false;
         #endif
         screen_history_depth = 0;
@@ -2843,26 +2855,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif
 
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     END_MENU();
   }
 
-  float move_menu_scale;
-
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
-    void lcd_move_z();
-
     void _man_probe_pt(const float &rx, const float &ry) {
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       do_blocking_move_to_xy(rx, ry);
 
       lcd_synchronize();
       move_menu_scale = MAX(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
       lcd_goto_screen(lcd_move_z);
     }
 
   #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION

commit 8ae113ff36b4fee576326c1b25f1f63859df73ea
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 1 01:30:10 2018 -0400

    Show zprobe_zoffset when BABYSTEP_HOTEND_Z_OFFSET is disabled (#11973)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ec35b5a31e..3fd754cb2e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1324,25 +1324,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
             if (do_probe) zprobe_zoffset = new_offs;
             #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
               else hotend_offset[Z_AXIS][active_extruder] = new_offs;
             #endif
 
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-            if (do_probe)
-              lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
-            else
+            if (!do_probe)
               lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+            else
           #endif
+              lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
             if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
       void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }

commit 2e98437392ef6192528c4622c09c150797b48bb9
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 1 01:15:06 2018 -0400

    Clean up main menu (#11972)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index aadc9486e7..ec35b5a31e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -500,40 +500,42 @@ uint16_t max_display_update_time = 0;
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
   #endif
 
   inline bool use_click() {
     const bool click = lcd_clicked;
     lcd_clicked = false;
     return click;
   }
 
+  inline bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING; }
+
   /**
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // Shadow for editing the fade height
         new_z_fade_height = planner.z_fade_height;
       #endif
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
-        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)/* && (planner.movesplanned() || IS_SD_PRINTING)*/)
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)/* && printer_busy()*/)
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
               lcd_babystep_zoffset
             #else
               lcd_babystep_z
             #endif
           ;
       #endif
 
       currentScreen = screen;
@@ -1046,20 +1048,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     static void _recalc_IDEX_settings() {
       if (active_extruder) {                      // For the 2nd extruder re-home so the next tool-change gets the new offsets.
         enqueue_and_echo_commands_P(PSTR("G28")); // In future, we can babystep the 2nd extruder (if active), making homing unnecessary.
         active_extruder = 0;
       }
     }
 
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
+
       MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
       const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
       MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
         ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
         : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
       );
       //MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
       //  ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
       //  : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
       //);
@@ -1138,46 +1141,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
     void lcd_autostart_sd() { card.beginautostart(); }
 
   #endif
 
   void lcd_main_menu() {
     START_MENU();
     MENU_BACK(MSG_WATCH);
 
-    #if ENABLED(CUSTOM_USER_MENUS)
-      MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
-    #endif
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      MENU_ITEM(submenu, MSG_IDEX_MENU, IDEX_menu);
-    #endif
-
-    //
-    // Debug Menu when certain options are enabled
-    //
-    #if HAS_DEBUG_MENU
-      MENU_ITEM(submenu, MSG_DEBUG_MENU, lcd_debug_menu);
-    #endif
-
-    //
-    // Set Case light on/off/brightness
-    //
-    #if ENABLED(MENU_ITEM_CASE_LIGHT)
-      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
-        MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
-      }
-      else
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
-    #endif
-
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
           if (card.sdprinting)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
         }
         else {
@@ -1188,28 +1165,34 @@ void lcd_quick_feedback(const bool clear_buttons) {
         }
       }
       else {
         MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
     #endif // SDSUPPORT
 
-    if (planner.movesplanned() || IS_SD_PRINTING)
+    const bool busy = printer_busy();
+    if (busy)
       MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
     else {
       MENU_ITEM(submenu, MSG_MOTION, lcd_movement_menu);
       MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_temperature_menu);
-      MENU_ITEM(submenu, MSG_CONFIGURATION, lcd_configuration_menu);
     }
 
+    MENU_ITEM(submenu, MSG_CONFIGURATION, lcd_configuration_menu);
+
+    #if ENABLED(CUSTOM_USER_MENUS)
+      MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
+    #endif
+
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
         if (thermalManager.targetHotEnoughToExtrude(active_extruder))
           MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
         else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
       #else
         MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
       #endif
     #endif
@@ -1229,21 +1212,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       if (powersupply_on)
         MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
       else
         MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
     #endif
 
     //
     // Autostart
     //
     #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+      if (!busy)
+        MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Tune" submenu items
    *
    */
@@ -2720,21 +2704,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
      *    Auto Home           (if homing needed)
      *    Leveling On/Off     (if data exists, and homed)
      *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
      *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
      *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
      *    Level Bed >
      *    Level Corners >     (if homed)
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
-    void lcd_bed_leveling() {
+    void lcd_bed_leveling_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       const bool is_homed = all_axes_known();
 
       // Auto Home if not using manual probing
       #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
         if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       #endif
 
@@ -2829,21 +2813,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
       MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
 
     #elif ENABLED(LCD_BED_LEVELING)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
-          MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling);
+          MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling_menu);
 
     #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
 
       #if DISABLED(PROBE_MANUALLY)
         MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
       #endif
       if (leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
@@ -3411,62 +3395,88 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
       END_MENU();
     }
 
   #endif
 
   void lcd_configuration_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
 
+    //
+    // Debug Menu when certain options are enabled
+    //
+    #if HAS_DEBUG_MENU
+      MENU_ITEM(submenu, MSG_DEBUG_MENU, lcd_debug_menu);
+    #endif
+
     MENU_ITEM(submenu, MSG_ADVANCED_SETTINGS, lcd_advanced_settings_menu);
 
+    const bool busy = printer_busy();
+    if (!busy) {
+      //
+      // Delta Calibration
+      //
+      #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
+      #endif
+
+      #if ENABLED(DUAL_X_CARRIAGE)
+        MENU_ITEM(submenu, MSG_IDEX_MENU, IDEX_menu);
+      #endif
+
+      #if ENABLED(BLTOUCH)
+        MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
+      #endif
+    }
+
     //
-    // Delta Calibration
+    // Set Case light on/off/brightness
     //
-    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
+    #if ENABLED(MENU_ITEM_CASE_LIGHT)
+      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
+        MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
+      else
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
     #endif
 
     #if HAS_LCD_CONTRAST
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_config_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif
 
-    #if ENABLED(BLTOUCH)
-      MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
-    #endif
-
     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
       MENU_ITEM_EDIT(bool, MSG_RUNOUT_SENSOR_ENABLE, &runout.enabled);
     #endif
 
     #if DISABLED(SLIM_LCD_MENUS)
       // Preheat configurations
       MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_configuration_temperature_preheat_material1_settings_menu);
       MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_configuration_temperature_preheat_material2_settings_menu);
     #endif
 
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+      if (!busy)
+        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif
 
-    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
+    if (!busy)
+      MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
 
     END_MENU();
   }
 
   /**
    *
    * "Temperature" submenu
    *
    */
 
@@ -4663,21 +4673,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
                     MENU_ITEM_P(submenu, msg5, lcd_temp_menu_e5_filament_change);
                   else
                     MENU_ITEM_P(gcode, msg5, PSTR("M600 B0 T5"));
                 #endif // E_STEPPERS > 5
               #endif // E_STEPPERS > 4
             #endif // E_STEPPERS > 3
           #endif // E_STEPPERS > 2
         #endif // E_STEPPERS == 1
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-          if (!planner.movesplanned() && !IS_SD_FILE_OPEN) {
+          if (!printer_busy()) {
             // Load filament
             #if E_STEPPERS == 1
               PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
               if (thermalManager.targetTooColdToExtrude(active_extruder))
                 MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
               else
                 MENU_ITEM_P(gcode, msg0, PSTR("M701"));
             #else
               PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
               PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);

commit 6d862b291677dbd91a5ecc40d7ebd881a45500ff
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 1 01:14:28 2018 -0400

    Home before level corners, if needed (#11976)
    
    …and add a consistent homing screen for all LCD pre-homing.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7f50d5d61b..aadc9486e7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1943,20 +1943,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
       no_reentry = false;
     }
 
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
     static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
   #endif
 
+  inline void _lcd_draw_homing() {
+    constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
+    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(line, PSTR(MSG_LEVEL_BED_HOMING));
+    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+  }
+
   #if ENABLED(LEVEL_BED_CORNERS)
 
     /**
      * Level corners, starting in the front-left corner.
      */
     static int8_t bed_corner;
     void _lcd_goto_next_corner() {
       line_to_z(4.0);
       switch (bed_corner) {
         case 0:
@@ -1994,25 +2000,36 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #if ENABLED(LEVEL_CENTER_TOO)
           MSG_LEVEL_BED_NEXT_POINT
         #else
           MSG_NEXT_CORNER
         #endif
         , _lcd_goto_next_corner);
       MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
       END_MENU();
     }
 
+    void _lcd_level_bed_corners_homing() {
+      _lcd_draw_homing();
+      if (all_axes_homed()) {
+        bed_corner = 0;
+        lcd_goto_screen(_lcd_corner_submenu);
+        _lcd_goto_next_corner();
+      }
+    }
+
     void _lcd_level_bed_corners() {
       defer_return_to_status = true;
-      lcd_goto_screen(_lcd_corner_submenu);
-      bed_corner = 0;
-      _lcd_goto_next_corner();
+      if (!all_axes_known()) {
+        axis_homed = 0;
+        enqueue_and_echo_commands_P(PSTR("G28"));
+      }
+      lcd_goto_screen(_lcd_level_bed_corners_homing);
     }
 
   #endif // LEVEL_BED_CORNERS
 
   #if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
 
     /**
      *
      * "Motion" > "Level Bed" handlers
      *
@@ -2145,22 +2162,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       if (use_click()) {
         manual_probe_index = 0;
         _lcd_level_goto_next_point();
       }
     }
 
     /**
      * Step 3: Display "Homing XYZ" - Wait for homing to finish
      */
     void _lcd_level_bed_homing() {
-      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
-      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+      _lcd_draw_homing();
       if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
     }
 
     #if ENABLED(PROBE_MANUALLY)
       extern bool g29_in_progress;
     #endif
 
     /**
      * Step 2: Continue Bed Leveling...
      */
@@ -2487,22 +2503,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       END_MENU();
     }
 
     /**
      * UBL LCD "radar" map homing
      */
     void _lcd_ubl_output_map_lcd();
 
     void _lcd_ubl_map_homing() {
       defer_return_to_status = true;
-      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT < 3 ? 0 : (LCD_HEIGHT > 4 ? 2 : 1), PSTR(MSG_LEVEL_BED_HOMING));
-      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+      _lcd_draw_homing();
       if (all_axes_homed()) {
         ubl.lcd_map_control = true; // Return to the map screen
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       }
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {
@@ -2751,21 +2766,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #elif HAS_BED_PROBE
         MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
       #endif
 
       #if ENABLED(LEVEL_BED_CORNERS)
         // Move to the next corner for leveling
-        if (all_axes_homed()) MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+        MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
   #endif // LCD_BED_LEVELING
@@ -2832,21 +2847,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
       #endif
 
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
-      if (all_axes_homed())
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     END_MENU();
   }
@@ -2879,24 +2893,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       KEEPALIVE_STATE(IN_HANDLER);
       lcd_goto_previous_menu_no_defer();
       return current_position[Z_AXIS];
     }
 
   #endif // DELTA_AUTO_CALIBRATION
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
 
     void _lcd_calibrate_homing() {
-      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      if (all_axes_homed())
-        lcd_goto_previous_menu();
+      _lcd_draw_homing();
+      if (all_axes_homed()) lcd_goto_previous_menu();
     }
 
     void _lcd_delta_calibrate_home() {
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
     void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7d3a8d0d38..7f50d5d61b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -118,29 +118,29 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
 void lcd_status_screen();
 
 millis_t next_lcd_update_ms;
 
 uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
 uint16_t max_display_update_time = 0;
 
 #if ENABLED(ULTIPANEL)
 
   #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
-    inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
+    inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
-    inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
+    inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
-    inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
+    inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, PGM_P pstr, PGM_P pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
       UNUSED(pstr2); UNUSED(pset); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(pget())); \
     } \
     typedef void _name##_void
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int3, itostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint8_t, int8, i8tostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float3, ftostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
@@ -247,45 +247,45 @@ uint16_t max_display_update_time = 0;
     void _lcd_set_z_fade_height() { set_z_fade_height(new_z_fade_height); }
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
-  void menu_action_gcode(const char* pgcode);
+  void menu_action_gcode(PGM_P pgcode);
   void menu_action_function(menuAction_t data);
 
   #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
     bool _menu_edit_ ## _name(); \
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
-    void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
-    void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
-    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback=NULL, const bool live=false); \
+    void _menu_action_setting_edit_ ## _name(PGM_P const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
+    void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
+    void menu_action_setting_edit_callback_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback=NULL, const bool live=false); \
     typedef void _name##_void
 
   DECLARE_MENU_EDIT_TYPE(int16_t, int3);
   DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
   DECLARE_MENU_EDIT_TYPE(float, float3);
   DECLARE_MENU_EDIT_TYPE(float, float52);
   DECLARE_MENU_EDIT_TYPE(float, float43);
   DECLARE_MENU_EDIT_TYPE(float, float5);
   DECLARE_MENU_EDIT_TYPE(float, float51);
   DECLARE_MENU_EDIT_TYPE(float, float52sign);
   DECLARE_MENU_EDIT_TYPE(float, float62);
   DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
 
-  void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
-  void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
+  void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr);
+  void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callbackFunc);
 
   #if ENABLED(SDSUPPORT)
     void lcd_sdcard_menu();
     void menu_action_sdfile(CardReader &theCard);
     void menu_action_sddirectory(CardReader &theCard);
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Macros ////////////
   ////////////////////////////////////////////
@@ -459,21 +459,21 @@ uint16_t max_display_update_time = 0;
   int8_t encoderTopLine;
   typedef struct {
     screenFunc_t menu_function;
     uint32_t encoder_position;
   } menuPosition;
   menuPosition screen_history[6];
   uint8_t screen_history_depth = 0;
   bool screen_changed, defer_return_to_status;
 
   // Value Editing
-  const char *editLabel;
+  PGM_P editLabel;
   void *editValue;
   int32_t minEditValue, maxEditValue;
   screenFunc_t callbackFunc;
   bool liveEdit;
 
   // Manual Moves
   const float manual_feedrate_mm_m[] = MANUAL_FEEDRATE;
   millis_t manual_move_start_time = 0;
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   #if EXTRUDERS > 1
@@ -563,42 +563,42 @@ uint16_t max_display_update_time = 0;
       #if ENABLED(DOGLCD)
         drawing_screen = false;
       #endif
     }
   }
 
   /**
    * Show "Moving..." till moves are done, then revert to previous display.
    */
   static const char moving[] PROGMEM = MSG_MOVING;
-  static const char *sync_message = moving;
+  static PGM_P sync_message = moving;
 
   //
   // Display the synchronize screen until moves are
   // finished, and don't return to the caller until
   // done. ** This blocks the command queue! **
   //
   void _lcd_synchronize() {
     if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
     if (no_reentry) return;
     // Make this the current handler till all moves are done
     no_reentry = true;
     const screenFunc_t old_screen = currentScreen;
     lcd_goto_screen(_lcd_synchronize);
     planner.synchronize(); // idle() is called until moves complete
     no_reentry = false;
     lcd_goto_screen(old_screen);
   }
 
   // Display the synchronize screen with a custom message
   // ** This blocks the command queue! **
-  void lcd_synchronize(const char * const msg=NULL) {
+  void lcd_synchronize(PGM_P const msg=NULL) {
     sync_message = msg ? msg : moving;
     _lcd_synchronize();
   }
 
   void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
 
   void lcd_save_previous_screen() {
     if (screen_history_depth < COUNT(screen_history)) {
       screen_history[screen_history_depth].menu_function = currentScreen;
       screen_history[screen_history_depth].encoder_position = encoderPosition;
@@ -765,41 +765,41 @@ void lcd_status_screen() {
   lcd_implementation_status_screen();
 }
 
 /**
  * Reset the status message
  */
 void lcd_reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
-  const char *msg;
+  PGM_P msg;
   if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (card.sdprinting)
       return lcd_setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
   lcd_setstatusPGM(msg, -1);
 }
 
 /**
  *
  * draw the kill screen
  *
  */
-void kill_screen(const char* lcd_msg) {
+void kill_screen(PGM_P lcd_msg) {
   lcd_init();
   lcd_setalertstatusPGM(lcd_msg);
   lcd_kill_screen();
 }
 
 /**
  *
  * Audio feedback for controller clicks
  *
  */
@@ -1073,21 +1073,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)
 
     #ifdef USER_SCRIPT_DONE
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
     #else
       #define _DONE_SCRIPT ""
     #endif
 
-    void _lcd_user_gcode(const char * const cmd) {
+    void _lcd_user_gcode(PGM_P const cmd) {
       enqueue_and_echo_commands_P(cmd);
       #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
         lcd_completion_feedback();
       #endif
       #if ENABLED(USER_SCRIPT_RETURN)
         lcd_return_to_status();
       #endif
     }
 
     #if defined(USER_DESC_1) && defined(USER_GCODE_1)
@@ -1281,21 +1281,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
         u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
         u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
       }
     }
 
   #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || MESH_EDIT_GFX_OVERLAY
 
   #if ENABLED(BABYSTEPPING)
 
-    void _lcd_babystep(const AxisEnum axis, const char* msg) {
+    void _lcd_babystep(const AxisEnum axis, PGM_P msg) {
       if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         thermalManager.babystep_axis(axis, babystep_increment);
         babysteps_done += babystep_increment;
       }
       if (lcdDrawUpdate)
@@ -1366,21 +1366,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif // !BABYSTEP_ZPROBE_OFFSET
 
   #endif // BABYSTEPPING
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
                                                   // separate value that doesn't lose precision.
     static int16_t ubl_encoderPosition = 0;
 
-    static void _lcd_mesh_fine_tune(const char* msg) {
+    static void _lcd_mesh_fine_tune(PGM_P msg) {
       defer_return_to_status = true;
       if (ubl.encoder_diff) {
         ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
         ubl.encoder_diff = 0;
 
         mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005f * 0.5f;
         mesh_edit_value = mesh_edit_accumulator;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
 
@@ -1930,21 +1930,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     /**
      * If the queue is full, the command will fail, so we have to loop
      * with idle() to make sure the command has been enqueued.
      */
     void lcd_enqueue_command(char * const cmd) {
       no_reentry = true;
       enqueue_and_echo_command_now(cmd);
       no_reentry = false;
     }
 
-    void lcd_enqueue_commands_P(const char * const cmd) {
+    void lcd_enqueue_commands_P(PGM_P const cmd) {
       no_reentry = true;
       enqueue_and_echo_commands_now_P(cmd);
       no_reentry = false;
     }
 
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
     static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
@@ -3023,21 +3023,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Motion" > "Move Axis" submenu
    *
    */
 
-  void _lcd_move_xyz(const char* name, AxisEnum axis) {
+  void _lcd_move_xyz(PGM_P name, AxisEnum axis) {
     if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
 
       // Start with no limits to movement
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       // Limit to software endstops, if enabled
       #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
@@ -4501,21 +4501,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
     /**
      *
      * "Change Filament" > "Change/Unload/Load Filament" submenu
      *
      */
     static AdvancedPauseMode _change_filament_temp_mode;
     static int8_t _change_filament_temp_extruder;
 
-    static const char* _change_filament_temp_command() {
+    static PGM_P _change_filament_temp_command() {
       switch (_change_filament_temp_mode) {
         case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
           return PSTR("M701 T%d");
         case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
           return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
         case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
         default:
           return PSTR("M600 B0 T%d");
       }
       return PSTR(MSG_FILAMENTCHANGE);
@@ -4524,21 +4524,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void _change_filament_temp(const uint16_t temperature) {
       char cmd[11];
       sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
       thermalManager.setTargetHotend(temperature, _change_filament_temp_extruder);
       lcd_enqueue_command(cmd);
     }
     void _lcd_change_filament_temp_1_menu() { _change_filament_temp(PREHEAT_1_TEMP_HOTEND); }
     void _lcd_change_filament_temp_2_menu() { _change_filament_temp(PREHEAT_2_TEMP_HOTEND); }
     void _lcd_change_filament_temp_custom_menu() { _change_filament_temp(thermalManager.target_temperature[_change_filament_temp_extruder]); }
 
-    static const char* change_filament_header(const AdvancedPauseMode mode) {
+    static PGM_P change_filament_header(const AdvancedPauseMode mode) {
       switch (mode) {
         case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
           return PSTR(MSG_FILAMENTLOAD);
         case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
           return PSTR(MSG_FILAMENTUNLOAD);
         default: break;
       }
       return PSTR(MSG_FILAMENTCHANGE);
     }
 
@@ -4772,21 +4772,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
           }
         #endif
 
         END_MENU();
       }
     #endif
 
     static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
     static uint8_t hotend_status_extruder = 0;
 
-    static const char* advanced_pause_header() {
+    static PGM_P advanced_pause_header() {
       switch (advanced_pause_mode) {
         case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
           return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
         case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
           return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
         default: break;
       }
       return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
     }
 
@@ -5054,23 +5054,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    * Functions for editing single values
    *
    * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
    *
    * For example, DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1) expands into these functions:
    *
    *   bool _menu_edit_int3();
    *   void menu_edit_int3(); // edit int16_t (interactively)
    *   void menu_edit_callback_int3(); // edit int16_t (interactively) with callback on completion
-   *   void _menu_action_setting_edit_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
-   *   void menu_action_setting_edit_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
-   *   void menu_action_setting_edit_callback_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
+   *   void _menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+   *   void menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+   *   void menu_action_setting_edit_callback_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
    *
    * You can then use one of the menu macros to present the edit interface:
    *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
    *
    * This expands into a more primitive menu item:
    *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *
    * ...which calls:
    *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    */
@@ -5083,37 +5083,37 @@ void lcd_quick_feedback(const bool clear_buttons) {
         lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale))); \
       if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
         _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale); \
         if (editValue != NULL) *((_type*)editValue) = value; \
         if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
         if (lcd_clicked) lcd_goto_previous_menu(); \
       } \
       return use_click(); \
     } \
     void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
-    void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
+    void _menu_action_setting_edit_ ## _name(PGM_P const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
       lcd_save_previous_screen(); \
       lcd_refresh(); \
       \
       editLabel = pstr; \
       editValue = ptr; \
       minEditValue = minValue * _scale; \
       maxEditValue = maxValue * _scale - minEditValue; \
       encoderPosition = (*ptr) * _scale - minEditValue; \
     } \
-    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
+    void menu_action_setting_edit_callback_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
-    FORCE_INLINE void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
+    FORCE_INLINE void menu_action_setting_edit_ ## _name(PGM_P const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
       menu_action_setting_edit_callback_ ## _name(pstr, ptr, minValue, maxValue); \
     } \
     typedef void _name##_void
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
@@ -5212,21 +5212,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #endif // REPRAPWORLD_KEYPAD
 
   /**
    *
    * Menu actions
    *
    */
   void _menu_action_back() { lcd_goto_previous_menu(); }
   void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
-  void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
+  void menu_action_gcode(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
   void menu_action_function(screenFunc_t func) { (*func)(); }
 
   #if ENABLED(SDSUPPORT)
 
     void menu_action_sdfile(CardReader &theCard) {
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
         last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
       #endif
       card.openAndPrintFile(theCard.filename);
       lcd_return_to_status();
@@ -5239,22 +5239,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
       #if ENABLED(DOGLCD)
         drawing_screen = false;
       #endif
       lcd_refresh();
     }
 
   #endif // SDSUPPORT
 
-  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
-  void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
+  void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
+  void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();
   }
 
 #endif // ULTIPANEL
 
 void lcd_init() {
 
   lcd_implementation_init();
 
@@ -5687,58 +5687,58 @@ void lcd_setstatus(const char * const message, const bool persist) {
   };
 
   // At this point, we have the proper cut point. Use it
   uint8_t maxLen = pend - message;
   strncpy(lcd_status_message, message, maxLen);
   lcd_status_message[maxLen] = '\0';
 
   lcd_finishstatus(persist);
 }
 
-void lcd_setstatusPGM(const char * const message, int8_t level) {
+void lcd_setstatusPGM(PGM_P const message, int8_t level) {
   if (level < 0) level = lcd_status_message_level = 0;
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
 
   // Here we have a problem. The message is encoded in UTF8, so
   // arbitrarily cutting it will be a problem. We MUST be sure
   // that there is no cutting in the middle of a multibyte character!
 
   // Get a pointer to the null terminator
-  const char* pend = message + strlen_P(message);
+  PGM_P pend = message + strlen_P(message);
 
   //  If length of supplied UTF8 string is greater than
   // our buffer size, start cutting whole UTF8 chars
   while ((pend - message) > MAX_MESSAGE_LENGTH) {
     --pend;
     while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
   };
 
   // At this point, we have the proper cut point. Use it
   uint8_t maxLen = pend - message;
   strncpy_P(lcd_status_message, message, maxLen);
   lcd_status_message[maxLen] = '\0';
 
   lcd_finishstatus(level > 0);
 }
 
-void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
+void lcd_status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
   va_list args;
   va_start(args, fmt);
   vsnprintf_P(lcd_status_message, MAX_MESSAGE_LENGTH, fmt, args);
   va_end(args);
   lcd_finishstatus(level > 0);
 }
 
-void lcd_setalertstatusPGM(const char * const message) {
+void lcd_setalertstatusPGM(PGM_P const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }
 
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
 #if HAS_LCD_CONTRAST
 

commit 4d5566a6b720d9cfde0073d55e551625144983fe
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Sep 30 22:33:46 2018 -0400

    Add filament runout sensor menu item (#11971)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index dabb694a16..7d3a8d0d38 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -64,20 +64,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../feature/leds/leds.h"
 #endif
 
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "../feature/runout.h"
+#endif
+
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
@@ -3421,20 +3425,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif
 
     #if ENABLED(BLTOUCH)
       MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
     #endif
 
+    #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+      MENU_ITEM_EDIT(bool, MSG_RUNOUT_SENSOR_ENABLE, &runout.enabled);
+    #endif
+
     #if DISABLED(SLIM_LCD_MENUS)
       // Preheat configurations
       MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_configuration_temperature_preheat_material1_settings_menu);
       MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_configuration_temperature_preheat_material2_settings_menu);
     #endif
 
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif

commit b30ca652aed417be0ba8857922c1cf2b4df26f2d
Author: AnoNymous <dgdanielf@gmail.com>
Date:   Sun Sep 30 11:59:14 2018 +0200

    Replace MIN# / MAX# with variadic MIN / MAX (#11960)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3f55bc96b3..dabb694a16 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3690,31 +3690,31 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     #endif // PIDTEMP
 
     END_MENU();
   }
 
   #if DISABLED(SLIM_LCD_MENUS)
 
     void _lcd_configuration_temperature_preheat_settings_menu(const uint8_t material) {
       #if HOTENDS > 5
-        #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
-        #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
+        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
+        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
       #elif HOTENDS > 4
-        #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
-        #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
+        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
+        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
       #elif HOTENDS > 3
-        #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
-        #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
+        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
+        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
       #elif HOTENDS > 2
-        #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
-        #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
+        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
+        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
         #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
         #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
       #else
         #define MINTEMP_ALL HEATER_0_MINTEMP
         #define MAXTEMP_ALL HEATER_0_MAXTEMP
       #endif
       START_MENU();
       MENU_BACK(MSG_CONFIGURATION);
       MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);

commit 93839e2f73c78fd2448c15c5ffefef62fd53fe6b
Author: Victor Tseng <palatis@gmail.com>
Date:   Sat Sep 29 05:52:56 2018 +0800

    Add option to enable/disable autoretract altogether (#11904)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 668db43d57..3f55bc96b3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4140,21 +4140,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
   /**
    *
    * "Configuration" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_config_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
+      #if ENABLED(FWRETRACT_AUTORETRACT)
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
+      #endif
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
       #endif

commit cee34f72901788fabc358a31580c9894c6424a20
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 24 21:46:56 2018 -0400

    Followup for BABYSTEP_HOTEND_Z_OFFSET (#11916)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9efd47d24f..668db43d57 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1303,56 +1303,60 @@ void lcd_quick_feedback(const bool clear_buttons) {
       void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
+        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+          const bool do_probe = (active_extruder == 0);
+        #else
+          constexpr bool do_probe = true;
+        #endif
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
-          const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
-          if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+          const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                      new_probe_offset = zprobe_zoffset + diff,
+                      new_offs =
+                        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+                          do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
+                        #else
+                          new_probe_offset
+                        #endif
+                      ;
+          if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
+            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
+            if (do_probe) zprobe_zoffset = new_offs;
             #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-              if (active_extruder == 0)
-              {
-                thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-                zprobe_zoffset = new_zoffset;
-              } else {
-                  thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-                  hotend_offset[Z_AXIS][active_extruder] -= (planner.steps_to_mm[Z_AXIS] * babystep_increment);
-                }
-            #else
-              zprobe_zoffset = new_zoffset;
+              else hotend_offset[Z_AXIS][active_extruder] = new_offs;
             #endif
+
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-            if (active_extruder == 0) {
+            if (do_probe)
               lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
-            } else {
+            else
               lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
-            }
           #endif
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-            if (active_extruder == 0) {
-              _lcd_zoffset_overlay_gfx(zprobe_zoffset);
-            }
+            if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
       void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
     #endif // !BABYSTEP_ZPROBE_OFFSET

commit 1104054d7347668a61e90fb6216e22afae2ef9f3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Sep 24 10:40:48 2018 -0400

    2.0 IDEX Independent z offset and other fixes (#11862)
    
    * Add Formbot Raptor board
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Add a second Z probe Z offset
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Modify method to utilize live adjustment of hotend z offset
    
    Should probably move config option to babystepping and rename as it may now apply to all multiextruder systems
    
    * Move config item and catchup other code to current method

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 34dc1c8cc5..9efd47d24f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1310,29 +1310,49 @@ void lcd_quick_feedback(const bool clear_buttons) {
       void lcd_babystep_zoffset() {
         if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-            zprobe_zoffset = new_zoffset;
+
+
+            #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+              if (active_extruder == 0)
+              {
+                thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+                zprobe_zoffset = new_zoffset;
+              } else {
+                  thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+                  hotend_offset[Z_AXIS][active_extruder] -= (planner.steps_to_mm[Z_AXIS] * babystep_increment);
+                }
+            #else
+              zprobe_zoffset = new_zoffset;
+            #endif
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
-          lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+          #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+            if (active_extruder == 0) {
+              lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+            } else {
+              lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+            }
+          #endif
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-            _lcd_zoffset_overlay_gfx(zprobe_zoffset);
+            if (active_extruder == 0) {
+              _lcd_zoffset_overlay_gfx(zprobe_zoffset);
+            }
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
       void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
     #endif // !BABYSTEP_ZPROBE_OFFSET

commit a2b0260f0f9544c87c276a7b23272bd9307dd1fa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 23 19:58:36 2018 -0400

    Update Sublime files

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c18ed1fb3b..34dc1c8cc5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -64,21 +64,20 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../feature/leds/leds.h"
 #endif
 
-// For i2c define BUZZ to use lcd_buzz
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 80a77752bf..c18ed1fb3b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1049,24 +1049,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
       const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
       MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
         ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
         : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
       );
-//    MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
-//      ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
-//      : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
-//    );
+      //MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
+      //  ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
+      //  : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
+      //);
       MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
       MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
       END_MENU();
     }
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)

commit 378f354939db76d68ca46e5812e82d380ec74e87
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 10:26:44 2018 -0500

    IDEX Scaled Duplication is still under development
    
    Take it out of the menu until it is tested and working.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1a0d5f9839..80a77752bf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1049,24 +1049,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
       const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
       MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
         ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
         : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
       );
-      MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
-        ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
-        : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
-      );
+//    MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
+//      ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
+//      : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
+//    );
       MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
       MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
       END_MENU();
     }
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 070d127850..1a0d5f9839 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -31,20 +31,22 @@
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
 #include "../module/printcounter.h"
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
+#include "../module/tool_change.h"
+
 
 #include "../Marlin.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
@@ -514,21 +516,21 @@ uint16_t max_display_update_time = 0;
       #endif
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
-        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms) && (planner.movesplanned() || IS_SD_PRINTING))
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms)/* && (planner.movesplanned() || IS_SD_PRINTING)*/)
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
               lcd_babystep_zoffset
             #else
               lcd_babystep_z
             #endif
           ;
       #endif
 
       currentScreen = screen;
@@ -1031,29 +1033,45 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
   #endif // HAS_DEBUG_MENU
 
   /**
    * IDEX submenu
    */
   #if ENABLED(DUAL_X_CARRIAGE)
+    static void _recalc_IDEX_settings() {
+      if (active_extruder) {                      // For the 2nd extruder re-home so the next tool-change gets the new offsets.
+        enqueue_and_echo_commands_P(PSTR("G28")); // In future, we can babystep the 2nd extruder (if active), making homing unnecessary.
+        active_extruder = 0;
+      }
+    }
+
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK, PSTR("M605 S1\nG28 X\nG1 X100"));
-      if (!TEST(axis_known_position, Y_AXIS) || !TEST(axis_known_position, Z_AXIS))
-        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100"));  // If Y or Z is not homed, a full G28 is done first.
-      else
-        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100"));       // If Y and Z is homed, a full G28 is not needed first.
+      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
+      const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
+      MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
+        ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
+        : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
+      );
+      MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
+        ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
+        : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
+      );
       MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
+      MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
       END_MENU();
     }
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)
 
     #ifdef USER_SCRIPT_DONE
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
     #else
       #define _DONE_SCRIPT ""

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 943edc153e..070d127850 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1395,20 +1395,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif
     void watch_temp_callback_E0() { _WATCH_FUNC(0); }
     #if HOTENDS > 1
       void watch_temp_callback_E1() { _WATCH_FUNC(1); }
       #if HOTENDS > 2
         void watch_temp_callback_E2() { _WATCH_FUNC(2); }
         #if HOTENDS > 3
           void watch_temp_callback_E3() { _WATCH_FUNC(3); }
           #if HOTENDS > 4
             void watch_temp_callback_E4() { _WATCH_FUNC(4); }
+            #if HOTENDS > 5
+              void watch_temp_callback_E5() { _WATCH_FUNC(5); }
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif // HAS_TEMP_HOTEND
 
   void watch_temp_callback_bed() {
     #if WATCH_THE_BED
       thermalManager.start_watching_bed();
     #endif
@@ -1427,20 +1430,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
   inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
   #if EXTRUDERS > 1
     inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
     inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
     #if EXTRUDERS > 2
       inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
       #if EXTRUDERS > 3
         inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
         #if EXTRUDERS > 4
           inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
+          #if EXTRUDERS > 5
+            inline void _lcd_refresh_e_factor_5() { planner.refresh_e_factor(5); }
+          #endif // EXTRUDERS > 5
         #endif // EXTRUDERS > 4
       #endif // EXTRUDERS > 3
     #endif // EXTRUDERS > 2
   #endif // EXTRUDERS > 1
 
   /**
    *
    * "Tune" submenu
    *
    */
@@ -1479,20 +1485,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #if HOTENDS > 2
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
         #if HOTENDS > 3
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
           #if HOTENDS > 4
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+            #if HOTENDS > 5
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
     //
     // Bed:
     //
     #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
@@ -1531,20 +1540,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #else // EXTRUDERS > 1
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
       #if EXTRUDERS > 2
         MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
         #if EXTRUDERS > 3
           MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
           #if EXTRUDERS > 4
             MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
+            #if EXTRUDERS > 5
+              MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N6, &planner.flow_percentage[5], 10, 999, _lcd_refresh_e_factor_5);
+            #endif // EXTRUDERS > 5
           #endif // EXTRUDERS > 4
         #endif // EXTRUDERS > 3
       #endif // EXTRUDERS > 2
     #endif // EXTRUDERS > 1
 
     //
     // Babystep X:
     // Babystep Y:
     // Babystep Z:
     //
@@ -1665,52 +1677,66 @@ void lcd_quick_feedback(const bool clear_buttons) {
           void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
           void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
         #endif
         #if HOTENDS > 4
           void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
           void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
           #if HAS_HEATED_BED
             void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
             void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
           #endif
+          #if HOTENDS > 5
+            void lcd_preheat_m1_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+            void lcd_preheat_m2_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+            #if HAS_HEATED_BED
+              void lcd_preheat_m1_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+              void lcd_preheat_m2_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+            #endif
+          #endif // HOTENDS > 5
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
 
     void lcd_preheat_m1_all() {
       #if HOTENDS > 1
         thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
         #if HOTENDS > 2
           thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
           #if HOTENDS > 3
             thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
             #if HOTENDS > 4
               thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
+              #if HOTENDS > 5
+                thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 5);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         lcd_preheat_m1_e0();
       #else
         lcd_preheat_m1_e0_only();
       #endif
     }
     void lcd_preheat_m2_all() {
       #if HOTENDS > 1
         thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
         #if HOTENDS > 2
           thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
           #if HOTENDS > 3
             thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
             #if HOTENDS > 4
               thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
+              #if HOTENDS > 5
+                thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 5);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         lcd_preheat_m2_e0();
       #else
         lcd_preheat_m2_e0_only();
       #endif
     }
@@ -1758,20 +1784,28 @@ void lcd_quick_feedback(const bool clear_buttons) {
             #else
               MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
             #endif
             #if HOTENDS > 4
               #if HAS_HEATED_BED
                 MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
                 MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
               #else
                 MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
               #endif
+              #if HOTENDS > 5
+                #if HAS_HEATED_BED
+                  MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5);
+                  MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E6, lcd_preheat_m1_e5_only);
+                #else
+                  MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5_only);
+                #endif
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
         MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
       #endif
       END_MENU();
     }
@@ -1810,20 +1844,28 @@ void lcd_quick_feedback(const bool clear_buttons) {
             #else
               MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
             #endif
             #if HOTENDS > 4
               #if HAS_HEATED_BED
                 MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
                 MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
               #else
                 MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
               #endif
+              #if HOTENDS > 5
+                #if HAS_HEATED_BED
+                  MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5);
+                  MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E6, lcd_preheat_m2_e5_only);
+                #else
+                  MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5_only);
+                #endif
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
         MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
       #endif
       END_MENU();
     }
@@ -3054,20 +3096,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #else
         switch (eindex) {
           default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
           case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
           #if E_MANUAL > 2
             case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
             #if E_MANUAL > 3
               case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
               #if E_MANUAL > 4
                 case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
+                #if E_MANUAL > 5
+                  case 5: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E6); break;
+                #endif // E_MANUAL > 5
               #endif // E_MANUAL > 4
             #endif // E_MANUAL > 3
           #endif // E_MANUAL > 2
         }
       #endif // E_MANUAL > 1
       lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
         #if ENABLED(MANUAL_E_MOVES_RELATIVE)
@@ -3080,20 +3125,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
   void lcd_move_e() { _lcd_move_e(); }
   #if E_MANUAL > 1
     void lcd_move_e0() { _lcd_move_e(0); }
     void lcd_move_e1() { _lcd_move_e(1); }
     #if E_MANUAL > 2
       void lcd_move_e2() { _lcd_move_e(2); }
       #if E_MANUAL > 3
         void lcd_move_e3() { _lcd_move_e(3); }
         #if E_MANUAL > 4
           void lcd_move_e4() { _lcd_move_e(4); }
+          #if E_MANUAL > 5
+            void lcd_move_e5() { _lcd_move_e(5); }
+          #endif // E_MANUAL > 5
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Motion" > "Move Xmm" > "Move XYZ" submenu
    *
    */
@@ -3140,20 +3188,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
   void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e); }
   #if E_MANUAL > 1
     void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0); }
     void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1); }
     #if E_MANUAL > 2
       void lcd_move_get_e2_amount()   { _lcd_move_distance_menu(E_AXIS, lcd_move_e2); }
       #if E_MANUAL > 3
         void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3); }
         #if E_MANUAL > 4
           void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4); }
+          #if E_MANUAL > 5
+            void lcd_move_get_e5_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e5); }
+          #endif // E_MANUAL > 5
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Motion" > "Move Axis" submenu
    *
    */
@@ -3192,21 +3243,30 @@ void lcd_quick_feedback(const bool clear_buttons) {
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 
       MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
     }
     else
       MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
 
     #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
 
-      #if EXTRUDERS == 4
+      #if EXTRUDERS == 6
+        switch (active_extruder) {
+          case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
+          case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
+          case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
+          case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
+          case 4: MENU_ITEM(gcode, MSG_SELECT " " MSG_E6, PSTR("T5")); break;
+          case 5: MENU_ITEM(gcode, MSG_SELECT " " MSG_E5, PSTR("T4")); break;
+        }
+      #elif EXTRUDERS == 5 || EXTRUDERS == 4
         switch (active_extruder) {
           case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
           case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
           case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
           case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
         }
       #elif EXTRUDERS == 3
         if (active_extruder < 2) {
           if (active_extruder)
             MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
@@ -3246,20 +3306,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
       #if E_MANUAL > 1
         MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
         MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
         #if E_MANUAL > 2
           MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
           #if E_MANUAL > 3
             MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
             #if E_MANUAL > 4
               MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+              #if E_MANUAL > 5
+                MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E6, lcd_move_get_e5_amount);
+              #endif // E_MANUAL > 5
             #endif // E_MANUAL > 4
           #endif // E_MANUAL > 3
         #endif // E_MANUAL > 2
       #endif // E_MANUAL > 1
 
     #endif
 
     END_MENU();
   }
 
@@ -3405,20 +3468,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
     DEFINE_PIDTEMP_FUNCS(0);
     #if ENABLED(PID_PARAMS_PER_HOTEND)
       #if HOTENDS > 1
         DEFINE_PIDTEMP_FUNCS(1);
         #if HOTENDS > 2
           DEFINE_PIDTEMP_FUNCS(2);
           #if HOTENDS > 3
             DEFINE_PIDTEMP_FUNCS(3);
             #if HOTENDS > 4
               DEFINE_PIDTEMP_FUNCS(4);
+              #if HOTENDS > 5
+                DEFINE_PIDTEMP_FUNCS(5);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
     #endif // PID_PARAMS_PER_HOTEND
 
   #endif // PIDTEMP
 
   /**
    *
@@ -3437,20 +3503,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #if HOTENDS > 2
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
         #if HOTENDS > 3
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
           #if HOTENDS > 4
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+            #if HOTENDS > 5
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
+            #endif // HOTENDS > 5
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
     //
     // Bed:
     //
     #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
@@ -3561,36 +3630,42 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
         PID_MENU_ITEMS(" " MSG_E1, 0);
         PID_MENU_ITEMS(" " MSG_E2, 1);
         #if HOTENDS > 2
           PID_MENU_ITEMS(" " MSG_E3, 2);
           #if HOTENDS > 3
             PID_MENU_ITEMS(" " MSG_E4, 3);
             #if HOTENDS > 4
               PID_MENU_ITEMS(" " MSG_E5, 4);
+              #if HOTENDS > 5
+                PID_MENU_ITEMS(" " MSG_E6, 5);
+              #endif // HOTENDS > 5
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
         PID_MENU_ITEMS("", 0);
       #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
 
     #endif // PIDTEMP
 
     END_MENU();
   }
 
   #if DISABLED(SLIM_LCD_MENUS)
 
     void _lcd_configuration_temperature_preheat_settings_menu(const uint8_t material) {
-      #if HOTENDS > 4
+      #if HOTENDS > 5
+        #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
+        #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
+      #elif HOTENDS > 4
         #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
         #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
       #elif HOTENDS > 3
         #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
         #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
       #elif HOTENDS > 2
         #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
         #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
         #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
@@ -3632,20 +3707,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #if ENABLED(DISTINCT_E_FACTORS)
       void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
       void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
       void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
       #if E_STEPPERS > 2
         void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
         #if E_STEPPERS > 3
           void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
           #if E_STEPPERS > 4
             void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
+            #if E_STEPPERS > 5
+              void _reset_e5_acceleration_rate() { _reset_e_acceleration_rate(5); }
+            #endif // E_STEPPERS > 5
           #endif // E_STEPPERS > 4
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     void _planner_refresh_positioning() { planner.refresh_positioning(); }
     #if ENABLED(DISTINCT_E_FACTORS)
       void _planner_refresh_e_positioning(const uint8_t e) {
         if (e == active_extruder)
           _planner_refresh_positioning();
@@ -3653,20 +3731,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
           planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.axis_steps_per_mm[E_AXIS + e];
       }
       void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
       void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
       #if E_STEPPERS > 2
         void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
         #if E_STEPPERS > 3
           void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
           #if E_STEPPERS > 4
             void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
+            #if E_STEPPERS > 5
+              void _planner_refresh_e5_positioning() { _planner_refresh_e_positioning(5); }
+            #endif // E_STEPPERS > 5
           #endif // E_STEPPERS > 4
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     // M203 / M205 Velocity options
     void lcd_advanced_velocity_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
@@ -3678,20 +3759,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
         #if E_STEPPERS > 2
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
           #if E_STEPPERS > 3
             MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
             #if E_STEPPERS > 4
               MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+              #if E_STEPPERS > 5
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
+              #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
       #endif
 
       // M205 S Min Feedrate
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
 
@@ -3723,20 +3807,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
         #if E_STEPPERS > 2
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
           #if E_STEPPERS > 3
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
             #if E_STEPPERS > 4
               MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+              #if E_STEPPERS > 5
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
+              #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
       #endif
 
       END_MENU();
     }
 
@@ -3780,20 +3867,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
         #if E_STEPPERS > 2
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
           #if E_STEPPERS > 3
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
             #if E_STEPPERS > 4
               MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
+              #if E_STEPPERS > 5
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
+              #endif // E_STEPPERS > 5
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
       #endif
 
       END_MENU();
     }
 
@@ -3858,20 +3948,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
       #elif EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
         #if EXTRUDERS > 2
           MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
           #if EXTRUDERS > 3
             MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
             #if EXTRUDERS > 4
               MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+              #if EXTRUDERS > 5
+                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
+              #endif // EXTRUDERS > 5
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2
       #endif // EXTRUDERS > 1
     #endif
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
     #endif
@@ -3907,42 +4000,48 @@ void lcd_quick_feedback(const bool clear_buttons) {
           MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
         #elif EXTRUDERS > 1
           MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
           MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
           #if EXTRUDERS > 2
             MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
             #if EXTRUDERS > 3
               MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
               #if EXTRUDERS > 4
                 MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+                #if EXTRUDERS > 5
+                  MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
+                #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
           #else // EXTRUDERS > 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
             #if EXTRUDERS > 2
               MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-            #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-              #if EXTRUDERS > 4
+              #if EXTRUDERS > 3
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+                #if EXTRUDERS > 4
                   MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+                  #if EXTRUDERS > 5
+                    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E6, &planner.filament_size[5], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+                  #endif // EXTRUDERS > 5
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
           #endif // EXTRUDERS > 1
         }
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         const float extrude_maxlength =
           #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
@@ -3953,41 +4052,47 @@ void lcd_quick_feedback(const bool clear_buttons) {
         ;
 
         #if EXTRUDERS == 1
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0, extrude_maxlength);
         #else // EXTRUDERS > 1
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0, extrude_maxlength);
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0, extrude_maxlength);
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0, extrude_maxlength);
           #if EXTRUDERS > 2
             MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0, extrude_maxlength);
-          #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0, extrude_maxlength);
-            #if EXTRUDERS > 4
+            #if EXTRUDERS > 3
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0, extrude_maxlength);
+              #if EXTRUDERS > 4
                 MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0, extrude_maxlength);
+                #if EXTRUDERS > 5
+                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &filament_change_unload_length[5], 0, extrude_maxlength);
+                #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
 
         #if EXTRUDERS == 1
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0, extrude_maxlength);
         #else // EXTRUDERS > 1
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0, extrude_maxlength);
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0, extrude_maxlength);
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0, extrude_maxlength);
           #if EXTRUDERS > 2
             MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0, extrude_maxlength);
-          #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0, extrude_maxlength);
-            #if EXTRUDERS > 4
+            #if EXTRUDERS > 3
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0, extrude_maxlength);
+              #if EXTRUDERS > 4
                 MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0, extrude_maxlength);
+                #if EXTRUDERS > 5
+                  MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &filament_change_load_length[5], 0, extrude_maxlength);
+                #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       #endif
 
       END_MENU();
     }
   #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
 
@@ -4398,20 +4503,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       switch (extruder) {
         default: max_temp = HEATER_0_MAXTEMP;
         #if HOTENDS > 1
           case 1: max_temp = HEATER_1_MAXTEMP; break;
           #if HOTENDS > 2
             case 2: max_temp = HEATER_2_MAXTEMP; break;
             #if HOTENDS > 3
               case 3: max_temp = HEATER_3_MAXTEMP; break;
               #if HOTENDS > 4
                 case 4: max_temp = HEATER_4_MAXTEMP; break;
+                #if HOTENDS > 5
+                  case 5: max_temp = HEATER_5_MAXTEMP; break;
+                #endif
               #endif
             #endif
           #endif
         #endif
       }
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PREHEAT_CUSTOM, &thermalManager.target_temperature[_change_filament_temp_extruder], EXTRUDE_MINTEMP, max_temp - 15, _lcd_change_filament_temp_custom_menu);
       END_MENU();
     }
     void lcd_temp_menu_e0_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
     void lcd_temp_menu_e0_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
@@ -4479,20 +4587,27 @@ void lcd_quick_feedback(const bool clear_buttons) {
               if (thermalManager.targetTooColdToExtrude(3))
                 MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_change);
               else
                 MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
               #if E_STEPPERS > 4
                 PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
                 if (thermalManager.targetTooColdToExtrude(4))
                   MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_change);
                 else
                   MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
+                #if E_STEPPERS > 5
+                  PGM_P msg5 = PSTR(MSG_FILAMENTCHANGE " " MSG_E6);
+                  if (thermalManager.targetTooColdToExtrude(5))
+                    MENU_ITEM_P(submenu, msg5, lcd_temp_menu_e5_filament_change);
+                  else
+                    MENU_ITEM_P(gcode, msg5, PSTR("M600 B0 T5"));
+                #endif // E_STEPPERS > 5
               #endif // E_STEPPERS > 4
             #endif // E_STEPPERS > 3
           #endif // E_STEPPERS > 2
         #endif // E_STEPPERS == 1
 
         #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           if (!planner.movesplanned() && !IS_SD_FILE_OPEN) {
             // Load filament
             #if E_STEPPERS == 1
               PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
@@ -4522,20 +4637,27 @@ void lcd_quick_feedback(const bool clear_buttons) {
                   if (thermalManager.targetTooColdToExtrude(3))
                     MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_load);
                   else
                     MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
                   #if E_STEPPERS > 4
                     PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
                     if (thermalManager.targetTooColdToExtrude(4))
                       MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_load);
                     else
                       MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
+                    #if E_STEPPERS > 5
+                      PGM_P msg5 = PSTR(MSG_FILAMENTLOAD " " MSG_E6);
+                      if (thermalManager.targetTooColdToExtrude(5))
+                        MENU_ITEM_P(submenu, msg5, lcd_temp_menu_e5_filament_load);
+                      else
+                        MENU_ITEM_P(gcode, msg5, PSTR("M701 T5"));
+                    #endif // E_STEPPERS > 5
                   #endif // E_STEPPERS > 4
                 #endif // E_STEPPERS > 3
               #endif // E_STEPPERS > 2
             #endif // E_STEPPERS == 1
 
             // Unload filament
             #if E_STEPPERS == 1
               if (thermalManager.targetHotEnoughToExtrude(active_extruder))
                 MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
               else
@@ -4544,20 +4666,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
               #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
                 if (thermalManager.targetHotEnoughToExtrude(0)
                   #if E_STEPPERS > 1
                     && thermalManager.targetHotEnoughToExtrude(1)
                     #if E_STEPPERS > 2
                       && thermalManager.targetHotEnoughToExtrude(2)
                       #if E_STEPPERS > 3
                         && thermalManager.targetHotEnoughToExtrude(3)
                         #if E_STEPPERS > 4
                           && thermalManager.targetHotEnoughToExtrude(4)
+                          #if E_STEPPERS > 5
+                            && thermalManager.targetHotEnoughToExtrude(5)
+                          #endif // E_STEPPERS > 5
                         #endif // E_STEPPERS > 4
                       #endif // E_STEPPERS > 3
                     #endif // E_STEPPERS > 2
                   #endif // E_STEPPERS > 1
                 )
                   MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
               else
                 MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, lcd_unload_filament_all_temp_menu);
               #endif
               if (thermalManager.targetHotEnoughToExtrude(0))
@@ -4576,20 +4701,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
                 #if E_STEPPERS > 3
                   if (thermalManager.targetHotEnoughToExtrude(3))
                     MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
                   else
                     MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, lcd_temp_menu_e3_filament_unload);
                   #if E_STEPPERS > 4
                     if (thermalManager.targetHotEnoughToExtrude(4))
                       MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
                     else
                       MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, lcd_temp_menu_e4_filament_unload);
+                    #if E_STEPPERS > 5
+                      if (thermalManager.targetHotEnoughToExtrude(5))
+                        MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E6, PSTR("M702 T5"));
+                      else
+                        MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E6, lcd_temp_menu_e5_filament_unload);
+                    #endif // E_STEPPERS > 5
                   #endif // E_STEPPERS > 4
                 #endif // E_STEPPERS > 3
               #endif // E_STEPPERS > 2
             #endif // E_STEPPERS == 1
           }
         #endif
 
         END_MENU();
       }
     #endif

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 37cdb82ba9..943edc153e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -834,21 +834,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   void lcd_completion_feedback(const bool good/*=true*/) {
     if (good) {
       lcd_buzz(100, 659);
       lcd_buzz(100, 698);
     }
     else lcd_buzz(20, 440);
   }
 
   inline void line_to_current_z() {
-    planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
+    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
   }
 
   inline void line_to_z(const float &z) {
     current_position[Z_AXIS] = z;
     line_to_current_z();
   }
 
   #if ENABLED(SDSUPPORT)
 
     void lcd_sdcard_pause() {
@@ -1885,21 +1885,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         case 3:
           current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
           break;
         #if ENABLED(LEVEL_CENTER_TOO)
           case 4:
             current_position[X_AXIS] = X_CENTER;
             current_position[Y_AXIS] = Y_CENTER;
             break;
         #endif
       }
-      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
+      planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
       line_to_z(0.0);
       if (++bed_corner > 3
         #if ENABLED(LEVEL_CENTER_TOO)
           + 1
         #endif
       ) bed_corner = 0;
     }
 
     void _lcd_corner_submenu() {
       START_MENU();
@@ -2425,21 +2425,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
       lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL LCD Map Movement
      */
     void ubl_map_move_to_xy() {
       current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
       current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
-      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
+      planner.buffer_line(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
     }
 
     /**
      * UBL LCD "radar" map
      */
     void set_current_from_steppers_for_axis(const AxisEnum axis);
     void sync_plan_position();
 
     void _lcd_do_nothing() {}
     void _lcd_hard_stop() {
@@ -2904,21 +2904,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         prepare_move_to_destination(); // will call set_current_from_destination()
         processing_manual_move = false;
 
         feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
-        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
+        planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
         manual_move_axis = (int8_t)NO_AXIS;
 
       #endif
     }
   }
 
   /**
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */
@@ -3739,30 +3739,37 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_advanced_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       #if ENABLED(JUNCTION_DEVIATION)
-        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
-      #else
+        #if ENABLED(LIN_ADVANCE)
+          MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
+        #else
+          MENU_ITEM_EDIT(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f);
+        #endif
+      #endif
+      #if HAS_CLASSIC_JERK
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
           MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
         #endif
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+        #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+        #endif
       #endif
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_advanced_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 

commit 84ed9b5a636ba21de56dfb85afdbf176d437f0df
Author: Hannes Brandstätter-Müller <hannes.mueller@gmail.com>
Date:   Sun Sep 16 03:17:35 2018 +0200

    Send "G33 S P1" for Delta Height Calibration (#11831)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3ac2515072..37cdb82ba9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2839,21 +2839,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5, 5, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5, delta_diagonal_rod + 5, _recalc_delta_settings);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
-        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
+        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 S P1"));
         MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
         #if ENABLED(EEPROM_SETTINGS)
           MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
           MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         #endif
       #endif
       MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
       #if ENABLED(DELTA_CALIBRATION_MENU)
         MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
         if (all_axes_homed()) {

commit 4f883d59712608d82d33d387d13571c8a0b7dfd4
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Tue Sep 11 04:37:32 2018 +0100

    [2.0.x] Extruder-Distinct Linear Advance K Factors (#11789)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 20d642962d..3ac2515072 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3840,21 +3840,35 @@ void lcd_quick_feedback(const bool clear_buttons) {
       // M92 - Steps Per mm
       MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
 
     #endif // !SLIM_LCD_MENUS
 
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+      #if EXTRUDERS == 1
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
+      #elif EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
+        #if EXTRUDERS > 2
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
+          #if EXTRUDERS > 3
+            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
+            #if EXTRUDERS > 4
+              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
     #endif
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
     #endif
 
     //
     // BLTouch Self-Test and Reset
     //
@@ -3875,21 +3889,35 @@ void lcd_quick_feedback(const bool clear_buttons) {
     /**
      *
      * "Advanced Settings" > "Filament" submenu
      *
      */
     void lcd_advanced_filament_menu() {
       START_MENU();
       MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       #if ENABLED(LIN_ADVANCE)
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+        #if EXTRUDERS == 1
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
+        #elif EXTRUDERS > 1
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
+          #if EXTRUDERS > 2
+            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
+            #if EXTRUDERS > 3
+              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
+              #if EXTRUDERS > 4
+                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
           #else // EXTRUDERS > 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);

commit 2ebfe90be964e321ee222c25eb4b15a392543f85
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Sep 10 01:51:46 2018 -0600

    Add custom preheat temp to filament change (#11475)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b02b9a932f..20d642962d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4323,48 +4323,66 @@ void lcd_quick_feedback(const bool clear_buttons) {
           return PSTR("M701 T%d");
         case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
           return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
         case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
         default:
           return PSTR("M600 B0 T%d");
       }
       return PSTR(MSG_FILAMENTCHANGE);
     }
 
-    void _change_filament_temp(const uint8_t index) {
+    void _change_filament_temp(const uint16_t temperature) {
       char cmd[11];
       sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
-      thermalManager.setTargetHotend(index == 1 ? PREHEAT_1_TEMP_HOTEND : PREHEAT_2_TEMP_HOTEND, _change_filament_temp_extruder);
+      thermalManager.setTargetHotend(temperature, _change_filament_temp_extruder);
       lcd_enqueue_command(cmd);
     }
-    void _lcd_change_filament_temp_1_menu() { _change_filament_temp(1); }
-    void _lcd_change_filament_temp_2_menu() { _change_filament_temp(2); }
+    void _lcd_change_filament_temp_1_menu() { _change_filament_temp(PREHEAT_1_TEMP_HOTEND); }
+    void _lcd_change_filament_temp_2_menu() { _change_filament_temp(PREHEAT_2_TEMP_HOTEND); }
+    void _lcd_change_filament_temp_custom_menu() { _change_filament_temp(thermalManager.target_temperature[_change_filament_temp_extruder]); }
 
     static const char* change_filament_header(const AdvancedPauseMode mode) {
       switch (mode) {
         case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
           return PSTR(MSG_FILAMENTLOAD);
         case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
           return PSTR(MSG_FILAMENTUNLOAD);
         default: break;
       }
       return PSTR(MSG_FILAMENTCHANGE);
     }
 
     void _lcd_temp_menu_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
       _change_filament_temp_mode = mode;
       _change_filament_temp_extruder = extruder;
       START_MENU();
       if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
       MENU_BACK(MSG_FILAMENTCHANGE);
       MENU_ITEM(submenu, MSG_PREHEAT_1, _lcd_change_filament_temp_1_menu);
       MENU_ITEM(submenu, MSG_PREHEAT_2, _lcd_change_filament_temp_2_menu);
+      uint16_t max_temp;
+      switch (extruder) {
+        default: max_temp = HEATER_0_MAXTEMP;
+        #if HOTENDS > 1
+          case 1: max_temp = HEATER_1_MAXTEMP; break;
+          #if HOTENDS > 2
+            case 2: max_temp = HEATER_2_MAXTEMP; break;
+            #if HOTENDS > 3
+              case 3: max_temp = HEATER_3_MAXTEMP; break;
+              #if HOTENDS > 4
+                case 4: max_temp = HEATER_4_MAXTEMP; break;
+              #endif
+            #endif
+          #endif
+        #endif
+      }
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PREHEAT_CUSTOM, &thermalManager.target_temperature[_change_filament_temp_extruder], EXTRUDE_MINTEMP, max_temp - 15, _lcd_change_filament_temp_custom_menu);
       END_MENU();
     }
     void lcd_temp_menu_e0_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
     void lcd_temp_menu_e0_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
     void lcd_temp_menu_e0_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
     #if E_STEPPERS > 1
       void lcd_temp_menu_e1_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
       void lcd_temp_menu_e1_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
       void lcd_temp_menu_e1_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
       #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)

commit 72af8e0f026bc3149696ee77dba8d0b26d99a7d2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 9 03:21:08 2018 -0500

    Patch extruder_advance_K edit menu
    
    Fix #11776

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a25b2d4c64..b02b9a932f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3840,21 +3840,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       // M92 - Steps Per mm
       MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
 
     #endif // !SLIM_LCD_MENUS
 
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
     #endif
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
     #endif
 
     //
     // BLTouch Self-Test and Reset
     //

commit eafd62308e90e98f16d3bf1725ba62eb1e0b2f2c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 8 20:41:21 2018 -0500

    Use TMC2208Stepper v0.2.5 (#11714)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 66bfbd958a..a25b2d4c64 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1027,23 +1027,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if ENABLED(LCD_PROGRESS_BAR_TEST)
         MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
       #endif
 
       END_MENU();
     }
 
   #endif // HAS_DEBUG_MENU
 
-   /**
-    * IDEX submenu
-    */
+  /**
+   * IDEX submenu
+   */
   #if ENABLED(DUAL_X_CARRIAGE)
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK, PSTR("M605 S1\nG28 X\nG1 X100"));
       if (!TEST(axis_known_position, Y_AXIS) || !TEST(axis_known_position, Z_AXIS))
         MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100"));  // If Y or Z is not homed, a full G28 is done first.
       else
         MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100"));       // If Y and Z is homed, a full G28 is not needed first.
       MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));

commit beb51c2d58100fa6959d7216d85294f3dbe2e1c5
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Sep 5 08:18:08 2018 -0600

    Show manual extrusion moves as relative in LCD
    
    - Implements FR#11724
    - Old behavior can be restored by commenting out MANUAL_E_MOVES_RELATIVE

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index eafa20f277..66bfbd958a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -470,20 +470,24 @@ uint16_t max_display_update_time = 0;
   // Manual Moves
   const float manual_feedrate_mm_m[] = MANUAL_FEEDRATE;
   millis_t manual_move_start_time = 0;
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   #if EXTRUDERS > 1
     int8_t manual_move_e_index = 0;
   #else
     #define manual_move_e_index 0
   #endif
 
+  #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+    float manual_move_e_origin = 0;
+  #endif
+
   #if IS_KINEMATIC
     bool processing_manual_move = false;
     float manual_move_offset = 0;
   #else
     constexpr bool processing_manual_move = false;
   #endif
 
   #if PIN_EXISTS(SD_DETECT)
     uint8_t lcd_sd_status;
   #endif
@@ -3059,20 +3063,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
                 case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
               #endif // E_MANUAL > 4
             #endif // E_MANUAL > 3
           #endif // E_MANUAL > 2
         }
       #endif // E_MANUAL > 1
       lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
+        #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+          - manual_move_e_origin
+        #endif
       ));
     }
   }
 
   void lcd_move_e() { _lcd_move_e(); }
   #if E_MANUAL > 1
     void lcd_move_e0() { _lcd_move_e(0); }
     void lcd_move_e1() { _lcd_move_e(1); }
     #if E_MANUAL > 2
       void lcd_move_e2() { _lcd_move_e(2); }
@@ -3107,21 +3114,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
     START_MENU();
     if (LCD_HEIGHT >= 4) {
       switch (axis) {
         case X_AXIS:
           STATIC_ITEM(MSG_MOVE_X, true, true); break;
         case Y_AXIS:
           STATIC_ITEM(MSG_MOVE_Y, true, true); break;
         case Z_AXIS:
           STATIC_ITEM(MSG_MOVE_Z, true, true); break;
         default:
-          STATIC_ITEM(MSG_MOVE_E, true, true); break;
+          #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+            manual_move_e_origin = current_position[E_AXIS];
+          #endif
+          STATIC_ITEM(MSG_MOVE_E, true, true);
+          break;
       }
     }
     MENU_BACK(MSG_MOVE_AXIS);
     MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
     MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
     MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
     END_MENU();
   }
   void lcd_move_get_x_amount()        { _lcd_move_distance_menu(X_AXIS, lcd_move_x); }
   void lcd_move_get_y_amount()        { _lcd_move_distance_menu(Y_AXIS, lcd_move_y); }

commit 8b837dc3ad5cdaf3e66fcbf58fc7510f545e1ec8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 3 23:23:20 2018 -0500

    No need for last \n in G-code items

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bbb16d1840..eafa20f277 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1030,26 +1030,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #endif // HAS_DEBUG_MENU
 
    /**
     * IDEX submenu
     */
   #if ENABLED(DUAL_X_CARRIAGE)
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100\n"));
+      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK, PSTR("M605 S1\nG28 X\nG1 X100"));
       if (!TEST(axis_known_position, Y_AXIS) || !TEST(axis_known_position, Z_AXIS))
-        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100\n"));  // If Y or Z is not homed, a full G28 is done first.
+        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100"));  // If Y or Z is not homed, a full G28 is done first.
       else
-        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100\n"));       // If Y and Z is homed, a full G28 is not needed first.
-      MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X\n"));
+        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100"));       // If Y and Z is homed, a full G28 is not needed first.
+      MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
       END_MENU();
     }
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)
 
     #ifdef USER_SCRIPT_DONE
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
     #else
       #define _DONE_SCRIPT ""

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f016f90364..bbb16d1840 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1033,21 +1033,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
    /**
     * IDEX submenu
     */
   #if ENABLED(DUAL_X_CARRIAGE)
     static void IDEX_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100\n"));
       if (!TEST(axis_known_position, Y_AXIS) || !TEST(axis_known_position, Z_AXIS))
         MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100\n"));  // If Y or Z is not homed, a full G28 is done first.
-      else  
+      else
         MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100\n"));       // If Y and Z is homed, a full G28 is not needed first.
       MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X\n"));
       END_MENU();
     }
   #endif // DUAL_X_CARRIAGE
 
   #if ENABLED(CUSTOM_USER_MENUS)
 
     #ifdef USER_SCRIPT_DONE
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a4c17ca1d9..f016f90364 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1023,20 +1023,37 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if ENABLED(LCD_PROGRESS_BAR_TEST)
         MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
       #endif
 
       END_MENU();
     }
 
   #endif // HAS_DEBUG_MENU
 
+   /**
+    * IDEX submenu
+    */
+  #if ENABLED(DUAL_X_CARRIAGE)
+    static void IDEX_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100\n"));
+      if (!TEST(axis_known_position, Y_AXIS) || !TEST(axis_known_position, Z_AXIS))
+        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nG28\nM605 S2 X200\nG28 X\nG1 X100\n"));  // If Y or Z is not homed, a full G28 is done first.
+      else  
+        MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, PSTR("T0\nM605 S2 X200\nG28 X\nG1 X100\n"));       // If Y and Z is homed, a full G28 is not needed first.
+      MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X\n"));
+      END_MENU();
+    }
+  #endif // DUAL_X_CARRIAGE
+
   #if ENABLED(CUSTOM_USER_MENUS)
 
     #ifdef USER_SCRIPT_DONE
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
     #else
       #define _DONE_SCRIPT ""
     #endif
 
     void _lcd_user_gcode(const char * const cmd) {
       enqueue_and_echo_commands_P(cmd);
@@ -1100,20 +1117,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #endif
 
   void lcd_main_menu() {
     START_MENU();
     MENU_BACK(MSG_WATCH);
 
     #if ENABLED(CUSTOM_USER_MENUS)
       MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
     #endif
 
+    #if ENABLED(DUAL_X_CARRIAGE)
+      MENU_ITEM(submenu, MSG_IDEX_MENU, IDEX_menu);
+    #endif
+
     //
     // Debug Menu when certain options are enabled
     //
     #if HAS_DEBUG_MENU
       MENU_ITEM(submenu, MSG_DEBUG_MENU, lcd_debug_menu);
     #endif
 
     //
     // Set Case light on/off/brightness
     //

commit 0966bdcbc424908180fb9f2d963917236ef60ac2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Aug 29 15:51:14 2018 -0600

    Reorganized ultralcd menu (10317) (#10360)
    
    Replaced "Prepare" and "Control" menus with "Movement", "Temperature", "Configuration" and "Advanced Settings"

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d33f2e1fd9..a4c17ca1d9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -174,33 +174,33 @@ uint16_t max_display_update_time = 0;
     #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
     uint8_t driverPercent[XYZE];
   #endif
 
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
-  void lcd_prepare_menu();
+  void lcd_movement_menu();
   void lcd_move_menu();
-  void lcd_control_menu();
-  void lcd_control_temperature_menu();
-  void lcd_control_motion_menu();
+  void lcd_configuration_menu();
+  void lcd_temperature_menu();
+  void lcd_advanced_settings_menu();
 
   #if DISABLED(SLIM_LCD_MENUS)
-    void lcd_control_temperature_preheat_material1_settings_menu();
-    void lcd_control_temperature_preheat_material2_settings_menu();
+    void lcd_configuration_temperature_preheat_material1_settings_menu();
+    void lcd_configuration_temperature_preheat_material2_settings_menu();
   #endif
 
   #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-    void lcd_control_filament_menu();
+    void lcd_advanced_filament_menu();
   #endif
 
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
     void lcd_info_menu();
   #endif // LCD_INFO_MENU
@@ -219,21 +219,21 @@ uint16_t max_display_update_time = 0;
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     void dac_driver_commit();
     void dac_driver_getValues();
     void lcd_dac_menu();
     void lcd_dac_write_eeprom();
   #endif
 
   #if ENABLED(FWRETRACT)
     #include "../feature/fwretract.h"
-    void lcd_control_retract_menu();
+    void lcd_config_retract_menu();
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
     #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
   #endif
 
@@ -1086,20 +1086,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
     }
 
   #endif
 
   /**
    *
    * "Main" menu
    *
    */
 
+  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+
+    void lcd_autostart_sd() { card.beginautostart(); }
+
+  #endif
+
   void lcd_main_menu() {
     START_MENU();
     MENU_BACK(MSG_WATCH);
 
     #if ENABLED(CUSTOM_USER_MENUS)
       MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
     #endif
 
     //
     // Debug Menu when certain options are enabled
@@ -1112,27 +1118,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     // Set Case light on/off/brightness
     //
     #if ENABLED(MENU_ITEM_CASE_LIGHT)
       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
         MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
       }
       else
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
     #endif
 
-    if (planner.movesplanned() || IS_SD_PRINTING)
-      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
-    else
-      MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
-
-    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
-
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
           if (card.sdprinting)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
         }
         else {
@@ -1143,48 +1142,73 @@ void lcd_quick_feedback(const bool clear_buttons) {
         }
       }
       else {
         MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
     #endif // SDSUPPORT
 
+    if (planner.movesplanned() || IS_SD_PRINTING)
+      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+    else {
+      MENU_ITEM(submenu, MSG_MOTION, lcd_movement_menu);
+      MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_temperature_menu);
+      MENU_ITEM(submenu, MSG_CONFIGURATION, lcd_configuration_menu);
+    }
+
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        if (thermalManager.targetHotEnoughToExtrude(active_extruder))
+          MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
+        else
+          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
+      #else
+        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
+      #endif
+    #endif
+
     #if ENABLED(LCD_INFO_MENU)
       MENU_ITEM(submenu, MSG_INFO_MENU, lcd_info_menu);
     #endif
 
     #if ENABLED(LED_CONTROL_MENU)
       MENU_ITEM(submenu, MSG_LED_CONTROL, lcd_led_menu);
     #endif
 
+    //
+    // Switch power on/off
+    //
+    #if HAS_POWER_SWITCH
+      if (powersupply_on)
+        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
+      else
+        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+    #endif
+
+    //
+    // Autostart
+    //
+    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+    #endif
+
     END_MENU();
   }
 
   /**
    *
    * "Tune" submenu items
    *
    */
 
-  #if HAS_M206_COMMAND
-    /**
-     * Set the home offset based on the current_position
-     */
-    void lcd_set_home_offsets() {
-      // M428 Command
-      enqueue_and_echo_commands_P(PSTR("M428"));
-      lcd_return_to_status();
-    }
-  #endif
-
   #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY) || ENABLED(MESH_EDIT_GFX_OVERLAY)
 
     void _lcd_zoffset_overlay_gfx(const float zvalue) {
       // Determine whether the user is raising or lowering the nozzle.
       static int8_t dir;
       static float old_zvalue;
       if (zvalue != old_zvalue) {
         dir = zvalue ? zvalue < old_zvalue ? -1 : 1 : 0;
         old_zvalue = zvalue;
       }
@@ -1504,34 +1528,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
         MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
       #endif
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #else
         MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
       #endif
     #endif
 
-    //
-    // Change filament
-    //
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-          MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
-        else
-          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
-      #else
-        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
-      #endif
-    #endif
-
     END_MENU();
   }
 
   /**
    *
    * "Driver current control" submenu items
    *
    */
   #if ENABLED(DAC_STEPPER_CURRENT)
 
@@ -1571,21 +1581,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
       END_MENU();
     }
 
   #endif // HAS_MOTOR_CURRENT_PWM
 
   constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
 
   /**
    *
-   * "Prepare" submenu items
+   * "Temperature" submenu items
    *
    */
   void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const int16_t fan) {
     if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
     #if HAS_HEATED_BED
       if (tempb >= 0) thermalManager.setTargetBed(tempb);
     #else
       UNUSED(tempb);
     #endif
     #if FAN_COUNT > 0
@@ -1684,21 +1694,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if HAS_HEATED_BED
     void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
   #endif
 
   #if HAS_TEMP_HOTEND || HAS_HEATED_BED
 
     void lcd_preheat_m1_menu() {
       START_MENU();
-      MENU_BACK(MSG_PREPARE);
+      MENU_BACK(MSG_TEMPERATURE);
       #if HOTENDS == 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
           MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
         #endif
       #elif HOTENDS > 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
@@ -1736,21 +1746,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
       #endif
       END_MENU();
     }
 
     void lcd_preheat_m2_menu() {
       START_MENU();
-      MENU_BACK(MSG_PREPARE);
+      MENU_BACK(MSG_TEMPERATURE);
       #if HOTENDS == 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
           MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
         #endif
       #elif HOTENDS > 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
@@ -1816,26 +1826,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     }
 
     void lcd_enqueue_commands_P(const char * const cmd) {
       no_reentry = true;
       enqueue_and_echo_commands_now_P(cmd);
       no_reentry = false;
     }
 
   #endif
 
-  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-
-    void lcd_autostart_sd() { card.beginautostart(); }
-
-  #endif
-
   #if ENABLED(EEPROM_SETTINGS)
     static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
     static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
 
     /**
      * Level corners, starting in the front-left corner.
      */
@@ -1891,21 +1895,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       bed_corner = 0;
       _lcd_goto_next_corner();
     }
 
   #endif // LEVEL_BED_CORNERS
 
   #if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
 
     /**
      *
-     * "Prepare" > "Level Bed" handlers
+     * "Motion" > "Level Bed" handlers
      *
      */
 
     static uint8_t manual_probe_index;
 
     // LCD probed points are from defaults
     constexpr uint8_t total_probe_points = (
       #if ENABLED(AUTO_BED_LEVELING_3POINT)
         3
       #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
@@ -2538,34 +2542,34 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
       MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
       MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
       MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
       END_MENU();
     }
 
     /**
      * UBL System submenu
      *
-     * << Prepare
+     * << Motion
      *  - Manually Build Mesh >>
      *  - Activate UBL >>
      *  - Deactivate UBL >>
      *  - Step-By-Step UBL >>
      *  - Mesh Storage >>
      *  - Output Map >>
      *  - UBL Tools >>
      *  - Output UBL Info >>
      */
 
     void _lcd_ubl_level_bed() {
       START_MENU();
-      MENU_BACK(MSG_PREPARE);
+      MENU_BACK(MSG_MOTION);
       MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
       MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
       MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
       MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
       MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
       MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
@@ -2578,34 +2582,34 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
     void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
   #endif
 
   #if ENABLED(LCD_BED_LEVELING)
 
     /**
      * Step 1: Bed Level entry-point
      *
-     * << Prepare
+     * << Motion
      *    Auto Home           (if homing needed)
      *    Leveling On/Off     (if data exists, and homed)
      *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
      *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
      *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
      *    Level Bed >
      *    Level Corners >     (if homed)
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
-      MENU_BACK(MSG_PREPARE);
+      MENU_BACK(MSG_MOTION);
 
       const bool is_homed = all_axes_known();
 
       // Auto Home if not using manual probing
       #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
         if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       #endif
 
       // Level Bed
       #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
@@ -2649,25 +2653,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
   #endif // LCD_BED_LEVELING
 
   /**
    *
-   * "Prepare" submenu
+   * "Movement" submenu
    *
    */
 
-  void lcd_prepare_menu() {
+  void lcd_movement_menu() {
     START_MENU();
 
     //
     // ^ Main
     //
     MENU_BACK(MSG_MAIN);
 
     //
     // Move Axis
     //
@@ -2720,106 +2724,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
       #endif
 
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (all_axes_homed())
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
-    #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
-      //
-      // Set Home Offsets
-      //
-      MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-    #endif
-
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
-    //
-    // Change filament
-    //
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      if (!IS_SD_FILE_OPEN) {
-        #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-          if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-            MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
-          else
-            MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
-        #else
-          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
-        #endif
-      }
-    #endif // ADVANCED_PAUSE_FEATURE
-
-    #if HAS_TEMP_HOTEND
-
-      //
-      // Cooldown
-      //
-      bool has_heat = false;
-      HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
-      #if HAS_HEATED_BED
-        if (thermalManager.target_temperature_bed) has_heat = true;
-      #endif
-      if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
-
-      //
-      // Preheat for Material 1 and 2
-      //
-      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
-        MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
-        MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
-      #endif
-
-    #endif // HAS_TEMP_HOTEND
-
-    //
-    // BLTouch Self-Test and Reset
-    //
-    #if ENABLED(BLTOUCH)
-      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-      if (!endstops.z_probe_enabled && TEST_BLTOUCH())
-        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-    #endif
-
-    //
-    // Switch power on/off
-    //
-    #if HAS_POWER_SWITCH
-      if (powersupply_on)
-        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
-      else
-        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
-    #endif
-
-    //
-    // Autostart
-    //
-    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
-    #endif
-
-    //
-    // Delta Calibration
-    //
-    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
-    #endif
-
     END_MENU();
   }
 
   float move_menu_scale;
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
     void lcd_move_z();
 
     void _man_probe_pt(const float &rx, const float &ry) {
@@ -2984,21 +2907,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         if (axis == E_AXIS)
       #endif
           manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
     manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
-   * "Prepare" > "Move Axis" submenu
+   * "Motion" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
 
       // Start with no limits to movement
       float min = current_position[axis] - 1000,
@@ -3136,21 +3059,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         void lcd_move_e3() { _lcd_move_e(3); }
         #if E_MANUAL > 4
           void lcd_move_e4() { _lcd_move_e(4); }
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
-   * "Prepare" > "Move Xmm" > "Move XYZ" submenu
+   * "Motion" > "Move Xmm" > "Move XYZ" submenu
    *
    */
 
   screenFunc_t _manual_move_func_ptr;
 
   void _goto_manual_move(const float scale) {
     defer_return_to_status = true;
     move_menu_scale = scale;
     lcd_goto_screen(_manual_move_func_ptr);
   }
@@ -3192,21 +3115,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3); }
         #if E_MANUAL > 4
           void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4); }
         #endif // E_MANUAL > 4
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
-   * "Prepare" > "Move Axis" submenu
+   * "Motion" > "Move Axis" submenu
    *
    */
 
   #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
     #define _MOVE_XYZ_ALLOWED (all_axes_homed())
   #else
     #define _MOVE_XYZ_ALLOWED true
   #endif
 
   #if ENABLED(DELTA)
@@ -3214,21 +3137,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void lcd_lower_z_to_clip_height() {
       line_to_z(delta_clip_start_height);
       lcd_synchronize();
     }
   #else
     #define _MOVE_XY_ALLOWED true
   #endif
 
   void lcd_move_menu() {
     START_MENU();
-    MENU_BACK(MSG_PREPARE);
+    MENU_BACK(MSG_MOTION);
 
     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
       MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
     #endif
 
     if (_MOVE_XYZ_ALLOWED) {
       if (_MOVE_XY_ALLOWED) {
         MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
         MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
       }
@@ -3303,21 +3226,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_MANUAL > 2
       #endif // E_MANUAL > 1
 
     #endif
 
     END_MENU();
   }
 
   /**
    *
-   * "Control" submenu
+   * "Configuration" submenu
    *
    */
 
   #if HAS_LCD_CONTRAST
     void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
   #endif
 
   static void lcd_factory_settings() {
     settings.reset();
     lcd_completion_feedback();
@@ -3325,67 +3248,70 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
 
     static void lcd_init_eeprom() {
       lcd_completion_feedback(settings.init_eeprom());
       lcd_goto_previous_menu();
     }
 
     static void lcd_init_eeprom_confirm() {
       START_MENU();
-      MENU_BACK(MSG_CONTROL);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
       MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
       END_MENU();
     }
 
   #endif
 
-  void lcd_control_menu() {
+  void lcd_configuration_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
-    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
-    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
-    #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
-    #elif ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+    MENU_ITEM(submenu, MSG_ADVANCED_SETTINGS, lcd_advanced_settings_menu);
+
+    //
+    // Delta Calibration
+    //
+    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
     #endif
 
     #if HAS_LCD_CONTRAST
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
-      MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
+      MENU_ITEM(submenu, MSG_RETRACT, lcd_config_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif
 
     #if ENABLED(BLTOUCH)
       MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
     #endif
 
+    #if DISABLED(SLIM_LCD_MENUS)
+      // Preheat configurations
+      MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_configuration_temperature_preheat_material1_settings_menu);
+      MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_configuration_temperature_preheat_material2_settings_menu);
+    #endif
+
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif
 
     MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
 
-    #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
-      MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
-    #endif
-
     END_MENU();
   }
 
   /**
    *
    * "Temperature" submenu
    *
    */
 
   #if ENABLED(PID_AUTOTUNE_MENU)
@@ -3457,30 +3383,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
     #endif // PID_PARAMS_PER_HOTEND
 
   #endif // PIDTEMP
 
   /**
    *
-   * "Control" > "Temperature" submenu
+   * "Temperature" submenu
    *
    */
-  void lcd_control_temperature_menu() {
+  void lcd_temperature_menu() {
     START_MENU();
-
-    //
-    // ^ Control
-    //
-    MENU_BACK(MSG_CONTROL);
+    MENU_BACK(MSG_MAIN);
 
     //
     // Nozzle:
     // Nozzle [1-5]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
@@ -3519,20 +3441,56 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif
       #endif
       #if HAS_FAN2
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
           MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
+    #if HAS_TEMP_HOTEND
+
+      //
+      // Cooldown
+      //
+      bool has_heat = false;
+      HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
+      #if HAS_TEMP_BED
+        if (thermalManager.target_temperature_bed) has_heat = true;
+      #endif
+      if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+
+      //
+      // Preheat for Material 1 and 2
+      //
+      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
+        MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
+        MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
+      #endif
+
+    #endif // HAS_TEMP_HOTEND
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Advanced Settings" -> "Temperature" submenu
+   *
+   */
+  void lcd_advanced_temperature_menu() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
     //
     // Autotemp, Min, Max, Fact
     //
     #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
       MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, float(HEATER_0_MAXTEMP) - 15);
       MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, float(HEATER_0_MAXTEMP) - 15);
       MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0, 1);
     #endif
 
@@ -3580,82 +3538,70 @@ void lcd_quick_feedback(const bool clear_buttons) {
               PID_MENU_ITEMS(" " MSG_E5, 4);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
         PID_MENU_ITEMS("", 0);
       #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
 
     #endif // PIDTEMP
 
-    #if DISABLED(SLIM_LCD_MENUS)
-      //
-      // Preheat Material 1 conf
-      //
-      MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_control_temperature_preheat_material1_settings_menu);
-
-      //
-      // Preheat Material 2 conf
-      //
-      MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
-    #endif
-
     END_MENU();
   }
 
   #if DISABLED(SLIM_LCD_MENUS)
 
-    void _lcd_control_temperature_preheat_settings_menu(const uint8_t material) {
+    void _lcd_configuration_temperature_preheat_settings_menu(const uint8_t material) {
       #if HOTENDS > 4
         #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
         #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
       #elif HOTENDS > 3
         #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
         #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
       #elif HOTENDS > 2
         #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
         #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
         #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
         #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
       #else
         #define MINTEMP_ALL HEATER_0_MINTEMP
         #define MAXTEMP_ALL HEATER_0_MAXTEMP
       #endif
       START_MENU();
-      MENU_BACK(MSG_TEMPERATURE);
+      MENU_BACK(MSG_CONFIGURATION);
       MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
       #if HAS_TEMP_HOTEND
         MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
       #endif
       #if HAS_HEATED_BED
         MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
     /**
      *
      * "Temperature" > "Preheat Material 1 conf" submenu
      *
      */
-    void lcd_control_temperature_preheat_material1_settings_menu() { _lcd_control_temperature_preheat_settings_menu(0); }
+    void lcd_configuration_temperature_preheat_material1_settings_menu() { _lcd_configuration_temperature_preheat_settings_menu(0); }
 
     /**
      *
      * "Temperature" > "Preheat Material 2 conf" submenu
      *
      */
-    void lcd_control_temperature_preheat_material2_settings_menu() { _lcd_control_temperature_preheat_settings_menu(1); }
+    void lcd_configuration_temperature_preheat_material2_settings_menu() { _lcd_configuration_temperature_preheat_settings_menu(1); }
 
     void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
     #if ENABLED(DISTINCT_E_FACTORS)
       void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
       void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
       void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
       #if E_STEPPERS > 2
         void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
         #if E_STEPPERS > 3
           void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
@@ -3681,23 +3627,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #if E_STEPPERS > 3
           void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
           #if E_STEPPERS > 4
             void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
           #endif // E_STEPPERS > 4
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     // M203 / M205 Velocity options
-    void lcd_control_motion_velocity_menu() {
+    void lcd_advanced_velocity_menu() {
       START_MENU();
-      MENU_BACK(MSG_MOTION);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       // M203 Max Feedrate
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.max_feedrate_mm_s[A_AXIS], 1, 999);
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.max_feedrate_mm_s[B_AXIS], 1, 999);
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.max_feedrate_mm_s[C_AXIS], 1, 999);
 
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
@@ -3717,23 +3663,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       // M205 S Min Feedrate
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
 
       // M205 T Min Travel Feedrate
       MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
 
       END_MENU();
     }
 
     // M201 / M204 Accelerations
-    void lcd_control_motion_acceleration_menu() {
+    void lcd_advanced_acceleration_menu() {
       START_MENU();
-      MENU_BACK(MSG_MOTION);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       // M204 P Acceleration
       MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
 
       // M204 R Retract Acceleration
       MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
 
       // M204 T Travel Acceleration
       MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
 
@@ -3756,44 +3702,44 @@ void lcd_quick_feedback(const bool clear_buttons) {
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
       #endif
 
       END_MENU();
     }
 
     // M205 Jerk
-    void lcd_control_motion_jerk_menu() {
+    void lcd_advanced_jerk_menu() {
       START_MENU();
-      MENU_BACK(MSG_MOTION);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       #if ENABLED(JUNCTION_DEVIATION)
         MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
       #else
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
           MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
         #endif
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
       #endif
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
-    void lcd_control_motion_steps_per_mm_menu() {
+    void lcd_advanced_steps_per_mm_menu() {
       START_MENU();
-      MENU_BACK(MSG_MOTION);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
 
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
         #if E_STEPPERS > 2
@@ -3809,67 +3755,106 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
       #endif
 
       END_MENU();
     }
 
   #endif // !SLIM_LCD_MENUS
 
   /**
    *
-   * "Control" > "Motion" submenu
+   * "Advanced Settings" submenu
    *
    */
 
-  void lcd_control_motion_menu() {
+  #if HAS_M206_COMMAND
+    /**
+     * Set the home offset based on the current_position
+     */
+    void lcd_set_home_offsets() {
+      // M428 Command
+      enqueue_and_echo_commands_P(PSTR("M428"));
+      lcd_return_to_status();
+    }
+  #endif
+
+  void lcd_advanced_settings_menu() {
     START_MENU();
-    MENU_BACK(MSG_CONTROL);
+    MENU_BACK(MSG_CONFIGURATION);
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
     #elif HAS_BED_PROBE
       MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
 
     #if DISABLED(SLIM_LCD_MENUS)
 
+      #if HAS_M206_COMMAND
+        //
+        // Set Home Offsets
+        //
+        MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
+      #endif
+
       // M203 / M205 - Feedrate items
-      MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
+      MENU_ITEM(submenu, MSG_VELOCITY, lcd_advanced_velocity_menu);
 
       // M201 - Acceleration items
-      MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
+      MENU_ITEM(submenu, MSG_ACCELERATION, lcd_advanced_acceleration_menu);
 
       // M205 - Max Jerk
-      MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);
+      MENU_ITEM(submenu, MSG_JERK, lcd_advanced_jerk_menu);
 
       // M92 - Steps Per mm
-      MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
+      MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_advanced_steps_per_mm_menu);
 
     #endif // !SLIM_LCD_MENUS
 
+    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_advanced_temperature_menu);
+
+    #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
+      MENU_ITEM(submenu, MSG_FILAMENT, lcd_advanced_filament_menu);
+    #elif ENABLED(LIN_ADVANCE)
+      MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+    #endif
+
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
     #endif
 
+    //
+    // BLTouch Self-Test and Reset
+    //
+    #if ENABLED(BLTOUCH)
+      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+      if (!endstops.z_probe_enabled && TEST_BLTOUCH())
+        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+    #endif
+
+    #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
+      MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
+    #endif
+
     END_MENU();
   }
 
   #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
     /**
      *
-     * "Control" > "Filament" submenu
+     * "Advanced Settings" > "Filament" submenu
      *
      */
-    void lcd_control_filament_menu() {
+    void lcd_advanced_filament_menu() {
       START_MENU();
-      MENU_BACK(MSG_CONTROL);
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
 
       #if ENABLED(LIN_ADVANCE)
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
@@ -3934,26 +3919,26 @@ void lcd_quick_feedback(const bool clear_buttons) {
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       #endif
 
       END_MENU();
     }
   #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
 
   /**
    *
-   * "Control" > "Retract" submenu
+   * "Configuration" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
-    void lcd_control_retract_menu() {
+    void lcd_config_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
       MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
@@ -4371,21 +4356,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif // E_STEPPERS > 1
 
     /**
      *
      * "Change Filament" submenu
      *
      */
     #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       void lcd_change_filament_menu() {
         START_MENU();
-        MENU_BACK(MSG_PREPARE);
+        MENU_BACK(MSG_MAIN);
 
         // Change filament
         #if E_STEPPERS == 1
           PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
           if (thermalManager.targetTooColdToExtrude(active_extruder))
             MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
           else
             MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
         #else
           PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);

commit acf5ae3083fd1c5c0a8e14703867b676dc56908c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 16:35:55 2018 -0500

    !ENABLED => DISABLED

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ee38000860..d33f2e1fd9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1508,21 +1508,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #else
         MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
       #endif
     #endif
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
         if (thermalManager.targetHotEnoughToExtrude(active_extruder))
           MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
         else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
       #else
         MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
       #endif
     #endif
 
     END_MENU();
@@ -2737,21 +2737,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (!IS_SD_FILE_OPEN) {
-        #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
           if (thermalManager.targetHotEnoughToExtrude(active_extruder))
             MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
           else
             MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
         #else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
         #endif
       }
     #endif // ADVANCED_PAUSE_FEATURE
 

commit c2553f9888e1fa7e23f0e3da26e289eb2d51e473
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Aug 15 14:26:11 2018 -0400

    2.0.x - Idex match119 (#11556)
    
    * Update ubl_G29.cpp
    
    * Update ultralcd.cpp

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9a46995477..ee38000860 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2930,21 +2930,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
 
       #if IS_KINEMATIC
 
         const float old_feedrate = feedrate_mm_s;
         feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
 
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
-          active_extruder = manual_move_e_index;
+          if (manual_move_axis == E_AXIS) active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
         set_destination_from_current();
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
         manual_move_offset = 0;
         manual_move_axis = (int8_t)NO_AXIS;
 
@@ -2956,21 +2956,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         prepare_move_to_destination(); // will call set_current_from_destination()
         processing_manual_move = false;
 
         feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
-        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
+        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_axis == E_AXIS ? manual_move_e_index : active_extruder);
         manual_move_axis = (int8_t)NO_AXIS;
 
       #endif
     }
   }
 
   /**
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */

commit f891416e701ccd9e6153c20d55ac9407a0fcf017
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Aug 7 13:51:36 2018 -0500

    No raise on G28 after power-loss

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 64610e044b..9a46995477 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -879,21 +879,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if ENABLED(POWER_LOSS_RECOVERY)
 
     static void lcd_power_loss_recovery_resume() {
       char cmd[20];
 
       // Return to status now
       lcd_return_to_status();
 
       // Turn leveling off and home
-      enqueue_and_echo_commands_P(PSTR("M420 S0\nG28"
+      enqueue_and_echo_commands_P(PSTR("M420 S0\nG28 R0"
         #if ENABLED(MARLIN_DEV_MODE)
           " S"
         #elif !IS_KINEMATIC
           " X Y"
         #endif
       ));
 
       #if HAS_HEATED_BED
         const int16_t bt = job_recovery_info.target_temperature_bed;
         if (bt) {

commit aadcf0891306bfef9f085390931095466a82a6e6
Author: MikeLud <36526272+MikeLud@users.noreply.github.com>
Date:   Thu Jul 26 06:09:49 2018 -0400

    [2.0.x] add Calibrate Z (M915) to Prepare Menu (#11331)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 77ab6749ed..64610e044b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2679,20 +2679,27 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     // Auto Home
     //
     MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
     #endif
 
+    //
+    // TMC Z Calibration
+    //
+    #if ENABLED(TMC_Z_CALIBRATION)
+      MENU_ITEM(gcode, MSG_TMC_Z_CALIBRATION, PSTR("G28\nM915"));
+    #endif
+
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
       MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
 
     #elif ENABLED(LCD_BED_LEVELING)
 
       #if ENABLED(PROBE_MANUALLY)

commit 065e9c3d66bd533694664120398e7419de3bd853
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 13 01:44:27 2018 -0500

    Add card.longest_filename method

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 78b870c5d0..77ab6749ed 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -270,22 +270,22 @@ uint16_t max_display_update_time = 0;
   DECLARE_MENU_EDIT_TYPE(float, float51);
   DECLARE_MENU_EDIT_TYPE(float, float52sign);
   DECLARE_MENU_EDIT_TYPE(float, float62);
   DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
 
   #if ENABLED(SDSUPPORT)
     void lcd_sdcard_menu();
-    void menu_action_sdfile(const char* filename, char* longFilename);
-    void menu_action_sddirectory(const char* filename, char* longFilename);
+    void menu_action_sdfile(CardReader &theCard);
+    void menu_action_sddirectory(CardReader &theCard);
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Macros ////////////
   ////////////////////////////////////////////
 
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
    *
    *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)
@@ -761,21 +761,21 @@ void lcd_status_screen() {
  */
 void lcd_reset_status() {
   static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
   static const char printing[] PROGMEM = MSG_PRINTING;
   static const char welcome[] PROGMEM = WELCOME_MSG;
   const char *msg;
   if (print_job_timer.isPaused())
     msg = paused;
   #if ENABLED(SDSUPPORT)
     else if (card.sdprinting)
-      return lcd_setstatus(card.longFilename[0] ? card.longFilename : card.filename, true);
+      return lcd_setstatus(card.longest_filename(), true);
   #endif
   else if (print_job_timer.isRunning())
     msg = printing;
   else
     msg = welcome;
 
   lcd_setstatusPGM(msg, -1);
 }
 
 /**
@@ -995,23 +995,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
       static int8_t bar_percent = 0;
       if (use_click()) {
         lcd_goto_previous_menu();
         lcd_set_custom_characters(CHARSET_MENU);
         return;
       }
       bar_percent += (int8_t)encoderPosition;
       bar_percent = constrain(bar_percent, 0, 100);
       encoderPosition = 0;
       lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
-      lcd.setCursor((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
-      lcd.print(itostr3(bar_percent)); lcd.write('%');
-      lcd.setCursor(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
+      lcd_moveto((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
+      lcd_put_u8str(int(bar_percent)); lcd_put_wchar('%');
+      lcd_moveto(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
     }
 
     void _progress_bar_test() {
       lcd_goto_screen(progress_bar_test);
       lcd_set_custom_characters();
     }
 
   #endif // LCD_PROGRESS_BAR_TEST
 
   #if HAS_DEBUG_MENU
@@ -2931,21 +2931,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
           active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
         set_destination_from_current();
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
-        manual_move_offset = 0.0;
+        manual_move_offset = 0;
         manual_move_axis = (int8_t)NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
         // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
         // processing_manual_move is true or the planner will get out of sync.
         processing_manual_move = true;
         prepare_move_to_destination(); // will call set_current_from_destination()
         processing_manual_move = false;
 
@@ -4035,23 +4035,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
             #endif
           i;
 
           #if ENABLED(SDCARD_SORT_ALPHA)
             card.getfilename_sorted(nr);
           #else
             card.getfilename(nr);
           #endif
 
           if (card.filenameIsDir)
-            MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+            MENU_ITEM(sddirectory, MSG_CARD_MENU, card);
           else
-            MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+            MENU_ITEM(sdfile, MSG_CARD_MENU, card);
         }
         else {
           MENU_ITEM_DUMMY();
         }
       }
       END_MENU();
     }
 
   #endif // SDSUPPORT
 
@@ -4958,33 +4958,31 @@ void lcd_quick_feedback(const bool clear_buttons) {
    * Menu actions
    *
    */
   void _menu_action_back() { lcd_goto_previous_menu(); }
   void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
   void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
   void menu_action_function(screenFunc_t func) { (*func)(); }
 
   #if ENABLED(SDSUPPORT)
 
-    void menu_action_sdfile(const char* filename, char* longFilename) {
+    void menu_action_sdfile(CardReader &theCard) {
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
         last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
       #endif
-      UNUSED(longFilename);
-      card.openAndPrintFile(filename);
+      card.openAndPrintFile(theCard.filename);
       lcd_return_to_status();
       lcd_reset_status();
     }
 
-    void menu_action_sddirectory(const char* filename, char* longFilename) {
-      UNUSED(longFilename);
-      card.chdir(filename);
+    void menu_action_sddirectory(CardReader &theCard) {
+      card.chdir(theCard.filename);
       encoderTopLine = 0;
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
       #if ENABLED(DOGLCD)
         drawing_screen = false;
       #endif
       lcd_refresh();
     }
 
   #endif // SDSUPPORT

commit 603e136e87e3b26177eff8d24d5df776c055fcb6
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Jul 8 14:41:38 2018 -0500

    Resolve issue where user can't edit UBL's mesh

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ec4604d025..78b870c5d0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2418,23 +2418,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
       currentScreen = _lcd_do_nothing;
       planner.quick_stop();
       currentScreen = old_screen;
       set_current_from_steppers_for_axis(ALL_AXES);
       sync_plan_position();
     }
 
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
-      if (!all_axes_known())
-        return lcd_goto_screen(_lcd_ubl_map_homing);
-
       if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
         if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7599e5f7f0..ec4604d025 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -472,21 +472,21 @@ uint16_t max_display_update_time = 0;
   millis_t manual_move_start_time = 0;
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   #if EXTRUDERS > 1
     int8_t manual_move_e_index = 0;
   #else
     #define manual_move_e_index 0
   #endif
 
   #if IS_KINEMATIC
     bool processing_manual_move = false;
-    float manual_move_offset = 0.0;
+    float manual_move_offset = 0;
   #else
     constexpr bool processing_manual_move = false;
   #endif
 
   #if PIN_EXISTS(SD_DETECT)
     uint8_t lcd_sd_status;
   #endif
 
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
@@ -1278,27 +1278,27 @@ void lcd_quick_feedback(const bool clear_buttons) {
     float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
                                                   // separate value that doesn't lose precision.
     static int16_t ubl_encoderPosition = 0;
 
     static void _lcd_mesh_fine_tune(const char* msg) {
       defer_return_to_status = true;
       if (ubl.encoder_diff) {
         ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
         ubl.encoder_diff = 0;
 
-        mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005 / 2.0;
+        mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005f * 0.5f;
         mesh_edit_value = mesh_edit_accumulator;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
 
-        const int32_t rounded = (int32_t)(mesh_edit_value * 1000.0);
-        mesh_edit_value = float(rounded - (rounded % 5L)) / 1000.0;
+        const int32_t rounded = (int32_t)(mesh_edit_value * 1000);
+        mesh_edit_value = float(rounded - (rounded % 5L)) / 1000;
       }
 
       if (lcdDrawUpdate) {
         lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
         #if ENABLED(MESH_EDIT_GFX_OVERLAY)
           _lcd_zoffset_overlay_gfx(mesh_edit_value);
         #endif
       }
     }
 
@@ -1412,21 +1412,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     // Manual bed leveling, Bed Z:
     //
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
 
     //
     // Leveling Fade Height
     //
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(SLIM_LCD_MENUS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
     #endif
 
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
@@ -1971,31 +1971,31 @@ void lcd_quick_feedback(const bool clear_buttons) {
           _lcd_level_goto_next_point();
 
         return;
       }
 
       //
       // Encoder knob or keypad buttons adjust the Z position
       //
       if (encoderPosition) {
         const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
-        line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5));
+        line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
         encoderPosition = 0;
       }
 
       //
       // Draw on first display, then only on Z change
       //
       if (lcdDrawUpdate) {
         const float v = current_position[Z_AXIS];
-        lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001 : 0.0001), '+'));
+        lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
       }
     }
 
     /**
      * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
      */
     void _lcd_level_bed_moving() {
       if (lcdDrawUpdate) {
         char msg[10];
         sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
@@ -2564,21 +2564,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_BACK(MSG_PREPARE);
       MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
       MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
       MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
       MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
       MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
       MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
       #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
 
   #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
     void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
   #endif
@@ -2620,21 +2620,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       // Homed and leveling is valid? Then leveling can be toggled.
       if (is_homed && leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
 
       // Z Fade Height
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -2706,21 +2706,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
 
       #if DISABLED(PROBE_MANUALLY)
         MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
       #endif
       if (leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0, 100, _lcd_set_z_fade_height);
       #endif
 
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (all_axes_homed())
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
@@ -2870,29 +2870,29 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void _recalc_delta_settings() {
       #if HAS_LEVELING
         reset_bed_level(); // After changing kinematics bed-level data is no longer valid
       #endif
       recalc_delta_settings();
     }
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10, delta_height + 10, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5, delta_radius + 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5, 5, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5, delta_diagonal_rod + 5, _recalc_delta_settings);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
         MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
@@ -2974,21 +2974,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #if E_MANUAL > 1
       , const int8_t eindex=-1
     #endif
   ) {
     #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
       #if E_MANUAL > 1
         if (axis == E_AXIS)
       #endif
           manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
-    manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
+    manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
@@ -3058,21 +3058,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       manual_move_to_current(axis);
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     encoderPosition = 0;
     if (lcdDrawUpdate) {
       const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
       , axis);
-      lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
+      lcd_implementation_drawedit(name, move_menu_scale >= 0.1f ? ftostr41sign(pos) : ftostr43sign(pos));
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       const int8_t eindex=-1
     #endif
   ) {
@@ -3143,23 +3143,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    */
 
   screenFunc_t _manual_move_func_ptr;
 
   void _goto_manual_move(const float scale) {
     defer_return_to_status = true;
     move_menu_scale = scale;
     lcd_goto_screen(_manual_move_func_ptr);
   }
-  void lcd_move_menu_10mm() { _goto_manual_move(10.0); }
-  void lcd_move_menu_1mm()  { _goto_manual_move( 1.0); }
-  void lcd_move_menu_01mm() { _goto_manual_move( 0.1); }
+  void lcd_move_menu_10mm() { _goto_manual_move(10); }
+  void lcd_move_menu_1mm()  { _goto_manual_move( 1); }
+  void lcd_move_menu_01mm() { _goto_manual_move( 0.1f); }
 
   void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func) {
     _manual_move_func_ptr = func;
     START_MENU();
     if (LCD_HEIGHT >= 4) {
       switch (axis) {
         case X_AXIS:
           STATIC_ITEM(MSG_MOVE_X, true, true); break;
         case Y_AXIS:
           STATIC_ITEM(MSG_MOVE_Y, true, true); break;
@@ -3520,40 +3520,40 @@ void lcd_quick_feedback(const bool clear_buttons) {
           MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Autotemp, Min, Max, Fact
     //
     #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
-      MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
-      MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
-      MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
+      MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, float(HEATER_0_MAXTEMP) - 15);
+      MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, float(HEATER_0_MAXTEMP) - 15);
+      MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0, 1);
     #endif
 
     //
     // PID-P, PID-I, PID-D, PID-C, PID Autotune
     // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
     // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
     // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
     // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
     // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
     //
     #if ENABLED(PIDTEMP)
 
       #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
         raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
         raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
         MENU_ITEM_EDIT(float52sign, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
-        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
+        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01f, 9990, copy_and_scalePID_i_E ## eindex); \
         MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
 
       #if ENABLED(PID_EXTRUSION_SCALING)
         #define _PID_MENU_ITEMS(ELABEL, eindex) \
           _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
           MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
       #else
         #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
       #endif
 
@@ -3661,21 +3661,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     void _planner_refresh_positioning() { planner.refresh_positioning(); }
     #if ENABLED(DISTINCT_E_FACTORS)
       void _planner_refresh_e_positioning(const uint8_t e) {
         if (e == active_extruder)
           _planner_refresh_positioning();
         else
-          planner.steps_to_mm[E_AXIS + e] = 1.0 / planner.axis_steps_per_mm[E_AXIS + e];
+          planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.axis_steps_per_mm[E_AXIS + e];
       }
       void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
       void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
       #if E_STEPPERS > 2
         void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
         #if E_STEPPERS > 3
           void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
           #if E_STEPPERS > 4
             void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
           #endif // E_STEPPERS > 4
@@ -3757,28 +3757,28 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       #if ENABLED(JUNCTION_DEVIATION)
-        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3, planner.recalculate_max_e_jerk);
+        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
       #else
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
-          MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
+          MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
         #endif
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
       #endif
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
@@ -3862,76 +3862,76 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if ENABLED(LIN_ADVANCE)
         MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
           #else // EXTRUDERS > 1
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
             #if EXTRUDERS > 2
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
             #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
               #if EXTRUDERS > 4
-                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
           #endif // EXTRUDERS > 1
         }
       #endif
 
       #if ENABLED(ADVANCED_PAUSE_FEATURE)
         const float extrude_maxlength =
           #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
             EXTRUDE_MAXLENGTH
           #else
-            999.0f
+            999
           #endif
         ;
 
         #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0, extrude_maxlength);
         #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0.0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0.0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0, extrude_maxlength);
           #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0.0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0, extrude_maxlength);
           #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0.0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0, extrude_maxlength);
             #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0.0, extrude_maxlength);
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0, extrude_maxlength);
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
 
         #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0, extrude_maxlength);
         #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0.0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0.0, extrude_maxlength);
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0, extrude_maxlength);
           #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0.0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0, extrude_maxlength);
           #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0.0, extrude_maxlength);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0, extrude_maxlength);
             #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0.0, extrude_maxlength);
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0, extrude_maxlength);
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       #endif
 
       END_MENU();
     }
   #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
 
@@ -4817,23 +4817,23 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    * ...which calls:
    *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    */
   #define DEFINE_MENU_EDIT_TYPE(_type, _name, _strFunc, _scale) \
     bool _menu_edit_ ## _name() { \
       ENCODER_DIRECTION_NORMAL(); \
       if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
       if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale))); \
+        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale))); \
       if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
-        _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale); \
+        _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0f / _scale); \
         if (editValue != NULL) *((_type*)editValue) = value; \
         if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
         if (lcd_clicked) lcd_goto_previous_menu(); \
       } \
       return use_click(); \
     } \
     void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
       lcd_save_previous_screen(); \
       lcd_refresh(); \
@@ -4850,28 +4850,28 @@ void lcd_quick_feedback(const bool clear_buttons) {
       callbackFunc = callback; \
       liveEdit = live; \
     } \
     FORCE_INLINE void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
       menu_action_setting_edit_callback_ ## _name(pstr, ptr, minValue, maxValue); \
     } \
     typedef void _name##_void
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
-  DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
-  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100.0);
-  DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
-  DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
-  DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
-  DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100.0);
-  DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
-  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01);
+  DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
+  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
+  DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
+  DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
+  DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10);
+  DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100);
+  DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100);
+  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01f);
 
   /**
    *
    * Handlers for Keypad input
    *
    */
   #if ENABLED(ADC_KEYPAD)
 
     inline bool handle_adc_keypad() {
       #define ADC_MIN_KEY_DELAY 100
@@ -5221,21 +5221,21 @@ void lcd_update() {
           int32_t encoderMultiplier = 1;
 
           #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
             if (encoderRateMultiplierEnabled) {
               int32_t encoderMovementSteps = ABS(encoderDiff) / ENCODER_PULSES_PER_STEP;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
-                float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000.0;
+                float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
                   SERIAL_ECHO_START();
                   SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
                   SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
                   SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
                   SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);

commit 1a0f4dedad5a564800520418ec01448982b9b023
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 2 23:21:28 2018 -0500

    Fix and improve POWER_LOSS_RECOVERY (#11187)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index df03380537..7599e5f7f0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -866,77 +866,93 @@ void lcd_quick_feedback(const bool clear_buttons) {
       lcd_reset_status();
     }
 
     bool abort_sd_printing; // =false
 
     void lcd_sdcard_stop() {
       wait_for_heatup = wait_for_user = false;
       abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
-
-      #if ENABLED(POWER_LOSS_RECOVERY)
-        card.removeJobRecoveryFile();
-      #endif
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(POWER_LOSS_RECOVERY)
 
-    static void lcd_sdcard_recover_job() {
+    static void lcd_power_loss_recovery_resume() {
       char cmd[20];
 
       // Return to status now
       lcd_return_to_status();
 
       // Turn leveling off and home
       enqueue_and_echo_commands_P(PSTR("M420 S0\nG28"
-        #if !IS_KINEMATIC
+        #if ENABLED(MARLIN_DEV_MODE)
+          " S"
+        #elif !IS_KINEMATIC
           " X Y"
         #endif
       ));
 
       #if HAS_HEATED_BED
-        // Restore the bed temperature
-        sprintf_P(cmd, PSTR("M190 S%i"), job_recovery_info.target_temperature_bed);
-        enqueue_and_echo_command(cmd);
+        const int16_t bt = job_recovery_info.target_temperature_bed;
+        if (bt) {
+          // Restore the bed temperature
+          sprintf_P(cmd, PSTR("M190 S%i"), bt);
+          enqueue_and_echo_command(cmd);
+        }
       #endif
 
       // Restore all hotend temperatures
       HOTEND_LOOP() {
-        sprintf_P(cmd, PSTR("M109 S%i"), job_recovery_info.target_temperature[e]);
-        enqueue_and_echo_command(cmd);
+        const int16_t et = job_recovery_info.target_temperature[e];
+        if (et) {
+          #if HOTENDS > 1
+            sprintf_P(cmd, PSTR("T%i"), e);
+            enqueue_and_echo_command(cmd);
+          #endif
+          sprintf_P(cmd, PSTR("M109 S%i"), et);
+          enqueue_and_echo_command(cmd);
+        }
       }
 
+      #if HOTENDS > 1
+        sprintf_P(cmd, PSTR("T%i"), job_recovery_info.active_hotend);
+        enqueue_and_echo_command(cmd);
+      #endif
+
       // Restore print cooling fan speeds
       for (uint8_t i = 0; i < FAN_COUNT; i++) {
-        sprintf_P(cmd, PSTR("M106 P%i S%i"), i, job_recovery_info.fanSpeeds[i]);
-        enqueue_and_echo_command(cmd);
+        int16_t f = job_recovery_info.fanSpeeds[i];
+        if (f) {
+          sprintf_P(cmd, PSTR("M106 P%i S%i"), i, f);
+          enqueue_and_echo_command(cmd);
+        }
       }
 
       // Start draining the job recovery command queue
       job_recovery_phase = JOB_RECOVERY_YES;
+    }
 
-      // Resume the print job timer
-      if (job_recovery_info.print_job_elapsed)
-        print_job_timer.resume(job_recovery_info.print_job_elapsed);
-
-      // Start getting commands from SD
-      card.startFileprint();
+    static void lcd_power_loss_recovery_cancel() {
+      card.removeJobRecoveryFile();
+      card.autostart_index = 0;
+      lcd_return_to_status();
     }
 
     static void lcd_job_recovery_menu() {
       defer_return_to_status = true;
       START_MENU();
-      MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_recover_job);
-      MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+      STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
+      MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
+      MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
       END_MENU();
     }
 
   #endif // POWER_LOSS_RECOVERY
 
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {

commit fbf1c9b4961dde2ee64dfede3857170766bbf5bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 29 22:41:02 2018 -0500

    Fix and tweak POWER_LOSS_RECOVERY (#11151)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f87587a656..df03380537 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -868,25 +868,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     bool abort_sd_printing; // =false
 
     void lcd_sdcard_stop() {
       wait_for_heatup = wait_for_user = false;
       abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
 
       #if ENABLED(POWER_LOSS_RECOVERY)
-        card.openJobRecoveryFile(false);
-        job_recovery_info.valid_head = job_recovery_info.valid_foot = 0;
-        (void)card.saveJobRecoveryInfo();
-        card.closeJobRecoveryFile();
-        job_recovery_commands_count = 0;
+        card.removeJobRecoveryFile();
       #endif
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(POWER_LOSS_RECOVERY)
 
     static void lcd_sdcard_recover_job() {
       char cmd[20];
 

commit 3349eb002010f64760124517eb8dd137ea5f7699
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 29 19:23:03 2018 -0500

    Fix SKEW_CORRECTION compile error

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 590e52410b..f87587a656 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2560,21 +2560,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
 
-  #if ENABLED(LCD_BED_LEVELING) || (PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS))
+  #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
     void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
   #endif
 
   #if ENABLED(LCD_BED_LEVELING)
 
     /**
      * Step 1: Bed Level entry-point
      *
      * << Prepare
      *    Auto Home           (if homing needed)
@@ -2684,21 +2684,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
 
     #elif ENABLED(LCD_BED_LEVELING)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
           MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling);
 
-    #elif PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS)
+    #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
 
       #if DISABLED(PROBE_MANUALLY)
         MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
       #endif
       if (leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);

commit 3b3029c4bfd785c19f791493fbea68fe312abf9a
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 27 03:38:31 2018 +0100

    Make max_e_jerk an array to reduce CPU usage (#11118)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 45a0b44b4b..590e52410b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3745,21 +3745,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       #if ENABLED(JUNCTION_DEVIATION)
-        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3, planner.recalculate_max_e_jerk_factor);
+        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3, planner.recalculate_max_e_jerk);
       #else
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
           MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
         #endif
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
       #endif

commit 383129728a712324445c4354961a37de42610310
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 21 11:52:29 2018 -0400

    Edit Z fade as whole numbers

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e936bd95f6..45a0b44b4b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1400,21 +1400,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     // Manual bed leveling, Bed Z:
     //
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
 
     //
     // Leveling Fade Height
     //
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(SLIM_LCD_MENUS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
     #endif
 
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
@@ -2552,21 +2552,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_BACK(MSG_PREPARE);
       MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
       MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
       MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
       MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
       MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
       MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
 
   #if ENABLED(LCD_BED_LEVELING) || (PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS))
     void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
   #endif
@@ -2608,21 +2608,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       // Homed and leveling is valid? Then leveling can be toggled.
       if (is_homed && leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
 
       // Z Fade Height
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -2694,21 +2694,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #elif PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS)
 
       #if DISABLED(PROBE_MANUALLY)
         MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
       #endif
       if (leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (all_axes_homed())
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)

commit 1239e8eda2edbfb0e78179424c6546f98ec97182
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 21 11:52:03 2018 -0400

    Fix value editing with callback

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9a7ad5c815..e936bd95f6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -251,21 +251,21 @@ uint16_t max_display_update_time = 0;
   void menu_action_submenu(screenFunc_t data);
   void menu_action_gcode(const char* pgcode);
   void menu_action_function(menuAction_t data);
 
   #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
     bool _menu_edit_ ## _name(); \
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
-    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live=false); \
+    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback=NULL, const bool live=false); \
     typedef void _name##_void
 
   DECLARE_MENU_EDIT_TYPE(int16_t, int3);
   DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
   DECLARE_MENU_EDIT_TYPE(float, float3);
   DECLARE_MENU_EDIT_TYPE(float, float52);
   DECLARE_MENU_EDIT_TYPE(float, float43);
   DECLARE_MENU_EDIT_TYPE(float, float5);
   DECLARE_MENU_EDIT_TYPE(float, float51);
   DECLARE_MENU_EDIT_TYPE(float, float52sign);
@@ -4809,47 +4809,45 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #define DEFINE_MENU_EDIT_TYPE(_type, _name, _strFunc, _scale) \
     bool _menu_edit_ ## _name() { \
       ENCODER_DIRECTION_NORMAL(); \
       if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
       if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
       if (lcdDrawUpdate) \
         lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale))); \
       if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
         _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale); \
         if (editValue != NULL) *((_type*)editValue) = value; \
-        if (liveEdit) (*callbackFunc)(); \
+        if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
         if (lcd_clicked) lcd_goto_previous_menu(); \
       } \
       return use_click(); \
     } \
     void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
-    void menu_edit_callback_ ## _name() { if (_menu_edit_ ## _name()) (*callbackFunc)(); } \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
       lcd_save_previous_screen(); \
       lcd_refresh(); \
       \
       editLabel = pstr; \
       editValue = ptr; \
       minEditValue = minValue * _scale; \
       maxEditValue = maxValue * _scale - minEditValue; \
       encoderPosition = (*ptr) * _scale - minEditValue; \
     } \
-    void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
-      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
-      currentScreen = menu_edit_ ## _name; \
-    } \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
-      currentScreen = menu_edit_callback_ ## _name; \
+      currentScreen = menu_edit_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
+    FORCE_INLINE void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
+      menu_action_setting_edit_callback_ ## _name(pstr, ptr, minValue, maxValue); \
+    } \
     typedef void _name##_void
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
   DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
   DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
   DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100.0);

commit 9d04f47d9809a22f2ed41cb8cc093ce68e5f5753
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 18:49:08 2018 -0500

    Improvements for junction_deviation_mm
    
    - Drop `max_jerk` with `JUNCTION_DEVIATION`
    - Add `max_e_jerk_factor` for use by `LIN_ADVANCE`
    - Recalculate `max_e_jerk_factor` when `junction_deviation_mm` changes
    - Fix LCD editing of `junction_deviation_mm`

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 80e0240adc..9a7ad5c815 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3745,31 +3745,31 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       #if ENABLED(JUNCTION_DEVIATION)
-        MENU_ITEM_EDIT(float3, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3);
+        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3, planner.recalculate_max_e_jerk_factor);
       #else
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
           MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
         #endif
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
       #endif
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a8297f9aad..80e0240adc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2019,34 +2019,33 @@ void lcd_quick_feedback(const bool clear_buttons) {
         _lcd_level_goto_next_point();
       }
     }
 
     /**
      * Step 3: Display "Homing XYZ" - Wait for homing to finish
      */
     void _lcd_level_bed_homing() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-        lcd_goto_screen(_lcd_level_bed_homing_done);
+      if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
     }
 
     #if ENABLED(PROBE_MANUALLY)
       extern bool g29_in_progress;
     #endif
 
     /**
      * Step 2: Continue Bed Leveling...
      */
     void _lcd_level_bed_continue() {
       defer_return_to_status = true;
-      axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
+      axis_homed = 0;
       lcd_goto_screen(_lcd_level_bed_homing);
       enqueue_and_echo_commands_P(PSTR("G28"));
     }
 
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
     static int16_t ubl_storage_slot = 0,
                custom_hotend_temp = 190,
@@ -2362,21 +2361,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     /**
      * UBL LCD "radar" map homing
      */
     void _lcd_ubl_output_map_lcd();
 
     void _lcd_ubl_map_homing() {
       defer_return_to_status = true;
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT < 3 ? 0 : (LCD_HEIGHT > 4 ? 2 : 1), PSTR(MSG_LEVEL_BED_HOMING));
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+      if (all_axes_homed()) {
         ubl.lcd_map_control = true; // Return to the map screen
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       }
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {
       char UBL_LCD_GCODE[50], str[10], str2[10];
@@ -2407,21 +2406,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       currentScreen = _lcd_do_nothing;
       planner.quick_stop();
       currentScreen = old_screen;
       set_current_from_steppers_for_axis(ALL_AXES);
       sync_plan_position();
     }
 
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
-      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
+      if (!all_axes_known())
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
       if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
         if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
         encoderPosition = 0;
@@ -2456,22 +2455,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
           _lcd_hard_stop();
 
         ubl_map_move_to_xy();       // Move to new location
       }
     }
 
     /**
      * UBL Homing before LCD map
      */
     void _lcd_ubl_output_map_lcd_cmd() {
-      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS])) {
-        axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
+      if (!all_axes_known()) {
+        axis_homed = 0;
         enqueue_and_echo_commands_P(PSTR("G28"));
       }
       lcd_goto_screen(_lcd_ubl_map_homing);
     }
 
     /**
      * UBL Output map submenu
      *
      * << Unified Bed Leveling
      *  Output for Host
@@ -2585,21 +2584,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
      *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
      *    Level Bed >
      *    Level Corners >     (if homed)
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
 
-      const bool is_homed = axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS];
+      const bool is_homed = all_axes_known();
 
       // Auto Home if not using manual probing
       #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
         if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       #endif
 
       // Level Bed
       #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
         // Manual leveling uses a guided procedure
         MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
@@ -2627,22 +2626,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #elif HAS_BED_PROBE
         MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
       #endif
 
       #if ENABLED(LEVEL_BED_CORNERS)
         // Move to the next corner for leveling
-        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-          MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+        if (all_axes_homed()) MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
   #endif // LCD_BED_LEVELING
@@ -2658,21 +2656,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     //
     // ^ Main
     //
     MENU_BACK(MSG_MAIN);
 
     //
     // Move Axis
     //
     #if ENABLED(DELTA)
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+      if (all_axes_homed())
     #endif
         MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
 
     //
     // Auto Home
     //
     MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
@@ -2702,21 +2700,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+      if (all_axes_homed())
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
       //
       // Set Home Offsets
       //
       MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
     #endif
 
@@ -2832,21 +2830,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       return current_position[Z_AXIS];
     }
 
   #endif // DELTA_AUTO_CALIBRATION
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
 
     void _lcd_calibrate_homing() {
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+      if (all_axes_homed())
         lcd_goto_previous_menu();
     }
 
     void _lcd_delta_calibrate_home() {
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
@@ -2887,21 +2885,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
         MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
         #if ENABLED(EEPROM_SETTINGS)
           MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
           MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         #endif
       #endif
       MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
       #if ENABLED(DELTA_CALIBRATION_MENU)
         MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
-        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+        if (all_axes_homed()) {
           MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
           MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
           MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
           MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
         }
       #endif
       END_MENU();
     }
 
   #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
@@ -3183,21 +3181,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-    #define _MOVE_XYZ_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+    #define _MOVE_XYZ_ALLOWED (all_axes_homed())
   #else
     #define _MOVE_XYZ_ALLOWED true
   #endif
 
   #if ENABLED(DELTA)
     #define _MOVE_XY_ALLOWED (current_position[Z_AXIS] <= delta_clip_start_height)
     void lcd_lower_z_to_clip_height() {
       line_to_z(delta_clip_start_height);
       lcd_synchronize();
     }
@@ -4923,21 +4921,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       }
       else if (!keypad_debounce) {
         keypad_debounce = 2;
 
         if (REPRAPWORLD_KEYPAD_MOVE_MENU)       reprapworld_keypad_move_menu();
 
         #if DISABLED(DELTA) && Z_HOME_DIR == -1
           if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
         #endif
 
-        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+        if (all_axes_homed()) {
           #if ENABLED(DELTA) || Z_HOME_DIR != -1
             if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
           #endif
           if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
           if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
           if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
           if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
           if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
         }
         else {

commit ae07a3e4aa8eff8e8060361f3e21f97bd26d8dee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 10 18:21:15 2018 -0500

    Multiplier edit large ranges

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b86fbabf71..a8297f9aad 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3672,106 +3672,106 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     // M203 / M205 Velocity options
     void lcd_control_motion_velocity_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       // M203 Max Feedrate
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.max_feedrate_mm_s[A_AXIS], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.max_feedrate_mm_s[B_AXIS], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.max_feedrate_mm_s[C_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.max_feedrate_mm_s[A_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.max_feedrate_mm_s[B_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.max_feedrate_mm_s[C_AXIS], 1, 999);
 
       #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
-        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
-        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
         #if E_STEPPERS > 2
-          MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
           #if E_STEPPERS > 3
-            MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
             #if E_STEPPERS > 4
-              MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
-        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
       #endif
 
       // M205 S Min Feedrate
-      MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
 
       // M205 T Min Travel Feedrate
-      MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
 
       END_MENU();
     }
 
     // M201 / M204 Accelerations
     void lcd_control_motion_acceleration_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       // M204 P Acceleration
-      MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
 
       // M204 R Retract Acceleration
-      MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
 
       // M204 T Travel Acceleration
-      MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
+      MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
 
       // M201 settings
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
 
       #if ENABLED(DISTINCT_E_FACTORS)
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
         #if E_STEPPERS > 2
-          MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
           #if E_STEPPERS > 3
-            MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
             #if E_STEPPERS > 4
-              MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
             #endif // E_STEPPERS > 4
           #endif // E_STEPPERS > 3
         #endif // E_STEPPERS > 2
       #else
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
       #endif
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       #if ENABLED(JUNCTION_DEVIATION)
         MENU_ITEM_EDIT(float3, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3);
       #else
-        MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
-        MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
-          MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
-          MENU_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
+          MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
         #endif
       #endif
-      MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);

commit 20a5db03bb3d9ed0b9a7177cec740ba45531dc52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 10 18:20:21 2018 -0500

    Junction Deviation limit (0.01 to 0.3)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 69920a9943..b86fbabf71 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3747,21 +3747,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       #if ENABLED(JUNCTION_DEVIATION)
-        MENU_ITEM_EDIT(float3, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0, 5);
+        MENU_ITEM_EDIT(float3, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01, 0.3);
       #else
         MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
         MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
         #if ENABLED(DELTA)
           MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
         #else
           MENU_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
         #endif
       #endif
       MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);

commit a2f521d34b7a500bcaea996e1f386b57ff40d2f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 10 18:02:54 2018 -0500

    Add Junction Deviation mm runtime setting (#10990)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4b3f39c536..69920a9943 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3746,26 +3746,30 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
-      MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
-      MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
-      #if ENABLED(DELTA)
-        MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
+      #if ENABLED(JUNCTION_DEVIATION)
+        MENU_ITEM_EDIT(float3, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0, 5);
       #else
-        MENU_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
+        MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
+        MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
+        #if ENABLED(DELTA)
+          MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
+        #else
+          MENU_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
+        #endif
       #endif
       MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);

commit 2fd9ba56dad9bd884598d1ae435d7cc54d981785
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:53:25 2018 -0500

    LED menu item bool (like Case Lights)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 011dd3088c..4b3f39c536 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4248,24 +4248,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
         #if ENABLED(NEOPIXEL_LED)
           MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_BRIGHTNESS, &leds.color.i, 0, 255, leds.update, true);
         #endif
       #endif
       END_MENU();
     }
 
     void lcd_led_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      if (leds.lights_on)
-        MENU_ITEM(function, MSG_LEDS_OFF, leds.toggle);
-      else
-        MENU_ITEM(function, MSG_LEDS_ON, leds.toggle);
+      bool led_on = leds.lights_on;
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_LEDS, &led_on, leds.toggle);
       MENU_ITEM(function, MSG_SET_LEDS_DEFAULT, leds.set_default);
       #if ENABLED(LED_COLOR_PRESETS)
         MENU_ITEM(submenu, MSG_LED_PRESETS, lcd_led_presets_menu);
       #endif
       MENU_ITEM(submenu, MSG_CUSTOM_LEDS, lcd_led_custom_menu);
       END_MENU();
     }
 
   #endif // LED_CONTROL_MENU
 

commit cf7d5a642aea61702823335c3c42d9432270802e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 26 18:30:53 2018 -0500

    Fix manual moves for switching tools (#10868)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8bf8dd77ce..011dd3088c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3253,34 +3253,50 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     #elif ENABLED(DUAL_X_CARRIAGE)
 
       if (active_extruder)
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
       else
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
 
     #endif
 
-    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
-    #if E_MANUAL > 1
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
-      #if E_MANUAL > 2
+    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
+
+      // Only the current...
+      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
+      // ...and the non-switching
+      #if E_MANUAL == 5
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+      #elif E_MANUAL == 3
         MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
-        #if E_MANUAL > 3
-          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
-          #if E_MANUAL > 4
-            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
-          #endif // E_MANUAL > 4
-        #endif // E_MANUAL > 3
-      #endif // E_MANUAL > 2
-    #endif // E_MANUAL > 1
+      #endif
+
+    #else
+
+      // Independent extruders with one E-stepper per hotend
+      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
+      #if E_MANUAL > 1
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
+        #if E_MANUAL > 2
+          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
+          #if E_MANUAL > 3
+            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
+            #if E_MANUAL > 4
+              MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+            #endif // E_MANUAL > 4
+          #endif // E_MANUAL > 3
+        #endif // E_MANUAL > 2
+      #endif // E_MANUAL > 1
+
+    #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Control" submenu
    *
    */
 

commit 6f330f397e58130dcc9871fba33786575ac37f6f
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Sat May 26 01:32:37 2018 -0300

    [2.0.x] Buffer overflow and scroll fix, UTF8 cleanup (#10844)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9b77c80512..8bf8dd77ce 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -73,21 +73,21 @@
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
-  uint8_t status_scroll_pos = 0;
+  uint8_t status_scroll_offset = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
@@ -5353,82 +5353,98 @@ void lcd_update() {
         lcdDrawUpdate = LCDVIEW_NONE;
       case LCDVIEW_NONE:
       case LCDVIEW_CALL_REDRAW_NEXT:
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
-inline void pad_message_string() {
-  uint8_t i = 0, j = 0;
-  char c;
-  lcd_status_message[MAX_MESSAGE_LENGTH] = '\0';
-  while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
-    if (PRINTABLE(c)) j++;
-    i++;
-  }
-  if (true
-    #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      && j < LCD_WIDTH
-    #endif
-  ) {
-    // pad with spaces to fill up the line
-    while (j++ < LCD_WIDTH) lcd_status_message[i++] = ' ';
-    // chop off at the edge
-    lcd_status_message[i] = '\0';
-  }
-}
-
 void lcd_finishstatus(const bool persist=false) {
 
-  pad_message_string();
-
   #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
     UNUSED(persist);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
     progress_bar_ms = millis();
     #if PROGRESS_MSG_EXPIRE > 0
       expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
     #endif
   #endif
   lcd_refresh();
 
   #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
     previous_lcd_status_ms = millis();  //get status message to show up for a while
   #endif
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    status_scroll_pos = 0;
+    status_scroll_offset = 0;
   #endif
 }
 
 #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   void dontExpireStatus() { expire_status_ms = 0; }
 #endif
 
 bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
 
 void lcd_setstatus(const char * const message, const bool persist) {
   if (lcd_status_message_level > 0) return;
-  strncpy(lcd_status_message, message, MAX_MESSAGE_LENGTH);
+
+  // Here we have a problem. The message is encoded in UTF8, so
+  // arbitrarily cutting it will be a problem. We MUST be sure
+  // that there is no cutting in the middle of a multibyte character!
+
+  // Get a pointer to the null terminator
+  const char* pend = message + strlen(message);
+
+  //  If length of supplied UTF8 string is greater than
+  // our buffer size, start cutting whole UTF8 chars
+  while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    --pend;
+    while (!START_OF_UTF8_CHAR(*pend)) --pend;
+  };
+
+  // At this point, we have the proper cut point. Use it
+  uint8_t maxLen = pend - message;
+  strncpy(lcd_status_message, message, maxLen);
+  lcd_status_message[maxLen] = '\0';
+
   lcd_finishstatus(persist);
 }
 
 void lcd_setstatusPGM(const char * const message, int8_t level) {
   if (level < 0) level = lcd_status_message_level = 0;
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
-  strncpy_P(lcd_status_message, message, MAX_MESSAGE_LENGTH);
+
+  // Here we have a problem. The message is encoded in UTF8, so
+  // arbitrarily cutting it will be a problem. We MUST be sure
+  // that there is no cutting in the middle of a multibyte character!
+
+  // Get a pointer to the null terminator
+  const char* pend = message + strlen_P(message);
+
+  //  If length of supplied UTF8 string is greater than
+  // our buffer size, start cutting whole UTF8 chars
+  while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    --pend;
+    while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
+  };
+
+  // At this point, we have the proper cut point. Use it
+  uint8_t maxLen = pend - message;
+  strncpy_P(lcd_status_message, message, maxLen);
+  lcd_status_message[maxLen] = '\0';
+
   lcd_finishstatus(level > 0);
 }
 
 void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
   va_list args;
   va_start(args, fmt);
   vsnprintf_P(lcd_status_message, MAX_MESSAGE_LENGTH, fmt, args);
   va_end(args);

commit c89649b46e86691a8b5b28557c4f248febf5fb0c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 23 02:37:09 2018 -0500

    Suppress U8glib build warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index be8958fdac..9b77c80512 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -96,23 +96,21 @@ uint8_t lcd_status_update_delay = 1, // First update one loop delayed
 #if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
-  #include <U8glib.h>
-  bool drawing_screen, // = false
-       first_page;
+  bool drawing_screen, first_page; // = false
 #else
   #include "ultralcd_impl_HD44780.h"
   constexpr bool first_page = true;
 #endif
 
 // The main status screen
 void lcd_status_screen();
 
 millis_t next_lcd_update_ms;
 

commit ee333f6be2204c6a7fe9b254f567412762e62c71
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 22 20:34:59 2018 -0500

    Followup to endstops tweaks

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1970bb60c1..be8958fdac 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5490,25 +5490,23 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if ENABLED(NEWPANEL)
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
-
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
-
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
         #if BUTTON_EXISTS(BACK)
           if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
         #endif
 
         //
         // Directional buttons
         //

commit 68d7fcec83b4610b49bab0e63d0cdc435984d89b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 20 12:29:23 2018 -0500

    Simplify and fix Z fade height edit
    
    Fix #10761

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6c42e06389..1970bb60c1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -499,20 +499,25 @@ uint16_t max_display_update_time = 0;
     lcd_clicked = false;
     return click;
   }
 
   /**
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        // Shadow for editing the fade height
+        new_z_fade_height = planner.z_fade_height;
+      #endif
+
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
         else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms) && (planner.movesplanned() || IS_SD_PRINTING))
           screen =
@@ -1071,27 +1076,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     }
 
   #endif
 
   /**
    *
    * "Main" menu
    *
    */
 
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-    void _lcd_goto_tune_menu() {
-      lcd_goto_screen(lcd_tune_menu);
-      new_z_fade_height = planner.z_fade_height;
-    }
-  #endif
-
   void lcd_main_menu() {
     START_MENU();
     MENU_BACK(MSG_WATCH);
 
     #if ENABLED(CUSTOM_USER_MENUS)
       MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
     #endif
 
     //
     // Debug Menu when certain options are enabled
@@ -1104,32 +1102,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
     // Set Case light on/off/brightness
     //
     #if ENABLED(MENU_ITEM_CASE_LIGHT)
       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
         MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
       }
       else
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
     #endif
 
-    if (planner.movesplanned() || IS_SD_PRINTING) {
-      MENU_ITEM(submenu, MSG_TUNE,
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          _lcd_goto_tune_menu
-        #else
-          lcd_tune_menu
-        #endif
-      );
-    }
-    else {
+    if (planner.movesplanned() || IS_SD_PRINTING)
+      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+    else
       MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
-    }
+
     MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
 
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
           if (card.sdprinting)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
@@ -2052,27 +2043,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
       defer_return_to_status = true;
       axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
       lcd_goto_screen(_lcd_level_bed_homing);
       enqueue_and_echo_commands_P(PSTR("G28"));
     }
 
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      void _lcd_goto_ubl_level_bed() {
-        lcd_goto_screen(_lcd_ubl_level_bed);
-        new_z_fade_height = planner.z_fade_height;
-      }
-    #endif
-
     static int16_t ubl_storage_slot = 0,
                custom_hotend_temp = 190,
                side_points = 3,
                ubl_fillin_amount = 5,
                ubl_height_amount = 1,
                n_edit_pts = 1,
                x_plot = 0,
                y_plot = 0;
 
     #if HAS_HEATED_BED
@@ -2656,27 +2640,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
           MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      void _lcd_goto_bed_leveling() {
-        lcd_goto_screen(lcd_bed_leveling);
-        new_z_fade_height = planner.z_fade_height;
-      }
-    #endif
-
   #endif // LCD_BED_LEVELING
 
   /**
    *
    * "Prepare" submenu
    *
    */
 
   void lcd_prepare_menu() {
     START_MENU();
@@ -2702,43 +2679,28 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
     #endif
 
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, (
-          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-            _lcd_goto_ubl_level_bed
-          #else
-            _lcd_ubl_level_bed
-          #endif
-        )
-      );
+      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
 
     #elif ENABLED(LCD_BED_LEVELING)
 
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
-
-          MENU_ITEM(submenu, MSG_BED_LEVELING, (
-              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-                _lcd_goto_bed_leveling
-              #else
-                lcd_bed_leveling
-              #endif
-            )
-          );
+          MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling);
 
     #elif PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS)
 
       #if DISABLED(PROBE_MANUALLY)
         MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
       #endif
       if (leveling_is_valid()) {
         bool new_level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f456ad3ade..6c42e06389 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2414,26 +2414,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
     }
 
     /**
      * UBL LCD "radar" map
      */
     void set_current_from_steppers_for_axis(const AxisEnum axis);
     void sync_plan_position();
 
     void _lcd_do_nothing() {}
     void _lcd_hard_stop() {
-      stepper.quick_stop();
       const screenFunc_t old_screen = currentScreen;
       currentScreen = _lcd_do_nothing;
-      while (planner.movesplanned()) idle();
+      planner.quick_stop();
       currentScreen = old_screen;
-      stepper.cleaning_buffer_counter = 0;
       set_current_from_steppers_for_axis(ALL_AXES);
       sync_plan_position();
     }
 
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
@@ -3849,21 +3847,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       // M205 - Max Jerk
       MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);
 
       // M92 - Steps Per mm
       MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
 
     #endif // !SLIM_LCD_MENUS
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-      MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
+      MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
     #endif
 
     END_MENU();
   }
 
   #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
     /**
      *
      * "Control" > "Filament" submenu
      *

commit 3c76bda2d8d1f198a9e6dcb94aca6e383c9d5392
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Fri May 18 20:16:59 2018 +0200

    Fix switching extruder
    
    `DONT_SWITCH` got lost along the way. Replace it with `DO_SWITCH_EXTRUDER` and adjust the code.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a6802f386f..f456ad3ade 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3263,21 +3263,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if ENABLED(DELTA)
         else
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 
       MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
     }
     else
       MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
 
-    #if ENABLED(SWITCHING_EXTRUDER)
+    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
 
       #if EXTRUDERS == 4
         switch (active_extruder) {
           case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
           case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
           case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
           case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
         }
       #elif EXTRUDERS == 3
         if (active_extruder < 2) {

commit c173a31060f904dc4f3017352965f50c08e6272e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 19 16:54:37 2018 -0500

    Fix some compile warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b4007a45cb..a6802f386f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3328,21 +3328,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if HAS_LCD_CONTRAST
     void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
   #endif
 
   static void lcd_factory_settings() {
     settings.reset();
     lcd_completion_feedback();
   }
 
-  #if ENABLED(EEPROM_SETTINGS)
+  #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
 
     static void lcd_init_eeprom() {
       lcd_completion_feedback(settings.init_eeprom());
       lcd_goto_previous_menu();
     }
 
     static void lcd_init_eeprom_confirm() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);

commit 0ea60d506a9d5676afe0a47c39dea32411068f1b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 14 23:54:50 2018 -0500

    Clear up LCD-related compile issues

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 94108ee1d8..b4007a45cb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -17,20 +17,22 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(ULTRA_LCD)
 
+#include <stdarg.h>
+
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
 #include "../module/printcounter.h"
 #include "../gcode/gcode.h"
@@ -4860,21 +4862,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_ ## _name; \
     } \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_callback_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
-    typedef void _name
+    typedef void _name##_void
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
   DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
   DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
   DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);

commit f07260c33fbc7f5aaf3c57f5bfcf8587a7c77ae2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 08:11:21 2018 -0500

    Don't babystep on long click unless printing
    
    As pointed out in #10731

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ba6bdabd4c..94108ee1d8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -505,21 +505,21 @@ uint16_t max_display_update_time = 0;
     if (currentScreen != screen) {
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
-        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms))
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms) && (planner.movesplanned() || IS_SD_PRINTING))
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
               lcd_babystep_zoffset
             #else
               lcd_babystep_z
             #endif
           ;
       #endif
 
       currentScreen = screen;

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 132d114daf..ba6bdabd4c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -622,21 +622,21 @@ uint16_t max_display_update_time = 0;
   int8_t encoderLine, screen_items;
   void scroll_screen(const uint8_t limit, const bool is_menu) {
     ENCODER_DIRECTION_MENUS();
     ENCODER_RATE_MULTIPLY(false);
     if (encoderPosition > 0x8000) encoderPosition = 0;
     if (first_page) {
       encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
       screen_changed = false;
     }
     if (screen_items > 0 && encoderLine >= screen_items - limit) {
-      encoderLine = max(0, screen_items - limit);
+      encoderLine = MAX(0, screen_items - limit);
       encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
     }
     if (is_menu) {
       NOMORE(encoderTopLine, encoderLine);
       if (encoderLine >= encoderTopLine + menu_bottom)
         encoderTopLine = encoderLine - menu_bottom + 1;
     }
     else
       encoderTopLine = encoderLine;
   }
@@ -1572,21 +1572,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
   #endif // HAS_MOTOR_CURRENT_PWM
 
   constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
 
   /**
    *
    * "Prepare" submenu items
    *
    */
   void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const int16_t fan) {
-    if (temph > 0) thermalManager.setTargetHotend(min(heater_maxtemp[endnum], temph), endnum);
+    if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
     #if HAS_HEATED_BED
       if (tempb >= 0) thermalManager.setTargetBed(tempb);
     #else
       UNUSED(tempb);
     #endif
     #if FAN_COUNT > 0
       #if FAN_COUNT > 1
         fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
       #else
         fanSpeeds[0] = fan;
@@ -2111,21 +2111,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
       const int ind = ubl_height_amount > 0 ? 9 : 10;
       strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
-      sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
+      sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), ABS(ubl_height_amount));
       lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Adjust Mesh Height submenu
      *
      * << Edit Mesh
      *    Height Amount: ---
      *    Adjust Mesh Height
      * << Info Screen
@@ -2434,21 +2434,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
       if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
-        if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
+        if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
       // Encoder to the right (++)
       if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
       if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
 
       // Encoder to the left (--)
       if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
@@ -2846,21 +2846,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
     void lcd_move_z();
 
     void _man_probe_pt(const float &rx, const float &ry) {
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       do_blocking_move_to_xy(rx, ry);
 
       lcd_synchronize();
-      move_menu_scale = max(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
+      move_menu_scale = MAX(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
       lcd_goto_screen(lcd_move_z);
     }
 
   #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
   #if ENABLED(DELTA_AUTO_CALIBRATION)
 
     float lcd_probe_pt(const float &rx, const float &ry) {
       _man_probe_pt(rx, ry);
       KEEPALIVE_STATE(PAUSED_FOR_USER);
@@ -3618,22 +3618,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #if HOTENDS > 4
         #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
         #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
       #elif HOTENDS > 3
         #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
         #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
       #elif HOTENDS > 2
         #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
         #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
-        #define MINTEMP_ALL min(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
-        #define MAXTEMP_ALL max(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
+        #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
+        #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
       #else
         #define MINTEMP_ALL HEATER_0_MINTEMP
         #define MAXTEMP_ALL HEATER_0_MAXTEMP
       #endif
       START_MENU();
       MENU_BACK(MSG_TEMPERATURE);
       MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
       #if HAS_TEMP_HOTEND
         MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
       #endif
@@ -5222,29 +5222,29 @@ void lcd_update() {
 
         if (handle_adc_keypad())
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
 
       #elif ENABLED(REPRAPWORLD_KEYPAD)
 
         handle_reprapworld_keypad();
 
       #endif
 
-      const bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
+      const bool encoderPastThreshold = (ABS(encoderDiff) >= ENCODER_PULSES_PER_STEP);
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
           int32_t encoderMultiplier = 1;
 
           #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
             if (encoderRateMultiplierEnabled) {
-              int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;
+              int32_t encoderMovementSteps = ABS(encoderDiff) / ENCODER_PULSES_PER_STEP;
 
               if (lastEncoderMovementMillis) {
                 // Note that the rate is always calculated between two passes through the
                 // loop and that the abs of the encoderDiff value is tracked.
                 float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000.0;
 
                 if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
                 else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)

commit 083ec9963e2ab37d9fbe3640d83fe3fdac6ac613
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:08:55 2018 -0500

    Tweaks to heater / lcd conditions

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 48f84d0859..132d114daf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -857,22 +857,22 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
     }
 
     bool abort_sd_printing; // =false
 
     void lcd_sdcard_stop() {
-      abort_sd_printing = true;
       wait_for_heatup = wait_for_user = false;
+      abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
 
       #if ENABLED(POWER_LOSS_RECOVERY)
         card.openJobRecoveryFile(false);
         job_recovery_info.valid_head = job_recovery_info.valid_foot = 0;
         (void)card.saveJobRecoveryInfo();
         card.closeJobRecoveryFile();
         job_recovery_commands_count = 0;
       #endif
@@ -1677,33 +1677,33 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
     }
 
   #endif // HOTENDS > 1
 
   #if HAS_HEATED_BED
     void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
   #endif
 
-  #if HAS_TEMP_HOTEND && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED)
+  #if HAS_TEMP_HOTEND || HAS_HEATED_BED
 
     void lcd_preheat_m1_menu() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
           MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
         #endif
-      #else
+      #elif HOTENDS > 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
           MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
           MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
         #endif
         #if HOTENDS > 2
@@ -1741,21 +1741,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void lcd_preheat_m2_menu() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
           MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
         #endif
-      #else
+      #elif HOTENDS > 1
         #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
           MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
           MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
         #endif
         #if HOTENDS > 2
@@ -1783,21 +1783,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
         MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
       #endif // HOTENDS > 1
       #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
       #endif
       END_MENU();
     }
 
-  #endif // HAS_TEMP_HOTEND && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_4 || TEMP_SENSOR_BED)
+  #endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
 
   void lcd_cooldown() {
     #if FAN_COUNT > 0
       for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
     #endif
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 84d2ffd21b..48f84d0859 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -563,21 +563,21 @@ uint16_t max_display_update_time = 0;
   // finished, and don't return to the caller until
   // done. ** This blocks the command queue! **
   //
   void _lcd_synchronize() {
     if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
     if (no_reentry) return;
     // Make this the current handler till all moves are done
     no_reentry = true;
     const screenFunc_t old_screen = currentScreen;
     lcd_goto_screen(_lcd_synchronize);
-    stepper.synchronize(); // idle() is called until moves complete
+    planner.synchronize(); // idle() is called until moves complete
     no_reentry = false;
     lcd_goto_screen(old_screen);
   }
 
   // Display the synchronize screen with a custom message
   // ** This blocks the command queue! **
   void lcd_synchronize(const char * const msg=NULL) {
     sync_message = msg ? msg : moving;
     _lcd_synchronize();
   }

commit 325bbbc8c2a65218ed6a0abc671e74fb41e6fc27
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 11 01:01:51 2018 -0500

    [2.0.x] Enable AD595 and AD8495 in concert (#10693)
    
    * Allow both AD595 and AD8495 in concert
    * General temperature code tweaks

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6a0cb2bbb4..84d2ffd21b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3532,21 +3532,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
           MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Autotemp, Min, Max, Fact
     //
-    #if ENABLED(AUTOTEMP) && (HAS_TEMP_HOTEND)
+    #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
       MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
     #endif
 
     //
     // PID-P, PID-I, PID-D, PID-C, PID Autotune
     // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
     // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2

commit a1fab8336e1f19c5d69f5de12377335ce54d2521
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 7 02:52:26 2018 -0500

    Fix abort of SD printing

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 704baaa93e..6a0cb2bbb4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -858,20 +858,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
     }
 
     bool abort_sd_printing; // =false
 
     void lcd_sdcard_stop() {
       abort_sd_printing = true;
+      wait_for_heatup = wait_for_user = false;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
 
       #if ENABLED(POWER_LOSS_RECOVERY)
         card.openJobRecoveryFile(false);
         job_recovery_info.valid_head = job_recovery_info.valid_foot = 0;
         (void)card.saveJobRecoveryInfo();
         card.closeJobRecoveryFile();
         job_recovery_commands_count = 0;
       #endif

commit 81b632c2558257c31b2f762e9bf8237c03638e07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 19:33:41 2018 -0500

    Additional temp-oriented improvements

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3f0e7b6043..704baaa93e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1572,231 +1572,231 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
 
   /**
    *
    * "Prepare" submenu items
    *
    */
   void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const int16_t fan) {
     if (temph > 0) thermalManager.setTargetHotend(min(heater_maxtemp[endnum], temph), endnum);
-    #if TEMP_SENSOR_BED != 0
+    #if HAS_HEATED_BED
       if (tempb >= 0) thermalManager.setTargetBed(tempb);
     #else
       UNUSED(tempb);
     #endif
     #if FAN_COUNT > 0
       #if FAN_COUNT > 1
         fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
       #else
         fanSpeeds[0] = fan;
       #endif
     #else
       UNUSED(fan);
     #endif
     lcd_return_to_status();
   }
 
-  #if TEMP_SENSOR_0 != 0
+  #if HAS_TEMP_HOTEND
     void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-    #if TEMP_SENSOR_BED != 0
+    #if HAS_HEATED_BED
       void lcd_preheat_m1_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
       void lcd_preheat_m2_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
     #endif
   #endif
 
   #if HOTENDS > 1
     void lcd_preheat_m1_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-    #if TEMP_SENSOR_BED != 0
+    #if HAS_HEATED_BED
       void lcd_preheat_m1_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
       void lcd_preheat_m2_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
     #endif
     #if HOTENDS > 2
       void lcd_preheat_m1_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
       void lcd_preheat_m2_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         void lcd_preheat_m1_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
         void lcd_preheat_m2_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
       #endif
       #if HOTENDS > 3
         void lcd_preheat_m1_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
         void lcd_preheat_m2_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-        #if TEMP_SENSOR_BED != 0
+        #if HAS_HEATED_BED
           void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
           void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
         #endif
         #if HOTENDS > 4
           void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
           void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-          #if TEMP_SENSOR_BED != 0
+          #if HAS_HEATED_BED
             void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
             void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
           #endif
         #endif // HOTENDS > 4
       #endif // HOTENDS > 3
     #endif // HOTENDS > 2
 
     void lcd_preheat_m1_all() {
       #if HOTENDS > 1
         thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
         #if HOTENDS > 2
           thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
           #if HOTENDS > 3
             thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
             #if HOTENDS > 4
               thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         lcd_preheat_m1_e0();
       #else
         lcd_preheat_m1_e0_only();
       #endif
     }
     void lcd_preheat_m2_all() {
       #if HOTENDS > 1
         thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
         #if HOTENDS > 2
           thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
           #if HOTENDS > 3
             thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
             #if HOTENDS > 4
               thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #endif // HOTENDS > 1
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         lcd_preheat_m2_e0();
       #else
         lcd_preheat_m2_e0_only();
       #endif
     }
 
   #endif // HOTENDS > 1
 
-  #if TEMP_SENSOR_BED != 0
+  #if HAS_HEATED_BED
     void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
     void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
   #endif
 
-  #if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || TEMP_SENSOR_BED != 0)
+  #if HAS_TEMP_HOTEND && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED)
 
     void lcd_preheat_m1_menu() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
-        #if TEMP_SENSOR_BED != 0
+        #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
           MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
         #endif
       #else
-        #if TEMP_SENSOR_BED != 0
+        #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
           MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
           MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
         #endif
         #if HOTENDS > 2
-          #if TEMP_SENSOR_BED != 0
+          #if HAS_HEATED_BED
             MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2);
             MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E3, lcd_preheat_m1_e2_only);
           #else
             MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2_only);
           #endif
           #if HOTENDS > 3
-            #if TEMP_SENSOR_BED != 0
+            #if HAS_HEATED_BED
               MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3);
               MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E4, lcd_preheat_m1_e3_only);
             #else
               MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
             #endif
             #if HOTENDS > 4
-              #if TEMP_SENSOR_BED != 0
+              #if HAS_HEATED_BED
                 MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
                 MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
               #else
                 MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
               #endif
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
         MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
       #endif // HOTENDS > 1
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
       #endif
       END_MENU();
     }
 
     void lcd_preheat_m2_menu() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
       #if HOTENDS == 1
-        #if TEMP_SENSOR_BED != 0
+        #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
           MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
         #endif
       #else
-        #if TEMP_SENSOR_BED != 0
+        #if HAS_HEATED_BED
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
           MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
           MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
         #else
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
           MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
         #endif
         #if HOTENDS > 2
-          #if TEMP_SENSOR_BED != 0
+          #if HAS_HEATED_BED
             MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2);
             MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E3, lcd_preheat_m2_e2_only);
           #else
             MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2_only);
           #endif
           #if HOTENDS > 3
-            #if TEMP_SENSOR_BED != 0
+            #if HAS_HEATED_BED
               MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3);
               MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E4, lcd_preheat_m2_e3_only);
             #else
               MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
             #endif
             #if HOTENDS > 4
-              #if TEMP_SENSOR_BED != 0
+              #if HAS_HEATED_BED
                 MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
                 MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
               #else
                 MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
               #endif
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
         MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
       #endif // HOTENDS > 1
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
       #endif
       END_MENU();
     }
 
-  #endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_4 || TEMP_SENSOR_BED)
+  #endif // HAS_TEMP_HOTEND && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_4 || TEMP_SENSOR_BED)
 
   void lcd_cooldown() {
     #if FAN_COUNT > 0
       for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
     #endif
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
@@ -2773,44 +2773,44 @@ void lcd_quick_feedback(const bool clear_buttons) {
           if (thermalManager.targetHotEnoughToExtrude(active_extruder))
             MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
           else
             MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
         #else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
         #endif
       }
     #endif // ADVANCED_PAUSE_FEATURE
 
-    #if TEMP_SENSOR_0 != 0
+    #if HAS_TEMP_HOTEND
 
       //
       // Cooldown
       //
       bool has_heat = false;
       HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
       #if HAS_HEATED_BED
         if (thermalManager.target_temperature_bed) has_heat = true;
       #endif
       if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
 
       //
       // Preheat for Material 1 and 2
       //
-      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || TEMP_SENSOR_BED != 0
+      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
         MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
         MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
       #else
         MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
         MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
       #endif
 
-    #endif // TEMP_SENSOR_0 != 0
+    #endif // HAS_TEMP_HOTEND
 
     //
     // BLTouch Self-Test and Reset
     //
     #if ENABLED(BLTOUCH)
       MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
       if (!endstops.z_probe_enabled && TEST_BLTOUCH())
         MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
     #endif
 
@@ -3531,21 +3531,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
           MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Autotemp, Min, Max, Fact
     //
-    #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
+    #if ENABLED(AUTOTEMP) && (HAS_TEMP_HOTEND)
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
       MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
     #endif
 
     //
     // PID-P, PID-I, PID-D, PID-C, PID Autotune
     // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
     // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
@@ -3626,24 +3626,24 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #elif HOTENDS > 1
         #define MINTEMP_ALL min(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
         #define MAXTEMP_ALL max(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
       #else
         #define MINTEMP_ALL HEATER_0_MINTEMP
         #define MAXTEMP_ALL HEATER_0_MAXTEMP
       #endif
       START_MENU();
       MENU_BACK(MSG_TEMPERATURE);
       MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
-      #if TEMP_SENSOR_0 != 0
+      #if HAS_TEMP_HOTEND
         MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
       #endif
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
     /**
      *
@@ -4147,21 +4147,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
       #if TEMP_SENSOR_4 != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_4
         #include "thermistornames.h"
         STATIC_ITEM("T4: " THERMISTOR_NAME, false, true);
         STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_4_MINTEMP), false);
         STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_4_MAXTEMP), false);
       #endif
 
-      #if TEMP_SENSOR_BED != 0
+      #if HAS_HEATED_BED
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_BED
         #include "thermistornames.h"
         STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
         STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
         STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
       #endif
       END_SCREEN();
     }
 

commit b7e938a9fbc2c5dc9bc59ed56cb4c63e803d3ec7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 07:10:43 2018 -0500

    LCD_BED_LEVELING enables a sub-menu for ABL

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8ef93835a4..3f0e7b6043 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1397,27 +1397,34 @@ void lcd_quick_feedback(const bool clear_buttons) {
     //
     // ^ Main
     //
     MENU_BACK(MSG_MAIN);
 
     //
     // Speed:
     //
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
 
+    //
     // Manual bed leveling, Bed Z:
+    //
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+
+    //
+    // Leveling Fade Height
+    //
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(SLIM_LCD_MENUS)
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
     #endif
+
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #if HOTENDS > 2
@@ -1876,21 +1883,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
     void _lcd_level_bed_corners() {
       defer_return_to_status = true;
       lcd_goto_screen(_lcd_corner_submenu);
       bed_corner = 0;
       _lcd_goto_next_corner();
     }
 
   #endif // LEVEL_BED_CORNERS
 
-  #if ENABLED(LCD_BED_LEVELING)
+  #if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
 
     /**
      *
      * "Prepare" > "Level Bed" handlers
      *
      */
 
     static uint8_t manual_probe_index;
 
     // LCD probed points are from defaults
@@ -2038,90 +2045,20 @@ void lcd_quick_feedback(const bool clear_buttons) {
     /**
      * Step 2: Continue Bed Leveling...
      */
     void _lcd_level_bed_continue() {
       defer_return_to_status = true;
       axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
       lcd_goto_screen(_lcd_level_bed_homing);
       enqueue_and_echo_commands_P(PSTR("G28"));
     }
 
-    static bool new_level_state;
-    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(new_level_state); }
-
-    /**
-     * Step 1: Bed Level entry-point
-     *
-     * << Prepare
-     *    Auto Home           (if homing needed)
-     *    Leveling On/Off     (if data exists, and homed)
-     *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
-     *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
-     *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
-     *    Level Bed >
-     *    Level Corners >     (if homed)
-     *    Load Settings       (Req: EEPROM_SETTINGS)
-     *    Save Settings       (Req: EEPROM_SETTINGS)
-     */
-    void lcd_bed_leveling() {
-      START_MENU();
-      MENU_BACK(MSG_PREPARE);
-
-      #if DISABLED(MESH_BED_LEVELING)
-        if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
-          MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-        else
-      #endif
-        if (leveling_is_valid()) {
-          new_level_state = planner.leveling_active;
-          MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-        }
-
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
-      #endif
-
-      //
-      // MBL Z Offset
-      //
-      #if ENABLED(MESH_BED_LEVELING)
-        MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-      #endif
-
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-      #elif HAS_BED_PROBE
-        MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-      #endif
-
-      MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
-
-      #if ENABLED(LEVEL_BED_CORNERS)
-        // Move to the next corner for leveling
-        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-          MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-      #endif
-
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-      #endif
-      END_MENU();
-    }
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      void _lcd_goto_bed_leveling() {
-        lcd_goto_screen(lcd_bed_leveling);
-        new_z_fade_height = planner.z_fade_height;
-      }
-    #endif
-
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       void _lcd_goto_ubl_level_bed() {
         lcd_goto_screen(_lcd_ubl_level_bed);
         new_z_fade_height = planner.z_fade_height;
       }
     #endif
@@ -2640,20 +2577,107 @@ void lcd_quick_feedback(const bool clear_buttons) {
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
+
+  #if ENABLED(LCD_BED_LEVELING) || (PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS))
+    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
+  #endif
+
+  #if ENABLED(LCD_BED_LEVELING)
+
+    /**
+     * Step 1: Bed Level entry-point
+     *
+     * << Prepare
+     *    Auto Home           (if homing needed)
+     *    Leveling On/Off     (if data exists, and homed)
+     *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
+     *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
+     *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
+     *    Level Bed >
+     *    Level Corners >     (if homed)
+     *    Load Settings       (Req: EEPROM_SETTINGS)
+     *    Save Settings       (Req: EEPROM_SETTINGS)
+     */
+    void lcd_bed_leveling() {
+      START_MENU();
+      MENU_BACK(MSG_PREPARE);
+
+      const bool is_homed = axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS];
+
+      // Auto Home if not using manual probing
+      #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
+        if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+      #endif
+
+      // Level Bed
+      #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+        // Manual leveling uses a guided procedure
+        MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+      #else
+        // Automatic leveling can just run the G-code
+        MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
+      #endif
+
+      // Homed and leveling is valid? Then leveling can be toggled.
+      if (is_homed && leveling_is_valid()) {
+        bool new_level_state = planner.leveling_active;
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+      }
+
+      // Z Fade Height
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      #endif
+
+      //
+      // MBL Z Offset
+      //
+      #if ENABLED(MESH_BED_LEVELING)
+        MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+      #endif
+
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+      #elif HAS_BED_PROBE
+        MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+      #endif
+
+      #if ENABLED(LEVEL_BED_CORNERS)
+        // Move to the next corner for leveling
+        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+          MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+      #endif
+
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+      #endif
+      END_MENU();
+    }
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      void _lcd_goto_bed_leveling() {
+        lcd_goto_screen(lcd_bed_leveling);
+        new_z_fade_height = planner.z_fade_height;
+      }
+    #endif
+
+  #endif // LCD_BED_LEVELING
+
   /**
    *
    * "Prepare" submenu
    *
    */
 
   void lcd_prepare_menu() {
     START_MENU();
 
     //
@@ -2676,40 +2700,58 @@ void lcd_quick_feedback(const bool clear_buttons) {
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
     #endif
 
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED,
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          _lcd_goto_ubl_level_bed
-        #else
-          _lcd_ubl_level_bed
-        #endif
+
+      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, (
+          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+            _lcd_goto_ubl_level_bed
+          #else
+            _lcd_ubl_level_bed
+          #endif
+        )
       );
+
     #elif ENABLED(LCD_BED_LEVELING)
+
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
-          MENU_ITEM(submenu, MSG_BED_LEVELING,
-            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-              _lcd_goto_bed_leveling
-            #else
-              lcd_bed_leveling
-            #endif
+
+          MENU_ITEM(submenu, MSG_BED_LEVELING, (
+              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+                _lcd_goto_bed_leveling
+              #else
+                lcd_bed_leveling
+              #endif
+            )
           );
-    #elif PLANNER_LEVELING && DISABLED(PROBE_MANUALLY) && DISABLED(SLIM_LCD_MENUS)
-      MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
+
+    #elif PLANNER_LEVELING && DISABLED(SLIM_LCD_MENUS)
+
+      #if DISABLED(PROBE_MANUALLY)
+        MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
+      #endif
+      if (leveling_is_valid()) {
+        bool new_level_state = planner.leveling_active;
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+      }
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      #endif
+
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
       //
       // Set Home Offsets

commit a90d99c27c0a52f7232ce23e2f250798c53e1b34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 07:08:47 2018 -0500

    Rename float32 => float52, etc.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 965a94dc60..8ef93835a4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -129,25 +129,25 @@ uint16_t max_display_update_time = 0;
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
       UNUSED(pstr2); UNUSED(pset); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(pget())); \
     } \
     typedef void _name##_void
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int3, itostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint8_t, int8, i8tostr3);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float3, ftostr3);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float32, ftostr32);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float51, ftostr51sign);
-  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52sign);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52sign, ftostr52sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float62, ftostr62rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint32_t, long5, ftostr5rj);
   #define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data)                    DRAW_BOOL_SETTING(sel, row, pstr, data)
   #define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) DRAW_BOOL_SETTING(sel, row, pstr, data)
   #define lcd_implementation_drawmenu_setting_edit_accessor_bool(sel, row, pstr, pstr2, pget, pset)     DRAW_BOOL_SETTING(sel, row, pstr, data)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
@@ -257,25 +257,25 @@ uint16_t max_display_update_time = 0;
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live=false); \
     typedef void _name##_void
 
   DECLARE_MENU_EDIT_TYPE(int16_t, int3);
   DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
   DECLARE_MENU_EDIT_TYPE(float, float3);
-  DECLARE_MENU_EDIT_TYPE(float, float32);
+  DECLARE_MENU_EDIT_TYPE(float, float52);
   DECLARE_MENU_EDIT_TYPE(float, float43);
   DECLARE_MENU_EDIT_TYPE(float, float5);
   DECLARE_MENU_EDIT_TYPE(float, float51);
-  DECLARE_MENU_EDIT_TYPE(float, float52);
+  DECLARE_MENU_EDIT_TYPE(float, float52sign);
   DECLARE_MENU_EDIT_TYPE(float, float62);
   DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
 
   #if ENABLED(SDSUPPORT)
     void lcd_sdcard_menu();
     void menu_action_sdfile(const char* filename, char* longFilename);
     void menu_action_sddirectory(const char* filename, char* longFilename);
@@ -2083,21 +2083,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #elif HAS_BED_PROBE
-        MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+        MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
       #endif
 
       MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
 
       #if ENABLED(LEVEL_BED_CORNERS)
         // Move to the next corner for leveling
         if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
           MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
@@ -2857,29 +2857,29 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void _recalc_delta_settings() {
       #if HAS_LEVELING
         reset_bed_level(); // After changing kinematics bed-level data is no longer valid
       #endif
       recalc_delta_settings();
     }
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
       MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, _recalc_delta_settings);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
         MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
@@ -3308,21 +3308,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
 
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
@@ -3493,39 +3493,39 @@ void lcd_quick_feedback(const bool clear_buttons) {
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Autotemp, Min, Max, Fact
     //
     #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
       MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
-      MENU_ITEM_EDIT(float32, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
+      MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
     #endif
 
     //
     // PID-P, PID-I, PID-D, PID-C, PID Autotune
     // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
     // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
     // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
     // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
     // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
     //
     #if ENABLED(PIDTEMP)
 
       #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
         raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
         raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
-        MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
-        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
-        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
+        MENU_ITEM_EDIT(float52sign, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
+        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
+        MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
 
       #if ENABLED(PID_EXTRUSION_SCALING)
         #define _PID_MENU_ITEMS(ELABEL, eindex) \
           _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
           MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
       #else
         #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
       #endif
 
       #if ENABLED(PID_AUTOTUNE_MENU)
@@ -3732,21 +3732,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
       MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
       #if ENABLED(DELTA)
         MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
       #else
-        MENU_ITEM_EDIT(float52, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
+        MENU_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
       #endif
       MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
@@ -3783,21 +3783,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    */
 
   void lcd_control_motion_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
     #elif HAS_BED_PROBE
-      MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+      MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
 
     #if DISABLED(SLIM_LCD_MENUS)
 
       // M203 / M205 - Feedrate items
       MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
 
       // M201 - Acceleration items
       MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
 
@@ -3821,21 +3821,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     /**
      *
      * "Control" > "Filament" submenu
      *
      */
     void lcd_control_filament_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
 
       #if ENABLED(LIN_ADVANCE)
-        MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           #else // EXTRUDERS > 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
@@ -3906,29 +3906,29 @@ void lcd_quick_feedback(const bool clear_buttons) {
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_control_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
+        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
+        MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.retract_recover_feedrate_mm_s, 1, 999);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.swap_retract_recover_feedrate_mm_s, 1, 999);
       #endif
       END_MENU();
     }
 
   #endif // FWRETRACT
 
@@ -4822,25 +4822,25 @@ void lcd_quick_feedback(const bool clear_buttons) {
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_callback_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
     typedef void _name
 
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
-  DEFINE_MENU_EDIT_TYPE(float, float32, ftostr32, 100.0);
+  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
   DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
-  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52sign, 100.0);
+  DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
   DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01);
 
   /**
    *
    * Handlers for Keypad input
    *
    */
   #if ENABLED(ADC_KEYPAD)
 

commit 05fca752d6d7b88b7697dd5273b6f0428655f3d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 01:01:02 2018 -0500

    Clean up autostart handling

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5000f7c2e5..965a94dc60 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1807,25 +1807,21 @@ void lcd_quick_feedback(const bool clear_buttons) {
     void lcd_enqueue_commands_P(const char * const cmd) {
       no_reentry = true;
       enqueue_and_echo_commands_now_P(cmd);
       no_reentry = false;
     }
 
   #endif
 
   #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
-    void lcd_autostart_sd() {
-      card.autostart_index = 0;
-      card.setroot();
-      card.checkautostart(true);
-    }
+    void lcd_autostart_sd() { card.beginautostart(); }
 
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
     static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
   #endif
 
   #if ENABLED(LEVEL_BED_CORNERS)
 
@@ -5124,23 +5120,26 @@ void lcd_update() {
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const uint8_t sd_status = (uint8_t)IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
-        safe_delay(1000); // some boards need a delay or the LCD won't show the new status
+        safe_delay(500); // Some boards need a delay to get settled
         card.initsd();
-        if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
+        if (old_sd_status == 2)
+          card.beginautostart();  // Initial boot
+        else
+          LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
       lcd_refresh();
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU

commit 05c33833e70c143b726fa32d0052618d178fa0ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 30 21:16:31 2018 -0500

    [2.0.x] Add NO_LCD_MENUS option (#10582)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index aab912791b..5000f7c2e5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -65,72 +65,67 @@
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../feature/leds/leds.h"
 #endif
 
 // For i2c define BUZZ to use lcd_buzz
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
-  bool lcd_external_control; // = false
-#endif
-
-// Initialized by settings.load()
-int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
-
-#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
-  millis_t previous_lcd_status_ms = 0;
-#endif
-
-#if ENABLED(BABYSTEPPING)
-  long babysteps_done = 0;
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    static void lcd_babystep_zoffset();
-  #else
-    static void lcd_babystep_z();
-  #endif
-#endif
-
-uint8_t lcd_status_update_delay = 1, // First update one loop delayed
-        lcd_status_message_level;    // Higher level blocks lower level
-
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
     #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
   #else
     #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
   #endif
   uint8_t status_scroll_pos = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
+uint8_t lcd_status_update_delay = 1, // First update one loop delayed
+        lcd_status_message_level;    // Higher level blocks lower level
 
-#if ENABLED(SCROLL_LONG_FILENAMES)
+#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+  millis_t previous_lcd_status_ms = 0;
+#endif
+
+#if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
   #include <U8glib.h>
+  bool drawing_screen, // = false
+       first_page;
 #else
   #include "ultralcd_impl_HD44780.h"
+  constexpr bool first_page = true;
 #endif
 
+// The main status screen
+void lcd_status_screen();
+
+millis_t next_lcd_update_ms;
+
+uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
+uint16_t max_display_update_time = 0;
+
 #if ENABLED(ULTIPANEL)
+
   #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
     inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
       UNUSED(pstr2); \
       DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
     } \
     inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
@@ -144,51 +139,49 @@ char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float32, ftostr32);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float51, ftostr51sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52sign);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float62, ftostr62rj);
   DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint32_t, long5, ftostr5rj);
   #define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data)                    DRAW_BOOL_SETTING(sel, row, pstr, data)
   #define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) DRAW_BOOL_SETTING(sel, row, pstr, data)
   #define lcd_implementation_drawmenu_setting_edit_accessor_bool(sel, row, pstr, pstr2, pget, pset)     DRAW_BOOL_SETTING(sel, row, pstr, data)
-#endif // ULTIPANEL
-
-// The main status screen
-void lcd_status_screen();
-
-millis_t next_lcd_update_ms;
-
-uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
-uint16_t max_display_update_time = 0;
-
-#if ENABLED(DOGLCD)
-  bool drawing_screen, // = false
-       first_page;
-#else
-  constexpr bool first_page = true;
-#endif
-
-#if ENABLED(DAC_STEPPER_CURRENT)
-  #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
-  uint8_t driverPercent[XYZE];
-#endif
-
-#if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   bool no_reentry = false;
   constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
 
+  // Initialized by settings.load()
+  int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+    bool lcd_external_control; // = false
+  #endif
+
+  #if ENABLED(BABYSTEPPING)
+    long babysteps_done = 0;
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      static void lcd_babystep_zoffset();
+    #else
+      static void lcd_babystep_z();
+    #endif
+  #endif
+
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
+    uint8_t driverPercent[XYZE];
+  #endif
+
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
@@ -784,50 +777,58 @@ void lcd_reset_status() {
  *
  * draw the kill screen
  *
  */
 void kill_screen(const char* lcd_msg) {
   lcd_init();
   lcd_setalertstatusPGM(lcd_msg);
   lcd_kill_screen();
 }
 
-#if ENABLED(ULTIPANEL)
+/**
+ *
+ * Audio feedback for controller clicks
+ *
+ */
+void lcd_buzz(const long duration, const uint16_t freq) {
+  #if ENABLED(LCD_USE_I2C_BUZZER)
+    lcd.buzz(duration, freq);
+  #elif PIN_EXISTS(BEEPER)
+    buzzer.tone(duration, freq);
+  #else
+    UNUSED(duration); UNUSED(freq);
+  #endif
+}
 
-  /**
-   *
-   * Audio feedback for controller clicks
-   *
-   */
-  void lcd_buzz(const long duration, const uint16_t freq) {
-    #if ENABLED(LCD_USE_I2C_BUZZER)
-      lcd.buzz(duration, freq);
-    #elif PIN_EXISTS(BEEPER)
-      buzzer.tone(duration, freq);
-    #else
-      UNUSED(duration); UNUSED(freq);
-    #endif
-  }
+void lcd_quick_feedback(const bool clear_buttons) {
 
-  void lcd_quick_feedback(const bool clear_buttons) {
+  #if ENABLED(ULTIPANEL)
     lcd_refresh();
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
+  #else
+    UNUSED(clear_buttons);
+  #endif
+
+  // Buzz and wait. The delay is needed for buttons to settle!
+  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
 
-    // Buzz and wait. The delay is needed for buttons to settle!
-    lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+  #if ENABLED(ULTIPANEL)
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
-  }
+  #endif
+}
+
+#if ENABLED(ULTIPANEL)
 
   void lcd_completion_feedback(const bool good/*=true*/) {
     if (good) {
       lcd_buzz(100, 659);
       lcd_buzz(100, 698);
     }
     else lcd_buzz(20, 440);
   }
 
   inline void line_to_current_z() {
@@ -5236,21 +5237,21 @@ void lcd_update() {
     ) {
       lcd_status_update_delay = 9
         #if ENABLED(DOGLCD)
           + 3
         #endif
       ;
       max_display_update_time--;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
 
-    #if ENABLED(SCROLL_LONG_FILENAMES)
+    #if ENABLED(ULTIPANEL) && ENABLED(SCROLL_LONG_FILENAMES)
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == lcd_sdcard_menu && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 

commit 524cc392f49aff4da789203d8c6467b2f3422e4b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 21:09:50 2018 -0500

    Fix sd_status comparison
    
    Co-Authored-By: perkmeister <perkmeister@users.noreply.github.com>

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 788ba91bb9..aab912791b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5116,24 +5116,24 @@ void lcd_update() {
       if (LCD_BACK_CLICKED) {
         lcd_quick_feedback(true);
         lcd_goto_previous_menu();
       }
     #endif
 
   #endif // ULTIPANEL
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
-    const bool sd_status = IS_SD_INSERTED;
+    const uint8_t sd_status = (uint8_t)IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
-      bool old_sd_status = lcd_sd_status; // prevent re-entry to this block!
+      uint8_t old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {
         safe_delay(1000); // some boards need a delay or the LCD won't show the new status
         card.initsd();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);

commit 9e0d99c0c61686b55347678633a44ff7ce680158
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 29 00:51:36 2018 -0500

    Round all floats in string conversion functions (#10566)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1535dffa66..788ba91bb9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4822,30 +4822,30 @@ void kill_screen(const char* lcd_msg) {
       currentScreen = menu_edit_ ## _name; \
     } \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_callback_ ## _name; \
       callbackFunc = callback; \
       liveEdit = live; \
     } \
     typedef void _name
 
-  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01);
   DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
   DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
   DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
   DEFINE_MENU_EDIT_TYPE(float, float32, ftostr32, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
   DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
   DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
   DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52sign, 100.0);
   DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
+  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01);
 
   /**
    *
    * Handlers for Keypad input
    *
    */
   #if ENABLED(ADC_KEYPAD)
 
     inline bool handle_adc_keypad() {
       #define ADC_MIN_KEY_DELAY 100

commit cb46cb8480c33ffc9f6361b96ed200986a3bd9ac
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 23 17:13:01 2018 -0500

    Add HAS_HEATED_BED conditional (#10495)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index af19eade33..1535dffa66 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -886,23 +886,25 @@ void kill_screen(const char* lcd_msg) {
       // Return to status now
       lcd_return_to_status();
 
       // Turn leveling off and home
       enqueue_and_echo_commands_P(PSTR("M420 S0\nG28"
         #if !IS_KINEMATIC
           " X Y"
         #endif
       ));
 
-      // Restore the bed temperature
-      sprintf_P(cmd, PSTR("M190 S%i"), job_recovery_info.target_temperature_bed);
-      enqueue_and_echo_command(cmd);
+      #if HAS_HEATED_BED
+        // Restore the bed temperature
+        sprintf_P(cmd, PSTR("M190 S%i"), job_recovery_info.target_temperature_bed);
+        enqueue_and_echo_command(cmd);
+      #endif
 
       // Restore all hotend temperatures
       HOTEND_LOOP() {
         sprintf_P(cmd, PSTR("M109 S%i"), job_recovery_info.target_temperature[e]);
         enqueue_and_echo_command(cmd);
       }
 
       // Restore print cooling fan speeds
       for (uint8_t i = 0; i < FAN_COUNT; i++) {
         sprintf_P(cmd, PSTR("M106 P%i S%i"), i, job_recovery_info.fanSpeeds[i]);
@@ -1424,21 +1426,21 @@ void kill_screen(const char* lcd_msg) {
           #if HOTENDS > 4
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
     //
     // Bed:
     //
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
@@ -2129,52 +2131,52 @@ void kill_screen(const char* lcd_msg) {
 
     static int16_t ubl_storage_slot = 0,
                custom_hotend_temp = 190,
                side_points = 3,
                ubl_fillin_amount = 5,
                ubl_height_amount = 1,
                n_edit_pts = 1,
                x_plot = 0,
                y_plot = 0;
 
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       static int16_t custom_bed_temp = 50;
     #endif
 
     /**
      * UBL Build Custom Mesh Command
      */
     void _lcd_ubl_build_custom_mesh() {
       char UBL_LCD_GCODE[20];
       enqueue_and_echo_commands_P(PSTR("G28"));
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
         lcd_enqueue_command(UBL_LCD_GCODE);
       #endif
       sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
       lcd_enqueue_command(UBL_LCD_GCODE);
       enqueue_and_echo_commands_P(PSTR("G29 P1"));
     }
 
     /**
      * UBL Custom Mesh submenu
      *
      * << Build Mesh
      *    Hotend Temp: ---
      *    Bed Temp: ---
      *    Build Custom Mesh
      */
     void _lcd_ubl_custom_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
       MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_HOTEND_TEMP, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_BED_TEMP, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
       #endif
       MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
@@ -2219,21 +2221,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Validate Custom Mesh Command
      */
     void _lcd_ubl_validate_custom_mesh() {
       char UBL_LCD_GCODE[24];
       const int temp =
-        #if HAS_TEMP_BED
+        #if HAS_HEATED_BED
           custom_bed_temp
         #else
           0
         #endif
       ;
       sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
       lcd_enqueue_commands_P(PSTR("G28"));
       lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
@@ -2242,21 +2244,21 @@ void kill_screen(const char* lcd_msg) {
      *
      * << UBL Tools
      *    PLA Mesh Validation
      *    ABS Mesh Validation
      *    Validate Custom Mesh
      * << Info Screen
      */
     void _lcd_ubl_validate_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_TOOLS);
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #else
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
         MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
       #endif
       MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
@@ -2346,21 +2348,21 @@ void kill_screen(const char* lcd_msg) {
      *    Build Cold Mesh
      *  - Fill-in Mesh >>
      *    Continue Bed Mesh
      *    Invalidate All
      *    Invalidate Closest
      * << Info Screen
      */
     void _lcd_ubl_build_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_TOOLS);
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         MENU_ITEM(gcode, MSG_UBL_BUILD_PLA_MESH, PSTR(
           "G28\n"
           "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
           "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
           "G29 P1\n"
           "M104 S0\n"
           "M140 S0"
         ));
         MENU_ITEM(gcode, MSG_UBL_BUILD_ABS_MESH, PSTR(
           "G28\n"
@@ -2739,21 +2741,21 @@ void kill_screen(const char* lcd_msg) {
       }
     #endif // ADVANCED_PAUSE_FEATURE
 
     #if TEMP_SENSOR_0 != 0
 
       //
       // Cooldown
       //
       bool has_heat = false;
       HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         if (thermalManager.target_temperature_bed) has_heat = true;
       #endif
       if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
 
       //
       // Preheat for Material 1 and 2
       //
       #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || TEMP_SENSOR_BED != 0
         MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
         MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
@@ -3459,21 +3461,21 @@ void kill_screen(const char* lcd_msg) {
           #if HOTENDS > 4
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
           #endif // HOTENDS > 4
         #endif // HOTENDS > 3
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
 
     //
     // Bed:
     //
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
         #if ENABLED(EXTRA_FAN_SPEED)
@@ -5110,21 +5112,21 @@ void lcd_update() {
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED) {
         lcd_quick_feedback(true);
         lcd_goto_previous_menu();
       }
     #endif
 
-  #endif
+  #endif // ULTIPANEL
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       bool old_sd_status = lcd_sd_status; // prevent re-entry to this block!
       lcd_sd_status = sd_status;
 
       if (sd_status) {

commit 9e07df5c1b39d0775158e21dcf0ec909eb98f75e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 02:50:48 2018 -0500

    Extra options for LEVEL_BED_CORNERS (#10483)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a633b6a8d1..af19eade33 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1827,41 +1827,57 @@ void kill_screen(const char* lcd_msg) {
   #if ENABLED(LEVEL_BED_CORNERS)
 
     /**
      * Level corners, starting in the front-left corner.
      */
     static int8_t bed_corner;
     void _lcd_goto_next_corner() {
       line_to_z(4.0);
       switch (bed_corner) {
         case 0:
-          current_position[X_AXIS] = X_MIN_BED + 10;
-          current_position[Y_AXIS] = Y_MIN_BED + 10;
+          current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
+          current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
           break;
         case 1:
-          current_position[X_AXIS] = X_MAX_BED - 10;
+          current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
           break;
         case 2:
-          current_position[Y_AXIS] = Y_MAX_BED - 10;
+          current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
           break;
         case 3:
-          current_position[X_AXIS] = X_MIN_BED + 10;
+          current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
           break;
+        #if ENABLED(LEVEL_CENTER_TOO)
+          case 4:
+            current_position[X_AXIS] = X_CENTER;
+            current_position[Y_AXIS] = Y_CENTER;
+            break;
+        #endif
       }
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
       line_to_z(0.0);
-      if (++bed_corner > 3) bed_corner = 0;
+      if (++bed_corner > 3
+        #if ENABLED(LEVEL_CENTER_TOO)
+          + 1
+        #endif
+      ) bed_corner = 0;
     }
 
     void _lcd_corner_submenu() {
       START_MENU();
-      MENU_ITEM(function, MSG_NEXT_CORNER, _lcd_goto_next_corner);
+      MENU_ITEM(function,
+        #if ENABLED(LEVEL_CENTER_TOO)
+          MSG_LEVEL_BED_NEXT_POINT
+        #else
+          MSG_NEXT_CORNER
+        #endif
+        , _lcd_goto_next_corner);
       MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
       END_MENU();
     }
 
     void _lcd_level_bed_corners() {
       defer_return_to_status = true;
       lcd_goto_screen(_lcd_corner_submenu);
       bed_corner = 0;
       _lcd_goto_next_corner();
     }

commit 023385ca594df78704aed01d390826c42c5e678a
Merge: 3396671011 11ab017dd0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 00:17:44 2018 -0500

    Merge pull request #10479 from thinkyhead/bf2_creality_power_loss_resume
    
    [2.0.x] Creality3D Power-Loss Recovery

diff --combined Marlin/src/lcd/ultralcd.cpp
index 16620cf23c,72edb5065f..a633b6a8d1
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -36,20 -36,24 +36,24 @@@
  #include "../gcode/gcode.h"
  #include "../gcode/queue.h"
  #include "../module/configuration_store.h"
  
  #include "../Marlin.h"
  
  #if ENABLED(ADVANCED_PAUSE_FEATURE)
    #include "../feature/pause.h"
  #endif
  
+ #if ENABLED(POWER_LOSS_RECOVERY)
+   #include "../feature/power_loss_recovery.h"
+ #endif
+ 
  #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
    #include "../libs/duration_t.h"
  #endif
  
  #if ENABLED(FILAMENT_LCD_DISPLAY)
    #include "../feature/filwidth.h"
  #endif
  
  #if ENABLED(BLTOUCH)
    #include "../module/endstops.h"
@@@ -747,41 -751,21 +751,41 @@@ void lcd_status_screen() 
        }
      #endif // ULTIPANEL_FEEDMULTIPLY
  
      feedrate_percentage = constrain(feedrate_percentage, 10, 999);
  
    #endif // ULTIPANEL
  
    lcd_implementation_status_screen();
  }
  
 -void lcd_reset_status() { lcd_setstatusPGM(PSTR(""), -1); }
 +/**
 + * Reset the status message
 + */
 +void lcd_reset_status() {
 +  static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
 +  static const char printing[] PROGMEM = MSG_PRINTING;
 +  static const char welcome[] PROGMEM = WELCOME_MSG;
 +  const char *msg;
 +  if (print_job_timer.isPaused())
 +    msg = paused;
 +  #if ENABLED(SDSUPPORT)
 +    else if (card.sdprinting)
 +      return lcd_setstatus(card.longFilename[0] ? card.longFilename : card.filename, true);
 +  #endif
 +  else if (print_job_timer.isRunning())
 +    msg = printing;
 +  else
 +    msg = welcome;
 +
 +  lcd_setstatusPGM(msg, -1);
 +}
  
  /**
   *
   * draw the kill screen
   *
   */
  void kill_screen(const char* lcd_msg) {
    lcd_init();
    lcd_setalertstatusPGM(lcd_msg);
    lcd_kill_screen();
@@@ -798,21 -782,21 +802,21 @@@
      #if ENABLED(LCD_USE_I2C_BUZZER)
        lcd.buzz(duration, freq);
      #elif PIN_EXISTS(BEEPER)
        buzzer.tone(duration, freq);
      #else
        UNUSED(duration); UNUSED(freq);
      #endif
    }
  
    void lcd_quick_feedback(const bool clear_buttons) {
 -    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 +    lcd_refresh();
      if (clear_buttons) buttons = 0;
      next_button_update_ms = millis() + 500;
  
      // Buzz and wait. The delay is needed for buttons to settle!
      lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
      #if ENABLED(LCD_USE_I2C_BUZZER)
        delay(10);
      #elif PIN_EXISTS(BEEPER)
        for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
      #endif
@@@ -836,43 -820,103 +840,103 @@@
    }
  
    #if ENABLED(SDSUPPORT)
  
      void lcd_sdcard_pause() {
        card.pauseSDPrint();
        print_job_timer.pause();
        #if ENABLED(PARK_HEAD_ON_PAUSE)
          enqueue_and_echo_commands_P(PSTR("M125"));
        #endif
 -      lcd_setstatusPGM(PSTR(MSG_PRINT_PAUSED), -1);
 +      lcd_reset_status();
      }
  
      void lcd_sdcard_resume() {
        #if ENABLED(PARK_HEAD_ON_PAUSE)
          enqueue_and_echo_commands_P(PSTR("M24"));
        #else
          card.startFileprint();
          print_job_timer.start();
        #endif
        lcd_reset_status();
      }
  
      bool abort_sd_printing; // =false
  
      void lcd_sdcard_stop() {
        abort_sd_printing = true;
        lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
        lcd_return_to_status();
+ 
+       #if ENABLED(POWER_LOSS_RECOVERY)
+         card.openJobRecoveryFile(false);
+         job_recovery_info.valid_head = job_recovery_info.valid_foot = 0;
+         (void)card.saveJobRecoveryInfo();
+         card.closeJobRecoveryFile();
+         job_recovery_commands_count = 0;
+       #endif
      }
  
    #endif // SDSUPPORT
  
+   #if ENABLED(POWER_LOSS_RECOVERY)
+ 
+     static void lcd_sdcard_recover_job() {
+       char cmd[20];
+ 
+       // Return to status now
+       lcd_return_to_status();
+ 
+       // Turn leveling off and home
+       enqueue_and_echo_commands_P(PSTR("M420 S0\nG28"
+         #if !IS_KINEMATIC
+           " X Y"
+         #endif
+       ));
+ 
+       // Restore the bed temperature
+       sprintf_P(cmd, PSTR("M190 S%i"), job_recovery_info.target_temperature_bed);
+       enqueue_and_echo_command(cmd);
+ 
+       // Restore all hotend temperatures
+       HOTEND_LOOP() {
+         sprintf_P(cmd, PSTR("M109 S%i"), job_recovery_info.target_temperature[e]);
+         enqueue_and_echo_command(cmd);
+       }
+ 
+       // Restore print cooling fan speeds
+       for (uint8_t i = 0; i < FAN_COUNT; i++) {
+         sprintf_P(cmd, PSTR("M106 P%i S%i"), i, job_recovery_info.fanSpeeds[i]);
+         enqueue_and_echo_command(cmd);
+       }
+ 
+       // Start draining the job recovery command queue
+       job_recovery_phase = JOB_RECOVERY_YES;
+ 
+       // Resume the print job timer
+       if (job_recovery_info.print_job_elapsed)
+         print_job_timer.resume(job_recovery_info.print_job_elapsed);
+ 
+       // Start getting commands from SD
+       card.startFileprint();
+     }
+ 
+     static void lcd_job_recovery_menu() {
+       defer_return_to_status = true;
+       START_MENU();
+       MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_recover_job);
+       MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+       END_MENU();
+     }
+ 
+   #endif // POWER_LOSS_RECOVERY
+ 
    #if ENABLED(MENU_ITEM_CASE_LIGHT)
  
      #include "../feature/caselight.h"
  
      void case_light_menu() {
        START_MENU();
        //
        // ^ Main
        //
        MENU_BACK(MSG_MAIN);
@@@ -3859,21 -3903,21 +3923,21 @@@
        void lcd_sd_refresh() {
          card.initsd();
          encoderTopLine = 0;
        }
      #endif
  
      void lcd_sd_updir() {
        encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
        encoderTopLine = 0;
        screen_changed = true;
 -      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 +      lcd_refresh();
      }
  
      /**
       *
       * "Print from SD" submenu
       *
       */
  
      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
        uint32_t last_sdfile_encoderPosition = 0xFFFF;
@@@ -4720,21 -4764,22 +4784,21 @@@
          if (editValue != NULL) *((_type*)editValue) = value; \
          if (liveEdit) (*callbackFunc)(); \
          if (lcd_clicked) lcd_goto_previous_menu(); \
        } \
        return use_click(); \
      } \
      void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
      void menu_edit_callback_ ## _name() { if (_menu_edit_ ## _name()) (*callbackFunc)(); } \
      void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
        lcd_save_previous_screen(); \
 -      \
 -      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
 +      lcd_refresh(); \
        \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * _scale; \
        maxEditValue = maxValue * _scale - minEditValue; \
        encoderPosition = (*ptr) * _scale - minEditValue; \
      } \
      void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
        _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
        currentScreen = menu_edit_ ## _name; \
@@@ -4860,38 -4905,37 +4924,38 @@@
  
    #if ENABLED(SDSUPPORT)
  
      void menu_action_sdfile(const char* filename, char* longFilename) {
        #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
          last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
        #endif
        UNUSED(longFilename);
        card.openAndPrintFile(filename);
        lcd_return_to_status();
 +      lcd_reset_status();
      }
  
      void menu_action_sddirectory(const char* filename, char* longFilename) {
        UNUSED(longFilename);
        card.chdir(filename);
        encoderTopLine = 0;
        encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
        screen_changed = true;
        #if ENABLED(DOGLCD)
          drawing_screen = false;
        #endif
 -      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 +      lcd_refresh();
      }
  
    #endif // SDSUPPORT
  
 -  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
 +  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
    void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
      menu_action_setting_edit_bool(pstr, ptr);
      (*callback)();
    }
  
  #endif // ULTIPANEL
  
  void lcd_init() {
  
    lcd_implementation_init();
@@@ -5050,30 -5094,37 +5114,37 @@@ void lcd_update() 
        if (sd_status) {
          safe_delay(1000); // some boards need a delay or the LCD won't show the new status
          card.initsd();
          if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
        }
        else {
          card.release();
          if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
        }
  
 -      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 +      lcd_refresh();
        lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
          #if ENABLED(LCD_PROGRESS_BAR)
            currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
          #endif
        );
      }
  
    #endif // SDSUPPORT && SD_DETECT_PIN
  
+   #if ENABLED(POWER_LOSS_RECOVERY)
+     if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
+       lcd_goto_screen(lcd_job_recovery_menu);
+       job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
+     }
+   #endif
+ 
    const millis_t ms = millis();
    if (ELAPSED(ms, next_lcd_update_ms)
      #if ENABLED(DOGLCD)
        || drawing_screen
      #endif
    ) {
  
      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
  
      #if ENABLED(LCD_HAS_STATUS_INDICATORS)
@@@ -5295,21 -5346,21 +5366,21 @@@ void lcd_finishstatus(const bool persis
    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
      UNUSED(persist);
    #endif
  
    #if ENABLED(LCD_PROGRESS_BAR)
      progress_bar_ms = millis();
      #if PROGRESS_MSG_EXPIRE > 0
        expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
      #endif
    #endif
 -  lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 +  lcd_refresh();
  
    #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
      previous_lcd_status_ms = millis();  //get status message to show up for a while
    #endif
  
    #if ENABLED(STATUS_MESSAGE_SCROLLING)
      status_scroll_pos = 0;
    #endif
  }
  

commit 33966710119b64f83a19075875a8d27452cca9a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 00:16:30 2018 -0500

    [2.0.x] Reset LCD status to fallbacks (#10470)
    
    * Remove obsolete strings
    * Tweak some static consts
    * Reset LCD status to fallbacks

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 106b805979..16620cf23c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -747,21 +747,41 @@ void lcd_status_screen() {
       }
     #endif // ULTIPANEL_FEEDMULTIPLY
 
     feedrate_percentage = constrain(feedrate_percentage, 10, 999);
 
   #endif // ULTIPANEL
 
   lcd_implementation_status_screen();
 }
 
-void lcd_reset_status() { lcd_setstatusPGM(PSTR(""), -1); }
+/**
+ * Reset the status message
+ */
+void lcd_reset_status() {
+  static const char paused[] PROGMEM = MSG_PRINT_PAUSED;
+  static const char printing[] PROGMEM = MSG_PRINTING;
+  static const char welcome[] PROGMEM = WELCOME_MSG;
+  const char *msg;
+  if (print_job_timer.isPaused())
+    msg = paused;
+  #if ENABLED(SDSUPPORT)
+    else if (card.sdprinting)
+      return lcd_setstatus(card.longFilename[0] ? card.longFilename : card.filename, true);
+  #endif
+  else if (print_job_timer.isRunning())
+    msg = printing;
+  else
+    msg = welcome;
+
+  lcd_setstatusPGM(msg, -1);
+}
 
 /**
  *
  * draw the kill screen
  *
  */
 void kill_screen(const char* lcd_msg) {
   lcd_init();
   lcd_setalertstatusPGM(lcd_msg);
   lcd_kill_screen();
@@ -778,21 +798,21 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #else
       UNUSED(duration); UNUSED(freq);
     #endif
   }
 
   void lcd_quick_feedback(const bool clear_buttons) {
-    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+    lcd_refresh();
     if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
 
     // Buzz and wait. The delay is needed for buttons to settle!
     lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
@@ -816,21 +836,21 @@ void kill_screen(const char* lcd_msg) {
   }
 
   #if ENABLED(SDSUPPORT)
 
     void lcd_sdcard_pause() {
       card.pauseSDPrint();
       print_job_timer.pause();
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M125"));
       #endif
-      lcd_setstatusPGM(PSTR(MSG_PRINT_PAUSED), -1);
+      lcd_reset_status();
     }
 
     void lcd_sdcard_resume() {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
@@ -3839,21 +3859,21 @@ void kill_screen(const char* lcd_msg) {
       void lcd_sd_refresh() {
         card.initsd();
         encoderTopLine = 0;
       }
     #endif
 
     void lcd_sd_updir() {
       encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
       encoderTopLine = 0;
       screen_changed = true;
-      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+      lcd_refresh();
     }
 
     /**
      *
      * "Print from SD" submenu
      *
      */
 
     #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
       uint32_t last_sdfile_encoderPosition = 0xFFFF;
@@ -4700,22 +4720,21 @@ void kill_screen(const char* lcd_msg) {
         if (editValue != NULL) *((_type*)editValue) = value; \
         if (liveEdit) (*callbackFunc)(); \
         if (lcd_clicked) lcd_goto_previous_menu(); \
       } \
       return use_click(); \
     } \
     void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
     void menu_edit_callback_ ## _name() { if (_menu_edit_ ## _name()) (*callbackFunc)(); } \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
       lcd_save_previous_screen(); \
-      \
-      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
+      lcd_refresh(); \
       \
       editLabel = pstr; \
       editValue = ptr; \
       minEditValue = minValue * _scale; \
       maxEditValue = maxValue * _scale - minEditValue; \
       encoderPosition = (*ptr) * _scale - minEditValue; \
     } \
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
       _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
       currentScreen = menu_edit_ ## _name; \
@@ -4841,37 +4860,38 @@ void kill_screen(const char* lcd_msg) {
 
   #if ENABLED(SDSUPPORT)
 
     void menu_action_sdfile(const char* filename, char* longFilename) {
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
         last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
       #endif
       UNUSED(longFilename);
       card.openAndPrintFile(filename);
       lcd_return_to_status();
+      lcd_reset_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderTopLine = 0;
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
       #if ENABLED(DOGLCD)
         drawing_screen = false;
       #endif
-      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+      lcd_refresh();
     }
 
   #endif // SDSUPPORT
 
-  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
+  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();
   }
 
 #endif // ULTIPANEL
 
 void lcd_init() {
 
   lcd_implementation_init();
@@ -5030,21 +5050,21 @@ void lcd_update() {
       if (sd_status) {
         safe_delay(1000); // some boards need a delay or the LCD won't show the new status
         card.initsd();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
         if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
-      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+      lcd_refresh();
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
         #endif
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   const millis_t ms = millis();
@@ -5275,21 +5295,21 @@ void lcd_finishstatus(const bool persist=false) {
   #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
     UNUSED(persist);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
     progress_bar_ms = millis();
     #if PROGRESS_MSG_EXPIRE > 0
       expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
     #endif
   #endif
-  lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+  lcd_refresh();
 
   #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
     previous_lcd_status_ms = millis();  //get status message to show up for a while
   #endif
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     status_scroll_pos = 0;
   #endif
 }
 

commit 11ab017dd06bb9d06435dc03469a799d53893493
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 21 19:41:26 2018 -0500

    Creality3D Power-Loss Recovery

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 106b805979..72edb5065f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -36,20 +36,24 @@
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
+
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
@@ -835,24 +839,84 @@ void kill_screen(const char* lcd_msg) {
       #endif
       lcd_reset_status();
     }
 
     bool abort_sd_printing; // =false
 
     void lcd_sdcard_stop() {
       abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
+
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        card.openJobRecoveryFile(false);
+        job_recovery_info.valid_head = job_recovery_info.valid_foot = 0;
+        (void)card.saveJobRecoveryInfo();
+        card.closeJobRecoveryFile();
+        job_recovery_commands_count = 0;
+      #endif
     }
 
   #endif // SDSUPPORT
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+
+    static void lcd_sdcard_recover_job() {
+      char cmd[20];
+
+      // Return to status now
+      lcd_return_to_status();
+
+      // Turn leveling off and home
+      enqueue_and_echo_commands_P(PSTR("M420 S0\nG28"
+        #if !IS_KINEMATIC
+          " X Y"
+        #endif
+      ));
+
+      // Restore the bed temperature
+      sprintf_P(cmd, PSTR("M190 S%i"), job_recovery_info.target_temperature_bed);
+      enqueue_and_echo_command(cmd);
+
+      // Restore all hotend temperatures
+      HOTEND_LOOP() {
+        sprintf_P(cmd, PSTR("M109 S%i"), job_recovery_info.target_temperature[e]);
+        enqueue_and_echo_command(cmd);
+      }
+
+      // Restore print cooling fan speeds
+      for (uint8_t i = 0; i < FAN_COUNT; i++) {
+        sprintf_P(cmd, PSTR("M106 P%i S%i"), i, job_recovery_info.fanSpeeds[i]);
+        enqueue_and_echo_command(cmd);
+      }
+
+      // Start draining the job recovery command queue
+      job_recovery_phase = JOB_RECOVERY_YES;
+
+      // Resume the print job timer
+      if (job_recovery_info.print_job_elapsed)
+        print_job_timer.resume(job_recovery_info.print_job_elapsed);
+
+      // Start getting commands from SD
+      card.startFileprint();
+    }
+
+    static void lcd_job_recovery_menu() {
+      defer_return_to_status = true;
+      START_MENU();
+      MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_recover_job);
+      MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+      END_MENU();
+    }
+
+  #endif // POWER_LOSS_RECOVERY
+
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
       //
       // ^ Main
       //
       MENU_BACK(MSG_MAIN);
@@ -5040,20 +5104,27 @@ void lcd_update() {
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
         #endif
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    if (job_recovery_commands_count && job_recovery_phase == JOB_RECOVERY_IDLE) {
+      lcd_goto_screen(lcd_job_recovery_menu);
+      job_recovery_phase = JOB_RECOVERY_MAYBE; // Waiting for a response
+    }
+  #endif
+
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if ENABLED(DOGLCD)
       || drawing_screen
     #endif
   ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)

commit 78ea4871f9916e859e8a7b45cc8d62612d382fd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 19 18:11:03 2018 -0500

    Fix up enqueue now functions
    
    …and apply to MALYAN_LCD.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bf2a6c87b8..106b805979 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1712,21 +1712,21 @@ void kill_screen(const char* lcd_msg) {
      * with idle() to make sure the command has been enqueued.
      */
     void lcd_enqueue_command(char * const cmd) {
       no_reentry = true;
       enqueue_and_echo_command_now(cmd);
       no_reentry = false;
     }
 
     void lcd_enqueue_commands_P(const char * const cmd) {
       no_reentry = true;
-      enqueue_and_echo_commands_P_now(cmd);
+      enqueue_and_echo_commands_now_P(cmd);
       no_reentry = false;
     }
 
   #endif
 
   #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
     void lcd_autostart_sd() {
       card.autostart_index = 0;
       card.setroot();

commit df2f24617bc110ee9fc19c1c60d1f83f8e1b8f6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 17 20:32:56 2018 -0500

    Use 0 as the bed position (not Z_MIN_POS)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0c25bc5b7c..bf2a6c87b8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1813,21 +1813,21 @@ void kill_screen(const char* lcd_msg) {
     // When G29 finishes the last move:
     // - Raise Z to the "manual probe height"
     // - Don't return until done.
     //
     // ** This blocks the command queue! **
     //
     void _lcd_level_bed_done() {
       if (!lcd_wait_for_move) {
         #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
           // Display "Done" screen and wait for moves to complete
-          line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
+          line_to_z(MANUAL_PROBE_HEIGHT);
           lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
         #endif
         lcd_goto_previous_menu_no_defer();
         lcd_completion_feedback();
       }
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
     }
 
     void _lcd_level_goto_next_point();

commit e4acd2c40ed78df699eddb6bb23f60cbb858a56b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 17 16:03:15 2018 -0500

    One fewer compare in _lcd_move_xyz

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 59b1221e52..0c25bc5b7c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2924,28 +2924,30 @@ void kill_screen(const char* lcd_msg) {
         if (axis != Z_AXIS) {
           max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
           min = -max;
         }
       #endif
 
       // Get the new position
       const float diff = float((int32_t)encoderPosition) * move_menu_scale;
       #if IS_KINEMATIC
         manual_move_offset += diff;
-        // Limit only when trying to move towards the limit
-        if ((int32_t)encoderPosition < 0) NOLESS(manual_move_offset, min - current_position[axis]);
-        if ((int32_t)encoderPosition > 0) NOMORE(manual_move_offset, max - current_position[axis]);
+        if ((int32_t)encoderPosition < 0)
+          NOLESS(manual_move_offset, min - current_position[axis]);
+        else
+          NOMORE(manual_move_offset, max - current_position[axis]);
       #else
         current_position[axis] += diff;
-        // Limit only when trying to move towards the limit
-        if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
-        if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
+        if ((int32_t)encoderPosition < 0)
+          NOLESS(current_position[axis], min);
+        else
+          NOMORE(current_position[axis], max);
       #endif
 
       manual_move_to_current(axis);
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     encoderPosition = 0;
     if (lcdDrawUpdate) {
       const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
         #if IS_KINEMATIC
           + manual_move_offset

commit 6c7a17dba6bc5b1912ff301f2e18d544badf504a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 15 18:27:54 2018 -0500

    Abort SD printing more safely (#10407)
    
    Allow the current command to complete when aborting an SD print, otherwise some commands (G28, G29, etc.) will cause trouble.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 242449ea60..59b1221e52 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -829,34 +829,24 @@ void kill_screen(const char* lcd_msg) {
     void lcd_sdcard_resume() {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
     }
 
+    bool abort_sd_printing; // =false
+
     void lcd_sdcard_stop() {
-      card.stopSDPrint(
-        #if SD_RESORT
-          true
-        #endif
-      );
-      clear_command_queue();
-      quickstop_stepper();
-      print_job_timer.stop();
-      thermalManager.disable_all_heaters();
-      #if FAN_COUNT > 0
-        for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
-      #endif
-      wait_for_heatup = false;
+      abort_sd_printing = true;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
     #include "../feature/caselight.h"
 

commit 6c535081ec6d35826a1bbb47ab060f95724de6a0
Author: KangDroid <hyunwoo286@gmail.com>
Date:   Fri Apr 13 14:24:09 2018 +0900

    [2.0.x] Add optional menu item to toggle software endstops (#10389)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4c59bdd62d..242449ea60 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3108,20 +3108,24 @@ void kill_screen(const char* lcd_msg) {
       lcd_synchronize();
     }
   #else
     #define _MOVE_XY_ALLOWED true
   #endif
 
   void lcd_move_menu() {
     START_MENU();
     MENU_BACK(MSG_PREPARE);
 
+    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
+      MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
+    #endif
+
     if (_MOVE_XYZ_ALLOWED) {
       if (_MOVE_XY_ALLOWED) {
         MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
         MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
       }
       #if ENABLED(DELTA)
         else
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 

commit 0535ebc4d258377446aab3394ae34f3c1869d7a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 12 22:45:47 2018 -0500

    MESH_BED_LEVELING before PROBE_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fbefa11391..4c59bdd62d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1854,24 +1854,24 @@ void kill_screen(const char* lcd_msg) {
         // Save the current Z position and move
         //
 
         // If done...
         if (++manual_probe_index >= total_probe_points) {
           //
           // The last G29 records the point and enables bed leveling
           //
           lcd_wait_for_move = true;
           lcd_goto_screen(_lcd_level_bed_done);
-          #if ENABLED(PROBE_MANUALLY)
-            enqueue_and_echo_commands_P(PSTR("G29 V1"));
-          #elif ENABLED(MESH_BED_LEVELING)
+          #if ENABLED(MESH_BED_LEVELING)
             enqueue_and_echo_commands_P(PSTR("G29 S2"));
+          #elif ENABLED(PROBE_MANUALLY)
+            enqueue_and_echo_commands_P(PSTR("G29 V1"));
           #endif
         }
         else
           _lcd_level_goto_next_point();
 
         return;
       }
 
       //
       // Encoder knob or keypad buttons adjust the Z position
@@ -1906,24 +1906,24 @@ void kill_screen(const char* lcd_msg) {
     }
 
     /**
      * Step 5: Initiate a move to the next point
      */
     void _lcd_level_goto_next_point() {
       lcd_goto_screen(_lcd_level_bed_moving);
 
       // G29 Records Z, moves, and signals when it pauses
       lcd_wait_for_move = true;
-      #if ENABLED(PROBE_MANUALLY)
-        enqueue_and_echo_commands_P(PSTR("G29 V1"));
-      #elif ENABLED(MESH_BED_LEVELING)
+      #if ENABLED(MESH_BED_LEVELING)
         enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
+      #elif ENABLED(PROBE_MANUALLY)
+        enqueue_and_echo_commands_P(PSTR("G29 V1"));
       #endif
     }
 
     /**
      * Step 4: Display "Click to Begin", wait for click
      *         Move to the first probe position
      */
     void _lcd_level_bed_homing_done() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
       if (use_click()) {

commit 12785583d0d79375b8b089c7b5fb2f118ea2cedd
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Fri Apr 13 03:22:29 2018 +0200

    [2.0.x] G33 MIN_STEPS_PER_SEGMENT (#10386)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 442caf6434..fbefa11391 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2714,21 +2714,21 @@ void kill_screen(const char* lcd_msg) {
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
     void lcd_move_z();
 
     void _man_probe_pt(const float &rx, const float &ry) {
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       do_blocking_move_to_xy(rx, ry);
 
       lcd_synchronize();
-      move_menu_scale = PROBE_MANUALLY_STEP;
+      move_menu_scale = max(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
       lcd_goto_screen(lcd_move_z);
     }
 
   #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
   #if ENABLED(DELTA_AUTO_CALIBRATION)
 
     float lcd_probe_pt(const float &rx, const float &ry) {
       _man_probe_pt(rx, ry);
       KEEPALIVE_STATE(PAUSED_FOR_USER);

commit c96412a78fbf7be0f1f4bca17edab49d8f1040bf
Author: Yunhui Fu <yhfudev@gmail.com>
Date:   Thu Apr 12 21:14:01 2018 -0400

    [2.0.x] UTF-8 language translation support (#10213)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c2cf1a1723..442caf6434 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4933,38 +4933,20 @@ void lcd_init() {
     slow_buttons = 0;
   #endif
 
   lcd_buttons_update();
 
   #if ENABLED(ULTIPANEL)
     encoderDiff = 0;
   #endif
 }
 
-int16_t lcd_strlen(const char* s) {
-  int16_t i = 0, j = 0;
-  while (s[i]) {
-    if (PRINTABLE(s[i])) j++;
-    i++;
-  }
-  return j;
-}
-
-int16_t lcd_strlen_P(const char* s) {
-  int16_t j = 0;
-  while (pgm_read_byte(s)) {
-    if (PRINTABLE(pgm_read_byte(s))) j++;
-    s++;
-  }
-  return j;
-}
-
 bool lcd_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
     next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }

commit 646aa20b433cbde61a849a2b79ddf1c0a13714ef
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 04:14:48 2018 +0200

    Overhaul of G33 Delta Calibration (#8822)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 69c014280c..c2cf1a1723 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2705,105 +2705,102 @@ void kill_screen(const char* lcd_msg) {
     //
     #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
       MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
     #endif
 
     END_MENU();
   }
 
   float move_menu_scale;
 
-  #if ENABLED(DELTA_CALIBRATION_MENU) || (ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE)
+  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
     void lcd_move_z();
 
     void _man_probe_pt(const float &rx, const float &ry) {
-      #if HAS_LEVELING
-        reset_bed_level(); // After calibration bed-level data is no longer valid
-      #endif
-
-      line_to_z((Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5);
-      current_position[X_AXIS] = rx;
-      current_position[Y_AXIS] = ry;
-      line_to_current_z();
-      line_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_xy(rx, ry);
 
       lcd_synchronize();
       move_menu_scale = PROBE_MANUALLY_STEP;
       lcd_goto_screen(lcd_move_z);
     }
 
-  #endif // DELTA_CALIBRATION_MENU || (DELTA_AUTO_CALIBRATION && !HAS_BED_PROBE)
+  #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
-  #if ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE
+  #if ENABLED(DELTA_AUTO_CALIBRATION)
 
     float lcd_probe_pt(const float &rx, const float &ry) {
       _man_probe_pt(rx, ry);
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       defer_return_to_status = true;
       wait_for_user = true;
       while (wait_for_user) idle();
       KEEPALIVE_STATE(IN_HANDLER);
       lcd_goto_previous_menu_no_defer();
       return current_position[Z_AXIS];
     }
 
-  #endif // DELTA_AUTO_CALIBRATION && !HAS_BED_PROBE
+  #endif // DELTA_AUTO_CALIBRATION
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
 
     void _lcd_calibrate_homing() {
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         lcd_goto_previous_menu();
     }
 
     void _lcd_delta_calibrate_home() {
-      #if HAS_LEVELING
-        reset_bed_level(); // After calibration bed-level data is no longer valid
-      #endif
-
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
     void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
     void _goto_center()  { _man_probe_pt(0,0); }
 
   #endif // DELTA_CALIBRATION_MENU
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
+    void _recalc_delta_settings() {
+      #if HAS_LEVELING
+        reset_bed_level(); // After changing kinematics bed-level data is no longer valid
+      #endif
+      recalc_delta_settings();
+    }
+
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, recalc_delta_settings);
-      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, _recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, _recalc_delta_settings);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
+        MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
         #if ENABLED(EEPROM_SETTINGS)
           MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
           MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         #endif
       #endif
       MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
       #if ENABLED(DELTA_CALIBRATION_MENU)
         MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
         if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
           MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
@@ -4583,21 +4580,21 @@ void kill_screen(const char* lcd_msg) {
       #endif
       #ifdef MSG_FILAMENT_CHANGE_PURGE_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
         #define _FC_LINES_G (__FC_LINES_G + 1)
       #else
         #define _FC_LINES_G __FC_LINES_G
       #endif
       #if LCD_HEIGHT > _FC_LINES_G + 1
         STATIC_ITEM(" ");
       #endif
-      HOTEND_STATUS_ITEM();                         
+      HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
       void lcd_advanced_pause_continuous_purge_menu() {
         START_SCREEN();
         STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
         #ifdef MSG_FILAMENT_CHANGE_PURGE_2
           STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
           #define __FC_LINES_G 3
@@ -4638,21 +4635,21 @@ void kill_screen(const char* lcd_msg) {
         case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
         case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
         case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
         case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
         case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
         case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
         case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
         case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
                                             return lcd_advanced_pause_option_menu;
         #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-          case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return lcd_advanced_pause_continuous_purge_menu;                                                                                              
+          case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return lcd_advanced_pause_continuous_purge_menu;
         #endif
         case ADVANCED_PAUSE_MESSAGE_STATUS:
         default: break;
       }
       return NULL;
     }
 
     void lcd_advanced_pause_show_message(
       const AdvancedPauseMessage message,
       const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,

commit 2fa0a73c2ce89b11b20a8126490555df38180516
Author: Sean <noingwhat@gmail.com>
Date:   Tue Mar 20 11:33:01 2018 -0700

    Implement filament change continuous purge

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 03495ab76d..69c014280c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -211,28 +211,20 @@ uint16_t max_display_update_time = 0;
   #if ENABLED(LED_CONTROL_MENU)
     void lcd_led_menu();
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
       void lcd_change_filament_menu();
     #else
       void lcd_temp_menu_e0_filament_change();
     #endif
-    void lcd_advanced_pause_option_menu();
-    void lcd_advanced_pause_init_message();
-    void lcd_advanced_pause_unload_message();
-    void lcd_advanced_pause_insert_message();
-    void lcd_advanced_pause_load_message();
-    void lcd_advanced_pause_heat_nozzle();
-    void lcd_advanced_pause_purge_message();
-    void lcd_advanced_pause_resume_message();
   #endif
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     void dac_driver_commit();
     void dac_driver_getValues();
     void lcd_dac_menu();
     void lcd_dac_write_eeprom();
   #endif
 
   #if ENABLED(FWRETRACT)
@@ -4591,24 +4583,49 @@ void kill_screen(const char* lcd_msg) {
       #endif
       #ifdef MSG_FILAMENT_CHANGE_PURGE_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
         #define _FC_LINES_G (__FC_LINES_G + 1)
       #else
         #define _FC_LINES_G __FC_LINES_G
       #endif
       #if LCD_HEIGHT > _FC_LINES_G + 1
         STATIC_ITEM(" ");
       #endif
-      HOTEND_STATUS_ITEM();
+      HOTEND_STATUS_ITEM();                         
       END_SCREEN();
     }
 
+    #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+      void lcd_advanced_pause_continuous_purge_menu() {
+        START_SCREEN();
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
+        #ifdef MSG_FILAMENT_CHANGE_PURGE_2
+          STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
+          #define __FC_LINES_G 3
+        #else
+          #define __FC_LINES_G 2
+        #endif
+        #ifdef MSG_FILAMENT_CHANGE_PURGE_3
+          STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
+          #define _FC_LINES_G (__FC_LINES_G + 1)
+        #else
+          #define _FC_LINES_G __FC_LINES_G
+        #endif
+        #if LCD_HEIGHT > _FC_LINES_G + 1
+          STATIC_ITEM(" ");
+        #endif
+        HOTEND_STATUS_ITEM();
+        STATIC_ITEM(MSG_USERWAIT);
+        END_SCREEN();
+      }
+    #endif
+
     void lcd_advanced_pause_resume_message() {
       START_SCREEN();
       STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
       #ifdef MSG_FILAMENT_CHANGE_RESUME_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
       #endif
       #ifdef MSG_FILAMENT_CHANGE_RESUME_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
       #endif
@@ -4620,20 +4637,23 @@ void kill_screen(const char* lcd_msg) {
         case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
         case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
         case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
         case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
         case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
         case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
         case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
         case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
         case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
                                             return lcd_advanced_pause_option_menu;
+        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+          case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return lcd_advanced_pause_continuous_purge_menu;                                                                                              
+        #endif
         case ADVANCED_PAUSE_MESSAGE_STATUS:
         default: break;
       }
       return NULL;
     }
 
     void lcd_advanced_pause_show_message(
       const AdvancedPauseMessage message,
       const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
       const uint8_t extruder/*=active_extruder*/

commit adcb87f0db47672c28cfec9fda3354adac81fa99
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 1 23:54:12 2018 -0500

    Z Endstop Servo => Z Probe Servo

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 53febec5e1..03495ab76d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -886,24 +886,24 @@ void kill_screen(const char* lcd_msg) {
      *
      * "BLTouch" submenu
      *
      */
     static void bltouch_menu() {
       START_MENU();
       //
       // ^ Main
       //
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
-      MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
       END_MENU();
     }
 
   #endif // BLTOUCH
 
   #if ENABLED(LCD_PROGRESS_BAR_TEST)
 
     static void progress_bar_test() {
       static int8_t bar_percent = 0;
       if (use_click()) {
@@ -2679,23 +2679,23 @@ void kill_screen(const char* lcd_msg) {
         MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
         MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
       #endif
 
     #endif // TEMP_SENSOR_0 != 0
 
     //
     // BLTouch Self-Test and Reset
     //
     #if ENABLED(BLTOUCH)
-      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
       if (!endstops.z_probe_enabled && TEST_BLTOUCH())
-        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
     #endif
 
     //
     // Switch power on/off
     //
     #if HAS_POWER_SWITCH
       if (powersupply_on)
         MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
       else
         MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));

commit 6098efcc590790a463d595f0f338f1563399dab0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 31 20:03:09 2018 -0500

    Use float62 for LCD edit of Z Fade

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a070467159..53febec5e1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1333,21 +1333,21 @@ void kill_screen(const char* lcd_msg) {
     //
     // Speed:
     //
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
 
     // Manual bed leveling, Bed Z:
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
     #endif
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
@@ -2552,21 +2552,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_BACK(MSG_PREPARE);
       MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
       MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
       MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
       MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
       MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
       MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
   /**
    *
    * "Prepare" submenu
    *

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0564126410..a070467159 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1878,21 +1878,20 @@ void kill_screen(const char* lcd_msg) {
         else
           _lcd_level_goto_next_point();
 
         return;
       }
 
       //
       // Encoder knob or keypad buttons adjust the Z position
       //
       if (encoderPosition) {
-        gcode.refresh_cmd_timeout();
         const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
         line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5));
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
         encoderPosition = 0;
       }
 
       //
       // Draw on first display, then only on Z change
       //
       if (lcdDrawUpdate) {
@@ -2402,39 +2401,35 @@ void kill_screen(const char* lcd_msg) {
     void _lcd_do_nothing() {}
     void _lcd_hard_stop() {
       stepper.quick_stop();
       const screenFunc_t old_screen = currentScreen;
       currentScreen = _lcd_do_nothing;
       while (planner.movesplanned()) idle();
       currentScreen = old_screen;
       stepper.cleaning_buffer_counter = 0;
       set_current_from_steppers_for_axis(ALL_AXES);
       sync_plan_position();
-      gcode.refresh_cmd_timeout();
     }
 
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
       if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
-        if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM)
-          step_scaler = 0;
-        gcode.refresh_cmd_timeout();
-
+        if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
       // Encoder to the right (++)
       if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
       if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
 
       // Encoder to the left (--)
       if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
@@ -2902,21 +2897,20 @@ void kill_screen(const char* lcd_msg) {
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
-      gcode.refresh_cmd_timeout();
 
       // Start with no limits to movement
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       // Limit to software endstops, if enabled
       #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
         if (soft_endstops_enabled) switch (axis) {
           case X_AXIS:
             #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)

commit fbdc5ad962e83e7b6431d3c831f2c35f5244a030
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 18:57:54 2018 -0500

    Prevent lcd_update stack overflow on SD Card change

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 56255fb959..0564126410 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5028,31 +5028,33 @@ void lcd_update() {
       }
     #endif
 
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
+      bool old_sd_status = lcd_sd_status; // prevent re-entry to this block!
+      lcd_sd_status = sd_status;
+
       if (sd_status) {
         safe_delay(1000); // some boards need a delay or the LCD won't show the new status
         card.initsd();
-        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
+        if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
-        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
+        if (old_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
-      lcd_sd_status = sd_status;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
         #endif
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 

commit f1327fd5f90e0b0fc9d4f808266f4c1b4ff5d8ae
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 00:50:15 2018 -0500

    Use lcd_goto_previous_menu_no_defer more

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b2ceb71b7b..56255fb959 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1834,23 +1834,22 @@ void kill_screen(const char* lcd_msg) {
     //
     // ** This blocks the command queue! **
     //
     void _lcd_level_bed_done() {
       if (!lcd_wait_for_move) {
         #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
           // Display "Done" screen and wait for moves to complete
           line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
           lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
         #endif
-        lcd_goto_previous_menu();
+        lcd_goto_previous_menu_no_defer();
         lcd_completion_feedback();
-        defer_return_to_status = false;
       }
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
     }
 
     void _lcd_level_goto_next_point();
 
     /**
      * Step 7: Get the Z coordinate, click goes to the next point or exits
      */
@@ -2900,21 +2899,21 @@ void kill_screen(const char* lcd_msg) {
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
-    if (use_click()) { return lcd_goto_previous_menu(); }
+    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
       gcode.refresh_cmd_timeout();
 
       // Start with no limits to movement
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       // Limit to software endstops, if enabled
       #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
@@ -2983,21 +2982,21 @@ void kill_screen(const char* lcd_msg) {
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       const int8_t eindex=-1
     #endif
   ) {
-    if (use_click()) { return lcd_goto_previous_menu(); }
+    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       if (!processing_manual_move) {
         const float diff = float((int32_t)encoderPosition) * move_menu_scale;
         #if IS_KINEMATIC
           manual_move_offset += diff;
         #else
           current_position[E_AXIS] += diff;
         #endif
         manual_move_to_current(E_AXIS

commit 51ebdf3b7d55cb8ae76bad4d1181c20aca31467b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 11 04:38:53 2018 -0500

    Finish scroll_screen with menu direction/multiplier
    
    Fixes #10041

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a5137c0094..b2ceb71b7b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -383,40 +383,20 @@ uint16_t max_display_update_time = 0;
   #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
     #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
     #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #else // !ENCODER_RATE_MULTIPLIER
     #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
     #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #endif // !ENCODER_RATE_MULTIPLIER
 
-  /**
-   * START_SCREEN_OR_MENU generates init code for a screen or menu
-   *
-   *   encoderLine is the position based on the encoder
-   *   encoderTopLine is the top menu line to display
-   *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
-   *   _menuLineNr is the menu item to draw and process
-   *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
-   *   screen_items is the total number of items in the menu (after one call)
-   */
-  #define START_SCREEN_OR_MENU(LIMIT) \
-    ENCODER_DIRECTION_MENUS(); \
-    ENCODER_RATE_MULTIPLY(false); \
-    if (encoderPosition > 0x8000) encoderPosition = 0; \
-    if (first_page) encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM); \
-    if (screen_items > 0 && encoderLine >= screen_items - (LIMIT)) { \
-      encoderLine = max(0, screen_items - (LIMIT)); \
-      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
-    }
-
   #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
     for (int8_t _lcdLineNr = 0; _lcdLineNr < menu_bottom; _lcdLineNr++, _menuLineNr++) { \
       _thisItemNr = 0
 
   /**
    * START_SCREEN  Opening code for a screen having only static items.
    *               Do simplified scrolling of the entire screen.
    *
    * START_MENU    Opening code for a screen with menu items.
@@ -635,23 +615,32 @@ uint16_t max_display_update_time = 0;
       lcd_return_to_status();
   }
 
   void lcd_goto_previous_menu_no_defer() {
     defer_return_to_status = false;
     lcd_goto_previous_menu();
   }
 
   /**
    * Scrolling for menus and other line-based screens
+   *
+   *   encoderLine is the position based on the encoder
+   *   encoderTopLine is the top menu line to display
+   *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
+   *   _menuLineNr is the menu item to draw and process
+   *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+   *   screen_items is the total number of items in the menu (after one call)
    */
   int8_t encoderLine, screen_items;
   void scroll_screen(const uint8_t limit, const bool is_menu) {
+    ENCODER_DIRECTION_MENUS();
+    ENCODER_RATE_MULTIPLY(false);
     if (encoderPosition > 0x8000) encoderPosition = 0;
     if (first_page) {
       encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
       screen_changed = false;
     }
     if (screen_items > 0 && encoderLine >= screen_items - limit) {
       encoderLine = max(0, screen_items - limit);
       encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
     }
     if (is_menu) {

commit 3c2bfa5e533b9f1d659baec30770f6e274cb539e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 8 18:56:47 2018 -0600

    Update powersupply_on in power_on/off (#10015)
    
    Fix #10004

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 40c1339d4c..a5137c0094 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -168,24 +168,20 @@ uint16_t max_display_update_time = 0;
   #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
   uint8_t driverPercent[XYZE];
 #endif
 
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
-  #if HAS_POWER_SWITCH
-    extern bool powersupply_on;
-  #endif
-
   bool no_reentry = false;
   constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
 
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();

commit 1913c37a910916da0e59805f4a7623c32fda74ae
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 8 00:48:57 2018 -0600

    Tweak to manual move eindex arg

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6afbb14463..40c1339d4c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2895,21 +2895,21 @@ void kill_screen(const char* lcd_msg) {
       #endif
     }
   }
 
   /**
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */
   inline void manual_move_to_current(AxisEnum axis
     #if E_MANUAL > 1
-      , int8_t eindex=-1
+      , const int8_t eindex=-1
     #endif
   ) {
     #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
       #if E_MANUAL > 1
         if (axis == E_AXIS)
       #endif
           manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
     manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
@@ -2995,21 +2995,21 @@ void kill_screen(const char* lcd_msg) {
         #endif
       , axis);
       lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
-      int8_t eindex=-1
+      const int8_t eindex=-1
     #endif
   ) {
     if (use_click()) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       if (!processing_manual_move) {
         const float diff = float((int32_t)encoderPosition) * move_menu_scale;
         #if IS_KINEMATIC
           manual_move_offset += diff;
         #else

commit 03e30113320c1ddeab6ae42f323b367e8a8c8f50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 21:56:37 2018 -0600

    Fix compile error with MAX_MESSAGE_LENGTH
    
    Fix #9988

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b7f65ddba5..6afbb14463 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -85,21 +85,25 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
     static void lcd_babystep_zoffset();
   #else
     static void lcd_babystep_z();
   #endif
 #endif
 
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
-  #define MAX_MESSAGE_LENGTH max(CHARSIZE * 2 * (LCD_WIDTH), LONG_FILENAME_LENGTH)
+  #if LONG_FILENAME_LENGTH > CHARSIZE * 2 * (LCD_WIDTH)
+    #define MAX_MESSAGE_LENGTH LONG_FILENAME_LENGTH
+  #else
+    #define MAX_MESSAGE_LENGTH CHARSIZE * 2 * (LCD_WIDTH)
+  #endif
   uint8_t status_scroll_pos = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif

commit be0e100fedb28ea01f6f2085bb67ebc88d428291
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 16:50:43 2018 -0600

    Fix sd subdirectory encoder position
    
    Followup to 7e386c7

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index efba5c3338..b7f65ddba5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4855,21 +4855,21 @@ void kill_screen(const char* lcd_msg) {
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderTopLine = 0;
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
       #if ENABLED(DOGLCD)
-        first_page = false;
+        drawing_screen = false;
       #endif
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
   #endif // SDSUPPORT
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();

commit 0149680f541513bac9d71f6e3249739434ae8872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 16:25:25 2018 -0600

    Fix compile error with char LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7294777f3f..efba5c3338 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4854,21 +4854,23 @@ void kill_screen(const char* lcd_msg) {
       card.openAndPrintFile(filename);
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderTopLine = 0;
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
-      first_page = false;
+      #if ENABLED(DOGLCD)
+        first_page = false;
+      #endif
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
   #endif // SDSUPPORT
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();
   }

commit 7e386c7e9879101e7dbf19ceb179a132f73f412f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 05:22:49 2018 -0600

    Fix encoder position for sddirectory

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 06c641b4a9..7294777f3f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4854,20 +4854,21 @@ void kill_screen(const char* lcd_msg) {
       card.openAndPrintFile(filename);
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderTopLine = 0;
       encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
+      first_page = false;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
   #endif // SDSUPPORT
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();
   }

commit 22a017a856df6cea7ab387656a57ac03e6b6ef64
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 7 01:42:11 2018 -0600

    Rebuild SD file sort array on Stop SD Print (#9976)
    
    Thanks Chuck Hellebuyck.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index da97724682..06c641b4a9 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -849,21 +849,25 @@ void kill_screen(const char* lcd_msg) {
       #if ENABLED(PARK_HEAD_ON_PAUSE)
         enqueue_and_echo_commands_P(PSTR("M24"));
       #else
         card.startFileprint();
         print_job_timer.start();
       #endif
       lcd_reset_status();
     }
 
     void lcd_sdcard_stop() {
-      card.stopSDPrint();
+      card.stopSDPrint(
+        #if SD_RESORT
+          true
+        #endif
+      );
       clear_command_queue();
       quickstop_stepper();
       print_job_timer.stop();
       thermalManager.disable_all_heaters();
       #if FAN_COUNT > 0
         for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
       #endif
       wait_for_heatup = false;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();

commit f9cafc4001167c7a8b6ea625678be2e6d6cf26f0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 5 23:05:15 2018 -0600

    Fix menu highlight glitch, tweak scrolling code (#9957)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 28eae6852c..da97724682 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -147,39 +147,43 @@ char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 
 // The main status screen
 void lcd_status_screen();
 
 millis_t next_lcd_update_ms;
 
 uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
 uint16_t max_display_update_time = 0;
 
 #if ENABLED(DOGLCD)
-  bool drawing_screen = false;
+  bool drawing_screen, // = false
+       first_page;
+#else
+  constexpr bool first_page = true;
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
   uint8_t driverPercent[XYZE];
 #endif
 
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   #if HAS_POWER_SWITCH
     extern bool powersupply_on;
   #endif
 
   bool no_reentry = false;
+  constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
 
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
@@ -387,68 +391,61 @@ uint16_t max_display_update_time = 0;
   #endif // !ENCODER_RATE_MULTIPLIER
 
   /**
    * START_SCREEN_OR_MENU generates init code for a screen or menu
    *
    *   encoderLine is the position based on the encoder
    *   encoderTopLine is the top menu line to display
    *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
    *   _menuLineNr is the menu item to draw and process
    *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
-   *   _countedItems is the total number of items in the menu (after one call)
+   *   screen_items is the total number of items in the menu (after one call)
    */
   #define START_SCREEN_OR_MENU(LIMIT) \
     ENCODER_DIRECTION_MENUS(); \
     ENCODER_RATE_MULTIPLY(false); \
     if (encoderPosition > 0x8000) encoderPosition = 0; \
-    static int8_t _countedItems = 0; \
-    int8_t encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM); \
-    if (_countedItems > 0 && encoderLine >= _countedItems - (LIMIT)) { \
-      encoderLine = max(0, _countedItems - (LIMIT)); \
+    if (first_page) encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM); \
+    if (screen_items > 0 && encoderLine >= screen_items - (LIMIT)) { \
+      encoderLine = max(0, screen_items - (LIMIT)); \
       encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
     }
 
   #define SCREEN_OR_MENU_LOOP() \
     int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
-    for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT - (TALL_FONT_CORRECTION); _lcdLineNr++, _menuLineNr++) { \
+    for (int8_t _lcdLineNr = 0; _lcdLineNr < menu_bottom; _lcdLineNr++, _menuLineNr++) { \
       _thisItemNr = 0
 
   /**
    * START_SCREEN  Opening code for a screen having only static items.
    *               Do simplified scrolling of the entire screen.
    *
    * START_MENU    Opening code for a screen with menu items.
    *               Scroll as-needed to keep the selected line in view.
    */
   #define START_SCREEN() \
-    START_SCREEN_OR_MENU(LCD_HEIGHT - (TALL_FONT_CORRECTION)); \
-    encoderTopLine = encoderLine; \
+    scroll_screen(menu_bottom, false); \
     bool _skipStatic = false; \
     SCREEN_OR_MENU_LOOP()
 
   #define START_MENU() \
-    START_SCREEN_OR_MENU(1); \
-    screen_changed = false; \
-    NOMORE(encoderTopLine, encoderLine); \
-    if (encoderLine >= encoderTopLine + LCD_HEIGHT - (TALL_FONT_CORRECTION)) { \
-      encoderTopLine = encoderLine - (LCD_HEIGHT - (TALL_FONT_CORRECTION) - 1); \
-    } \
+    scroll_screen(1, true); \
     bool _skipStatic = true; \
     SCREEN_OR_MENU_LOOP()
 
   #define END_SCREEN() \
     } \
-    _countedItems = _thisItemNr
+    screen_items = _thisItemNr
 
   #define END_MENU() \
     } \
-    _countedItems = _thisItemNr; \
+    screen_items = _thisItemNr; \
     UNUSED(_skipStatic)
 
   ////////////////////////////////////////////
   ///////////// Global Variables /////////////
   ////////////////////////////////////////////
 
   /**
    * REVERSE_MENU_DIRECTION
    *
    * To reverse the menu direction we need a general way to reverse
@@ -636,20 +633,43 @@ uint16_t max_display_update_time = 0;
     }
     else
       lcd_return_to_status();
   }
 
   void lcd_goto_previous_menu_no_defer() {
     defer_return_to_status = false;
     lcd_goto_previous_menu();
   }
 
+  /**
+   * Scrolling for menus and other line-based screens
+   */
+  int8_t encoderLine, screen_items;
+  void scroll_screen(const uint8_t limit, const bool is_menu) {
+    if (encoderPosition > 0x8000) encoderPosition = 0;
+    if (first_page) {
+      encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
+      screen_changed = false;
+    }
+    if (screen_items > 0 && encoderLine >= screen_items - limit) {
+      encoderLine = max(0, screen_items - limit);
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
+    }
+    if (is_menu) {
+      NOMORE(encoderTopLine, encoderLine);
+      if (encoderLine >= encoderTopLine + menu_bottom)
+        encoderTopLine = encoderLine - menu_bottom + 1;
+    }
+    else
+      encoderTopLine = encoderLine;
+  }
+
 #endif // ULTIPANEL
 
 /**
  *
  * "Info Screen"
  *
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 void lcd_status_screen() {
@@ -778,24 +798,21 @@ void kill_screen(const char* lcd_msg) {
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #else
       UNUSED(duration); UNUSED(freq);
     #endif
   }
 
   void lcd_quick_feedback(const bool clear_buttons) {
     lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-
-    if (clear_buttons)
-      buttons = 0;
-
+    if (clear_buttons) buttons = 0;
     next_button_update_ms = millis() + 500;
 
     // Buzz and wait. The delay is needed for buttons to settle!
     lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   }
@@ -3225,21 +3242,20 @@ void kill_screen(const char* lcd_msg) {
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
-      // please don't remove the "(int16_t*)" - it's needed for the VIKI2 display  --- see PR #9132 before changing it
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
@@ -5186,25 +5202,26 @@ void lcd_update() {
           #endif
           const bool do_u8g_loop = !in_status;
           lcd_in_status(in_status);
           if (in_status) lcd_status_screen();
         #else
           constexpr bool do_u8g_loop = true;
         #endif
         if (do_u8g_loop) {
           if (!drawing_screen) {                        // If not already drawing pages
             u8g.firstPage();                            // Start the first page
-            drawing_screen = 1;                         // Flag as drawing pages
+            drawing_screen = first_page = true;         // Flag as drawing pages
           }
           lcd_setFont(FONT_MENU);                       // Setup font for every page draw
           u8g.setColorIndex(1);                         // And reset the color
           CURRENTSCREEN();                              // Draw and process the current screen
+          first_page = false;
 
           // The screen handler can clear drawing_screen for an action that changes the screen.
           // If still drawing and there's another page, update max-time and return now.
           // The nextPage will already be set up on the next call.
           if (drawing_screen && (drawing_screen = u8g.nextPage())) {
             NOLESS(max_display_update_time, millis() - ms);
             return;
           }
         }
       #else
@@ -5373,23 +5390,25 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if ENABLED(NEWPANEL)
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
+
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
+
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
         #if BUTTON_EXISTS(BACK)
           if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
         #endif
 
         //
         // Directional buttons
         //

commit 2d1233b86c21c19070fa000f2d298f6684e457ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 28 20:21:33 2018 -0600

    Fix lcd_quick_feedback call for BTN_BACK

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 17cec7c9e0..28eae6852c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5005,21 +5005,21 @@ void lcd_update() {
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback(true);        //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
 
     #if BUTTON_EXISTS(BACK)
       if (LCD_BACK_CLICKED) {
-        lcd_quick_feedback();
+        lcd_quick_feedback(true);
         lcd_goto_previous_menu();
       }
     #endif
 
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {

commit 8bffb26c23a252e74e079350e549cc11276571aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 28 17:33:23 2018 -0600

    Fix manual move position display
    
    Manual moves now correctly include the workspace offset.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index edc3214dcc..17cec7c9e0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2957,25 +2957,25 @@ void kill_screen(const char* lcd_msg) {
         // Limit only when trying to move towards the limit
         if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
         if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
       #endif
 
       manual_move_to_current(axis);
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     encoderPosition = 0;
     if (lcdDrawUpdate) {
-      const float pos = (processing_manual_move ? destination[axis] : current_position[axis]
+      const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
-      );
+      , axis);
       lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       int8_t eindex=-1
     #endif

commit 35ec67885a39d1c5072b848e065f130066ce3274
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 26 22:52:57 2018 -0600

    Add support for BACK button (RADDS) (#9835)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7cca48e45a..edc3214dcc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4855,25 +4855,23 @@ void kill_screen(const char* lcd_msg) {
 #endif // ULTIPANEL
 
 void lcd_init() {
 
   lcd_implementation_init();
 
   #if ENABLED(NEWPANEL)
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
-
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
-
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
     #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
       SET_INPUT_PULLUP(SHIFT_OUT);
     #endif
 
@@ -5004,20 +5002,28 @@ void lcd_update() {
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback(true);        //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
+
+    #if BUTTON_EXISTS(BACK)
+      if (LCD_BACK_CLICKED) {
+        lcd_quick_feedback();
+        lcd_goto_previous_menu();
+      }
+    #endif
+
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       if (sd_status) {
         safe_delay(1000); // some boards need a delay or the LCD won't show the new status
         card.initsd();
@@ -5367,28 +5373,29 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     static uint8_t lastEncoderBits;
     const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if ENABLED(NEWPANEL)
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
-
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
-
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
+        #if BUTTON_EXISTS(BACK)
+          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+        #endif
 
         //
         // Directional buttons
         //
         #if LCD_HAS_DIRECTIONAL_BUTTONS
 
           #if ENABLED(REVERSE_MENU_DIRECTION)
             #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
           #else
             #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM

commit eb079959fb320f99cfa885e576fed23e7aa3354f
Author: TheSFReader <TheSFReader@gmail.com>
Date:   Mon Feb 26 22:38:27 2018 +0100

    Report sd card progress [FR]  #9751 (#9832)
    
    * SD Status auto-report feature
    Feature Request #9751

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 12edd47166..7cca48e45a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2596,21 +2596,21 @@ void kill_screen(const char* lcd_msg) {
 
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       MENU_ITEM(submenu, MSG_UBL_LEVEL_BED,
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           _lcd_goto_ubl_level_bed
         #else
           _lcd_ubl_level_bed
-        #endif        
+        #endif
       );
     #elif ENABLED(LCD_BED_LEVELING)
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
           MENU_ITEM(submenu, MSG_BED_LEVELING,
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               _lcd_goto_bed_leveling
             #else
               lcd_bed_leveling

commit 43ff15244d06f04dc9ed3a914f474dba86d07af7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 23 19:34:11 2018 -0600

    Fix a progress bar condition

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7fcc653c3f..12edd47166 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -652,21 +652,21 @@ uint16_t max_display_update_time = 0;
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
-  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
+  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && ENABLED(SDSUPPORT) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
     // Progress bar % comes from SD when actively printing
     if (IS_SD_PRINTING)
       progress_bar_percent = card.percentDone();
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4a7e703924..7fcc653c3f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3221,21 +3221,21 @@ void kill_screen(const char* lcd_msg) {
 
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
+      MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
       // please don't remove the "(int16_t*)" - it's needed for the VIKI2 display  --- see PR #9132 before changing it
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
@@ -3735,21 +3735,21 @@ void kill_screen(const char* lcd_msg) {
     /**
      *
      * "Control" > "Filament" submenu
      *
      */
     void lcd_control_filament_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
 
       #if ENABLED(LIN_ADVANCE)
-        MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
+        MENU_ITEM_EDIT(float32, MSG_ADVANCE_K, &planner.extruder_advance_K, 0, 999);
       #endif
 
       #if DISABLED(NO_VOLUMETRICS)
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
         if (parser.volumetric_enabled) {
           #if EXTRUDERS == 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           #else // EXTRUDERS > 1
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);

commit 9c9cd54ef37772f0e325cda48e279b348ecf3089
Author: Studiodyne <diabolomix@hotmail.fr>
Date:   Fri Feb 23 07:29:58 2018 +0100

    Add Z Fade Height edit to UBL and Tune submenus (#9738)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d72e699198..4a7e703924 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -237,20 +237,25 @@ uint16_t max_display_update_time = 0;
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
     #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
   #endif
 
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    static float new_z_fade_height;
+    void _lcd_set_z_fade_height() { set_z_fade_height(new_z_fade_height); }
+  #endif
+
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
   void menu_action_gcode(const char* pgcode);
   void menu_action_function(menuAction_t data);
 
@@ -984,20 +989,27 @@ void kill_screen(const char* lcd_msg) {
     }
 
   #endif
 
   /**
    *
    * "Main" menu
    *
    */
 
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    void _lcd_goto_tune_menu() {
+      lcd_goto_screen(lcd_tune_menu);
+      new_z_fade_height = planner.z_fade_height;
+    }
+  #endif
+
   void lcd_main_menu() {
     START_MENU();
     MENU_BACK(MSG_WATCH);
 
     #if ENABLED(CUSTOM_USER_MENUS)
       MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
     #endif
 
     //
     // Debug Menu when certain options are enabled
@@ -1011,21 +1023,27 @@ void kill_screen(const char* lcd_msg) {
     //
     #if ENABLED(MENU_ITEM_CASE_LIGHT)
       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
         MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
       }
       else
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
     #endif
 
     if (planner.movesplanned() || IS_SD_PRINTING) {
-      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+      MENU_ITEM(submenu, MSG_TUNE,
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          _lcd_goto_tune_menu
+        #else
+          lcd_tune_menu
+        #endif
+      );
     }
     else {
       MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
     }
     MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
 
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
           if (card.sdprinting)
@@ -1304,21 +1322,23 @@ void kill_screen(const char* lcd_msg) {
 
     //
     // Speed:
     //
     MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
 
     // Manual bed leveling, Bed Z:
     #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
       MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
     #endif
-
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+    #endif
     //
     // Nozzle:
     // Nozzle [1-4]:
     //
     #if HOTENDS == 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
     #else // HOTENDS > 1
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
       #if HOTENDS > 2
@@ -1932,25 +1952,20 @@ void kill_screen(const char* lcd_msg) {
     void _lcd_level_bed_continue() {
       defer_return_to_status = true;
       axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
       lcd_goto_screen(_lcd_level_bed_homing);
       enqueue_and_echo_commands_P(PSTR("G28"));
     }
 
     static bool new_level_state;
     void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(new_level_state); }
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      static float new_z_fade_height;
-      void _lcd_set_z_fade_height() { set_z_fade_height(new_z_fade_height); }
-    #endif
-
     /**
      * Step 1: Bed Level entry-point
      *
      * << Prepare
      *    Auto Home           (if homing needed)
      *    Leveling On/Off     (if data exists, and homed)
      *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
      *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
      *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
      *    Level Bed >
@@ -1997,31 +2012,38 @@ void kill_screen(const char* lcd_msg) {
           MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
-    void _lcd_goto_bed_leveling() {
-      lcd_goto_screen(lcd_bed_leveling);
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      void _lcd_goto_bed_leveling() {
+        lcd_goto_screen(lcd_bed_leveling);
         new_z_fade_height = planner.z_fade_height;
-      #endif
-    }
+      }
+    #endif
 
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      void _lcd_goto_ubl_level_bed() {
+        lcd_goto_screen(_lcd_ubl_level_bed);
+        new_z_fade_height = planner.z_fade_height;
+      }
+    #endif
+
     static int16_t ubl_storage_slot = 0,
                custom_hotend_temp = 190,
                side_points = 3,
                ubl_fillin_amount = 5,
                ubl_height_amount = 1,
                n_edit_pts = 1,
                x_plot = 0,
                y_plot = 0;
 
     #if HAS_TEMP_BED
@@ -2525,20 +2547,23 @@ void kill_screen(const char* lcd_msg) {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
       MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
       MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
       MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
       MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
       MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
       MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
       MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
       MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      #endif
       END_MENU();
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
   /**
    *
    * "Prepare" submenu
    *
    */
@@ -2566,21 +2591,27 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
     #endif
 
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
+      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED,
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          _lcd_goto_ubl_level_bed
+        #else
+          _lcd_ubl_level_bed
+        #endif        
+      );
     #elif ENABLED(LCD_BED_LEVELING)
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
           MENU_ITEM(submenu, MSG_BED_LEVELING,
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               _lcd_goto_bed_leveling
             #else
               lcd_bed_leveling
             #endif

commit 532bb3aaa119d2d6ac6f5c31d33d5cc1aecd357b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Feb 14 14:43:54 2018 -0700

    Lightweight status screen for ST7920
    
    - This status screen uses the ST7920 character generator to greatly
      reduce SPI traffic and MCU load when updating the status screen.
    
    - Has been tested with the RepRapDiscount Full Graphics Smart Controller
      but should work with any LCD that uses an ST7920 or fully compatible
      controller.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5bf308d3cf..d72e699198 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5134,34 +5134,48 @@ void lcd_update() {
         buttons_reprapworld_keypad = 0;
       #endif
 
       #if ENABLED(ULTIPANEL)
         #define CURRENTSCREEN() (*currentScreen)()
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
 
       #if ENABLED(DOGLCD)
-        if (!drawing_screen) {                        // If not already drawing pages
-          u8g.firstPage();                            // Start the first page
-          drawing_screen = 1;                         // Flag as drawing pages
-        }
-        lcd_setFont(FONT_MENU);                       // Setup font for every page draw
-        u8g.setColorIndex(1);                         // And reset the color
-        CURRENTSCREEN();                              // Draw and process the current screen
-
-        // The screen handler can clear drawing_screen for an action that changes the screen.
-        // If still drawing and there's another page, update max-time and return now.
-        // The nextPage will already be set up on the next call.
-        if (drawing_screen && (drawing_screen = u8g.nextPage())) {
-          NOLESS(max_display_update_time, millis() - ms);
-          return;
+        #if ENABLED(LIGHTWEIGHT_UI)
+          #if ENABLED(ULTIPANEL)
+            const bool in_status = currentScreen == lcd_status_screen;
+          #else
+            constexpr bool in_status = true;
+          #endif
+          const bool do_u8g_loop = !in_status;
+          lcd_in_status(in_status);
+          if (in_status) lcd_status_screen();
+        #else
+          constexpr bool do_u8g_loop = true;
+        #endif
+        if (do_u8g_loop) {
+          if (!drawing_screen) {                        // If not already drawing pages
+            u8g.firstPage();                            // Start the first page
+            drawing_screen = 1;                         // Flag as drawing pages
+          }
+          lcd_setFont(FONT_MENU);                       // Setup font for every page draw
+          u8g.setColorIndex(1);                         // And reset the color
+          CURRENTSCREEN();                              // Draw and process the current screen
+
+          // The screen handler can clear drawing_screen for an action that changes the screen.
+          // If still drawing and there's another page, update max-time and return now.
+          // The nextPage will already be set up on the next call.
+          if (drawing_screen && (drawing_screen = u8g.nextPage())) {
+            NOLESS(max_display_update_time, millis() - ms);
+            return;
+          }
         }
       #else
         CURRENTSCREEN();
       #endif
 
       #if ENABLED(ULTIPANEL)
         lcd_clicked = false;
       #endif
 
       // Keeping track of the longest time for an individual LCD update.

commit 72f63a4980908257c9fdc9dc9749c976d4d9d19c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 21 19:25:50 2018 -0600

    Fix DOGM progress bar with LCD_SET_PROGRESS_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a5b82fcad6..5bf308d3cf 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -647,34 +647,34 @@ uint16_t max_display_update_time = 0;
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
 void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
+  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(DOGLCD))
+    // Progress bar % comes from SD when actively printing
+    if (IS_SD_PRINTING)
+      progress_bar_percent = card.percentDone();
+  #endif
+
   #if ENABLED(LCD_PROGRESS_BAR)
 
     //
     // HD44780 implements the following message blinking and
     // message expiration because Status Line and Progress Bar
     // share the same line on the display.
     //
 
-    // Set current percentage from SD when actively printing
-    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-      if (IS_SD_PRINTING)
-        progress_bar_percent = card.percentDone();
-    #endif
-
     millis_t ms = millis();
 
     // If the message will blink rather than expire...
     #if DISABLED(PROGRESS_MSG_ONCE)
       if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
     #endif
 
     #if PROGRESS_MSG_EXPIRE > 0
 

commit fc460fff941963a055862cc9299cc60fb5551d61
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 11:12:42 2018 -0600

    Extend menu items for SWITCHING_EXTRUDER
    
    Reference #5367

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7f3f9022a3..a5b82fcad6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3100,25 +3100,50 @@ void kill_screen(const char* lcd_msg) {
       #if ENABLED(DELTA)
         else
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 
       MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
     }
     else
       MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
 
-    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(DUAL_X_CARRIAGE)
+    #if ENABLED(SWITCHING_EXTRUDER)
+
+      #if EXTRUDERS == 4
+        switch (active_extruder) {
+          case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
+          case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
+          case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
+          case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
+        }
+      #elif EXTRUDERS == 3
+        if (active_extruder < 2) {
+          if (active_extruder)
+            MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+          else
+            MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+        }
+      #else
+        if (active_extruder)
+          MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+        else
+          MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+      #endif
+
+    #elif ENABLED(DUAL_X_CARRIAGE)
+
       if (active_extruder)
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
       else
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+
     #endif
 
     MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
     #if E_MANUAL > 1
       MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
       MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
       #if E_MANUAL > 2
         MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
         #if E_MANUAL > 3
           MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);

commit 25e3e62354591d1d5f461967e6521b9f52902394
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 10:09:08 2018 -0600

    Null-terminate lcd_status_message

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c4b6756d0e..7f3f9022a3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5165,20 +5165,21 @@ void lcd_update() {
       case LCDVIEW_CALL_NO_REDRAW:
       default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
 inline void pad_message_string() {
   uint8_t i = 0, j = 0;
   char c;
+  lcd_status_message[MAX_MESSAGE_LENGTH] = '\0';
   while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
     if (PRINTABLE(c)) j++;
     i++;
   }
   if (true
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
       && j < LCD_WIDTH
     #endif
   ) {
     // pad with spaces to fill up the line
@@ -5214,38 +5215,38 @@ void lcd_finishstatus(const bool persist=false) {
 }
 
 #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   void dontExpireStatus() { expire_status_ms = 0; }
 #endif
 
 bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
 
 void lcd_setstatus(const char * const message, const bool persist) {
   if (lcd_status_message_level > 0) return;
-  strncpy(lcd_status_message, message, COUNT(lcd_status_message) - 1);
+  strncpy(lcd_status_message, message, MAX_MESSAGE_LENGTH);
   lcd_finishstatus(persist);
 }
 
 void lcd_setstatusPGM(const char * const message, int8_t level) {
   if (level < 0) level = lcd_status_message_level = 0;
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
-  strncpy_P(lcd_status_message, message, COUNT(lcd_status_message) - 1);
+  strncpy_P(lcd_status_message, message, MAX_MESSAGE_LENGTH);
   lcd_finishstatus(level > 0);
 }
 
 void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
   va_list args;
   va_start(args, fmt);
-  vsnprintf_P(lcd_status_message, COUNT(lcd_status_message) - 1, fmt, args);
+  vsnprintf_P(lcd_status_message, MAX_MESSAGE_LENGTH, fmt, args);
   va_end(args);
   lcd_finishstatus(level > 0);
 }
 
 void lcd_setalertstatusPGM(const char * const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }

commit cff62042ee3dfa6e18a4b89c07c7995d9ad3692c
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Fri Feb 16 02:34:36 2018 -0600

    Fix LCD manual movement on kinematic machines (#9655)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 220955c81a..c4b6756d0e 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2811,21 +2811,24 @@ void kill_screen(const char* lcd_msg) {
         #endif
 
         // Set movement on a single axis
         set_destination_from_current();
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
         manual_move_offset = 0.0;
         manual_move_axis = (int8_t)NO_AXIS;
 
-        // Set a blocking flag so no new moves can be added until all segments are done
+        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
+        // move_to_destination. This will cause idle() to be called, which can then call this function while the
+        // previous invocation is being blocked. Modifications to manual_move_offset shouldn't be made while
+        // processing_manual_move is true or the planner will get out of sync.
         processing_manual_move = true;
         prepare_move_to_destination(); // will call set_current_from_destination()
         processing_manual_move = false;
 
         feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
@@ -2923,25 +2926,25 @@ void kill_screen(const char* lcd_msg) {
         // Limit only when trying to move towards the limit
         if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
         if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
       #endif
 
       manual_move_to_current(axis);
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     encoderPosition = 0;
     if (lcdDrawUpdate) {
-      const float pos = current_position[axis]
+      const float pos = (processing_manual_move ? destination[axis] : current_position[axis]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
-      ;
+      );
       lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       int8_t eindex=-1
     #endif

commit 93c0198b2dec4497c42d20cd01a6dac909416da7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 14 05:09:44 2018 -0600

    Init LCD welcome message programmatically

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fb85089a32..220955c81a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -91,21 +91,21 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #define MAX_MESSAGE_LENGTH max(CHARSIZE * 2 * (LCD_WIDTH), LONG_FILENAME_LENGTH)
   uint8_t status_scroll_pos = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
-char lcd_status_message[MAX_MESSAGE_LENGTH + 1] = WELCOME_MSG;
+char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)

commit e6b8207b03c68402cde002d45c39d5f9a67aacd3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 12 01:02:30 2018 -0600

    Restore welcome message

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 220955c81a..fb85089a32 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -91,21 +91,21 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   #define MAX_MESSAGE_LENGTH max(CHARSIZE * 2 * (LCD_WIDTH), LONG_FILENAME_LENGTH)
   uint8_t status_scroll_pos = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
-char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
+char lcd_status_message[MAX_MESSAGE_LENGTH + 1] = WELCOME_MSG;
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)

commit 299606e4ae7b896d1febc2f45cfafb5e7958bc99
Author: GMagician <3684609+GMagician@users.noreply.github.com>
Date:   Sat Feb 10 21:14:34 2018 +0100

    [2.0.x] Memory overflow protection (#9562)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d5b439e904..220955c81a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -85,21 +85,21 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
     static void lcd_babystep_zoffset();
   #else
     static void lcd_babystep_z();
   #endif
 #endif
 
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
-  #define MAX_MESSAGE_LENGTH max(2 * CHARSIZE * LCD_WIDTH, LONG_FILENAME_LENGTH)
+  #define MAX_MESSAGE_LENGTH max(CHARSIZE * 2 * (LCD_WIDTH), LONG_FILENAME_LENGTH)
   uint8_t status_scroll_pos = 0;
 #else
   #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
 char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
@@ -5211,38 +5211,38 @@ void lcd_finishstatus(const bool persist=false) {
 }
 
 #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   void dontExpireStatus() { expire_status_ms = 0; }
 #endif
 
 bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
 
 void lcd_setstatus(const char * const message, const bool persist) {
   if (lcd_status_message_level > 0) return;
-  strncpy(lcd_status_message, message, 3 * (LCD_WIDTH));
+  strncpy(lcd_status_message, message, COUNT(lcd_status_message) - 1);
   lcd_finishstatus(persist);
 }
 
 void lcd_setstatusPGM(const char * const message, int8_t level) {
   if (level < 0) level = lcd_status_message_level = 0;
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
-  strncpy_P(lcd_status_message, message, 3 * (LCD_WIDTH));
+  strncpy_P(lcd_status_message, message, COUNT(lcd_status_message) - 1);
   lcd_finishstatus(level > 0);
 }
 
 void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
   if (level < lcd_status_message_level) return;
   lcd_status_message_level = level;
   va_list args;
   va_start(args, fmt);
-  vsnprintf_P(lcd_status_message, 3 * (LCD_WIDTH), fmt, args);
+  vsnprintf_P(lcd_status_message, COUNT(lcd_status_message) - 1, fmt, args);
   va_end(args);
   lcd_finishstatus(level > 0);
 }
 
 void lcd_setalertstatusPGM(const char * const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }

commit 5a7088746755b46521d1342875cb2f49c40959fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 8 23:03:47 2018 -0600

    Size lcd_status_message based on language (#9545)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bbcf4156ef..d5b439e904 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -83,26 +83,30 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
   long babysteps_done = 0;
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     static void lcd_babystep_zoffset();
   #else
     static void lcd_babystep_z();
   #endif
 #endif
 
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
         lcd_status_message_level;    // Higher level blocks lower level
-char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
+  #define MAX_MESSAGE_LENGTH max(2 * CHARSIZE * LCD_WIDTH, LONG_FILENAME_LENGTH)
   uint8_t status_scroll_pos = 0;
+#else
+  #define MAX_MESSAGE_LENGTH CHARSIZE * (LCD_WIDTH)
 #endif
 
+char lcd_status_message[MAX_MESSAGE_LENGTH + 1];
+
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"

commit e5ee0b6f6c9a2236a460ca1cd104b9745d9c7a28
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 4 00:39:01 2018 -0600

    Implement MALYAN_LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 75950fd7dd..bbcf4156ef 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1201,35 +1201,35 @@ void kill_screen(const char* lcd_msg) {
       defer_return_to_status = true;
     }
 
     float lcd_mesh_edit() {
       lcd_goto_screen(_lcd_mesh_edit_NOP);
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
       return mesh_edit_value;
     }
 
-    void lcd_mesh_edit_setup(const float initial) {
+    void lcd_mesh_edit_setup(const float &initial) {
       mesh_edit_value = mesh_edit_accumulator = initial;
       lcd_goto_screen(_lcd_mesh_edit_NOP);
     }
 
     void _lcd_z_offset_edit() {
       _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
     }
 
     float lcd_z_offset_edit() {
       lcd_goto_screen(_lcd_z_offset_edit);
       return mesh_edit_value;
     }
 
-    void lcd_z_offset_edit_setup(float initial) {
+    void lcd_z_offset_edit_setup(const float &initial) {
       mesh_edit_value = mesh_edit_accumulator = initial;
       lcd_goto_screen(_lcd_z_offset_edit);
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
 
   /**
    * Watch temperature callbacks
    */

commit 2ea4e74ed317d80084645569d88b056ef24e56e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 4 17:39:32 2018 -0600

    Misc. comments

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2c14acd3f6..75950fd7dd 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5403,23 +5403,22 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     if (buttons & EN_B) enc |= B10;
     if (enc != lastEncoderBits) {
       switch (enc) {
         case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
         case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
         case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
         case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
       }
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (lcd_external_control) {
-          ubl.encoder_diff = encoderDiff;   // Make the encoder's rotation available to G29's Mesh Editor
-          encoderDiff = 0;                  // We are going to lie to the LCD Panel and claim the encoder
-                                            // knob has not turned.
+          ubl.encoder_diff = encoderDiff;   // Make encoder rotation available to UBL G29 mesh editing.
+          encoderDiff = 0;                  // Hide the encoder event from the current screen handler.
         }
       #endif
       lastEncoderBits = enc;
     }
   }
 
   #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
     bool lcd_detected() { return lcd.LcdDetected() == 1; }
   #else
     bool lcd_detected() { return true; }

commit 786746404b8aa58c44a93734afd61c701d2abecb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Feb 4 00:26:05 2018 -0600

    [2.0.x] Apply feedrate to nozzle movement for kinematic machines (#8778)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6d4fdd7ac6..2c14acd3f6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3504,23 +3504,23 @@ void kill_screen(const char* lcd_msg) {
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
     #endif
 
     // M203 / M205 Velocity options
     void lcd_control_motion_velocity_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
       // M203 Max Feedrate
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate_mm_s[X_AXIS], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate_mm_s[Y_AXIS], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate_mm_s[Z_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.max_feedrate_mm_s[A_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.max_feedrate_mm_s[B_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.max_feedrate_mm_s[C_AXIS], 1, 999);
 
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
         MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
         MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
         #if E_STEPPERS > 2
           MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
           #if E_STEPPERS > 3
             MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
             #if E_STEPPERS > 4
@@ -3549,23 +3549,23 @@ void kill_screen(const char* lcd_msg) {
       // M204 P Acceleration
       MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
 
       // M204 R Retract Acceleration
       MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
 
       // M204 T Travel Acceleration
       MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
 
       // M201 settings
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
 
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
         MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
         MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
         #if E_STEPPERS > 2
           MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
           #if E_STEPPERS > 3
             MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
             #if E_STEPPERS > 4
@@ -3578,40 +3578,40 @@ void kill_screen(const char* lcd_msg) {
       #endif
 
       END_MENU();
     }
 
     // M205 Jerk
     void lcd_control_motion_jerk_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
-      MENU_ITEM_EDIT(float3, MSG_VX_JERK, &planner.max_jerk[X_AXIS], 1, 990);
-      MENU_ITEM_EDIT(float3, MSG_VY_JERK, &planner.max_jerk[Y_AXIS], 1, 990);
+      MENU_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
+      MENU_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
       #if ENABLED(DELTA)
-        MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 1, 990);
+        MENU_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
       #else
-        MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 0.1, 990);
+        MENU_ITEM_EDIT(float52, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1, 990);
       #endif
       MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
 
       END_MENU();
     }
 
     // M92 Steps-per-mm
     void lcd_control_motion_steps_per_mm_menu() {
       START_MENU();
       MENU_BACK(MSG_MOTION);
 
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
 
       #if ENABLED(DISTINCT_E_FACTORS)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
         #if E_STEPPERS > 2
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
           #if E_STEPPERS > 3
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
             #if E_STEPPERS > 4

commit 79796b22ada24b08d1cda936455050a22fa83663
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 31 18:43:33 2018 -0600

    Fix up _Bootscreen.h and _Statusscreen.h

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e8f528ba11..6d4fdd7ac6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -13,21 +13,21 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
-#include "../inc/MarlinConfig.h"
+#include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(ULTRA_LCD)
 
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
@@ -4874,21 +4874,21 @@ int16_t lcd_strlen_P(const char* s) {
   }
   return j;
 }
 
 bool lcd_blink() {
   static uint8_t blink = 0;
   static millis_t next_blink_ms = 0;
   millis_t ms = millis();
   if (ELAPSED(ms, next_blink_ms)) {
     blink ^= 0xFF;
-    next_blink_ms = ms + 1000 - LCD_UPDATE_INTERVAL / 2;
+    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
   }
   return blink != 0;
 }
 
 /**
  * Update the LCD, read encoder buttons, etc.
  *   - Read button states
  *   - Check the SD Card slot state
  *   - Act on RepRap World keypad input
  *   - Update the encoder position

commit 61bf8478a2a10f083462f4292a44671b944bce0e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 04:29:29 2018 -0600

    Add hotEnough methods

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8366710a8f..e8f528ba11 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1395,21 +1395,21 @@ void kill_screen(const char* lcd_msg) {
       #else
         MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
       #endif
     #endif
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        if (!thermalManager.targetTooColdToExtrude(active_extruder))
+        if (thermalManager.targetHotEnoughToExtrude(active_extruder))
           MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
         else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
       #else
         MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
       #endif
     #endif
 
     END_MENU();
   }
@@ -2601,21 +2601,21 @@ void kill_screen(const char* lcd_msg) {
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (!IS_SD_FILE_OPEN) {
         #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-          if (!thermalManager.targetTooColdToExtrude(active_extruder))
+          if (thermalManager.targetHotEnoughToExtrude(active_extruder))
             MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
           else
             MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
         #else
           MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
         #endif
       }
     #endif // ADVANCED_PAUSE_FEATURE
 
     #if TEMP_SENSOR_0 != 0
@@ -4275,64 +4275,64 @@ void kill_screen(const char* lcd_msg) {
                       MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_load);
                     else
                       MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
                   #endif // E_STEPPERS > 4
                 #endif // E_STEPPERS > 3
               #endif // E_STEPPERS > 2
             #endif // E_STEPPERS == 1
 
             // Unload filament
             #if E_STEPPERS == 1
-              if (!thermalManager.targetTooColdToExtrude(active_extruder))
+              if (thermalManager.targetHotEnoughToExtrude(active_extruder))
                 MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
               else
                 MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, lcd_temp_menu_e0_filament_unload);
             #else
               #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
-                if (!thermalManager.targetTooColdToExtrude(0)
+                if (thermalManager.targetHotEnoughToExtrude(0)
                   #if E_STEPPERS > 1
-                    && !thermalManager.targetTooColdToExtrude(1)
+                    && thermalManager.targetHotEnoughToExtrude(1)
                     #if E_STEPPERS > 2
-                      && !thermalManager.targetTooColdToExtrude(2)
+                      && thermalManager.targetHotEnoughToExtrude(2)
                       #if E_STEPPERS > 3
-                        && !thermalManager.targetTooColdToExtrude(3)
+                        && thermalManager.targetHotEnoughToExtrude(3)
                         #if E_STEPPERS > 4
-                          && !thermalManager.targetTooColdToExtrude(4)
+                          && thermalManager.targetHotEnoughToExtrude(4)
                         #endif // E_STEPPERS > 4
                       #endif // E_STEPPERS > 3
                     #endif // E_STEPPERS > 2
                   #endif // E_STEPPERS > 1
                 )
                   MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
               else
                 MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, lcd_unload_filament_all_temp_menu);
               #endif
-              if (!thermalManager.targetTooColdToExtrude(0))
+              if (thermalManager.targetHotEnoughToExtrude(0))
                 MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
               else
                 MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, lcd_temp_menu_e0_filament_unload);
-              if (!thermalManager.targetTooColdToExtrude(1))
+              if (thermalManager.targetHotEnoughToExtrude(1))
                 MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
               else
                 MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, lcd_temp_menu_e1_filament_unload);
               #if E_STEPPERS > 2
-                if (!thermalManager.targetTooColdToExtrude(2))
+                if (thermalManager.targetHotEnoughToExtrude(2))
                   MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
                 else
                   MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, lcd_temp_menu_e2_filament_unload);
                 #if E_STEPPERS > 3
-                  if (!thermalManager.targetTooColdToExtrude(3))
+                  if (thermalManager.targetHotEnoughToExtrude(3))
                     MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
                   else
                     MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, lcd_temp_menu_e3_filament_unload);
                   #if E_STEPPERS > 4
-                    if (!thermalManager.targetTooColdToExtrude(4))
+                    if (thermalManager.targetHotEnoughToExtrude(4))
                       MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
                     else
                       MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, lcd_temp_menu_e4_filament_unload);
                   #endif // E_STEPPERS > 4
                 #endif // E_STEPPERS > 3
               #endif // E_STEPPERS > 2
             #endif // E_STEPPERS == 1
           }
         #endif
 

commit 719cd53e09b59da9e79a2a627cf485dd2143ff7c
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Fri Jan 19 19:32:46 2018 +0100

    Standardized max temp values
    
    Everywhere in menu items temperatures are "defined value" subtracted by 15.
    In one place is subtracted by 5

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b7bd1fccea..8366710a8f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2045,21 +2045,21 @@ void kill_screen(const char* lcd_msg) {
      * << Build Mesh
      *    Hotend Temp: ---
      *    Bed Temp: ---
      *    Build Custom Mesh
      */
     void _lcd_ubl_custom_mesh() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
       MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_HOTEND_TEMP, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
       #if HAS_TEMP_BED
-        MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_BED_TEMP, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 5));
+        MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_BED_TEMP, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
       #endif
       MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];

commit f5f1b069ade516793995870bac4d6707cff43407
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jan 16 11:08:00 2018 -0600

    Convert UBL mesh tilting to all use the same algorithm  (#9204)
    
    A number of regressions were patched also. The UBL G29 P2 and P4 Press and Hold had stopped working. It is very possible this is broken in the bugfix_v1.1.x branch also.
    
    The main purpose of the Pull Request is to get the 3-Point mesh tilting to use the LSF algorithm just like the grid based mesh tilt. This simplifies the logic and reduces the code size some what. But the real reason to do it is the 3-Point case can be solved exactly. And by feeding these numbers into the LSF algorithm it provides a way to check all that code for 'correctness'.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4473ded646..b7bd1fccea 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -767,23 +767,26 @@ void kill_screen(const char* lcd_msg) {
   void lcd_buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #else
       UNUSED(duration); UNUSED(freq);
     #endif
   }
 
-  void lcd_quick_feedback() {
+  void lcd_quick_feedback(const bool clear_buttons) {
     lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-    buttons = 0;
+
+    if (clear_buttons)
+      buttons = 0;
+
     next_button_update_ms = millis() + 500;
 
     // Buzz and wait. The delay is needed for buttons to settle!
     lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     #if ENABLED(LCD_USE_I2C_BUZZER)
       delay(10);
     #elif PIN_EXISTS(BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #endif
   }
@@ -4665,22 +4668,22 @@ void kill_screen(const char* lcd_msg) {
    */
   #if ENABLED(ADC_KEYPAD)
 
     inline bool handle_adc_keypad() {
       #define ADC_MIN_KEY_DELAY 100
       if (buttons_reprapworld_keypad) {
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         if (encoderDirection == -1) { // side effect which signals we are inside a menu
           if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
           else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(); }
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(); }
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(true); }
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(true); }
         }
         else {
           if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
                  if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
             else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
             else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
           }
         }
         #if ENABLED(ADC_KEYPAD_DEBUG)
           SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
@@ -4934,21 +4937,21 @@ void lcd_update() {
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
-        lcd_quick_feedback();            //  Always make a click sound
+        lcd_quick_feedback(true);        //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 

commit e633ce06c723d262dc570c74dc21efcadb9ea7a8
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Tue Jan 9 23:41:14 2018 -0600

    LCD contrast type mismatch  is back
    
    WORKS!

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2add63942c..4473ded646 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3159,20 +3159,21 @@ void kill_screen(const char* lcd_msg) {
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
     #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
+      // please don't remove the "(int16_t*)" - it's needed for the VIKI2 display  --- see PR #9132 before changing it
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
@@ -5236,21 +5237,21 @@ void lcd_setalertstatusPGM(const char * const message) {
   lcd_setstatusPGM(message, 1);
   #if ENABLED(ULTIPANEL)
     lcd_return_to_status();
   #endif
 }
 
 void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
 #if HAS_LCD_CONTRAST
 
-  void set_lcd_contrast(const uint16_t value) {
+  void set_lcd_contrast(const int16_t value) {
     lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
     u8g.setContrast(lcd_contrast);
   }
 
 #endif
 
 #if ENABLED(ULTIPANEL)
 
   /**
    * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)

commit f26805e862c192de21506abbb9c2f37d25544921
Author: Tannoo <tannoo@msn.com>
Date:   Sun Jan 7 19:33:53 2018 -0700

    [2.0.x] UBL Mesh Storage Message (#9095)

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0ba85f3495..2add63942c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2272,34 +2272,36 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
       MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Load Mesh Command
      */
     void _lcd_ubl_load_mesh_cmd() {
-      char UBL_LCD_GCODE[10];
+      char UBL_LCD_GCODE[25];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
       lcd_enqueue_command(UBL_LCD_GCODE);
-      enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_LOADED "."));
+      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED), ubl_storage_slot);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Save Mesh Command
      */
     void _lcd_ubl_save_mesh_cmd() {
-      char UBL_LCD_GCODE[10];
+      char UBL_LCD_GCODE[25];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
       lcd_enqueue_command(UBL_LCD_GCODE);
-      enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_SAVED "."));
+      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED), ubl_storage_slot);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Mesh Storage submenu
      *
      * << Unified Bed Leveling
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
      */

commit cb0e826c5dc8b67ec3ecfa673911c7afe94c9af1
Merge: 702c8acdd5 f72b0a7b04
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Jan 5 21:09:57 2018 -0600

    Merge pull request #9068 from Bob-the-Kuhn/SD-detect
    
    [2.0.x] SD card detect improvement

diff --combined Marlin/src/lcd/ultralcd.cpp
index 553ecdf4d4,292a0f5ac1..0ba85f3495
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -32,24 -32,20 +32,24 @@@
  #include "../module/stepper.h"
  #include "../module/motion.h"
  #include "../module/probe.h"
  #include "../module/printcounter.h"
  #include "../gcode/gcode.h"
  #include "../gcode/queue.h"
  #include "../module/configuration_store.h"
  
  #include "../Marlin.h"
  
 +#if ENABLED(ADVANCED_PAUSE_FEATURE)
 +  #include "../feature/pause.h"
 +#endif
 +
  #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
    #include "../libs/duration_t.h"
  #endif
  
  #if ENABLED(FILAMENT_LCD_DISPLAY)
    #include "../feature/filwidth.h"
  #endif
  
  #if ENABLED(BLTOUCH)
    #include "../module/endstops.h"
@@@ -180,50 -176,46 +180,50 @@@ uint16_t max_display_update_time = 0
    void lcd_move_menu();
    void lcd_control_menu();
    void lcd_control_temperature_menu();
    void lcd_control_motion_menu();
  
    #if DISABLED(SLIM_LCD_MENUS)
      void lcd_control_temperature_preheat_material1_settings_menu();
      void lcd_control_temperature_preheat_material2_settings_menu();
    #endif
  
 -  #if DISABLED(NO_VOLUMETRICS)
 +  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
      void lcd_control_filament_menu();
    #endif
  
    #if ENABLED(LCD_INFO_MENU)
      #if ENABLED(PRINTCOUNTER)
        void lcd_info_stats_menu();
      #endif
      void lcd_info_thermistors_menu();
      void lcd_info_board_menu();
      void lcd_info_menu();
    #endif // LCD_INFO_MENU
  
    #if ENABLED(LED_CONTROL_MENU)
      void lcd_led_menu();
    #endif
  
    #if ENABLED(ADVANCED_PAUSE_FEATURE)
 -    void lcd_advanced_pause_toocold_menu();
 +    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
 +      void lcd_change_filament_menu();
 +    #else
 +      void lcd_temp_menu_e0_filament_change();
 +    #endif
      void lcd_advanced_pause_option_menu();
      void lcd_advanced_pause_init_message();
      void lcd_advanced_pause_unload_message();
      void lcd_advanced_pause_insert_message();
      void lcd_advanced_pause_load_message();
      void lcd_advanced_pause_heat_nozzle();
 -    void lcd_advanced_pause_extrude_message();
 +    void lcd_advanced_pause_purge_message();
      void lcd_advanced_pause_resume_message();
    #endif
  
    #if ENABLED(DAC_STEPPER_CURRENT)
      void dac_driver_commit();
      void dac_driver_getValues();
      void lcd_dac_menu();
      void lcd_dac_write_eeprom();
    #endif
  
@@@ -304,84 -296,80 +304,84 @@@
     *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
     *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
     *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
     *
     */
    #define _MENU_ITEM_PART_1(TYPE, ...) \
      if (_menuLineNr == _thisItemNr) { \
        if (encoderLine == _thisItemNr && lcd_clicked) { \
          lcd_clicked = false
  
 -  #define _MENU_ITEM_PART_2(TYPE, LABEL, ...) \
 +  #define _MENU_ITEM_PART_2(TYPE, PLABEL, ...) \
          menu_action_ ## TYPE(__VA_ARGS__); \
          if (screen_changed) return; \
        } \
        if (lcdDrawUpdate) \
 -        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
 +        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PLABEL, ## __VA_ARGS__); \
      } \
      ++_thisItemNr
  
 -  #define MENU_ITEM(TYPE, LABEL, ...) do { \
 +  #define MENU_ITEM_P(TYPE, PLABEL, ...) do { \
        _skipStatic = false; \
        _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
 -      _MENU_ITEM_PART_2(TYPE, LABEL, ## __VA_ARGS__); \
 +      _MENU_ITEM_PART_2(TYPE, PLABEL, ## __VA_ARGS__); \
      }while(0)
  
 +  #define MENU_ITEM(TYPE, LABEL, ...) MENU_ITEM_P(TYPE, PSTR(LABEL), ## __VA_ARGS__)
 +
    #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
  
    // Used to print static text with no visible cursor.
    // Parameters: label [, bool center [, bool invert [, char *value] ] ]
 -  #define STATIC_ITEM(LABEL, ...) \
 +  #define STATIC_ITEM_P(LABEL, ...) \
      if (_menuLineNr == _thisItemNr) { \
        if (_skipStatic && encoderLine <= _thisItemNr) { \
          encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
          ++encoderLine; \
        } \
        if (lcdDrawUpdate) \
 -        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
 +        lcd_implementation_drawmenu_static(_lcdLineNr, LABEL, ## __VA_ARGS__); \
      } \
      ++_thisItemNr
  
 +  #define STATIC_ITEM(LABEL, ...) STATIC_ITEM_P(PSTR(LABEL), ## __VA_ARGS__)
 +
    #if ENABLED(ENCODER_RATE_MULTIPLIER)
  
      bool encoderRateMultiplierEnabled;
      #define ENCODER_RATE_MULTIPLY(F) (encoderRateMultiplierEnabled = F)
  
      //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
  
      /**
       * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item
       */
 -    #define MENU_MULTIPLIER_ITEM(type, label, ...) do { \
 -        _MENU_ITEM_PART_1(type, ## __VA_ARGS__); \
 +    #define MENU_MULTIPLIER_ITEM(TYPE, LABEL, ...) do { \
 +        _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
          encoderRateMultiplierEnabled = true; \
          lastEncoderMovementMillis = 0; \
 -        _MENU_ITEM_PART_2(type, label, ## __VA_ARGS__); \
 +        _MENU_ITEM_PART_2(TYPE, PSTR(LABEL), ## __VA_ARGS__); \
        }while(0)
  
    #else // !ENCODER_RATE_MULTIPLIER
      #define ENCODER_RATE_MULTIPLY(F) NOOP
    #endif // !ENCODER_RATE_MULTIPLIER
  
    #define MENU_ITEM_DUMMY() do { _thisItemNr++; }while(0)
 -  #define MENU_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
 -  #define MENU_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
 +  #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
 +  #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
    #if ENABLED(ENCODER_RATE_MULTIPLIER)
 -    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
 -    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
 +    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
 +    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
    #else // !ENCODER_RATE_MULTIPLIER
 -    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
 -    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
 +    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
 +    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
    #endif // !ENCODER_RATE_MULTIPLIER
  
    /**
     * START_SCREEN_OR_MENU generates init code for a screen or menu
     *
     *   encoderLine is the position based on the encoder
     *   encoderTopLine is the top menu line to display
     *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
     *   _menuLineNr is the menu item to draw and process
     *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
@@@ -1136,21 -1124,24 +1136,21 @@@ void kill_screen(const char* lcd_msg) 
        void lcd_babystep_zoffset() {
          if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
          defer_return_to_status = true;
          ENCODER_DIRECTION_NORMAL();
          if (encoderPosition) {
            const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
            encoderPosition = 0;
  
            const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
            if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 -
 -            if (planner.leveling_active)
 -              thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 -
 +            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
              zprobe_zoffset = new_zoffset;
              lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
            }
          }
          if (lcdDrawUpdate) {
            lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
            #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
              _lcd_zoffset_overlay_gfx(zprobe_zoffset);
            #endif
          }
@@@ -1250,20 -1241,75 +1250,20 @@@
        #endif // HOTENDS > 2
      #endif // HOTENDS > 1
    #endif // HAS_TEMP_HOTEND
  
    void watch_temp_callback_bed() {
      #if WATCH_THE_BED
        thermalManager.start_watching_bed();
      #endif
    }
  
 -  #if ENABLED(ADVANCED_PAUSE_FEATURE)
 -
 -    void lcd_enqueue_filament_change(
 -      #if EXTRUDERS > 1
 -        const uint8_t extruder
 -      #endif
 -    ) {
 -
 -      #if ENABLED(PREVENT_COLD_EXTRUSION)
 -        if (!DEBUGGING(DRYRUN) && thermalManager.tooColdToExtrude(active_extruder)) {
 -          lcd_save_previous_screen();
 -          lcd_goto_screen(lcd_advanced_pause_toocold_menu);
 -          return;
 -        }
 -      #endif
 -
 -      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
 -
 -      #if EXTRUDERS <= 1
 -        enqueue_and_echo_commands_P(PSTR("M600 B0"));
 -      #else
 -        char *command_M600;
 -        switch (extruder) {
 -          case 0: command_M600 = PSTR("M600 B0 T0"); break;
 -          case 1: command_M600 = PSTR("M600 B0 T1"); break;
 -          #if EXTRUDERS > 2
 -            case 2: command_M600 = PSTR("M600 B0 T2"); break;
 -            #if EXTRUDERS > 3
 -              case 3: command_M600 = PSTR("M600 B0 T3"); break;
 -              #if EXTRUDERS > 4
 -                case 4: command_M600 = PSTR("M600 B0 T4"); break;
 -              #endif // EXTRUDERS > 4
 -            #endif // EXTRUDERS > 3
 -          #endif // EXTRUDERS > 2
 -        }
 -        enqueue_and_echo_commands_P(command_M600);
 -      #endif // EXTRUDERS > 1
 -    }
 -
 -    #if EXTRUDERS > 1
 -      void lcd_enqueue_filament_change_e0() { lcd_enqueue_filament_change(0); }
 -      void lcd_enqueue_filament_change_e1() { lcd_enqueue_filament_change(1); }
 -      #if EXTRUDERS > 2
 -        void lcd_enqueue_filament_change_e2() { lcd_enqueue_filament_change(2); }
 -        #if EXTRUDERS > 3
 -          void lcd_enqueue_filament_change_e3() { lcd_enqueue_filament_change(3); }
 -          #if EXTRUDERS > 4
 -            void lcd_enqueue_filament_change_e4() { lcd_enqueue_filament_change(4); }
 -          #endif // EXTRUDERS > 4
 -        #endif // EXTRUDERS > 3
 -      #endif // EXTRUDERS > 2
 -    #endif // EXTRUDERS > 1
 -
 -  #endif // ADVANCED_PAUSE_FEATURE
 -
    // First Fan Speed title in "Tune" and "Control>Temperature" menus
    #if FAN_COUNT > 0 && HAS_FAN0
      #if FAN_COUNT > 1
        #define FAN_SPEED_1_SUFFIX " 1"
      #else
        #define FAN_SPEED_1_SUFFIX ""
      #endif
    #endif
  
    // Refresh the E factor after changing flow
@@@ -1391,27 -1437,40 +1391,27 @@@
          MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
        #else
          MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
        #endif
      #endif
  
      //
      // Change filament
      //
      #if ENABLED(ADVANCED_PAUSE_FEATURE)
 -      #if EXTRUDERS > 1
 -        if (!thermalManager.tooColdToExtrude(0))
 -          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
 -        if (!thermalManager.tooColdToExtrude(1))
 -          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
 -        #if EXTRUDERS > 2
 -          if (!thermalManager.tooColdToExtrude(2))
 -            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
 -          #if EXTRUDERS > 3
 -            if (!thermalManager.tooColdToExtrude(3))
 -              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
 -            #if EXTRUDERS > 4
 -              if (!thermalManager.tooColdToExtrude(4))
 -                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
 -            #endif // EXTRUDERS > 4
 -          #endif // EXTRUDERS > 3
 -        #endif // EXTRUDERS > 2
 +      #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
 +        if (!thermalManager.targetTooColdToExtrude(active_extruder))
 +          MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
 +        else
 +          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
        #else
 -        if (!thermalManager.tooColdToExtrude(active_extruder))
 -          MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
 +        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
        #endif
      #endif
  
      END_MENU();
    }
  
    /**
     *
     * "Driver current control" submenu items
     *
@@@ -1685,29 -1744,23 +1685,29 @@@
      thermalManager.disable_all_heaters();
      lcd_return_to_status();
    }
  
    #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
  
      /**
       * If the queue is full, the command will fail, so we have to loop
       * with idle() to make sure the command has been enqueued.
       */
 -    void lcd_enqueue_command_sram(char * const cmd) {
 +    void lcd_enqueue_command(char * const cmd) {
 +      no_reentry = true;
 +      enqueue_and_echo_command_now(cmd);
 +      no_reentry = false;
 +    }
 +
 +    void lcd_enqueue_commands_P(const char * const cmd) {
        no_reentry = true;
 -      while (enqueue_and_echo_command(cmd)) idle();
 +      enqueue_and_echo_commands_P_now(cmd);
        no_reentry = false;
      }
  
    #endif
  
    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
  
      void lcd_autostart_sd() {
        card.autostart_index = 0;
        card.setroot();
@@@ -2022,24 -2075,24 +2022,24 @@@
      #endif
  
      /**
       * UBL Build Custom Mesh Command
       */
      void _lcd_ubl_build_custom_mesh() {
        char UBL_LCD_GCODE[20];
        enqueue_and_echo_commands_P(PSTR("G28"));
        #if HAS_TEMP_BED
          sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
 -        lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +        lcd_enqueue_command(UBL_LCD_GCODE);
        #endif
        sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("G29 P1"));
      }
  
      /**
       * UBL Custom Mesh submenu
       *
       * << Build Mesh
       *    Hotend Temp: ---
       *    Bed Temp: ---
       *    Build Custom Mesh
@@@ -2056,21 -2109,21 +2056,21 @@@
      }
  
      /**
       * UBL Adjust Mesh Height Command
       */
      void _lcd_ubl_adjust_height_cmd() {
        char UBL_LCD_GCODE[16];
        const int ind = ubl_height_amount > 0 ? 9 : 10;
        strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
        sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Adjust Mesh Height submenu
       *
       * << Edit Mesh
       *    Height Amount: ---
       *    Adjust Mesh Height
       * << Info Screen
       */
@@@ -2107,22 -2160,22 +2107,22 @@@
      void _lcd_ubl_validate_custom_mesh() {
        char UBL_LCD_GCODE[24];
        const int temp =
          #if HAS_TEMP_BED
            custom_bed_temp
          #else
            0
          #endif
        ;
        sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
 -      lcd_enqueue_command_sram("G28");
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_commands_P(PSTR("G28"));
 +      lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Validate Mesh submenu
       *
       * << UBL Tools
       *    PLA Mesh Validation
       *    ABS Mesh Validation
       *    Validate Custom Mesh
       * << Info Screen
@@@ -2141,21 -2194,21 +2141,21 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Grid Leveling Command
       */
      void _lcd_ubl_grid_level_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Grid Leveling submenu
       *
       * << UBL Tools
       *    Side points: ---
       *    Level Mesh
       */
      void _lcd_ubl_grid_level() {
@@@ -2182,21 -2235,21 +2182,21 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Fill-in Amount Mesh Command
       */
      void _lcd_ubl_fillin_amount_cmd() {
        char UBL_LCD_GCODE[16];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Fill-in Mesh submenu
       *
       * << Build Mesh
       *    Fill-in Amount: ---
       *    Fill-in Mesh
       *    Smart Fill-in
       *    Manual Fill-in
@@@ -2274,48 -2327,49 +2274,48 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Load Mesh Command
       */
      void _lcd_ubl_load_mesh_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_LOADED "."));
      }
  
      /**
       * UBL Save Mesh Command
       */
      void _lcd_ubl_save_mesh_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_SAVED "."));
      }
  
      /**
       * UBL Mesh Storage submenu
       *
       * << Unified Bed Leveling
       *    Memory Slot: ---
       *    Load Bed Mesh
       *    Save Bed Mesh
       */
      void _lcd_ubl_storage_mesh() {
        int16_t a = settings.calc_num_meshes();
        START_MENU();
        MENU_BACK(MSG_UBL_LEVEL_BED);
        if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
          STATIC_ITEM(MSG_NO_STORAGE);
 -        STATIC_ITEM(MSG_INIT_EEPROM);
        }
        else {
          MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
          MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
          MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
        }
        END_MENU();
      }
  
      /**
@@@ -2334,21 -2388,21 +2334,21 @@@
      }
  
      /**
       * UBL LCD "radar" map point editing
       */
      void _lcd_ubl_map_lcd_edit_cmd() {
        char UBL_LCD_GCODE[50], str[10], str2[10];
        dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
        dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
        snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
 -      lcd_enqueue_command_sram(UBL_LCD_GCODE);
 +      lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL LCD Map Movement
       */
      void ubl_map_move_to_xy() {
        current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
        current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
      }
@@@ -2583,39 -2637,53 +2583,39 @@@
      #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
          MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
      #endif
  
      #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
        //
        // Set Home Offsets
        //
        MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
 -      //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
      #endif
  
      //
      // Disable Steppers
      //
      MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
  
      //
      // Change filament
      //
      #if ENABLED(ADVANCED_PAUSE_FEATURE)
        if (!IS_SD_FILE_OPEN) {
 -        #if EXTRUDERS > 1
 -          if (!thermalManager.tooColdToExtrude(0))
 -            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
 -          if (!thermalManager.tooColdToExtrude(1))
 -            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
 -          #if EXTRUDERS > 2
 -            if (!thermalManager.tooColdToExtrude(2))
 -              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
 -            #if EXTRUDERS > 3
 -              if (!thermalManager.tooColdToExtrude(3))
 -                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
 -              #if EXTRUDERS > 4
 -                if (!thermalManager.tooColdToExtrude(4))
 -                  MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
 -              #endif // EXTRUDERS > 4
 -            #endif // EXTRUDERS > 3
 -          #endif // EXTRUDERS > 2
 +        #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
 +          if (!thermalManager.targetTooColdToExtrude(active_extruder))
 +            MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
 +          else
 +            MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
          #else
 -          if (!thermalManager.tooColdToExtrude(active_extruder))
 -            MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
 +          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
          #endif
        }
      #endif // ADVANCED_PAUSE_FEATURE
  
      #if TEMP_SENSOR_0 != 0
  
        //
        // Cooldown
        //
        bool has_heat = false;
@@@ -3131,40 -3199,41 +3131,40 @@@
    #endif
  
    static void lcd_factory_settings() {
      settings.reset();
      lcd_completion_feedback();
    }
  
    #if ENABLED(EEPROM_SETTINGS)
  
      static void lcd_init_eeprom() {
 -      lcd_factory_settings();
 -      settings.save();
 +      lcd_completion_feedback(settings.init_eeprom());
        lcd_goto_previous_menu();
      }
  
      static void lcd_init_eeprom_confirm() {
        START_MENU();
        MENU_BACK(MSG_CONTROL);
        MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
        END_MENU();
      }
  
    #endif
  
    void lcd_control_menu() {
      START_MENU();
      MENU_BACK(MSG_MAIN);
      MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
      MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
  
 -    #if DISABLED(NO_VOLUMETRICS)
 +    #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
        MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
      #elif ENABLED(LIN_ADVANCE)
        MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
      #endif
  
      #if HAS_LCD_CONTRAST
        MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
      #endif
      #if ENABLED(FWRETRACT)
        MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
@@@ -3214,21 -3283,21 +3214,21 @@@
        char cmd[30];
        sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
          #if HAS_PID_FOR_BOTH
            e < 0 ? autotune_temp_bed : autotune_temp[e]
          #elif ENABLED(PIDTEMPBED)
            autotune_temp_bed
          #else
            autotune_temp[e]
          #endif
        );
 -      lcd_enqueue_command_sram(cmd);
 +      lcd_enqueue_command(cmd);
      }
  
    #endif // PID_AUTOTUNE_MENU
  
    #if ENABLED(PIDTEMP)
  
      // Helpers for editing PID Ki & Kd values
      // grab the PID value out of the temp variable; scale it; then update the PID driver
      void copy_and_scalePID_i(int16_t e) {
        #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
@@@ -3409,21 -3478,21 +3409,21 @@@
        // Preheat Material 2 conf
        //
        MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
      #endif
  
      END_MENU();
    }
  
    #if DISABLED(SLIM_LCD_MENUS)
  
 -    void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
 +    void _lcd_control_temperature_preheat_settings_menu(const uint8_t material) {
        #if HOTENDS > 4
          #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
          #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
        #elif HOTENDS > 3
          #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
          #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
        #elif HOTENDS > 2
          #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
          #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
        #elif HOTENDS > 1
@@@ -3655,104 -3724,58 +3655,104 @@@
      #endif // !SLIM_LCD_MENUS
  
      // M540 S - Abort on endstop hit when SD printing
      #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
        MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
      #endif
  
      END_MENU();
    }
  
 -  #if DISABLED(NO_VOLUMETRICS)
 +  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
      /**
       *
       * "Control" > "Filament" submenu
       *
       */
      void lcd_control_filament_menu() {
        START_MENU();
        MENU_BACK(MSG_CONTROL);
  
        #if ENABLED(LIN_ADVANCE)
          MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
        #endif
  
 -      MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 +      #if DISABLED(NO_VOLUMETRICS)
 +        MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 +
 +        if (parser.volumetric_enabled) {
 +          #if EXTRUDERS == 1
 +            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +          #else // EXTRUDERS > 1
 +            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +            #if EXTRUDERS > 2
 +              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +            #if EXTRUDERS > 3
 +              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +              #if EXTRUDERS > 4
 +                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +                #endif // EXTRUDERS > 4
 +              #endif // EXTRUDERS > 3
 +            #endif // EXTRUDERS > 2
 +          #endif // EXTRUDERS > 1
 +        }
 +      #endif
 +
 +      #if ENABLED(ADVANCED_PAUSE_FEATURE)
 +        const float extrude_maxlength =
 +          #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
 +            EXTRUDE_MAXLENGTH
 +          #else
 +            999.0f
 +          #endif
 +        ;
  
 -      if (parser.volumetric_enabled) {
          #if EXTRUDERS == 1
 -          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0.0, extrude_maxlength);
          #else // EXTRUDERS > 1
 -          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 -          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 -          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0.0, extrude_maxlength);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0.0, extrude_maxlength);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0.0, extrude_maxlength);
            #if EXTRUDERS > 2
 -            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 -            #if EXTRUDERS > 3
 -              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 -              #if EXTRUDERS > 4
 -                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
 +            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0.0, extrude_maxlength);
 +          #if EXTRUDERS > 3
 +            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0.0, extrude_maxlength);
 +            #if EXTRUDERS > 4
 +                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0.0, extrude_maxlength);
                #endif // EXTRUDERS > 4
              #endif // EXTRUDERS > 3
            #endif // EXTRUDERS > 2
          #endif // EXTRUDERS > 1
 -      }
 +
 +        #if EXTRUDERS == 1
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0.0, extrude_maxlength);
 +        #else // EXTRUDERS > 1
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0.0, extrude_maxlength);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0.0, extrude_maxlength);
 +          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0.0, extrude_maxlength);
 +          #if EXTRUDERS > 2
 +            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0.0, extrude_maxlength);
 +          #if EXTRUDERS > 3
 +            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0.0, extrude_maxlength);
 +            #if EXTRUDERS > 4
 +                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0.0, extrude_maxlength);
 +              #endif // EXTRUDERS > 4
 +            #endif // EXTRUDERS > 3
 +          #endif // EXTRUDERS > 2
 +        #endif // EXTRUDERS > 1
 +      #endif
  
        END_MENU();
      }
 -  #endif // !NO_VOLUMETRICS
 +  #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
  
    /**
     *
     * "Control" > "Retract" submenu
     *
     */
    #if ENABLED(FWRETRACT)
  
      void lcd_control_retract_menu() {
        START_MENU();
@@@ -4095,303 -4118,69 +4095,303 @@@
  
    #endif // LED_CONTROL_MENU
  
    /**
     *
     * Filament Change Feature Screens
     *
     */
    #if ENABLED(ADVANCED_PAUSE_FEATURE)
  
 +    /**
 +     *
 +     * "Change Filament" > "Change/Unload/Load Filament" submenu
 +     *
 +     */
 +    static AdvancedPauseMode _change_filament_temp_mode;
 +    static int8_t _change_filament_temp_extruder;
 +
 +    static const char* _change_filament_temp_command() {
 +      switch (_change_filament_temp_mode) {
 +        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
 +          return PSTR("M701 T%d");
 +        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
 +          return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
 +        case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
 +        default:
 +          return PSTR("M600 B0 T%d");
 +      }
 +      return PSTR(MSG_FILAMENTCHANGE);
 +    }
 +
 +    void _change_filament_temp(const uint8_t index) {
 +      char cmd[11];
 +      sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
 +      thermalManager.setTargetHotend(index == 1 ? PREHEAT_1_TEMP_HOTEND : PREHEAT_2_TEMP_HOTEND, _change_filament_temp_extruder);
 +      lcd_enqueue_command(cmd);
 +    }
 +    void _lcd_change_filament_temp_1_menu() { _change_filament_temp(1); }
 +    void _lcd_change_filament_temp_2_menu() { _change_filament_temp(2); }
 +
 +    static const char* change_filament_header(const AdvancedPauseMode mode) {
 +      switch (mode) {
 +        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
 +          return PSTR(MSG_FILAMENTLOAD);
 +        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
 +          return PSTR(MSG_FILAMENTUNLOAD);
 +        default: break;
 +      }
 +      return PSTR(MSG_FILAMENTCHANGE);
 +    }
 +
 +    void _lcd_temp_menu_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
 +      _change_filament_temp_mode = mode;
 +      _change_filament_temp_extruder = extruder;
 +      START_MENU();
 +      if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
 +      MENU_BACK(MSG_FILAMENTCHANGE);
 +      MENU_ITEM(submenu, MSG_PREHEAT_1, _lcd_change_filament_temp_1_menu);
 +      MENU_ITEM(submenu, MSG_PREHEAT_2, _lcd_change_filament_temp_2_menu);
 +      END_MENU();
 +    }
 +    void lcd_temp_menu_e0_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
 +    void lcd_temp_menu_e0_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
 +    void lcd_temp_menu_e0_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
 +    #if E_STEPPERS > 1
 +      void lcd_temp_menu_e1_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
 +      void lcd_temp_menu_e1_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
 +      void lcd_temp_menu_e1_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
 +      #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
 +        void lcd_unload_filament_all_temp_menu() { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, -1); }
 +      #endif
 +      #if E_STEPPERS > 2
 +        void lcd_temp_menu_e2_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 2); }
 +        void lcd_temp_menu_e2_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 2); }
 +        void lcd_temp_menu_e2_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 2); }
 +        #if E_STEPPERS > 3
 +          void lcd_temp_menu_e3_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 3); }
 +          void lcd_temp_menu_e3_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 3); }
 +          void lcd_temp_menu_e3_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 3); }
 +          #if E_STEPPERS > 4
 +            void lcd_temp_menu_e4_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 4); }
 +            void lcd_temp_menu_e4_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 4); }
 +            void lcd_temp_menu_e4_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 4); }
 +          #endif // E_STEPPERS > 4
 +        #endif // E_STEPPERS > 3
 +      #endif // E_STEPPERS > 2
 +    #endif // E_STEPPERS > 1
 +
 +    /**
 +     *
 +     * "Change Filament" submenu
 +     *
 +     */
 +    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
 +      void lcd_change_filament_menu() {
 +        START_MENU();
 +        MENU_BACK(MSG_PREPARE);
 +
 +        // Change filament
 +        #if E_STEPPERS == 1
 +          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
 +          if (thermalManager.targetTooColdToExtrude(active_extruder))
 +            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
 +          else
 +            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
 +        #else
 +          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);
 +          PGM_P msg1 = PSTR(MSG_FILAMENTCHANGE " " MSG_E2);
 +          if (thermalManager.targetTooColdToExtrude(0))
 +            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
 +          else
 +            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0 T0"));
 +          if (thermalManager.targetTooColdToExtrude(1))
 +            MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_change);
 +          else
 +            MENU_ITEM_P(gcode, msg1, PSTR("M600 B0 T1"));
 +          #if E_STEPPERS > 2
 +            PGM_P msg2 = PSTR(MSG_FILAMENTCHANGE " " MSG_E3);
 +            if (thermalManager.targetTooColdToExtrude(2))
 +              MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_change);
 +            else
 +              MENU_ITEM_P(gcode, msg2, PSTR("M600 B0 T2"));
 +            #if E_STEPPERS > 3
 +              PGM_P msg3 = PSTR(MSG_FILAMENTCHANGE " " MSG_E4);
 +              if (thermalManager.targetTooColdToExtrude(3))
 +                MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_change);
 +              else
 +                MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
 +              #if E_STEPPERS > 4
 +                PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
 +                if (thermalManager.targetTooColdToExtrude(4))
 +                  MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_change);
 +                else
 +                  MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
 +              #endif // E_STEPPERS > 4
 +            #endif // E_STEPPERS > 3
 +          #endif // E_STEPPERS > 2
 +        #endif // E_STEPPERS == 1
 +
 +        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
 +          if (!planner.movesplanned() && !IS_SD_FILE_OPEN) {
 +            // Load filament
 +            #if E_STEPPERS == 1
 +              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
 +              if (thermalManager.targetTooColdToExtrude(active_extruder))
 +                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
 +              else
 +                MENU_ITEM_P(gcode, msg0, PSTR("M701"));
 +            #else
 +              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
 +              PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);
 +              if (thermalManager.targetTooColdToExtrude(0))
 +                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
 +              else
 +                MENU_ITEM_P(gcode, msg0, PSTR("M701 T0"));
 +              if (thermalManager.targetTooColdToExtrude(1))
 +                MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_load);
 +              else
 +                MENU_ITEM_P(gcode, msg1, PSTR("M701 T1"));
 +              #if E_STEPPERS > 2
 +                PGM_P msg2 = PSTR(MSG_FILAMENTLOAD " " MSG_E3);
 +                if (thermalManager.targetTooColdToExtrude(2))
 +                  MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_load);
 +                else
 +                  MENU_ITEM_P(gcode, msg2, PSTR("M701 T2"));
 +                #if E_STEPPERS > 3
 +                  PGM_P msg3 = PSTR(MSG_FILAMENTLOAD " " MSG_E4);
 +                  if (thermalManager.targetTooColdToExtrude(3))
 +                    MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_load);
 +                  else
 +                    MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
 +                  #if E_STEPPERS > 4
 +                    PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
 +                    if (thermalManager.targetTooColdToExtrude(4))
 +                      MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_load);
 +                    else
 +                      MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
 +                  #endif // E_STEPPERS > 4
 +                #endif // E_STEPPERS > 3
 +              #endif // E_STEPPERS > 2
 +            #endif // E_STEPPERS == 1
 +
 +            // Unload filament
 +            #if E_STEPPERS == 1
 +              if (!thermalManager.targetTooColdToExtrude(active_extruder))
 +                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
 +              else
 +                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, lcd_temp_menu_e0_filament_unload);
 +            #else
 +              #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
 +                if (!thermalManager.targetTooColdToExtrude(0)
 +                  #if E_STEPPERS > 1
 +                    && !thermalManager.targetTooColdToExtrude(1)
 +                    #if E_STEPPERS > 2
 +                      && !thermalManager.targetTooColdToExtrude(2)
 +                      #if E_STEPPERS > 3
 +                        && !thermalManager.targetTooColdToExtrude(3)
 +                        #if E_STEPPERS > 4
 +                          && !thermalManager.targetTooColdToExtrude(4)
 +                        #endif // E_STEPPERS > 4
 +                      #endif // E_STEPPERS > 3
 +                    #endif // E_STEPPERS > 2
 +                  #endif // E_STEPPERS > 1
 +                )
 +                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
 +              else
 +                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, lcd_unload_filament_all_temp_menu);
 +              #endif
 +              if (!thermalManager.targetTooColdToExtrude(0))
 +                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
 +              else
 +                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, lcd_temp_menu_e0_filament_unload);
 +              if (!thermalManager.targetTooColdToExtrude(1))
 +                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
 +              else
 +                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, lcd_temp_menu_e1_filament_unload);
 +              #if E_STEPPERS > 2
 +                if (!thermalManager.targetTooColdToExtrude(2))
 +                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
 +                else
 +                  MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, lcd_temp_menu_e2_filament_unload);
 +                #if E_STEPPERS > 3
 +                  if (!thermalManager.targetTooColdToExtrude(3))
 +                    MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
 +                  else
 +                    MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, lcd_temp_menu_e3_filament_unload);
 +                  #if E_STEPPERS > 4
 +                    if (!thermalManager.targetTooColdToExtrude(4))
 +                      MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
 +                    else
 +                      MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, lcd_temp_menu_e4_filament_unload);
 +                  #endif // E_STEPPERS > 4
 +                #endif // E_STEPPERS > 3
 +              #endif // E_STEPPERS > 2
 +            #endif // E_STEPPERS == 1
 +          }
 +        #endif
 +
 +        END_MENU();
 +      }
 +    #endif
 +
 +    static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
 +    static uint8_t hotend_status_extruder = 0;
 +
 +    static const char* advanced_pause_header() {
 +      switch (advanced_pause_mode) {
 +        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
 +          return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
 +        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
 +          return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
 +        default: break;
 +      }
 +      return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
 +    }
 +
      // Portions from STATIC_ITEM...
      #define HOTEND_STATUS_ITEM() do { \
        if (_menuLineNr == _thisItemNr) { \
          if (lcdDrawUpdate) { \
            lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
 -          lcd_implementation_hotend_status(_lcdLineNr); \
 +          lcd_implementation_hotend_status(_lcdLineNr, hotend_status_extruder); \
          } \
          if (_skipStatic && encoderLine <= _thisItemNr) { \
            encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
            ++encoderLine; \
          } \
          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
        } \
        ++_thisItemNr; \
      }while(0)
  
 -    void lcd_advanced_pause_toocold_menu() {
 -      START_MENU();
 -      STATIC_ITEM(MSG_HEATING_FAILED_LCD, true, true);
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_MINTEMP STRINGIFY(EXTRUDE_MINTEMP) ".", false, false);
 -      MENU_BACK(MSG_BACK);
 -      #if LCD_HEIGHT > 4
 -        STATIC_ITEM(" ");
 -      #endif
 -      HOTEND_STATUS_ITEM();
 -      END_MENU();
 -    }
 -
      void lcd_advanced_pause_resume_print() {
        advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
      }
  
      void lcd_advanced_pause_extrude_more() {
        advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
      }
  
      void lcd_advanced_pause_option_menu() {
        START_MENU();
        #if LCD_HEIGHT > 2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
        #endif
        MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
 -      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_EXTRUDE, lcd_advanced_pause_extrude_more);
 +      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_PURGE, lcd_advanced_pause_extrude_more);
        END_MENU();
      }
  
      void lcd_advanced_pause_init_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
        #ifdef MSG_FILAMENT_CHANGE_INIT_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
          #define __FC_LINES_A 3
        #else
          #define __FC_LINES_A 2
        #endif
        #ifdef MSG_FILAMENT_CHANGE_INIT_3
          STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
          #define _FC_LINES_A (__FC_LINES_A + 1)
@@@ -4400,21 -4189,21 +4400,21 @@@
        #endif
        #if LCD_HEIGHT > _FC_LINES_A + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_unload_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
        #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
          #define __FC_LINES_B 3
        #else
          #define __FC_LINES_B 2
        #endif
        #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
          STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
          #define _FC_LINES_B (__FC_LINES_B + 1)
@@@ -4423,55 -4212,55 +4423,55 @@@
        #endif
        #if LCD_HEIGHT > _FC_LINES_B + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_wait_for_nozzles_to_heat() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
        #ifdef MSG_FILAMENT_CHANGE_HEATING_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
          #define _FC_LINES_C 3
        #else
          #define _FC_LINES_C 2
        #endif
        #if LCD_HEIGHT > _FC_LINES_C + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_heat_nozzle() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
        #ifdef MSG_FILAMENT_CHANGE_INSERT_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
          #define _FC_LINES_D 3
        #else
          #define _FC_LINES_D 2
        #endif
        #if LCD_HEIGHT > _FC_LINES_D + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_insert_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
        #ifdef MSG_FILAMENT_CHANGE_INSERT_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
          #define __FC_LINES_E 3
        #else
          #define __FC_LINES_E 2
        #endif
        #ifdef MSG_FILAMENT_CHANGE_INSERT_3
          STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
          #define _FC_LINES_E (__FC_LINES_E + 1)
@@@ -4480,109 -4269,120 +4480,109 @@@
        #endif
        #if LCD_HEIGHT > _FC_LINES_E + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_load_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
        #ifdef MSG_FILAMENT_CHANGE_LOAD_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
          #define __FC_LINES_F 3
        #else
          #define __FC_LINES_F 2
        #endif
        #ifdef MSG_FILAMENT_CHANGE_LOAD_3
          STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
          #define _FC_LINES_F (__FC_LINES_F + 1)
        #else
          #define _FC_LINES_F __FC_LINES_F
        #endif
        #if LCD_HEIGHT > _FC_LINES_F + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
 -    void lcd_advanced_pause_extrude_message() {
 +    void lcd_advanced_pause_purge_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_1);
 -      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_2
 -        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_2);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
 +      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
 +      #ifdef MSG_FILAMENT_CHANGE_PURGE_2
 +        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
          #define __FC_LINES_G 3
        #else
          #define __FC_LINES_G 2
        #endif
 -      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_3
 -        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_3);
 +      #ifdef MSG_FILAMENT_CHANGE_PURGE_3
 +        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
          #define _FC_LINES_G (__FC_LINES_G + 1)
        #else
          #define _FC_LINES_G __FC_LINES_G
        #endif
        #if LCD_HEIGHT > _FC_LINES_G + 1
          STATIC_ITEM(" ");
        #endif
        HOTEND_STATUS_ITEM();
        END_SCREEN();
      }
  
      void lcd_advanced_pause_resume_message() {
        START_SCREEN();
 -      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
 +      STATIC_ITEM_P(advanced_pause_header(), true, true);
        STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
        #ifdef MSG_FILAMENT_CHANGE_RESUME_2
          STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
        #endif
        #ifdef MSG_FILAMENT_CHANGE_RESUME_3
          STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
        #endif
        END_SCREEN();
      }
  
 -    void lcd_advanced_pause_show_message(const AdvancedPauseMessage message) {
 +    FORCE_INLINE screenFunc_t ap_message_screen(const AdvancedPauseMessage message) {
        switch (message) {
 -        case ADVANCED_PAUSE_MESSAGE_INIT:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_init_message);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_UNLOAD:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_unload_message);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_INSERT:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_insert_message);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_LOAD:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_load_message);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_EXTRUDE:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_extrude_message);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_heat_nozzle);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_wait_for_nozzles_to_heat);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_OPTION:
 -          defer_return_to_status = true;
 -          advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
 -          lcd_goto_screen(lcd_advanced_pause_option_menu);
 -          break;
 -        case ADVANCED_PAUSE_MESSAGE_RESUME:
 -          defer_return_to_status = true;
 -          lcd_goto_screen(lcd_advanced_pause_resume_message);
 -          break;
 +        case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
 +        case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
 +        case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
 +        case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
 +        case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
 +        case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
 +        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
 +        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
 +        case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
 +                                            return lcd_advanced_pause_option_menu;
          case ADVANCED_PAUSE_MESSAGE_STATUS:
 -          lcd_return_to_status();
 -          break;
 +        default: break;
        }
 +      return NULL;
 +    }
 +
 +    void lcd_advanced_pause_show_message(
 +      const AdvancedPauseMessage message,
 +      const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
 +      const uint8_t extruder/*=active_extruder*/
 +    ) {
 +      advanced_pause_mode = mode;
 +      hotend_status_extruder = extruder;
 +      const screenFunc_t next_screen = ap_message_screen(message);
 +      if (next_screen) {
 +        defer_return_to_status = true;
 +        lcd_goto_screen(next_screen);
 +      }
 +      else
 +        lcd_return_to_status();
      }
  
    #endif // ADVANCED_PAUSE_FEATURE
  
    /**
     *
     * Functions for editing single values
     *
     * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
     *
@@@ -4929,34 -4729,35 +4929,35 @@@ void lcd_update() 
        // Don't run the debouncer if UBL owns the display
        #define UBL_CONDITION !lcd_external_control
      #else
        #define UBL_CONDITION true
      #endif
  
      // If the action button is pressed...
      if (UBL_CONDITION && LCD_CLICKED) {
        if (!wait_for_unclick) {           // If not waiting for a debounce release:
          wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
 -        lcd_clicked = !wait_for_user && !no_reentry; // Flag the click if allowed
 +        lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
          wait_for_user = false;           //  Any click clears wait for user
          lcd_quick_feedback();            //  Always make a click sound
        }
      }
      else wait_for_unclick = false;
    #endif
  
    #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
  
      const bool sd_status = IS_SD_INSERTED;
      if (sd_status != lcd_sd_status && lcd_detected()) {
  
        if (sd_status) {
+         safe_delay(1000); // some boards need a delay or the LCD won't show the new status
          card.initsd();
          if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
        }
        else {
          card.release();
          if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
        }
  
        lcd_sd_status = sd_status;
        lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;

commit f72b0a7b046793e27f2f9696b8ddd336869eacd8
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Jan 5 20:36:05 2018 -0600

    1234

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 840f1bbb90..292a0f5ac1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4743,20 +4743,21 @@ void lcd_update() {
     }
     else wait_for_unclick = false;
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;
     if (sd_status != lcd_sd_status && lcd_detected()) {
 
       if (sd_status) {
+        safe_delay(1000); // some boards need a delay or the LCD won't show the new status
         card.initsd();
         if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
       }
       else {
         card.release();
         if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
       lcd_sd_status = sd_status;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;

commit e89f1453ab75cd2e1cdb0a314bc61e46082234a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 21:09:56 2018 -0600

    UBL G29 works without settings.load()

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 550c712630..553ecdf4d4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2302,21 +2302,20 @@ void kill_screen(const char* lcd_msg) {
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
      */
     void _lcd_ubl_storage_mesh() {
       int16_t a = settings.calc_num_meshes();
       START_MENU();
       MENU_BACK(MSG_UBL_LEVEL_BED);
       if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
         STATIC_ITEM(MSG_NO_STORAGE);
-        STATIC_ITEM(MSG_INIT_EEPROM);
       }
       else {
         MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
         MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
         MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
       }
       END_MENU();
     }
 
     /**

commit 7541316bb49303ce97e062da601e26426321c4ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 05:06:34 2018 -0600

    Add M701/M702 Filament Load/Unload, M603

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index cace6dd592..550c712630 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -32,20 +32,24 @@
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
 #include "../module/printcounter.h"
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../feature/pause.h"
+#endif
+
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
@@ -176,46 +180,50 @@ uint16_t max_display_update_time = 0;
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
   void lcd_control_motion_menu();
 
   #if DISABLED(SLIM_LCD_MENUS)
     void lcd_control_temperature_preheat_material1_settings_menu();
     void lcd_control_temperature_preheat_material2_settings_menu();
   #endif
 
-  #if DISABLED(NO_VOLUMETRICS)
+  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
     void lcd_control_filament_menu();
   #endif
 
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
     void lcd_info_menu();
   #endif // LCD_INFO_MENU
 
   #if ENABLED(LED_CONTROL_MENU)
     void lcd_led_menu();
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    void lcd_advanced_pause_toocold_menu();
+    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      void lcd_change_filament_menu();
+    #else
+      void lcd_temp_menu_e0_filament_change();
+    #endif
     void lcd_advanced_pause_option_menu();
     void lcd_advanced_pause_init_message();
     void lcd_advanced_pause_unload_message();
     void lcd_advanced_pause_insert_message();
     void lcd_advanced_pause_load_message();
     void lcd_advanced_pause_heat_nozzle();
-    void lcd_advanced_pause_extrude_message();
+    void lcd_advanced_pause_purge_message();
     void lcd_advanced_pause_resume_message();
   #endif
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     void dac_driver_commit();
     void dac_driver_getValues();
     void lcd_dac_menu();
     void lcd_dac_write_eeprom();
   #endif
 
@@ -1242,75 +1250,20 @@ void kill_screen(const char* lcd_msg) {
       #endif // HOTENDS > 2
     #endif // HOTENDS > 1
   #endif // HAS_TEMP_HOTEND
 
   void watch_temp_callback_bed() {
     #if WATCH_THE_BED
       thermalManager.start_watching_bed();
     #endif
   }
 
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-    void lcd_enqueue_filament_change(
-      #if EXTRUDERS > 1
-        const uint8_t extruder
-      #endif
-    ) {
-
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        if (!DEBUGGING(DRYRUN) && thermalManager.tooColdToExtrude(active_extruder)) {
-          lcd_save_previous_screen();
-          lcd_goto_screen(lcd_advanced_pause_toocold_menu);
-          return;
-        }
-      #endif
-
-      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
-
-      #if EXTRUDERS <= 1
-        enqueue_and_echo_commands_P(PSTR("M600 B0"));
-      #else
-        char *command_M600;
-        switch (extruder) {
-          case 0: command_M600 = PSTR("M600 B0 T0"); break;
-          case 1: command_M600 = PSTR("M600 B0 T1"); break;
-          #if EXTRUDERS > 2
-            case 2: command_M600 = PSTR("M600 B0 T2"); break;
-            #if EXTRUDERS > 3
-              case 3: command_M600 = PSTR("M600 B0 T3"); break;
-              #if EXTRUDERS > 4
-                case 4: command_M600 = PSTR("M600 B0 T4"); break;
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        }
-        enqueue_and_echo_commands_P(command_M600);
-      #endif // EXTRUDERS > 1
-    }
-
-    #if EXTRUDERS > 1
-      void lcd_enqueue_filament_change_e0() { lcd_enqueue_filament_change(0); }
-      void lcd_enqueue_filament_change_e1() { lcd_enqueue_filament_change(1); }
-      #if EXTRUDERS > 2
-        void lcd_enqueue_filament_change_e2() { lcd_enqueue_filament_change(2); }
-        #if EXTRUDERS > 3
-          void lcd_enqueue_filament_change_e3() { lcd_enqueue_filament_change(3); }
-          #if EXTRUDERS > 4
-            void lcd_enqueue_filament_change_e4() { lcd_enqueue_filament_change(4); }
-          #endif // EXTRUDERS > 4
-        #endif // EXTRUDERS > 3
-      #endif // EXTRUDERS > 2
-    #endif // EXTRUDERS > 1
-
-  #endif // ADVANCED_PAUSE_FEATURE
-
   // First Fan Speed title in "Tune" and "Control>Temperature" menus
   #if FAN_COUNT > 0 && HAS_FAN0
     #if FAN_COUNT > 1
       #define FAN_SPEED_1_SUFFIX " 1"
     #else
       #define FAN_SPEED_1_SUFFIX ""
     #endif
   #endif
 
   // Refresh the E factor after changing flow
@@ -1438,40 +1391,27 @@ void kill_screen(const char* lcd_msg) {
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #else
         MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
       #endif
     #endif
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      #if EXTRUDERS > 1
-        if (!thermalManager.tooColdToExtrude(0))
-          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
-        if (!thermalManager.tooColdToExtrude(1))
-          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
-        #if EXTRUDERS > 2
-          if (!thermalManager.tooColdToExtrude(2))
-            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
-          #if EXTRUDERS > 3
-            if (!thermalManager.tooColdToExtrude(3))
-              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
-            #if EXTRUDERS > 4
-              if (!thermalManager.tooColdToExtrude(4))
-                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
+      #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        if (!thermalManager.targetTooColdToExtrude(active_extruder))
+          MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
+        else
+          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
       #else
-        if (!thermalManager.tooColdToExtrude(active_extruder))
-          MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
       #endif
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Driver current control" submenu items
    *
@@ -2644,53 +2584,39 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
       //
       // Set Home Offsets
       //
       MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-      //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
     #endif
 
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (!IS_SD_FILE_OPEN) {
-        #if EXTRUDERS > 1
-          if (!thermalManager.tooColdToExtrude(0))
-            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
-          if (!thermalManager.tooColdToExtrude(1))
-            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
-          #if EXTRUDERS > 2
-            if (!thermalManager.tooColdToExtrude(2))
-              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
-            #if EXTRUDERS > 3
-              if (!thermalManager.tooColdToExtrude(3))
-                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
-              #if EXTRUDERS > 4
-                if (!thermalManager.tooColdToExtrude(4))
-                  MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
+        #if E_STEPPERS == 1 && !ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+          if (!thermalManager.targetTooColdToExtrude(active_extruder))
+            MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
+          else
+            MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_temp_menu_e0_filament_change);
         #else
-          if (!thermalManager.tooColdToExtrude(active_extruder))
-            MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+          MENU_ITEM(submenu, MSG_FILAMENTCHANGE, lcd_change_filament_menu);
         #endif
       }
     #endif // ADVANCED_PAUSE_FEATURE
 
     #if TEMP_SENSOR_0 != 0
 
       //
       // Cooldown
       //
       bool has_heat = false;
@@ -3225,28 +3151,28 @@ void kill_screen(const char* lcd_msg) {
     }
 
   #endif
 
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
-    #if DISABLED(NO_VOLUMETRICS)
+    #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*) &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif
@@ -3484,21 +3410,21 @@ void kill_screen(const char* lcd_msg) {
       // Preheat Material 2 conf
       //
       MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
     #endif
 
     END_MENU();
   }
 
   #if DISABLED(SLIM_LCD_MENUS)
 
-    void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
+    void _lcd_control_temperature_preheat_settings_menu(const uint8_t material) {
       #if HOTENDS > 4
         #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
         #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
       #elif HOTENDS > 3
         #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
         #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
       #elif HOTENDS > 2
         #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
         #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
       #elif HOTENDS > 1
@@ -3730,58 +3656,104 @@ void kill_screen(const char* lcd_msg) {
     #endif // !SLIM_LCD_MENUS
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
     #endif
 
     END_MENU();
   }
 
-  #if DISABLED(NO_VOLUMETRICS)
+  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
     /**
      *
      * "Control" > "Filament" submenu
      *
      */
     void lcd_control_filament_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
 
       #if ENABLED(LIN_ADVANCE)
         MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
       #endif
 
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
+      #if DISABLED(NO_VOLUMETRICS)
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
+
+        if (parser.volumetric_enabled) {
+          #if EXTRUDERS == 1
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          #else // EXTRUDERS > 1
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            #if EXTRUDERS > 2
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            #if EXTRUDERS > 3
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+              #if EXTRUDERS > 4
+                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+                #endif // EXTRUDERS > 4
+              #endif // EXTRUDERS > 3
+            #endif // EXTRUDERS > 2
+          #endif // EXTRUDERS > 1
+        }
+      #endif
+
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        const float extrude_maxlength =
+          #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+            EXTRUDE_MAXLENGTH
+          #else
+            999.0f
+          #endif
+        ;
 
-      if (parser.volumetric_enabled) {
         #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[0], 0.0, extrude_maxlength);
         #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &filament_change_unload_length[active_extruder], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &filament_change_unload_length[0], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &filament_change_unload_length[1], 0.0, extrude_maxlength);
           #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-            #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-              #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &filament_change_unload_length[2], 0.0, extrude_maxlength);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &filament_change_unload_length[3], 0.0, extrude_maxlength);
+            #if EXTRUDERS > 4
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &filament_change_unload_length[4], 0.0, extrude_maxlength);
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
-      }
+
+        #if EXTRUDERS == 1
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[0], 0.0, extrude_maxlength);
+        #else // EXTRUDERS > 1
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &filament_change_load_length[active_extruder], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &filament_change_load_length[0], 0.0, extrude_maxlength);
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &filament_change_load_length[1], 0.0, extrude_maxlength);
+          #if EXTRUDERS > 2
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &filament_change_load_length[2], 0.0, extrude_maxlength);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &filament_change_load_length[3], 0.0, extrude_maxlength);
+            #if EXTRUDERS > 4
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &filament_change_load_length[4], 0.0, extrude_maxlength);
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      #endif
 
       END_MENU();
     }
-  #endif // !NO_VOLUMETRICS
+  #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
 
   /**
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_control_retract_menu() {
       START_MENU();
@@ -4124,69 +4096,303 @@ void kill_screen(const char* lcd_msg) {
 
   #endif // LED_CONTROL_MENU
 
   /**
    *
    * Filament Change Feature Screens
    *
    */
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
+    /**
+     *
+     * "Change Filament" > "Change/Unload/Load Filament" submenu
+     *
+     */
+    static AdvancedPauseMode _change_filament_temp_mode;
+    static int8_t _change_filament_temp_extruder;
+
+    static const char* _change_filament_temp_command() {
+      switch (_change_filament_temp_mode) {
+        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+          return PSTR("M701 T%d");
+        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+          return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
+        case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
+        default:
+          return PSTR("M600 B0 T%d");
+      }
+      return PSTR(MSG_FILAMENTCHANGE);
+    }
+
+    void _change_filament_temp(const uint8_t index) {
+      char cmd[11];
+      sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
+      thermalManager.setTargetHotend(index == 1 ? PREHEAT_1_TEMP_HOTEND : PREHEAT_2_TEMP_HOTEND, _change_filament_temp_extruder);
+      lcd_enqueue_command(cmd);
+    }
+    void _lcd_change_filament_temp_1_menu() { _change_filament_temp(1); }
+    void _lcd_change_filament_temp_2_menu() { _change_filament_temp(2); }
+
+    static const char* change_filament_header(const AdvancedPauseMode mode) {
+      switch (mode) {
+        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+          return PSTR(MSG_FILAMENTLOAD);
+        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+          return PSTR(MSG_FILAMENTUNLOAD);
+        default: break;
+      }
+      return PSTR(MSG_FILAMENTCHANGE);
+    }
+
+    void _lcd_temp_menu_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
+      _change_filament_temp_mode = mode;
+      _change_filament_temp_extruder = extruder;
+      START_MENU();
+      if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
+      MENU_BACK(MSG_FILAMENTCHANGE);
+      MENU_ITEM(submenu, MSG_PREHEAT_1, _lcd_change_filament_temp_1_menu);
+      MENU_ITEM(submenu, MSG_PREHEAT_2, _lcd_change_filament_temp_2_menu);
+      END_MENU();
+    }
+    void lcd_temp_menu_e0_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
+    void lcd_temp_menu_e0_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
+    void lcd_temp_menu_e0_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
+    #if E_STEPPERS > 1
+      void lcd_temp_menu_e1_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
+      void lcd_temp_menu_e1_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
+      void lcd_temp_menu_e1_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
+      #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
+        void lcd_unload_filament_all_temp_menu() { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, -1); }
+      #endif
+      #if E_STEPPERS > 2
+        void lcd_temp_menu_e2_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 2); }
+        void lcd_temp_menu_e2_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 2); }
+        void lcd_temp_menu_e2_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 2); }
+        #if E_STEPPERS > 3
+          void lcd_temp_menu_e3_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 3); }
+          void lcd_temp_menu_e3_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 3); }
+          void lcd_temp_menu_e3_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 3); }
+          #if E_STEPPERS > 4
+            void lcd_temp_menu_e4_filament_change()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 4); }
+            void lcd_temp_menu_e4_filament_load()    { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 4); }
+            void lcd_temp_menu_e4_filament_unload()  { _lcd_temp_menu_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 4); }
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #endif // E_STEPPERS > 1
+
+    /**
+     *
+     * "Change Filament" submenu
+     *
+     */
+    #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      void lcd_change_filament_menu() {
+        START_MENU();
+        MENU_BACK(MSG_PREPARE);
+
+        // Change filament
+        #if E_STEPPERS == 1
+          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
+          if (thermalManager.targetTooColdToExtrude(active_extruder))
+            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
+          else
+            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
+        #else
+          PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);
+          PGM_P msg1 = PSTR(MSG_FILAMENTCHANGE " " MSG_E2);
+          if (thermalManager.targetTooColdToExtrude(0))
+            MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_change);
+          else
+            MENU_ITEM_P(gcode, msg0, PSTR("M600 B0 T0"));
+          if (thermalManager.targetTooColdToExtrude(1))
+            MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_change);
+          else
+            MENU_ITEM_P(gcode, msg1, PSTR("M600 B0 T1"));
+          #if E_STEPPERS > 2
+            PGM_P msg2 = PSTR(MSG_FILAMENTCHANGE " " MSG_E3);
+            if (thermalManager.targetTooColdToExtrude(2))
+              MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_change);
+            else
+              MENU_ITEM_P(gcode, msg2, PSTR("M600 B0 T2"));
+            #if E_STEPPERS > 3
+              PGM_P msg3 = PSTR(MSG_FILAMENTCHANGE " " MSG_E4);
+              if (thermalManager.targetTooColdToExtrude(3))
+                MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_change);
+              else
+                MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
+              #if E_STEPPERS > 4
+                PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
+                if (thermalManager.targetTooColdToExtrude(4))
+                  MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_change);
+                else
+                  MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
+              #endif // E_STEPPERS > 4
+            #endif // E_STEPPERS > 3
+          #endif // E_STEPPERS > 2
+        #endif // E_STEPPERS == 1
+
+        #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+          if (!planner.movesplanned() && !IS_SD_FILE_OPEN) {
+            // Load filament
+            #if E_STEPPERS == 1
+              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
+              if (thermalManager.targetTooColdToExtrude(active_extruder))
+                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
+              else
+                MENU_ITEM_P(gcode, msg0, PSTR("M701"));
+            #else
+              PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
+              PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);
+              if (thermalManager.targetTooColdToExtrude(0))
+                MENU_ITEM_P(submenu, msg0, lcd_temp_menu_e0_filament_load);
+              else
+                MENU_ITEM_P(gcode, msg0, PSTR("M701 T0"));
+              if (thermalManager.targetTooColdToExtrude(1))
+                MENU_ITEM_P(submenu, msg1, lcd_temp_menu_e1_filament_load);
+              else
+                MENU_ITEM_P(gcode, msg1, PSTR("M701 T1"));
+              #if E_STEPPERS > 2
+                PGM_P msg2 = PSTR(MSG_FILAMENTLOAD " " MSG_E3);
+                if (thermalManager.targetTooColdToExtrude(2))
+                  MENU_ITEM_P(submenu, msg2, lcd_temp_menu_e2_filament_load);
+                else
+                  MENU_ITEM_P(gcode, msg2, PSTR("M701 T2"));
+                #if E_STEPPERS > 3
+                  PGM_P msg3 = PSTR(MSG_FILAMENTLOAD " " MSG_E4);
+                  if (thermalManager.targetTooColdToExtrude(3))
+                    MENU_ITEM_P(submenu, msg3, lcd_temp_menu_e3_filament_load);
+                  else
+                    MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
+                  #if E_STEPPERS > 4
+                    PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
+                    if (thermalManager.targetTooColdToExtrude(4))
+                      MENU_ITEM_P(submenu, msg4, lcd_temp_menu_e4_filament_load);
+                    else
+                      MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
+                  #endif // E_STEPPERS > 4
+                #endif // E_STEPPERS > 3
+              #endif // E_STEPPERS > 2
+            #endif // E_STEPPERS == 1
+
+            // Unload filament
+            #if E_STEPPERS == 1
+              if (!thermalManager.targetTooColdToExtrude(active_extruder))
+                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
+              else
+                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, lcd_temp_menu_e0_filament_unload);
+            #else
+              #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
+                if (!thermalManager.targetTooColdToExtrude(0)
+                  #if E_STEPPERS > 1
+                    && !thermalManager.targetTooColdToExtrude(1)
+                    #if E_STEPPERS > 2
+                      && !thermalManager.targetTooColdToExtrude(2)
+                      #if E_STEPPERS > 3
+                        && !thermalManager.targetTooColdToExtrude(3)
+                        #if E_STEPPERS > 4
+                          && !thermalManager.targetTooColdToExtrude(4)
+                        #endif // E_STEPPERS > 4
+                      #endif // E_STEPPERS > 3
+                    #endif // E_STEPPERS > 2
+                  #endif // E_STEPPERS > 1
+                )
+                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
+              else
+                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, lcd_unload_filament_all_temp_menu);
+              #endif
+              if (!thermalManager.targetTooColdToExtrude(0))
+                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
+              else
+                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, lcd_temp_menu_e0_filament_unload);
+              if (!thermalManager.targetTooColdToExtrude(1))
+                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
+              else
+                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, lcd_temp_menu_e1_filament_unload);
+              #if E_STEPPERS > 2
+                if (!thermalManager.targetTooColdToExtrude(2))
+                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
+                else
+                  MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, lcd_temp_menu_e2_filament_unload);
+                #if E_STEPPERS > 3
+                  if (!thermalManager.targetTooColdToExtrude(3))
+                    MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
+                  else
+                    MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, lcd_temp_menu_e3_filament_unload);
+                  #if E_STEPPERS > 4
+                    if (!thermalManager.targetTooColdToExtrude(4))
+                      MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
+                    else
+                      MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, lcd_temp_menu_e4_filament_unload);
+                  #endif // E_STEPPERS > 4
+                #endif // E_STEPPERS > 3
+              #endif // E_STEPPERS > 2
+            #endif // E_STEPPERS == 1
+          }
+        #endif
+
+        END_MENU();
+      }
+    #endif
+
+    static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
+    static uint8_t hotend_status_extruder = 0;
+
+    static const char* advanced_pause_header() {
+      switch (advanced_pause_mode) {
+        case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+          return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
+        case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+          return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
+        default: break;
+      }
+      return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
+    }
+
     // Portions from STATIC_ITEM...
     #define HOTEND_STATUS_ITEM() do { \
       if (_menuLineNr == _thisItemNr) { \
         if (lcdDrawUpdate) { \
           lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
-          lcd_implementation_hotend_status(_lcdLineNr); \
+          lcd_implementation_hotend_status(_lcdLineNr, hotend_status_extruder); \
         } \
         if (_skipStatic && encoderLine <= _thisItemNr) { \
           encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
           ++encoderLine; \
         } \
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
       } \
       ++_thisItemNr; \
     }while(0)
 
-    void lcd_advanced_pause_toocold_menu() {
-      START_MENU();
-      STATIC_ITEM(MSG_HEATING_FAILED_LCD, true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_MINTEMP STRINGIFY(EXTRUDE_MINTEMP) ".", false, false);
-      MENU_BACK(MSG_BACK);
-      #if LCD_HEIGHT > 4
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      END_MENU();
-    }
-
     void lcd_advanced_pause_resume_print() {
       advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
     }
 
     void lcd_advanced_pause_extrude_more() {
       advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
     }
 
     void lcd_advanced_pause_option_menu() {
       START_MENU();
       #if LCD_HEIGHT > 2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
       #endif
       MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
-      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_EXTRUDE, lcd_advanced_pause_extrude_more);
+      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_PURGE, lcd_advanced_pause_extrude_more);
       END_MENU();
     }
 
     void lcd_advanced_pause_init_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
       #ifdef MSG_FILAMENT_CHANGE_INIT_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
         #define __FC_LINES_A 3
       #else
         #define __FC_LINES_A 2
       #endif
       #ifdef MSG_FILAMENT_CHANGE_INIT_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
         #define _FC_LINES_A (__FC_LINES_A + 1)
@@ -4195,21 +4401,21 @@ void kill_screen(const char* lcd_msg) {
       #endif
       #if LCD_HEIGHT > _FC_LINES_A + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_unload_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
       #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
         #define __FC_LINES_B 3
       #else
         #define __FC_LINES_B 2
       #endif
       #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
         #define _FC_LINES_B (__FC_LINES_B + 1)
@@ -4218,55 +4424,55 @@ void kill_screen(const char* lcd_msg) {
       #endif
       #if LCD_HEIGHT > _FC_LINES_B + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_wait_for_nozzles_to_heat() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
       #ifdef MSG_FILAMENT_CHANGE_HEATING_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
         #define _FC_LINES_C 3
       #else
         #define _FC_LINES_C 2
       #endif
       #if LCD_HEIGHT > _FC_LINES_C + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_heat_nozzle() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
       #ifdef MSG_FILAMENT_CHANGE_INSERT_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
         #define _FC_LINES_D 3
       #else
         #define _FC_LINES_D 2
       #endif
       #if LCD_HEIGHT > _FC_LINES_D + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_insert_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
       #ifdef MSG_FILAMENT_CHANGE_INSERT_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
         #define __FC_LINES_E 3
       #else
         #define __FC_LINES_E 2
       #endif
       #ifdef MSG_FILAMENT_CHANGE_INSERT_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
         #define _FC_LINES_E (__FC_LINES_E + 1)
@@ -4275,120 +4481,109 @@ void kill_screen(const char* lcd_msg) {
       #endif
       #if LCD_HEIGHT > _FC_LINES_E + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_load_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
       #ifdef MSG_FILAMENT_CHANGE_LOAD_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
         #define __FC_LINES_F 3
       #else
         #define __FC_LINES_F 2
       #endif
       #ifdef MSG_FILAMENT_CHANGE_LOAD_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
         #define _FC_LINES_F (__FC_LINES_F + 1)
       #else
         #define _FC_LINES_F __FC_LINES_F
       #endif
       #if LCD_HEIGHT > _FC_LINES_F + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
-    void lcd_advanced_pause_extrude_message() {
+    void lcd_advanced_pause_purge_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_1);
-      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_2);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
+      #ifdef MSG_FILAMENT_CHANGE_PURGE_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
         #define __FC_LINES_G 3
       #else
         #define __FC_LINES_G 2
       #endif
-      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_3);
+      #ifdef MSG_FILAMENT_CHANGE_PURGE_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
         #define _FC_LINES_G (__FC_LINES_G + 1)
       #else
         #define _FC_LINES_G __FC_LINES_G
       #endif
       #if LCD_HEIGHT > _FC_LINES_G + 1
         STATIC_ITEM(" ");
       #endif
       HOTEND_STATUS_ITEM();
       END_SCREEN();
     }
 
     void lcd_advanced_pause_resume_message() {
       START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM_P(advanced_pause_header(), true, true);
       STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
       #ifdef MSG_FILAMENT_CHANGE_RESUME_2
         STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
       #endif
       #ifdef MSG_FILAMENT_CHANGE_RESUME_3
         STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
       #endif
       END_SCREEN();
     }
 
-    void lcd_advanced_pause_show_message(const AdvancedPauseMessage message) {
+    FORCE_INLINE screenFunc_t ap_message_screen(const AdvancedPauseMessage message) {
       switch (message) {
-        case ADVANCED_PAUSE_MESSAGE_INIT:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_init_message);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_UNLOAD:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_unload_message);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_INSERT:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_insert_message);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_LOAD:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_load_message);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_EXTRUDE:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_extrude_message);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_heat_nozzle);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_wait_for_nozzles_to_heat);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_OPTION:
-          defer_return_to_status = true;
-          advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
-          lcd_goto_screen(lcd_advanced_pause_option_menu);
-          break;
-        case ADVANCED_PAUSE_MESSAGE_RESUME:
-          defer_return_to_status = true;
-          lcd_goto_screen(lcd_advanced_pause_resume_message);
-          break;
+        case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
+        case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
+        case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
+        case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
+        case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
+        case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
+        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
+        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
+        case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
+                                            return lcd_advanced_pause_option_menu;
         case ADVANCED_PAUSE_MESSAGE_STATUS:
-          lcd_return_to_status();
-          break;
+        default: break;
       }
+      return NULL;
+    }
+
+    void lcd_advanced_pause_show_message(
+      const AdvancedPauseMessage message,
+      const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
+      const uint8_t extruder/*=active_extruder*/
+    ) {
+      advanced_pause_mode = mode;
+      hotend_status_extruder = extruder;
+      const screenFunc_t next_screen = ap_message_screen(message);
+      if (next_screen) {
+        defer_return_to_status = true;
+        lcd_goto_screen(next_screen);
+      }
+      else
+        lcd_return_to_status();
     }
 
   #endif // ADVANCED_PAUSE_FEATURE
 
   /**
    *
    * Functions for editing single values
    *
    * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
    *
@@ -4735,21 +4930,21 @@ void lcd_update() {
       // Don't run the debouncer if UBL owns the display
       #define UBL_CONDITION !lcd_external_control
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user && !no_reentry; // Flag the click if allowed
+        lcd_clicked = !wait_for_user && !no_reentry; //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback();            //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;

commit 455592eee8485d32b3093d10210726c4de45145e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 3 22:05:12 2018 -0600

    Improvements to LCD menu macros

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 28f80c5056..cace6dd592 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -296,80 +296,84 @@ uint16_t max_display_update_time = 0;
    *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *
    */
   #define _MENU_ITEM_PART_1(TYPE, ...) \
     if (_menuLineNr == _thisItemNr) { \
       if (encoderLine == _thisItemNr && lcd_clicked) { \
         lcd_clicked = false
 
-  #define _MENU_ITEM_PART_2(TYPE, LABEL, ...) \
+  #define _MENU_ITEM_PART_2(TYPE, PLABEL, ...) \
         menu_action_ ## TYPE(__VA_ARGS__); \
         if (screen_changed) return; \
       } \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
+        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PLABEL, ## __VA_ARGS__); \
     } \
     ++_thisItemNr
 
-  #define MENU_ITEM(TYPE, LABEL, ...) do { \
+  #define MENU_ITEM_P(TYPE, PLABEL, ...) do { \
       _skipStatic = false; \
       _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
-      _MENU_ITEM_PART_2(TYPE, LABEL, ## __VA_ARGS__); \
+      _MENU_ITEM_PART_2(TYPE, PLABEL, ## __VA_ARGS__); \
     }while(0)
 
+  #define MENU_ITEM(TYPE, LABEL, ...) MENU_ITEM_P(TYPE, PSTR(LABEL), ## __VA_ARGS__)
+
   #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
 
   // Used to print static text with no visible cursor.
   // Parameters: label [, bool center [, bool invert [, char *value] ] ]
-  #define STATIC_ITEM(LABEL, ...) \
+  #define STATIC_ITEM_P(LABEL, ...) \
     if (_menuLineNr == _thisItemNr) { \
       if (_skipStatic && encoderLine <= _thisItemNr) { \
         encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
         ++encoderLine; \
       } \
       if (lcdDrawUpdate) \
-        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
+        lcd_implementation_drawmenu_static(_lcdLineNr, LABEL, ## __VA_ARGS__); \
     } \
     ++_thisItemNr
 
+  #define STATIC_ITEM(LABEL, ...) STATIC_ITEM_P(PSTR(LABEL), ## __VA_ARGS__)
+
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
     bool encoderRateMultiplierEnabled;
     #define ENCODER_RATE_MULTIPLY(F) (encoderRateMultiplierEnabled = F)
 
     //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
 
     /**
      * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item
      */
-    #define MENU_MULTIPLIER_ITEM(type, label, ...) do { \
-        _MENU_ITEM_PART_1(type, ## __VA_ARGS__); \
+    #define MENU_MULTIPLIER_ITEM(TYPE, LABEL, ...) do { \
+        _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
         encoderRateMultiplierEnabled = true; \
         lastEncoderMovementMillis = 0; \
-        _MENU_ITEM_PART_2(type, label, ## __VA_ARGS__); \
+        _MENU_ITEM_PART_2(TYPE, PSTR(LABEL), ## __VA_ARGS__); \
       }while(0)
 
   #else // !ENCODER_RATE_MULTIPLIER
     #define ENCODER_RATE_MULTIPLY(F) NOOP
   #endif // !ENCODER_RATE_MULTIPLIER
 
   #define MENU_ITEM_DUMMY() do { _thisItemNr++; }while(0)
-  #define MENU_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
-  #define MENU_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #else // !ENCODER_RATE_MULTIPLIER
-    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
-    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT(TYPE, LABEL, ...) MENU_ITEM(setting_edit_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(TYPE, LABEL, ...) MENU_ITEM(setting_edit_callback_ ## TYPE, LABEL, PSTR(LABEL), ## __VA_ARGS__)
   #endif // !ENCODER_RATE_MULTIPLIER
 
   /**
    * START_SCREEN_OR_MENU generates init code for a screen or menu
    *
    *   encoderLine is the position based on the encoder
    *   encoderTopLine is the top menu line to display
    *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
    *   _menuLineNr is the menu item to draw and process
    *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM

commit e43f3ac989973825b35af8f897f3c9c7e6533185
Author: Tannoo <tannoo@msn.com>
Date:   Mon Jan 1 14:18:25 2018 -0700

    EEPROM init fix

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f7cf9594f5..28f80c5056 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3202,22 +3202,21 @@ void kill_screen(const char* lcd_msg) {
   #endif
 
   static void lcd_factory_settings() {
     settings.reset();
     lcd_completion_feedback();
   }
 
   #if ENABLED(EEPROM_SETTINGS)
 
     static void lcd_init_eeprom() {
-      lcd_factory_settings();
-      settings.save();
+      lcd_completion_feedback(settings.init_eeprom());
       lcd_goto_previous_menu();
     }
 
     static void lcd_init_eeprom_confirm() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
       MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
       END_MENU();
     }
 

commit fc67c64b8f02dfc5c5aa79769f2e20435b0e09e9
Merge: eca5cc8669 8afc4f8d9d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 2 21:38:45 2018 -0600

    Merge pull request #8989 from tcm0116/2.0.x_ubl
    
    [2.0.x] Fix UBL compilation warnings

diff --combined Marlin/src/lcd/ultralcd.cpp
index 394bde8143,e93fdfa0e5..f7cf9594f5
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -1124,21 -1124,24 +1124,21 @@@ void kill_screen(const char* lcd_msg) 
        void lcd_babystep_zoffset() {
          if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
          defer_return_to_status = true;
          ENCODER_DIRECTION_NORMAL();
          if (encoderPosition) {
            const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
            encoderPosition = 0;
  
            const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
            if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 -
 -            if (planner.leveling_active)
 -              thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 -
 +            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
              zprobe_zoffset = new_zoffset;
              lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
            }
          }
          if (lcdDrawUpdate) {
            lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
            #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
              _lcd_zoffset_overlay_gfx(zprobe_zoffset);
            #endif
          }
@@@ -1741,23 -1744,29 +1741,29 @@@
      thermalManager.disable_all_heaters();
      lcd_return_to_status();
    }
  
    #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
  
      /**
       * If the queue is full, the command will fail, so we have to loop
       * with idle() to make sure the command has been enqueued.
       */
-     void lcd_enqueue_command_sram(char * const cmd) {
+     void lcd_enqueue_command(char * const cmd) {
        no_reentry = true;
-       while (enqueue_and_echo_command(cmd)) idle();
+       enqueue_and_echo_command_now(cmd);
+       no_reentry = false;
+     }
+ 
+     void lcd_enqueue_commands_P(const char * const cmd) {
+       no_reentry = true;
+       enqueue_and_echo_commands_P_now(cmd);
        no_reentry = false;
      }
  
    #endif
  
    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
  
      void lcd_autostart_sd() {
        card.autostart_index = 0;
        card.setroot();
@@@ -2072,24 -2081,24 +2078,24 @@@
      #endif
  
      /**
       * UBL Build Custom Mesh Command
       */
      void _lcd_ubl_build_custom_mesh() {
        char UBL_LCD_GCODE[20];
        enqueue_and_echo_commands_P(PSTR("G28"));
        #if HAS_TEMP_BED
          sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
-         lcd_enqueue_command_sram(UBL_LCD_GCODE);
+         lcd_enqueue_command(UBL_LCD_GCODE);
        #endif
        sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("G29 P1"));
      }
  
      /**
       * UBL Custom Mesh submenu
       *
       * << Build Mesh
       *    Hotend Temp: ---
       *    Bed Temp: ---
       *    Build Custom Mesh
@@@ -2106,21 -2115,21 +2112,21 @@@
      }
  
      /**
       * UBL Adjust Mesh Height Command
       */
      void _lcd_ubl_adjust_height_cmd() {
        char UBL_LCD_GCODE[16];
        const int ind = ubl_height_amount > 0 ? 9 : 10;
        strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
        sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Adjust Mesh Height submenu
       *
       * << Edit Mesh
       *    Height Amount: ---
       *    Adjust Mesh Height
       * << Info Screen
       */
@@@ -2157,22 -2166,22 +2163,22 @@@
      void _lcd_ubl_validate_custom_mesh() {
        char UBL_LCD_GCODE[24];
        const int temp =
          #if HAS_TEMP_BED
            custom_bed_temp
          #else
            0
          #endif
        ;
        sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
-       lcd_enqueue_command_sram("G28");
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_commands_P(PSTR("G28"));
+       lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Validate Mesh submenu
       *
       * << UBL Tools
       *    PLA Mesh Validation
       *    ABS Mesh Validation
       *    Validate Custom Mesh
       * << Info Screen
@@@ -2191,21 -2200,21 +2197,21 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Grid Leveling Command
       */
      void _lcd_ubl_grid_level_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Grid Leveling submenu
       *
       * << UBL Tools
       *    Side points: ---
       *    Level Mesh
       */
      void _lcd_ubl_grid_level() {
@@@ -2232,21 -2241,21 +2238,21 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Fill-in Amount Mesh Command
       */
      void _lcd_ubl_fillin_amount_cmd() {
        char UBL_LCD_GCODE[16];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL Fill-in Mesh submenu
       *
       * << Build Mesh
       *    Fill-in Amount: ---
       *    Fill-in Mesh
       *    Smart Fill-in
       *    Manual Fill-in
@@@ -2324,31 -2333,31 +2330,31 @@@
        MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
        END_MENU();
      }
  
      /**
       * UBL Load Mesh Command
       */
      void _lcd_ubl_load_mesh_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_LOADED "."));
      }
  
      /**
       * UBL Save Mesh Command
       */
      void _lcd_ubl_save_mesh_cmd() {
        char UBL_LCD_GCODE[10];
        sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
        enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_SAVED "."));
      }
  
      /**
       * UBL Mesh Storage submenu
       *
       * << Unified Bed Leveling
       *    Memory Slot: ---
       *    Load Bed Mesh
       *    Save Bed Mesh
@@@ -2385,21 -2394,21 +2391,21 @@@
      }
  
      /**
       * UBL LCD "radar" map point editing
       */
      void _lcd_ubl_map_lcd_edit_cmd() {
        char UBL_LCD_GCODE[50], str[10], str2[10];
        dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
        dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
        snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
-       lcd_enqueue_command_sram(UBL_LCD_GCODE);
+       lcd_enqueue_command(UBL_LCD_GCODE);
      }
  
      /**
       * UBL LCD Map Movement
       */
      void ubl_map_move_to_xy() {
        current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
        current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
      }
@@@ -3223,21 -3232,21 +3229,21 @@@
      MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
      MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
  
      #if DISABLED(NO_VOLUMETRICS)
        MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
      #elif ENABLED(LIN_ADVANCE)
        MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
      #endif
  
      #if HAS_LCD_CONTRAST
 -      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
 +      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*) &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
      #endif
      #if ENABLED(FWRETRACT)
        MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
      #endif
      #if ENABLED(DAC_STEPPER_CURRENT)
        MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
      #endif
      #if HAS_MOTOR_CURRENT_PWM
        MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
      #endif
@@@ -3280,21 -3289,21 +3286,21 @@@
        char cmd[30];
        sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
          #if HAS_PID_FOR_BOTH
            e < 0 ? autotune_temp_bed : autotune_temp[e]
          #elif ENABLED(PIDTEMPBED)
            autotune_temp_bed
          #else
            autotune_temp[e]
          #endif
        );
-       lcd_enqueue_command_sram(cmd);
+       lcd_enqueue_command(cmd);
      }
  
    #endif // PID_AUTOTUNE_MENU
  
    #if ENABLED(PIDTEMP)
  
      // Helpers for editing PID Ki & Kd values
      // grab the PID value out of the temp variable; scale it; then update the PID driver
      void copy_and_scalePID_i(int16_t e) {
        #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1

commit 8afc4f8d9d629781f847b628ca1708e44be83725
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Tue Jan 2 21:00:06 2018 -0600

    Fix UBL compilation warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 840f1bbb90..e93fdfa0e5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1744,23 +1744,29 @@ void kill_screen(const char* lcd_msg) {
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
 
     /**
      * If the queue is full, the command will fail, so we have to loop
      * with idle() to make sure the command has been enqueued.
      */
-    void lcd_enqueue_command_sram(char * const cmd) {
+    void lcd_enqueue_command(char * const cmd) {
       no_reentry = true;
-      while (enqueue_and_echo_command(cmd)) idle();
+      enqueue_and_echo_command_now(cmd);
+      no_reentry = false;
+    }
+
+    void lcd_enqueue_commands_P(const char * const cmd) {
+      no_reentry = true;
+      enqueue_and_echo_commands_P_now(cmd);
       no_reentry = false;
     }
 
   #endif
 
   #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
     void lcd_autostart_sd() {
       card.autostart_index = 0;
       card.setroot();
@@ -2075,24 +2081,24 @@ void kill_screen(const char* lcd_msg) {
     #endif
 
     /**
      * UBL Build Custom Mesh Command
      */
     void _lcd_ubl_build_custom_mesh() {
       char UBL_LCD_GCODE[20];
       enqueue_and_echo_commands_P(PSTR("G28"));
       #if HAS_TEMP_BED
         sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
-        lcd_enqueue_command_sram(UBL_LCD_GCODE);
+        lcd_enqueue_command(UBL_LCD_GCODE);
       #endif
       sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
       enqueue_and_echo_commands_P(PSTR("G29 P1"));
     }
 
     /**
      * UBL Custom Mesh submenu
      *
      * << Build Mesh
      *    Hotend Temp: ---
      *    Bed Temp: ---
      *    Build Custom Mesh
@@ -2109,21 +2115,21 @@ void kill_screen(const char* lcd_msg) {
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
       const int ind = ubl_height_amount > 0 ? 9 : 10;
       strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
       sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Adjust Mesh Height submenu
      *
      * << Edit Mesh
      *    Height Amount: ---
      *    Adjust Mesh Height
      * << Info Screen
      */
@@ -2160,22 +2166,22 @@ void kill_screen(const char* lcd_msg) {
     void _lcd_ubl_validate_custom_mesh() {
       char UBL_LCD_GCODE[24];
       const int temp =
         #if HAS_TEMP_BED
           custom_bed_temp
         #else
           0
         #endif
       ;
       sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
-      lcd_enqueue_command_sram("G28");
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_commands_P(PSTR("G28"));
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Validate Mesh submenu
      *
      * << UBL Tools
      *    PLA Mesh Validation
      *    ABS Mesh Validation
      *    Validate Custom Mesh
      * << Info Screen
@@ -2194,21 +2200,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Grid Leveling Command
      */
     void _lcd_ubl_grid_level_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Grid Leveling submenu
      *
      * << UBL Tools
      *    Side points: ---
      *    Level Mesh
      */
     void _lcd_ubl_grid_level() {
@@ -2235,21 +2241,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Fill-in Amount Mesh Command
      */
     void _lcd_ubl_fillin_amount_cmd() {
       char UBL_LCD_GCODE[16];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Fill-in Mesh submenu
      *
      * << Build Mesh
      *    Fill-in Amount: ---
      *    Fill-in Mesh
      *    Smart Fill-in
      *    Manual Fill-in
@@ -2327,31 +2333,31 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Load Mesh Command
      */
     void _lcd_ubl_load_mesh_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
       enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_LOADED "."));
     }
 
     /**
      * UBL Save Mesh Command
      */
     void _lcd_ubl_save_mesh_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
       enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_SAVED "."));
     }
 
     /**
      * UBL Mesh Storage submenu
      *
      * << Unified Bed Leveling
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
@@ -2388,21 +2394,21 @@ void kill_screen(const char* lcd_msg) {
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {
       char UBL_LCD_GCODE[50], str[10], str2[10];
       dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
       dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
       snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
-      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      lcd_enqueue_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL LCD Map Movement
      */
     void ubl_map_move_to_xy() {
       current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
       current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
     }
@@ -3283,21 +3289,21 @@ void kill_screen(const char* lcd_msg) {
       char cmd[30];
       sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
         #if HAS_PID_FOR_BOTH
           e < 0 ? autotune_temp_bed : autotune_temp[e]
         #elif ENABLED(PIDTEMPBED)
           autotune_temp_bed
         #else
           autotune_temp[e]
         #endif
       );
-      lcd_enqueue_command_sram(cmd);
+      lcd_enqueue_command(cmd);
     }
 
   #endif // PID_AUTOTUNE_MENU
 
   #if ENABLED(PIDTEMP)
 
     // Helpers for editing PID Ki & Kd values
     // grab the PID value out of the temp variable; scale it; then update the PID driver
     void copy_and_scalePID_i(int16_t e) {
       #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1

commit e9fc7bc69c18dce9c38dd390df860a0fa90ac4b3
Merge: 448b0a0014 ef911a2d12
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Tue Jan 2 18:46:31 2018 -0600

    Merge pull request #9000 from Bob-the-Kuhn/2.0-LCD-contrast
    
    [2.0.x] lcd_contrast type mismatch work around

diff --combined Marlin/src/lcd/ultralcd.cpp
index 85996b6de7,9bfcc39536..394bde8143
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -1124,21 -1124,24 +1124,21 @@@ void kill_screen(const char* lcd_msg) 
        void lcd_babystep_zoffset() {
          if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
          defer_return_to_status = true;
          ENCODER_DIRECTION_NORMAL();
          if (encoderPosition) {
            const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
            encoderPosition = 0;
  
            const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
            if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 -
 -            if (planner.leveling_active)
 -              thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 -
 +            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
              zprobe_zoffset = new_zoffset;
              lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
            }
          }
          if (lcdDrawUpdate) {
            lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
            #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
              _lcd_zoffset_overlay_gfx(zprobe_zoffset);
            #endif
          }
@@@ -3223,21 -3226,21 +3223,21 @@@
      MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
      MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
  
      #if DISABLED(NO_VOLUMETRICS)
        MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
      #elif ENABLED(LIN_ADVANCE)
        MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
      #endif
  
      #if HAS_LCD_CONTRAST
-       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*) &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
      #endif
      #if ENABLED(FWRETRACT)
        MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
      #endif
      #if ENABLED(DAC_STEPPER_CURRENT)
        MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
      #endif
      #if HAS_MOTOR_CURRENT_PWM
        MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
      #endif

commit 39e5fabfa9ac3cb79947308432bbdef353fd362b
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Jan 1 14:46:50 2018 -0600

    Z BabyStepping should not be dependent on a bed leveling system being active

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 840f1bbb90..85996b6de7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1124,24 +1124,21 @@ void kill_screen(const char* lcd_msg) {
       void lcd_babystep_zoffset() {
         if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-
-            if (planner.leveling_active)
-              thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-
+            thermalManager.babystep_axis(Z_AXIS, babystep_increment);
             zprobe_zoffset = new_zoffset;
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
             _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }

commit ef911a2d12d29ff4e3c2080ac9bbc4dc4bc1aeb5
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Mon Jan 1 14:35:16 2018 -0600

    works

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 840f1bbb90..9bfcc39536 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3226,21 +3226,21 @@ void kill_screen(const char* lcd_msg) {
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
 
     #if DISABLED(NO_VOLUMETRICS)
       MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
     #elif ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
     #if HAS_LCD_CONTRAST
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*) &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif

commit 2929c9e56f5e3b4ab11de3f33367d5be43f6c6ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 30 23:57:12 2017 -0600

    A specific option to SLIM_LCD_MENUS

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0bd42289d3..840f1bbb90 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -169,24 +169,27 @@ uint16_t max_display_update_time = 0;
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
-  void lcd_control_temperature_preheat_material1_settings_menu();
-  void lcd_control_temperature_preheat_material2_settings_menu();
   void lcd_control_motion_menu();
 
+  #if DISABLED(SLIM_LCD_MENUS)
+    void lcd_control_temperature_preheat_material1_settings_menu();
+    void lcd_control_temperature_preheat_material2_settings_menu();
+  #endif
+
   #if DISABLED(NO_VOLUMETRICS)
     void lcd_control_filament_menu();
   #endif
 
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
@@ -2620,30 +2623,30 @@ void kill_screen(const char* lcd_msg) {
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
           MENU_ITEM(submenu, MSG_BED_LEVELING,
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               _lcd_goto_bed_leveling
             #else
               lcd_bed_leveling
             #endif
           );
-    #elif PLANNER_LEVELING && DISABLED(PROBE_MANUALLY)
+    #elif PLANNER_LEVELING && DISABLED(PROBE_MANUALLY) && DISABLED(SLIM_LCD_MENUS)
       MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
-    #if HAS_M206_COMMAND
+    #if HAS_M206_COMMAND && DISABLED(SLIM_LCD_MENUS)
       //
       // Set Home Offsets
       //
       MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
       //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
     #endif
 
     //
     // Disable Steppers
     //
@@ -3243,22 +3246,24 @@ void kill_screen(const char* lcd_msg) {
     #endif
 
     #if ENABLED(BLTOUCH)
       MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
     #endif
 
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif
+
     MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
-    #if ENABLED(EEPROM_SETTINGS)
+
+    #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
       MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Temperature" submenu
    *
@@ -3456,264 +3461,274 @@ void kill_screen(const char* lcd_msg) {
               PID_MENU_ITEMS(" " MSG_E5, 4);
             #endif // HOTENDS > 4
           #endif // HOTENDS > 3
         #endif // HOTENDS > 2
       #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
         PID_MENU_ITEMS("", 0);
       #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
 
     #endif // PIDTEMP
 
-    //
-    // Preheat Material 1 conf
-    //
-    MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_control_temperature_preheat_material1_settings_menu);
-
-    //
-    // Preheat Material 2 conf
-    //
-    MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
-    END_MENU();
-  }
+    #if DISABLED(SLIM_LCD_MENUS)
+      //
+      // Preheat Material 1 conf
+      //
+      MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_control_temperature_preheat_material1_settings_menu);
 
-  void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
-    #if HOTENDS > 4
-      #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
-      #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
-    #elif HOTENDS > 3
-      #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
-      #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
-    #elif HOTENDS > 2
-      #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
-      #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
-    #elif HOTENDS > 1
-      #define MINTEMP_ALL min(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
-      #define MAXTEMP_ALL max(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
-    #else
-      #define MINTEMP_ALL HEATER_0_MINTEMP
-      #define MAXTEMP_ALL HEATER_0_MAXTEMP
-    #endif
-    START_MENU();
-    MENU_BACK(MSG_TEMPERATURE);
-    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
-    #if TEMP_SENSOR_0 != 0
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
-    #endif
-    #if TEMP_SENSOR_BED != 0
-      MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
-    #endif
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+      //
+      // Preheat Material 2 conf
+      //
+      MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
     #endif
+
     END_MENU();
   }
 
-  /**
-   *
-   * "Temperature" > "Preheat Material 1 conf" submenu
-   *
-   */
-  void lcd_control_temperature_preheat_material1_settings_menu() { _lcd_control_temperature_preheat_settings_menu(0); }
-
-  /**
-   *
-   * "Temperature" > "Preheat Material 2 conf" submenu
-   *
-   */
-  void lcd_control_temperature_preheat_material2_settings_menu() { _lcd_control_temperature_preheat_settings_menu(1); }
-
-
-  /**
-   *
-   * "Control" > "Motion" submenu
-   *
-   */
-
-  void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
-  #if ENABLED(DISTINCT_E_FACTORS)
-    void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
-    void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
-    void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
-    #if E_STEPPERS > 2
-      void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
-      #if E_STEPPERS > 3
-        void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
-        #if E_STEPPERS > 4
-          void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
-        #endif // E_STEPPERS > 4
-      #endif // E_STEPPERS > 3
-    #endif // E_STEPPERS > 2
-  #endif
-
-  void _planner_refresh_positioning() { planner.refresh_positioning(); }
-  #if ENABLED(DISTINCT_E_FACTORS)
-    void _planner_refresh_e_positioning(const uint8_t e) {
-      if (e == active_extruder)
-        _planner_refresh_positioning();
-      else
-        planner.steps_to_mm[E_AXIS + e] = 1.0 / planner.axis_steps_per_mm[E_AXIS + e];
-    }
-    void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
-    void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
-    #if E_STEPPERS > 2
-      void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
-      #if E_STEPPERS > 3
-        void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
-        #if E_STEPPERS > 4
-          void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
-        #endif // E_STEPPERS > 4
-      #endif // E_STEPPERS > 3
-    #endif // E_STEPPERS > 2
-  #endif
+  #if DISABLED(SLIM_LCD_MENUS)
+
+    void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
+      #if HOTENDS > 4
+        #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
+        #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
+      #elif HOTENDS > 3
+        #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
+        #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
+      #elif HOTENDS > 2
+        #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
+        #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
+      #elif HOTENDS > 1
+        #define MINTEMP_ALL min(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
+        #define MAXTEMP_ALL max(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
+      #else
+        #define MINTEMP_ALL HEATER_0_MINTEMP
+        #define MAXTEMP_ALL HEATER_0_MAXTEMP
+      #endif
+      START_MENU();
+      MENU_BACK(MSG_TEMPERATURE);
+      MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
+      #if TEMP_SENSOR_0 != 0
+        MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
+      #endif
+      #if TEMP_SENSOR_BED != 0
+        MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
+      #endif
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+      #endif
+      END_MENU();
+    }
 
-  // M203 / M205 Velocity options
-  void lcd_control_motion_velocity_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
+    /**
+     *
+     * "Temperature" > "Preheat Material 1 conf" submenu
+     *
+     */
+    void lcd_control_temperature_preheat_material1_settings_menu() { _lcd_control_temperature_preheat_settings_menu(0); }
 
-    // M203 Max Feedrate
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate_mm_s[X_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate_mm_s[Y_AXIS], 1, 999);
-    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate_mm_s[Z_AXIS], 1, 999);
+    /**
+     *
+     * "Temperature" > "Preheat Material 2 conf" submenu
+     *
+     */
+    void lcd_control_temperature_preheat_material2_settings_menu() { _lcd_control_temperature_preheat_settings_menu(1); }
 
+    void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
     #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+      void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
+      void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
+      void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
       #if E_STEPPERS > 2
-        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+        void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
         #if E_STEPPERS > 3
-          MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+          void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
           #if E_STEPPERS > 4
-            MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+            void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
           #endif // E_STEPPERS > 4
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
-    #else
-      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
     #endif
 
-    // M205 S Min Feedrate
-    MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
-
-    // M205 T Min Travel Feedrate
-    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
-
-    END_MENU();
-  }
-
-  // M201 / M204 Accelerations
-  void lcd_control_motion_acceleration_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
-
-    // M204 P Acceleration
-    MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
-
-    // M204 R Retract Acceleration
-    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
-
-    // M204 T Travel Acceleration
-    MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
-
-    // M201 settings
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
-    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
-
+    void _planner_refresh_positioning() { planner.refresh_positioning(); }
     #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+      void _planner_refresh_e_positioning(const uint8_t e) {
+        if (e == active_extruder)
+          _planner_refresh_positioning();
+        else
+          planner.steps_to_mm[E_AXIS + e] = 1.0 / planner.axis_steps_per_mm[E_AXIS + e];
+      }
+      void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
+      void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
       #if E_STEPPERS > 2
-        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+        void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
         #if E_STEPPERS > 3
-          MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+          void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
           #if E_STEPPERS > 4
-            MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+            void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
           #endif // E_STEPPERS > 4
         #endif // E_STEPPERS > 3
       #endif // E_STEPPERS > 2
-    #else
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
     #endif
 
-    END_MENU();
-  }
+    // M203 / M205 Velocity options
+    void lcd_control_motion_velocity_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MOTION);
+
+      // M203 Max Feedrate
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate_mm_s[X_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate_mm_s[Y_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate_mm_s[Z_AXIS], 1, 999);
+
+      #if ENABLED(DISTINCT_E_FACTORS)
+        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
+        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+        #if E_STEPPERS > 2
+          MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+          #if E_STEPPERS > 3
+            MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+            #if E_STEPPERS > 4
+              MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+            #endif // E_STEPPERS > 4
+          #endif // E_STEPPERS > 3
+        #endif // E_STEPPERS > 2
+      #else
+        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+      #endif
 
-  // M205 Jerk
-  void lcd_control_motion_jerk_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
+      // M205 S Min Feedrate
+      MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
 
-    MENU_ITEM_EDIT(float3, MSG_VX_JERK, &planner.max_jerk[X_AXIS], 1, 990);
-    MENU_ITEM_EDIT(float3, MSG_VY_JERK, &planner.max_jerk[Y_AXIS], 1, 990);
-    #if ENABLED(DELTA)
-      MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 1, 990);
-    #else
-      MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 0.1, 990);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+      // M205 T Min Travel Feedrate
+      MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
 
-    END_MENU();
-  }
+      END_MENU();
+    }
 
-  // M92 Steps-per-mm
-  void lcd_control_motion_steps_per_mm_menu() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
+    // M201 / M204 Accelerations
+    void lcd_control_motion_acceleration_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MOTION);
+
+      // M204 P Acceleration
+      MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
+
+      // M204 R Retract Acceleration
+      MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
+
+      // M204 T Travel Acceleration
+      MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
+
+      // M201 settings
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
+
+      #if ENABLED(DISTINCT_E_FACTORS)
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+        #if E_STEPPERS > 2
+          MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+          #if E_STEPPERS > 3
+            MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+            #if E_STEPPERS > 4
+              MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+            #endif // E_STEPPERS > 4
+          #endif // E_STEPPERS > 3
+        #endif // E_STEPPERS > 2
+      #else
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+      #endif
 
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999, _planner_refresh_positioning);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999, _planner_refresh_positioning);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
+      END_MENU();
+    }
 
-    #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
-      #if E_STEPPERS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
-        #if E_STEPPERS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
-          #if E_STEPPERS > 4
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #else
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
-    #endif
+    // M205 Jerk
+    void lcd_control_motion_jerk_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MOTION);
 
-    END_MENU();
-  }
+      MENU_ITEM_EDIT(float3, MSG_VX_JERK, &planner.max_jerk[X_AXIS], 1, 990);
+      MENU_ITEM_EDIT(float3, MSG_VY_JERK, &planner.max_jerk[Y_AXIS], 1, 990);
+      #if ENABLED(DELTA)
+        MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 1, 990);
+      #else
+        MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 0.1, 990);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+
+      END_MENU();
+    }
+
+    // M92 Steps-per-mm
+    void lcd_control_motion_steps_per_mm_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MOTION);
+
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
+
+      #if ENABLED(DISTINCT_E_FACTORS)
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
+        #if E_STEPPERS > 2
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
+          #if E_STEPPERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
+            #if E_STEPPERS > 4
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
+            #endif // E_STEPPERS > 4
+          #endif // E_STEPPERS > 3
+        #endif // E_STEPPERS > 2
+      #else
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
+      #endif
+
+      END_MENU();
+    }
+
+  #endif // !SLIM_LCD_MENUS
+
+  /**
+   *
+   * "Control" > "Motion" submenu
+   *
+   */
 
   void lcd_control_motion_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
     #elif HAS_BED_PROBE
       MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
 
-    // M203 / M205 - Feedrate items
-    MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
+    #if DISABLED(SLIM_LCD_MENUS)
+
+      // M203 / M205 - Feedrate items
+      MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
+
+      // M201 - Acceleration items
+      MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
 
-    // M201 - Acceleration items
-    MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
+      // M205 - Max Jerk
+      MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);
 
-    // M205 - Max Jerk
-    MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);
+      // M92 - Steps Per mm
+      MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
 
-    // M92 - Steps Per mm
-    MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
+    #endif // !SLIM_LCD_MENUS
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
     #endif
 
     END_MENU();
   }
 
   #if DISABLED(NO_VOLUMETRICS)

commit 615146c06920cec731b4f75e8bb5b21d3b8f16d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 30 04:08:26 2017 -0600

    Enqueue commands better in ultralcd.cpp

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 48db56c8ba..0bd42289d3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -157,20 +157,22 @@ uint16_t max_display_update_time = 0;
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   #if HAS_POWER_SWITCH
     extern bool powersupply_on;
   #endif
 
+  bool no_reentry = false;
+
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
@@ -565,28 +567,27 @@ uint16_t max_display_update_time = 0;
    */
   static const char moving[] PROGMEM = MSG_MOVING;
   static const char *sync_message = moving;
 
   //
   // Display the synchronize screen until moves are
   // finished, and don't return to the caller until
   // done. ** This blocks the command queue! **
   //
   void _lcd_synchronize() {
-    static bool no_reentry = false;
     if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
     if (no_reentry) return;
     // Make this the current handler till all moves are done
     no_reentry = true;
     const screenFunc_t old_screen = currentScreen;
     lcd_goto_screen(_lcd_synchronize);
-    stepper.synchronize();
+    stepper.synchronize(); // idle() is called until moves complete
     no_reentry = false;
     lcd_goto_screen(old_screen);
   }
 
   // Display the synchronize screen with a custom message
   // ** This blocks the command queue! **
   void lcd_synchronize(const char * const msg=NULL) {
     sync_message = msg ? msg : moving;
     _lcd_synchronize();
   }
@@ -1734,20 +1735,34 @@ void kill_screen(const char* lcd_msg) {
   #endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_4 || TEMP_SENSOR_BED)
 
   void lcd_cooldown() {
     #if FAN_COUNT > 0
       for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
     #endif
     thermalManager.disable_all_heaters();
     lcd_return_to_status();
   }
 
+  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
+
+    /**
+     * If the queue is full, the command will fail, so we have to loop
+     * with idle() to make sure the command has been enqueued.
+     */
+    void lcd_enqueue_command_sram(char * const cmd) {
+      no_reentry = true;
+      while (enqueue_and_echo_command(cmd)) idle();
+      no_reentry = false;
+    }
+
+  #endif
+
   #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
 
     void lcd_autostart_sd() {
       card.autostart_index = 0;
       card.setroot();
       card.checkautostart(true);
     }
 
   #endif
 
@@ -1910,21 +1925,20 @@ void kill_screen(const char* lcd_msg) {
         lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
       }
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
       if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
     }
 
     /**
      * Step 5: Initiate a move to the next point
      */
     void _lcd_level_goto_next_point() {
-      // Set the menu to display ahead of blocking call
       lcd_goto_screen(_lcd_level_bed_moving);
 
       // G29 Records Z, moves, and signals when it pauses
       lcd_wait_for_move = true;
       #if ENABLED(PROBE_MANUALLY)
         enqueue_and_echo_commands_P(PSTR("G29 V1"));
       #elif ENABLED(MESH_BED_LEVELING)
         enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
       #endif
     }
@@ -2058,24 +2072,24 @@ void kill_screen(const char* lcd_msg) {
     #endif
 
     /**
      * UBL Build Custom Mesh Command
      */
     void _lcd_ubl_build_custom_mesh() {
       char UBL_LCD_GCODE[20];
       enqueue_and_echo_commands_P(PSTR("G28"));
       #if HAS_TEMP_BED
         sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
-        enqueue_and_echo_command(UBL_LCD_GCODE);
+        lcd_enqueue_command_sram(UBL_LCD_GCODE);
       #endif
       sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
       enqueue_and_echo_commands_P(PSTR("G29 P1"));
     }
 
     /**
      * UBL Custom Mesh submenu
      *
      * << Build Mesh
      *    Hotend Temp: ---
      *    Bed Temp: ---
      *    Build Custom Mesh
@@ -2092,21 +2106,21 @@ void kill_screen(const char* lcd_msg) {
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
       const int ind = ubl_height_amount > 0 ? 9 : 10;
       strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
       sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Adjust Mesh Height submenu
      *
      * << Edit Mesh
      *    Height Amount: ---
      *    Adjust Mesh Height
      * << Info Screen
      */
@@ -2142,22 +2156,23 @@ void kill_screen(const char* lcd_msg) {
      */
     void _lcd_ubl_validate_custom_mesh() {
       char UBL_LCD_GCODE[24];
       const int temp =
         #if HAS_TEMP_BED
           custom_bed_temp
         #else
           0
         #endif
       ;
-      sprintf_P(UBL_LCD_GCODE, PSTR("G28\nG26 C B%i H%i P"), temp, custom_hotend_temp);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
+      lcd_enqueue_command_sram("G28");
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Validate Mesh submenu
      *
      * << UBL Tools
      *    PLA Mesh Validation
      *    ABS Mesh Validation
      *    Validate Custom Mesh
      * << Info Screen
@@ -2176,21 +2191,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Grid Leveling Command
      */
     void _lcd_ubl_grid_level_cmd() {
       char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Grid Leveling submenu
      *
      * << UBL Tools
      *    Side points: ---
      *    Level Mesh
      */
     void _lcd_ubl_grid_level() {
@@ -2217,47 +2232,38 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Fill-in Amount Mesh Command
      */
     void _lcd_ubl_fillin_amount_cmd() {
       char UBL_LCD_GCODE[16];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
-    }
-
-    /**
-     * UBL Smart Fill-in Command
-     */
-    void _lcd_ubl_smart_fillin_cmd() {
-      char UBL_LCD_GCODE[12];
-      sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 T0"));
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Fill-in Mesh submenu
      *
      * << Build Mesh
      *    Fill-in Amount: ---
      *    Fill-in Mesh
      *    Smart Fill-in
      *    Manual Fill-in
      * << Info Screen
      */
     void _lcd_ubl_fillin_menu() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9, _lcd_ubl_fillin_amount_cmd);
-      MENU_ITEM(function, MSG_UBL_SMART_FILLIN, _lcd_ubl_smart_fillin_cmd);
+      MENU_ITEM(gcode, MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
       MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     void _lcd_ubl_invalidate() {
       ubl.invalidate();
       SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
     }
 
@@ -2316,36 +2322,34 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
       MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Load Mesh Command
      */
     void _lcd_ubl_load_mesh_cmd() {
-      char UBL_LCD_GCODE[25];
+      char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
-      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED "."), ubl_storage_slot);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_LOADED "."));
     }
 
     /**
      * UBL Save Mesh Command
      */
     void _lcd_ubl_save_mesh_cmd() {
-      char UBL_LCD_GCODE[25];
+      char UBL_LCD_GCODE[10];
       sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
-      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED "."), ubl_storage_slot);
-      enqueue_and_echo_command(UBL_LCD_GCODE);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
+      enqueue_and_echo_commands_P(PSTR("M117 " MSG_MESH_SAVED "."));
     }
 
     /**
      * UBL Mesh Storage submenu
      *
      * << Unified Bed Leveling
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
      */
@@ -2377,26 +2381,25 @@ void kill_screen(const char* lcd_msg) {
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
         ubl.lcd_map_control = true; // Return to the map screen
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       }
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {
-      char ubl_lcd_gcode [50], str[10], str2[10];
-
+      char UBL_LCD_GCODE[50], str[10], str2[10];
       dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
       dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
-      snprintf_P(ubl_lcd_gcode, sizeof(ubl_lcd_gcode), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
-      enqueue_and_echo_command(ubl_lcd_gcode);
+      snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
+      lcd_enqueue_command_sram(UBL_LCD_GCODE);
     }
 
     /**
      * UBL LCD Map Movement
      */
     void ubl_map_move_to_xy() {
       current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
       current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
     }
@@ -2530,21 +2533,21 @@ void kill_screen(const char* lcd_msg) {
      *  - 3 Validate Mesh >>
      *    4 Fine Tune All
      *  - 5 Validate Mesh >>
      *    6 Fine Tune All
      *    7 Save Bed Mesh
      */
     void _lcd_ubl_step_by_step() {
       START_MENU();
       MENU_BACK(MSG_UBL_LEVEL_BED);
       MENU_ITEM(gcode, "1 " MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
-      MENU_ITEM(function, "2 " MSG_UBL_SMART_FILLIN, _lcd_ubl_smart_fillin_cmd);
+      MENU_ITEM(gcode, "2 " MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
       MENU_ITEM(submenu, "3 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
       MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
       MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
       MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
       MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
       END_MENU();
     }
 
     /**
      * UBL System submenu
@@ -2972,25 +2975,24 @@ void kill_screen(const char* lcd_msg) {
         if ((int32_t)encoderPosition < 0) NOLESS(manual_move_offset, min - current_position[axis]);
         if ((int32_t)encoderPosition > 0) NOMORE(manual_move_offset, max - current_position[axis]);
       #else
         current_position[axis] += diff;
         // Limit only when trying to move towards the limit
         if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
         if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
       #endif
 
       manual_move_to_current(axis);
-
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
     encoderPosition = 0;
-    if (lcdDrawUpdate && !processing_manual_move) {
+    if (lcdDrawUpdate) {
       const float pos = current_position[axis]
         #if IS_KINEMATIC
           + manual_move_offset
         #endif
       ;
       lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
@@ -3012,21 +3014,21 @@ void kill_screen(const char* lcd_msg) {
         #endif
         manual_move_to_current(E_AXIS
           #if E_MANUAL > 1
             , eindex
           #endif
         );
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
       encoderPosition = 0;
     }
-    if (lcdDrawUpdate && !processing_manual_move) {
+    if (lcdDrawUpdate) {
       PGM_P pos_label;
       #if E_MANUAL == 1
         pos_label = PSTR(MSG_MOVE_E);
       #else
         switch (eindex) {
           default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
           case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
           #if E_MANUAL > 2
             case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
             #if E_MANUAL > 3
@@ -3276,21 +3278,21 @@ void kill_screen(const char* lcd_msg) {
       char cmd[30];
       sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
         #if HAS_PID_FOR_BOTH
           e < 0 ? autotune_temp_bed : autotune_temp[e]
         #elif ENABLED(PIDTEMPBED)
           autotune_temp_bed
         #else
           autotune_temp[e]
         #endif
       );
-      enqueue_and_echo_command(cmd);
+      lcd_enqueue_command_sram(cmd);
     }
 
   #endif // PID_AUTOTUNE_MENU
 
   #if ENABLED(PIDTEMP)
 
     // Helpers for editing PID Ki & Kd values
     // grab the PID value out of the temp variable; scale it; then update the PID driver
     void copy_and_scalePID_i(int16_t e) {
       #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
@@ -4712,21 +4714,21 @@ void lcd_update() {
       // Don't run the debouncer if UBL owns the display
       #define UBL_CONDITION !lcd_external_control
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
-        lcd_clicked = !wait_for_user;    //  Keep the click if not waiting for a user-click
+        lcd_clicked = !wait_for_user && !no_reentry; // Flag the click if allowed
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback();            //  Always make a click sound
       }
     }
     else wait_for_unclick = false;
   #endif
 
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
 
     const bool sd_status = IS_SD_INSERTED;

commit 9ecdd1f4c73c4302af465c2566c48d5618fd76c6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 26 22:16:13 2017 -0600

    Multi extruder support for M600 and LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 44ff950198..48db56c8ba 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1239,35 +1239,71 @@ void kill_screen(const char* lcd_msg) {
   #endif // HAS_TEMP_HOTEND
 
   void watch_temp_callback_bed() {
     #if WATCH_THE_BED
       thermalManager.start_watching_bed();
     #endif
   }
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
-    void lcd_enqueue_filament_change() {
+    void lcd_enqueue_filament_change(
+      #if EXTRUDERS > 1
+        const uint8_t extruder
+      #endif
+    ) {
 
       #if ENABLED(PREVENT_COLD_EXTRUSION)
-        if (!DEBUGGING(DRYRUN) && !thermalManager.allow_cold_extrude &&
-            thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
+        if (!DEBUGGING(DRYRUN) && thermalManager.tooColdToExtrude(active_extruder)) {
           lcd_save_previous_screen();
           lcd_goto_screen(lcd_advanced_pause_toocold_menu);
           return;
         }
       #endif
 
       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
-      enqueue_and_echo_commands_P(PSTR("M600 B0"));
+
+      #if EXTRUDERS <= 1
+        enqueue_and_echo_commands_P(PSTR("M600 B0"));
+      #else
+        char *command_M600;
+        switch (extruder) {
+          case 0: command_M600 = PSTR("M600 B0 T0"); break;
+          case 1: command_M600 = PSTR("M600 B0 T1"); break;
+          #if EXTRUDERS > 2
+            case 2: command_M600 = PSTR("M600 B0 T2"); break;
+            #if EXTRUDERS > 3
+              case 3: command_M600 = PSTR("M600 B0 T3"); break;
+              #if EXTRUDERS > 4
+                case 4: command_M600 = PSTR("M600 B0 T4"); break;
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        }
+        enqueue_and_echo_commands_P(command_M600);
+      #endif // EXTRUDERS > 1
     }
 
+    #if EXTRUDERS > 1
+      void lcd_enqueue_filament_change_e0() { lcd_enqueue_filament_change(0); }
+      void lcd_enqueue_filament_change_e1() { lcd_enqueue_filament_change(1); }
+      #if EXTRUDERS > 2
+        void lcd_enqueue_filament_change_e2() { lcd_enqueue_filament_change(2); }
+        #if EXTRUDERS > 3
+          void lcd_enqueue_filament_change_e3() { lcd_enqueue_filament_change(3); }
+          #if EXTRUDERS > 4
+            void lcd_enqueue_filament_change_e4() { lcd_enqueue_filament_change(4); }
+          #endif // EXTRUDERS > 4
+        #endif // EXTRUDERS > 3
+      #endif // EXTRUDERS > 2
+    #endif // EXTRUDERS > 1
+
   #endif // ADVANCED_PAUSE_FEATURE
 
   // First Fan Speed title in "Tune" and "Control>Temperature" menus
   #if FAN_COUNT > 0 && HAS_FAN0
     #if FAN_COUNT > 1
       #define FAN_SPEED_1_SUFFIX " 1"
     #else
       #define FAN_SPEED_1_SUFFIX ""
     #endif
   #endif
@@ -1397,22 +1433,41 @@ void kill_screen(const char* lcd_msg) {
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #else
         MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
       #endif
     #endif
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      if (!thermalManager.tooColdToExtrude(active_extruder))
-        MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+      #if EXTRUDERS > 1
+        if (!thermalManager.tooColdToExtrude(0))
+          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
+        if (!thermalManager.tooColdToExtrude(1))
+          MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
+        #if EXTRUDERS > 2
+          if (!thermalManager.tooColdToExtrude(2))
+            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
+          #if EXTRUDERS > 3
+            if (!thermalManager.tooColdToExtrude(3))
+              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
+            #if EXTRUDERS > 4
+              if (!thermalManager.tooColdToExtrude(4))
+                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #else
+        if (!thermalManager.tooColdToExtrude(active_extruder))
+          MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+      #endif
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Driver current control" submenu items
    *
    */
@@ -2588,23 +2643,44 @@ void kill_screen(const char* lcd_msg) {
 
     //
     // Disable Steppers
     //
     MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
 
     //
     // Change filament
     //
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      if (!thermalManager.tooColdToExtrude(active_extruder) && !IS_SD_FILE_OPEN)
-        MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
-    #endif
+      if (!IS_SD_FILE_OPEN) {
+        #if EXTRUDERS > 1
+          if (!thermalManager.tooColdToExtrude(0))
+            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E1, lcd_enqueue_filament_change_e0);
+          if (!thermalManager.tooColdToExtrude(1))
+            MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E2, lcd_enqueue_filament_change_e1);
+          #if EXTRUDERS > 2
+            if (!thermalManager.tooColdToExtrude(2))
+              MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E3, lcd_enqueue_filament_change_e2);
+            #if EXTRUDERS > 3
+              if (!thermalManager.tooColdToExtrude(3))
+                MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E4, lcd_enqueue_filament_change_e3);
+              #if EXTRUDERS > 4
+                if (!thermalManager.tooColdToExtrude(4))
+                  MENU_ITEM(function, MSG_FILAMENTCHANGE " " MSG_E5, lcd_enqueue_filament_change_e4);
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #else
+          if (!thermalManager.tooColdToExtrude(active_extruder))
+            MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+        #endif
+      }
+    #endif // ADVANCED_PAUSE_FEATURE
 
     #if TEMP_SENSOR_0 != 0
 
       //
       // Cooldown
       //
       bool has_heat = false;
       HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
       #if HAS_TEMP_BED
         if (thermalManager.target_temperature_bed) has_heat = true;

commit a1ce6e8ff46c74f1b2a130839dc43792daaa2d95
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 26 22:12:05 2017 -0600

    Clear lcd_clicked immediately on use

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a5c6ebd786..44ff950198 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -288,21 +288,22 @@ uint16_t max_display_update_time = 0;
    *     menu_action_function(lcd_sdcard_pause)
    *
    *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
    *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
    *
    */
   #define _MENU_ITEM_PART_1(TYPE, ...) \
     if (_menuLineNr == _thisItemNr) { \
-      if (lcd_clicked && encoderLine == _thisItemNr) {
+      if (encoderLine == _thisItemNr && lcd_clicked) { \
+        lcd_clicked = false
 
   #define _MENU_ITEM_PART_2(TYPE, LABEL, ...) \
         menu_action_ ## TYPE(__VA_ARGS__); \
         if (screen_changed) return; \
       } \
       if (lcdDrawUpdate) \
         lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
     } \
     ++_thisItemNr
 
@@ -492,20 +493,26 @@ uint16_t max_display_update_time = 0;
   #endif
 
   #if PIN_EXISTS(SD_DETECT)
     uint8_t lcd_sd_status;
   #endif
 
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
   #endif
 
+  inline bool use_click() {
+    const bool click = lcd_clicked;
+    lcd_clicked = false;
+    return click;
+  }
+
   /**
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
@@ -671,21 +678,21 @@ void lcd_status_screen() {
           expire_status_ms += LCD_UPDATE_INTERVAL;
         }
       }
 
     #endif // PROGRESS_MSG_EXPIRE
 
   #endif // LCD_PROGRESS_BAR
 
   #if ENABLED(ULTIPANEL)
 
-    if (lcd_clicked) {
+    if (use_click()) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
           CHARSET_MENU
         #endif
       );
       lcd_goto_screen(lcd_main_menu);
       return;
@@ -854,21 +861,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
       END_MENU();
     }
 
   #endif // BLTOUCH
 
   #if ENABLED(LCD_PROGRESS_BAR_TEST)
 
     static void progress_bar_test() {
       static int8_t bar_percent = 0;
-      if (lcd_clicked) {
+      if (use_click()) {
         lcd_goto_previous_menu();
         lcd_set_custom_characters(CHARSET_MENU);
         return;
       }
       bar_percent += (int8_t)encoderPosition;
       bar_percent = constrain(bar_percent, 0, 100);
       encoderPosition = 0;
       lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
       lcd.setCursor((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
       lcd.print(itostr3(bar_percent)); lcd.write('%');
@@ -1081,21 +1088,21 @@ void kill_screen(const char* lcd_msg) {
         u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
         u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
       }
     }
 
   #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || MESH_EDIT_GFX_OVERLAY
 
   #if ENABLED(BABYSTEPPING)
 
     void _lcd_babystep(const AxisEnum axis, const char* msg) {
-      if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
+      if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         thermalManager.babystep_axis(axis, babystep_increment);
         babysteps_done += babystep_increment;
       }
       if (lcdDrawUpdate)
         lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
@@ -1104,21 +1111,21 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(BABYSTEP_XY)
       void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
       void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
-        if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
+        if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
             if (planner.leveling_active)
@@ -1786,21 +1793,21 @@ void kill_screen(const char* lcd_msg) {
     }
 
     void _lcd_level_goto_next_point();
 
     /**
      * Step 7: Get the Z coordinate, click goes to the next point or exits
      */
     void _lcd_level_bed_get_z() {
       ENCODER_DIRECTION_NORMAL();
 
-      if (lcd_clicked) {
+      if (use_click()) {
 
         //
         // Save the current Z position and move
         //
 
         // If done...
         if (++manual_probe_index >= total_probe_points) {
           //
           // The last G29 records the point and enables bed leveling
           //
@@ -1866,21 +1873,21 @@ void kill_screen(const char* lcd_msg) {
         enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
       #endif
     }
 
     /**
      * Step 4: Display "Click to Begin", wait for click
      *         Move to the first probe position
      */
     void _lcd_level_bed_homing_done() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-      if (lcd_clicked) {
+      if (use_click()) {
         manual_probe_index = 0;
         _lcd_level_goto_next_point();
       }
     }
 
     /**
      * Step 3: Display "Homing XYZ" - Wait for homing to finish
      */
     void _lcd_level_bed_homing() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
@@ -2357,21 +2364,21 @@ void kill_screen(const char* lcd_msg) {
       sync_plan_position();
       gcode.refresh_cmd_timeout();
     }
 
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
-      if (lcd_clicked) return _lcd_ubl_map_lcd_edit_cmd();
+      if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
         if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM)
           step_scaler = 0;
         gcode.refresh_cmd_timeout();
 
         encoderPosition = 0;
@@ -2826,21 +2833,21 @@ void kill_screen(const char* lcd_msg) {
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
-    if (lcd_clicked) { return lcd_goto_previous_menu(); }
+    if (use_click()) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
       gcode.refresh_cmd_timeout();
 
       // Start with no limits to movement
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       // Limit to software endstops, if enabled
       #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
@@ -2910,21 +2917,21 @@ void kill_screen(const char* lcd_msg) {
     }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       int8_t eindex=-1
     #endif
   ) {
-    if (lcd_clicked) { return lcd_goto_previous_menu(); }
+    if (use_click()) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       if (!processing_manual_move) {
         const float diff = float((int32_t)encoderPosition) * move_menu_scale;
         #if IS_KINEMATIC
           manual_move_offset += diff;
         #else
           current_position[E_AXIS] += diff;
         #endif
         manual_move_to_current(E_AXIS
@@ -2992,21 +2999,21 @@ void kill_screen(const char* lcd_msg) {
     lcd_goto_screen(_manual_move_func_ptr);
   }
   void lcd_move_menu_10mm() { _goto_manual_move(10.0); }
   void lcd_move_menu_1mm()  { _goto_manual_move( 1.0); }
   void lcd_move_menu_01mm() { _goto_manual_move( 0.1); }
 
   void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func) {
     _manual_move_func_ptr = func;
     START_MENU();
     if (LCD_HEIGHT >= 4) {
-      switch(axis) {
+      switch (axis) {
         case X_AXIS:
           STATIC_ITEM(MSG_MOVE_X, true, true); break;
         case Y_AXIS:
           STATIC_ITEM(MSG_MOVE_Y, true, true); break;
         case Z_AXIS:
           STATIC_ITEM(MSG_MOVE_Z, true, true); break;
         default:
           STATIC_ITEM(MSG_MOVE_E, true, true); break;
       }
     }
@@ -3795,21 +3802,21 @@ void kill_screen(const char* lcd_msg) {
 
   #if ENABLED(LCD_INFO_MENU)
 
     #if ENABLED(PRINTCOUNTER)
       /**
        *
        * About Printer > Statistics submenu
        *
        */
       void lcd_info_stats_menu() {
-        if (lcd_clicked) { return lcd_goto_previous_menu(); }
+        if (use_click()) { return lcd_goto_previous_menu(); }
 
         char buffer[21];
         printStatistics stats = print_job_timer.getStats();
 
         START_SCREEN();                                                                                // 12345678901234567890
         STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));          // Print Count: 999
         STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints));   // Completed  : 666
 
         duration_t elapsed = stats.printTime;
         elapsed.toString(buffer);
@@ -3829,21 +3836,21 @@ void kill_screen(const char* lcd_msg) {
         END_SCREEN();
       }
     #endif // PRINTCOUNTER
 
     /**
      *
      * About Printer > Thermistors
      *
      */
     void lcd_info_thermistors_menu() {
-      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      if (use_click()) { return lcd_goto_previous_menu(); }
       START_SCREEN();
       #define THERMISTOR_ID TEMP_SENSOR_0
       #include "thermistornames.h"
       STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
       STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
       STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
 
       #if TEMP_SENSOR_1 != 0
         #undef THERMISTOR_ID
         #define THERMISTOR_ID TEMP_SENSOR_1
@@ -3890,42 +3897,42 @@ void kill_screen(const char* lcd_msg) {
       #endif
       END_SCREEN();
     }
 
     /**
      *
      * About Printer > Board Info
      *
      */
     void lcd_info_board_menu() {
-      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      if (use_click()) { return lcd_goto_previous_menu(); }
       START_SCREEN();
       STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
       STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
       STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
       #if POWER_SUPPLY == 0
         STATIC_ITEM(MSG_INFO_PSU ": Generic", true);
       #elif POWER_SUPPLY == 1
         STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
       #elif POWER_SUPPLY == 2
         STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
       #endif
       END_SCREEN();
     }
 
     /**
      *
      * About Printer > Printer Info
      *
      */
     void lcd_info_printer_menu() {
-      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      if (use_click()) { return lcd_goto_previous_menu(); }
       START_SCREEN();
       STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
       STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
       STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
       STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
       STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
       STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
       #if ENABLED(AUTO_BED_LEVELING_3POINT)
         STATIC_ITEM(MSG_3POINT_LEVELING, true);                        // 3-Point Leveling
       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
@@ -4310,21 +4317,21 @@ void kill_screen(const char* lcd_msg) {
       if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
       if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
       if (lcdDrawUpdate) \
         lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale))); \
       if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
         _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale); \
         if (editValue != NULL) *((_type*)editValue) = value; \
         if (liveEdit) (*callbackFunc)(); \
         if (lcd_clicked) lcd_goto_previous_menu(); \
       } \
-      return lcd_clicked; \
+      return use_click(); \
     } \
     void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
     void menu_edit_callback_ ## _name() { if (_menu_edit_ ## _name()) (*callbackFunc)(); } \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
       lcd_save_previous_screen(); \
       \
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
       \
       editLabel = pstr; \
       editValue = ptr; \
@@ -4667,21 +4674,21 @@ void lcd_update() {
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if ENABLED(DOGLCD)
       || drawing_screen
     #endif
-    ) {
+  ) {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
     #if ENABLED(LCD_HAS_STATUS_INDICATORS)
       lcd_implementation_update_indicators();
     #endif
 
     #if ENABLED(ULTIPANEL)
 
       #if ENABLED(LCD_HAS_SLOW_BUTTONS)
@@ -4771,38 +4778,39 @@ void lcd_update() {
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if ENABLED(DOGLCD)
       #define IS_DRAWING drawing_screen
     #else
       #define IS_DRAWING false
     #endif
 
     if ((lcdDrawUpdate || IS_DRAWING) && (!bbr2 || bbr2 > max_display_update_time)) {
 
+      // Change state of drawing flag between screen updates
       if (!IS_DRAWING) switch (lcdDrawUpdate) {
         case LCDVIEW_CALL_NO_REDRAW:
           lcdDrawUpdate = LCDVIEW_NONE;
           break;
-        case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
-        case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)
+        case LCDVIEW_CLEAR_CALL_REDRAW:
+        case LCDVIEW_CALL_REDRAW_NEXT:
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
         case LCDVIEW_NONE:
           break;
       } // switch
 
       #if ENABLED(ADC_KEYPAD)
         buttons_reprapworld_keypad = 0;
       #endif
 
       #if ENABLED(ULTIPANEL)
-        #define CURRENTSCREEN() (*currentScreen)(), lcd_clicked = false
+        #define CURRENTSCREEN() (*currentScreen)()
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
 
       #if ENABLED(DOGLCD)
         if (!drawing_screen) {                        // If not already drawing pages
           u8g.firstPage();                            // Start the first page
           drawing_screen = 1;                         // Flag as drawing pages
         }
         lcd_setFont(FONT_MENU);                       // Setup font for every page draw
@@ -4813,46 +4821,49 @@ void lcd_update() {
         // If still drawing and there's another page, update max-time and return now.
         // The nextPage will already be set up on the next call.
         if (drawing_screen && (drawing_screen = u8g.nextPage())) {
           NOLESS(max_display_update_time, millis() - ms);
           return;
         }
       #else
         CURRENTSCREEN();
       #endif
 
+      #if ENABLED(ULTIPANEL)
+        lcd_clicked = false;
+      #endif
+
       // Keeping track of the longest time for an individual LCD update.
       // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
+    // Change state of drawing flag between screen updates
     if (!IS_DRAWING) switch (lcdDrawUpdate) {
       case LCDVIEW_CLEAR_CALL_REDRAW:
-        lcd_implementation_clear();
-      case LCDVIEW_CALL_REDRAW_NEXT:
-        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-        break;
+        lcd_implementation_clear(); break;
       case LCDVIEW_REDRAW_NOW:
         lcdDrawUpdate = LCDVIEW_NONE;
-        break;
       case LCDVIEW_NONE:
-        break;
+      case LCDVIEW_CALL_REDRAW_NEXT:
+      case LCDVIEW_CALL_NO_REDRAW:
+      default: break;
     } // switch
 
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
 inline void pad_message_string() {
   uint8_t i = 0, j = 0;
   char c;
   while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
     if (PRINTABLE(c)) j++;

commit f163eede78d2539b339fef525cc7b803ffe9260e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 26 18:23:35 2017 -0600

    No sub-menu if NO_VOLUMETRICS
    
    For parity with #8911

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e8ab943ede..a5c6ebd786 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -170,21 +170,24 @@ uint16_t max_display_update_time = 0;
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
   void lcd_control_temperature_preheat_material1_settings_menu();
   void lcd_control_temperature_preheat_material2_settings_menu();
   void lcd_control_motion_menu();
-  void lcd_control_filament_menu();
+
+  #if DISABLED(NO_VOLUMETRICS)
+    void lcd_control_filament_menu();
+  #endif
 
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
     void lcd_info_menu();
   #endif // LCD_INFO_MENU
 
@@ -3127,21 +3130,26 @@ void kill_screen(const char* lcd_msg) {
       END_MENU();
     }
 
   #endif
 
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
-    MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
+
+    #if DISABLED(NO_VOLUMETRICS)
+      MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
+    #elif ENABLED(LIN_ADVANCE)
+      MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
+    #endif
 
     #if HAS_LCD_CONTRAST
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
@@ -3616,34 +3624,33 @@ void kill_screen(const char* lcd_msg) {
     MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
 
     // M540 S - Abort on endstop hit when SD printing
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
     #endif
 
     END_MENU();
   }
 
-  /**
-   *
-   * "Control" > "Filament" submenu
-   *
-   */
-  void lcd_control_filament_menu() {
-    START_MENU();
-    MENU_BACK(MSG_CONTROL);
-
-    #if ENABLED(LIN_ADVANCE)
-      MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
-    #endif
+  #if DISABLED(NO_VOLUMETRICS)
+    /**
+     *
+     * "Control" > "Filament" submenu
+     *
+     */
+    void lcd_control_filament_menu() {
+      START_MENU();
+      MENU_BACK(MSG_CONTROL);
 
-    #if DISABLED(NO_VOLUMETRICS)
+      #if ENABLED(LIN_ADVANCE)
+        MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
+      #endif
 
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
       if (parser.volumetric_enabled) {
         #if EXTRUDERS == 1
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
         #else // EXTRUDERS > 1
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
@@ -3652,24 +3659,23 @@ void kill_screen(const char* lcd_msg) {
             #if EXTRUDERS > 3
               MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
               #if EXTRUDERS > 4
                 MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       }
 
-    #endif // !NO_VOLUMETRICS
-
-    END_MENU();
-  }
+      END_MENU();
+    }
+  #endif // !NO_VOLUMETRICS
 
   /**
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_control_retract_menu() {
       START_MENU();

commit 4ef965cc4024fd8801f9cdc19eda20802a38e2a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 08:48:54 2017 -0600

    Fix compiler warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 105916be45..e8ab943ede 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2278,21 +2278,21 @@ void kill_screen(const char* lcd_msg) {
 
     /**
      * UBL Mesh Storage submenu
      *
      * << Unified Bed Leveling
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
      */
     void _lcd_ubl_storage_mesh() {
-      uint16_t a = settings.calc_num_meshes();
+      int16_t a = settings.calc_num_meshes();
       START_MENU();
       MENU_BACK(MSG_UBL_LEVEL_BED);
       if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
         STATIC_ITEM(MSG_NO_STORAGE);
         STATIC_ITEM(MSG_INIT_EEPROM);
       }
       else {
         MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
         MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
         MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);

commit 4b49ea1e92d2963f261bfc7ea1233b49200407af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 03:32:31 2017 -0600

    General cleanup of config-store, reset_bed_level

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e8ab943ede..105916be45 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2278,21 +2278,21 @@ void kill_screen(const char* lcd_msg) {
 
     /**
      * UBL Mesh Storage submenu
      *
      * << Unified Bed Leveling
      *    Memory Slot: ---
      *    Load Bed Mesh
      *    Save Bed Mesh
      */
     void _lcd_ubl_storage_mesh() {
-      int16_t a = settings.calc_num_meshes();
+      uint16_t a = settings.calc_num_meshes();
       START_MENU();
       MENU_BACK(MSG_UBL_LEVEL_BED);
       if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
         STATIC_ITEM(MSG_NO_STORAGE);
         STATIC_ITEM(MSG_INIT_EEPROM);
       }
       else {
         MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
         MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
         MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);

commit 933f76fda3a2e8ecd9b3e8493b2885f4356b0430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 19:44:11 2017 -0600

    Option to disable all volumetric extrusion

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3362e677ed..e8ab943ede 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3629,40 +3629,44 @@ void kill_screen(const char* lcd_msg) {
    *
    */
   void lcd_control_filament_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
-
-    if (parser.volumetric_enabled) {
-      #if EXTRUDERS == 1
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-      #else // EXTRUDERS > 1
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-        #if EXTRUDERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-          #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-            #if EXTRUDERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-    }
+    #if DISABLED(NO_VOLUMETRICS)
+
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
+
+      if (parser.volumetric_enabled) {
+        #if EXTRUDERS == 1
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+        #else // EXTRUDERS > 1
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+          #if EXTRUDERS > 2
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+            #if EXTRUDERS > 3
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+              #if EXTRUDERS > 4
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      }
+
+    #endif // !NO_VOLUMETRICS
 
     END_MENU();
   }
 
   /**
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)

commit de5ca96654313a4c9cecaafe265035f6654128bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 18:36:16 2017 -0600

    More parity with 1.1.x, plus whitespace

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 79d65437df..3362e677ed 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2552,24 +2552,22 @@ void kill_screen(const char* lcd_msg) {
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
           MENU_ITEM(submenu, MSG_BED_LEVELING,
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               _lcd_goto_bed_leveling
             #else
               lcd_bed_leveling
             #endif
           );
-    #else
-      #if PLANNER_LEVELING
-        MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
-      #endif
+    #elif PLANNER_LEVELING && DISABLED(PROBE_MANUALLY)
+      MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
     #endif
 
     #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND
       //
       // Set Home Offsets

commit 9898b969926dca060eee40dc7a92a3a31da757c0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:28:50 2017 -0600

    No lcd_map_control flag in quick_stop

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ae58c10b17..79d65437df 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2300,25 +2300,26 @@ void kill_screen(const char* lcd_msg) {
       END_MENU();
     }
 
     /**
      * UBL LCD "radar" map homing
      */
     void _lcd_ubl_output_map_lcd();
 
     void _lcd_ubl_map_homing() {
       defer_return_to_status = true;
-      ubl.lcd_map_control = true; // Return to the map screen
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT < 3 ? 0 : (LCD_HEIGHT > 4 ? 2 : 1), PSTR(MSG_LEVEL_BED_HOMING));
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+        ubl.lcd_map_control = true; // Return to the map screen
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
+      }
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {
       char ubl_lcd_gcode [50], str[10], str2[10];
 
       dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
       dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
@@ -2334,20 +2335,33 @@ void kill_screen(const char* lcd_msg) {
       current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
     }
 
     /**
      * UBL LCD "radar" map
      */
     void set_current_from_steppers_for_axis(const AxisEnum axis);
     void sync_plan_position();
 
+    void _lcd_do_nothing() {}
+    void _lcd_hard_stop() {
+      stepper.quick_stop();
+      const screenFunc_t old_screen = currentScreen;
+      currentScreen = _lcd_do_nothing;
+      while (planner.movesplanned()) idle();
+      currentScreen = old_screen;
+      stepper.cleaning_buffer_counter = 0;
+      set_current_from_steppers_for_axis(ALL_AXES);
+      sync_plan_position();
+      gcode.refresh_cmd_timeout();
+    }
+
     void _lcd_ubl_output_map_lcd() {
       static int16_t step_scaler = 0;
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
       if (lcd_clicked) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
@@ -2378,29 +2392,24 @@ void kill_screen(const char* lcd_msg) {
         n_edit_pts = 9; //TODO: Delta accessible edit points
       #else
         const bool xc = WITHIN(x_plot, 1, GRID_MAX_POINTS_X - 2),
                    yc = WITHIN(y_plot, 1, GRID_MAX_POINTS_Y - 2);
         n_edit_pts = yc ? (xc ? 9 : 6) : (xc ? 6 : 4); // Corners
       #endif
 
       if (lcdDrawUpdate) {
         lcd_implementation_ubl_plot(x_plot, y_plot);
 
-        ubl_map_move_to_xy(); // Move to current location
+        if (planner.movesplanned()) // If the nozzle is already moving, cancel the move.
+          _lcd_hard_stop();
 
-        if (planner.movesplanned() > 1) { // if the nozzle is moving, cancel the move.  There is a new location
-          stepper.quick_stop();
-          set_current_from_steppers_for_axis(ALL_AXES);
-          sync_plan_position();
-          ubl_map_move_to_xy(); // Move to new location
-          gcode.refresh_cmd_timeout();
-        }
+        ubl_map_move_to_xy();       // Move to new location
       }
     }
 
     /**
      * UBL Homing before LCD map
      */
     void _lcd_ubl_output_map_lcd_cmd() {
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS])) {
         axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
         enqueue_and_echo_commands_P(PSTR("G28"));

commit c846388a65d96e8ce804c7682d226bb67722ac7a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:28:04 2017 -0600

    Standardize LCD interface code for UBL a little

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ab784a71f2..ae58c10b17 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -5098,20 +5098,24 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
   #endif
 
   #if ENABLED(G26_MESH_VALIDATION)
     void lcd_chirp() {
       lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     }
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
     bool is_lcd_clicked() { return LCD_CLICKED; }
+    void wait_for_release() {
+      while (is_lcd_clicked()) safe_delay(50);
+      safe_delay(50);
+    }
   #endif
 
 #endif // ULTIPANEL
 
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;

commit 2fde60da124fddb6cf2a8f15479680f3410b53af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 16:56:30 2017 -0600

    Changes for parity with 1.1.x

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4a3500f0e2..ab784a71f2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -78,26 +78,27 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
 #if ENABLED(BABYSTEPPING)
   long babysteps_done = 0;
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     static void lcd_babystep_zoffset();
   #else
     static void lcd_babystep_z();
   #endif
 #endif
 
 uint8_t lcd_status_update_delay = 1, // First update one loop delayed
-        lcd_status_message_level;    // Higher level overrides lower
+        lcd_status_message_level;    // Higher level blocks lower level
 char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   uint8_t status_scroll_pos = 0;
 #endif
+
 #if ENABLED(SCROLL_LONG_FILENAMES)
   uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
@@ -156,22 +157,20 @@ uint16_t max_display_update_time = 0;
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   #if HAS_POWER_SWITCH
     extern bool powersupply_on;
   #endif
 
-  float move_menu_scale;
-
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
@@ -237,30 +236,30 @@ uint16_t max_display_update_time = 0;
 
   #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
     bool _menu_edit_ ## _name(); \
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live=false); \
     typedef void _name##_void
 
-  DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
   DECLARE_MENU_EDIT_TYPE(int16_t, int3);
   DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
   DECLARE_MENU_EDIT_TYPE(float, float3);
   DECLARE_MENU_EDIT_TYPE(float, float32);
   DECLARE_MENU_EDIT_TYPE(float, float43);
   DECLARE_MENU_EDIT_TYPE(float, float5);
   DECLARE_MENU_EDIT_TYPE(float, float51);
   DECLARE_MENU_EDIT_TYPE(float, float52);
   DECLARE_MENU_EDIT_TYPE(float, float62);
+  DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
 
   #if ENABLED(SDSUPPORT)
     void lcd_sdcard_menu();
     void menu_action_sdfile(const char* filename, char* longFilename);
     void menu_action_sddirectory(const char* filename, char* longFilename);
   #endif
 
@@ -559,24 +558,23 @@ uint16_t max_display_update_time = 0;
 
   //
   // Display the synchronize screen until moves are
   // finished, and don't return to the caller until
   // done. ** This blocks the command queue! **
   //
   void _lcd_synchronize() {
     static bool no_reentry = false;
     if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
     if (no_reentry) return;
-
     // Make this the current handler till all moves are done
     no_reentry = true;
-    screenFunc_t old_screen = currentScreen;
+    const screenFunc_t old_screen = currentScreen;
     lcd_goto_screen(_lcd_synchronize);
     stepper.synchronize();
     no_reentry = false;
     lcd_goto_screen(old_screen);
   }
 
   // Display the synchronize screen with a custom message
   // ** This blocks the command queue! **
   void lcd_synchronize(const char * const msg=NULL) {
     sync_message = msg ? msg : moving;
@@ -990,21 +988,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
     }
     else {
       MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
     }
     MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
 
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
-          if (IS_SD_PRINTING)
+          if (card.sdprinting)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
         }
         else {
           MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
           #if !PIN_EXISTS(SD_DETECT)
             MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
           #endif
@@ -1067,21 +1065,21 @@ void kill_screen(const char* lcd_msg) {
         const int left = 0, right = 45, nozzle = 95;
       #else
         const int left = 5, right = 90, nozzle = 60;
       #endif
 
       // Draw a representation of the nozzle
       if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
       if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
 
       // Draw cw/ccw indicator and up/down arrows.
-      if (PAGE_CONTAINS(47,62)) {
+      if (PAGE_CONTAINS(47, 62)) {
         u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
         u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
         u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
         u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
       }
     }
 
   #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || MESH_EDIT_GFX_OVERLAY
 
   #if ENABLED(BABYSTEPPING)
@@ -1108,30 +1106,31 @@ void kill_screen(const char* lcd_msg) {
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
+          encoderPosition = 0;
+
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
             if (planner.leveling_active)
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
-          encoderPosition = 0;
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
             _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
@@ -1157,59 +1156,61 @@ void kill_screen(const char* lcd_msg) {
 
         mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005 / 2.0;
         mesh_edit_value = mesh_edit_accumulator;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
 
         const int32_t rounded = (int32_t)(mesh_edit_value * 1000.0);
         mesh_edit_value = float(rounded - (rounded % 5L)) / 1000.0;
       }
 
-      if (lcdDrawUpdate)
+      if (lcdDrawUpdate) {
         lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
         #if ENABLED(MESH_EDIT_GFX_OVERLAY)
           _lcd_zoffset_overlay_gfx(mesh_edit_value);
         #endif
+      }
     }
 
     void _lcd_mesh_edit_NOP() {
       defer_return_to_status = true;
     }
 
     float lcd_mesh_edit() {
       lcd_goto_screen(_lcd_mesh_edit_NOP);
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
       return mesh_edit_value;
     }
 
-    void lcd_mesh_edit_setup(float initial) {
+    void lcd_mesh_edit_setup(const float initial) {
       mesh_edit_value = mesh_edit_accumulator = initial;
       lcd_goto_screen(_lcd_mesh_edit_NOP);
     }
 
     void _lcd_z_offset_edit() {
       _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
     }
 
     float lcd_z_offset_edit() {
       lcd_goto_screen(_lcd_z_offset_edit);
       return mesh_edit_value;
     }
 
     void lcd_z_offset_edit_setup(float initial) {
       mesh_edit_value = mesh_edit_accumulator = initial;
       lcd_goto_screen(_lcd_z_offset_edit);
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
+
   /**
    * Watch temperature callbacks
    */
   #if HAS_TEMP_HOTEND
     #if WATCH_HOTENDS
       #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
     #else
       #define _WATCH_FUNC(N) NOOP
     #endif
     void watch_temp_callback_E0() { _WATCH_FUNC(0); }
@@ -2023,39 +2024,38 @@ void kill_screen(const char* lcd_msg) {
       #endif
       MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
       END_MENU();
     }
 
     /**
      * UBL Adjust Mesh Height Command
      */
     void _lcd_ubl_adjust_height_cmd() {
       char UBL_LCD_GCODE[16];
-      const int ind = ubl_height_amount < 0 ? 6 : 7;
-      strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6-"));
+      const int ind = ubl_height_amount > 0 ? 9 : 10;
+      strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
       sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
       enqueue_and_echo_command(UBL_LCD_GCODE);
     }
 
     /**
      * UBL Adjust Mesh Height submenu
      *
      * << Edit Mesh
      *    Height Amount: ---
      *    Adjust Mesh Height
      * << Info Screen
      */
     void _lcd_ubl_height_adjust_menu() {
       START_MENU();
       MENU_BACK(MSG_UBL_EDIT_MESH_MENU);
-      MENU_ITEM_EDIT(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9);
-      MENU_ITEM(function, MSG_UBL_MESH_HEIGHT_ADJUST, _lcd_ubl_adjust_height_cmd);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9, _lcd_ubl_adjust_height_cmd);
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     /**
      * UBL Edit Mesh submenu
      *
      * << UBL Tools
      *    Fine Tune All
      *    Fine Tune Closest
@@ -2177,22 +2177,21 @@ void kill_screen(const char* lcd_msg) {
      * << Build Mesh
      *    Fill-in Amount: ---
      *    Fill-in Mesh
      *    Smart Fill-in
      *    Manual Fill-in
      * << Info Screen
      */
     void _lcd_ubl_fillin_menu() {
       START_MENU();
       MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-      MENU_ITEM_EDIT(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9);
-      MENU_ITEM(function, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_amount_cmd);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9, _lcd_ubl_fillin_amount_cmd);
       MENU_ITEM(function, MSG_UBL_SMART_FILLIN, _lcd_ubl_smart_fillin_cmd);
       MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
       MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
       END_MENU();
     }
 
     void _lcd_ubl_invalidate() {
       ubl.invalidate();
       SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
     }
@@ -2637,36 +2636,36 @@ void kill_screen(const char* lcd_msg) {
     //
     // Delta Calibration
     //
     #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
       MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
     #endif
 
     END_MENU();
   }
 
+  float move_menu_scale;
+
   #if ENABLED(DELTA_CALIBRATION_MENU) || (ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE)
 
     void lcd_move_z();
 
     void _man_probe_pt(const float &rx, const float &ry) {
       #if HAS_LEVELING
         reset_bed_level(); // After calibration bed-level data is no longer valid
       #endif
 
-      float z_dest = (Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5;
-      line_to_z(z_dest);
+      line_to_z((Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5);
       current_position[X_AXIS] = rx;
       current_position[Y_AXIS] = ry;
       line_to_current_z();
-      z_dest = Z_CLEARANCE_BETWEEN_PROBES;
-      line_to_z(z_dest);
+      line_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
       lcd_synchronize();
       move_menu_scale = PROBE_MANUALLY_STEP;
       lcd_goto_screen(lcd_move_z);
     }
 
   #endif // DELTA_CALIBRATION_MENU || (DELTA_AUTO_CALIBRATION && !HAS_BED_PROBE)
 
   #if ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE
 
@@ -2806,37 +2805,37 @@ void kill_screen(const char* lcd_msg) {
     #if E_MANUAL > 1
       , int8_t eindex=-1
     #endif
   ) {
     #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
       #if E_MANUAL > 1
         if (axis == E_AXIS)
       #endif
           manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
-
     manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (lcd_clicked) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
       gcode.refresh_cmd_timeout();
 
+      // Start with no limits to movement
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       // Limit to software endstops, if enabled
       #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
         if (soft_endstops_enabled) switch (axis) {
           case X_AXIS:
             #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
               min = soft_endstop_min[X_AXIS];
             #endif
@@ -2860,21 +2859,21 @@ void kill_screen(const char* lcd_msg) {
               max = soft_endstop_max[Z_AXIS];
             #endif
           default: break;
         }
       #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
 
       // Delta limits XY based on the current offset from center
       // This assumes the center is 0,0
       #if ENABLED(DELTA)
         if (axis != Z_AXIS) {
-          max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis]));
+          max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
           min = -max;
         }
       #endif
 
       // Get the new position
       const float diff = float((int32_t)encoderPosition) * move_menu_scale;
       #if IS_KINEMATIC
         manual_move_offset += diff;
         // Limit only when trying to move towards the limit
         if ((int32_t)encoderPosition < 0) NOLESS(manual_move_offset, min - current_position[axis]);
@@ -3124,21 +3123,21 @@ void kill_screen(const char* lcd_msg) {
   #endif
 
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
     MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
 
     #if HAS_LCD_CONTRAST
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*)&lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
     #endif
     #if ENABLED(DAC_STEPPER_CURRENT)
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
     #endif
     #if HAS_MOTOR_CURRENT_PWM
       MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
     #endif
@@ -3717,21 +3716,21 @@ void kill_screen(const char* lcd_msg) {
           lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           _lcd_synchronize();
           safe_delay(50);
           _lcd_synchronize();
           lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           drawing_screen = screen_changed = true;
         #endif
 
         lcd_goto_screen(lcd_sdcard_menu, last_sdfile_encoderPosition);
         defer_return_to_status = true;
-        last_sdfile_encoderPosition == 0xFFFF;
+        last_sdfile_encoderPosition = 0xFFFF;
 
         #if ENABLED(DOGLCD)
           lcd_update();
         #endif
       }
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
 
@@ -3742,43 +3741,41 @@ void kill_screen(const char* lcd_msg) {
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
         MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
       }
 
-      if (fileCnt) {
-        for (uint16_t i = 0; i < fileCnt; i++) {
-          if (_menuLineNr == _thisItemNr) {
-            const uint16_t nr =
-              #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
-                fileCnt - 1 -
-              #endif
-            i;
-
-            #if ENABLED(SDCARD_SORT_ALPHA)
-              card.getfilename_sorted(nr);
-            #else
-              card.getfilename(nr);
+      for (uint16_t i = 0; i < fileCnt; i++) {
+        if (_menuLineNr == _thisItemNr) {
+          const uint16_t nr =
+            #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
+              fileCnt - 1 -
             #endif
+          i;
 
-            if (card.filenameIsDir)
-              MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
-            else
-              MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
-          }
-          else {
-            MENU_ITEM_DUMMY();
-          }
+          #if ENABLED(SDCARD_SORT_ALPHA)
+            card.getfilename_sorted(nr);
+          #else
+            card.getfilename(nr);
+          #endif
+
+          if (card.filenameIsDir)
+            MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+          else
+            MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+        }
+        else {
+          MENU_ITEM_DUMMY();
         }
       }
       END_MENU();
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(LCD_INFO_MENU)
 
     #if ENABLED(PRINTCOUNTER)
@@ -4469,27 +4466,28 @@ void kill_screen(const char* lcd_msg) {
     (*callback)();
   }
 
 #endif // ULTIPANEL
 
 void lcd_init() {
 
   lcd_implementation_init();
 
   #if ENABLED(NEWPANEL)
-
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
+
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
+
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
     #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
       SET_INPUT_PULLUP(SHIFT_OUT);
     #endif
 
@@ -4677,21 +4675,21 @@ void lcd_update() {
 
         if (handle_adc_keypad())
           return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
 
       #elif ENABLED(REPRAPWORLD_KEYPAD)
 
         handle_reprapworld_keypad();
 
       #endif
 
-      bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
+      const bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
       if (encoderPastThreshold || lcd_clicked) {
         if (encoderPastThreshold) {
           int32_t encoderMultiplier = 1;
 
           #if ENABLED(ENCODER_RATE_MULTIPLIER)
 
             if (encoderRateMultiplierEnabled) {
               int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;
 
               if (lastEncoderMovementMillis) {
@@ -4972,25 +4970,20 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
         #endif
 
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
 
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
 
-        buttons = newbutton;
-        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-          buttons |= slow_buttons;
-        #endif
-
         //
         // Directional buttons
         //
         #if LCD_HAS_DIRECTIONAL_BUTTONS
 
           #if ENABLED(REVERSE_MENU_DIRECTION)
             #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
           #else
             #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM
           #endif
@@ -5025,20 +5018,25 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = ENCODER_LR_PULSES;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // LCD_HAS_DIRECTIONAL_BUTTONS
 
+        buttons = newbutton;
+        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+          buttons |= slow_buttons;
+        #endif
+
         #if ENABLED(ADC_KEYPAD)
 
           uint8_t newbutton_reprapworld_keypad = 0;
           buttons = 0;
           if (buttons_reprapworld_keypad == 0) {
             newbutton_reprapworld_keypad = get_ADC_keyValue();
             if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
               buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
           }
 

commit aeb5c623c1aa4c1c73f16faa6566a1f3fd5e00eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 5 21:58:43 2017 -0600

    Show "Level Bed Corners" with UBL too
    
    Addressing #8676

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1b345d6b8a..4a3500f0e2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2548,24 +2548,25 @@ void kill_screen(const char* lcd_msg) {
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               _lcd_goto_bed_leveling
             #else
               lcd_bed_leveling
             #endif
           );
     #else
       #if PLANNER_LEVELING
         MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
       #endif
-      #if ENABLED(LEVEL_BED_CORNERS)
-        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-          MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-      #endif
+    #endif
+
+    #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
     #endif
 
     #if HAS_M206_COMMAND
       //
       // Set Home Offsets
       //
       MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
       //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
     #endif
 

commit e37dd645488ffc4377b6ec818c1e38e55b5903b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 28 01:07:10 2017 -0600

    Apply LEDColor, language fixes

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 06adb16d79..1b345d6b8a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -184,21 +184,20 @@ uint16_t max_display_update_time = 0;
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
     void lcd_info_menu();
   #endif // LCD_INFO_MENU
 
   #if ENABLED(LED_CONTROL_MENU)
     void lcd_led_menu();
-    void lcd_led_custom_menu();
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     void lcd_advanced_pause_toocold_menu();
     void lcd_advanced_pause_option_menu();
     void lcd_advanced_pause_init_message();
     void lcd_advanced_pause_unload_message();
     void lcd_advanced_pause_insert_message();
     void lcd_advanced_pause_load_message();
     void lcd_advanced_pause_heat_nozzle();
@@ -1017,22 +1016,23 @@ void kill_screen(const char* lcd_msg) {
           MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
     #endif // SDSUPPORT
 
     #if ENABLED(LCD_INFO_MENU)
       MENU_ITEM(submenu, MSG_INFO_MENU, lcd_info_menu);
     #endif
 
     #if ENABLED(LED_CONTROL_MENU)
-      MENU_ITEM(submenu, "LED Control", lcd_led_menu);
+      MENU_ITEM(submenu, MSG_LED_CONTROL, lcd_led_menu);
     #endif
+
     END_MENU();
   }
 
   /**
    *
    * "Tune" submenu items
    *
    */
 
   #if HAS_M206_COMMAND
@@ -3944,133 +3944,67 @@ void kill_screen(const char* lcd_msg) {
   #endif // LCD_INFO_MENU
 
   /**
    *
    * LED Menu
    *
    */
 
   #if ENABLED(LED_CONTROL_MENU)
 
-    bool led_restore_color =
-      #if ENABLED(LED_USER_PRESET_STARTUP)
-        false;
-      #else
-        true;
-      #endif
+    #if ENABLED(LED_COLOR_PRESETS)
 
-    extern uint8_t led_intensity_red,
-           led_intensity_green,
-           led_intensity_blue
-           #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
-             , led_intensity_white
-           #endif
-           #if ENABLED(NEOPIXEL_LED)
-             , led_intensity
-           #endif
-           ;
-
-    void update_leds() {
-      if (led_restore_color) {
-        #if ENABLED(LED_COLOR_PRESETS)
-          led_intensity_red = LED_USER_PRESET_RED;
-          led_intensity_green = LED_USER_PRESET_GREEN;
-          led_intensity_blue = LED_USER_PRESET_BLUE;
-          #if ENABLED(RGBW_LED)
-            led_intensity_white = LED_USER_PRESET_WHITE;
-          #endif
-          #if ENABLED(NEOPIXEL_LED)
-            led_intensity = LED_USER_PRESET_INTENSITY;
-          #endif
-        #else
-          led_intensity_red = 255;
-          led_intensity_green = 255;
-          led_intensity_blue = 255;
-          #if ENABLED(RGBW_LED)
-            led_intensity_white = 0;
-          #endif
-          #if ENABLED(NEOPIXEL_LED)
-            led_intensity = LED_USER_PRESET_INTENSITY;
-          #endif
+      void lcd_led_presets_menu() {
+        START_MENU();
+        #if LCD_HEIGHT > 2
+          STATIC_ITEM(MSG_LED_PRESETS, true, true);
         #endif
-        led_restore_color = false;
+        MENU_BACK(MSG_LED_CONTROL);
+        MENU_ITEM(function, MSG_SET_LEDS_WHITE, leds.set_white);
+        MENU_ITEM(function, MSG_SET_LEDS_RED, leds.set_red);
+        MENU_ITEM(function, MSG_SET_LEDS_ORANGE, leds.set_orange);
+        MENU_ITEM(function, MSG_SET_LEDS_YELLOW,leds.set_yellow);
+        MENU_ITEM(function, MSG_SET_LEDS_GREEN, leds.set_green);
+        MENU_ITEM(function, MSG_SET_LEDS_BLUE, leds.set_blue);
+        MENU_ITEM(function, MSG_SET_LEDS_INDIGO, leds.set_indigo);
+        MENU_ITEM(function, MSG_SET_LEDS_VIOLET, leds.set_violet);
+        END_MENU();
       }
-
-      set_led_color(led_intensity_red, led_intensity_green, led_intensity_blue
-        #if ENABLED(RGBW_LED)
-          , led_intensity_white
-        #endif
-        #if ENABLED(NEOPIXEL_LED)
-          , 0, led_intensity
-        #endif
-        );
-      led_restore_color = false;
-    }
-
-    void led_restore_default() {
-      led_restore_color = true;
-      update_leds();
-    }
-
-    void set_leds_off() {
-      set_led_color(0, 0, 0
-        #if ENABLED(RGBW) || ENABLED(NEOPIXEL_LED)
-        , 0
-        #endif
-        );
-    }
-
-    void lcd_led_red()    { set_led_color(255, 0, 0); }
-    void lcd_led_orange() { set_led_color(150, 60, 0); }
-    void lcd_led_yellow() { set_led_color(255, 255, 0); }
-    void lcd_led_green()  { set_led_color(0, 255, 0); }
-    void lcd_led_blue()   { set_led_color(0, 0, 255); }
-    void lcd_led_purple() { set_led_color(255, 0, 255); }
-
-    void lcd_led_presets_menu() {
-      START_MENU();
-      MENU_BACK(MSG_LED_CONTROL);
-      MENU_ITEM(function, MSG_LED_ON MSG_RED MSG_LIGHTS, lcd_led_red);
-      MENU_ITEM(function, MSG_LED_ON MSG_ORANGE MSG_LIGHTS, lcd_led_orange);
-      MENU_ITEM(function, MSG_LED_ON MSG_YELLOW MSG_LIGHTS,lcd_led_yellow);
-      MENU_ITEM(function, MSG_LED_ON MSG_GREEN MSG_LIGHTS, lcd_led_green);
-      MENU_ITEM(function, MSG_LED_ON MSG_BLUE MSG_LIGHTS, lcd_led_blue);
-      MENU_ITEM(function, MSG_LED_ON MSG_PURPLE MSG_LIGHTS, lcd_led_purple);
-      MENU_ITEM(function, MSG_LED_ON MSG_WHITE MSG_LIGHTS, set_led_white);
-      END_MENU();
-    }
+    #endif // LED_COLOR_PRESETS
 
     void lcd_led_custom_menu() {
       START_MENU();
       MENU_BACK(MSG_LED_CONTROL);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_RED MSG_LED_INTENSITY, &led_intensity_red, 0, 255, update_leds, true);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_GREEN MSG_LED_INTENSITY, &led_intensity_green, 0, 255, update_leds, true);
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_BLUE MSG_LED_INTENSITY, &led_intensity_blue, 0, 255, update_leds, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_R, &leds.color.r, 0, 255, leds.update, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_G, &leds.color.g, 0, 255, leds.update, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_B, &leds.color.b, 0, 255, leds.update, true);
       #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
-        MENU_ITEM_EDIT_CALLBACK(int8, MSG_WHITE MSG_LED_INTENSITY, &led_intensity_white, 0, 255, update_leds, true);
-      #endif
-      #if ENABLED(NEOPIXEL_LED)
-        MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_INTENSITY, &led_intensity, 0, 255, update_leds, true);
+        MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_W, &leds.color.w, 0, 255, leds.update, true);
+        #if ENABLED(NEOPIXEL_LED)
+          MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_BRIGHTNESS, &leds.color.i, 0, 255, leds.update, true);
+        #endif
       #endif
       END_MENU();
     }
 
     void lcd_led_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM(function, MSG_LIGHTS MSG_OFF, set_leds_off); // works
-      MENU_ITEM(function, MSG_LIGHTS MSG_ON, update_leds); // works
-      MENU_ITEM(function, MSG_LED_LOAD MSG_LED_DEFAULT MSG_LIGHTS, led_restore_default); // works
+      if (leds.lights_on)
+        MENU_ITEM(function, MSG_LEDS_OFF, leds.toggle);
+      else
+        MENU_ITEM(function, MSG_LEDS_ON, leds.toggle);
+      MENU_ITEM(function, MSG_SET_LEDS_DEFAULT, leds.set_default);
       #if ENABLED(LED_COLOR_PRESETS)
-        MENU_ITEM(submenu, MSG_LED_PRESET MSG_LIGHTS, lcd_led_presets_menu);
+        MENU_ITEM(submenu, MSG_LED_PRESETS, lcd_led_presets_menu);
       #endif
-      MENU_ITEM(submenu, MSG_CUSTOM MSG_LIGHTS, lcd_led_custom_menu);
+      MENU_ITEM(submenu, MSG_CUSTOM_LEDS, lcd_led_custom_menu);
       END_MENU();
     }
 
   #endif // LED_CONTROL_MENU
 
   /**
    *
    * Filament Change Feature Screens
    *
    */

commit cf0f78336b7557f7aca81e841c1e6b74c3f1be07
Author: Tannoo <tannoo@msn.com>
Date:   Thu Nov 9 16:39:01 2017 -0700

    New Feature: LED_CONTROL_MENU

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 239b262290..06adb16d79 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -48,20 +48,24 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(LED_CONTROL_MENU)
+  #include "../feature/leds/leds.h"
+#endif
+
 // For i2c define BUZZ to use lcd_buzz
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
   bool lcd_external_control; // = false
 #endif
 
 // Initialized by settings.load()
@@ -178,20 +182,25 @@ uint16_t max_display_update_time = 0;
 
   #if ENABLED(LCD_INFO_MENU)
     #if ENABLED(PRINTCOUNTER)
       void lcd_info_stats_menu();
     #endif
     void lcd_info_thermistors_menu();
     void lcd_info_board_menu();
     void lcd_info_menu();
   #endif // LCD_INFO_MENU
 
+  #if ENABLED(LED_CONTROL_MENU)
+    void lcd_led_menu();
+    void lcd_led_custom_menu();
+  #endif
+
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     void lcd_advanced_pause_toocold_menu();
     void lcd_advanced_pause_option_menu();
     void lcd_advanced_pause_init_message();
     void lcd_advanced_pause_unload_message();
     void lcd_advanced_pause_insert_message();
     void lcd_advanced_pause_load_message();
     void lcd_advanced_pause_heat_nozzle();
     void lcd_advanced_pause_extrude_message();
     void lcd_advanced_pause_resume_message();
@@ -1007,20 +1016,23 @@ void kill_screen(const char* lcd_msg) {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
         #endif
       }
     #endif // SDSUPPORT
 
     #if ENABLED(LCD_INFO_MENU)
       MENU_ITEM(submenu, MSG_INFO_MENU, lcd_info_menu);
     #endif
 
+    #if ENABLED(LED_CONTROL_MENU)
+      MENU_ITEM(submenu, "LED Control", lcd_led_menu);
+    #endif
     END_MENU();
   }
 
   /**
    *
    * "Tune" submenu items
    *
    */
 
   #if HAS_M206_COMMAND
@@ -3924,20 +3936,146 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, lcd_info_printer_menu);        // Printer Info >
       MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, lcd_info_board_menu);            // Board Info >
       MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, lcd_info_thermistors_menu); // Thermistors >
       #if ENABLED(PRINTCOUNTER)
         MENU_ITEM(submenu, MSG_INFO_STATS_MENU, lcd_info_stats_menu);          // Printer Statistics >
       #endif
       END_MENU();
     }
   #endif // LCD_INFO_MENU
 
+  /**
+   *
+   * LED Menu
+   *
+   */
+
+  #if ENABLED(LED_CONTROL_MENU)
+
+    bool led_restore_color =
+      #if ENABLED(LED_USER_PRESET_STARTUP)
+        false;
+      #else
+        true;
+      #endif
+
+    extern uint8_t led_intensity_red,
+           led_intensity_green,
+           led_intensity_blue
+           #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
+             , led_intensity_white
+           #endif
+           #if ENABLED(NEOPIXEL_LED)
+             , led_intensity
+           #endif
+           ;
+
+    void update_leds() {
+      if (led_restore_color) {
+        #if ENABLED(LED_COLOR_PRESETS)
+          led_intensity_red = LED_USER_PRESET_RED;
+          led_intensity_green = LED_USER_PRESET_GREEN;
+          led_intensity_blue = LED_USER_PRESET_BLUE;
+          #if ENABLED(RGBW_LED)
+            led_intensity_white = LED_USER_PRESET_WHITE;
+          #endif
+          #if ENABLED(NEOPIXEL_LED)
+            led_intensity = LED_USER_PRESET_INTENSITY;
+          #endif
+        #else
+          led_intensity_red = 255;
+          led_intensity_green = 255;
+          led_intensity_blue = 255;
+          #if ENABLED(RGBW_LED)
+            led_intensity_white = 0;
+          #endif
+          #if ENABLED(NEOPIXEL_LED)
+            led_intensity = LED_USER_PRESET_INTENSITY;
+          #endif
+        #endif
+        led_restore_color = false;
+      }
+
+      set_led_color(led_intensity_red, led_intensity_green, led_intensity_blue
+        #if ENABLED(RGBW_LED)
+          , led_intensity_white
+        #endif
+        #if ENABLED(NEOPIXEL_LED)
+          , 0, led_intensity
+        #endif
+        );
+      led_restore_color = false;
+    }
+
+    void led_restore_default() {
+      led_restore_color = true;
+      update_leds();
+    }
+
+    void set_leds_off() {
+      set_led_color(0, 0, 0
+        #if ENABLED(RGBW) || ENABLED(NEOPIXEL_LED)
+        , 0
+        #endif
+        );
+    }
+
+    void lcd_led_red()    { set_led_color(255, 0, 0); }
+    void lcd_led_orange() { set_led_color(150, 60, 0); }
+    void lcd_led_yellow() { set_led_color(255, 255, 0); }
+    void lcd_led_green()  { set_led_color(0, 255, 0); }
+    void lcd_led_blue()   { set_led_color(0, 0, 255); }
+    void lcd_led_purple() { set_led_color(255, 0, 255); }
+
+    void lcd_led_presets_menu() {
+      START_MENU();
+      MENU_BACK(MSG_LED_CONTROL);
+      MENU_ITEM(function, MSG_LED_ON MSG_RED MSG_LIGHTS, lcd_led_red);
+      MENU_ITEM(function, MSG_LED_ON MSG_ORANGE MSG_LIGHTS, lcd_led_orange);
+      MENU_ITEM(function, MSG_LED_ON MSG_YELLOW MSG_LIGHTS,lcd_led_yellow);
+      MENU_ITEM(function, MSG_LED_ON MSG_GREEN MSG_LIGHTS, lcd_led_green);
+      MENU_ITEM(function, MSG_LED_ON MSG_BLUE MSG_LIGHTS, lcd_led_blue);
+      MENU_ITEM(function, MSG_LED_ON MSG_PURPLE MSG_LIGHTS, lcd_led_purple);
+      MENU_ITEM(function, MSG_LED_ON MSG_WHITE MSG_LIGHTS, set_led_white);
+      END_MENU();
+    }
+
+    void lcd_led_custom_menu() {
+      START_MENU();
+      MENU_BACK(MSG_LED_CONTROL);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_RED MSG_LED_INTENSITY, &led_intensity_red, 0, 255, update_leds, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_GREEN MSG_LED_INTENSITY, &led_intensity_green, 0, 255, update_leds, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_BLUE MSG_LED_INTENSITY, &led_intensity_blue, 0, 255, update_leds, true);
+      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
+        MENU_ITEM_EDIT_CALLBACK(int8, MSG_WHITE MSG_LED_INTENSITY, &led_intensity_white, 0, 255, update_leds, true);
+      #endif
+      #if ENABLED(NEOPIXEL_LED)
+        MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_INTENSITY, &led_intensity, 0, 255, update_leds, true);
+      #endif
+      END_MENU();
+    }
+
+    void lcd_led_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM(function, MSG_LIGHTS MSG_OFF, set_leds_off); // works
+      MENU_ITEM(function, MSG_LIGHTS MSG_ON, update_leds); // works
+      MENU_ITEM(function, MSG_LED_LOAD MSG_LED_DEFAULT MSG_LIGHTS, led_restore_default); // works
+      #if ENABLED(LED_COLOR_PRESETS)
+        MENU_ITEM(submenu, MSG_LED_PRESET MSG_LIGHTS, lcd_led_presets_menu);
+      #endif
+      MENU_ITEM(submenu, MSG_CUSTOM MSG_LIGHTS, lcd_led_custom_menu);
+      END_MENU();
+    }
+
+  #endif // LED_CONTROL_MENU
+
   /**
    *
    * Filament Change Feature Screens
    *
    */
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
     // Portions from STATIC_ITEM...
     #define HOTEND_STATUS_ITEM() do { \
       if (_menuLineNr == _thisItemNr) { \

commit 276271e72fc8b2b496fcb2c96544c91ae362cb3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 27 02:12:29 2017 -0600

    Make MBL work more like PROBE_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f52aec8e95..239b262290 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -208,21 +208,20 @@ uint16_t max_display_update_time = 0;
     #include "../feature/fwretract.h"
     void lcd_control_retract_menu();
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
     #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
-    extern void mesh_probing_done();
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
   void menu_action_gcode(const char* pgcode);
@@ -1735,124 +1734,77 @@ void kill_screen(const char* lcd_msg) {
 
     // LCD probed points are from defaults
     constexpr uint8_t total_probe_points = (
       #if ENABLED(AUTO_BED_LEVELING_3POINT)
         3
       #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
         GRID_MAX_POINTS
       #endif
     );
 
+    bool lcd_wait_for_move;
+
+    //
+    // Bed leveling is done. Wait for G29 to complete.
+    // A flag is used so that this can release control
+    // and allow the command queue to be processed.
+    //
+    // When G29 finishes the last move:
+    // - Raise Z to the "manual probe height"
+    // - Don't return until done.
     //
-    // Raise Z to the "manual probe height"
-    // Don't return until done.
     // ** This blocks the command queue! **
     //
-    void _lcd_after_probing() {
-      #if MANUAL_PROBE_HEIGHT > 0
-        line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
-      #endif
-      // Display "Done" screen and wait for moves to complete
-      #if MANUAL_PROBE_HEIGHT > 0 || ENABLED(MESH_BED_LEVELING)
-        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
-      #endif
-      lcd_goto_previous_menu();
-      lcd_completion_feedback();
-      defer_return_to_status = false;
-      //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
-    }
-
-    #if ENABLED(MESH_BED_LEVELING)
-
-      // Utility to go to the next mesh point
-      inline void _manual_probe_goto_xy(const float &rx, const float &ry) {
-        #if MANUAL_PROBE_HEIGHT > 0
-          const float prev_z = current_position[Z_AXIS];
+    void _lcd_level_bed_done() {
+      if (!lcd_wait_for_move) {
+        #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
+          // Display "Done" screen and wait for moves to complete
           line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
+          lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
         #endif
-        current_position[X_AXIS] = rx;
-        current_position[Y_AXIS] = ry;
-        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
-        #if MANUAL_PROBE_HEIGHT > 0
-          line_to_z(prev_z);
-        #endif
-        lcd_synchronize();
-      }
-
-    #elif ENABLED(PROBE_MANUALLY)
-
-      bool lcd_wait_for_move;
-
-      //
-      // Bed leveling is done. Wait for G29 to complete.
-      // A flag is used so that this can release control
-      // and allow the command queue to be processed.
-      //
-      void _lcd_level_bed_done() {
-        if (!lcd_wait_for_move) _lcd_after_probing();
-        if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_DONE));
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        lcd_goto_previous_menu();
+        lcd_completion_feedback();
+        defer_return_to_status = false;
       }
-
-    #endif
+      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+    }
 
     void _lcd_level_goto_next_point();
 
     /**
      * Step 7: Get the Z coordinate, click goes to the next point or exits
      */
     void _lcd_level_bed_get_z() {
       ENCODER_DIRECTION_NORMAL();
 
       if (lcd_clicked) {
 
         //
-        // Save the current Z position
+        // Save the current Z position and move
         //
 
-        #if ENABLED(MESH_BED_LEVELING)
-
-          //
-          // MBL records the position but doesn't move to the next one
-          //
-
-          mbl.set_zigzag_z(manual_probe_index, current_position[Z_AXIS]);
-
-        #endif
-
         // If done...
         if (++manual_probe_index >= total_probe_points) {
-
+          //
+          // The last G29 records the point and enables bed leveling
+          //
+          lcd_wait_for_move = true;
+          lcd_goto_screen(_lcd_level_bed_done);
           #if ENABLED(PROBE_MANUALLY)
-
-            //
-            // The last G29 will record and enable but not move.
-            //
-            lcd_wait_for_move = true;
             enqueue_and_echo_commands_P(PSTR("G29 V1"));
-            lcd_goto_screen(_lcd_level_bed_done);
-
           #elif ENABLED(MESH_BED_LEVELING)
-
-            _lcd_after_probing();
-
-            mbl.has_mesh = true;
-            mesh_probing_done();
-
+            enqueue_and_echo_commands_P(PSTR("G29 S2"));
           #endif
-
         }
-        else {
-          // MESH_BED_LEVELING: Z already stored, just move
-          //    PROBE_MANUALLY: Send G29 to record Z, then move
+        else
           _lcd_level_goto_next_point();
-        }
 
         return;
       }
 
       //
       // Encoder knob or keypad buttons adjust the Z position
       //
       if (encoderPosition) {
         gcode.refresh_cmd_timeout();
         const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
@@ -1866,58 +1818,43 @@ void kill_screen(const char* lcd_msg) {
       //
       if (lcdDrawUpdate) {
         const float v = current_position[Z_AXIS];
         lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001 : 0.0001), '+'));
       }
     }
 
     /**
      * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
      */
-
     void _lcd_level_bed_moving() {
       if (lcdDrawUpdate) {
         char msg[10];
         sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
         lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
       }
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-      #if ENABLED(PROBE_MANUALLY)
-        if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
-      #endif
+      if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
     }
 
     /**
      * Step 5: Initiate a move to the next point
      */
     void _lcd_level_goto_next_point() {
-
       // Set the menu to display ahead of blocking call
       lcd_goto_screen(_lcd_level_bed_moving);
 
-      #if ENABLED(MESH_BED_LEVELING)
-
-        int8_t px, py;
-        mbl.zigzag(manual_probe_index, px, py);
-
-        // Controls the loop until the move is done
-        _manual_probe_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
-
-        // After the blocking function returns, change menus
-        lcd_goto_screen(_lcd_level_bed_get_z);
-
-      #elif ENABLED(PROBE_MANUALLY)
-
-        // G29 Records Z, moves, and signals when it pauses
-        lcd_wait_for_move = true;
+      // G29 Records Z, moves, and signals when it pauses
+      lcd_wait_for_move = true;
+      #if ENABLED(PROBE_MANUALLY)
         enqueue_and_echo_commands_P(PSTR("G29 V1"));
-
+      #elif ENABLED(MESH_BED_LEVELING)
+        enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
       #endif
     }
 
     /**
      * Step 4: Display "Click to Begin", wait for click
      *         Move to the first probe position
      */
     void _lcd_level_bed_homing_done() {
       if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
       if (lcd_clicked) {
@@ -1969,25 +1906,29 @@ void kill_screen(const char* lcd_msg) {
      *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
      *    Level Bed >
      *    Level Corners >     (if homed)
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
 
-      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
-        MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-      else if (leveling_is_valid()) {
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-      }
+      #if DISABLED(MESH_BED_LEVELING)
+        if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
+          MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+        else
+      #endif
+        if (leveling_is_valid()) {
+          new_level_state = planner.leveling_active;
+          MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+        }
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
@@ -2009,23 +1950,20 @@ void kill_screen(const char* lcd_msg) {
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
     void _lcd_goto_bed_leveling() {
       lcd_goto_screen(lcd_bed_leveling);
-      #if ENABLED(LCD_BED_LEVELING)
-        new_level_state = planner.leveling_active;
-      #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         new_z_fade_height = planner.z_fade_height;
       #endif
     }
 
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
     static int16_t ubl_storage_slot = 0,

commit f90c075d1f06b4e336c9a20cd28f9aec7b5a0972
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 26 01:14:18 2017 -0600

    SD Menu patches

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b0b4c15e1b..f52aec8e95 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3736,21 +3736,21 @@ void kill_screen(const char* lcd_msg) {
   #if ENABLED(SDSUPPORT)
 
     #if !PIN_EXISTS(SD_DETECT)
       void lcd_sd_refresh() {
         card.initsd();
         encoderTopLine = 0;
       }
     #endif
 
     void lcd_sd_updir() {
-      card.updir();
+      encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
       encoderTopLine = 0;
       screen_changed = true;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
     /**
      *
      * "Print from SD" submenu
      *
      */
@@ -4437,21 +4437,22 @@ void kill_screen(const char* lcd_msg) {
         last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
       #endif
       UNUSED(longFilename);
       card.openAndPrintFile(filename);
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
-      encoderPosition = 0;
+      encoderTopLine = 0;
+      encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
       screen_changed = true;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
   #endif // SDSUPPORT
 
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();

commit 9b64be0bc527900c46ad8dca0d77858b4e9c07b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 26 00:05:36 2017 -0600

    Fixes for leveling sub-menus

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index dc4781f046..b0b4c15e1b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1997,32 +1997,32 @@ void kill_screen(const char* lcd_msg) {
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #elif HAS_BED_PROBE
         MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
       #endif
 
       MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
 
       #if ENABLED(LEVEL_BED_CORNERS)
         // Move to the next corner for leveling
         if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-          MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+          MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
     void _lcd_goto_bed_leveling() {
-      currentScreen = lcd_bed_leveling;
+      lcd_goto_screen(lcd_bed_leveling);
       #if ENABLED(LCD_BED_LEVELING)
         new_level_state = planner.leveling_active;
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         new_z_fade_height = planner.z_fade_height;
       #endif
     }
 
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 

commit 5926c9c97b7855b75ec6af14ce49366b91ab0bec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 24 13:35:08 2017 -0600

    Followup for MESH_EDIT_GFX_OVERLAY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ef97797a3a..dc4781f046 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1028,20 +1028,58 @@ void kill_screen(const char* lcd_msg) {
     /**
      * Set the home offset based on the current_position
      */
     void lcd_set_home_offsets() {
       // M428 Command
       enqueue_and_echo_commands_P(PSTR("M428"));
       lcd_return_to_status();
     }
   #endif
 
+  #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY) || ENABLED(MESH_EDIT_GFX_OVERLAY)
+
+    void _lcd_zoffset_overlay_gfx(const float zvalue) {
+      // Determine whether the user is raising or lowering the nozzle.
+      static int8_t dir;
+      static float old_zvalue;
+      if (zvalue != old_zvalue) {
+        dir = zvalue ? zvalue < old_zvalue ? -1 : 1 : 0;
+        old_zvalue = zvalue;
+      }
+
+      #if ENABLED(OVERLAY_GFX_REVERSE)
+        const unsigned char *rot_up = ccw_bmp, *rot_down = cw_bmp;
+      #else
+        const unsigned char *rot_up = cw_bmp, *rot_down = ccw_bmp;
+      #endif
+
+      #if ENABLED(USE_BIG_EDIT_FONT)
+        const int left = 0, right = 45, nozzle = 95;
+      #else
+        const int left = 5, right = 90, nozzle = 60;
+      #endif
+
+      // Draw a representation of the nozzle
+      if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
+      if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
+
+      // Draw cw/ccw indicator and up/down arrows.
+      if (PAGE_CONTAINS(47,62)) {
+        u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
+        u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
+        u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
+        u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
+      }
+    }
+
+  #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || MESH_EDIT_GFX_OVERLAY
+
   #if ENABLED(BABYSTEPPING)
 
     void _lcd_babystep(const AxisEnum axis, const char* msg) {
       if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
       ENCODER_DIRECTION_NORMAL();
       if (encoderPosition) {
         const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         thermalManager.babystep_axis(axis, babystep_increment);
@@ -1051,60 +1089,20 @@ void kill_screen(const char* lcd_msg) {
         lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
     }
 
     #if ENABLED(BABYSTEP_XY)
       void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
       void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
-    #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY) || ENABLED(ENABLE_MESH_EDIT_GFX_OVERLAY)
-
-      void _lcd_zoffset_overlay_gfx(const float in_zoffset) {
-        // Determine whether the user is raising or lowering the nozzle.
-        int8_t dir = 0;
-        static float old_zprobe_zoffset = 0;
-        if (in_zoffset != old_zprobe_zoffset) {
-          dir = (in_zoffset > old_zprobe_zoffset) ? 1 : (in_zoffset == 0) ? 0 : -1;
-          old_zprobe_zoffset = in_zoffset;
-        }
-
-        #if ENABLED(BABYSTEP_ZPROBE_GFX_REVERSE)
-          const unsigned char *rot_up   = ccw_bmp;
-          const unsigned char *rot_down = cw_bmp;
-        #else
-          const unsigned char *rot_up   = cw_bmp;
-          const unsigned char *rot_down = ccw_bmp;
-        #endif
-
-        #if ENABLED(USE_BIG_EDIT_FONT)
-          const int left = 0, right = 45, nozzle = 95;
-        #else
-          const int left = 5, right = 90, nozzle = 60;
-        #endif
-
-        // Draw a representation of the nozzle
-        if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
-        if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
-
-        // Draw cw/ccw indicator and up/down arrows.
-        if (PAGE_CONTAINS(47,62)) {
-          u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
-          u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
-          u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
-          u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
-        }
-      }
-
-    #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || ENABLE_MESH_EDIT_GFX_OVERLAY
-
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
@@ -1150,21 +1148,21 @@ void kill_screen(const char* lcd_msg) {
         mesh_edit_value = mesh_edit_accumulator;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
 
         const int32_t rounded = (int32_t)(mesh_edit_value * 1000.0);
         mesh_edit_value = float(rounded - (rounded % 5L)) / 1000.0;
       }
 
       if (lcdDrawUpdate)
         lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
-        #if ENABLED(ENABLE_MESH_EDIT_GFX_OVERLAY)
+        #if ENABLED(MESH_EDIT_GFX_OVERLAY)
           _lcd_zoffset_overlay_gfx(mesh_edit_value);
         #endif
     }
 
     void _lcd_mesh_edit_NOP() {
       defer_return_to_status = true;
     }
 
     float lcd_mesh_edit() {
       lcd_goto_screen(_lcd_mesh_edit_NOP);
@@ -1187,21 +1185,20 @@ void kill_screen(const char* lcd_msg) {
       return mesh_edit_value;
     }
 
     void lcd_z_offset_edit_setup(float initial) {
       mesh_edit_value = mesh_edit_accumulator = initial;
       lcd_goto_screen(_lcd_z_offset_edit);
     }
 
   #endif // AUTO_BED_LEVELING_UBL
 
-
   /**
    * Watch temperature callbacks
    */
   #if HAS_TEMP_HOTEND
     #if WATCH_HOTENDS
       #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
     #else
       #define _WATCH_FUNC(N) NOOP
     #endif
     void watch_temp_callback_E0() { _WATCH_FUNC(0); }

commit c6b0c104bbab04d4d59c4f3f8fddb728e9b99603
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 23 17:59:43 2017 -0600

    Adapt G26 to work for all meshes

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b1ebb29258..ef97797a3a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -53,20 +53,24 @@
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 // For i2c define BUZZ to use lcd_buzz
 #if DISABLED(LCD_USE_I2C_BUZZER)
   #include "../libs/buzzer.h"
 #endif
 
+#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+  bool lcd_external_control; // = false
+#endif
+
 // Initialized by settings.load()
 int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
 #endif
 
 #if ENABLED(BABYSTEPPING)
   long babysteps_done = 0;
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -4592,21 +4596,21 @@ void lcd_update() {
     // Handle any queued Move Axis motion
     manage_manual_move();
 
     // Update button states for LCD_CLICKED, etc.
     // After state changes the next button update
     // may be delayed 300-500ms.
     lcd_buttons_update();
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       // Don't run the debouncer if UBL owns the display
-      #define UBL_CONDITION !ubl.has_control_of_lcd_panel
+      #define UBL_CONDITION !lcd_external_control
     #else
       #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user;    //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
@@ -5063,44 +5067,44 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     if (buttons & EN_A) enc |= B01;
     if (buttons & EN_B) enc |= B10;
     if (enc != lastEncoderBits) {
       switch (enc) {
         case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
         case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
         case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
         case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
       }
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        if (ubl.has_control_of_lcd_panel) {
+        if (lcd_external_control) {
           ubl.encoder_diff = encoderDiff;   // Make the encoder's rotation available to G29's Mesh Editor
           encoderDiff = 0;                  // We are going to lie to the LCD Panel and claim the encoder
                                             // knob has not turned.
         }
       #endif
       lastEncoderBits = enc;
     }
   }
 
   #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
     bool lcd_detected() { return lcd.LcdDetected() == 1; }
   #else
     bool lcd_detected() { return true; }
   #endif
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    void chirp_at_user() {
+  #if ENABLED(G26_MESH_VALIDATION)
+    void lcd_chirp() {
       lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     }
+  #endif
 
-    bool ubl_lcd_clicked() { return LCD_CLICKED; }
-
+  #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(G26_MESH_VALIDATION)
+    bool is_lcd_clicked() { return LCD_CLICKED; }
   #endif
 
 #endif // ULTIPANEL
 
 #if ENABLED(ADC_KEYPAD)
 
   typedef struct {
     uint16_t ADCKeyValueMin, ADCKeyValueMax;
     uint8_t  ADCKeyNo;
   } _stADCKeypadTable_;

commit 9406c87a9740790b2a3488199854cd1fc816f62d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 22 18:22:55 2017 -0600

    Fix up LCD init / charset

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 0517f5b80d..b1ebb29258 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -515,27 +515,29 @@ uint16_t max_display_update_time = 0;
       if (screen == lcd_status_screen) {
         defer_return_to_status = false;
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.lcd_map_control = false;
         #endif
         screen_history_depth = 0;
       }
       lcd_implementation_clear();
       // Re-initialize custom characters that may be re-used
       #if DISABLED(DOGLCD) && ENABLED(AUTO_BED_LEVELING_UBL)
-        if (!ubl.lcd_map_control) lcd_set_custom_characters(
-          #if ENABLED(LCD_PROGRESS_BAR)
-            screen == lcd_status_screen
-          #endif
-        );
+        if (!ubl.lcd_map_control) {
+          lcd_set_custom_characters(
+            #if ENABLED(LCD_PROGRESS_BAR)
+              screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
+            #endif
+          );
+        }
       #elif ENABLED(LCD_PROGRESS_BAR)
-        lcd_set_custom_characters(screen == lcd_status_screen);
+        lcd_set_custom_characters(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
       #endif
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       screen_changed = true;
       #if ENABLED(DOGLCD)
         drawing_screen = false;
       #endif
     }
   }
 
   /**
@@ -663,21 +665,21 @@ void lcd_status_screen() {
   #endif // LCD_PROGRESS_BAR
 
   #if ENABLED(ULTIPANEL)
 
     if (lcd_clicked) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
-          false
+          CHARSET_MENU
         #endif
       );
       lcd_goto_screen(lcd_main_menu);
       return;
     }
 
     #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
       const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
       // Dead zone at 100% feedrate
       if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
@@ -842,21 +844,21 @@ void kill_screen(const char* lcd_msg) {
     }
 
   #endif // BLTOUCH
 
   #if ENABLED(LCD_PROGRESS_BAR_TEST)
 
     static void progress_bar_test() {
       static int8_t bar_percent = 0;
       if (lcd_clicked) {
         lcd_goto_previous_menu();
-        lcd_set_custom_characters(false);
+        lcd_set_custom_characters(CHARSET_MENU);
         return;
       }
       bar_percent += (int8_t)encoderPosition;
       bar_percent = constrain(bar_percent, 0, 100);
       encoderPosition = 0;
       lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
       lcd.setCursor((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
       lcd.print(itostr3(bar_percent)); lcd.write('%');
       lcd.setCursor(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
     }
@@ -4451,25 +4453,21 @@ void kill_screen(const char* lcd_msg) {
   void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
   void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
     menu_action_setting_edit_bool(pstr, ptr);
     (*callback)();
   }
 
 #endif // ULTIPANEL
 
 void lcd_init() {
 
-  lcd_implementation_init(
-    #if ENABLED(LCD_PROGRESS_BAR)
-      true
-    #endif
-  );
+  lcd_implementation_init();
 
   #if ENABLED(NEWPANEL)
 
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
     #if BUTTON_EXISTS(ENC)
@@ -4629,21 +4627,21 @@ void lcd_update() {
       }
       else {
         card.release();
         if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
       }
 
       lcd_sd_status = sd_status;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
-          currentScreen == lcd_status_screen
+          currentScreen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
         #endif
       );
     }
 
   #endif // SDSUPPORT && SD_DETECT_PIN
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_lcd_update_ms)
     #if ENABLED(DOGLCD)
       || drawing_screen

commit 56c02b7f59bc83da78ef04e1065b1f5c9fe49dc1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 21 00:20:01 2017 -0600

    Shift register buttons question
    
    Can LCD shift registers keep up with faster MCUs?

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5b01604d92..0517f5b80d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4924,21 +4924,21 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
    * These values are independent of which pins are used for EN_A and EN_B indications
    * The rotary encoder part is also independent to the chipset used for the LCD
    */
   #if defined(EN_A) && defined(EN_B)
     #define encrot0 0
     #define encrot1 2
     #define encrot2 3
     #define encrot3 1
   #endif
 
-  #define GET_BUTTON_STATES(DST) \
+  #define GET_SHIFT_BUTTON_STATES(DST) \
     uint8_t new_##DST = 0; \
     WRITE(SHIFT_LD, LOW); \
     WRITE(SHIFT_LD, HIGH); \
     for (int8_t i = 0; i < 8; i++) { \
       new_##DST >>= 1; \
       if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
       WRITE(SHIFT_CLK, HIGH); \
       WRITE(SHIFT_CLK, LOW); \
     } \
     DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
@@ -5026,27 +5026,29 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
           uint8_t newbutton_reprapworld_keypad = 0;
           buttons = 0;
           if (buttons_reprapworld_keypad == 0) {
             newbutton_reprapworld_keypad = get_ADC_keyValue();
             if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
               buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
           }
 
         #elif ENABLED(REPRAPWORLD_KEYPAD)
 
-          GET_BUTTON_STATES(buttons_reprapworld_keypad);
+          GET_SHIFT_BUTTON_STATES(buttons_reprapworld_keypad);
 
         #endif
 
-      #else
-        GET_BUTTON_STATES(buttons);
-      #endif // !NEWPANEL
+      #else // !NEWPANEL
+
+        GET_SHIFT_BUTTON_STATES(buttons);
+
+      #endif
 
     } // next_button_update_ms
 
     // Manage encoder rotation
     #if ENABLED(REVERSE_MENU_DIRECTION) && ENABLED(REVERSE_ENCODER_DIRECTION)
       #define ENCODER_DIFF_CW  (encoderDiff -= encoderDirection)
       #define ENCODER_DIFF_CCW (encoderDiff += encoderDirection)
     #elif ENABLED(REVERSE_MENU_DIRECTION)
       #define ENCODER_DIFF_CW  (encoderDiff += encoderDirection)
       #define ENCODER_DIFF_CCW (encoderDiff -= encoderDirection)

commit 3994d3b935d0d52e4b23a854680a8eef2d4adc7a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 21 00:18:46 2017 -0600

    General cosmetic LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 8d92c936f0..5b01604d92 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4583,28 +4583,34 @@ bool lcd_blink() {
  *   After the menu handler callback runs (or not):
  *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
  *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
  *
  * No worries. This function is only called from the main thread.
  */
 void lcd_update() {
 
   #if ENABLED(ULTIPANEL)
     static millis_t return_to_status_ms = 0;
+
+    // Handle any queued Move Axis motion
     manage_manual_move();
 
+    // Update button states for LCD_CLICKED, etc.
+    // After state changes the next button update
+    // may be delayed 300-500ms.
     lcd_buttons_update();
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const bool UBL_CONDITION = !ubl.has_control_of_lcd_panel;
+      // Don't run the debouncer if UBL owns the display
+      #define UBL_CONDITION !ubl.has_control_of_lcd_panel
     #else
-      constexpr bool UBL_CONDITION = true;
+      #define UBL_CONDITION true
     #endif
 
     // If the action button is pressed...
     if (UBL_CONDITION && LCD_CLICKED) {
       if (!wait_for_unclick) {           // If not waiting for a debounce release:
         wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
         lcd_clicked = !wait_for_user;    //  Keep the click if not waiting for a user-click
         wait_for_user = false;           //  Any click clears wait for user
         lcd_quick_feedback();            //  Always make a click sound
       }
@@ -4937,41 +4943,48 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
     } \
     DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
 
 
   /**
    * Read encoder buttons from the hardware registers
    * Warning: This function is called from interrupt context!
    */
   void lcd_buttons_update() {
     static uint8_t lastEncoderBits;
-    millis_t now = millis();
+    const millis_t now = millis();
     if (ELAPSED(now, next_button_update_ms)) {
 
       #if ENABLED(NEWPANEL)
         uint8_t newbutton = 0;
 
         #if BUTTON_EXISTS(EN1)
           if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
         #endif
 
         #if BUTTON_EXISTS(EN2)
           if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
         #endif
 
         #if BUTTON_EXISTS(ENC)
           if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
         #endif
 
+        buttons = newbutton;
+        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+          buttons |= slow_buttons;
+        #endif
+
+        //
+        // Directional buttons
+        //
         #if LCD_HAS_DIRECTIONAL_BUTTONS
 
-          // Manage directional buttons
           #if ENABLED(REVERSE_MENU_DIRECTION)
             #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
           #else
             #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM
           #endif
           #if ENABLED(REVERSE_ENCODER_DIRECTION)
             #define ENCODER_UD_STEPS _ENCODER_UD_STEPS
             #define ENCODER_LR_PULSES ENCODER_PULSES_PER_STEP
           #else
             #define ENCODER_UD_STEPS -(_ENCODER_UD_STEPS)
@@ -5001,25 +5014,20 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
           #endif
           #if BUTTON_EXISTS(RT)
             else if (BUTTON_PRESSED(RT)) {
               encoderDiff = ENCODER_LR_PULSES;
               next_button_update_ms = now + 300;
             }
           #endif
 
         #endif // LCD_HAS_DIRECTIONAL_BUTTONS
 
-        buttons = newbutton;
-        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
-          buttons |= slow_buttons;
-        #endif
-
         #if ENABLED(ADC_KEYPAD)
 
           uint8_t newbutton_reprapworld_keypad = 0;
           buttons = 0;
           if (buttons_reprapworld_keypad == 0) {
             newbutton_reprapworld_keypad = get_ADC_keyValue();
             if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
               buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
           }
 

commit 6e533748eb221d5bfba69904b9a657aebd541a9b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 18 05:15:55 2017 -0600

    Fixes #8472

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c5118242a6..8d92c936f0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3675,20 +3675,21 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
     MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
     if (parser.volumetric_enabled) {
       #if EXTRUDERS == 1
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
       #else // EXTRUDERS > 1
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5, 3.25, planner.calculate_volumetric_multipliers);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
         #if EXTRUDERS > 2
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           #if EXTRUDERS > 3
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
             #if EXTRUDERS > 4
               MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3

commit 3bba7d60f352c7da638bc1fb65b279cd972d9b79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 16:53:55 2017 -0600

    No retroactive changes with M851 Z
    
    If using babystep to adjust the Z probe offset, the axis will move and the mesh will be updated at the same time, causing a doubling of the Z offset over the rest of the print.
    
    To correct for this, the current Z position would need to be modified in the opposite direction, canceling out the additional Z offset added to the mesh. This would be confusing to users, and moreover it would not be accurate without also taking the current Z fade level and current Z height into account.
    
    It might make sense to change the mesh in the case where no babystepping is taking place, but this could be considered an undesirable side-effect of changing the `zprobe_zoffset`.
    
    One way to remedy this would be to return to storing the mesh with `zprobe_zoffset` included, then subtracting `zprobe_zoffset` from the returned Z value. Thus, a babystep moving the Z axis up 1mm would subtract 1 from `zprobe_zoffset` while adding 1 to all mesh Z values.
    
    Without including the `zprobe_zoffset` in the `z_values` there is no safe way to alter the mesh in conjunction with babystepping, although it's fine without it.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5b310f6e37..c5118242a6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1093,32 +1093,30 @@ void kill_screen(const char* lcd_msg) {
     #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || ENABLE_MESH_EDIT_GFX_OVERLAY
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
-          encoderPosition = 0;
-
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
             if (planner.leveling_active)
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
-            refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
+          encoderPosition = 0;
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
             _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
@@ -1671,25 +1669,20 @@ void kill_screen(const char* lcd_msg) {
       card.checkautostart(true);
     }
 
   #endif
 
   #if ENABLED(EEPROM_SETTINGS)
     static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
     static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
   #endif
 
-  #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
-    static void lcd_refresh_zprobe_zoffset() { refresh_zprobe_zoffset(); }
-  #endif
-
-
   #if ENABLED(LEVEL_BED_CORNERS)
 
     /**
      * Level corners, starting in the front-left corner.
      */
     static int8_t bed_corner;
     void _lcd_goto_next_corner() {
       line_to_z(4.0);
       switch (bed_corner) {
         case 0:
@@ -1993,21 +1986,21 @@ void kill_screen(const char* lcd_msg) {
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
       #elif HAS_BED_PROBE
-        MENU_ITEM_EDIT_CALLBACK(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, lcd_refresh_zprobe_zoffset);
+        MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
       #endif
 
       MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
 
       #if ENABLED(LEVEL_BED_CORNERS)
         // Move to the next corner for leveling
         if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
           MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
@@ -3640,21 +3633,21 @@ void kill_screen(const char* lcd_msg) {
     END_MENU();
   }
 
   void lcd_control_motion_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
     #elif HAS_BED_PROBE
-      MENU_ITEM_EDIT_CALLBACK(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, lcd_refresh_zprobe_zoffset);
+      MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
     #endif
 
     // M203 / M205 - Feedrate items
     MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
 
     // M201 - Acceleration items
     MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
 
     // M205 - Max Jerk
     MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);

commit 36426af564cb2c11825b83cdd6c1976b874b6ab7
Merge: c0fe6cc34d cba9c1cf9e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 10 19:44:08 2017 -0600

    Merge pull request #8356 from tcm0116/2.0.x-M600
    
    [2.0.x] Normalize load/unload length in M600

diff --combined Marlin/src/lcd/ultralcd.cpp
index 588fb68893,03899fdb42..5b310f6e37
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -198,21 -198,21 +198,21 @@@ uint16_t max_display_update_time = 0
      void dac_driver_getValues();
      void lcd_dac_menu();
      void lcd_dac_write_eeprom();
    #endif
  
    #if ENABLED(FWRETRACT)
      #include "../feature/fwretract.h"
      void lcd_control_retract_menu();
    #endif
  
 -  #if ENABLED(DELTA_CALIBRATION_MENU)
 +  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
      void lcd_delta_calibrate_menu();
    #endif
  
    #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
      #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
      extern void mesh_probing_done();
    #endif
  
    ////////////////////////////////////////////
    //////////// Menu System Actions ///////////
@@@ -1242,20 -1242,36 +1242,36 @@@ void kill_screen(const char* lcd_msg) 
  
    // First Fan Speed title in "Tune" and "Control>Temperature" menus
    #if FAN_COUNT > 0 && HAS_FAN0
      #if FAN_COUNT > 1
        #define FAN_SPEED_1_SUFFIX " 1"
      #else
        #define FAN_SPEED_1_SUFFIX ""
      #endif
    #endif
  
+   // Refresh the E factor after changing flow
+   inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
+   #if EXTRUDERS > 1
+     inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
+     inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
+     #if EXTRUDERS > 2
+       inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
+       #if EXTRUDERS > 3
+         inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
+         #if EXTRUDERS > 4
+           inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
+         #endif // EXTRUDERS > 4
+       #endif // EXTRUDERS > 3
+     #endif // EXTRUDERS > 2
+   #endif // EXTRUDERS > 1
+ 
    /**
     *
     * "Tune" submenu
     *
     */
    void lcd_tune_menu() {
      START_MENU();
  
      //
      // ^ Main
@@@ -1321,31 -1337,31 +1337,31 @@@
            MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
          #endif
        #endif
      #endif // FAN_COUNT > 0
  
      //
      // Flow:
      // Flow [1-5]:
      //
      #if EXTRUDERS == 1
-       MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999);
+       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
      #else // EXTRUDERS > 1
-       MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999);
-       MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999);
-       MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999);
+       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
+       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
+       MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
        #if EXTRUDERS > 2
-         MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999);
+         MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
          #if EXTRUDERS > 3
-           MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999);
+           MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
            #if EXTRUDERS > 4
-             MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999);
+             MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
            #endif // EXTRUDERS > 4
          #endif // EXTRUDERS > 3
        #endif // EXTRUDERS > 2
      #endif // EXTRUDERS > 1
  
      //
      // Babystep X:
      // Babystep Y:
      // Babystep Z:
      //
@@@ -2552,21 -2568,21 +2568,21 @@@
  
      //
      // ^ Main
      //
      MENU_BACK(MSG_MAIN);
  
      //
      // Move Axis
      //
      #if ENABLED(DELTA)
 -      if (axis_homed[Z_AXIS])
 +      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
      #endif
          MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
  
      //
      // Auto Home
      //
      MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
      #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
        MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
        MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
@@@ -2667,21 -2683,21 +2683,21 @@@
      //
      // Autostart
      //
      #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
        MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
      #endif
  
      //
      // Delta Calibration
      //
 -    #if ENABLED(DELTA_CALIBRATION_MENU)
 +    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
      #endif
  
      END_MENU();
    }
  
    #if ENABLED(DELTA_CALIBRATION_MENU) || (ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE)
  
      void lcd_move_z();
  
@@@ -2736,64 -2752,62 +2752,64 @@@
  
        enqueue_and_echo_commands_P(PSTR("G28"));
        lcd_goto_screen(_lcd_calibrate_homing);
      }
  
      void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
      void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
      void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
      void _goto_center()  { _man_probe_pt(0,0); }
  
 -    void _lcd_set_delta_height() {
 -      update_software_endstops(Z_AXIS);
 -    }
 +  #endif // DELTA_CALIBRATION_MENU
 +
 +  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
  
      void lcd_delta_settings() {
        START_MENU();
        MENU_BACK(MSG_DELTA_CALIBRATE);
 -      MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
 -      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _lcd_set_delta_height);
 -      MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
 -      MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
 -      MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
 -      MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
 -      MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
 -      MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
 -      MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);
 +      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, recalc_delta_settings);
 +      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, recalc_delta_settings);
        END_MENU();
      }
  
      void lcd_delta_calibrate_menu() {
        START_MENU();
        MENU_BACK(MSG_MAIN);
        #if ENABLED(DELTA_AUTO_CALIBRATION)
 -        MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
          MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
          MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
          #if ENABLED(EEPROM_SETTINGS)
            MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
            MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
          #endif
        #endif
 -      MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
 -      if (axis_homed[Z_AXIS]) {
 -        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
 -        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
 -        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
 -        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
 -      }
 +      MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
 +      #if ENABLED(DELTA_CALIBRATION_MENU)
 +        MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
 +        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
 +          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
 +          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
 +          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
 +          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
 +        }
 +      #endif
        END_MENU();
      }
  
 -  #endif // DELTA_CALIBRATION_MENU
 +  #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
  
    /**
     * If the most recent manual move hasn't been fed to the planner yet,
     * and the planner can accept one, send immediately
     */
    inline void manage_manual_move() {
  
      if (processing_manual_move) return;
  
      if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {

commit e334efb2a7914b6a39fb3c060790319664d98b2d
Author: LVD-AC <lvd@sound-silence.com>
Date:   Wed Nov 8 10:07:17 2017 +0100

    PROBE_MANUALLY etc.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f11c7a3157..588fb68893 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -198,21 +198,21 @@ uint16_t max_display_update_time = 0;
     void dac_driver_getValues();
     void lcd_dac_menu();
     void lcd_dac_write_eeprom();
   #endif
 
   #if ENABLED(FWRETRACT)
     #include "../feature/fwretract.h"
     void lcd_control_retract_menu();
   #endif
 
-  #if ENABLED(DELTA_CALIBRATION_MENU)
+  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
     #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
     extern void mesh_probing_done();
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
@@ -2552,21 +2552,21 @@ void kill_screen(const char* lcd_msg) {
 
     //
     // ^ Main
     //
     MENU_BACK(MSG_MAIN);
 
     //
     // Move Axis
     //
     #if ENABLED(DELTA)
-      if (axis_homed[Z_AXIS])
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
     #endif
         MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
 
     //
     // Auto Home
     //
     MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
       MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
       MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
@@ -2667,21 +2667,21 @@ void kill_screen(const char* lcd_msg) {
     //
     // Autostart
     //
     #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
       MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
     #endif
 
     //
     // Delta Calibration
     //
-    #if ENABLED(DELTA_CALIBRATION_MENU)
+    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
       MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
     #endif
 
     END_MENU();
   }
 
   #if ENABLED(DELTA_CALIBRATION_MENU) || (ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE)
 
     void lcd_move_z();
 
@@ -2736,62 +2736,64 @@ void kill_screen(const char* lcd_msg) {
 
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
     void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
     void _goto_center()  { _man_probe_pt(0,0); }
 
-    void _lcd_set_delta_height() {
-      update_software_endstops(Z_AXIS);
-    }
+  #endif // DELTA_CALIBRATION_MENU
+
+  #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
-      MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _lcd_set_delta_height);
-      MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
-      MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5.0, delta_diagonal_rod + 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5.0, delta_radius + 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0, recalc_delta_settings);
+      MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0, recalc_delta_settings);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
-        MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
         #if ENABLED(EEPROM_SETTINGS)
           MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
           MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         #endif
       #endif
-      MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
-      if (axis_homed[Z_AXIS]) {
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
-      }
+      MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
+      #if ENABLED(DELTA_CALIBRATION_MENU)
+        MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
+        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
+          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
+          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
+          MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
+        }
+      #endif
       END_MENU();
     }
 
-  #endif // DELTA_CALIBRATION_MENU
+  #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send immediately
    */
   inline void manage_manual_move() {
 
     if (processing_manual_move) return;
 
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f11c7a3157..03899fdb42 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1242,20 +1242,36 @@ void kill_screen(const char* lcd_msg) {
 
   // First Fan Speed title in "Tune" and "Control>Temperature" menus
   #if FAN_COUNT > 0 && HAS_FAN0
     #if FAN_COUNT > 1
       #define FAN_SPEED_1_SUFFIX " 1"
     #else
       #define FAN_SPEED_1_SUFFIX ""
     #endif
   #endif
 
+  // Refresh the E factor after changing flow
+  inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
+  #if EXTRUDERS > 1
+    inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
+    inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
+    #if EXTRUDERS > 2
+      inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
+      #if EXTRUDERS > 3
+        inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
+        #if EXTRUDERS > 4
+          inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
+        #endif // EXTRUDERS > 4
+      #endif // EXTRUDERS > 3
+    #endif // EXTRUDERS > 2
+  #endif // EXTRUDERS > 1
+
   /**
    *
    * "Tune" submenu
    *
    */
   void lcd_tune_menu() {
     START_MENU();
 
     //
     // ^ Main
@@ -1321,31 +1337,31 @@ void kill_screen(const char* lcd_msg) {
           MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
         #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Flow:
     // Flow [1-5]:
     //
     #if EXTRUDERS == 1
-      MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
     #else // EXTRUDERS > 1
-      MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999);
-      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999);
-      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
       #if EXTRUDERS > 2
-        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999);
+        MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
         #if EXTRUDERS > 3
-          MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999);
+          MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
           #if EXTRUDERS > 4
-            MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999);
+            MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
           #endif // EXTRUDERS > 4
         #endif // EXTRUDERS > 3
       #endif // EXTRUDERS > 2
     #endif // EXTRUDERS > 1
 
     //
     // Babystep X:
     // Babystep Y:
     // Babystep Z:
     //

commit f34c3597dcaef54624c82f732f13151215bbe650
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Wed Nov 8 22:10:08 2017 -0600

    Add delta_height variable in lieu of using home_offset

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 510dd8bd47..f11c7a3157 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2736,32 +2736,29 @@ void kill_screen(const char* lcd_msg) {
 
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
     void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
     void _goto_center()  { _man_probe_pt(0,0); }
 
-    static float _delta_height = DELTA_HEIGHT;
     void _lcd_set_delta_height() {
-      home_offset[Z_AXIS] = _delta_height - DELTA_HEIGHT;
       update_software_endstops(Z_AXIS);
     }
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
       MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
-      _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10.0, delta_height + 10.0, _lcd_set_delta_height);
       MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
       MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);
       END_MENU();
     }
 

commit 82f45c3e6ad00a2f8cc60f0a1f7297958c98637f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 7 19:34:34 2017 -0600

    Patch G33 misuse of PROBE_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1c5108cc7f..510dd8bd47 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -148,20 +148,22 @@ uint16_t max_display_update_time = 0;
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
   #if HAS_POWER_SWITCH
     extern bool powersupply_on;
   #endif
 
+  float move_menu_scale;
+
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
   void lcd_prepare_menu();
   void lcd_move_menu();
   void lcd_control_menu();
   void lcd_control_temperature_menu();
@@ -2672,72 +2674,77 @@ void kill_screen(const char* lcd_msg) {
     //
     // Delta Calibration
     //
     #if ENABLED(DELTA_CALIBRATION_MENU)
       MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
     #endif
 
     END_MENU();
   }
 
-  float move_menu_scale;
-
-  #if ENABLED(DELTA_CALIBRATION_MENU)
+  #if ENABLED(DELTA_CALIBRATION_MENU) || (ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE)
 
     void lcd_move_z();
-    void lcd_delta_calibrate_menu();
-
-    void _lcd_calibrate_homing() {
-      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-        lcd_goto_previous_menu();
-    }
-
-    void _lcd_delta_calibrate_home() {
-      #if HAS_LEVELING
-        reset_bed_level(); // After calibration bed-level data is no longer valid
-      #endif
-
-      enqueue_and_echo_commands_P(PSTR("G28"));
-      lcd_goto_screen(_lcd_calibrate_homing);
-    }
 
     void _man_probe_pt(const float &rx, const float &ry) {
       #if HAS_LEVELING
         reset_bed_level(); // After calibration bed-level data is no longer valid
       #endif
 
       float z_dest = (Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5;
       line_to_z(z_dest);
       current_position[X_AXIS] = rx;
       current_position[Y_AXIS] = ry;
       line_to_current_z();
       z_dest = Z_CLEARANCE_BETWEEN_PROBES;
       line_to_z(z_dest);
 
       lcd_synchronize();
       move_menu_scale = PROBE_MANUALLY_STEP;
       lcd_goto_screen(lcd_move_z);
     }
 
+  #endif // DELTA_CALIBRATION_MENU || (DELTA_AUTO_CALIBRATION && !HAS_BED_PROBE)
+
+  #if ENABLED(DELTA_AUTO_CALIBRATION) && !HAS_BED_PROBE
+
     float lcd_probe_pt(const float &rx, const float &ry) {
       _man_probe_pt(rx, ry);
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       defer_return_to_status = true;
       wait_for_user = true;
       while (wait_for_user) idle();
       KEEPALIVE_STATE(IN_HANDLER);
       lcd_goto_previous_menu_no_defer();
       return current_position[Z_AXIS];
     }
 
+  #endif // DELTA_AUTO_CALIBRATION && !HAS_BED_PROBE
+
+  #if ENABLED(DELTA_CALIBRATION_MENU)
+
+    void _lcd_calibrate_homing() {
+      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        lcd_goto_previous_menu();
+    }
+
+    void _lcd_delta_calibrate_home() {
+      #if HAS_LEVELING
+        reset_bed_level(); // After calibration bed-level data is no longer valid
+      #endif
+
+      enqueue_and_echo_commands_P(PSTR("G28"));
+      lcd_goto_screen(_lcd_calibrate_homing);
+    }
+
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
     void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
     void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
     void _goto_center()  { _man_probe_pt(0,0); }
 
     static float _delta_height = DELTA_HEIGHT;
     void _lcd_set_delta_height() {
       home_offset[Z_AXIS] = _delta_height - DELTA_HEIGHT;
       update_software_endstops(Z_AXIS);
     }

commit 064e6fe60e2864a678eae89c0b16a202280dca88
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 7 22:26:33 2017 -0600

    Remove debugging pin toggle from LCD code

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9a3f513ed2..1c5108cc7f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4722,97 +4722,91 @@ void lcd_update() {
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if ENABLED(DOGLCD)
       #define IS_DRAWING drawing_screen
     #else
       #define IS_DRAWING false
     #endif
 
     if ((lcdDrawUpdate || IS_DRAWING) && (!bbr2 || bbr2 > max_display_update_time)) {
-      #if ENABLED(DOGLCD)
-        if (!drawing_screen)
-      #endif
-        {
-          switch (lcdDrawUpdate) {
-            case LCDVIEW_CALL_NO_REDRAW:
-              lcdDrawUpdate = LCDVIEW_NONE;
-              break;
-            case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
-            case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)
-              lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-            case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
-            case LCDVIEW_NONE:
-              break;
-          } // switch
-        }
+
+      if (!IS_DRAWING) switch (lcdDrawUpdate) {
+        case LCDVIEW_CALL_NO_REDRAW:
+          lcdDrawUpdate = LCDVIEW_NONE;
+          break;
+        case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
+        case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)
+          lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
+        case LCDVIEW_NONE:
+          break;
+      } // switch
 
       #if ENABLED(ADC_KEYPAD)
         buttons_reprapworld_keypad = 0;
       #endif
 
       #if ENABLED(ULTIPANEL)
         #define CURRENTSCREEN() (*currentScreen)(), lcd_clicked = false
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
 
-      #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display
-        if (!drawing_screen) {
-#if defined(TARGET_LPC1768)
-digitalWrite(P1_4, !digitalRead(P1_4));  //re-arm (was 77 in the old system)
-#else
-digitalWrite(29, !digitalRead(29));  //2560
-#endif           
-          u8g.firstPage();
-          drawing_screen = 1;
+      #if ENABLED(DOGLCD)
+        if (!drawing_screen) {                        // If not already drawing pages
+          u8g.firstPage();                            // Start the first page
+          drawing_screen = 1;                         // Flag as drawing pages
         }
-        lcd_setFont(FONT_MENU);
-        u8g.setColorIndex(1);
-        CURRENTSCREEN();
+        lcd_setFont(FONT_MENU);                       // Setup font for every page draw
+        u8g.setColorIndex(1);                         // And reset the color
+        CURRENTSCREEN();                              // Draw and process the current screen
+
+        // The screen handler can clear drawing_screen for an action that changes the screen.
+        // If still drawing and there's another page, update max-time and return now.
+        // The nextPage will already be set up on the next call.
         if (drawing_screen && (drawing_screen = u8g.nextPage())) {
           NOLESS(max_display_update_time, millis() - ms);
           return;
         }
       #else
         CURRENTSCREEN();
       #endif
+
+      // Keeping track of the longest time for an individual LCD update.
+      // Used to do screen throttling when the planner starts to fill up.
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
-    #if ENABLED(DOGLCD)
-      if (!drawing_screen)
-    #endif
-      {
-        switch (lcdDrawUpdate) {
-          case LCDVIEW_CLEAR_CALL_REDRAW:
-            lcd_implementation_clear();
-          case LCDVIEW_CALL_REDRAW_NEXT:
-            lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-            break;
-          case LCDVIEW_REDRAW_NOW:
-            lcdDrawUpdate = LCDVIEW_NONE;
-            break;
-          case LCDVIEW_NONE:
-            break;
-        } // switch
-      }
+    if (!IS_DRAWING) switch (lcdDrawUpdate) {
+      case LCDVIEW_CLEAR_CALL_REDRAW:
+        lcd_implementation_clear();
+      case LCDVIEW_CALL_REDRAW_NEXT:
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        break;
+      case LCDVIEW_REDRAW_NOW:
+        lcdDrawUpdate = LCDVIEW_NONE;
+        break;
+      case LCDVIEW_NONE:
+        break;
+    } // switch
+
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
 inline void pad_message_string() {
   uint8_t i = 0, j = 0;
   char c;
   while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
     if (PRINTABLE(c)) j++;
     i++;
   }

commit 0483a7df913f949ab6c61261356a5cfbe5f0e276
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Thu Nov 2 20:57:08 2017 -0500

    AVR RRD works
    
    LPC1768 VIKI2 & RRDFG are working
    
    looks like all SPIs are working
    
    library change
    
    sh1106 locks up
    
    fixed lockup, started I2C SW com
    
    pretty
    
    re-org
    
    restore a few files
    
    make library happy
    
    switched HAL version of rrd
    
    fix travis error
    
    travis error fixes
    
    another travis fix
    
    cleanup
    
    minor update
    
    one more
    
    correct spacing in platformio.ini

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 043380def3..9a3f513ed2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4751,20 +4751,25 @@ void lcd_update() {
       #endif
 
       #if ENABLED(ULTIPANEL)
         #define CURRENTSCREEN() (*currentScreen)(), lcd_clicked = false
       #else
         #define CURRENTSCREEN() lcd_status_screen()
       #endif
 
       #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display
         if (!drawing_screen) {
+#if defined(TARGET_LPC1768)
+digitalWrite(P1_4, !digitalRead(P1_4));  //re-arm (was 77 in the old system)
+#else
+digitalWrite(29, !digitalRead(29));  //2560
+#endif           
           u8g.firstPage();
           drawing_screen = 1;
         }
         lcd_setFont(FONT_MENU);
         u8g.setColorIndex(1);
         CURRENTSCREEN();
         if (drawing_screen && (drawing_screen = u8g.nextPage())) {
           NOLESS(max_display_update_time, millis() - ms);
           return;
         }

commit ca7d36d9ed3667c91fa97a9b8ab53a4625ba66ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 21:22:53 2017 -0500

    RAMPS pins for ANET_KEYPAD_LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d5e058489e..043380def3 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4442,28 +4442,27 @@ void kill_screen(const char* lcd_msg) {
 
 void lcd_init() {
 
   lcd_implementation_init(
     #if ENABLED(LCD_PROGRESS_BAR)
       true
     #endif
   );
 
   #if ENABLED(NEWPANEL)
+
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
-
     #if BUTTON_EXISTS(EN2)
       SET_INPUT_PULLUP(BTN_EN2);
     #endif
-
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
     #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
       SET_OUTPUT(SHIFT_CLK);
       OUT_WRITE(SHIFT_LD, HIGH);
       SET_INPUT_PULLUP(SHIFT_OUT);
     #endif
 

commit 4df024d7b95c0adef4321ab462f9f15e7037f091
Merge: 601ccded89 f8393a0908
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 4 14:31:44 2017 -0500

    Merge pull request #8234 from thinkyhead/bf2_native_operation
    
    [2.0.x] Operate in Native Machine Space

diff --combined Marlin/src/lcd/ultralcd.cpp
index b36dc758e7,6847560105..d5e058489e
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -708,21 -708,28 +708,21 @@@ void lcd_status_screen() 
  void lcd_reset_status() { lcd_setstatusPGM(PSTR(""), -1); }
  
  /**
   *
   * draw the kill screen
   *
   */
  void kill_screen(const char* lcd_msg) {
    lcd_init();
    lcd_setalertstatusPGM(lcd_msg);
 -  #if ENABLED(DOGLCD)
 -    u8g.firstPage();
 -    do {
 -      lcd_kill_screen();
 -    } while (u8g.nextPage());
 -  #else
 -    lcd_kill_screen();
 -  #endif
 +  lcd_kill_screen();
  }
  
  #if ENABLED(ULTIPANEL)
  
    /**
     *
     * Audio feedback for controller clicks
     *
     */
    void lcd_buzz(const long duration, const uint16_t freq) {
@@@ -1665,38 -1672,38 +1665,38 @@@
    #endif
  
  
    #if ENABLED(LEVEL_BED_CORNERS)
  
      /**
       * Level corners, starting in the front-left corner.
       */
      static int8_t bed_corner;
      void _lcd_goto_next_corner() {
-       line_to_z(LOGICAL_Z_POSITION(4.0));
+       line_to_z(4.0);
        switch (bed_corner) {
          case 0:
            current_position[X_AXIS] = X_MIN_BED + 10;
            current_position[Y_AXIS] = Y_MIN_BED + 10;
            break;
          case 1:
            current_position[X_AXIS] = X_MAX_BED - 10;
            break;
          case 2:
            current_position[Y_AXIS] = Y_MAX_BED - 10;
            break;
          case 3:
            current_position[X_AXIS] = X_MIN_BED + 10;
            break;
        }
        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
-       line_to_z(LOGICAL_Z_POSITION(0.0));
+       line_to_z(0.0);
        if (++bed_corner > 3) bed_corner = 0;
      }
  
      void _lcd_corner_submenu() {
        START_MENU();
        MENU_ITEM(function, MSG_NEXT_CORNER, _lcd_goto_next_corner);
        MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
        END_MENU();
      }
  
@@@ -1728,42 -1735,42 +1728,42 @@@
        #endif
      );
  
      //
      // Raise Z to the "manual probe height"
      // Don't return until done.
      // ** This blocks the command queue! **
      //
      void _lcd_after_probing() {
        #if MANUAL_PROBE_HEIGHT > 0
-         line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+         line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
        #endif
        // Display "Done" screen and wait for moves to complete
        #if MANUAL_PROBE_HEIGHT > 0 || ENABLED(MESH_BED_LEVELING)
          lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
        #endif
        lcd_goto_previous_menu();
        lcd_completion_feedback();
        defer_return_to_status = false;
        //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
      }
  
      #if ENABLED(MESH_BED_LEVELING)
  
        // Utility to go to the next mesh point
-       inline void _manual_probe_goto_xy(float x, float y) {
+       inline void _manual_probe_goto_xy(const float &rx, const float &ry) {
          #if MANUAL_PROBE_HEIGHT > 0
            const float prev_z = current_position[Z_AXIS];
-           line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+           line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
          #endif
-         current_position[X_AXIS] = LOGICAL_X_POSITION(x);
-         current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
+         current_position[X_AXIS] = rx;
+         current_position[Y_AXIS] = ry;
          planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
          #if MANUAL_PROBE_HEIGHT > 0
            line_to_z(prev_z);
          #endif
          lcd_synchronize();
        }
  
      #elif ENABLED(PROBE_MANUALLY)
  
        bool lcd_wait_for_move;
@@@ -1879,24 -1886,21 +1879,21 @@@
  
        // Set the menu to display ahead of blocking call
        lcd_goto_screen(_lcd_level_bed_moving);
  
        #if ENABLED(MESH_BED_LEVELING)
  
          int8_t px, py;
          mbl.zigzag(manual_probe_index, px, py);
  
          // Controls the loop until the move is done
-         _manual_probe_goto_xy(
-           LOGICAL_X_POSITION(mbl.index_to_xpos[px]),
-           LOGICAL_Y_POSITION(mbl.index_to_ypos[py])
-         );
+         _manual_probe_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
  
          // After the blocking function returns, change menus
          lcd_goto_screen(_lcd_level_bed_get_z);
  
        #elif ENABLED(PROBE_MANUALLY)
  
          // G29 Records Z, moves, and signals when it pauses
          lcd_wait_for_move = true;
          enqueue_and_echo_commands_P(PSTR("G29 V1"));
  
@@@ -2363,22 -2367,22 +2360,22 @@@
        dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
        dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
        snprintf_P(ubl_lcd_gcode, sizeof(ubl_lcd_gcode), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
        enqueue_and_echo_command(ubl_lcd_gcode);
      }
  
      /**
       * UBL LCD Map Movement
       */
      void ubl_map_move_to_xy() {
-       current_position[X_AXIS] = LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]));
-       current_position[Y_AXIS] = LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]));
+       current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
+       current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
      }
  
      /**
       * UBL LCD "radar" map
       */
      void set_current_from_steppers_for_axis(const AxisEnum axis);
      void sync_plan_position();
  
      void _lcd_ubl_output_map_lcd() {
@@@ -2698,40 -2702,40 +2695,40 @@@
  
      void _lcd_delta_calibrate_home() {
        #if HAS_LEVELING
          reset_bed_level(); // After calibration bed-level data is no longer valid
        #endif
  
        enqueue_and_echo_commands_P(PSTR("G28"));
        lcd_goto_screen(_lcd_calibrate_homing);
      }
  
-     void _man_probe_pt(const float &lx, const float &ly) {
+     void _man_probe_pt(const float &rx, const float &ry) {
        #if HAS_LEVELING
          reset_bed_level(); // After calibration bed-level data is no longer valid
        #endif
  
-       float z_dest = LOGICAL_Z_POSITION((Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5);
+       float z_dest = (Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5;
        line_to_z(z_dest);
-       current_position[X_AXIS] = LOGICAL_X_POSITION(lx);
-       current_position[Y_AXIS] = LOGICAL_Y_POSITION(ly);
+       current_position[X_AXIS] = rx;
+       current_position[Y_AXIS] = ry;
        line_to_current_z();
-       z_dest = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
+       z_dest = Z_CLEARANCE_BETWEEN_PROBES;
        line_to_z(z_dest);
  
        lcd_synchronize();
        move_menu_scale = PROBE_MANUALLY_STEP;
        lcd_goto_screen(lcd_move_z);
      }
  
-     float lcd_probe_pt(const float &lx, const float &ly) {
-       _man_probe_pt(lx, ly);
+     float lcd_probe_pt(const float &rx, const float &ry) {
+       _man_probe_pt(rx, ry);
        KEEPALIVE_STATE(PAUSED_FOR_USER);
        defer_return_to_status = true;
        wait_for_user = true;
        while (wait_for_user) idle();
        KEEPALIVE_STATE(IN_HANDLER);
        lcd_goto_previous_menu_no_defer();
        return current_position[Z_AXIS];
      }
  
      void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
@@@ -4315,43 -4319,45 +4312,43 @@@
    DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
  
    /**
     *
     * Handlers for Keypad input
     *
     */
    #if ENABLED(ADC_KEYPAD)
  
      inline bool handle_adc_keypad() {
 -      static uint8_t adc_steps = 0;
 +      #define ADC_MIN_KEY_DELAY 100
        if (buttons_reprapworld_keypad) {
 -        if (adc_steps < 20) ++adc_steps;
 -        lcd_quick_feedback();
          lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
          if (encoderDirection == -1) { // side effect which signals we are inside a menu
            if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
 -          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  menu_action_back();
 -          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) lcd_return_to_status();
 +          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(); }
 +          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(); }
          }
          else {
 -          const int8_t step = adc_steps > 19 ? 100 : adc_steps > 10 ? 10 : 1;
 -               if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP * step;
 -          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP * step;
 -          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
 +          if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
 +                 if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
 +            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
 +            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
 +          }
          }
          #if ENABLED(ADC_KEYPAD_DEBUG)
            SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
            SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
          #endif
 +        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
          return true;
        }
 -      else if (!thermalManager.current_ADCKey_raw)
 -        adc_steps = 0; // reset stepping acceleration
  
        return false;
      }
  
    #elif ENABLED(REPRAPWORLD_KEYPAD)
  
      void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
        move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
        encoderPosition = dir;
        switch (axis) {

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 314080d79b..6847560105 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1672,38 +1672,38 @@ void kill_screen(const char* lcd_msg) {
   #endif
 
 
   #if ENABLED(LEVEL_BED_CORNERS)
 
     /**
      * Level corners, starting in the front-left corner.
      */
     static int8_t bed_corner;
     void _lcd_goto_next_corner() {
-      line_to_z(LOGICAL_Z_POSITION(4.0));
+      line_to_z(4.0);
       switch (bed_corner) {
         case 0:
           current_position[X_AXIS] = X_MIN_BED + 10;
           current_position[Y_AXIS] = Y_MIN_BED + 10;
           break;
         case 1:
           current_position[X_AXIS] = X_MAX_BED - 10;
           break;
         case 2:
           current_position[Y_AXIS] = Y_MAX_BED - 10;
           break;
         case 3:
           current_position[X_AXIS] = X_MIN_BED + 10;
           break;
       }
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
-      line_to_z(LOGICAL_Z_POSITION(0.0));
+      line_to_z(0.0);
       if (++bed_corner > 3) bed_corner = 0;
     }
 
     void _lcd_corner_submenu() {
       START_MENU();
       MENU_ITEM(function, MSG_NEXT_CORNER, _lcd_goto_next_corner);
       MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
       END_MENU();
     }
 
@@ -1735,42 +1735,42 @@ void kill_screen(const char* lcd_msg) {
       #endif
     );
 
     //
     // Raise Z to the "manual probe height"
     // Don't return until done.
     // ** This blocks the command queue! **
     //
     void _lcd_after_probing() {
       #if MANUAL_PROBE_HEIGHT > 0
-        line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+        line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
       #endif
       // Display "Done" screen and wait for moves to complete
       #if MANUAL_PROBE_HEIGHT > 0 || ENABLED(MESH_BED_LEVELING)
         lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
       #endif
       lcd_goto_previous_menu();
       lcd_completion_feedback();
       defer_return_to_status = false;
       //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
     }
 
     #if ENABLED(MESH_BED_LEVELING)
 
       // Utility to go to the next mesh point
-      inline void _manual_probe_goto_xy(float x, float y) {
+      inline void _manual_probe_goto_xy(const float &rx, const float &ry) {
         #if MANUAL_PROBE_HEIGHT > 0
           const float prev_z = current_position[Z_AXIS];
-          line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+          line_to_z(Z_MIN_POS + MANUAL_PROBE_HEIGHT);
         #endif
-        current_position[X_AXIS] = LOGICAL_X_POSITION(x);
-        current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
+        current_position[X_AXIS] = rx;
+        current_position[Y_AXIS] = ry;
         planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
         #if MANUAL_PROBE_HEIGHT > 0
           line_to_z(prev_z);
         #endif
         lcd_synchronize();
       }
 
     #elif ENABLED(PROBE_MANUALLY)
 
       bool lcd_wait_for_move;
@@ -1886,24 +1886,21 @@ void kill_screen(const char* lcd_msg) {
 
       // Set the menu to display ahead of blocking call
       lcd_goto_screen(_lcd_level_bed_moving);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         int8_t px, py;
         mbl.zigzag(manual_probe_index, px, py);
 
         // Controls the loop until the move is done
-        _manual_probe_goto_xy(
-          LOGICAL_X_POSITION(mbl.index_to_xpos[px]),
-          LOGICAL_Y_POSITION(mbl.index_to_ypos[py])
-        );
+        _manual_probe_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
 
         // After the blocking function returns, change menus
         lcd_goto_screen(_lcd_level_bed_get_z);
 
       #elif ENABLED(PROBE_MANUALLY)
 
         // G29 Records Z, moves, and signals when it pauses
         lcd_wait_for_move = true;
         enqueue_and_echo_commands_P(PSTR("G29 V1"));
 
@@ -2370,22 +2367,22 @@ void kill_screen(const char* lcd_msg) {
       dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
       dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
       snprintf_P(ubl_lcd_gcode, sizeof(ubl_lcd_gcode), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
       enqueue_and_echo_command(ubl_lcd_gcode);
     }
 
     /**
      * UBL LCD Map Movement
      */
     void ubl_map_move_to_xy() {
-      current_position[X_AXIS] = LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]));
-      current_position[Y_AXIS] = LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]));
+      current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
+      current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
     }
 
     /**
      * UBL LCD "radar" map
      */
     void set_current_from_steppers_for_axis(const AxisEnum axis);
     void sync_plan_position();
 
     void _lcd_ubl_output_map_lcd() {
@@ -2705,40 +2702,40 @@ void kill_screen(const char* lcd_msg) {
 
     void _lcd_delta_calibrate_home() {
       #if HAS_LEVELING
         reset_bed_level(); // After calibration bed-level data is no longer valid
       #endif
 
       enqueue_and_echo_commands_P(PSTR("G28"));
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
-    void _man_probe_pt(const float &lx, const float &ly) {
+    void _man_probe_pt(const float &rx, const float &ry) {
       #if HAS_LEVELING
         reset_bed_level(); // After calibration bed-level data is no longer valid
       #endif
 
-      float z_dest = LOGICAL_Z_POSITION((Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5);
+      float z_dest = (Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5;
       line_to_z(z_dest);
-      current_position[X_AXIS] = LOGICAL_X_POSITION(lx);
-      current_position[Y_AXIS] = LOGICAL_Y_POSITION(ly);
+      current_position[X_AXIS] = rx;
+      current_position[Y_AXIS] = ry;
       line_to_current_z();
-      z_dest = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
+      z_dest = Z_CLEARANCE_BETWEEN_PROBES;
       line_to_z(z_dest);
 
       lcd_synchronize();
       move_menu_scale = PROBE_MANUALLY_STEP;
       lcd_goto_screen(lcd_move_z);
     }
 
-    float lcd_probe_pt(const float &lx, const float &ly) {
-      _man_probe_pt(lx, ly);
+    float lcd_probe_pt(const float &rx, const float &ry) {
+      _man_probe_pt(rx, ry);
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       defer_return_to_status = true;
       wait_for_user = true;
       while (wait_for_user) idle();
       KEEPALIVE_STATE(IN_HANDLER);
       lcd_goto_previous_menu_no_defer();
       return current_position[Z_AXIS];
     }
 
     void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }

commit ca0e4b4e963d6f198beab5646bf95721f8a2414b
Author: AnHardt <github@kitelab.de>
Date:   Fri Nov 3 11:58:20 2017 +0100

    Some cleanup around 'lcd_bootscreen()' and 'lcd_kill_screen()'
    
    Move 'lcd_bootscreen()' from `lcd_init()` to 'setup()' where it is cexecute exactly once. Saves 'bool show_bootscreen'.
    Move the call of 'lcd_custom_bootscreen()' to the begin of 'lcd_bootscreen()'.
    Move the delays into the related functions.
    Move the picture loop around 'lcd_kill_screen()' into the function.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 630bb5288d..b36dc758e7 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -708,28 +708,21 @@ void lcd_status_screen() {
 void lcd_reset_status() { lcd_setstatusPGM(PSTR(""), -1); }
 
 /**
  *
  * draw the kill screen
  *
  */
 void kill_screen(const char* lcd_msg) {
   lcd_init();
   lcd_setalertstatusPGM(lcd_msg);
-  #if ENABLED(DOGLCD)
-    u8g.firstPage();
-    do {
-      lcd_kill_screen();
-    } while (u8g.nextPage());
-  #else
-    lcd_kill_screen();
-  #endif
+  lcd_kill_screen();
 }
 
 #if ENABLED(ULTIPANEL)
 
   /**
    *
    * Audio feedback for controller clicks
    *
    */
   void lcd_buzz(const long duration, const uint16_t freq) {

commit e5ae5456474a3de5a7bdf1f2427b50dd3e04aa16
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 3 03:41:55 2017 -0500

    Remove ADCKey steps acceleration

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fb3288e4dc..630bb5288d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4323,47 +4323,42 @@ void kill_screen(const char* lcd_msg) {
 
   /**
    *
    * Handlers for Keypad input
    *
    */
   #if ENABLED(ADC_KEYPAD)
 
     inline bool handle_adc_keypad() {
       #define ADC_MIN_KEY_DELAY 100
-      static uint8_t adc_steps = 0;
       if (buttons_reprapworld_keypad) {
-        if (adc_steps < 20) ++adc_steps;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         if (encoderDirection == -1) { // side effect which signals we are inside a menu
           if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
           else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
           else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(); }
           else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(); }
         }
         else {
           if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
-            const int8_t step = adc_steps > 19 ? 100 : adc_steps > 10 ? 10 : 1;
-                 if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP * step;
-            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP * step;
+                 if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP;
+            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP;
             else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
           }
         }
         #if ENABLED(ADC_KEYPAD_DEBUG)
           SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
           SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
         #endif
         next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
-      else if (!thermalManager.current_ADCKey_raw)
-        adc_steps = 0; // reset stepping acceleration
 
       return false;
     }
 
   #elif ENABLED(REPRAPWORLD_KEYPAD)
 
     void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
       move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
       encoderPosition = dir;
       switch (axis) {

commit 03e5369411074d093a89a1d2236d173c349644c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 30 18:36:06 2017 -0500

    Faster menu navigation for Anet A8
    
    Addressing #8166

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 314080d79b..fb3288e4dc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -4322,41 +4322,44 @@ void kill_screen(const char* lcd_msg) {
   DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
 
   /**
    *
    * Handlers for Keypad input
    *
    */
   #if ENABLED(ADC_KEYPAD)
 
     inline bool handle_adc_keypad() {
+      #define ADC_MIN_KEY_DELAY 100
       static uint8_t adc_steps = 0;
       if (buttons_reprapworld_keypad) {
         if (adc_steps < 20) ++adc_steps;
-        lcd_quick_feedback();
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         if (encoderDirection == -1) { // side effect which signals we are inside a menu
           if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
           else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  menu_action_back();
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) lcd_return_to_status();
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  { menu_action_back(); lcd_quick_feedback(); }
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) { lcd_return_to_status(); lcd_quick_feedback(); }
         }
         else {
-          const int8_t step = adc_steps > 19 ? 100 : adc_steps > 10 ? 10 : 1;
-               if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP * step;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP * step;
-          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
+          if (buttons_reprapworld_keypad & (EN_REPRAPWORLD_KEYPAD_DOWN|EN_REPRAPWORLD_KEYPAD_UP|EN_REPRAPWORLD_KEYPAD_RIGHT)) {
+            const int8_t step = adc_steps > 19 ? 100 : adc_steps > 10 ? 10 : 1;
+                 if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP * step;
+            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP * step;
+            else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
+          }
         }
         #if ENABLED(ADC_KEYPAD_DEBUG)
           SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
           SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
         #endif
+        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
         return true;
       }
       else if (!thermalManager.current_ADCKey_raw)
         adc_steps = 0; // reset stepping acceleration
 
       return false;
     }
 
   #elif ENABLED(REPRAPWORLD_KEYPAD)
 

commit 2cdde0833946ee3b04c08cf2f83f2453f4fda0a1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 30 14:34:11 2017 -0500

    Apply items specified in code review
    
    Followup to #8122

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1bac1ac792..314080d79b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3768,23 +3768,22 @@ void kill_screen(const char* lcd_msg) {
 
         #if ENABLED(DOGLCD)
           lcd_update();
         #endif
       }
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
 
-      const uint16_t fileCnt = card.get_num_Files();  // Only access SD card if sort not active
-                                                      // This minimizes garbage on RepRap Discount Full Graphics Smart Controller
-                                                      // when using the Re-ARM card.
+      const uint16_t fileCnt = card.get_num_Files();
+
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
         MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);

commit b7a66742ddbcbc2e6090dc28997f1e843d9052ac
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Oct 27 13:42:19 2017 -0500

    tested
    
    add sort alpha section to other LPC1768 boards

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f824e1bd2b..1bac1ac792 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3768,21 +3768,23 @@ void kill_screen(const char* lcd_msg) {
 
         #if ENABLED(DOGLCD)
           lcd_update();
         #endif
       }
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
 
-      const uint16_t fileCnt = card.getnrfilenames();
+      const uint16_t fileCnt = card.get_num_Files();  // Only access SD card if sort not active
+                                                      // This minimizes garbage on RepRap Discount Full Graphics Smart Controller
+                                                      // when using the Re-ARM card.
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
         MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);

commit 12458cefc4230129878f2f733a87ba68371c1459
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 19:44:49 2017 -0500

    Remove 5s timer hack. Encoder pos is saved on print start!

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 44290b1d4a..f824e1bd2b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3768,30 +3768,20 @@ void kill_screen(const char* lcd_msg) {
 
         #if ENABLED(DOGLCD)
           lcd_update();
         #endif
       }
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
 
-      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-        static millis_t assume_print_finished = 0;
-        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not
-          lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
-          encoderPosition = last_sdfile_encoderPosition;      // encoderPosition to the last selected item.
-          assume_print_finished = millis() + 5000;
-        }
-        last_sdfile_encoderPosition = encoderPosition;   // needed as a workaround for the 5s timer
-      #endif
-
       const uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
@@ -4737,32 +4727,27 @@ void lcd_update() {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
-    if (
-      #if ENABLED(DOGLCD)
-        (lcdDrawUpdate || drawing_screen) && (
-          !bbr2 || (bbr2 > max_display_update_time)
-          #if ENABLED(SDSUPPORT)
-            || currentScreen == lcd_sdcard_menu
-          #endif
-        )
-      #else
-        lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time))
-      #endif
-    ) {
+    #if ENABLED(DOGLCD)
+      #define IS_DRAWING drawing_screen
+    #else
+      #define IS_DRAWING false
+    #endif
+
+    if ((lcdDrawUpdate || IS_DRAWING) && (!bbr2 || bbr2 > max_display_update_time)) {
       #if ENABLED(DOGLCD)
         if (!drawing_screen)
       #endif
         {
           switch (lcdDrawUpdate) {
             case LCDVIEW_CALL_NO_REDRAW:
               lcdDrawUpdate = LCDVIEW_NONE;
               break;
             case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
             case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)

commit 9a4cf1183539dd35cb457472ec9e72a4b2b7c121
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 19:37:40 2017 -0500

    Remove return_to_status_ms hack, just use defer...

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4443006147..44290b1d4a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3776,21 +3776,20 @@ void kill_screen(const char* lcd_msg) {
       ENCODER_DIRECTION_MENUS();
 
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
         static millis_t assume_print_finished = 0;
         if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
           encoderPosition = last_sdfile_encoderPosition;      // encoderPosition to the last selected item.
           assume_print_finished = millis() + 5000;
         }
         last_sdfile_encoderPosition = encoderPosition;   // needed as a workaround for the 5s timer
-        //defer_return_to_status = true;           // already done in lcd_reselect_last_file
       #endif
 
       const uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
@@ -4799,26 +4798,21 @@ void lcd_update() {
       #else
         CURRENTSCREEN();
       #endif
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
-        #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-          if (currentScreen != lcd_sdcard_menu)                // lcd_sdcard_menu() does not time out if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for
-        #else                                                  // a re-print.
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
-        #endif
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
     #if ENABLED(DOGLCD)
       if (!drawing_screen)
     #endif
       {
         switch (lcdDrawUpdate) {

commit 8949c8c0a529038eceb0a3a177b77d223c043ec6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 26 23:39:51 2017 -0500

    Move SD_REPRINT_LAST_SELECTED_FILE to ultralcd.cpp

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a44b26ae56..4443006147 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3738,36 +3738,59 @@ void kill_screen(const char* lcd_msg) {
       encoderTopLine = 0;
       screen_changed = true;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
     /**
      *
      * "Print from SD" submenu
      *
      */
+
     #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-      uint32_t saved_encoderPosition = 0;
-      static millis_t assume_print_finished = 0;
+      uint32_t last_sdfile_encoderPosition = 0xFFFF;
+
+      void lcd_reselect_last_file() {
+        if (last_sdfile_encoderPosition == 0xFFFF) return;
+        #if ENABLED(DOGLCD)
+          // Some of this is a hack to force the screen update to work.
+          // TODO: Fix the real issue that causes this!
+          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+          _lcd_synchronize();
+          safe_delay(50);
+          _lcd_synchronize();
+          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+          drawing_screen = screen_changed = true;
+        #endif
+
+        lcd_goto_screen(lcd_sdcard_menu, last_sdfile_encoderPosition);
+        defer_return_to_status = true;
+        last_sdfile_encoderPosition == 0xFFFF;
+
+        #if ENABLED(DOGLCD)
+          lcd_update();
+        #endif
+      }
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
 
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+        static millis_t assume_print_finished = 0;
         if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
-          encoderPosition = saved_encoderPosition;      // encoderPosition to the last selected item.
+          encoderPosition = last_sdfile_encoderPosition;      // encoderPosition to the last selected item.
           assume_print_finished = millis() + 5000;
         }
-        saved_encoderPosition = encoderPosition;
-        defer_return_to_status = true;
+        last_sdfile_encoderPosition = encoderPosition;   // needed as a workaround for the 5s timer
+        //defer_return_to_status = true;           // already done in lcd_reselect_last_file
       #endif
 
       const uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
@@ -4407,21 +4430,21 @@ void kill_screen(const char* lcd_msg) {
    */
   void _menu_action_back() { lcd_goto_previous_menu(); }
   void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
   void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
   void menu_action_function(screenFunc_t func) { (*func)(); }
 
   #if ENABLED(SDSUPPORT)
 
     void menu_action_sdfile(const char* filename, char* longFilename) {
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-        saved_encoderPosition = encoderPosition;  // Save which file was selected for later use
+        last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
       #endif
       UNUSED(longFilename);
       card.openAndPrintFile(filename);
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderPosition = 0;
@@ -4715,30 +4738,32 @@ void lcd_update() {
         lcd_status_update_delay = 6;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
-    #if ENABLED(DOGLCD)
-      if ((lcdDrawUpdate || drawing_screen) && (!bbr2 || (bbr2 > max_display_update_time)
-      #if ENABLED(SDSUPPORT)
-        || (currentScreen == lcd_sdcard_menu)
+    if (
+      #if ENABLED(DOGLCD)
+        (lcdDrawUpdate || drawing_screen) && (
+          !bbr2 || (bbr2 > max_display_update_time)
+          #if ENABLED(SDSUPPORT)
+            || currentScreen == lcd_sdcard_menu
+          #endif
+        )
+      #else
+        lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time))
       #endif
-      ))
-    #else
-      if (lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time)))
-    #endif
-    {
+    ) {
       #if ENABLED(DOGLCD)
         if (!drawing_screen)
       #endif
         {
           switch (lcdDrawUpdate) {
             case LCDVIEW_CALL_NO_REDRAW:
               lcdDrawUpdate = LCDVIEW_NONE;
               break;
             case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
             case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)

commit b338cafc658f8ace2bc26b9668a6343df5ced82a
Merge: ada90f7335 33f379fe88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 27 02:02:06 2017 -0500

    Merge pull request #8111 from thinkyhead/bf2_fwretract_fix_oct26
    
    [2.0.x] Improved Firmware Retraction logic

diff --combined Marlin/src/lcd/ultralcd.cpp
index 51a8412a13,d9669c06a5..a44b26ae56
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -3709,20 -3709,23 +3709,23 @@@ void kill_screen(const char* lcd_msg) 
        #if EXTRUDERS > 1
          MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
        #endif
        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
        #if EXTRUDERS > 1
          MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
        #endif
        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.retract_recover_feedrate_mm_s, 1, 999);
+       #if EXTRUDERS > 1
+         MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.swap_retract_recover_feedrate_mm_s, 1, 999);
+       #endif
        END_MENU();
      }
  
    #endif // FWRETRACT
  
    #if ENABLED(SDSUPPORT)
  
      #if !PIN_EXISTS(SD_DETECT)
        void lcd_sd_refresh() {
          card.initsd();
@@@ -3742,31 -3745,31 +3745,31 @@@
       * "Print from SD" submenu
       *
       */
      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
        uint32_t saved_encoderPosition = 0;
        static millis_t assume_print_finished = 0;
      #endif
  
      void lcd_sdcard_menu() {
        ENCODER_DIRECTION_MENUS();
 -  
 +
        #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
 -        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not 
 +        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not
            lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
            encoderPosition = saved_encoderPosition;      // encoderPosition to the last selected item.
            assume_print_finished = millis() + 5000;
          }
          saved_encoderPosition = encoderPosition;
          defer_return_to_status = true;
        #endif
 -      
 +
        const uint16_t fileCnt = card.getnrfilenames();
        START_MENU();
        MENU_BACK(MSG_MAIN);
        card.getWorkDirName();
        if (card.filename[0] == '/') {
          #if !PIN_EXISTS(SD_DETECT)
            MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
          #endif
        }
        else {
@@@ -4773,21 -4776,21 +4776,21 @@@ void lcd_update() 
        #endif
        NOLESS(max_display_update_time, millis() - ms);
      }
  
      #if ENABLED(ULTIPANEL)
  
        // Return to Status Screen after a timeout
        if (currentScreen == lcd_status_screen || defer_return_to_status)
          #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
            if (currentScreen != lcd_sdcard_menu)                // lcd_sdcard_menu() does not time out if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
 -            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for 
 +            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for
          #else                                                  // a re-print.
          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
          #endif
        else if (ELAPSED(ms, return_to_status_ms))
          lcd_return_to_status();
  
      #endif // ULTIPANEL
  
      #if ENABLED(DOGLCD)
        if (!drawing_screen)

commit ada90f7335305d1086a4e35b9f28cb6eceb10934
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 26 23:33:43 2017 -0500

    Clean up trailing spaces

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ca036563a0..51a8412a13 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3742,31 +3742,31 @@ void kill_screen(const char* lcd_msg) {
      * "Print from SD" submenu
      *
      */
     #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
       uint32_t saved_encoderPosition = 0;
       static millis_t assume_print_finished = 0;
     #endif
 
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
-  
+
       #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not 
+        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not
           lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
           encoderPosition = saved_encoderPosition;      // encoderPosition to the last selected item.
           assume_print_finished = millis() + 5000;
         }
         saved_encoderPosition = encoderPosition;
         defer_return_to_status = true;
       #endif
-      
+
       const uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
@@ -4773,21 +4773,21 @@ void lcd_update() {
       #endif
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
         #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
           if (currentScreen != lcd_sdcard_menu)                // lcd_sdcard_menu() does not time out if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for 
+            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for
         #else                                                  // a re-print.
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         #endif
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
     #if ENABLED(DOGLCD)
       if (!drawing_screen)

commit eb02f8c71921b09d9f1044f43c1e57e588d9fe7c
Author: studiodyne <diabolomix@hotmail.fr>
Date:   Thu Oct 26 23:33:19 2017 +0200

    Improve FWRETRACT logic, add common sense

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ca036563a0..d9669c06a5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3709,20 +3709,23 @@ void kill_screen(const char* lcd_msg) {
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.retract_recover_feedrate_mm_s, 1, 999);
+      #if EXTRUDERS > 1
+        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.swap_retract_recover_feedrate_mm_s, 1, 999);
+      #endif
       END_MENU();
     }
 
   #endif // FWRETRACT
 
   #if ENABLED(SDSUPPORT)
 
     #if !PIN_EXISTS(SD_DETECT)
       void lcd_sd_refresh() {
         card.initsd();

commit 3f5f39576be4198ca68f770dea747f2dd639b3d9
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Oct 26 15:50:18 2017 -0500

    Reprint option for last SD Memory card file (#8106)
    
    * Re-Print of same SD Memory Card file with single click
    
    * Re-Print of same SD Memory Card file with single click
    * This is the bugfix-v2.0.0 version of  https://github.com/MarlinFirmware/Marlin/pull/8104

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 37c6a61eca..ca036563a0 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3735,24 +3735,39 @@ void kill_screen(const char* lcd_msg) {
       encoderTopLine = 0;
       screen_changed = true;
       lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
     }
 
     /**
      *
      * "Print from SD" submenu
      *
      */
+    #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+      uint32_t saved_encoderPosition = 0;
+      static millis_t assume_print_finished = 0;
+    #endif
+
     void lcd_sdcard_menu() {
       ENCODER_DIRECTION_MENUS();
-      if (!lcdDrawUpdate && !lcd_clicked) return; // nothing to do (so don't thrash the SD card)
-      const uint16_t fileCnt = card.get_num_Files();
+  
+      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+        if (ELAPSED(millis(), assume_print_finished)) { // if the printer has been busy printing, lcd_sdcard_menu() should not 
+          lcdDrawUpdate = LCDVIEW_REDRAW_NOW;           // have been active for 5 seconds.  In this case, restore the previous
+          encoderPosition = saved_encoderPosition;      // encoderPosition to the last selected item.
+          assume_print_finished = millis() + 5000;
+        }
+        saved_encoderPosition = encoderPosition;
+        defer_return_to_status = true;
+      #endif
+      
+      const uint16_t fileCnt = card.getnrfilenames();
       START_MENU();
       MENU_BACK(MSG_MAIN);
       card.getWorkDirName();
       if (card.filename[0] == '/') {
         #if !PIN_EXISTS(SD_DETECT)
           MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
         #endif
       }
       else {
         MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
@@ -4388,20 +4403,23 @@ void kill_screen(const char* lcd_msg) {
    *
    */
   void _menu_action_back() { lcd_goto_previous_menu(); }
   void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
   void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
   void menu_action_function(screenFunc_t func) { (*func)(); }
 
   #if ENABLED(SDSUPPORT)
 
     void menu_action_sdfile(const char* filename, char* longFilename) {
+      #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+        saved_encoderPosition = encoderPosition;  // Save which file was selected for later use
+      #endif
       UNUSED(longFilename);
       card.openAndPrintFile(filename);
       lcd_return_to_status();
     }
 
     void menu_action_sddirectory(const char* filename, char* longFilename) {
       UNUSED(longFilename);
       card.chdir(filename);
       encoderPosition = 0;
       screen_changed = true;
@@ -4695,21 +4713,25 @@ void lcd_update() {
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         filename_scroll_pos++;
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
       }
     #endif
 
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if ENABLED(DOGLCD)
-      if ((lcdDrawUpdate || drawing_screen) && (!bbr2 || (bbr2 > max_display_update_time)))
+      if ((lcdDrawUpdate || drawing_screen) && (!bbr2 || (bbr2 > max_display_update_time)
+      #if ENABLED(SDSUPPORT)
+        || (currentScreen == lcd_sdcard_menu)
+      #endif
+      ))
     #else
       if (lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time)))
     #endif
     {
       #if ENABLED(DOGLCD)
         if (!drawing_screen)
       #endif
         {
           switch (lcdDrawUpdate) {
             case LCDVIEW_CALL_NO_REDRAW:
@@ -4749,21 +4771,26 @@ void lcd_update() {
       #else
         CURRENTSCREEN();
       #endif
       NOLESS(max_display_update_time, millis() - ms);
     }
 
     #if ENABLED(ULTIPANEL)
 
       // Return to Status Screen after a timeout
       if (currentScreen == lcd_status_screen || defer_return_to_status)
+        #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+          if (currentScreen != lcd_sdcard_menu)                // lcd_sdcard_menu() does not time out if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+            return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;  // When the printer finishes a file, it will wait with the file selected for 
+        #else                                                  // a re-print.
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        #endif
       else if (ELAPSED(ms, return_to_status_ms))
         lcd_return_to_status();
 
     #endif // ULTIPANEL
 
     #if ENABLED(DOGLCD)
       if (!drawing_screen)
     #endif
       {
         switch (lcdDrawUpdate) {

commit 6296ab2173b50200b48a4f9c5d8d6319eb5af695
Author: cdedwards <cd.edwards@sasktel.net>
Date:   Tue Oct 24 13:14:03 2017 -0600

    Add GFX overlay to UBL mesh edit (#8038)
    
    * Add GFX overlay to UBL mesh edit
    
    Fixed misplaced HAS_TEMP_BED in dogm_bitmaps.h
    
    rename _lcd_babystep_zoffset_overlay to _lcd_zoffset_overlay_gfx and move it out of BABYSTEP_ZPROBE_OFFSET to we can use it for over things. Add this function into UBL mesh edit screen.
    
    update all Configuration.h to add ENABLE_MESH_EDIT_GFX_OVERLAY
    
    * Add Sanity to UBL  insanity
    
    Need to check for DOGLCD  otherwise error out.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 42feaced47..37c6a61eca 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1050,61 +1050,61 @@ void kill_screen(const char* lcd_msg) {
         lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
     }
 
     #if ENABLED(BABYSTEP_XY)
       void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
       void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-
-      #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-
-        void _lcd_babystep_zoffset_overlay(const float in_zoffset) {
-          // Determine whether the user is raising or lowering the nozzle.
-          int8_t dir = 0;
-          static float old_zprobe_zoffset = 0;
-          if (in_zoffset != old_zprobe_zoffset) {
-            dir = (in_zoffset > old_zprobe_zoffset) ? 1 : -1;
-            old_zprobe_zoffset = in_zoffset;
-          }
+    #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY) || ENABLED(ENABLE_MESH_EDIT_GFX_OVERLAY)
+
+      void _lcd_zoffset_overlay_gfx(const float in_zoffset) {
+        // Determine whether the user is raising or lowering the nozzle.
+        int8_t dir = 0;
+        static float old_zprobe_zoffset = 0;
+        if (in_zoffset != old_zprobe_zoffset) {
+          dir = (in_zoffset > old_zprobe_zoffset) ? 1 : (in_zoffset == 0) ? 0 : -1;
+          old_zprobe_zoffset = in_zoffset;
+        }
 
-          #if ENABLED(BABYSTEP_ZPROBE_GFX_REVERSE)
-            const unsigned char *rot_up   = ccw_bmp;
-            const unsigned char *rot_down = cw_bmp;
-          #else
-            const unsigned char *rot_up   = cw_bmp;
-            const unsigned char *rot_down = ccw_bmp;
-          #endif
+        #if ENABLED(BABYSTEP_ZPROBE_GFX_REVERSE)
+          const unsigned char *rot_up   = ccw_bmp;
+          const unsigned char *rot_down = cw_bmp;
+        #else
+          const unsigned char *rot_up   = cw_bmp;
+          const unsigned char *rot_down = ccw_bmp;
+        #endif
 
-          #if ENABLED(USE_BIG_EDIT_FONT)
-            const int left = 0, right = 45, nozzle = 95;
-          #else
-            const int left = 5, right = 90, nozzle = 60;
-          #endif
+        #if ENABLED(USE_BIG_EDIT_FONT)
+          const int left = 0, right = 45, nozzle = 95;
+        #else
+          const int left = 5, right = 90, nozzle = 60;
+        #endif
 
-          // Draw a representation of the nozzle
-          if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
-          if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
+        // Draw a representation of the nozzle
+        if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
+        if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
 
-          // Draw cw/ccw indicator and up/down arrows.
-          if (PAGE_CONTAINS(47,62)) {
-            u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
-            u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
-            u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
-            u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
-          }
+        // Draw cw/ccw indicator and up/down arrows.
+        if (PAGE_CONTAINS(47,62)) {
+          u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
+          u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
+          u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
+          u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
         }
+      }
+
+    #endif // BABYSTEP_ZPROBE_GFX_OVERLAY || ENABLE_MESH_EDIT_GFX_OVERLAY
 
-      #endif // BABYSTEP_ZPROBE_GFX_OVERLAY
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
@@ -1114,21 +1114,21 @@ void kill_screen(const char* lcd_msg) {
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-            _lcd_babystep_zoffset_overlay(zprobe_zoffset);
+            _lcd_zoffset_overlay_gfx(zprobe_zoffset);
           #endif
         }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
       void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
     #endif // !BABYSTEP_ZPROBE_OFFSET
@@ -1151,20 +1151,23 @@ void kill_screen(const char* lcd_msg) {
         mesh_edit_value = mesh_edit_accumulator;
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
 
         const int32_t rounded = (int32_t)(mesh_edit_value * 1000.0);
         mesh_edit_value = float(rounded - (rounded % 5L)) / 1000.0;
       }
 
       if (lcdDrawUpdate)
         lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
+        #if ENABLED(ENABLE_MESH_EDIT_GFX_OVERLAY)
+          _lcd_zoffset_overlay_gfx(mesh_edit_value);
+        #endif
     }
 
     void _lcd_mesh_edit_NOP() {
       defer_return_to_status = true;
     }
 
     float lcd_mesh_edit() {
       lcd_goto_screen(_lcd_mesh_edit_NOP);
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       _lcd_mesh_fine_tune(PSTR("Mesh Editor"));

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index bff5142b54..42feaced47 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2803,30 +2803,30 @@ void kill_screen(const char* lcd_msg) {
 
         const float old_feedrate = feedrate_mm_s;
         feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
 
         #if EXTRUDERS > 1
           const int8_t old_extruder = active_extruder;
           active_extruder = manual_move_e_index;
         #endif
 
         // Set movement on a single axis
-        set_destination_to_current();
+        set_destination_from_current();
         destination[manual_move_axis] += manual_move_offset;
 
         // Reset for the next move
         manual_move_offset = 0.0;
         manual_move_axis = (int8_t)NO_AXIS;
 
         // Set a blocking flag so no new moves can be added until all segments are done
         processing_manual_move = true;
-        prepare_move_to_destination(); // will call set_current_to_destination
+        prepare_move_to_destination(); // will call set_current_from_destination()
         processing_manual_move = false;
 
         feedrate_mm_s = old_feedrate;
         #if EXTRUDERS > 1
           active_extruder = old_extruder;
         #endif
 
       #else
 
         planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);

commit 783ddf9691f425dc1c1bd5c4e4df4461ca717a06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 18 22:15:33 2017 -0500

    Add SCROLL_LONG_FILENAMES option

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index c1e71f7cec..bff5142b54 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -69,26 +69,30 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
 
 #if ENABLED(BABYSTEPPING)
   long babysteps_done = 0;
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     static void lcd_babystep_zoffset();
   #else
     static void lcd_babystep_z();
   #endif
 #endif
 
-uint8_t lcd_status_message_level;
+uint8_t lcd_status_update_delay = 1, // First update one loop delayed
+        lcd_status_message_level;    // Higher level overrides lower
 char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   uint8_t status_scroll_pos = 0;
 #endif
+#if ENABLED(SCROLL_LONG_FILENAMES)
+  uint8_t filename_scroll_pos, filename_scroll_max, filename_scroll_hash;
+#endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   uint8_t progress_bar_percent;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
   #include <U8glib.h>
 #else
   #include "ultralcd_impl_HD44780.h"
@@ -4658,36 +4662,46 @@ void lcd_update() {
           encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
           encoderDiff = 0;
         }
         return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
     #endif // ULTIPANEL
 
     // We arrive here every ~100ms when idling often enough.
     // Instead of tracking the changes simply redraw the Info Screen ~1 time a second.
-    static int8_t lcd_status_update_delay = 1; // first update one loop delayed
     if (
       #if ENABLED(ULTIPANEL)
         currentScreen == lcd_status_screen &&
       #endif
       !lcd_status_update_delay--
     ) {
       lcd_status_update_delay = 9
         #if ENABLED(DOGLCD)
           + 3
         #endif
       ;
       max_display_update_time--;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
 
+    #if ENABLED(SCROLL_LONG_FILENAMES)
+      // If scrolling of long file names is enabled and we are in the sd card menu,
+      // cause a refresh to occur until all the text has scrolled into view.
+      if (currentScreen == lcd_sdcard_menu && filename_scroll_pos < filename_scroll_max && !lcd_status_update_delay--) {
+        lcd_status_update_delay = 6;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        filename_scroll_pos++;
+        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+      }
+    #endif
+
     // then we want to use 1/2 of the time only.
     uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
     #if ENABLED(DOGLCD)
       if ((lcdDrawUpdate || drawing_screen) && (!bbr2 || (bbr2 > max_display_update_time)))
     #else
       if (lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time)))
     #endif
     {
       #if ENABLED(DOGLCD)
@@ -4758,21 +4772,21 @@ void lcd_update() {
           case LCDVIEW_REDRAW_NOW:
             lcdDrawUpdate = LCDVIEW_NONE;
             break;
           case LCDVIEW_NONE:
             break;
         } // switch
       }
   } // ELAPSED(ms, next_lcd_update_ms)
 }
 
-void pad_message_string() {
+inline void pad_message_string() {
   uint8_t i = 0, j = 0;
   char c;
   while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
     if (PRINTABLE(c)) j++;
     i++;
   }
   if (true
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
       && j < LCD_WIDTH
     #endif

commit ce48403a0bd39870be32a4795e255fcc3cc917c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 16 01:41:45 2017 -0500

    Add EXTRA_FAN_SPEED feature
    
    Based on #7883 by @studiodyne

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index f9968e2798..c1e71f7cec 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1231,20 +1231,29 @@ void kill_screen(const char* lcd_msg) {
           return;
         }
       #endif
 
       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
       enqueue_and_echo_commands_P(PSTR("M600 B0"));
     }
 
   #endif // ADVANCED_PAUSE_FEATURE
 
+  // First Fan Speed title in "Tune" and "Control>Temperature" menus
+  #if FAN_COUNT > 0 && HAS_FAN0
+    #if FAN_COUNT > 1
+      #define FAN_SPEED_1_SUFFIX " 1"
+    #else
+      #define FAN_SPEED_1_SUFFIX ""
+    #endif
+  #endif
+
   /**
    *
    * "Tune" submenu
    *
    */
   void lcd_tune_menu() {
     START_MENU();
 
     //
     // ^ Main
@@ -1286,32 +1295,36 @@ void kill_screen(const char* lcd_msg) {
     //
     #if HAS_TEMP_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
-        #if FAN_COUNT > 1
-          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
-        #else
-          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fanSpeeds[0], 3, 255);
         #endif
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
       #endif
       #if HAS_FAN1
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 2", &new_fanSpeeds[1], 3, 255);
+        #endif
       #endif
       #if HAS_FAN2
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
+        #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Flow:
     // Flow [1-5]:
     //
     #if EXTRUDERS == 1
       MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999);
     #else // EXTRUDERS > 1
@@ -3298,32 +3311,36 @@ void kill_screen(const char* lcd_msg) {
     //
     #if HAS_TEMP_BED
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
     #endif
 
     //
     // Fan Speed:
     //
     #if FAN_COUNT > 0
       #if HAS_FAN0
-        #if FAN_COUNT > 1
-          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
-        #else
-          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fanSpeeds[0], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fanSpeeds[0], 3, 255);
         #endif
-        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
       #endif
       #if HAS_FAN1
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 2", &new_fanSpeeds[1], 3, 255);
+        #endif
       #endif
       #if HAS_FAN2
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+        #if ENABLED(EXTRA_FAN_SPEED)
+          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_EXTRA_FAN_SPEED " 3", &new_fanSpeeds[2], 3, 255);
+        #endif
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Autotemp, Min, Max, Fact
     //
     #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
       MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
       MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
       MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);

commit 5c4f3e010786c1a280b7a8d448426de521e369b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 15 02:15:19 2017 -0500

    Add LCD_SET_PROGRESS_MANUALLY

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index dc9921f1d1..f9968e2798 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -76,20 +76,24 @@ int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_spe
   #endif
 #endif
 
 uint8_t lcd_status_message_level;
 char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
 
 #if ENABLED(STATUS_MESSAGE_SCROLLING)
   uint8_t status_scroll_pos = 0;
 #endif
 
+#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+  uint8_t progress_bar_percent;
+#endif
+
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
   #include <U8glib.h>
 #else
   #include "ultralcd_impl_HD44780.h"
 #endif
 
 #if ENABLED(ULTIPANEL)
   #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
     inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
@@ -597,50 +601,66 @@ uint16_t max_display_update_time = 0;
  */
 
 void lcd_status_screen() {
 
   #if ENABLED(ULTIPANEL)
     ENCODER_DIRECTION_NORMAL();
     ENCODER_RATE_MULTIPLY(false);
   #endif
 
   #if ENABLED(LCD_PROGRESS_BAR)
+
+    //
+    // HD44780 implements the following message blinking and
+    // message expiration because Status Line and Progress Bar
+    // share the same line on the display.
+    //
+
+    // Set current percentage from SD when actively printing
+    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+      if (IS_SD_PRINTING)
+        progress_bar_percent = card.percentDone();
+    #endif
+
     millis_t ms = millis();
+
+    // If the message will blink rather than expire...
     #if DISABLED(PROGRESS_MSG_ONCE)
-      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME)) {
+      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
         progress_bar_ms = ms;
-      }
     #endif
+
     #if PROGRESS_MSG_EXPIRE > 0
+
       // Handle message expire
       if (expire_status_ms > 0) {
-        #if ENABLED(SDSUPPORT)
-          if (card.isFileOpen()) {
-            // Expire the message when printing is active
-            if (IS_SD_PRINTING) {
-              if (ELAPSED(ms, expire_status_ms)) {
-                lcd_status_message[0] = '\0';
-                expire_status_ms = 0;
-              }
-            }
-            else {
-              expire_status_ms += LCD_UPDATE_INTERVAL;
-            }
-          }
-          else {
+
+        #if DISABLED(LCD_SET_PROGRESS_MANUALLY)
+          const uint8_t progress_bar_percent = card.percentDone();
+        #endif
+
+        // Expire the message if a job is active and the bar has ticks
+        if (progress_bar_percent > 2 && !print_job_timer.isPaused()) {
+          if (ELAPSED(ms, expire_status_ms)) {
+            lcd_status_message[0] = '\0';
             expire_status_ms = 0;
           }
-        #else
-          expire_status_ms = 0;
-        #endif // SDSUPPORT
+        }
+        else {
+          // Defer message expiration before bar appears
+          // and during any pause (not just SD)
+          expire_status_ms += LCD_UPDATE_INTERVAL;
+        }
       }
-    #endif
+
+    #endif // PROGRESS_MSG_EXPIRE
+
   #endif // LCD_PROGRESS_BAR
 
   #if ENABLED(ULTIPANEL)
 
     if (lcd_clicked) {
       #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
         previous_lcd_status_ms = millis();  // get status message to show up for a while
       #endif
       lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
         #if ENABLED(LCD_PROGRESS_BAR)
@@ -2853,21 +2873,21 @@ void kill_screen(const char* lcd_msg) {
               max = soft_endstop_max[Y_AXIS];
             #endif
             break;
           case Z_AXIS:
             #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
               min = soft_endstop_min[Z_AXIS];
             #endif
             #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
               max = soft_endstop_max[Z_AXIS];
             #endif
-            break;
+          default: break;
         }
       #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
 
       // Delta limits XY based on the current offset from center
       // This assumes the center is 0,0
       #if ENABLED(DELTA)
         if (axis != Z_AXIS) {
           max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis]));
           min = -max;
         }

commit b206f70693c68494b15451518062e19f31a9e019
Author: Jeff Eberl <jeffeb3@gmail.com>
Date:   Sat Oct 14 06:18:09 2017 -0600

    Split the software endstop capability by axis.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 3931a8f48a..dc9921f1d1 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2827,31 +2827,49 @@ void kill_screen(const char* lcd_msg) {
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (lcd_clicked) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition && !processing_manual_move) {
       gcode.refresh_cmd_timeout();
 
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
-      #if HAS_SOFTWARE_ENDSTOPS
-        // Limit to software endstops, if enabled
-        if (soft_endstops_enabled) {
-          #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
-            min = soft_endstop_min[axis];
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-            max = soft_endstop_max[axis];
-          #endif
+      // Limit to software endstops, if enabled
+      #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
+        if (soft_endstops_enabled) switch (axis) {
+          case X_AXIS:
+            #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+              min = soft_endstop_min[X_AXIS];
+            #endif
+            #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+              max = soft_endstop_max[X_AXIS];
+            #endif
+            break;
+          case Y_AXIS:
+            #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+              min = soft_endstop_min[Y_AXIS];
+            #endif
+            #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+              max = soft_endstop_max[Y_AXIS];
+            #endif
+            break;
+          case Z_AXIS:
+            #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+              min = soft_endstop_min[Z_AXIS];
+            #endif
+            #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+              max = soft_endstop_max[Z_AXIS];
+            #endif
+            break;
         }
-      #endif
+      #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
 
       // Delta limits XY based on the current offset from center
       // This assumes the center is 0,0
       #if ENABLED(DELTA)
         if (axis != Z_AXIS) {
           max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis]));
           min = -max;
         }
       #endif
 

commit 8dd08425fd4149a102d9cc213cf1c462b83cd404
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 21:39:10 2017 -0500

    Improve LCD leveling edits

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e8aa8067c5..3931a8f48a 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1899,25 +1899,26 @@ void kill_screen(const char* lcd_msg) {
     /**
      * Step 2: Continue Bed Leveling...
      */
     void _lcd_level_bed_continue() {
       defer_return_to_status = true;
       axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
       lcd_goto_screen(_lcd_level_bed_homing);
       enqueue_and_echo_commands_P(PSTR("G28"));
     }
 
-    static bool _level_state;
-    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(_level_state); }
+    static bool new_level_state;
+    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(new_level_state); }
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      void _lcd_set_z_fade_height() { set_z_fade_height(planner.z_fade_height); }
+      static float new_z_fade_height;
+      void _lcd_set_z_fade_height() { set_z_fade_height(new_z_fade_height); }
     #endif
 
     /**
      * Step 1: Bed Level entry-point
      *
      * << Prepare
      *    Auto Home           (if homing needed)
      *    Leveling On/Off     (if data exists, and homed)
      *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
      *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
@@ -1927,27 +1928,25 @@ void kill_screen(const char* lcd_msg) {
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       else if (leveling_is_valid()) {
-        _level_state = planner.leveling_active;
-        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &_level_state, _lcd_toggle_bed_leveling);
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
       }
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        //set_z_fade_height(planner.z_fade_height);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &planner.z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &new_z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -1964,20 +1963,30 @@ void kill_screen(const char* lcd_msg) {
           MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
 
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
         MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       #endif
       END_MENU();
     }
 
+    void _lcd_goto_bed_leveling() {
+      currentScreen = lcd_bed_leveling;
+      #if ENABLED(LCD_BED_LEVELING)
+        new_level_state = planner.leveling_active;
+      #endif
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        new_z_fade_height = planner.z_fade_height;
+      #endif
+    }
+
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
     void _lcd_ubl_level_bed();
 
     static int16_t ubl_storage_slot = 0,
                custom_hotend_temp = 190,
                side_points = 3,
                ubl_fillin_amount = 5,
                ubl_height_amount = 1,
                n_edit_pts = 1,
@@ -2534,21 +2543,27 @@ void kill_screen(const char* lcd_msg) {
 
     //
     // Level Bed
     //
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
     #elif ENABLED(LCD_BED_LEVELING)
       #if ENABLED(PROBE_MANUALLY)
         if (!g29_in_progress)
       #endif
-      MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling);
+          MENU_ITEM(submenu, MSG_BED_LEVELING,
+            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+              _lcd_goto_bed_leveling
+            #else
+              lcd_bed_leveling
+            #endif
+          );
     #else
       #if PLANNER_LEVELING
         MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
       #endif
       #if ENABLED(LEVEL_BED_CORNERS)
         if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
           MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
       #endif
     #endif
 

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 5ea064803c..e8aa8067c5 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1079,21 +1079,21 @@ void kill_screen(const char* lcd_msg) {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
-            if (LEVELING_IS_ACTIVE())
+            if (planner.leveling_active)
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
@@ -1781,21 +1781,21 @@ void kill_screen(const char* lcd_msg) {
             // The last G29 will record and enable but not move.
             //
             lcd_wait_for_move = true;
             enqueue_and_echo_commands_P(PSTR("G29 V1"));
             lcd_goto_screen(_lcd_level_bed_done);
 
           #elif ENABLED(MESH_BED_LEVELING)
 
             _lcd_after_probing();
 
-            mbl.set_has_mesh(true);
+            mbl.has_mesh = true;
             mesh_probing_done();
 
           #endif
 
         }
         else {
           // MESH_BED_LEVELING: Z already stored, just move
           //    PROBE_MANUALLY: Send G29 to record Z, then move
           _lcd_level_goto_next_point();
         }
@@ -1927,26 +1927,26 @@ void kill_screen(const char* lcd_msg) {
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       else if (leveling_is_valid()) {
-        _level_state = LEVELING_IS_ACTIVE();
+        _level_state = planner.leveling_active;
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &_level_state, _lcd_toggle_bed_leveling);
       }
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        set_z_fade_height(planner.z_fade_height);
+        //set_z_fade_height(planner.z_fade_height);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &planner.z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset
       //
       #if ENABLED(MESH_BED_LEVELING)
         MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
       #endif
 

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 6a3728cc92..5ea064803c 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1079,21 +1079,21 @@ void kill_screen(const char* lcd_msg) {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
-            if (leveling_is_active())
+            if (LEVELING_IS_ACTIVE())
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
           #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
@@ -1927,21 +1927,21 @@ void kill_screen(const char* lcd_msg) {
      *    Load Settings       (Req: EEPROM_SETTINGS)
      *    Save Settings       (Req: EEPROM_SETTINGS)
      */
     void lcd_bed_leveling() {
       START_MENU();
       MENU_BACK(MSG_PREPARE);
 
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
         MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
       else if (leveling_is_valid()) {
-        _level_state = leveling_is_active();
+        _level_state = LEVELING_IS_ACTIVE();
         MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &_level_state, _lcd_toggle_bed_leveling);
       }
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         set_z_fade_height(planner.z_fade_height);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &planner.z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
       #endif
 
       //
       // MBL Z Offset

commit 9b0ee53b1286a7609675466a6fbd139a2e22c941
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Oct 7 18:16:41 2017 -0500

    Use segmented moves when moving axis from LCD

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9fee89afb4..6a3728cc92 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -454,20 +454,27 @@ uint16_t max_display_update_time = 0;
   // Manual Moves
   const float manual_feedrate_mm_m[] = MANUAL_FEEDRATE;
   millis_t manual_move_start_time = 0;
   int8_t manual_move_axis = (int8_t)NO_AXIS;
   #if EXTRUDERS > 1
     int8_t manual_move_e_index = 0;
   #else
     #define manual_move_e_index 0
   #endif
 
+  #if IS_KINEMATIC
+    bool processing_manual_move = false;
+    float manual_move_offset = 0.0;
+  #else
+    constexpr bool processing_manual_move = false;
+  #endif
+
   #if PIN_EXISTS(SD_DETECT)
     uint8_t lcd_sd_status;
   #endif
 
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
   #endif
 
   /**
    * General function to go directly to a screen
@@ -2728,23 +2735,59 @@ void kill_screen(const char* lcd_msg) {
       END_MENU();
     }
 
   #endif // DELTA_CALIBRATION_MENU
 
   /**
    * If the most recent manual move hasn't been fed to the planner yet,
    * and the planner can accept one, send immediately
    */
   inline void manage_manual_move() {
+
+    if (processing_manual_move) return;
+
     if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
-      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
-      manual_move_axis = (int8_t)NO_AXIS;
+
+      #if IS_KINEMATIC
+
+        const float old_feedrate = feedrate_mm_s;
+        feedrate_mm_s = MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]);
+
+        #if EXTRUDERS > 1
+          const int8_t old_extruder = active_extruder;
+          active_extruder = manual_move_e_index;
+        #endif
+
+        // Set movement on a single axis
+        set_destination_to_current();
+        destination[manual_move_axis] += manual_move_offset;
+
+        // Reset for the next move
+        manual_move_offset = 0.0;
+        manual_move_axis = (int8_t)NO_AXIS;
+
+        // Set a blocking flag so no new moves can be added until all segments are done
+        processing_manual_move = true;
+        prepare_move_to_destination(); // will call set_current_to_destination
+        processing_manual_move = false;
+
+        feedrate_mm_s = old_feedrate;
+        #if EXTRUDERS > 1
+          active_extruder = old_extruder;
+        #endif
+
+      #else
+
+        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
+        manual_move_axis = (int8_t)NO_AXIS;
+
+      #endif
     }
   }
 
   /**
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */
   inline void manual_move_to_current(AxisEnum axis
     #if E_MANUAL > 1
       , int8_t eindex=-1
@@ -2763,102 +2806,126 @@ void kill_screen(const char* lcd_msg) {
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (lcd_clicked) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition) {
+    if (encoderPosition && !processing_manual_move) {
       gcode.refresh_cmd_timeout();
 
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       #if HAS_SOFTWARE_ENDSTOPS
         // Limit to software endstops, if enabled
         if (soft_endstops_enabled) {
           #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
             min = soft_endstop_min[axis];
           #endif
           #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
             max = soft_endstop_max[axis];
           #endif
         }
       #endif
 
-      // Get the new position
-      current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
-
       // Delta limits XY based on the current offset from center
       // This assumes the center is 0,0
       #if ENABLED(DELTA)
         if (axis != Z_AXIS) {
           max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis]));
           min = -max;
         }
       #endif
 
-      // Limit only when trying to move towards the limit
-      if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
-      if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
+      // Get the new position
+      const float diff = float((int32_t)encoderPosition) * move_menu_scale;
+      #if IS_KINEMATIC
+        manual_move_offset += diff;
+        // Limit only when trying to move towards the limit
+        if ((int32_t)encoderPosition < 0) NOLESS(manual_move_offset, min - current_position[axis]);
+        if ((int32_t)encoderPosition > 0) NOMORE(manual_move_offset, max - current_position[axis]);
+      #else
+        current_position[axis] += diff;
+        // Limit only when trying to move towards the limit
+        if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
+        if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
+      #endif
 
       manual_move_to_current(axis);
 
-      encoderPosition = 0;
       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
     }
-    if (lcdDrawUpdate)
-      lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(current_position[axis]) : ftostr43sign(current_position[axis]));
+    encoderPosition = 0;
+    if (lcdDrawUpdate && !processing_manual_move) {
+      const float pos = current_position[axis]
+        #if IS_KINEMATIC
+          + manual_move_offset
+        #endif
+      ;
+      lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(pos) : ftostr43sign(pos));
+    }
   }
   void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
   void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
   void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
   void _lcd_move_e(
     #if E_MANUAL > 1
       int8_t eindex=-1
     #endif
   ) {
     if (lcd_clicked) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
-      current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
-      encoderPosition = 0;
-      manual_move_to_current(E_AXIS
-        #if E_MANUAL > 1
-          , eindex
+      if (!processing_manual_move) {
+        const float diff = float((int32_t)encoderPosition) * move_menu_scale;
+        #if IS_KINEMATIC
+          manual_move_offset += diff;
+        #else
+          current_position[E_AXIS] += diff;
         #endif
-      );
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        manual_move_to_current(E_AXIS
+          #if E_MANUAL > 1
+            , eindex
+          #endif
+        );
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      }
+      encoderPosition = 0;
     }
-    if (lcdDrawUpdate) {
+    if (lcdDrawUpdate && !processing_manual_move) {
       PGM_P pos_label;
       #if E_MANUAL == 1
         pos_label = PSTR(MSG_MOVE_E);
       #else
         switch (eindex) {
           default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
           case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
           #if E_MANUAL > 2
             case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
             #if E_MANUAL > 3
               case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
               #if E_MANUAL > 4
                 case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
               #endif // E_MANUAL > 4
             #endif // E_MANUAL > 3
           #endif // E_MANUAL > 2
         }
       #endif // E_MANUAL > 1
-      lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
+      lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
+        #if IS_KINEMATIC
+          + manual_move_offset
+        #endif
+      ));
     }
   }
 
   void lcd_move_e() { _lcd_move_e(); }
   #if E_MANUAL > 1
     void lcd_move_e0() { _lcd_move_e(0); }
     void lcd_move_e1() { _lcd_move_e(1); }
     #if E_MANUAL > 2
       void lcd_move_e2() { _lcd_move_e(2); }
       #if E_MANUAL > 3

commit ca3c9baf1bef13e42be9c2c5423d0922c199e2a6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 2 23:35:55 2017 -0500

    Fix DUAL_X_CARRIAGE manual moves, add T0/T1 menu item

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a248a1f94b..9fee89afb4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2743,23 +2743,27 @@ void kill_screen(const char* lcd_msg) {
 
   /**
    * Set a flag that lcd_update() should start a move
    * to "current_position" after a short delay.
    */
   inline void manual_move_to_current(AxisEnum axis
     #if E_MANUAL > 1
       , int8_t eindex=-1
     #endif
   ) {
-    #if E_MANUAL > 1
-      if (axis == E_AXIS) manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
+    #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
+      #if E_MANUAL > 1
+        if (axis == E_AXIS)
+      #endif
+          manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
+
     manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
     manual_move_axis = (int8_t)axis;
   }
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
@@ -2956,21 +2960,21 @@ void kill_screen(const char* lcd_msg) {
       #if ENABLED(DELTA)
         else
           MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
       #endif
 
       MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
     }
     else
       MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
 
-    #if ENABLED(SWITCHING_EXTRUDER)
+    #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
       else
         MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
     #endif
 
     MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
     #if E_MANUAL > 1
       MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
       MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);

commit a8b8d4e85ea6c2b49563f9bccc16247c1c59b61e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 2 23:33:57 2017 -0500

    Add a typedef for MENU_ITEM(function,…) functions

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 9a19104d71..a248a1f94b 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -205,21 +205,21 @@ uint16_t max_display_update_time = 0;
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
   void menu_action_gcode(const char* pgcode);
-  void menu_action_function(screenFunc_t data);
+  void menu_action_function(menuAction_t data);
 
   #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
     bool _menu_edit_ ## _name(); \
     void menu_edit_ ## _name(); \
     void menu_edit_callback_ ## _name(); \
     void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
     void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live=false); \
     typedef void _name##_void
 

commit 90af1fe5eefd353c9fb9c40430f45031147fd675
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:34:58 2017 -0500

    Implement NO_MOTION_BEFORE_HOMING option

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 2db06d5316..9a19104d71 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2921,33 +2921,33 @@ void kill_screen(const char* lcd_msg) {
       #endif // E_MANUAL > 3
     #endif // E_MANUAL > 2
   #endif // E_MANUAL > 1
 
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
-  #if IS_KINEMATIC
+  #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
     #define _MOVE_XYZ_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
-    #if ENABLED(DELTA)
-      #define _MOVE_XY_ALLOWED (current_position[Z_AXIS] <= delta_clip_start_height)
-      void lcd_lower_z_to_clip_height() {
-        line_to_z(delta_clip_start_height);
-        lcd_synchronize();
-      }
-    #else
-      #define _MOVE_XY_ALLOWED true
-    #endif
   #else
     #define _MOVE_XYZ_ALLOWED true
+  #endif
+
+  #if ENABLED(DELTA)
+    #define _MOVE_XY_ALLOWED (current_position[Z_AXIS] <= delta_clip_start_height)
+    void lcd_lower_z_to_clip_height() {
+      line_to_z(delta_clip_start_height);
+      lcd_synchronize();
+    }
+  #else
     #define _MOVE_XY_ALLOWED true
   #endif
 
   void lcd_move_menu() {
     START_MENU();
     MENU_BACK(MSG_PREPARE);
 
     if (_MOVE_XYZ_ALLOWED) {
       if (_MOVE_XY_ALLOWED) {
         MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);

commit ac41eb5871b5f36686412b2ae83789e4d6bd9f31
Merge: c0b365fdb4 0cb00f52d9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 1 21:56:54 2017 -0500

    Merge pull request #7722 from tcm0116/2.0.x-warnings
    
    Cleanup 2.0.x compiler warnings

diff --combined Marlin/src/lcd/ultralcd.cpp
index 01365993ff,dbf021c49d..2db06d5316
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@@ -2686,21 -2686,20 +2686,20 @@@ void kill_screen(const char* lcd_msg) 
  
      static float _delta_height = DELTA_HEIGHT;
      void _lcd_set_delta_height() {
        home_offset[Z_AXIS] = _delta_height - DELTA_HEIGHT;
        update_software_endstops(Z_AXIS);
      }
  
      void lcd_delta_settings() {
        START_MENU();
        MENU_BACK(MSG_DELTA_CALIBRATE);
-       float Tz = 0.00;
        MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
        _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
        MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
        MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
        MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
        MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
        MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
        MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
        MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);
@@@ -3550,21 -3549,21 +3549,21 @@@
    /**
     *
     * "Control" > "Retract" submenu
     *
     */
    #if ENABLED(FWRETRACT)
  
      void lcd_control_retract_menu() {
        START_MENU();
        MENU_BACK(MSG_CONTROL);
 -      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled);
 +      MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
        #if EXTRUDERS > 1
          MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
        #endif
        MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
        #if EXTRUDERS > 1
          MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
        #endif

commit ae2173cd52eab7f63ef7e7850ab6459b1b7b5a9b
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Fri Sep 29 08:03:28 2017 -0500

    Synchronize retractions

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7c83a977a8..01365993ff 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3550,21 +3550,21 @@ void kill_screen(const char* lcd_msg) {
   /**
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_control_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
-      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled);
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
       MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
       #endif

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7c83a977a8..dbf021c49d 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2686,21 +2686,20 @@ void kill_screen(const char* lcd_msg) {
 
     static float _delta_height = DELTA_HEIGHT;
     void _lcd_set_delta_height() {
       home_offset[Z_AXIS] = _delta_height - DELTA_HEIGHT;
       update_software_endstops(Z_AXIS);
     }
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
-      float Tz = 0.00;
       MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
       _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
       MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
       MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);

commit 604b804125571782a11ff819b29a062b23879ba0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 27 11:07:51 2017 -0500

    Add confirmation step to Init EEPROM

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b5dee03b42..7c83a977a8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2997,20 +2997,37 @@ void kill_screen(const char* lcd_msg) {
 
   #if HAS_LCD_CONTRAST
     void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
   #endif
 
   static void lcd_factory_settings() {
     settings.reset();
     lcd_completion_feedback();
   }
 
+  #if ENABLED(EEPROM_SETTINGS)
+
+    static void lcd_init_eeprom() {
+      lcd_factory_settings();
+      settings.save();
+      lcd_goto_previous_menu();
+    }
+
+    static void lcd_init_eeprom_confirm() {
+      START_MENU();
+      MENU_BACK(MSG_CONTROL);
+      MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
+      END_MENU();
+    }
+
+  #endif
+
   void lcd_control_menu() {
     START_MENU();
     MENU_BACK(MSG_MAIN);
     MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
     MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
     MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
 
     #if HAS_LCD_CONTRAST
       MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*)&lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
     #endif
@@ -3027,21 +3044,21 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(BLTOUCH)
       MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
     #endif
 
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif
     MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(gcode, MSG_INIT_EEPROM, PSTR("M502\nM500"));
+      MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Temperature" submenu
    *
    */

commit c869dc97452ed78c6fcf4f877a40afc8eaa49c45
Author: Tannoo <tannoo@msn.com>
Date:   Tue Sep 26 23:49:34 2017 -0600

    User script return-to-status option

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 34384b6e02..b5dee03b42 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -864,20 +864,23 @@ void kill_screen(const char* lcd_msg) {
       #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
     #else
       #define _DONE_SCRIPT ""
     #endif
 
     void _lcd_user_gcode(const char * const cmd) {
       enqueue_and_echo_commands_P(cmd);
       #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
         lcd_completion_feedback();
       #endif
+      #if ENABLED(USER_SCRIPT_RETURN)
+        lcd_return_to_status();
+      #endif
     }
 
     #if defined(USER_DESC_1) && defined(USER_GCODE_1)
       void lcd_user_gcode_1() { _lcd_user_gcode(PSTR(USER_GCODE_1 _DONE_SCRIPT)); }
     #endif
     #if defined(USER_DESC_2) && defined(USER_GCODE_2)
       void lcd_user_gcode_2() { _lcd_user_gcode(PSTR(USER_GCODE_2 _DONE_SCRIPT)); }
     #endif
     #if defined(USER_DESC_3) && defined(USER_GCODE_3)
       void lcd_user_gcode_3() { _lcd_user_gcode(PSTR(USER_GCODE_3 _DONE_SCRIPT)); }
@@ -3024,21 +3027,21 @@ void kill_screen(const char* lcd_msg) {
     #if ENABLED(BLTOUCH)
       MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
     #endif
 
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
       MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
     #endif
     MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(gcode, MSG_INIT_EEPROM, PSTR("M502\nM500")); // TODO: Add "Are You Sure?" step
+      MENU_ITEM(gcode, MSG_INIT_EEPROM, PSTR("M502\nM500"));
     #endif
 
     END_MENU();
   }
 
   /**
    *
    * "Temperature" submenu
    *
    */

commit ce1638e32f06a040645daef371dd16113bf44f0d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 27 00:58:46 2017 -0500

    Add Babystep Z graphic overlay
    
    See PR #7593

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 4eaee2aede..34384b6e02 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1018,41 +1018,85 @@ void kill_screen(const char* lcd_msg) {
 
     #if ENABLED(BABYSTEP_XY)
       void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
       void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
+      #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
+
+        void _lcd_babystep_zoffset_overlay(const float in_zoffset) {
+          // Determine whether the user is raising or lowering the nozzle.
+          int8_t dir = 0;
+          static float old_zprobe_zoffset = 0;
+          if (in_zoffset != old_zprobe_zoffset) {
+            dir = (in_zoffset > old_zprobe_zoffset) ? 1 : -1;
+            old_zprobe_zoffset = in_zoffset;
+          }
+
+          #if ENABLED(BABYSTEP_ZPROBE_GFX_REVERSE)
+            const unsigned char *rot_up   = ccw_bmp;
+            const unsigned char *rot_down = cw_bmp;
+          #else
+            const unsigned char *rot_up   = cw_bmp;
+            const unsigned char *rot_down = ccw_bmp;
+          #endif
+
+          #if ENABLED(USE_BIG_EDIT_FONT)
+            const int left = 0, right = 45, nozzle = 95;
+          #else
+            const int left = 5, right = 90, nozzle = 60;
+          #endif
+
+          // Draw a representation of the nozzle
+          if (PAGE_CONTAINS(3, 16))  u8g.drawBitmapP(nozzle + 6, 4 - dir, 2, 12, nozzle_bmp);
+          if (PAGE_CONTAINS(20, 20)) u8g.drawBitmapP(nozzle + 0, 20, 3, 1, offset_bedline_bmp);
+
+          // Draw cw/ccw indicator and up/down arrows.
+          if (PAGE_CONTAINS(47,62)) {
+            u8g.drawBitmapP(left  + 0, 47, 3, 16, rot_down);
+            u8g.drawBitmapP(right + 0, 47, 3, 16, rot_up);
+            u8g.drawBitmapP(right + 20, 48 - dir, 2, 13, up_arrow_bmp);
+            u8g.drawBitmapP(left  + 20, 49 - dir, 2, 13, down_arrow_bmp);
+          }
+        }
+
+      #endif // BABYSTEP_ZPROBE_GFX_OVERLAY
+
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
             if (leveling_is_active())
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
-        if (lcdDrawUpdate)
+        if (lcdDrawUpdate) {
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+          #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
+            _lcd_babystep_zoffset_overlay(zprobe_zoffset);
+          #endif
+        }
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
       void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
     #endif // !BABYSTEP_ZPROBE_OFFSET
 
   #endif // BABYSTEPPING

commit 92dbf5f148f657a62b7d5f4b99e77fb5f46683ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 26 23:41:20 2017 -0500

    Fix babystep edit label, allowing translation

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 450dae7dd4..4eaee2aede 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1010,22 +1010,22 @@ void kill_screen(const char* lcd_msg) {
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
         thermalManager.babystep_axis(axis, babystep_increment);
         babysteps_done += babystep_increment;
       }
       if (lcdDrawUpdate)
         lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
     }
 
     #if ENABLED(BABYSTEP_XY)
-      void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
-      void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
+      void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
+      void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
       void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
       void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
     #endif
 
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
       void lcd_babystep_zoffset() {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
@@ -1043,21 +1043,21 @@ void kill_screen(const char* lcd_msg) {
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate)
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
       }
 
     #else // !BABYSTEP_ZPROBE_OFFSET
 
-      void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }
+      void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
       void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
 
     #endif // !BABYSTEP_ZPROBE_OFFSET
 
   #endif // BABYSTEPPING
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
                                                   // separate value that doesn't lose precision.

commit 7a29f802d024cfd2fdb76364e748e0249ba96445
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 26 23:34:09 2017 -0500

    Fix ENCODER_PULSES_PER_STEP for G3D_PANEL

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fdb5b3b529..450dae7dd4 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -240,30 +240,20 @@ uint16_t max_display_update_time = 0;
   #if ENABLED(SDSUPPORT)
     void lcd_sdcard_menu();
     void menu_action_sdfile(const char* filename, char* longFilename);
     void menu_action_sddirectory(const char* filename, char* longFilename);
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Macros ////////////
   ////////////////////////////////////////////
 
-  #ifndef ENCODER_FEEDRATE_DEADZONE
-    #define ENCODER_FEEDRATE_DEADZONE 10
-  #endif
-  #ifndef ENCODER_STEPS_PER_MENU_ITEM
-    #define ENCODER_STEPS_PER_MENU_ITEM 5
-  #endif
-  #ifndef ENCODER_PULSES_PER_STEP
-    #define ENCODER_PULSES_PER_STEP 1
-  #endif
-
   /**
    * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
    *
    *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)
    *   menu_action_[type](arg3...)
    *
    * Examples:
    *   MENU_ITEM(back, MSG_WATCH, 0 [dummy parameter] )
    *   or
    *   MENU_BACK(MSG_WATCH)

commit 6d5fcac54ae76374065aed322e9f66f71756af70
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 24 02:18:15 2017 -0500

    G33 changes from 1.1.x

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index a0d16584cb..fdb5b3b529 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -2659,21 +2659,21 @@ void kill_screen(const char* lcd_msg) {
       float Tz = 0.00;
       MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
       _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
       MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
       MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Tz", &Tz, -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5.0, 5.0);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
         MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
         MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
         MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));

commit 71d63fcafb15c654c206a57ca5a50c3a4c73a4ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 23 19:24:43 2017 -0500

    Apply LCD changes from 1.1.x
    
    Changes from #7720

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index b10eff5e3f..a0d16584cb 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -83,20 +83,50 @@ char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kan
   uint8_t status_scroll_pos = 0;
 #endif
 
 #if ENABLED(DOGLCD)
   #include "ultralcd_impl_DOGM.h"
   #include <U8glib.h>
 #else
   #include "ultralcd_impl_HD44780.h"
 #endif
 
+#if ENABLED(ULTIPANEL)
+  #define DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(_type, _name, _strFunc) \
+    inline void lcd_implementation_drawmenu_setting_edit_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
+      UNUSED(pstr2); \
+      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
+    } \
+    inline void lcd_implementation_drawmenu_setting_edit_callback_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type * const data, ...) { \
+      UNUSED(pstr2); \
+      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(*(data))); \
+    } \
+    inline void lcd_implementation_drawmenu_setting_edit_accessor_ ## _name (const bool sel, const uint8_t row, const char* pstr, const char* pstr2, _type (*pget)(), void (*pset)(_type), ...) { \
+      UNUSED(pstr2); UNUSED(pset); \
+      DRAWMENU_SETTING_EDIT_GENERIC(_strFunc(pget())); \
+    } \
+    typedef void _name##_void
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(int16_t, int3, itostr3);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint8_t, int8, i8tostr3);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float3, ftostr3);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float32, ftostr32);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float43, ftostr43sign);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float5, ftostr5rj);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float51, ftostr51sign);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float52, ftostr52sign);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(float, float62, ftostr62rj);
+  DEFINE_LCD_IMPLEMENTATION_DRAWMENU_SETTING_EDIT_TYPE(uint32_t, long5, ftostr5rj);
+  #define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data)                    DRAW_BOOL_SETTING(sel, row, pstr, data)
+  #define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) DRAW_BOOL_SETTING(sel, row, pstr, data)
+  #define lcd_implementation_drawmenu_setting_edit_accessor_bool(sel, row, pstr, pstr2, pget, pset)     DRAW_BOOL_SETTING(sel, row, pstr, data)
+#endif // ULTIPANEL
+
 // The main status screen
 void lcd_status_screen();
 
 millis_t next_lcd_update_ms;
 
 uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
 uint16_t max_display_update_time = 0;
 
 #if ENABLED(DOGLCD)
   bool drawing_screen = false;

commit bfd1e75c040d0c6a0b2c4900649c3094770503a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 23 17:25:18 2017 -0500

    Patch for caselight + lcd compile issues

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 386b8aa9bc..b10eff5e3f 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -754,31 +754,29 @@ void kill_screen(const char* lcd_msg) {
       #endif
       wait_for_heatup = false;
       lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
       lcd_return_to_status();
     }
 
   #endif // SDSUPPORT
 
   #if ENABLED(MENU_ITEM_CASE_LIGHT)
 
-    extern int case_light_brightness;
-    extern bool case_light_on;
-    extern void update_case_light();
+    #include "../feature/caselight.h"
 
     void case_light_menu() {
       START_MENU();
       //
       // ^ Main
       //
       MENU_BACK(MSG_MAIN);
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
       MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
       END_MENU();
     }
   #endif // MENU_ITEM_CASE_LIGHT
 
   #if ENABLED(BLTOUCH)
 
     /**
      *
      * "BLTouch" submenu

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index e4bbf00448..386b8aa9bc 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3435,34 +3435,34 @@ void kill_screen(const char* lcd_msg) {
    *
    */
   void lcd_control_filament_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, calculate_volumetric_multipliers);
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
 
     if (parser.volumetric_enabled) {
       #if EXTRUDERS == 1
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
       #else // EXTRUDERS > 1
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5, 3.25, planner.calculate_volumetric_multipliers);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5, 3.25, planner.calculate_volumetric_multipliers);
         #if EXTRUDERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5, 3.25, planner.calculate_volumetric_multipliers);
           #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5, 3.25, planner.calculate_volumetric_multipliers);
             #if EXTRUDERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &filament_size[4], 1.5, 3.25, calculate_volumetric_multipliers);
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5, 3.25, planner.calculate_volumetric_multipliers);
             #endif // EXTRUDERS > 4
           #endif // EXTRUDERS > 3
         #endif // EXTRUDERS > 2
       #endif // EXTRUDERS > 1
     }
 
     END_MENU();
   }
 
   /**

commit 4f1eadf41f1e2d79f7c62c60a1ead6ae34b63be5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 12 15:02:17 2017 -0500

    FILAMENT_WIDTH_SENSOR feature

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 49ce24d5b8..e4bbf00448 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -40,24 +40,20 @@
 #include "../Marlin.h"
 
 #if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
-#if HAS_BED_PROBE
-  #include "../module/probe.h"
-#endif
-
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 // For i2c define BUZZ to use lcd_buzz
 #if DISABLED(LCD_USE_I2C_BUZZER)

commit d5fe0fb02b40311f00c2355df25400f139eb34f4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 9 00:18:43 2017 -0500

    Consolidate PrintCounter

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index fca4f41461..49ce24d5b8 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -25,28 +25,28 @@
 #if ENABLED(ULTRA_LCD)
 
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
 #include "../module/probe.h"
+#include "../module/printcounter.h"
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
-#if ENABLED(PRINTCOUNTER)
-  #include "../module/printcounter.h"
+#if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../module/probe.h"
 #endif

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index ae747f2132..fca4f41461 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -24,20 +24,21 @@
 
 #if ENABLED(ULTRA_LCD)
 
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/motion.h"
+#include "../module/probe.h"
 #include "../gcode/gcode.h"
 #include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "../module/printcounter.h"
   #include "../libs/duration_t.h"
 #endif
@@ -166,21 +167,21 @@ uint16_t max_display_update_time = 0;
   #if ENABLED(FWRETRACT)
     #include "../feature/fwretract.h"
     void lcd_control_retract_menu();
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-    #include "../feature/mbl/mesh_bed_leveling.h"
+    #include "../feature/bedlevel/mbl/mesh_bed_leveling.h"
     extern void mesh_probing_done();
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
@@ -1014,21 +1015,21 @@ void kill_screen(const char* lcd_msg) {
         if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
         defer_return_to_status = true;
         ENCODER_DIRECTION_NORMAL();
         if (encoderPosition) {
           const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
           encoderPosition = 0;
 
           const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
           if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
-            if (planner.abl_enabled)
+            if (leveling_is_active())
               thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
             zprobe_zoffset = new_zoffset;
             refresh_zprobe_zoffset(true);
             lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
           }
         }
         if (lcdDrawUpdate)
           lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
       }
@@ -2628,23 +2629,23 @@ void kill_screen(const char* lcd_msg) {
       update_software_endstops(Z_AXIS);
     }
 
     void lcd_delta_settings() {
       START_MENU();
       MENU_BACK(MSG_DELTA_CALIBRATE);
       float Tz = 0.00;
       MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
       _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
       MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
-      MENU_ITEM_EDIT(float43, "Ex", &endstop_adj[A_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Ey", &endstop_adj[B_AXIS], -5.0, 5.0);
-      MENU_ITEM_EDIT(float43, "Ez", &endstop_adj[C_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ex", &delta_endstop_adj[A_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ey", &delta_endstop_adj[B_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ez", &delta_endstop_adj[C_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
       MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
       MENU_ITEM_EDIT(float43, "Tz", &Tz, -5.0, 5.0);
       END_MENU();
     }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);

commit 63228fc45355232ba2c6a7838666ed76958623f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 11:41:12 2017 -0500

    Move volumetric flag to GCodeParser

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index d796f45faa..ae747f2132 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -3438,23 +3438,23 @@ void kill_screen(const char* lcd_msg) {
    *
    */
   void lcd_control_filament_menu() {
     START_MENU();
     MENU_BACK(MSG_CONTROL);
 
     #if ENABLED(LIN_ADVANCE)
       MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
     #endif
 
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, calculate_volumetric_multipliers);
 
-    if (volumetric_enabled) {
+    if (parser.volumetric_enabled) {
       #if EXTRUDERS == 1
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
       #else // EXTRUDERS > 1
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
         MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
         #if EXTRUDERS > 2
           MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
           #if EXTRUDERS > 3
             MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
             #if EXTRUDERS > 4

commit bf7af95db361d57e844894278fcb0a5d5ea4eba5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 23:50:46 2017 -0500

    Move flow_percentage to Planner

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 72a2288c61..d796f45faa 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -1217,31 +1217,31 @@ void kill_screen(const char* lcd_msg) {
       #if HAS_FAN2
         MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
       #endif
     #endif // FAN_COUNT > 0
 
     //
     // Flow:
     // Flow [1-5]:
     //
     #if EXTRUDERS == 1
-      MENU_ITEM_EDIT(int3, MSG_FLOW, &flow_percentage[0], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999);
     #else // EXTRUDERS > 1
-      MENU_ITEM_EDIT(int3, MSG_FLOW, &flow_percentage[active_extruder], 10, 999);
-      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &flow_percentage[0], 10, 999);
-      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &flow_percentage[1], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999);
       #if EXTRUDERS > 2
-        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &flow_percentage[2], 10, 999);
+        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999);
         #if EXTRUDERS > 3
-          MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &flow_percentage[3], 10, 999);
+          MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999);
           #if EXTRUDERS > 4
-            MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N5, &flow_percentage[4], 10, 999);
+            MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999);
           #endif // EXTRUDERS > 4
         #endif // EXTRUDERS > 3
       #endif // EXTRUDERS > 2
     #endif // EXTRUDERS > 1
 
     //
     // Babystep X:
     // Babystep Y:
     // Babystep Z:
     //

commit a98e9874dbf24a73874ecbda86b5fe739a8223d0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:40:32 2017 -0500

    FWRETRACT as a feature

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 34012b4ba2..72a2288c61 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -157,20 +157,21 @@ uint16_t max_display_update_time = 0;
   #endif
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     void dac_driver_commit();
     void dac_driver_getValues();
     void lcd_dac_menu();
     void lcd_dac_write_eeprom();
   #endif
 
   #if ENABLED(FWRETRACT)
+    #include "../feature/fwretract.h"
     void lcd_control_retract_menu();
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
     #include "../feature/mbl/mesh_bed_leveling.h"
     extern void mesh_probing_done();
@@ -3470,32 +3471,32 @@ void kill_screen(const char* lcd_msg) {
   /**
    *
    * "Control" > "Retract" submenu
    *
    */
   #if ENABLED(FWRETRACT)
 
     void lcd_control_retract_menu() {
       START_MENU();
       MENU_BACK(MSG_CONTROL);
-      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &fwretract.retract_length, 0, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &swap_retract_length, 0, 100);
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &fwretract.swap_retract_length, 0, 100);
       #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate_mm_s, 1, 999);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
-      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, -100, 100);
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.retract_feedrate_mm_s, 1, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &fwretract.retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &fwretract.retract_recover_length, -100, 100);
       #if EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &swap_retract_recover_length, -100, 100);
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.swap_retract_recover_length, -100, 100);
       #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate_mm_s, 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.retract_recover_feedrate_mm_s, 1, 999);
       END_MENU();
     }
 
   #endif // FWRETRACT
 
   #if ENABLED(SDSUPPORT)
 
     #if !PIN_EXISTS(SD_DETECT)
       void lcd_sd_refresh() {
         card.initsd();

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 7e40a438e6..34012b4ba2 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -23,20 +23,23 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(ULTRA_LCD)
 
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
+#include "../module/motion.h"
+#include "../gcode/gcode.h"
+#include "../gcode/queue.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "../module/printcounter.h"
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
@@ -1727,21 +1730,21 @@ void kill_screen(const char* lcd_msg) {
           _lcd_level_goto_next_point();
         }
 
         return;
       }
 
       //
       // Encoder knob or keypad buttons adjust the Z position
       //
       if (encoderPosition) {
-        refresh_cmd_timeout();
+        gcode.refresh_cmd_timeout();
         const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
         line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5));
         lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
         encoderPosition = 0;
       }
 
       //
       // Draw on first display, then only on Z change
       //
       if (lcdDrawUpdate) {
@@ -2273,21 +2276,21 @@ void kill_screen(const char* lcd_msg) {
         return lcd_goto_screen(_lcd_ubl_map_homing);
 
       if (lcd_clicked) return _lcd_ubl_map_lcd_edit_cmd();
       ENCODER_DIRECTION_NORMAL();
 
       if (encoderPosition) {
         step_scaler += (int32_t)encoderPosition;
         x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
         if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM)
           step_scaler = 0;
-        refresh_cmd_timeout();
+        gcode.refresh_cmd_timeout();
 
         encoderPosition = 0;
         lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
       }
 
       // Encoder to the right (++)
       if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
       if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
 
       // Encoder to the left (--)
@@ -2310,21 +2313,21 @@ void kill_screen(const char* lcd_msg) {
       if (lcdDrawUpdate) {
         lcd_implementation_ubl_plot(x_plot, y_plot);
 
         ubl_map_move_to_xy(); // Move to current location
 
         if (planner.movesplanned() > 1) { // if the nozzle is moving, cancel the move.  There is a new location
           stepper.quick_stop();
           set_current_from_steppers_for_axis(ALL_AXES);
           sync_plan_position();
           ubl_map_move_to_xy(); // Move to new location
-          refresh_cmd_timeout();
+          gcode.refresh_cmd_timeout();
         }
       }
     }
 
     /**
      * UBL Homing before LCD map
      */
     void _lcd_ubl_output_map_lcd_cmd() {
       if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS])) {
         axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
@@ -2695,21 +2698,21 @@ void kill_screen(const char* lcd_msg) {
   /**
    *
    * "Prepare" > "Move Axis" submenu
    *
    */
 
   void _lcd_move_xyz(const char* name, AxisEnum axis) {
     if (lcd_clicked) { return lcd_goto_previous_menu(); }
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
-      refresh_cmd_timeout();
+      gcode.refresh_cmd_timeout();
 
       float min = current_position[axis] - 1000,
             max = current_position[axis] + 1000;
 
       #if HAS_SOFTWARE_ENDSTOPS
         // Limit to software endstops, if enabled
         if (soft_endstops_enabled) {
           #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
             min = soft_endstop_min[axis];
           #endif

commit e0a189a481b00826d4ded0cc38580fd5726e4c79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 14 15:33:07 2017 -0500

    Consolidate Buzzer

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 1adb40cd05..7e40a438e6 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -27,24 +27,20 @@
 #include "ultralcd.h"
 
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../module/planner.h"
 #include "../module/stepper.h"
 #include "../module/configuration_store.h"
 
 #include "../Marlin.h"
 
-#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
-  #include "../libs/buzzer.h"
-#endif
-
 #if ENABLED(PRINTCOUNTER)
   #include "../module/printcounter.h"
   #include "../libs/duration_t.h"
 #endif
 
 #if ENABLED(FILAMENT_LCD_DISPLAY)
   #include "../feature/filwidth.h"
 #endif
 
 #if HAS_BED_PROBE
@@ -52,20 +48,25 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../module/endstops.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+// For i2c define BUZZ to use lcd_buzz
+#if DISABLED(LCD_USE_I2C_BUZZER)
+  #include "../libs/buzzer.h"
+#endif
+
 // Initialized by settings.load()
 int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
 #endif
 
 #if ENABLED(BABYSTEPPING)
   long babysteps_done = 0;
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -672,21 +673,21 @@ void kill_screen(const char* lcd_msg) {
   #endif
 }
 
 #if ENABLED(ULTIPANEL)
 
   /**
    *
    * Audio feedback for controller clicks
    *
    */
-  void lcd_buzz(long duration, uint16_t freq) {
+  void lcd_buzz(const long duration, const uint16_t freq) {
     #if ENABLED(LCD_USE_I2C_BUZZER)
       lcd.buzz(duration, freq);
     #elif PIN_EXISTS(BEEPER)
       buzzer.tone(duration, freq);
     #else
       UNUSED(duration); UNUSED(freq);
     #endif
   }
 
   void lcd_quick_feedback() {
@@ -4796,25 +4797,21 @@ void lcd_reset_alert_level() { lcd_status_message_level = 0; }
 
   #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
     bool lcd_detected() { return lcd.LcdDetected() == 1; }
   #else
     bool lcd_detected() { return true; }
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     void chirp_at_user() {
-      #if ENABLED(LCD_USE_I2C_BUZZER)
-        lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-      #elif PIN_EXISTS(BEEPER)
-        buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
-      #endif
+      lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
     }
 
     bool ubl_lcd_clicked() { return LCD_CLICKED; }
 
   #endif
 
 #endif // ULTIPANEL
 
 #if ENABLED(ADC_KEYPAD)
 

commit 0fcec02db56adca8b01300d6e49eed2246b8e61a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    LCD updates

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
index 11b412258c..1adb40cd05 100644
--- a/Marlin/src/lcd/ultralcd.cpp
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -13,47 +13,57 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
-#include "ultralcd.h"
+#include "../inc/MarlinConfig.h"
+
 #if ENABLED(ULTRA_LCD)
-#include "Marlin.h"
-#include "language.h"
-#include "cardreader.h"
-#include "temperature.h"
-#include "planner.h"
-#include "stepper.h"
-#include "configuration_store.h"
-#include "utility.h"
+
+#include "ultralcd.h"
+
+#include "../sd/cardreader.h"
+#include "../module/temperature.h"
+#include "../module/planner.h"
+#include "../module/stepper.h"
+#include "../module/configuration_store.h"
+
+#include "../Marlin.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
-  #include "buzzer.h"
+  #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(PRINTCOUNTER)
-  #include "printcounter.h"
-  #include "duration_t.h"
+  #include "../module/printcounter.h"
+  #include "../libs/duration_t.h"
+#endif
+
+#if ENABLED(FILAMENT_LCD_DISPLAY)
+  #include "../feature/filwidth.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../module/probe.h"
 #endif
 
 #if ENABLED(BLTOUCH)
-  #include "endstops.h"
+  #include "../module/endstops.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "ubl.h"
-  bool ubl_lcd_map_control = false;
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 // Initialized by settings.load()
 int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
 
 #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
   millis_t previous_lcd_status_ms = 0;
 #endif
 
 #if ENABLED(BABYSTEPPING)
@@ -85,33 +95,30 @@ void lcd_status_screen();
 millis_t next_lcd_update_ms;
 
 uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
 uint16_t max_display_update_time = 0;
 
 #if ENABLED(DOGLCD)
   bool drawing_screen = false;
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
-  #include "stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
+  #include "../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
   uint8_t driverPercent[XYZE];
 #endif
 
 #if ENABLED(ULTIPANEL)
 
   #ifndef TALL_FONT_CORRECTION
     #define TALL_FONT_CORRECTION 0
   #endif
 
-  // Function pointer to menu functions.
-  typedef void (*screenFunc_t)();
-
   #if HAS_POWER_SWITCH
     extern bool powersupply_on;
   #endif
 
   ////////////////////////////////////////////
   ///////////////// Menu Tree ////////////////
   ////////////////////////////////////////////
 
   void lcd_main_menu();
   void lcd_tune_menu();
@@ -154,21 +161,21 @@ uint16_t max_display_update_time = 0;
 
   #if ENABLED(FWRETRACT)
     void lcd_control_retract_menu();
   #endif
 
   #if ENABLED(DELTA_CALIBRATION_MENU)
     void lcd_delta_calibrate_menu();
   #endif
 
   #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-    #include "mesh_bed_leveling.h"
+    #include "../feature/mbl/mesh_bed_leveling.h"
     extern void mesh_probing_done();
   #endif
 
   ////////////////////////////////////////////
   //////////// Menu System Actions ///////////
   ////////////////////////////////////////////
 
   #define menu_action_back(dummy) _menu_action_back()
   void _menu_action_back();
   void menu_action_submenu(screenFunc_t data);
@@ -436,21 +443,21 @@ uint16_t max_display_update_time = 0;
     uint8_t lcd_sd_status;
   #endif
 
   #if ENABLED(PIDTEMP)
     float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
   #endif
 
   /**
    * General function to go directly to a screen
    */
-  void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder = 0) {
+  void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     if (currentScreen != screen) {
 
       #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
         static millis_t doubleclick_expire_ms = 0;
         // Going to lcd_main_menu from status screen? Remember first click time.
         // Going back to status screen within a very short time? Go to Z babystepping.
         if (screen == lcd_main_menu) {
           if (currentScreen == lcd_status_screen)
             doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
         }
@@ -462,28 +469,28 @@ uint16_t max_display_update_time = 0;
               lcd_babystep_z
             #endif
           ;
       #endif
 
       currentScreen = screen;
       encoderPosition = encoder;
       if (screen == lcd_status_screen) {
         defer_return_to_status = false;
         #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl_lcd_map_control = false;
+          ubl.lcd_map_control = false;
         #endif
         screen_history_depth = 0;
       }
       lcd_implementation_clear();
       // Re-initialize custom characters that may be re-used
       #if DISABLED(DOGLCD) && ENABLED(AUTO_BED_LEVELING_UBL)
-        if (!ubl_lcd_map_control) lcd_set_custom_characters(
+        if (!ubl.lcd_map_control) lcd_set_custom_characters(
           #if ENABLED(LCD_PROGRESS_BAR)
             screen == lcd_status_screen
           #endif
         );
       #elif ENABLED(LCD_PROGRESS_BAR)
         lcd_set_custom_characters(screen == lcd_status_screen);
       #endif
       lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       screen_changed = true;
       #if ENABLED(DOGLCD)
@@ -921,21 +928,21 @@ void kill_screen(const char* lcd_msg) {
       MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
     }
     else {
       MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
     }
     MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
 
     #if ENABLED(SDSUPPORT)
       if (card.cardOK) {
         if (card.isFileOpen()) {
-          if (card.sdprinting)
+          if (IS_SD_PRINTING)
             MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
           else
             MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
           MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
         }
         else {
           MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
           #if !PIN_EXISTS(SD_DETECT)
             MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
           #endif
@@ -2217,21 +2224,21 @@ void kill_screen(const char* lcd_msg) {
       END_MENU();
     }
 
     /**
      * UBL LCD "radar" map homing
      */
     void _lcd_ubl_output_map_lcd();
 
     void _lcd_ubl_map_homing() {
       defer_return_to_status = true;
-      ubl_lcd_map_control = true; // Return to the map screen
+      ubl.lcd_map_control = true; // Return to the map screen
       if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT < 3 ? 0 : (LCD_HEIGHT > 4 ? 2 : 1), PSTR(MSG_LEVEL_BED_HOMING));
       lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
       if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
     }
 
     /**
      * UBL LCD "radar" map point editing
      */
     void _lcd_ubl_map_lcd_edit_cmd() {

commit cc92e544a58dc259a4a2f70ba57b6b48b3aa1e7b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'lcd' files

diff --git a/Marlin/src/lcd/ultralcd.cpp b/Marlin/src/lcd/ultralcd.cpp
new file mode 100644
index 0000000000..11b412258c
--- /dev/null
+++ b/Marlin/src/lcd/ultralcd.cpp
@@ -0,0 +1,4850 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ultralcd.h"
+#if ENABLED(ULTRA_LCD)
+#include "Marlin.h"
+#include "language.h"
+#include "cardreader.h"
+#include "temperature.h"
+#include "planner.h"
+#include "stepper.h"
+#include "configuration_store.h"
+#include "utility.h"
+
+#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #include "buzzer.h"
+#endif
+
+#if ENABLED(PRINTCOUNTER)
+  #include "printcounter.h"
+  #include "duration_t.h"
+#endif
+
+#if ENABLED(BLTOUCH)
+  #include "endstops.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "ubl.h"
+  bool ubl_lcd_map_control = false;
+#endif
+
+// Initialized by settings.load()
+int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2];
+
+#if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+  millis_t previous_lcd_status_ms = 0;
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  long babysteps_done = 0;
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    static void lcd_babystep_zoffset();
+  #else
+    static void lcd_babystep_z();
+  #endif
+#endif
+
+uint8_t lcd_status_message_level;
+char lcd_status_message[3 * (LCD_WIDTH) + 1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1
+
+#if ENABLED(STATUS_MESSAGE_SCROLLING)
+  uint8_t status_scroll_pos = 0;
+#endif
+
+#if ENABLED(DOGLCD)
+  #include "ultralcd_impl_DOGM.h"
+  #include <U8glib.h>
+#else
+  #include "ultralcd_impl_HD44780.h"
+#endif
+
+// The main status screen
+void lcd_status_screen();
+
+millis_t next_lcd_update_ms;
+
+uint8_t lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; // Set when the LCD needs to draw, decrements after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial)
+uint16_t max_display_update_time = 0;
+
+#if ENABLED(DOGLCD)
+  bool drawing_screen = false;
+#endif
+
+#if ENABLED(DAC_STEPPER_CURRENT)
+  #include "stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
+  uint8_t driverPercent[XYZE];
+#endif
+
+#if ENABLED(ULTIPANEL)
+
+  #ifndef TALL_FONT_CORRECTION
+    #define TALL_FONT_CORRECTION 0
+  #endif
+
+  // Function pointer to menu functions.
+  typedef void (*screenFunc_t)();
+
+  #if HAS_POWER_SWITCH
+    extern bool powersupply_on;
+  #endif
+
+  ////////////////////////////////////////////
+  ///////////////// Menu Tree ////////////////
+  ////////////////////////////////////////////
+
+  void lcd_main_menu();
+  void lcd_tune_menu();
+  void lcd_prepare_menu();
+  void lcd_move_menu();
+  void lcd_control_menu();
+  void lcd_control_temperature_menu();
+  void lcd_control_temperature_preheat_material1_settings_menu();
+  void lcd_control_temperature_preheat_material2_settings_menu();
+  void lcd_control_motion_menu();
+  void lcd_control_filament_menu();
+
+  #if ENABLED(LCD_INFO_MENU)
+    #if ENABLED(PRINTCOUNTER)
+      void lcd_info_stats_menu();
+    #endif
+    void lcd_info_thermistors_menu();
+    void lcd_info_board_menu();
+    void lcd_info_menu();
+  #endif // LCD_INFO_MENU
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    void lcd_advanced_pause_toocold_menu();
+    void lcd_advanced_pause_option_menu();
+    void lcd_advanced_pause_init_message();
+    void lcd_advanced_pause_unload_message();
+    void lcd_advanced_pause_insert_message();
+    void lcd_advanced_pause_load_message();
+    void lcd_advanced_pause_heat_nozzle();
+    void lcd_advanced_pause_extrude_message();
+    void lcd_advanced_pause_resume_message();
+  #endif
+
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    void dac_driver_commit();
+    void dac_driver_getValues();
+    void lcd_dac_menu();
+    void lcd_dac_write_eeprom();
+  #endif
+
+  #if ENABLED(FWRETRACT)
+    void lcd_control_retract_menu();
+  #endif
+
+  #if ENABLED(DELTA_CALIBRATION_MENU)
+    void lcd_delta_calibrate_menu();
+  #endif
+
+  #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
+    #include "mesh_bed_leveling.h"
+    extern void mesh_probing_done();
+  #endif
+
+  ////////////////////////////////////////////
+  //////////// Menu System Actions ///////////
+  ////////////////////////////////////////////
+
+  #define menu_action_back(dummy) _menu_action_back()
+  void _menu_action_back();
+  void menu_action_submenu(screenFunc_t data);
+  void menu_action_gcode(const char* pgcode);
+  void menu_action_function(screenFunc_t data);
+
+  #define DECLARE_MENU_EDIT_TYPE(_type, _name) \
+    bool _menu_edit_ ## _name(); \
+    void menu_edit_ ## _name(); \
+    void menu_edit_callback_ ## _name(); \
+    void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue); \
+    void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue); \
+    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live=false); \
+    typedef void _name##_void
+
+  DECLARE_MENU_EDIT_TYPE(uint32_t, long5);
+  DECLARE_MENU_EDIT_TYPE(int16_t, int3);
+  DECLARE_MENU_EDIT_TYPE(uint8_t, int8);
+  DECLARE_MENU_EDIT_TYPE(float, float3);
+  DECLARE_MENU_EDIT_TYPE(float, float32);
+  DECLARE_MENU_EDIT_TYPE(float, float43);
+  DECLARE_MENU_EDIT_TYPE(float, float5);
+  DECLARE_MENU_EDIT_TYPE(float, float51);
+  DECLARE_MENU_EDIT_TYPE(float, float52);
+  DECLARE_MENU_EDIT_TYPE(float, float62);
+
+  void menu_action_setting_edit_bool(const char* pstr, bool* ptr);
+  void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callbackFunc);
+
+  #if ENABLED(SDSUPPORT)
+    void lcd_sdcard_menu();
+    void menu_action_sdfile(const char* filename, char* longFilename);
+    void menu_action_sddirectory(const char* filename, char* longFilename);
+  #endif
+
+  ////////////////////////////////////////////
+  //////////// Menu System Macros ////////////
+  ////////////////////////////////////////////
+
+  #ifndef ENCODER_FEEDRATE_DEADZONE
+    #define ENCODER_FEEDRATE_DEADZONE 10
+  #endif
+  #ifndef ENCODER_STEPS_PER_MENU_ITEM
+    #define ENCODER_STEPS_PER_MENU_ITEM 5
+  #endif
+  #ifndef ENCODER_PULSES_PER_STEP
+    #define ENCODER_PULSES_PER_STEP 1
+  #endif
+
+  /**
+   * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
+   *
+   *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)
+   *   menu_action_[type](arg3...)
+   *
+   * Examples:
+   *   MENU_ITEM(back, MSG_WATCH, 0 [dummy parameter] )
+   *   or
+   *   MENU_BACK(MSG_WATCH)
+   *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH))
+   *     menu_action_back()
+   *
+   *   MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause)
+   *     lcd_implementation_drawmenu_function(sel, row, PSTR(MSG_PAUSE_PRINT), lcd_sdcard_pause)
+   *     menu_action_function(lcd_sdcard_pause)
+   *
+   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
+   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+   *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+   *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+   *
+   */
+  #define _MENU_ITEM_PART_1(TYPE, ...) \
+    if (_menuLineNr == _thisItemNr) { \
+      if (lcd_clicked && encoderLine == _thisItemNr) {
+
+  #define _MENU_ITEM_PART_2(TYPE, LABEL, ...) \
+        menu_action_ ## TYPE(__VA_ARGS__); \
+        if (screen_changed) return; \
+      } \
+      if (lcdDrawUpdate) \
+        lcd_implementation_drawmenu_ ## TYPE(encoderLine == _thisItemNr, _lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
+    } \
+    ++_thisItemNr
+
+  #define MENU_ITEM(TYPE, LABEL, ...) do { \
+      _skipStatic = false; \
+      _MENU_ITEM_PART_1(TYPE, ## __VA_ARGS__); \
+      _MENU_ITEM_PART_2(TYPE, LABEL, ## __VA_ARGS__); \
+    }while(0)
+
+  #define MENU_BACK(LABEL) MENU_ITEM(back, LABEL, 0)
+
+  // Used to print static text with no visible cursor.
+  // Parameters: label [, bool center [, bool invert [, char *value] ] ]
+  #define STATIC_ITEM(LABEL, ...) \
+    if (_menuLineNr == _thisItemNr) { \
+      if (_skipStatic && encoderLine <= _thisItemNr) { \
+        encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
+        ++encoderLine; \
+      } \
+      if (lcdDrawUpdate) \
+        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(LABEL), ## __VA_ARGS__); \
+    } \
+    ++_thisItemNr
+
+  #if ENABLED(ENCODER_RATE_MULTIPLIER)
+
+    bool encoderRateMultiplierEnabled;
+    #define ENCODER_RATE_MULTIPLY(F) (encoderRateMultiplierEnabled = F)
+
+    //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
+
+    /**
+     * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item
+     */
+    #define MENU_MULTIPLIER_ITEM(type, label, ...) do { \
+        _MENU_ITEM_PART_1(type, ## __VA_ARGS__); \
+        encoderRateMultiplierEnabled = true; \
+        lastEncoderMovementMillis = 0; \
+        _MENU_ITEM_PART_2(type, label, ## __VA_ARGS__); \
+      }while(0)
+
+  #else // !ENCODER_RATE_MULTIPLIER
+    #define ENCODER_RATE_MULTIPLY(F) NOOP
+  #endif // !ENCODER_RATE_MULTIPLIER
+
+  #define MENU_ITEM_DUMMY() do { _thisItemNr++; }while(0)
+  #define MENU_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #define MENU_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #if ENABLED(ENCODER_RATE_MULTIPLIER)
+    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #else // !ENCODER_RATE_MULTIPLIER
+    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, ...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## __VA_ARGS__)
+    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, ...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## __VA_ARGS__)
+  #endif // !ENCODER_RATE_MULTIPLIER
+
+  /**
+   * START_SCREEN_OR_MENU generates init code for a screen or menu
+   *
+   *   encoderLine is the position based on the encoder
+   *   encoderTopLine is the top menu line to display
+   *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
+   *   _menuLineNr is the menu item to draw and process
+   *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+   *   _countedItems is the total number of items in the menu (after one call)
+   */
+  #define START_SCREEN_OR_MENU(LIMIT) \
+    ENCODER_DIRECTION_MENUS(); \
+    ENCODER_RATE_MULTIPLY(false); \
+    if (encoderPosition > 0x8000) encoderPosition = 0; \
+    static int8_t _countedItems = 0; \
+    int8_t encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM); \
+    if (_countedItems > 0 && encoderLine >= _countedItems - (LIMIT)) { \
+      encoderLine = max(0, _countedItems - (LIMIT)); \
+      encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM); \
+    }
+
+  #define SCREEN_OR_MENU_LOOP() \
+    int8_t _menuLineNr = encoderTopLine, _thisItemNr; \
+    for (int8_t _lcdLineNr = 0; _lcdLineNr < LCD_HEIGHT - (TALL_FONT_CORRECTION); _lcdLineNr++, _menuLineNr++) { \
+      _thisItemNr = 0
+
+  /**
+   * START_SCREEN  Opening code for a screen having only static items.
+   *               Do simplified scrolling of the entire screen.
+   *
+   * START_MENU    Opening code for a screen with menu items.
+   *               Scroll as-needed to keep the selected line in view.
+   */
+  #define START_SCREEN() \
+    START_SCREEN_OR_MENU(LCD_HEIGHT - (TALL_FONT_CORRECTION)); \
+    encoderTopLine = encoderLine; \
+    bool _skipStatic = false; \
+    SCREEN_OR_MENU_LOOP()
+
+  #define START_MENU() \
+    START_SCREEN_OR_MENU(1); \
+    screen_changed = false; \
+    NOMORE(encoderTopLine, encoderLine); \
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT - (TALL_FONT_CORRECTION)) { \
+      encoderTopLine = encoderLine - (LCD_HEIGHT - (TALL_FONT_CORRECTION) - 1); \
+    } \
+    bool _skipStatic = true; \
+    SCREEN_OR_MENU_LOOP()
+
+  #define END_SCREEN() \
+    } \
+    _countedItems = _thisItemNr
+
+  #define END_MENU() \
+    } \
+    _countedItems = _thisItemNr; \
+    UNUSED(_skipStatic)
+
+  ////////////////////////////////////////////
+  ///////////// Global Variables /////////////
+  ////////////////////////////////////////////
+
+  /**
+   * REVERSE_MENU_DIRECTION
+   *
+   * To reverse the menu direction we need a general way to reverse
+   * the direction of the encoder everywhere. So encoderDirection is
+   * added to allow the encoder to go the other way.
+   *
+   * This behavior is limited to scrolling Menus and SD card listings,
+   * and is disabled in other contexts.
+   */
+  #if ENABLED(REVERSE_MENU_DIRECTION)
+    int8_t encoderDirection = 1;
+    #define ENCODER_DIRECTION_NORMAL() (encoderDirection = 1)
+    #define ENCODER_DIRECTION_MENUS() (encoderDirection = -1)
+  #else
+    #define ENCODER_DIRECTION_NORMAL() ;
+    #define ENCODER_DIRECTION_MENUS() ;
+  #endif
+
+  // Encoder Movement
+  volatile int8_t encoderDiff; // Updated in lcd_buttons_update, added to encoderPosition every LCD update
+  uint32_t encoderPosition;
+  millis_t lastEncoderMovementMillis = 0;
+
+  // Button States
+  bool lcd_clicked, wait_for_unclick;
+  volatile uint8_t buttons;
+  millis_t next_button_update_ms;
+  #if ENABLED(REPRAPWORLD_KEYPAD)
+    volatile uint8_t buttons_reprapworld_keypad;
+  #endif
+  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+    volatile uint8_t slow_buttons;
+  #endif
+
+  // Menu System Navigation
+  screenFunc_t currentScreen = lcd_status_screen;
+  int8_t encoderTopLine;
+  typedef struct {
+    screenFunc_t menu_function;
+    uint32_t encoder_position;
+  } menuPosition;
+  menuPosition screen_history[6];
+  uint8_t screen_history_depth = 0;
+  bool screen_changed, defer_return_to_status;
+
+  // Value Editing
+  const char *editLabel;
+  void *editValue;
+  int32_t minEditValue, maxEditValue;
+  screenFunc_t callbackFunc;
+  bool liveEdit;
+
+  // Manual Moves
+  const float manual_feedrate_mm_m[] = MANUAL_FEEDRATE;
+  millis_t manual_move_start_time = 0;
+  int8_t manual_move_axis = (int8_t)NO_AXIS;
+  #if EXTRUDERS > 1
+    int8_t manual_move_e_index = 0;
+  #else
+    #define manual_move_e_index 0
+  #endif
+
+  #if PIN_EXISTS(SD_DETECT)
+    uint8_t lcd_sd_status;
+  #endif
+
+  #if ENABLED(PIDTEMP)
+    float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
+  #endif
+
+  /**
+   * General function to go directly to a screen
+   */
+  void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder = 0) {
+    if (currentScreen != screen) {
+
+      #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
+        static millis_t doubleclick_expire_ms = 0;
+        // Going to lcd_main_menu from status screen? Remember first click time.
+        // Going back to status screen within a very short time? Go to Z babystepping.
+        if (screen == lcd_main_menu) {
+          if (currentScreen == lcd_status_screen)
+            doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
+        }
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms))
+          screen =
+            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+              lcd_babystep_zoffset
+            #else
+              lcd_babystep_z
+            #endif
+          ;
+      #endif
+
+      currentScreen = screen;
+      encoderPosition = encoder;
+      if (screen == lcd_status_screen) {
+        defer_return_to_status = false;
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          ubl_lcd_map_control = false;
+        #endif
+        screen_history_depth = 0;
+      }
+      lcd_implementation_clear();
+      // Re-initialize custom characters that may be re-used
+      #if DISABLED(DOGLCD) && ENABLED(AUTO_BED_LEVELING_UBL)
+        if (!ubl_lcd_map_control) lcd_set_custom_characters(
+          #if ENABLED(LCD_PROGRESS_BAR)
+            screen == lcd_status_screen
+          #endif
+        );
+      #elif ENABLED(LCD_PROGRESS_BAR)
+        lcd_set_custom_characters(screen == lcd_status_screen);
+      #endif
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      screen_changed = true;
+      #if ENABLED(DOGLCD)
+        drawing_screen = false;
+      #endif
+    }
+  }
+
+  /**
+   * Show "Moving..." till moves are done, then revert to previous display.
+   */
+  static const char moving[] PROGMEM = MSG_MOVING;
+  static const char *sync_message = moving;
+
+  //
+  // Display the synchronize screen until moves are
+  // finished, and don't return to the caller until
+  // done. ** This blocks the command queue! **
+  //
+  void _lcd_synchronize() {
+    static bool no_reentry = false;
+    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
+    if (no_reentry) return;
+
+    // Make this the current handler till all moves are done
+    no_reentry = true;
+    screenFunc_t old_screen = currentScreen;
+    lcd_goto_screen(_lcd_synchronize);
+    stepper.synchronize();
+    no_reentry = false;
+    lcd_goto_screen(old_screen);
+  }
+
+  // Display the synchronize screen with a custom message
+  // ** This blocks the command queue! **
+  void lcd_synchronize(const char * const msg=NULL) {
+    sync_message = msg ? msg : moving;
+    _lcd_synchronize();
+  }
+
+  void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
+
+  void lcd_save_previous_screen() {
+    if (screen_history_depth < COUNT(screen_history)) {
+      screen_history[screen_history_depth].menu_function = currentScreen;
+      screen_history[screen_history_depth].encoder_position = encoderPosition;
+      ++screen_history_depth;
+    }
+  }
+
+  void lcd_goto_previous_menu() {
+    if (screen_history_depth > 0) {
+      --screen_history_depth;
+      lcd_goto_screen(
+        screen_history[screen_history_depth].menu_function,
+        screen_history[screen_history_depth].encoder_position
+      );
+    }
+    else
+      lcd_return_to_status();
+  }
+
+  void lcd_goto_previous_menu_no_defer() {
+    defer_return_to_status = false;
+    lcd_goto_previous_menu();
+  }
+
+#endif // ULTIPANEL
+
+/**
+ *
+ * "Info Screen"
+ *
+ * This is very display-dependent, so the lcd implementation draws this.
+ */
+
+void lcd_status_screen() {
+
+  #if ENABLED(ULTIPANEL)
+    ENCODER_DIRECTION_NORMAL();
+    ENCODER_RATE_MULTIPLY(false);
+  #endif
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+    millis_t ms = millis();
+    #if DISABLED(PROGRESS_MSG_ONCE)
+      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME)) {
+        progress_bar_ms = ms;
+      }
+    #endif
+    #if PROGRESS_MSG_EXPIRE > 0
+      // Handle message expire
+      if (expire_status_ms > 0) {
+        #if ENABLED(SDSUPPORT)
+          if (card.isFileOpen()) {
+            // Expire the message when printing is active
+            if (IS_SD_PRINTING) {
+              if (ELAPSED(ms, expire_status_ms)) {
+                lcd_status_message[0] = '\0';
+                expire_status_ms = 0;
+              }
+            }
+            else {
+              expire_status_ms += LCD_UPDATE_INTERVAL;
+            }
+          }
+          else {
+            expire_status_ms = 0;
+          }
+        #else
+          expire_status_ms = 0;
+        #endif // SDSUPPORT
+      }
+    #endif
+  #endif // LCD_PROGRESS_BAR
+
+  #if ENABLED(ULTIPANEL)
+
+    if (lcd_clicked) {
+      #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+        previous_lcd_status_ms = millis();  // get status message to show up for a while
+      #endif
+      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
+        #if ENABLED(LCD_PROGRESS_BAR)
+          false
+        #endif
+      );
+      lcd_goto_screen(lcd_main_menu);
+      return;
+    }
+
+    #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+      const int16_t new_frm = feedrate_percentage + (int32_t)encoderPosition;
+      // Dead zone at 100% feedrate
+      if ((feedrate_percentage < 100 && new_frm > 100) || (feedrate_percentage > 100 && new_frm < 100)) {
+        feedrate_percentage = 100;
+        encoderPosition = 0;
+      }
+      else if (feedrate_percentage == 100) {
+        if ((int32_t)encoderPosition > ENCODER_FEEDRATE_DEADZONE) {
+          feedrate_percentage += (int32_t)encoderPosition - (ENCODER_FEEDRATE_DEADZONE);
+          encoderPosition = 0;
+        }
+        else if ((int32_t)encoderPosition < -(ENCODER_FEEDRATE_DEADZONE)) {
+          feedrate_percentage += (int32_t)encoderPosition + ENCODER_FEEDRATE_DEADZONE;
+          encoderPosition = 0;
+        }
+      }
+      else {
+        feedrate_percentage = new_frm;
+        encoderPosition = 0;
+      }
+    #endif // ULTIPANEL_FEEDMULTIPLY
+
+    feedrate_percentage = constrain(feedrate_percentage, 10, 999);
+
+  #endif // ULTIPANEL
+
+  lcd_implementation_status_screen();
+}
+
+void lcd_reset_status() { lcd_setstatusPGM(PSTR(""), -1); }
+
+/**
+ *
+ * draw the kill screen
+ *
+ */
+void kill_screen(const char* lcd_msg) {
+  lcd_init();
+  lcd_setalertstatusPGM(lcd_msg);
+  #if ENABLED(DOGLCD)
+    u8g.firstPage();
+    do {
+      lcd_kill_screen();
+    } while (u8g.nextPage());
+  #else
+    lcd_kill_screen();
+  #endif
+}
+
+#if ENABLED(ULTIPANEL)
+
+  /**
+   *
+   * Audio feedback for controller clicks
+   *
+   */
+  void lcd_buzz(long duration, uint16_t freq) {
+    #if ENABLED(LCD_USE_I2C_BUZZER)
+      lcd.buzz(duration, freq);
+    #elif PIN_EXISTS(BEEPER)
+      buzzer.tone(duration, freq);
+    #else
+      UNUSED(duration); UNUSED(freq);
+    #endif
+  }
+
+  void lcd_quick_feedback() {
+    lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+    buttons = 0;
+    next_button_update_ms = millis() + 500;
+
+    // Buzz and wait. The delay is needed for buttons to settle!
+    lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+    #if ENABLED(LCD_USE_I2C_BUZZER)
+      delay(10);
+    #elif PIN_EXISTS(BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #endif
+  }
+
+  void lcd_completion_feedback(const bool good/*=true*/) {
+    if (good) {
+      lcd_buzz(100, 659);
+      lcd_buzz(100, 698);
+    }
+    else lcd_buzz(20, 440);
+  }
+
+  inline void line_to_current_z() {
+    planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
+  }
+
+  inline void line_to_z(const float &z) {
+    current_position[Z_AXIS] = z;
+    line_to_current_z();
+  }
+
+  #if ENABLED(SDSUPPORT)
+
+    void lcd_sdcard_pause() {
+      card.pauseSDPrint();
+      print_job_timer.pause();
+      #if ENABLED(PARK_HEAD_ON_PAUSE)
+        enqueue_and_echo_commands_P(PSTR("M125"));
+      #endif
+      lcd_setstatusPGM(PSTR(MSG_PRINT_PAUSED), -1);
+    }
+
+    void lcd_sdcard_resume() {
+      #if ENABLED(PARK_HEAD_ON_PAUSE)
+        enqueue_and_echo_commands_P(PSTR("M24"));
+      #else
+        card.startFileprint();
+        print_job_timer.start();
+      #endif
+      lcd_reset_status();
+    }
+
+    void lcd_sdcard_stop() {
+      card.stopSDPrint();
+      clear_command_queue();
+      quickstop_stepper();
+      print_job_timer.stop();
+      thermalManager.disable_all_heaters();
+      #if FAN_COUNT > 0
+        for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+      #endif
+      wait_for_heatup = false;
+      lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
+      lcd_return_to_status();
+    }
+
+  #endif // SDSUPPORT
+
+  #if ENABLED(MENU_ITEM_CASE_LIGHT)
+
+    extern int case_light_brightness;
+    extern bool case_light_on;
+    extern void update_case_light();
+
+    void case_light_menu() {
+      START_MENU();
+      //
+      // ^ Main
+      //
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
+      END_MENU();
+    }
+  #endif // MENU_ITEM_CASE_LIGHT
+
+  #if ENABLED(BLTOUCH)
+
+    /**
+     *
+     * "BLTouch" submenu
+     *
+     */
+    static void bltouch_menu() {
+      START_MENU();
+      //
+      // ^ Main
+      //
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
+      MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
+      END_MENU();
+    }
+
+  #endif // BLTOUCH
+
+  #if ENABLED(LCD_PROGRESS_BAR_TEST)
+
+    static void progress_bar_test() {
+      static int8_t bar_percent = 0;
+      if (lcd_clicked) {
+        lcd_goto_previous_menu();
+        lcd_set_custom_characters(false);
+        return;
+      }
+      bar_percent += (int8_t)encoderPosition;
+      bar_percent = constrain(bar_percent, 0, 100);
+      encoderPosition = 0;
+      lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
+      lcd.setCursor((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
+      lcd.print(itostr3(bar_percent)); lcd.write('%');
+      lcd.setCursor(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
+    }
+
+    void _progress_bar_test() {
+      lcd_goto_screen(progress_bar_test);
+      lcd_set_custom_characters();
+    }
+
+  #endif // LCD_PROGRESS_BAR_TEST
+
+  #if HAS_DEBUG_MENU
+
+    void lcd_debug_menu() {
+      START_MENU();
+
+      MENU_BACK(MSG_MAIN); // ^ Main
+
+      #if ENABLED(LCD_PROGRESS_BAR_TEST)
+        MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
+      #endif
+
+      END_MENU();
+    }
+
+  #endif // HAS_DEBUG_MENU
+
+  #if ENABLED(CUSTOM_USER_MENUS)
+
+    #ifdef USER_SCRIPT_DONE
+      #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
+    #else
+      #define _DONE_SCRIPT ""
+    #endif
+
+    void _lcd_user_gcode(const char * const cmd) {
+      enqueue_and_echo_commands_P(cmd);
+      #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
+        lcd_completion_feedback();
+      #endif
+    }
+
+    #if defined(USER_DESC_1) && defined(USER_GCODE_1)
+      void lcd_user_gcode_1() { _lcd_user_gcode(PSTR(USER_GCODE_1 _DONE_SCRIPT)); }
+    #endif
+    #if defined(USER_DESC_2) && defined(USER_GCODE_2)
+      void lcd_user_gcode_2() { _lcd_user_gcode(PSTR(USER_GCODE_2 _DONE_SCRIPT)); }
+    #endif
+    #if defined(USER_DESC_3) && defined(USER_GCODE_3)
+      void lcd_user_gcode_3() { _lcd_user_gcode(PSTR(USER_GCODE_3 _DONE_SCRIPT)); }
+    #endif
+    #if defined(USER_DESC_4) && defined(USER_GCODE_4)
+      void lcd_user_gcode_4() { _lcd_user_gcode(PSTR(USER_GCODE_4 _DONE_SCRIPT)); }
+    #endif
+    #if defined(USER_DESC_5) && defined(USER_GCODE_5)
+      void lcd_user_gcode_5() { _lcd_user_gcode(PSTR(USER_GCODE_5 _DONE_SCRIPT)); }
+    #endif
+
+    void _lcd_user_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      #if defined(USER_DESC_1) && defined(USER_GCODE_1)
+        MENU_ITEM(function, USER_DESC_1, lcd_user_gcode_1);
+      #endif
+      #if defined(USER_DESC_2) && defined(USER_GCODE_2)
+        MENU_ITEM(function, USER_DESC_2, lcd_user_gcode_2);
+      #endif
+      #if defined(USER_DESC_3) && defined(USER_GCODE_3)
+        MENU_ITEM(function, USER_DESC_3, lcd_user_gcode_3);
+      #endif
+      #if defined(USER_DESC_4) && defined(USER_GCODE_4)
+        MENU_ITEM(function, USER_DESC_4, lcd_user_gcode_4);
+      #endif
+      #if defined(USER_DESC_5) && defined(USER_GCODE_5)
+        MENU_ITEM(function, USER_DESC_5, lcd_user_gcode_5);
+      #endif
+      END_MENU();
+    }
+
+  #endif
+
+  /**
+   *
+   * "Main" menu
+   *
+   */
+
+  void lcd_main_menu() {
+    START_MENU();
+    MENU_BACK(MSG_WATCH);
+
+    #if ENABLED(CUSTOM_USER_MENUS)
+      MENU_ITEM(submenu, MSG_USER_MENU, _lcd_user_menu);
+    #endif
+
+    //
+    // Debug Menu when certain options are enabled
+    //
+    #if HAS_DEBUG_MENU
+      MENU_ITEM(submenu, MSG_DEBUG_MENU, lcd_debug_menu);
+    #endif
+
+    //
+    // Set Case light on/off/brightness
+    //
+    #if ENABLED(MENU_ITEM_CASE_LIGHT)
+      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
+        MENU_ITEM(submenu, MSG_CASE_LIGHT, case_light_menu);
+      }
+      else
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
+    #endif
+
+    if (planner.movesplanned() || IS_SD_PRINTING) {
+      MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);
+    }
+    else {
+      MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);
+    }
+    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);
+
+    #if ENABLED(SDSUPPORT)
+      if (card.cardOK) {
+        if (card.isFileOpen()) {
+          if (card.sdprinting)
+            MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
+          else
+            MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
+          MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+        }
+        else {
+          MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);
+          #if !PIN_EXISTS(SD_DETECT)
+            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+          #endif
+        }
+      }
+      else {
+        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);
+        #if !PIN_EXISTS(SD_DETECT)
+          MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
+        #endif
+      }
+    #endif // SDSUPPORT
+
+    #if ENABLED(LCD_INFO_MENU)
+      MENU_ITEM(submenu, MSG_INFO_MENU, lcd_info_menu);
+    #endif
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Tune" submenu items
+   *
+   */
+
+  #if HAS_M206_COMMAND
+    /**
+     * Set the home offset based on the current_position
+     */
+    void lcd_set_home_offsets() {
+      // M428 Command
+      enqueue_and_echo_commands_P(PSTR("M428"));
+      lcd_return_to_status();
+    }
+  #endif
+
+  #if ENABLED(BABYSTEPPING)
+
+    void _lcd_babystep(const AxisEnum axis, const char* msg) {
+      if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
+      ENCODER_DIRECTION_NORMAL();
+      if (encoderPosition) {
+        const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
+        encoderPosition = 0;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        thermalManager.babystep_axis(axis, babystep_increment);
+        babysteps_done += babystep_increment;
+      }
+      if (lcdDrawUpdate)
+        lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
+    }
+
+    #if ENABLED(BABYSTEP_XY)
+      void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
+      void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
+      void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
+      void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
+    #endif
+
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+
+      void lcd_babystep_zoffset() {
+        if (lcd_clicked) { return lcd_goto_previous_menu_no_defer(); }
+        defer_return_to_status = true;
+        ENCODER_DIRECTION_NORMAL();
+        if (encoderPosition) {
+          const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
+          encoderPosition = 0;
+
+          const float new_zoffset = zprobe_zoffset + planner.steps_to_mm[Z_AXIS] * babystep_increment;
+          if (WITHIN(new_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+
+            if (planner.abl_enabled)
+              thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+
+            zprobe_zoffset = new_zoffset;
+            refresh_zprobe_zoffset(true);
+            lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+          }
+        }
+        if (lcdDrawUpdate)
+          lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+      }
+
+    #else // !BABYSTEP_ZPROBE_OFFSET
+
+      void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }
+      void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
+
+    #endif // !BABYSTEP_ZPROBE_OFFSET
+
+  #endif // BABYSTEPPING
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
+                                                  // separate value that doesn't lose precision.
+    static int16_t ubl_encoderPosition = 0;
+
+    static void _lcd_mesh_fine_tune(const char* msg) {
+      defer_return_to_status = true;
+      if (ubl.encoder_diff) {
+        ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
+        ubl.encoder_diff = 0;
+
+        mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005 / 2.0;
+        mesh_edit_value = mesh_edit_accumulator;
+        encoderPosition = 0;
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+
+        const int32_t rounded = (int32_t)(mesh_edit_value * 1000.0);
+        mesh_edit_value = float(rounded - (rounded % 5L)) / 1000.0;
+      }
+
+      if (lcdDrawUpdate)
+        lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
+    }
+
+    void _lcd_mesh_edit_NOP() {
+      defer_return_to_status = true;
+    }
+
+    float lcd_mesh_edit() {
+      lcd_goto_screen(_lcd_mesh_edit_NOP);
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
+      return mesh_edit_value;
+    }
+
+    void lcd_mesh_edit_setup(float initial) {
+      mesh_edit_value = mesh_edit_accumulator = initial;
+      lcd_goto_screen(_lcd_mesh_edit_NOP);
+    }
+
+    void _lcd_z_offset_edit() {
+      _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
+    }
+
+    float lcd_z_offset_edit() {
+      lcd_goto_screen(_lcd_z_offset_edit);
+      return mesh_edit_value;
+    }
+
+    void lcd_z_offset_edit_setup(float initial) {
+      mesh_edit_value = mesh_edit_accumulator = initial;
+      lcd_goto_screen(_lcd_z_offset_edit);
+    }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+
+  /**
+   * Watch temperature callbacks
+   */
+  #if HAS_TEMP_HOTEND
+    #if WATCH_HOTENDS
+      #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
+    #else
+      #define _WATCH_FUNC(N) NOOP
+    #endif
+    void watch_temp_callback_E0() { _WATCH_FUNC(0); }
+    #if HOTENDS > 1
+      void watch_temp_callback_E1() { _WATCH_FUNC(1); }
+      #if HOTENDS > 2
+        void watch_temp_callback_E2() { _WATCH_FUNC(2); }
+        #if HOTENDS > 3
+          void watch_temp_callback_E3() { _WATCH_FUNC(3); }
+          #if HOTENDS > 4
+            void watch_temp_callback_E4() { _WATCH_FUNC(4); }
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+  #endif // HAS_TEMP_HOTEND
+
+  void watch_temp_callback_bed() {
+    #if WATCH_THE_BED
+      thermalManager.start_watching_bed();
+    #endif
+  }
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+    void lcd_enqueue_filament_change() {
+
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        if (!DEBUGGING(DRYRUN) && !thermalManager.allow_cold_extrude &&
+            thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
+          lcd_save_previous_screen();
+          lcd_goto_screen(lcd_advanced_pause_toocold_menu);
+          return;
+        }
+      #endif
+
+      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
+      enqueue_and_echo_commands_P(PSTR("M600 B0"));
+    }
+
+  #endif // ADVANCED_PAUSE_FEATURE
+
+  /**
+   *
+   * "Tune" submenu
+   *
+   */
+  void lcd_tune_menu() {
+    START_MENU();
+
+    //
+    // ^ Main
+    //
+    MENU_BACK(MSG_MAIN);
+
+    //
+    // Speed:
+    //
+    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
+
+    // Manual bed leveling, Bed Z:
+    #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
+      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+    #endif
+
+    //
+    // Nozzle:
+    // Nozzle [1-4]:
+    //
+    #if HOTENDS == 1
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+    #else // HOTENDS > 1
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+      #if HOTENDS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
+        #if HOTENDS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+          #if HOTENDS > 4
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+
+    //
+    // Bed:
+    //
+    #if HAS_TEMP_BED
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+    #endif
+
+    //
+    // Fan Speed:
+    //
+    #if FAN_COUNT > 0
+      #if HAS_FAN0
+        #if FAN_COUNT > 1
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
+        #else
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
+        #endif
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
+      #endif
+      #if HAS_FAN1
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+      #endif
+      #if HAS_FAN2
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+      #endif
+    #endif // FAN_COUNT > 0
+
+    //
+    // Flow:
+    // Flow [1-5]:
+    //
+    #if EXTRUDERS == 1
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &flow_percentage[0], 10, 999);
+    #else // EXTRUDERS > 1
+      MENU_ITEM_EDIT(int3, MSG_FLOW, &flow_percentage[active_extruder], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &flow_percentage[0], 10, 999);
+      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &flow_percentage[1], 10, 999);
+      #if EXTRUDERS > 2
+        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &flow_percentage[2], 10, 999);
+        #if EXTRUDERS > 3
+          MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &flow_percentage[3], 10, 999);
+          #if EXTRUDERS > 4
+            MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N5, &flow_percentage[4], 10, 999);
+          #endif // EXTRUDERS > 4
+        #endif // EXTRUDERS > 3
+      #endif // EXTRUDERS > 2
+    #endif // EXTRUDERS > 1
+
+    //
+    // Babystep X:
+    // Babystep Y:
+    // Babystep Z:
+    //
+    #if ENABLED(BABYSTEPPING)
+      #if ENABLED(BABYSTEP_XY)
+        MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
+        MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
+      #endif
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+      #else
+        MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
+      #endif
+    #endif
+
+    //
+    // Change filament
+    //
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      if (!thermalManager.tooColdToExtrude(active_extruder))
+        MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+    #endif
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Driver current control" submenu items
+   *
+   */
+  #if ENABLED(DAC_STEPPER_CURRENT)
+
+    void dac_driver_getValues() { LOOP_XYZE(i) driverPercent[i] = dac_current_get_percent((AxisEnum)i); }
+
+    void dac_driver_commit() { dac_current_set_percents(driverPercent); }
+
+    void dac_driver_eeprom_write() { dac_commit_eeprom(); }
+
+    void lcd_dac_menu() {
+      dac_driver_getValues();
+      START_MENU();
+      MENU_BACK(MSG_CONTROL);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_X " " MSG_DAC_PERCENT, &driverPercent[X_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_Y " " MSG_DAC_PERCENT, &driverPercent[Y_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_Z " " MSG_DAC_PERCENT, &driverPercent[Z_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_E " " MSG_DAC_PERCENT, &driverPercent[E_AXIS], 0, 100, dac_driver_commit);
+      MENU_ITEM(function, MSG_DAC_EEPROM_WRITE, dac_driver_eeprom_write);
+      END_MENU();
+    }
+
+  #endif // DAC_STEPPER_CURRENT
+
+  #if HAS_MOTOR_CURRENT_PWM
+
+    void lcd_pwm_menu() {
+      START_MENU();
+      MENU_BACK(MSG_CONTROL);
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_X MSG_Y, &stepper.motor_current_setting[0], 100, 2000, Stepper::refresh_motor_power);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_Z, &stepper.motor_current_setting[1], 100, 2000, Stepper::refresh_motor_power);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_E, &stepper.motor_current_setting[2], 100, 2000, Stepper::refresh_motor_power);
+      #endif
+      END_MENU();
+    }
+
+  #endif // HAS_MOTOR_CURRENT_PWM
+
+  constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP);
+
+  /**
+   *
+   * "Prepare" submenu items
+   *
+   */
+  void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const int16_t fan) {
+    if (temph > 0) thermalManager.setTargetHotend(min(heater_maxtemp[endnum], temph), endnum);
+    #if TEMP_SENSOR_BED != 0
+      if (tempb >= 0) thermalManager.setTargetBed(tempb);
+    #else
+      UNUSED(tempb);
+    #endif
+    #if FAN_COUNT > 0
+      #if FAN_COUNT > 1
+        fanSpeeds[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
+      #else
+        fanSpeeds[0] = fan;
+      #endif
+    #else
+      UNUSED(fan);
+    #endif
+    lcd_return_to_status();
+  }
+
+  #if TEMP_SENSOR_0 != 0
+    void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+    #if TEMP_SENSOR_BED != 0
+      void lcd_preheat_m1_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_m2_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+    #endif
+  #endif
+
+  #if HOTENDS > 1
+    void lcd_preheat_m1_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+    #if TEMP_SENSOR_BED != 0
+      void lcd_preheat_m1_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_m2_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+    #endif
+    #if HOTENDS > 2
+      void lcd_preheat_m1_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_m2_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+      #if TEMP_SENSOR_BED != 0
+        void lcd_preheat_m1_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+        void lcd_preheat_m2_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+      #endif
+      #if HOTENDS > 3
+        void lcd_preheat_m1_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+        void lcd_preheat_m2_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+        #if TEMP_SENSOR_BED != 0
+          void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+          void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+        #endif
+        #if HOTENDS > 4
+          void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+          void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+          #if TEMP_SENSOR_BED != 0
+            void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+            void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+          #endif
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+
+    void lcd_preheat_m1_all() {
+      #if HOTENDS > 1
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
+        #if HOTENDS > 2
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
+          #if HOTENDS > 3
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
+            #if HOTENDS > 4
+              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+      #if TEMP_SENSOR_BED != 0
+        lcd_preheat_m1_e0();
+      #else
+        lcd_preheat_m1_e0_only();
+      #endif
+    }
+    void lcd_preheat_m2_all() {
+      #if HOTENDS > 1
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
+        #if HOTENDS > 2
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
+          #if HOTENDS > 3
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
+            #if HOTENDS > 4
+              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+      #if TEMP_SENSOR_BED != 0
+        lcd_preheat_m2_e0();
+      #else
+        lcd_preheat_m2_e0_only();
+      #endif
+    }
+
+  #endif // HOTENDS > 1
+
+  #if TEMP_SENSOR_BED != 0
+    void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+  #endif
+
+  #if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || TEMP_SENSOR_BED != 0)
+
+    void lcd_preheat_m1_menu() {
+      START_MENU();
+      MENU_BACK(MSG_PREPARE);
+      #if HOTENDS == 1
+        #if TEMP_SENSOR_BED != 0
+          MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
+          MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
+        #endif
+      #else
+        #if TEMP_SENSOR_BED != 0
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
+          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
+          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
+        #endif
+        #if HOTENDS > 2
+          #if TEMP_SENSOR_BED != 0
+            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2);
+            MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E3, lcd_preheat_m1_e2_only);
+          #else
+            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2_only);
+          #endif
+          #if HOTENDS > 3
+            #if TEMP_SENSOR_BED != 0
+              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3);
+              MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E4, lcd_preheat_m1_e3_only);
+            #else
+              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
+            #endif
+            #if HOTENDS > 4
+              #if TEMP_SENSOR_BED != 0
+                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
+                MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
+              #else
+                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
+              #endif
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+        MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
+      #endif // HOTENDS > 1
+      #if TEMP_SENSOR_BED != 0
+        MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
+      #endif
+      END_MENU();
+    }
+
+    void lcd_preheat_m2_menu() {
+      START_MENU();
+      MENU_BACK(MSG_PREPARE);
+      #if HOTENDS == 1
+        #if TEMP_SENSOR_BED != 0
+          MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
+          MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
+        #endif
+      #else
+        #if TEMP_SENSOR_BED != 0
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
+          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
+          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
+        #endif
+        #if HOTENDS > 2
+          #if TEMP_SENSOR_BED != 0
+            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2);
+            MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E3, lcd_preheat_m2_e2_only);
+          #else
+            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2_only);
+          #endif
+          #if HOTENDS > 3
+            #if TEMP_SENSOR_BED != 0
+              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3);
+              MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E4, lcd_preheat_m2_e3_only);
+            #else
+              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
+            #endif
+            #if HOTENDS > 4
+              #if TEMP_SENSOR_BED != 0
+                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
+                MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
+              #else
+                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
+              #endif
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+        MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
+      #endif // HOTENDS > 1
+      #if TEMP_SENSOR_BED != 0
+        MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
+      #endif
+      END_MENU();
+    }
+
+  #endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_4 || TEMP_SENSOR_BED)
+
+  void lcd_cooldown() {
+    #if FAN_COUNT > 0
+      for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+    #endif
+    thermalManager.disable_all_heaters();
+    lcd_return_to_status();
+  }
+
+  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+
+    void lcd_autostart_sd() {
+      card.autostart_index = 0;
+      card.setroot();
+      card.checkautostart(true);
+    }
+
+  #endif
+
+  #if ENABLED(EEPROM_SETTINGS)
+    static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
+    static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
+  #endif
+
+  #if HAS_BED_PROBE && DISABLED(BABYSTEP_ZPROBE_OFFSET)
+    static void lcd_refresh_zprobe_zoffset() { refresh_zprobe_zoffset(); }
+  #endif
+
+
+  #if ENABLED(LEVEL_BED_CORNERS)
+
+    /**
+     * Level corners, starting in the front-left corner.
+     */
+    static int8_t bed_corner;
+    void _lcd_goto_next_corner() {
+      line_to_z(LOGICAL_Z_POSITION(4.0));
+      switch (bed_corner) {
+        case 0:
+          current_position[X_AXIS] = X_MIN_BED + 10;
+          current_position[Y_AXIS] = Y_MIN_BED + 10;
+          break;
+        case 1:
+          current_position[X_AXIS] = X_MAX_BED - 10;
+          break;
+        case 2:
+          current_position[Y_AXIS] = Y_MAX_BED - 10;
+          break;
+        case 3:
+          current_position[X_AXIS] = X_MIN_BED + 10;
+          break;
+      }
+      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
+      line_to_z(LOGICAL_Z_POSITION(0.0));
+      if (++bed_corner > 3) bed_corner = 0;
+    }
+
+    void _lcd_corner_submenu() {
+      START_MENU();
+      MENU_ITEM(function, MSG_NEXT_CORNER, _lcd_goto_next_corner);
+      MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
+      END_MENU();
+    }
+
+    void _lcd_level_bed_corners() {
+      defer_return_to_status = true;
+      lcd_goto_screen(_lcd_corner_submenu);
+      bed_corner = 0;
+      _lcd_goto_next_corner();
+    }
+
+  #endif // LEVEL_BED_CORNERS
+
+  #if ENABLED(LCD_BED_LEVELING)
+
+    /**
+     *
+     * "Prepare" > "Level Bed" handlers
+     *
+     */
+
+    static uint8_t manual_probe_index;
+
+    // LCD probed points are from defaults
+    constexpr uint8_t total_probe_points = (
+      #if ENABLED(AUTO_BED_LEVELING_3POINT)
+        3
+      #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
+        GRID_MAX_POINTS
+      #endif
+    );
+
+    //
+    // Raise Z to the "manual probe height"
+    // Don't return until done.
+    // ** This blocks the command queue! **
+    //
+    void _lcd_after_probing() {
+      #if MANUAL_PROBE_HEIGHT > 0
+        line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+      #endif
+      // Display "Done" screen and wait for moves to complete
+      #if MANUAL_PROBE_HEIGHT > 0 || ENABLED(MESH_BED_LEVELING)
+        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
+      #endif
+      lcd_goto_previous_menu();
+      lcd_completion_feedback();
+      defer_return_to_status = false;
+      //LCD_MESSAGEPGM(MSG_LEVEL_BED_DONE);
+    }
+
+    #if ENABLED(MESH_BED_LEVELING)
+
+      // Utility to go to the next mesh point
+      inline void _manual_probe_goto_xy(float x, float y) {
+        #if MANUAL_PROBE_HEIGHT > 0
+          const float prev_z = current_position[Z_AXIS];
+          line_to_z(LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT);
+        #endif
+        current_position[X_AXIS] = LOGICAL_X_POSITION(x);
+        current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
+        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
+        #if MANUAL_PROBE_HEIGHT > 0
+          line_to_z(prev_z);
+        #endif
+        lcd_synchronize();
+      }
+
+    #elif ENABLED(PROBE_MANUALLY)
+
+      bool lcd_wait_for_move;
+
+      //
+      // Bed leveling is done. Wait for G29 to complete.
+      // A flag is used so that this can release control
+      // and allow the command queue to be processed.
+      //
+      void _lcd_level_bed_done() {
+        if (!lcd_wait_for_move) _lcd_after_probing();
+        if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_DONE));
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      }
+
+    #endif
+
+    void _lcd_level_goto_next_point();
+
+    /**
+     * Step 7: Get the Z coordinate, click goes to the next point or exits
+     */
+    void _lcd_level_bed_get_z() {
+      ENCODER_DIRECTION_NORMAL();
+
+      if (lcd_clicked) {
+
+        //
+        // Save the current Z position
+        //
+
+        #if ENABLED(MESH_BED_LEVELING)
+
+          //
+          // MBL records the position but doesn't move to the next one
+          //
+
+          mbl.set_zigzag_z(manual_probe_index, current_position[Z_AXIS]);
+
+        #endif
+
+        // If done...
+        if (++manual_probe_index >= total_probe_points) {
+
+          #if ENABLED(PROBE_MANUALLY)
+
+            //
+            // The last G29 will record and enable but not move.
+            //
+            lcd_wait_for_move = true;
+            enqueue_and_echo_commands_P(PSTR("G29 V1"));
+            lcd_goto_screen(_lcd_level_bed_done);
+
+          #elif ENABLED(MESH_BED_LEVELING)
+
+            _lcd_after_probing();
+
+            mbl.set_has_mesh(true);
+            mesh_probing_done();
+
+          #endif
+
+        }
+        else {
+          // MESH_BED_LEVELING: Z already stored, just move
+          //    PROBE_MANUALLY: Send G29 to record Z, then move
+          _lcd_level_goto_next_point();
+        }
+
+        return;
+      }
+
+      //
+      // Encoder knob or keypad buttons adjust the Z position
+      //
+      if (encoderPosition) {
+        refresh_cmd_timeout();
+        const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
+        line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5, (LCD_PROBE_Z_RANGE) * 0.5));
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        encoderPosition = 0;
+      }
+
+      //
+      // Draw on first display, then only on Z change
+      //
+      if (lcdDrawUpdate) {
+        const float v = current_position[Z_AXIS];
+        lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001 : 0.0001), '+'));
+      }
+    }
+
+    /**
+     * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
+     */
+
+    void _lcd_level_bed_moving() {
+      if (lcdDrawUpdate) {
+        char msg[10];
+        sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
+        lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+      }
+      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+      #if ENABLED(PROBE_MANUALLY)
+        if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
+      #endif
+    }
+
+    /**
+     * Step 5: Initiate a move to the next point
+     */
+    void _lcd_level_goto_next_point() {
+
+      // Set the menu to display ahead of blocking call
+      lcd_goto_screen(_lcd_level_bed_moving);
+
+      #if ENABLED(MESH_BED_LEVELING)
+
+        int8_t px, py;
+        mbl.zigzag(manual_probe_index, px, py);
+
+        // Controls the loop until the move is done
+        _manual_probe_goto_xy(
+          LOGICAL_X_POSITION(mbl.index_to_xpos[px]),
+          LOGICAL_Y_POSITION(mbl.index_to_ypos[py])
+        );
+
+        // After the blocking function returns, change menus
+        lcd_goto_screen(_lcd_level_bed_get_z);
+
+      #elif ENABLED(PROBE_MANUALLY)
+
+        // G29 Records Z, moves, and signals when it pauses
+        lcd_wait_for_move = true;
+        enqueue_and_echo_commands_P(PSTR("G29 V1"));
+
+      #endif
+    }
+
+    /**
+     * Step 4: Display "Click to Begin", wait for click
+     *         Move to the first probe position
+     */
+    void _lcd_level_bed_homing_done() {
+      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
+      if (lcd_clicked) {
+        manual_probe_index = 0;
+        _lcd_level_goto_next_point();
+      }
+    }
+
+    /**
+     * Step 3: Display "Homing XYZ" - Wait for homing to finish
+     */
+    void _lcd_level_bed_homing() {
+      if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_HOMING), NULL);
+      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        lcd_goto_screen(_lcd_level_bed_homing_done);
+    }
+
+    #if ENABLED(PROBE_MANUALLY)
+      extern bool g29_in_progress;
+    #endif
+
+    /**
+     * Step 2: Continue Bed Leveling...
+     */
+    void _lcd_level_bed_continue() {
+      defer_return_to_status = true;
+      axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
+      lcd_goto_screen(_lcd_level_bed_homing);
+      enqueue_and_echo_commands_P(PSTR("G28"));
+    }
+
+    static bool _level_state;
+    void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(_level_state); }
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      void _lcd_set_z_fade_height() { set_z_fade_height(planner.z_fade_height); }
+    #endif
+
+    /**
+     * Step 1: Bed Level entry-point
+     *
+     * << Prepare
+     *    Auto Home           (if homing needed)
+     *    Leveling On/Off     (if data exists, and homed)
+     *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
+     *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
+     *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
+     *    Level Bed >
+     *    Level Corners >     (if homed)
+     *    Load Settings       (Req: EEPROM_SETTINGS)
+     *    Save Settings       (Req: EEPROM_SETTINGS)
+     */
+    void lcd_bed_leveling() {
+      START_MENU();
+      MENU_BACK(MSG_PREPARE);
+
+      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
+        MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+      else if (leveling_is_valid()) {
+        _level_state = leveling_is_active();
+        MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &_level_state, _lcd_toggle_bed_leveling);
+      }
+
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        set_z_fade_height(planner.z_fade_height);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_Z_FADE_HEIGHT, &planner.z_fade_height, 0.0, 100.0, _lcd_set_z_fade_height);
+      #endif
+
+      //
+      // MBL Z Offset
+      //
+      #if ENABLED(MESH_BED_LEVELING)
+        MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+      #endif
+
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+      #elif HAS_BED_PROBE
+        MENU_ITEM_EDIT_CALLBACK(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, lcd_refresh_zprobe_zoffset);
+      #endif
+
+      MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+
+      #if ENABLED(LEVEL_BED_CORNERS)
+        // Move to the next corner for leveling
+        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+          MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+      #endif
+
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+      #endif
+      END_MENU();
+    }
+
+  #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+    void _lcd_ubl_level_bed();
+
+    static int16_t ubl_storage_slot = 0,
+               custom_hotend_temp = 190,
+               side_points = 3,
+               ubl_fillin_amount = 5,
+               ubl_height_amount = 1,
+               n_edit_pts = 1,
+               x_plot = 0,
+               y_plot = 0;
+
+    #if HAS_TEMP_BED
+      static int16_t custom_bed_temp = 50;
+    #endif
+
+    /**
+     * UBL Build Custom Mesh Command
+     */
+    void _lcd_ubl_build_custom_mesh() {
+      char UBL_LCD_GCODE[20];
+      enqueue_and_echo_commands_P(PSTR("G28"));
+      #if HAS_TEMP_BED
+        sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
+        enqueue_and_echo_command(UBL_LCD_GCODE);
+      #endif
+      sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+      enqueue_and_echo_commands_P(PSTR("G29 P1"));
+    }
+
+    /**
+     * UBL Custom Mesh submenu
+     *
+     * << Build Mesh
+     *    Hotend Temp: ---
+     *    Bed Temp: ---
+     *    Build Custom Mesh
+     */
+    void _lcd_ubl_custom_mesh() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
+      MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_HOTEND_TEMP, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
+      #if HAS_TEMP_BED
+        MENU_ITEM_EDIT(int3, MSG_UBL_CUSTOM_BED_TEMP, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 5));
+      #endif
+      MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
+      END_MENU();
+    }
+
+    /**
+     * UBL Adjust Mesh Height Command
+     */
+    void _lcd_ubl_adjust_height_cmd() {
+      char UBL_LCD_GCODE[16];
+      const int ind = ubl_height_amount < 0 ? 6 : 7;
+      strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6-"));
+      sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), abs(ubl_height_amount));
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Adjust Mesh Height submenu
+     *
+     * << Edit Mesh
+     *    Height Amount: ---
+     *    Adjust Mesh Height
+     * << Info Screen
+     */
+    void _lcd_ubl_height_adjust_menu() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_EDIT_MESH_MENU);
+      MENU_ITEM_EDIT(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9);
+      MENU_ITEM(function, MSG_UBL_MESH_HEIGHT_ADJUST, _lcd_ubl_adjust_height_cmd);
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    /**
+     * UBL Edit Mesh submenu
+     *
+     * << UBL Tools
+     *    Fine Tune All
+     *    Fine Tune Closest
+     *  - Adjust Mesh Height >>
+     * << Info Screen
+     */
+    void _lcd_ubl_edit_mesh() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_TOOLS);
+      MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+      MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_CLOSEST, PSTR("G29 P4 T"));
+      MENU_ITEM(submenu, MSG_UBL_MESH_HEIGHT_ADJUST, _lcd_ubl_height_adjust_menu);
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    /**
+     * UBL Validate Custom Mesh Command
+     */
+    void _lcd_ubl_validate_custom_mesh() {
+      char UBL_LCD_GCODE[24];
+      const int temp =
+        #if HAS_TEMP_BED
+          custom_bed_temp
+        #else
+          0
+        #endif
+      ;
+      sprintf_P(UBL_LCD_GCODE, PSTR("G28\nG26 C B%i H%i P"), temp, custom_hotend_temp);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Validate Mesh submenu
+     *
+     * << UBL Tools
+     *    PLA Mesh Validation
+     *    ABS Mesh Validation
+     *    Validate Custom Mesh
+     * << Info Screen
+     */
+    void _lcd_ubl_validate_mesh() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_TOOLS);
+      #if HAS_TEMP_BED
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+      #else
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_PLA_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+        MENU_ITEM(gcode, MSG_UBL_VALIDATE_ABS_MESH, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+      #endif
+      MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    /**
+     * UBL Grid Leveling Command
+     */
+    void _lcd_ubl_grid_level_cmd() {
+      char UBL_LCD_GCODE[10];
+      sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Grid Leveling submenu
+     *
+     * << UBL Tools
+     *    Side points: ---
+     *    Level Mesh
+     */
+    void _lcd_ubl_grid_level() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_TOOLS);
+      MENU_ITEM_EDIT(int3, MSG_UBL_SIDE_POINTS, &side_points, 2, 6);
+      MENU_ITEM(function, MSG_UBL_MESH_LEVEL, _lcd_ubl_grid_level_cmd);
+      END_MENU();
+    }
+
+    /**
+     * UBL Mesh Leveling submenu
+     *
+     * << UBL Tools
+     *    3-Point Mesh Leveling
+     *  - Grid Mesh Leveling >>
+     * << Info Screen
+     */
+    void _lcd_ubl_mesh_leveling() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_TOOLS);
+      MENU_ITEM(gcode, MSG_UBL_3POINT_MESH_LEVELING, PSTR("G29 J0"));
+      MENU_ITEM(submenu, MSG_UBL_GRID_MESH_LEVELING, _lcd_ubl_grid_level);
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    /**
+     * UBL Fill-in Amount Mesh Command
+     */
+    void _lcd_ubl_fillin_amount_cmd() {
+      char UBL_LCD_GCODE[16];
+      sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Smart Fill-in Command
+     */
+    void _lcd_ubl_smart_fillin_cmd() {
+      char UBL_LCD_GCODE[12];
+      sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 T0"));
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Fill-in Mesh submenu
+     *
+     * << Build Mesh
+     *    Fill-in Amount: ---
+     *    Fill-in Mesh
+     *    Smart Fill-in
+     *    Manual Fill-in
+     * << Info Screen
+     */
+    void _lcd_ubl_fillin_menu() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
+      MENU_ITEM_EDIT(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9);
+      MENU_ITEM(function, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_amount_cmd);
+      MENU_ITEM(function, MSG_UBL_SMART_FILLIN, _lcd_ubl_smart_fillin_cmd);
+      MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    void _lcd_ubl_invalidate() {
+      ubl.invalidate();
+      SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
+    }
+
+    /**
+     * UBL Build Mesh submenu
+     *
+     * << UBL Tools
+     *    Build PLA Mesh
+     *    Build ABS Mesh
+     *  - Build Custom Mesh >>
+     *    Build Cold Mesh
+     *  - Fill-in Mesh >>
+     *    Continue Bed Mesh
+     *    Invalidate All
+     *    Invalidate Closest
+     * << Info Screen
+     */
+    void _lcd_ubl_build_mesh() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_TOOLS);
+      #if HAS_TEMP_BED
+        MENU_ITEM(gcode, MSG_UBL_BUILD_PLA_MESH, PSTR(
+          "G28\n"
+          "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
+          "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
+          "G29 P1\n"
+          "M104 S0\n"
+          "M140 S0"
+        ));
+        MENU_ITEM(gcode, MSG_UBL_BUILD_ABS_MESH, PSTR(
+          "G28\n"
+          "M190 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\n"
+          "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
+          "G29 P1\n"
+          "M104 S0\n"
+          "M140 S0"
+        ));
+      #else
+        MENU_ITEM(gcode, MSG_UBL_BUILD_PLA_MESH, PSTR(
+          "G28\n"
+          "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
+          "G29 P1\n"
+          "M104 S0"
+        ));
+        MENU_ITEM(gcode, MSG_UBL_BUILD_ABS_MESH, PSTR(
+          "G28\n"
+          "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
+          "G29 P1\n"
+          "M104 S0"
+        ));
+      #endif
+      MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
+      MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
+      MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _lcd_ubl_fillin_menu);
+      MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
+      MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
+      MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
+      MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+      END_MENU();
+    }
+
+    /**
+     * UBL Load Mesh Command
+     */
+    void _lcd_ubl_load_mesh_cmd() {
+      char UBL_LCD_GCODE[25];
+      sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED "."), ubl_storage_slot);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Save Mesh Command
+     */
+    void _lcd_ubl_save_mesh_cmd() {
+      char UBL_LCD_GCODE[25];
+      sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+      sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED "."), ubl_storage_slot);
+      enqueue_and_echo_command(UBL_LCD_GCODE);
+    }
+
+    /**
+     * UBL Mesh Storage submenu
+     *
+     * << Unified Bed Leveling
+     *    Memory Slot: ---
+     *    Load Bed Mesh
+     *    Save Bed Mesh
+     */
+    void _lcd_ubl_storage_mesh() {
+      int16_t a = settings.calc_num_meshes();
+      START_MENU();
+      MENU_BACK(MSG_UBL_LEVEL_BED);
+      if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
+        STATIC_ITEM(MSG_NO_STORAGE);
+        STATIC_ITEM(MSG_INIT_EEPROM);
+      }
+      else {
+        MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
+        MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
+        MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
+      }
+      END_MENU();
+    }
+
+    /**
+     * UBL LCD "radar" map homing
+     */
+    void _lcd_ubl_output_map_lcd();
+
+    void _lcd_ubl_map_homing() {
+      defer_return_to_status = true;
+      ubl_lcd_map_control = true; // Return to the map screen
+      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT < 3 ? 0 : (LCD_HEIGHT > 4 ? 2 : 1), PSTR(MSG_LEVEL_BED_HOMING));
+      lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        lcd_goto_screen(_lcd_ubl_output_map_lcd);
+    }
+
+    /**
+     * UBL LCD "radar" map point editing
+     */
+    void _lcd_ubl_map_lcd_edit_cmd() {
+      char ubl_lcd_gcode [50], str[10], str2[10];
+
+      dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
+      dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
+      snprintf_P(ubl_lcd_gcode, sizeof(ubl_lcd_gcode), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
+      enqueue_and_echo_command(ubl_lcd_gcode);
+    }
+
+    /**
+     * UBL LCD Map Movement
+     */
+    void ubl_map_move_to_xy() {
+      current_position[X_AXIS] = LOGICAL_X_POSITION(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]));
+      current_position[Y_AXIS] = LOGICAL_Y_POSITION(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]));
+      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
+    }
+
+    /**
+     * UBL LCD "radar" map
+     */
+    void set_current_from_steppers_for_axis(const AxisEnum axis);
+    void sync_plan_position();
+
+    void _lcd_ubl_output_map_lcd() {
+      static int16_t step_scaler = 0;
+
+      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]))
+        return lcd_goto_screen(_lcd_ubl_map_homing);
+
+      if (lcd_clicked) return _lcd_ubl_map_lcd_edit_cmd();
+      ENCODER_DIRECTION_NORMAL();
+
+      if (encoderPosition) {
+        step_scaler += (int32_t)encoderPosition;
+        x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
+        if (abs(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM)
+          step_scaler = 0;
+        refresh_cmd_timeout();
+
+        encoderPosition = 0;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      }
+
+      // Encoder to the right (++)
+      if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
+      if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
+
+      // Encoder to the left (--)
+      if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
+      if (y_plot <= GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1)) y_plot = GRID_MAX_POINTS_Y - 1;
+
+      // Prevent underrun/overrun of plot numbers
+      x_plot = constrain(x_plot, GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1), GRID_MAX_POINTS_X + 1);
+      y_plot = constrain(y_plot, GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1), GRID_MAX_POINTS_Y + 1);
+
+      // Determine number of points to edit
+      #if IS_KINEMATIC
+        n_edit_pts = 9; //TODO: Delta accessible edit points
+      #else
+        const bool xc = WITHIN(x_plot, 1, GRID_MAX_POINTS_X - 2),
+                   yc = WITHIN(y_plot, 1, GRID_MAX_POINTS_Y - 2);
+        n_edit_pts = yc ? (xc ? 9 : 6) : (xc ? 6 : 4); // Corners
+      #endif
+
+      if (lcdDrawUpdate) {
+        lcd_implementation_ubl_plot(x_plot, y_plot);
+
+        ubl_map_move_to_xy(); // Move to current location
+
+        if (planner.movesplanned() > 1) { // if the nozzle is moving, cancel the move.  There is a new location
+          stepper.quick_stop();
+          set_current_from_steppers_for_axis(ALL_AXES);
+          sync_plan_position();
+          ubl_map_move_to_xy(); // Move to new location
+          refresh_cmd_timeout();
+        }
+      }
+    }
+
+    /**
+     * UBL Homing before LCD map
+     */
+    void _lcd_ubl_output_map_lcd_cmd() {
+      if (!(axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS])) {
+        axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
+        enqueue_and_echo_commands_P(PSTR("G28"));
+      }
+      lcd_goto_screen(_lcd_ubl_map_homing);
+    }
+
+    /**
+     * UBL Output map submenu
+     *
+     * << Unified Bed Leveling
+     *  Output for Host
+     *  Output for CSV
+     *  Off Printer Backup
+     *  Output Mesh Map
+     */
+    void _lcd_ubl_output_map() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_LEVEL_BED);
+      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_HOST, PSTR("G29 T0"));
+      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_CSV, PSTR("G29 T1"));
+      MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_BACKUP, PSTR("G29 S-1"));
+      MENU_ITEM(function, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map_lcd_cmd);
+      END_MENU();
+    }
+
+    /**
+     * UBL Tools submenu
+     *
+     * << Unified Bed Leveling
+     *  - Build Mesh >>
+     *  - Validate Mesh >>
+     *  - Edit Mesh >>
+     *  - Mesh Leveling >>
+     */
+    void _lcd_ubl_tools_menu() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_LEVEL_BED);
+      MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_MENU, _lcd_ubl_build_mesh);
+      MENU_ITEM(gcode, MSG_UBL_MANUAL_MESH, PSTR("G29 I999\nG29 P2 B T0"));
+      MENU_ITEM(submenu, MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+      MENU_ITEM(submenu, MSG_UBL_EDIT_MESH_MENU, _lcd_ubl_edit_mesh);
+      MENU_ITEM(submenu, MSG_UBL_MESH_LEVELING, _lcd_ubl_mesh_leveling);
+      END_MENU();
+    }
+
+    /**
+     * UBL Step-By-Step submenu
+     *
+     * << Unified Bed Leveling
+     *    1 Build Cold Mesh
+     *    2 Smart Fill-in
+     *  - 3 Validate Mesh >>
+     *    4 Fine Tune All
+     *  - 5 Validate Mesh >>
+     *    6 Fine Tune All
+     *    7 Save Bed Mesh
+     */
+    void _lcd_ubl_step_by_step() {
+      START_MENU();
+      MENU_BACK(MSG_UBL_LEVEL_BED);
+      MENU_ITEM(gcode, "1 " MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
+      MENU_ITEM(function, "2 " MSG_UBL_SMART_FILLIN, _lcd_ubl_smart_fillin_cmd);
+      MENU_ITEM(submenu, "3 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+      MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+      MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+      MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+      MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
+      END_MENU();
+    }
+
+    /**
+     * UBL System submenu
+     *
+     * << Prepare
+     *  - Manually Build Mesh >>
+     *  - Activate UBL >>
+     *  - Deactivate UBL >>
+     *  - Step-By-Step UBL >>
+     *  - Mesh Storage >>
+     *  - Output Map >>
+     *  - UBL Tools >>
+     *  - Output UBL Info >>
+     */
+
+    void _lcd_ubl_level_bed() {
+      START_MENU();
+      MENU_BACK(MSG_PREPARE);
+      MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
+      MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
+      MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
+      MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
+      MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
+      MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
+      MENU_ITEM(submenu, MSG_UBL_TOOLS, _lcd_ubl_tools_menu);
+      MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
+      END_MENU();
+    }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+  /**
+   *
+   * "Prepare" submenu
+   *
+   */
+
+  void lcd_prepare_menu() {
+    START_MENU();
+
+    //
+    // ^ Main
+    //
+    MENU_BACK(MSG_MAIN);
+
+    //
+    // Move Axis
+    //
+    #if ENABLED(DELTA)
+      if (axis_homed[Z_AXIS])
+    #endif
+        MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
+
+    //
+    // Auto Home
+    //
+    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
+      MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
+      MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
+      MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
+    #endif
+
+    //
+    // Level Bed
+    //
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
+    #elif ENABLED(LCD_BED_LEVELING)
+      #if ENABLED(PROBE_MANUALLY)
+        if (!g29_in_progress)
+      #endif
+      MENU_ITEM(submenu, MSG_BED_LEVELING, lcd_bed_leveling);
+    #else
+      #if PLANNER_LEVELING
+        MENU_ITEM(gcode, MSG_BED_LEVELING, PSTR("G28\nG29"));
+      #endif
+      #if ENABLED(LEVEL_BED_CORNERS)
+        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+          MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+      #endif
+    #endif
+
+    #if HAS_M206_COMMAND
+      //
+      // Set Home Offsets
+      //
+      MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
+      //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
+    #endif
+
+    //
+    // Disable Steppers
+    //
+    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
+
+    //
+    // Change filament
+    //
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      if (!thermalManager.tooColdToExtrude(active_extruder) && !IS_SD_FILE_OPEN)
+        MENU_ITEM(function, MSG_FILAMENTCHANGE, lcd_enqueue_filament_change);
+    #endif
+
+    #if TEMP_SENSOR_0 != 0
+
+      //
+      // Cooldown
+      //
+      bool has_heat = false;
+      HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
+      #if HAS_TEMP_BED
+        if (thermalManager.target_temperature_bed) has_heat = true;
+      #endif
+      if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+
+      //
+      // Preheat for Material 1 and 2
+      //
+      #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || TEMP_SENSOR_BED != 0
+        MENU_ITEM(submenu, MSG_PREHEAT_1, lcd_preheat_m1_menu);
+        MENU_ITEM(submenu, MSG_PREHEAT_2, lcd_preheat_m2_menu);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
+      #endif
+
+    #endif // TEMP_SENSOR_0 != 0
+
+    //
+    // BLTouch Self-Test and Reset
+    //
+    #if ENABLED(BLTOUCH)
+      MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+      if (!endstops.z_probe_enabled && TEST_BLTOUCH())
+        MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_ENDSTOP_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+    #endif
+
+    //
+    // Switch power on/off
+    //
+    #if HAS_POWER_SWITCH
+      if (powersupply_on)
+        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
+      else
+        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+    #endif
+
+    //
+    // Autostart
+    //
+    #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+    #endif
+
+    //
+    // Delta Calibration
+    //
+    #if ENABLED(DELTA_CALIBRATION_MENU)
+      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
+    #endif
+
+    END_MENU();
+  }
+
+  float move_menu_scale;
+
+  #if ENABLED(DELTA_CALIBRATION_MENU)
+
+    void lcd_move_z();
+    void lcd_delta_calibrate_menu();
+
+    void _lcd_calibrate_homing() {
+      if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_HOMING));
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+        lcd_goto_previous_menu();
+    }
+
+    void _lcd_delta_calibrate_home() {
+      #if HAS_LEVELING
+        reset_bed_level(); // After calibration bed-level data is no longer valid
+      #endif
+
+      enqueue_and_echo_commands_P(PSTR("G28"));
+      lcd_goto_screen(_lcd_calibrate_homing);
+    }
+
+    void _man_probe_pt(const float &lx, const float &ly) {
+      #if HAS_LEVELING
+        reset_bed_level(); // After calibration bed-level data is no longer valid
+      #endif
+
+      float z_dest = LOGICAL_Z_POSITION((Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5);
+      line_to_z(z_dest);
+      current_position[X_AXIS] = LOGICAL_X_POSITION(lx);
+      current_position[Y_AXIS] = LOGICAL_Y_POSITION(ly);
+      line_to_current_z();
+      z_dest = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
+      line_to_z(z_dest);
+
+      lcd_synchronize();
+      move_menu_scale = PROBE_MANUALLY_STEP;
+      lcd_goto_screen(lcd_move_z);
+    }
+
+    float lcd_probe_pt(const float &lx, const float &ly) {
+      _man_probe_pt(lx, ly);
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      defer_return_to_status = true;
+      wait_for_user = true;
+      while (wait_for_user) idle();
+      KEEPALIVE_STATE(IN_HANDLER);
+      lcd_goto_previous_menu_no_defer();
+      return current_position[Z_AXIS];
+    }
+
+    void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
+    void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
+    void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
+    void _goto_center()  { _man_probe_pt(0,0); }
+
+    static float _delta_height = DELTA_HEIGHT;
+    void _lcd_set_delta_height() {
+      home_offset[Z_AXIS] = _delta_height - DELTA_HEIGHT;
+      update_software_endstops(Z_AXIS);
+    }
+
+    void lcd_delta_settings() {
+      START_MENU();
+      MENU_BACK(MSG_DELTA_CALIBRATE);
+      float Tz = 0.00;
+      MENU_ITEM_EDIT(float52, MSG_DELTA_DIAG_ROG, &delta_diagonal_rod, DELTA_DIAGONAL_ROD - 5.0, DELTA_DIAGONAL_ROD + 5.0);
+      _delta_height = DELTA_HEIGHT + home_offset[Z_AXIS];
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_DELTA_HEIGHT, &_delta_height, _delta_height - 10.0, _delta_height + 10.0, _lcd_set_delta_height);
+      MENU_ITEM_EDIT(float43, "Ex", &endstop_adj[A_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ey", &endstop_adj[B_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ez", &endstop_adj[C_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float52, MSG_DELTA_RADIUS, &delta_radius, DELTA_RADIUS - 5.0, DELTA_RADIUS + 5.0);
+      MENU_ITEM_EDIT(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5.0, 5.0);
+      MENU_ITEM_EDIT(float43, "Tz", &Tz, -5.0, 5.0);
+      END_MENU();
+    }
+
+    void lcd_delta_calibrate_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      #if ENABLED(DELTA_AUTO_CALIBRATION)
+        MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
+        MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
+        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 P1"));
+        #if ENABLED(EEPROM_SETTINGS)
+          MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+          MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+        #endif
+      #endif
+      MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
+      if (axis_homed[Z_AXIS]) {
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
+      }
+      END_MENU();
+    }
+
+  #endif // DELTA_CALIBRATION_MENU
+
+  /**
+   * If the most recent manual move hasn't been fed to the planner yet,
+   * and the planner can accept one, send immediately
+   */
+  inline void manage_manual_move() {
+    if (manual_move_axis != (int8_t)NO_AXIS && ELAPSED(millis(), manual_move_start_time) && !planner.is_full()) {
+      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(manual_feedrate_mm_m[manual_move_axis]), manual_move_e_index);
+      manual_move_axis = (int8_t)NO_AXIS;
+    }
+  }
+
+  /**
+   * Set a flag that lcd_update() should start a move
+   * to "current_position" after a short delay.
+   */
+  inline void manual_move_to_current(AxisEnum axis
+    #if E_MANUAL > 1
+      , int8_t eindex=-1
+    #endif
+  ) {
+    #if E_MANUAL > 1
+      if (axis == E_AXIS) manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
+    #endif
+    manual_move_start_time = millis() + (move_menu_scale < 0.99 ? 0UL : 250UL); // delay for bigger moves
+    manual_move_axis = (int8_t)axis;
+  }
+
+  /**
+   *
+   * "Prepare" > "Move Axis" submenu
+   *
+   */
+
+  void _lcd_move_xyz(const char* name, AxisEnum axis) {
+    if (lcd_clicked) { return lcd_goto_previous_menu(); }
+    ENCODER_DIRECTION_NORMAL();
+    if (encoderPosition) {
+      refresh_cmd_timeout();
+
+      float min = current_position[axis] - 1000,
+            max = current_position[axis] + 1000;
+
+      #if HAS_SOFTWARE_ENDSTOPS
+        // Limit to software endstops, if enabled
+        if (soft_endstops_enabled) {
+          #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
+            min = soft_endstop_min[axis];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+            max = soft_endstop_max[axis];
+          #endif
+        }
+      #endif
+
+      // Get the new position
+      current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
+
+      // Delta limits XY based on the current offset from center
+      // This assumes the center is 0,0
+      #if ENABLED(DELTA)
+        if (axis != Z_AXIS) {
+          max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis]));
+          min = -max;
+        }
+      #endif
+
+      // Limit only when trying to move towards the limit
+      if ((int32_t)encoderPosition < 0) NOLESS(current_position[axis], min);
+      if ((int32_t)encoderPosition > 0) NOMORE(current_position[axis], max);
+
+      manual_move_to_current(axis);
+
+      encoderPosition = 0;
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+    if (lcdDrawUpdate)
+      lcd_implementation_drawedit(name, move_menu_scale >= 0.1 ? ftostr41sign(current_position[axis]) : ftostr43sign(current_position[axis]));
+  }
+  void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
+  void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
+  void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
+  void _lcd_move_e(
+    #if E_MANUAL > 1
+      int8_t eindex=-1
+    #endif
+  ) {
+    if (lcd_clicked) { return lcd_goto_previous_menu(); }
+    ENCODER_DIRECTION_NORMAL();
+    if (encoderPosition) {
+      current_position[E_AXIS] += float((int32_t)encoderPosition) * move_menu_scale;
+      encoderPosition = 0;
+      manual_move_to_current(E_AXIS
+        #if E_MANUAL > 1
+          , eindex
+        #endif
+      );
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+    if (lcdDrawUpdate) {
+      PGM_P pos_label;
+      #if E_MANUAL == 1
+        pos_label = PSTR(MSG_MOVE_E);
+      #else
+        switch (eindex) {
+          default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
+          case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
+          #if E_MANUAL > 2
+            case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
+            #if E_MANUAL > 3
+              case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
+              #if E_MANUAL > 4
+                case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
+              #endif // E_MANUAL > 4
+            #endif // E_MANUAL > 3
+          #endif // E_MANUAL > 2
+        }
+      #endif // E_MANUAL > 1
+      lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]));
+    }
+  }
+
+  void lcd_move_e() { _lcd_move_e(); }
+  #if E_MANUAL > 1
+    void lcd_move_e0() { _lcd_move_e(0); }
+    void lcd_move_e1() { _lcd_move_e(1); }
+    #if E_MANUAL > 2
+      void lcd_move_e2() { _lcd_move_e(2); }
+      #if E_MANUAL > 3
+        void lcd_move_e3() { _lcd_move_e(3); }
+        #if E_MANUAL > 4
+          void lcd_move_e4() { _lcd_move_e(4); }
+        #endif // E_MANUAL > 4
+      #endif // E_MANUAL > 3
+    #endif // E_MANUAL > 2
+  #endif // E_MANUAL > 1
+
+  /**
+   *
+   * "Prepare" > "Move Xmm" > "Move XYZ" submenu
+   *
+   */
+
+  screenFunc_t _manual_move_func_ptr;
+
+  void _goto_manual_move(const float scale) {
+    defer_return_to_status = true;
+    move_menu_scale = scale;
+    lcd_goto_screen(_manual_move_func_ptr);
+  }
+  void lcd_move_menu_10mm() { _goto_manual_move(10.0); }
+  void lcd_move_menu_1mm()  { _goto_manual_move( 1.0); }
+  void lcd_move_menu_01mm() { _goto_manual_move( 0.1); }
+
+  void _lcd_move_distance_menu(const AxisEnum axis, const screenFunc_t func) {
+    _manual_move_func_ptr = func;
+    START_MENU();
+    if (LCD_HEIGHT >= 4) {
+      switch(axis) {
+        case X_AXIS:
+          STATIC_ITEM(MSG_MOVE_X, true, true); break;
+        case Y_AXIS:
+          STATIC_ITEM(MSG_MOVE_Y, true, true); break;
+        case Z_AXIS:
+          STATIC_ITEM(MSG_MOVE_Z, true, true); break;
+        default:
+          STATIC_ITEM(MSG_MOVE_E, true, true); break;
+      }
+    }
+    MENU_BACK(MSG_MOVE_AXIS);
+    MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
+    MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
+    MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
+    END_MENU();
+  }
+  void lcd_move_get_x_amount()        { _lcd_move_distance_menu(X_AXIS, lcd_move_x); }
+  void lcd_move_get_y_amount()        { _lcd_move_distance_menu(Y_AXIS, lcd_move_y); }
+  void lcd_move_get_z_amount()        { _lcd_move_distance_menu(Z_AXIS, lcd_move_z); }
+  void lcd_move_get_e_amount()        { _lcd_move_distance_menu(E_AXIS, lcd_move_e); }
+  #if E_MANUAL > 1
+    void lcd_move_get_e0_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e0); }
+    void lcd_move_get_e1_amount()     { _lcd_move_distance_menu(E_AXIS, lcd_move_e1); }
+    #if E_MANUAL > 2
+      void lcd_move_get_e2_amount()   { _lcd_move_distance_menu(E_AXIS, lcd_move_e2); }
+      #if E_MANUAL > 3
+        void lcd_move_get_e3_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e3); }
+        #if E_MANUAL > 4
+          void lcd_move_get_e4_amount() { _lcd_move_distance_menu(E_AXIS, lcd_move_e4); }
+        #endif // E_MANUAL > 4
+      #endif // E_MANUAL > 3
+    #endif // E_MANUAL > 2
+  #endif // E_MANUAL > 1
+
+  /**
+   *
+   * "Prepare" > "Move Axis" submenu
+   *
+   */
+
+  #if IS_KINEMATIC
+    #define _MOVE_XYZ_ALLOWED (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS])
+    #if ENABLED(DELTA)
+      #define _MOVE_XY_ALLOWED (current_position[Z_AXIS] <= delta_clip_start_height)
+      void lcd_lower_z_to_clip_height() {
+        line_to_z(delta_clip_start_height);
+        lcd_synchronize();
+      }
+    #else
+      #define _MOVE_XY_ALLOWED true
+    #endif
+  #else
+    #define _MOVE_XYZ_ALLOWED true
+    #define _MOVE_XY_ALLOWED true
+  #endif
+
+  void lcd_move_menu() {
+    START_MENU();
+    MENU_BACK(MSG_PREPARE);
+
+    if (_MOVE_XYZ_ALLOWED) {
+      if (_MOVE_XY_ALLOWED) {
+        MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
+        MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
+      }
+      #if ENABLED(DELTA)
+        else
+          MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
+      #endif
+
+      MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
+    }
+    else
+      MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+
+    #if ENABLED(SWITCHING_EXTRUDER)
+      if (active_extruder)
+        MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+      else
+        MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+    #endif
+
+    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
+    #if E_MANUAL > 1
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
+      #if E_MANUAL > 2
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
+        #if E_MANUAL > 3
+          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
+          #if E_MANUAL > 4
+            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+          #endif // E_MANUAL > 4
+        #endif // E_MANUAL > 3
+      #endif // E_MANUAL > 2
+    #endif // E_MANUAL > 1
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Control" submenu
+   *
+   */
+
+  #if HAS_LCD_CONTRAST
+    void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
+  #endif
+
+  static void lcd_factory_settings() {
+    settings.reset();
+    lcd_completion_feedback();
+  }
+
+  void lcd_control_menu() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);
+    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);
+    MENU_ITEM(submenu, MSG_FILAMENT, lcd_control_filament_menu);
+
+    #if HAS_LCD_CONTRAST
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, (int16_t*)&lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+    #endif
+    #if ENABLED(FWRETRACT)
+      MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);
+    #endif
+    #if ENABLED(DAC_STEPPER_CURRENT)
+      MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_dac_menu);
+    #endif
+    #if HAS_MOTOR_CURRENT_PWM
+      MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, lcd_pwm_menu);
+    #endif
+
+    #if ENABLED(BLTOUCH)
+      MENU_ITEM(submenu, MSG_BLTOUCH, bltouch_menu);
+    #endif
+
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+    #endif
+    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(gcode, MSG_INIT_EEPROM, PSTR("M502\nM500")); // TODO: Add "Are You Sure?" step
+    #endif
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Temperature" submenu
+   *
+   */
+
+  #if ENABLED(PID_AUTOTUNE_MENU)
+
+    #if ENABLED(PIDTEMP)
+      int16_t autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
+    #endif
+
+    #if ENABLED(PIDTEMPBED)
+      int16_t autotune_temp_bed = 70;
+    #endif
+
+    void _lcd_autotune(int16_t e) {
+      char cmd[30];
+      sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
+        #if HAS_PID_FOR_BOTH
+          e < 0 ? autotune_temp_bed : autotune_temp[e]
+        #elif ENABLED(PIDTEMPBED)
+          autotune_temp_bed
+        #else
+          autotune_temp[e]
+        #endif
+      );
+      enqueue_and_echo_command(cmd);
+    }
+
+  #endif // PID_AUTOTUNE_MENU
+
+  #if ENABLED(PIDTEMP)
+
+    // Helpers for editing PID Ki & Kd values
+    // grab the PID value out of the temp variable; scale it; then update the PID driver
+    void copy_and_scalePID_i(int16_t e) {
+      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
+        UNUSED(e);
+      #endif
+      PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
+      thermalManager.updatePID();
+    }
+    void copy_and_scalePID_d(int16_t e) {
+      #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
+        UNUSED(e);
+      #endif
+      PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
+      thermalManager.updatePID();
+    }
+    #define _DEFINE_PIDTEMP_BASE_FUNCS(N) \
+      void copy_and_scalePID_i_E ## N() { copy_and_scalePID_i(N); } \
+      void copy_and_scalePID_d_E ## N() { copy_and_scalePID_d(N); }
+
+    #if ENABLED(PID_AUTOTUNE_MENU)
+      #define DEFINE_PIDTEMP_FUNCS(N) \
+        _DEFINE_PIDTEMP_BASE_FUNCS(N); \
+        void lcd_autotune_callback_E ## N() { _lcd_autotune(N); } typedef void _pid_##N##_void
+    #else
+      #define DEFINE_PIDTEMP_FUNCS(N) _DEFINE_PIDTEMP_BASE_FUNCS(N) typedef void _pid_##N##_void
+    #endif
+
+    DEFINE_PIDTEMP_FUNCS(0);
+    #if ENABLED(PID_PARAMS_PER_HOTEND)
+      #if HOTENDS > 1
+        DEFINE_PIDTEMP_FUNCS(1);
+        #if HOTENDS > 2
+          DEFINE_PIDTEMP_FUNCS(2);
+          #if HOTENDS > 3
+            DEFINE_PIDTEMP_FUNCS(3);
+            #if HOTENDS > 4
+              DEFINE_PIDTEMP_FUNCS(4);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #endif // HOTENDS > 1
+    #endif // PID_PARAMS_PER_HOTEND
+
+  #endif // PIDTEMP
+
+  /**
+   *
+   * "Control" > "Temperature" submenu
+   *
+   */
+  void lcd_control_temperature_menu() {
+    START_MENU();
+
+    //
+    // ^ Control
+    //
+    MENU_BACK(MSG_CONTROL);
+
+    //
+    // Nozzle:
+    // Nozzle [1-5]:
+    //
+    #if HOTENDS == 1
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+    #else // HOTENDS > 1
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+      #if HOTENDS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
+        #if HOTENDS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+          #if HOTENDS > 4
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+
+    //
+    // Bed:
+    //
+    #if HAS_TEMP_BED
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+    #endif
+
+    //
+    // Fan Speed:
+    //
+    #if FAN_COUNT > 0
+      #if HAS_FAN0
+        #if FAN_COUNT > 1
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED " 1"
+        #else
+          #define MSG_1ST_FAN_SPEED MSG_FAN_SPEED
+        #endif
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_1ST_FAN_SPEED, &fanSpeeds[0], 0, 255);
+      #endif
+      #if HAS_FAN1
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 2", &fanSpeeds[1], 0, 255);
+      #endif
+      #if HAS_FAN2
+        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED " 3", &fanSpeeds[2], 0, 255);
+      #endif
+    #endif // FAN_COUNT > 0
+
+    //
+    // Autotemp, Min, Max, Fact
+    //
+    #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)
+      MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
+      MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, HEATER_0_MAXTEMP - 15);
+      MENU_ITEM_EDIT(float32, MSG_FACTOR, &planner.autotemp_factor, 0.0, 1.0);
+    #endif
+
+    //
+    // PID-P, PID-I, PID-D, PID-C, PID Autotune
+    // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
+    // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
+    // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
+    // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
+    // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
+    //
+    #if ENABLED(PIDTEMP)
+
+      #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
+        raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
+        raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
+        MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \
+        MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
+
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        #define _PID_MENU_ITEMS(ELABEL, eindex) \
+          _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
+          MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
+      #else
+        #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
+      #endif
+
+      #if ENABLED(PID_AUTOTUNE_MENU)
+        #define PID_MENU_ITEMS(ELABEL, eindex) \
+          _PID_MENU_ITEMS(ELABEL, eindex); \
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
+      #else
+        #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
+      #endif
+
+      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+        PID_MENU_ITEMS(" " MSG_E1, 0);
+        PID_MENU_ITEMS(" " MSG_E2, 1);
+        #if HOTENDS > 2
+          PID_MENU_ITEMS(" " MSG_E3, 2);
+          #if HOTENDS > 3
+            PID_MENU_ITEMS(" " MSG_E4, 3);
+            #if HOTENDS > 4
+              PID_MENU_ITEMS(" " MSG_E5, 4);
+            #endif // HOTENDS > 4
+          #endif // HOTENDS > 3
+        #endif // HOTENDS > 2
+      #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
+        PID_MENU_ITEMS("", 0);
+      #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
+
+    #endif // PIDTEMP
+
+    //
+    // Preheat Material 1 conf
+    //
+    MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, lcd_control_temperature_preheat_material1_settings_menu);
+
+    //
+    // Preheat Material 2 conf
+    //
+    MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, lcd_control_temperature_preheat_material2_settings_menu);
+    END_MENU();
+  }
+
+  void _lcd_control_temperature_preheat_settings_menu(uint8_t material) {
+    #if HOTENDS > 4
+      #define MINTEMP_ALL MIN5(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
+      #define MAXTEMP_ALL MAX5(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
+    #elif HOTENDS > 3
+      #define MINTEMP_ALL MIN4(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
+      #define MAXTEMP_ALL MAX4(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
+    #elif HOTENDS > 2
+      #define MINTEMP_ALL MIN3(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
+      #define MAXTEMP_ALL MAX3(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
+    #elif HOTENDS > 1
+      #define MINTEMP_ALL min(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
+      #define MAXTEMP_ALL max(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
+    #else
+      #define MINTEMP_ALL HEATER_0_MINTEMP
+      #define MAXTEMP_ALL HEATER_0_MAXTEMP
+    #endif
+    START_MENU();
+    MENU_BACK(MSG_TEMPERATURE);
+    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
+    #if TEMP_SENSOR_0 != 0
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
+    #endif
+    #if TEMP_SENSOR_BED != 0
+      MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
+    #endif
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+    #endif
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Temperature" > "Preheat Material 1 conf" submenu
+   *
+   */
+  void lcd_control_temperature_preheat_material1_settings_menu() { _lcd_control_temperature_preheat_settings_menu(0); }
+
+  /**
+   *
+   * "Temperature" > "Preheat Material 2 conf" submenu
+   *
+   */
+  void lcd_control_temperature_preheat_material2_settings_menu() { _lcd_control_temperature_preheat_settings_menu(1); }
+
+
+  /**
+   *
+   * "Control" > "Motion" submenu
+   *
+   */
+
+  void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
+  #if ENABLED(DISTINCT_E_FACTORS)
+    void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
+    void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
+    void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
+    #if E_STEPPERS > 2
+      void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
+      #if E_STEPPERS > 3
+        void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
+        #if E_STEPPERS > 4
+          void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
+        #endif // E_STEPPERS > 4
+      #endif // E_STEPPERS > 3
+    #endif // E_STEPPERS > 2
+  #endif
+
+  void _planner_refresh_positioning() { planner.refresh_positioning(); }
+  #if ENABLED(DISTINCT_E_FACTORS)
+    void _planner_refresh_e_positioning(const uint8_t e) {
+      if (e == active_extruder)
+        _planner_refresh_positioning();
+      else
+        planner.steps_to_mm[E_AXIS + e] = 1.0 / planner.axis_steps_per_mm[E_AXIS + e];
+    }
+    void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
+    void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
+    #if E_STEPPERS > 2
+      void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
+      #if E_STEPPERS > 3
+        void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
+        #if E_STEPPERS > 4
+          void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
+        #endif // E_STEPPERS > 4
+      #endif // E_STEPPERS > 3
+    #endif // E_STEPPERS > 2
+  #endif
+
+  // M203 / M205 Velocity options
+  void lcd_control_motion_velocity_menu() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+
+    // M203 Max Feedrate
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &planner.max_feedrate_mm_s[X_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &planner.max_feedrate_mm_s[Y_AXIS], 1, 999);
+    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &planner.max_feedrate_mm_s[Z_AXIS], 1, 999);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+      #if E_STEPPERS > 2
+        MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+        #if E_STEPPERS > 3
+          MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+          #if E_STEPPERS > 4
+            MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.max_feedrate_mm_s[E_AXIS], 1, 999);
+    #endif
+
+    // M205 S Min Feedrate
+    MENU_ITEM_EDIT(float3, MSG_VMIN, &planner.min_feedrate_mm_s, 0, 999);
+
+    // M205 T Min Travel Feedrate
+    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.min_travel_feedrate_mm_s, 0, 999);
+
+    END_MENU();
+  }
+
+  // M201 / M204 Accelerations
+  void lcd_control_motion_acceleration_menu() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+
+    // M204 P Acceleration
+    MENU_ITEM_EDIT(float5, MSG_ACC, &planner.acceleration, 10, 99000);
+
+    // M204 R Retract Acceleration
+    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.retract_acceleration, 100, 99000);
+
+    // M204 T Travel Acceleration
+    MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.travel_acceleration, 100, 99000);
+
+    // M201 settings
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &planner.max_acceleration_mm_per_s2[X_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &planner.max_acceleration_mm_per_s2[Y_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &planner.max_acceleration_mm_per_s2[Z_AXIS], 10, 99000, _reset_acceleration_rates);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+      #if E_STEPPERS > 2
+        MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+        #if E_STEPPERS > 3
+          MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+          #if E_STEPPERS > 4
+            MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+    #endif
+
+    END_MENU();
+  }
+
+  // M205 Jerk
+  void lcd_control_motion_jerk_menu() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+
+    MENU_ITEM_EDIT(float3, MSG_VX_JERK, &planner.max_jerk[X_AXIS], 1, 990);
+    MENU_ITEM_EDIT(float3, MSG_VY_JERK, &planner.max_jerk[Y_AXIS], 1, 990);
+    #if ENABLED(DELTA)
+      MENU_ITEM_EDIT(float3, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 1, 990);
+    #else
+      MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &planner.max_jerk[Z_AXIS], 0.1, 990);
+    #endif
+    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+
+    END_MENU();
+  }
+
+  // M92 Steps-per-mm
+  void lcd_control_motion_steps_per_mm_menu() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_XSTEPS, &planner.axis_steps_per_mm[X_AXIS], 5, 9999, _planner_refresh_positioning);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_YSTEPS, &planner.axis_steps_per_mm[Y_AXIS], 5, 9999, _planner_refresh_positioning);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ZSTEPS, &planner.axis_steps_per_mm[Z_AXIS], 5, 9999, _planner_refresh_positioning);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
+      #if E_STEPPERS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
+        #if E_STEPPERS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
+          #if E_STEPPERS > 4
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
+    #endif
+
+    END_MENU();
+  }
+
+  void lcd_control_motion_menu() {
+    START_MENU();
+    MENU_BACK(MSG_CONTROL);
+
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+    #elif HAS_BED_PROBE
+      MENU_ITEM_EDIT_CALLBACK(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, lcd_refresh_zprobe_zoffset);
+    #endif
+
+    // M203 / M205 - Feedrate items
+    MENU_ITEM(submenu, MSG_VELOCITY, lcd_control_motion_velocity_menu);
+
+    // M201 - Acceleration items
+    MENU_ITEM(submenu, MSG_ACCELERATION, lcd_control_motion_acceleration_menu);
+
+    // M205 - Max Jerk
+    MENU_ITEM(submenu, MSG_JERK, lcd_control_motion_jerk_menu);
+
+    // M92 - Steps Per mm
+    MENU_ITEM(submenu, MSG_STEPS_PER_MM, lcd_control_motion_steps_per_mm_menu);
+
+    // M540 S - Abort on endstop hit when SD printing
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+      MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &stepper.abort_on_endstop_hit);
+    #endif
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Control" > "Filament" submenu
+   *
+   */
+  void lcd_control_filament_menu() {
+    START_MENU();
+    MENU_BACK(MSG_CONTROL);
+
+    #if ENABLED(LIN_ADVANCE)
+      MENU_ITEM_EDIT(float3, MSG_ADVANCE_K, &planner.extruder_advance_k, 0, 999);
+    #endif
+
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);
+
+    if (volumetric_enabled) {
+      #if EXTRUDERS == 1
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+      #else // EXTRUDERS > 1
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
+        #if EXTRUDERS > 2
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
+            #if EXTRUDERS > 4
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &filament_size[4], 1.5, 3.25, calculate_volumetric_multipliers);
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
+    }
+
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Control" > "Retract" submenu
+   *
+   */
+  #if ENABLED(FWRETRACT)
+
+    void lcd_control_retract_menu() {
+      START_MENU();
+      MENU_BACK(MSG_CONTROL);
+      MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);
+      #if EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &swap_retract_length, 0, 100);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate_mm_s, 1, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, -100, 100);
+      #if EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &swap_retract_recover_length, -100, 100);
+      #endif
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate_mm_s, 1, 999);
+      END_MENU();
+    }
+
+  #endif // FWRETRACT
+
+  #if ENABLED(SDSUPPORT)
+
+    #if !PIN_EXISTS(SD_DETECT)
+      void lcd_sd_refresh() {
+        card.initsd();
+        encoderTopLine = 0;
+      }
+    #endif
+
+    void lcd_sd_updir() {
+      card.updir();
+      encoderTopLine = 0;
+      screen_changed = true;
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+    }
+
+    /**
+     *
+     * "Print from SD" submenu
+     *
+     */
+    void lcd_sdcard_menu() {
+      ENCODER_DIRECTION_MENUS();
+      if (!lcdDrawUpdate && !lcd_clicked) return; // nothing to do (so don't thrash the SD card)
+      const uint16_t fileCnt = card.get_num_Files();
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      card.getWorkDirName();
+      if (card.filename[0] == '/') {
+        #if !PIN_EXISTS(SD_DETECT)
+          MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
+        #endif
+      }
+      else {
+        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+      }
+
+      if (fileCnt) {
+        for (uint16_t i = 0; i < fileCnt; i++) {
+          if (_menuLineNr == _thisItemNr) {
+            const uint16_t nr =
+              #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
+                fileCnt - 1 -
+              #endif
+            i;
+
+            #if ENABLED(SDCARD_SORT_ALPHA)
+              card.getfilename_sorted(nr);
+            #else
+              card.getfilename(nr);
+            #endif
+
+            if (card.filenameIsDir)
+              MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
+            else
+              MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
+          }
+          else {
+            MENU_ITEM_DUMMY();
+          }
+        }
+      }
+      END_MENU();
+    }
+
+  #endif // SDSUPPORT
+
+  #if ENABLED(LCD_INFO_MENU)
+
+    #if ENABLED(PRINTCOUNTER)
+      /**
+       *
+       * About Printer > Statistics submenu
+       *
+       */
+      void lcd_info_stats_menu() {
+        if (lcd_clicked) { return lcd_goto_previous_menu(); }
+
+        char buffer[21];
+        printStatistics stats = print_job_timer.getStats();
+
+        START_SCREEN();                                                                                // 12345678901234567890
+        STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));          // Print Count: 999
+        STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints));   // Completed  : 666
+
+        duration_t elapsed = stats.printTime;
+        elapsed.toString(buffer);
+
+        STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", false, false);                                           // Total print Time:
+        STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
+
+        elapsed = stats.longestPrint;
+        elapsed.toString(buffer);
+
+        STATIC_ITEM(MSG_INFO_PRINT_LONGEST ": ", false, false);                                        // Longest job time:
+        STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
+
+        sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
+        STATIC_ITEM(MSG_INFO_PRINT_FILAMENT ": ", false, false);                                       // Extruded total:
+        STATIC_ITEM("", false, false, buffer);                                                         // 125m
+        END_SCREEN();
+      }
+    #endif // PRINTCOUNTER
+
+    /**
+     *
+     * About Printer > Thermistors
+     *
+     */
+    void lcd_info_thermistors_menu() {
+      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      START_SCREEN();
+      #define THERMISTOR_ID TEMP_SENSOR_0
+      #include "thermistornames.h"
+      STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
+
+      #if TEMP_SENSOR_1 != 0
+        #undef THERMISTOR_ID
+        #define THERMISTOR_ID TEMP_SENSOR_1
+        #include "thermistornames.h"
+        STATIC_ITEM("T1: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP), false);
+      #endif
+
+      #if TEMP_SENSOR_2 != 0
+        #undef THERMISTOR_ID
+        #define THERMISTOR_ID TEMP_SENSOR_2
+        #include "thermistornames.h"
+        STATIC_ITEM("T2: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP), false);
+      #endif
+
+      #if TEMP_SENSOR_3 != 0
+        #undef THERMISTOR_ID
+        #define THERMISTOR_ID TEMP_SENSOR_3
+        #include "thermistornames.h"
+        STATIC_ITEM("T3: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP), false);
+      #endif
+
+      #if TEMP_SENSOR_4 != 0
+        #undef THERMISTOR_ID
+        #define THERMISTOR_ID TEMP_SENSOR_4
+        #include "thermistornames.h"
+        STATIC_ITEM("T4: " THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_4_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_4_MAXTEMP), false);
+      #endif
+
+      #if TEMP_SENSOR_BED != 0
+        #undef THERMISTOR_ID
+        #define THERMISTOR_ID TEMP_SENSOR_BED
+        #include "thermistornames.h"
+        STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
+        STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
+        STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
+      #endif
+      END_SCREEN();
+    }
+
+    /**
+     *
+     * About Printer > Board Info
+     *
+     */
+    void lcd_info_board_menu() {
+      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      START_SCREEN();
+      STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
+      STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
+      STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
+      #if POWER_SUPPLY == 0
+        STATIC_ITEM(MSG_INFO_PSU ": Generic", true);
+      #elif POWER_SUPPLY == 1
+        STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
+      #elif POWER_SUPPLY == 2
+        STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
+      #endif
+      END_SCREEN();
+    }
+
+    /**
+     *
+     * About Printer > Printer Info
+     *
+     */
+    void lcd_info_printer_menu() {
+      if (lcd_clicked) { return lcd_goto_previous_menu(); }
+      START_SCREEN();
+      STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
+      STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
+      STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
+      STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
+      STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
+      STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
+      #if ENABLED(AUTO_BED_LEVELING_3POINT)
+        STATIC_ITEM(MSG_3POINT_LEVELING, true);                        // 3-Point Leveling
+      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+        STATIC_ITEM(MSG_LINEAR_LEVELING, true);                        // Linear Leveling
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        STATIC_ITEM(MSG_BILINEAR_LEVELING, true);                      // Bi-linear Leveling
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        STATIC_ITEM(MSG_UBL_LEVELING, true);                           // Unified Bed Leveling
+      #elif ENABLED(MESH_BED_LEVELING)
+        STATIC_ITEM(MSG_MESH_LEVELING, true);                          // Mesh Leveling
+      #endif
+      END_SCREEN();
+    }
+
+    /**
+     *
+     * "About Printer" submenu
+     *
+     */
+    void lcd_info_menu() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+      MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, lcd_info_printer_menu);        // Printer Info >
+      MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, lcd_info_board_menu);            // Board Info >
+      MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, lcd_info_thermistors_menu); // Thermistors >
+      #if ENABLED(PRINTCOUNTER)
+        MENU_ITEM(submenu, MSG_INFO_STATS_MENU, lcd_info_stats_menu);          // Printer Statistics >
+      #endif
+      END_MENU();
+    }
+  #endif // LCD_INFO_MENU
+
+  /**
+   *
+   * Filament Change Feature Screens
+   *
+   */
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+    // Portions from STATIC_ITEM...
+    #define HOTEND_STATUS_ITEM() do { \
+      if (_menuLineNr == _thisItemNr) { \
+        if (lcdDrawUpdate) { \
+          lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
+          lcd_implementation_hotend_status(_lcdLineNr); \
+        } \
+        if (_skipStatic && encoderLine <= _thisItemNr) { \
+          encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
+          ++encoderLine; \
+        } \
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
+      } \
+      ++_thisItemNr; \
+    }while(0)
+
+    void lcd_advanced_pause_toocold_menu() {
+      START_MENU();
+      STATIC_ITEM(MSG_HEATING_FAILED_LCD, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_MINTEMP STRINGIFY(EXTRUDE_MINTEMP) ".", false, false);
+      MENU_BACK(MSG_BACK);
+      #if LCD_HEIGHT > 4
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_MENU();
+    }
+
+    void lcd_advanced_pause_resume_print() {
+      advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
+    }
+
+    void lcd_advanced_pause_extrude_more() {
+      advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
+    }
+
+    void lcd_advanced_pause_option_menu() {
+      START_MENU();
+      #if LCD_HEIGHT > 2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
+      #endif
+      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
+      MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_EXTRUDE, lcd_advanced_pause_extrude_more);
+      END_MENU();
+    }
+
+    void lcd_advanced_pause_init_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
+      #ifdef MSG_FILAMENT_CHANGE_INIT_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
+        #define __FC_LINES_A 3
+      #else
+        #define __FC_LINES_A 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_INIT_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
+        #define _FC_LINES_A (__FC_LINES_A + 1)
+      #else
+        #define _FC_LINES_A __FC_LINES_A
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_A + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_unload_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
+      #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
+        #define __FC_LINES_B 3
+      #else
+        #define __FC_LINES_B 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
+        #define _FC_LINES_B (__FC_LINES_B + 1)
+      #else
+        #define _FC_LINES_B __FC_LINES_B
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_B + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_wait_for_nozzles_to_heat() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
+      #ifdef MSG_FILAMENT_CHANGE_HEATING_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
+        #define _FC_LINES_C 3
+      #else
+        #define _FC_LINES_C 2
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_C + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_heat_nozzle() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
+      #ifdef MSG_FILAMENT_CHANGE_INSERT_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
+        #define _FC_LINES_D 3
+      #else
+        #define _FC_LINES_D 2
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_D + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_insert_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
+      #ifdef MSG_FILAMENT_CHANGE_INSERT_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
+        #define __FC_LINES_E 3
+      #else
+        #define __FC_LINES_E 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_INSERT_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
+        #define _FC_LINES_E (__FC_LINES_E + 1)
+      #else
+        #define _FC_LINES_E __FC_LINES_E
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_E + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_load_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
+      #ifdef MSG_FILAMENT_CHANGE_LOAD_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
+        #define __FC_LINES_F 3
+      #else
+        #define __FC_LINES_F 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_LOAD_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
+        #define _FC_LINES_F (__FC_LINES_F + 1)
+      #else
+        #define _FC_LINES_F __FC_LINES_F
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_F + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_extrude_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_1);
+      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_2);
+        #define __FC_LINES_G 3
+      #else
+        #define __FC_LINES_G 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_EXTRUDE_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_EXTRUDE_3);
+        #define _FC_LINES_G (__FC_LINES_G + 1)
+      #else
+        #define _FC_LINES_G __FC_LINES_G
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_G + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_resume_message() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEADER, true, true);
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
+      #ifdef MSG_FILAMENT_CHANGE_RESUME_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_RESUME_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
+      #endif
+      END_SCREEN();
+    }
+
+    void lcd_advanced_pause_show_message(const AdvancedPauseMessage message) {
+      switch (message) {
+        case ADVANCED_PAUSE_MESSAGE_INIT:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_init_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_UNLOAD:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_unload_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_INSERT:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_insert_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_LOAD:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_load_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_EXTRUDE:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_extrude_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_heat_nozzle);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_wait_for_nozzles_to_heat);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_OPTION:
+          defer_return_to_status = true;
+          advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
+          lcd_goto_screen(lcd_advanced_pause_option_menu);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_RESUME:
+          defer_return_to_status = true;
+          lcd_goto_screen(lcd_advanced_pause_resume_message);
+          break;
+        case ADVANCED_PAUSE_MESSAGE_STATUS:
+          lcd_return_to_status();
+          break;
+      }
+    }
+
+  #endif // ADVANCED_PAUSE_FEATURE
+
+  /**
+   *
+   * Functions for editing single values
+   *
+   * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
+   *
+   * For example, DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1) expands into these functions:
+   *
+   *   bool _menu_edit_int3();
+   *   void menu_edit_int3(); // edit int16_t (interactively)
+   *   void menu_edit_callback_int3(); // edit int16_t (interactively) with callback on completion
+   *   void _menu_action_setting_edit_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+   *   void menu_action_setting_edit_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+   *   void menu_action_setting_edit_callback_int3(const char * const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
+   *
+   * You can then use one of the menu macros to present the edit interface:
+   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
+   *
+   * This expands into a more primitive menu item:
+   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+   *
+   * ...which calls:
+   *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+   */
+  #define DEFINE_MENU_EDIT_TYPE(_type, _name, _strFunc, _scale) \
+    bool _menu_edit_ ## _name() { \
+      ENCODER_DIRECTION_NORMAL(); \
+      if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
+      if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
+      if (lcdDrawUpdate) \
+        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale))); \
+      if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
+        _type value = ((_type)((int32_t)encoderPosition + minEditValue)) * (1.0 / _scale); \
+        if (editValue != NULL) *((_type*)editValue) = value; \
+        if (liveEdit) (*callbackFunc)(); \
+        if (lcd_clicked) lcd_goto_previous_menu(); \
+      } \
+      return lcd_clicked; \
+    } \
+    void menu_edit_ ## _name() { _menu_edit_ ## _name(); } \
+    void menu_edit_callback_ ## _name() { if (_menu_edit_ ## _name()) (*callbackFunc)(); } \
+    void _menu_action_setting_edit_ ## _name(const char * const pstr, _type* const ptr, const _type minValue, const _type maxValue) { \
+      lcd_save_previous_screen(); \
+      \
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; \
+      \
+      editLabel = pstr; \
+      editValue = ptr; \
+      minEditValue = minValue * _scale; \
+      maxEditValue = maxValue * _scale - minEditValue; \
+      encoderPosition = (*ptr) * _scale - minEditValue; \
+    } \
+    void menu_action_setting_edit_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue) { \
+      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+      currentScreen = menu_edit_ ## _name; \
+    } \
+    void menu_action_setting_edit_callback_ ## _name(const char * const pstr, _type * const ptr, const _type minValue, const _type maxValue, const screenFunc_t callback, const bool live) { \
+      _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \
+      currentScreen = menu_edit_callback_ ## _name; \
+      callbackFunc = callback; \
+      liveEdit = live; \
+    } \
+    typedef void _name
+
+  DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01);
+  DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
+  DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
+  DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1.0);
+  DEFINE_MENU_EDIT_TYPE(float, float32, ftostr32, 100.0);
+  DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000.0);
+  DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01);
+  DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10.0);
+  DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52sign, 100.0);
+  DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100.0);
+
+  /**
+   *
+   * Handlers for Keypad input
+   *
+   */
+  #if ENABLED(ADC_KEYPAD)
+
+    inline bool handle_adc_keypad() {
+      static uint8_t adc_steps = 0;
+      if (buttons_reprapworld_keypad) {
+        if (adc_steps < 20) ++adc_steps;
+        lcd_quick_feedback();
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+        if (encoderDirection == -1) { // side effect which signals we are inside a menu
+          if      (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_LEFT)  menu_action_back();
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) lcd_return_to_status();
+        }
+        else {
+          const int8_t step = adc_steps > 19 ? 100 : adc_steps > 10 ? 10 : 1;
+               if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_DOWN)  encoderPosition += ENCODER_PULSES_PER_STEP * step;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_UP)    encoderPosition -= ENCODER_PULSES_PER_STEP * step;
+          else if (buttons_reprapworld_keypad & EN_REPRAPWORLD_KEYPAD_RIGHT) encoderPosition = 0;
+        }
+        #if ENABLED(ADC_KEYPAD_DEBUG)
+          SERIAL_PROTOCOLLNPAIR("buttons_reprapworld_keypad = ", (uint32_t)buttons_reprapworld_keypad);
+          SERIAL_PROTOCOLLNPAIR("encoderPosition = ", (uint32_t)encoderPosition);
+        #endif
+        return true;
+      }
+      else if (!thermalManager.current_ADCKey_raw)
+        adc_steps = 0; // reset stepping acceleration
+
+      return false;
+    }
+
+  #elif ENABLED(REPRAPWORLD_KEYPAD)
+
+    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
+      move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      encoderPosition = dir;
+      switch (axis) {
+        case X_AXIS: lcd_move_x(); break;
+        case Y_AXIS: lcd_move_y(); break;
+        case Z_AXIS: lcd_move_z();
+        default: break;
+      }
+    }
+    void reprapworld_keypad_move_z_up()    { _reprapworld_keypad_move(Z_AXIS,  1); }
+    void reprapworld_keypad_move_z_down()  { _reprapworld_keypad_move(Z_AXIS, -1); }
+    void reprapworld_keypad_move_x_left()  { _reprapworld_keypad_move(X_AXIS, -1); }
+    void reprapworld_keypad_move_x_right() { _reprapworld_keypad_move(X_AXIS,  1); }
+    void reprapworld_keypad_move_y_up()    { _reprapworld_keypad_move(Y_AXIS, -1); }
+    void reprapworld_keypad_move_y_down()  { _reprapworld_keypad_move(Y_AXIS,  1); }
+    void reprapworld_keypad_move_home()    { enqueue_and_echo_commands_P(PSTR("G28")); } // move all axes home and wait
+    void reprapworld_keypad_move_menu()    { lcd_goto_screen(lcd_move_menu); }
+
+    inline void handle_reprapworld_keypad() {
+
+      static uint8_t keypad_debounce = 0;
+
+      if (!REPRAPWORLD_KEYPAD_PRESSED) {
+        if (keypad_debounce > 0) keypad_debounce--;
+      }
+      else if (!keypad_debounce) {
+        keypad_debounce = 2;
+
+        if (REPRAPWORLD_KEYPAD_MOVE_MENU)       reprapworld_keypad_move_menu();
+
+        #if DISABLED(DELTA) && Z_HOME_DIR == -1
+          if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();
+        #endif
+
+        if (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
+          #if ENABLED(DELTA) || Z_HOME_DIR != -1
+            if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)   reprapworld_keypad_move_z_up();
+          #endif
+          if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();
+          if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();
+          if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();
+          if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();
+          if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();
+        }
+        else {
+          if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();
+        }
+      }
+    }
+
+  #endif // REPRAPWORLD_KEYPAD
+
+  /**
+   *
+   * Menu actions
+   *
+   */
+  void _menu_action_back() { lcd_goto_previous_menu(); }
+  void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
+  void menu_action_gcode(const char* pgcode) { enqueue_and_echo_commands_P(pgcode); }
+  void menu_action_function(screenFunc_t func) { (*func)(); }
+
+  #if ENABLED(SDSUPPORT)
+
+    void menu_action_sdfile(const char* filename, char* longFilename) {
+      UNUSED(longFilename);
+      card.openAndPrintFile(filename);
+      lcd_return_to_status();
+    }
+
+    void menu_action_sddirectory(const char* filename, char* longFilename) {
+      UNUSED(longFilename);
+      card.chdir(filename);
+      encoderPosition = 0;
+      screen_changed = true;
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+    }
+
+  #endif // SDSUPPORT
+
+  void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; }
+  void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, screenFunc_t callback) {
+    menu_action_setting_edit_bool(pstr, ptr);
+    (*callback)();
+  }
+
+#endif // ULTIPANEL
+
+void lcd_init() {
+
+  lcd_implementation_init(
+    #if ENABLED(LCD_PROGRESS_BAR)
+      true
+    #endif
+  );
+
+  #if ENABLED(NEWPANEL)
+    #if BUTTON_EXISTS(EN1)
+      SET_INPUT_PULLUP(BTN_EN1);
+    #endif
+
+    #if BUTTON_EXISTS(EN2)
+      SET_INPUT_PULLUP(BTN_EN2);
+    #endif
+
+    #if BUTTON_EXISTS(ENC)
+      SET_INPUT_PULLUP(BTN_ENC);
+    #endif
+
+    #if ENABLED(REPRAPWORLD_KEYPAD) && DISABLED(ADC_KEYPAD)
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      SET_INPUT_PULLUP(SHIFT_OUT);
+    #endif
+
+    #if BUTTON_EXISTS(UP)
+      SET_INPUT(BTN_UP);
+    #endif
+    #if BUTTON_EXISTS(DWN)
+      SET_INPUT(BTN_DWN);
+    #endif
+    #if BUTTON_EXISTS(LFT)
+      SET_INPUT(BTN_LFT);
+    #endif
+    #if BUTTON_EXISTS(RT)
+      SET_INPUT(BTN_RT);
+    #endif
+
+  #else // !NEWPANEL
+
+    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+      SET_OUTPUT(SR_DATA_PIN);
+      SET_OUTPUT(SR_CLK_PIN);
+    #elif defined(SHIFT_CLK)
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      OUT_WRITE(SHIFT_EN, LOW);
+      SET_INPUT_PULLUP(SHIFT_OUT);
+    #endif // SR_LCD_2W_NL
+
+  #endif // !NEWPANEL
+
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+    SET_INPUT_PULLUP(SD_DETECT_PIN);
+    lcd_sd_status = 2; // UNKNOWN
+  #endif
+
+  #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+    slow_buttons = 0;
+  #endif
+
+  lcd_buttons_update();
+
+  #if ENABLED(ULTIPANEL)
+    encoderDiff = 0;
+  #endif
+}
+
+int16_t lcd_strlen(const char* s) {
+  int16_t i = 0, j = 0;
+  while (s[i]) {
+    if (PRINTABLE(s[i])) j++;
+    i++;
+  }
+  return j;
+}
+
+int16_t lcd_strlen_P(const char* s) {
+  int16_t j = 0;
+  while (pgm_read_byte(s)) {
+    if (PRINTABLE(pgm_read_byte(s))) j++;
+    s++;
+  }
+  return j;
+}
+
+bool lcd_blink() {
+  static uint8_t blink = 0;
+  static millis_t next_blink_ms = 0;
+  millis_t ms = millis();
+  if (ELAPSED(ms, next_blink_ms)) {
+    blink ^= 0xFF;
+    next_blink_ms = ms + 1000 - LCD_UPDATE_INTERVAL / 2;
+  }
+  return blink != 0;
+}
+
+/**
+ * Update the LCD, read encoder buttons, etc.
+ *   - Read button states
+ *   - Check the SD Card slot state
+ *   - Act on RepRap World keypad input
+ *   - Update the encoder position
+ *   - Apply acceleration to the encoder position
+ *   - Set lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NOW on controller events
+ *   - Reset the Info Screen timeout if there's any input
+ *   - Update status indicators, if any
+ *
+ *   Run the current LCD menu handler callback function:
+ *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
+ *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
+ *   - Call the menu handler. Menu handlers should do the following:
+ *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
+ *       (Encoder events automatically set lcdDrawUpdate for you.)
+ *     - if (lcdDrawUpdate) { redraw }
+ *     - Before exiting the handler set lcdDrawUpdate to:
+ *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
+ *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
+ *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
+ *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
+ *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
+ *             so don't change lcdDrawUpdate without considering this.
+ *
+ *   After the menu handler callback runs (or not):
+ *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
+ *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
+ *
+ * No worries. This function is only called from the main thread.
+ */
+void lcd_update() {
+
+  #if ENABLED(ULTIPANEL)
+    static millis_t return_to_status_ms = 0;
+    manage_manual_move();
+
+    lcd_buttons_update();
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      const bool UBL_CONDITION = !ubl.has_control_of_lcd_panel;
+    #else
+      constexpr bool UBL_CONDITION = true;
+    #endif
+
+    // If the action button is pressed...
+    if (UBL_CONDITION && LCD_CLICKED) {
+      if (!wait_for_unclick) {           // If not waiting for a debounce release:
+        wait_for_unclick = true;         //  Set debounce flag to ignore continous clicks
+        lcd_clicked = !wait_for_user;    //  Keep the click if not waiting for a user-click
+        wait_for_user = false;           //  Any click clears wait for user
+        lcd_quick_feedback();            //  Always make a click sound
+      }
+    }
+    else wait_for_unclick = false;
+  #endif
+
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+
+    const bool sd_status = IS_SD_INSERTED;
+    if (sd_status != lcd_sd_status && lcd_detected()) {
+
+      if (sd_status) {
+        card.initsd();
+        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);
+      }
+      else {
+        card.release();
+        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);
+      }
+
+      lcd_sd_status = sd_status;
+      lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
+        #if ENABLED(LCD_PROGRESS_BAR)
+          currentScreen == lcd_status_screen
+        #endif
+      );
+    }
+
+  #endif // SDSUPPORT && SD_DETECT_PIN
+
+  const millis_t ms = millis();
+  if (ELAPSED(ms, next_lcd_update_ms)
+    #if ENABLED(DOGLCD)
+      || drawing_screen
+    #endif
+    ) {
+
+    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
+
+    #if ENABLED(LCD_HAS_STATUS_INDICATORS)
+      lcd_implementation_update_indicators();
+    #endif
+
+    #if ENABLED(ULTIPANEL)
+
+      #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+        slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context
+      #endif
+
+      #if ENABLED(ADC_KEYPAD)
+
+        if (handle_adc_keypad())
+          return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+
+      #elif ENABLED(REPRAPWORLD_KEYPAD)
+
+        handle_reprapworld_keypad();
+
+      #endif
+
+      bool encoderPastThreshold = (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP);
+      if (encoderPastThreshold || lcd_clicked) {
+        if (encoderPastThreshold) {
+          int32_t encoderMultiplier = 1;
+
+          #if ENABLED(ENCODER_RATE_MULTIPLIER)
+
+            if (encoderRateMultiplierEnabled) {
+              int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;
+
+              if (lastEncoderMovementMillis) {
+                // Note that the rate is always calculated between two passes through the
+                // loop and that the abs of the encoderDiff value is tracked.
+                float encoderStepRate = float(encoderMovementSteps) / float(ms - lastEncoderMovementMillis) * 1000.0;
+
+                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
+
+                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                  SERIAL_ECHO_START();
+                  SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
+                  SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
+                  SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                  SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                  SERIAL_EOL();
+                #endif // ENCODER_RATE_MULTIPLIER_DEBUG
+              }
+
+              lastEncoderMovementMillis = ms;
+            } // encoderRateMultiplierEnabled
+          #endif // ENCODER_RATE_MULTIPLIER
+
+          encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;
+          encoderDiff = 0;
+        }
+        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+        lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      }
+    #endif // ULTIPANEL
+
+    // We arrive here every ~100ms when idling often enough.
+    // Instead of tracking the changes simply redraw the Info Screen ~1 time a second.
+    static int8_t lcd_status_update_delay = 1; // first update one loop delayed
+    if (
+      #if ENABLED(ULTIPANEL)
+        currentScreen == lcd_status_screen &&
+      #endif
+      !lcd_status_update_delay--
+    ) {
+      lcd_status_update_delay = 9
+        #if ENABLED(DOGLCD)
+          + 3
+        #endif
+      ;
+      max_display_update_time--;
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+
+    // then we want to use 1/2 of the time only.
+    uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
+
+    #if ENABLED(DOGLCD)
+      if ((lcdDrawUpdate || drawing_screen) && (!bbr2 || (bbr2 > max_display_update_time)))
+    #else
+      if (lcdDrawUpdate && (!bbr2 || (bbr2 > max_display_update_time)))
+    #endif
+    {
+      #if ENABLED(DOGLCD)
+        if (!drawing_screen)
+      #endif
+        {
+          switch (lcdDrawUpdate) {
+            case LCDVIEW_CALL_NO_REDRAW:
+              lcdDrawUpdate = LCDVIEW_NONE;
+              break;
+            case LCDVIEW_CLEAR_CALL_REDRAW: // set by handlers, then altered after (rarely occurs here)
+            case LCDVIEW_CALL_REDRAW_NEXT:  // set by handlers, then altered after (never occurs here?)
+              lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+            case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
+            case LCDVIEW_NONE:
+              break;
+          } // switch
+        }
+
+      #if ENABLED(ADC_KEYPAD)
+        buttons_reprapworld_keypad = 0;
+      #endif
+
+      #if ENABLED(ULTIPANEL)
+        #define CURRENTSCREEN() (*currentScreen)(), lcd_clicked = false
+      #else
+        #define CURRENTSCREEN() lcd_status_screen()
+      #endif
+
+      #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display
+        if (!drawing_screen) {
+          u8g.firstPage();
+          drawing_screen = 1;
+        }
+        lcd_setFont(FONT_MENU);
+        u8g.setColorIndex(1);
+        CURRENTSCREEN();
+        if (drawing_screen && (drawing_screen = u8g.nextPage())) {
+          NOLESS(max_display_update_time, millis() - ms);
+          return;
+        }
+      #else
+        CURRENTSCREEN();
+      #endif
+      NOLESS(max_display_update_time, millis() - ms);
+    }
+
+    #if ENABLED(ULTIPANEL)
+
+      // Return to Status Screen after a timeout
+      if (currentScreen == lcd_status_screen || defer_return_to_status)
+        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;
+      else if (ELAPSED(ms, return_to_status_ms))
+        lcd_return_to_status();
+
+    #endif // ULTIPANEL
+
+    #if ENABLED(DOGLCD)
+      if (!drawing_screen)
+    #endif
+      {
+        switch (lcdDrawUpdate) {
+          case LCDVIEW_CLEAR_CALL_REDRAW:
+            lcd_implementation_clear();
+          case LCDVIEW_CALL_REDRAW_NEXT:
+            lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+            break;
+          case LCDVIEW_REDRAW_NOW:
+            lcdDrawUpdate = LCDVIEW_NONE;
+            break;
+          case LCDVIEW_NONE:
+            break;
+        } // switch
+      }
+  } // ELAPSED(ms, next_lcd_update_ms)
+}
+
+void pad_message_string() {
+  uint8_t i = 0, j = 0;
+  char c;
+  while ((c = lcd_status_message[i]) && j < LCD_WIDTH) {
+    if (PRINTABLE(c)) j++;
+    i++;
+  }
+  if (true
+    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+      && j < LCD_WIDTH
+    #endif
+  ) {
+    // pad with spaces to fill up the line
+    while (j++ < LCD_WIDTH) lcd_status_message[i++] = ' ';
+    // chop off at the edge
+    lcd_status_message[i] = '\0';
+  }
+}
+
+void lcd_finishstatus(const bool persist=false) {
+
+  pad_message_string();
+
+  #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE > 0))
+    UNUSED(persist);
+  #endif
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+    progress_bar_ms = millis();
+    #if PROGRESS_MSG_EXPIRE > 0
+      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;
+    #endif
+  #endif
+  lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+
+  #if ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(SDSUPPORT)
+    previous_lcd_status_ms = millis();  //get status message to show up for a while
+  #endif
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    status_scroll_pos = 0;
+  #endif
+}
+
+#if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
+  void dontExpireStatus() { expire_status_ms = 0; }
+#endif
+
+bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }
+
+void lcd_setstatus(const char * const message, const bool persist) {
+  if (lcd_status_message_level > 0) return;
+  strncpy(lcd_status_message, message, 3 * (LCD_WIDTH));
+  lcd_finishstatus(persist);
+}
+
+void lcd_setstatusPGM(const char * const message, int8_t level) {
+  if (level < 0) level = lcd_status_message_level = 0;
+  if (level < lcd_status_message_level) return;
+  lcd_status_message_level = level;
+  strncpy_P(lcd_status_message, message, 3 * (LCD_WIDTH));
+  lcd_finishstatus(level > 0);
+}
+
+void lcd_status_printf_P(const uint8_t level, const char * const fmt, ...) {
+  if (level < lcd_status_message_level) return;
+  lcd_status_message_level = level;
+  va_list args;
+  va_start(args, fmt);
+  vsnprintf_P(lcd_status_message, 3 * (LCD_WIDTH), fmt, args);
+  va_end(args);
+  lcd_finishstatus(level > 0);
+}
+
+void lcd_setalertstatusPGM(const char * const message) {
+  lcd_setstatusPGM(message, 1);
+  #if ENABLED(ULTIPANEL)
+    lcd_return_to_status();
+  #endif
+}
+
+void lcd_reset_alert_level() { lcd_status_message_level = 0; }
+
+#if HAS_LCD_CONTRAST
+
+  void set_lcd_contrast(const uint16_t value) {
+    lcd_contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
+    u8g.setContrast(lcd_contrast);
+  }
+
+#endif
+
+#if ENABLED(ULTIPANEL)
+
+  /**
+   * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
+   * These values are independent of which pins are used for EN_A and EN_B indications
+   * The rotary encoder part is also independent to the chipset used for the LCD
+   */
+  #if defined(EN_A) && defined(EN_B)
+    #define encrot0 0
+    #define encrot1 2
+    #define encrot2 3
+    #define encrot3 1
+  #endif
+
+  #define GET_BUTTON_STATES(DST) \
+    uint8_t new_##DST = 0; \
+    WRITE(SHIFT_LD, LOW); \
+    WRITE(SHIFT_LD, HIGH); \
+    for (int8_t i = 0; i < 8; i++) { \
+      new_##DST >>= 1; \
+      if (READ(SHIFT_OUT)) SBI(new_##DST, 7); \
+      WRITE(SHIFT_CLK, HIGH); \
+      WRITE(SHIFT_CLK, LOW); \
+    } \
+    DST = ~new_##DST; //invert it, because a pressed switch produces a logical 0
+
+
+  /**
+   * Read encoder buttons from the hardware registers
+   * Warning: This function is called from interrupt context!
+   */
+  void lcd_buttons_update() {
+    static uint8_t lastEncoderBits;
+    millis_t now = millis();
+    if (ELAPSED(now, next_button_update_ms)) {
+
+      #if ENABLED(NEWPANEL)
+        uint8_t newbutton = 0;
+
+        #if BUTTON_EXISTS(EN1)
+          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+        #endif
+
+        #if BUTTON_EXISTS(EN2)
+          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+        #endif
+
+        #if BUTTON_EXISTS(ENC)
+          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+        #endif
+
+        #if LCD_HAS_DIRECTIONAL_BUTTONS
+
+          // Manage directional buttons
+          #if ENABLED(REVERSE_MENU_DIRECTION)
+            #define _ENCODER_UD_STEPS (ENCODER_STEPS_PER_MENU_ITEM * encoderDirection)
+          #else
+            #define _ENCODER_UD_STEPS ENCODER_STEPS_PER_MENU_ITEM
+          #endif
+          #if ENABLED(REVERSE_ENCODER_DIRECTION)
+            #define ENCODER_UD_STEPS _ENCODER_UD_STEPS
+            #define ENCODER_LR_PULSES ENCODER_PULSES_PER_STEP
+          #else
+            #define ENCODER_UD_STEPS -(_ENCODER_UD_STEPS)
+            #define ENCODER_LR_PULSES -(ENCODER_PULSES_PER_STEP)
+          #endif
+
+          if (false) {
+            // for the else-ifs below
+          }
+          #if BUTTON_EXISTS(UP)
+            else if (BUTTON_PRESSED(UP)) {
+              encoderDiff = -(ENCODER_UD_STEPS);
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(DWN)
+            else if (BUTTON_PRESSED(DWN)) {
+              encoderDiff = ENCODER_UD_STEPS;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(LFT)
+            else if (BUTTON_PRESSED(LFT)) {
+              encoderDiff = -(ENCODER_LR_PULSES);
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(RT)
+            else if (BUTTON_PRESSED(RT)) {
+              encoderDiff = ENCODER_LR_PULSES;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+
+        #endif // LCD_HAS_DIRECTIONAL_BUTTONS
+
+        buttons = newbutton;
+        #if ENABLED(LCD_HAS_SLOW_BUTTONS)
+          buttons |= slow_buttons;
+        #endif
+
+        #if ENABLED(ADC_KEYPAD)
+
+          uint8_t newbutton_reprapworld_keypad = 0;
+          buttons = 0;
+          if (buttons_reprapworld_keypad == 0) {
+            newbutton_reprapworld_keypad = get_ADC_keyValue();
+            if (WITHIN(newbutton_reprapworld_keypad, 1, 8))
+              buttons_reprapworld_keypad = _BV(newbutton_reprapworld_keypad - 1);
+          }
+
+        #elif ENABLED(REPRAPWORLD_KEYPAD)
+
+          GET_BUTTON_STATES(buttons_reprapworld_keypad);
+
+        #endif
+
+      #else
+        GET_BUTTON_STATES(buttons);
+      #endif // !NEWPANEL
+
+    } // next_button_update_ms
+
+    // Manage encoder rotation
+    #if ENABLED(REVERSE_MENU_DIRECTION) && ENABLED(REVERSE_ENCODER_DIRECTION)
+      #define ENCODER_DIFF_CW  (encoderDiff -= encoderDirection)
+      #define ENCODER_DIFF_CCW (encoderDiff += encoderDirection)
+    #elif ENABLED(REVERSE_MENU_DIRECTION)
+      #define ENCODER_DIFF_CW  (encoderDiff += encoderDirection)
+      #define ENCODER_DIFF_CCW (encoderDiff -= encoderDirection)
+    #elif ENABLED(REVERSE_ENCODER_DIRECTION)
+      #define ENCODER_DIFF_CW  (encoderDiff--)
+      #define ENCODER_DIFF_CCW (encoderDiff++)
+    #else
+      #define ENCODER_DIFF_CW  (encoderDiff++)
+      #define ENCODER_DIFF_CCW (encoderDiff--)
+    #endif
+    #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: ENCODER_DIFF_CW; break; case _E2: ENCODER_DIFF_CCW; }
+
+    uint8_t enc = 0;
+    if (buttons & EN_A) enc |= B01;
+    if (buttons & EN_B) enc |= B10;
+    if (enc != lastEncoderBits) {
+      switch (enc) {
+        case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
+        case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
+        case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
+        case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
+      }
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        if (ubl.has_control_of_lcd_panel) {
+          ubl.encoder_diff = encoderDiff;   // Make the encoder's rotation available to G29's Mesh Editor
+          encoderDiff = 0;                  // We are going to lie to the LCD Panel and claim the encoder
+                                            // knob has not turned.
+        }
+      #endif
+      lastEncoderBits = enc;
+    }
+  }
+
+  #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)
+    bool lcd_detected() { return lcd.LcdDetected() == 1; }
+  #else
+    bool lcd_detected() { return true; }
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    void chirp_at_user() {
+      #if ENABLED(LCD_USE_I2C_BUZZER)
+        lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+      #elif PIN_EXISTS(BEEPER)
+        buzzer.tone(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
+      #endif
+    }
+
+    bool ubl_lcd_clicked() { return LCD_CLICKED; }
+
+  #endif
+
+#endif // ULTIPANEL
+
+#if ENABLED(ADC_KEYPAD)
+
+  typedef struct {
+    uint16_t ADCKeyValueMin, ADCKeyValueMax;
+    uint8_t  ADCKeyNo;
+  } _stADCKeypadTable_;
+
+  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
+    // VALUE_MIN, VALUE_MAX, KEY
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F1 + 1 },     // F1
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F2 + 1 },     // F2
+    { 4000, 4096, BLEN_REPRAPWORLD_KEYPAD_F3 + 1 },     // F3
+    {  300,  500, BLEN_REPRAPWORLD_KEYPAD_LEFT + 1 },   // LEFT
+    { 1900, 2200, BLEN_REPRAPWORLD_KEYPAD_RIGHT + 1 },  // RIGHT
+    {  570,  870, BLEN_REPRAPWORLD_KEYPAD_UP + 1 },     // UP
+    { 2670, 2870, BLEN_REPRAPWORLD_KEYPAD_DOWN + 1 },   // DOWN
+    { 1150, 1450, BLEN_REPRAPWORLD_KEYPAD_MIDDLE + 1 }, // ENTER
+  };
+
+  uint8_t get_ADC_keyValue(void) {
+    if (thermalManager.ADCKey_count >= 16) {
+      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw >> 2;
+      #if ENABLED(ADC_KEYPAD_DEBUG)
+        SERIAL_PROTOCOLLN(currentkpADCValue);
+      #endif
+      thermalManager.current_ADCKey_raw = 0;
+      thermalManager.ADCKey_count = 0;
+      if (currentkpADCValue < 4000)
+        for (uint8_t i = 0; i < ADC_KEY_NUM; i++) {
+          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
+                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
+          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
+        }
+    }
+    return 0;
+  }
+#endif
+
+#endif // ULTRA_LCD
