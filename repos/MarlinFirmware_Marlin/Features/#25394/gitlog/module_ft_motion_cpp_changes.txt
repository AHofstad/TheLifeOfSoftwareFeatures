commit 9a5f1d2f516f58d7ea6d2a5ebc381686be76b750
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jul 15 20:30:42 2024 +0200

    üö∏ FT Motion: Linear Advance adjustments (#26785)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 0099b3a25e..b19cd8600a 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -579,7 +579,7 @@ void FTMotion::makeVector() {
   #if HAS_EXTRUDERS
     if (cfg.linearAdvEna) {
       float dedt_adj = (traj.e[makeVector_batchIdx] - e_raw_z1) * (FTM_FS);
-      if (ratio.e > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
+      if (ratio.e > 0.0f) dedt_adj += accel_k * cfg.linearAdvK * 0.0001f;
 
       e_raw_z1 = traj.e[makeVector_batchIdx];
       e_advanced_z1 += dedt_adj * (FTM_TS);

commit f0bc4274f817166fcce82949d94330bd1c441c15
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jul 15 20:13:00 2024 +0200

    üßë‚Äçüíª FT Motion: Individual axis shaping, new buffer management (#26848)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index e73c75b9c5..0099b3a25e 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -30,23 +30,6 @@
 
 FTMotion ftMotion;
 
-#if !HAS_X_AXIS
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZV, "ftMotionMode_ZV requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVD, "ftMotionMode_ZVD requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVDD, "ftMotionMode_ZVD requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVDDD, "ftMotionMode_ZVD requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_EI, "ftMotionMode_EI requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_2HEI, "ftMotionMode_2HEI requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_3HEI, "ftMotionMode_3HEI requires at least one linear axis.");
-  static_assert(FTM_DEFAULT_MODE == ftMotionMode_MZV, "ftMotionMode_MZV requires at least one linear axis.");
-#endif
-#if !HAS_DYNAMIC_FREQ_MM
-  static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_Z_BASED, "dynFreqMode_Z_BASED requires a Z axis.");
-#endif
-#if !HAS_DYNAMIC_FREQ_G
-  static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_MASS_BASED, "dynFreqMode_MASS_BASED requires an X axis and an extruder.");
-#endif
-
 //-----------------------------------------------------------------
 // Variables.
 //-----------------------------------------------------------------
@@ -60,8 +43,6 @@ int32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper comman
         FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
 
 bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items and is in use.
-millis_t FTMotion::axis_pos_move_end_ti[NUM_AXIS_ENUMS] = {0},
-         FTMotion::axis_neg_move_end_ti[NUM_AXIS_ENUMS] = {0};
 
 
 // Private variables.
@@ -70,17 +51,15 @@ millis_t FTMotion::axis_pos_move_end_ti[NUM_AXIS_ENUMS] = {0},
 xyze_trajectory_t    FTMotion::traj;            // = {0.0f} Storage for fixed-time-based trajectory.
 xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for fixed time trajectory window.
 
-bool FTMotion::blockProcRdy = false,            // Indicates a block is ready to be processed.
-     FTMotion::blockProcRdy_z1 = false,         // Storage for the previous indicator.
-     FTMotion::blockProcDn = false;             // Indicates current block is done being processed.
-bool FTMotion::batchRdy = false;                // Indicates a batch of the fixed time trajectory
-                                                //  has been generated, is now available in the upper -
-                                                //  half of traj.x[], y, z ... e vectors, and is ready to be
-                                                //  post processed, if applicable, then interpolated.
-bool FTMotion::batchRdyForInterp = false;       // Indicates the batch is done being post processed,
-                                                //  if applicable, and is ready to be converted to step commands.
-bool FTMotion::runoutEna = false;               // True if runout of the block hasn't been done and is allowed.
-bool FTMotion::blockDataIsRunout = false;       // Indicates the last loaded block variables are for a runout.
+bool FTMotion::blockProcRdy = false;            // Set when new block data is loaded from stepper module into FTM, ...
+                                                // ... and reset when block is completely converted to FTM trajectory.
+bool FTMotion::batchRdy = false;                // Indicates a batch of the fixed time trajectory...
+                                                // ... has been generated, is now available in the upper -
+                                                // batch of traj.x[], y, z ... e vectors, and is ready to be
+                                                // post processed, if applicable, then interpolated. Reset when the
+                                                // data has been shifted out.
+bool FTMotion::batchRdyForInterp = false;       // Indicates the batch is done being post processed...
+                                                // ... if applicable, and is ready to be converted to step commands.
 
 // Trapezoid data variables.
 xyze_pos_t   FTMotion::startPosn,                     // (mm) Start position of block
@@ -101,22 +80,20 @@ uint32_t FTMotion::max_intervals;               // Total number of data points t
 
 // Make vector variables.
 uint32_t FTMotion::makeVector_idx = 0,          // Index of fixed time trajectory generation of the overall block.
-         FTMotion::makeVector_idx_z1 = 0,       // Storage for the previously calculated index above.
          FTMotion::makeVector_batchIdx = 0;     // Index of fixed time trajectory generation within the batch.
 
 // Interpolation variables.
 xyze_long_t FTMotion::steps = { 0 };            // Step count accumulator.
 
-uint32_t FTMotion::interpIdx = 0,               // Index of current data point being interpolated.
-         FTMotion::interpIdx_z1 = 0;            // Storage for the previously calculated index above.
+uint32_t FTMotion::interpIdx = 0;               // Index of current data point being interpolated.
 
 // Shaping variables.
 #if HAS_X_AXIS
   FTMotion::shaping_t FTMotion::shaping = {
-    0, 0,
-    x:{ false, { 0.0f }, { 0.0f }, { 0 } },            // d_zi, Ai, Ni
+    0,
+    x:{ false, { 0.0f }, { 0.0f }, { 0 }, { 0 } },            // ena, d_zi, Ai, Ni, max_i
     #if HAS_Y_AXIS
-      y:{ false, { 0.0f }, { 0.0f }, { 0 } }           // d_zi, Ai, Ni
+      y:{ false, { 0.0f }, { 0.0f }, { 0 }, { 0 } }           // ena, d_zi, Ai, Ni, max_i
     #endif
   };
 #endif
@@ -127,7 +104,7 @@ uint32_t FTMotion::interpIdx = 0,               // Index of current data point b
   float FTMotion::e_advanced_z1 = 0.0f;   // (ms) Unit delay of advanced extruder position.
 #endif
 
-constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
+constexpr uint32_t BATCH_SIDX_IN_WINDOW = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE); // Batch start index in window.
 
 //-----------------------------------------------------------------
 // Function definitions.
@@ -137,41 +114,10 @@ constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
 
 static bool markBlockStart = false;
 
-// Sets controller states to begin processing a block.
-// Called by Stepper::ftMotion_blockQueueUpdate, invoked from the main loop.
-void FTMotion::startBlockProc() {
-  blockProcRdy = true;
-  blockProcDn = false;
-  runoutEna = true;
-}
-
-// Move any free data points to the stepper buffer even if a full batch isn't ready.
-void FTMotion::runoutBlock() {
-
-  if (!runoutEna) return;
-
-  startPosn = endPosn_prevBlock;
-  ratio.reset();
-
-  max_intervals = cfg.modeHasShaper() ? shaper_intervals : 0;
-  if (max_intervals <= TERN(FTM_UNIFIED_BWS, FTM_BATCH_SIZE, min_max_intervals - (FTM_BATCH_SIZE)))
-    max_intervals = min_max_intervals;
-
-  max_intervals += (
-    #if ENABLED(FTM_UNIFIED_BWS)
-      FTM_WINDOW_SIZE - makeVector_batchIdx
-    #else
-      FTM_WINDOW_SIZE - ((last_batchIdx < (FTM_BATCH_SIZE)) ? 0 : makeVector_batchIdx)
-    #endif
-  );
-  blockProcRdy = blockDataIsRunout = true;
-  runoutEna = blockProcDn = false;
-}
-
 // Controller main, to be invoked from non-isr task.
 void FTMotion::loop() {
 
-  if (!cfg.mode) return;
+  if (!cfg.active) return;
 
   /**
    * Handle block abort with the following sequence:
@@ -182,24 +128,49 @@ void FTMotion::loop() {
    */
   if (stepper.abort_current_block) {
     if (sts_stepperBusy) return;          // Wait until motion buffers are emptied
+    discard_planner_block_protected();
     reset();
-    blockProcDn = true;                   // Set queueing to look for next block.
     stepper.abort_current_block = false;  // Abort finished.
   }
 
-  // Planner processing and block conversion.
-  if (!blockProcRdy) stepper.ftMotion_blockQueueUpdate();
+  while (!blockProcRdy && (stepper.current_block = planner.get_current_block())) {
+    if (stepper.current_block->is_sync()) { // Sync block?
+      if (stepper.current_block->is_sync_pos()) // Position sync? Set the position.
+        stepper._set_position(stepper.current_block->position);
+      discard_planner_block_protected();
+      continue;
+    }
+    loadBlockData(stepper.current_block);
+    markBlockStart = true;
+    blockProcRdy = true;
+    // Some kinematics track axis motion in HX, HY, HZ
+    #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
+      stepper.last_direction_bits.hx = stepper.current_block->direction_bits.hx;
+    #endif
+    #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
+      stepper.last_direction_bits.hy = stepper.current_block->direction_bits.hy;
+    #endif
+    #if ANY(CORE_IS_XZ, CORE_IS_YZ)
+      stepper.last_direction_bits.hz = stepper.current_block->direction_bits.hz;
+    #endif
+  }
 
   if (blockProcRdy) {
-    if (!blockProcRdy_z1) { // One-shot.
-      if (!blockDataIsRunout) {
-        loadBlockData(stepper.current_block);
-        markBlockStart = true;
+
+    if (!batchRdy) makeVector(); // Caution: Do not consolidate checks on blockProcRdy/batchRdy, as they are written by makeVector().
+    // When makeVector is finished: either blockProcRdy has been set false (because the block is
+    // done being processed) or batchRdy is set true, or both.
+
+    // Check if the block has been completely converted:
+    if (!blockProcRdy) {
+      discard_planner_block_protected();
+
+      // Check if the block needs to be runout:
+      if (!batchRdy && !planner.movesplanned()){
+        runoutBlock();
+        makeVector(); // Do an additional makeVector call to guarantee batchRdy set this loop.
       }
-      else blockDataIsRunout = false;
     }
-    while (!blockProcDn && !batchRdy && (makeVector_idx - makeVector_idx_z1 < (FTM_POINTS_PER_LOOP)))
-      makeVector();
   }
 
   // FBS / post processing.
@@ -215,7 +186,7 @@ void FTMotion::loop() {
       LOGICAL_AXIS_MAP_LC(TCOPY);
 
       // Shift the time series back in the window
-      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], last_batchIdx * sizeof(traj.A[0]));
+      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], BATCH_SIDX_IN_WINDOW * sizeof(traj.A[0]));
       LOGICAL_AXIS_MAP_LC(TSHIFT);
     #endif
 
@@ -227,9 +198,7 @@ void FTMotion::loop() {
 
   // Interpolation.
   while (batchRdyForInterp
-    && (stepperCmdBuffItems() < (FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME))
-    && (interpIdx - interpIdx_z1 < (FTM_STEPS_PER_LOOP))
-  ) {
+    && (stepperCmdBuffItems() < (FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME))) {
     convertToSteps(interpIdx);
     if (++interpIdx == FTM_BATCH_SIZE) {
       batchRdyForInterp = false;
@@ -238,196 +207,139 @@ void FTMotion::loop() {
   }
 
   // Report busy status to planner.
-  busy = (sts_stepperBusy || ((!blockProcDn && blockProcRdy) || batchRdy || batchRdyForInterp || runoutEna));
+  busy = (sts_stepperBusy || blockProcRdy || batchRdy || batchRdyForInterp);
 
-  blockProcRdy_z1 = blockProcRdy;
-  makeVector_idx_z1 = makeVector_idx;
-  interpIdx_z1 = interpIdx;
 }
 
 #if HAS_X_AXIS
 
   // Refresh the gains used by shaping functions.
-  // To be called on init or mode or zeta change.
+  void FTMotion::AxisShaping::set_axis_shaping_A(const ftMotionShaper_t shaper, const_float_t zeta, const_float_t vtol) {
 
-  void FTMotion::Shaping::updateShapingA(float zeta[]/*=cfg.zeta*/, float vtol[]/*=cfg.vtol*/) {
+    const float K = exp(-zeta * M_PI / sqrt(1.f - sq(zeta))),
+                K2 = sq(K),
+                K3 = K2 * K,
+                K4 = K3 * K;
 
-    const float Kx = exp(-zeta[0] * M_PI / sqrt(1.0f - sq(zeta[0]))),
-                Ky = exp(-zeta[1] * M_PI / sqrt(1.0f - sq(zeta[1]))),
-                Kx2 = sq(Kx),
-                Ky2 = sq(Ky);
+    switch (shaper) {
 
-    switch (cfg.mode) {
-
-      case ftMotionMode_ZV:
+      case ftMotionShaper_ZV:
         max_i = 1U;
-        x.Ai[0] = 1.0f / (1.0f + Kx);
-        x.Ai[1] = x.Ai[0] * Kx;
-
-        y.Ai[0] = 1.0f / (1.0f + Ky);
-        y.Ai[1] = y.Ai[0] * Ky;
+        Ai[0] = 1.0f / (1.0f + K);
+        Ai[1] = Ai[0] * K;
         break;
 
-      case ftMotionMode_ZVD:
+      case ftMotionShaper_ZVD:
         max_i = 2U;
-        x.Ai[0] = 1.0f / (1.0f + 2.0f * Kx + Kx2);
-        x.Ai[1] = x.Ai[0] * 2.0f * Kx;
-        x.Ai[2] = x.Ai[0] * Kx2;
-
-        y.Ai[0] = 1.0f / (1.0f + 2.0f * Ky + Ky2);
-        y.Ai[1] = y.Ai[0] * 2.0f * Ky;
-        y.Ai[2] = y.Ai[0] * Ky2;
+        Ai[0] = 1.0f / (1.0f + 2.0f * K + K2);
+        Ai[1] = Ai[0] * 2.0f * K;
+        Ai[2] = Ai[0] * K2;
         break;
 
-      case ftMotionMode_ZVDD:
+      case ftMotionShaper_ZVDD:
         max_i = 3U;
-        x.Ai[0] = 1.0f / (1.0f + 3.0f * Kx + 3.0f * Kx2 + cu(Kx));
-        x.Ai[1] = x.Ai[0] * 3.0f * Kx;
-        x.Ai[2] = x.Ai[0] * 3.0f * Kx2;
-        x.Ai[3] = x.Ai[0] * cu(Kx);
-
-        y.Ai[0] = 1.0f / (1.0f + 3.0f * Ky + 3.0f * Ky2 + cu(Ky));
-        y.Ai[1] = y.Ai[0] * 3.0f * Ky;
-        y.Ai[2] = y.Ai[0] * 3.0f * Ky2;
-        y.Ai[3] = y.Ai[0] * cu(Ky);
+        Ai[0] = 1.0f / (1.0f + 3.0f * K + 3.0f * K2 + K3);
+        Ai[1] = Ai[0] * 3.0f * K;
+        Ai[2] = Ai[0] * 3.0f * K2;
+        Ai[3] = Ai[0] * K3;
         break;
 
-      case ftMotionMode_ZVDDD:
+      case ftMotionShaper_ZVDDD:
         max_i = 4U;
-        x.Ai[0] = 1.0f / (1.0f + 4.0f * Kx + 6.0f * Kx2 + 4.0f * cu(Kx) + sq(Kx2));
-        x.Ai[1] = x.Ai[0] * 4.0f * Kx;
-        x.Ai[2] = x.Ai[0] * 6.0f * Kx2;
-        x.Ai[3] = x.Ai[0] * 4.0f * cu(Kx);
-        x.Ai[4] = x.Ai[0] * sq(Kx2);
-
-        y.Ai[0] = 1.0f / (1.0f + 4.0f * Ky + 6.0f * Ky2 + 4.0f * cu(Ky) + sq(Ky2));
-        y.Ai[1] = y.Ai[0] * 4.0f * Ky;
-        y.Ai[2] = y.Ai[0] * 6.0f * Ky2;
-        y.Ai[3] = y.Ai[0] * 4.0f * cu(Ky);
-        y.Ai[4] = y.Ai[0] * sq(Ky2);
+        Ai[0] = 1.0f / (1.0f + 4.0f * K + 6.0f * K2 + 4.0f * K3 + K4);
+        Ai[1] = Ai[0] * 4.0f * K;
+        Ai[2] = Ai[0] * 6.0f * K2;
+        Ai[3] = Ai[0] * 4.0f * K3;
+        Ai[4] = Ai[0] * K4;
         break;
 
-      case ftMotionMode_EI: {
+      case ftMotionShaper_EI: {
         max_i = 2U;
-        x.Ai[0] = 0.25f * (1.0f + vtol[0]);
-        x.Ai[1] = 0.50f * (1.0f - vtol[0]) * Kx;
-        x.Ai[2] = x.Ai[0] * Kx2;
-
-        y.Ai[0] = 0.25f * (1.0f + vtol[1]);
-        y.Ai[1] = 0.50f * (1.0f - vtol[1]) * Ky;
-        y.Ai[2] = y.Ai[0] * Ky2;
+        Ai[0] = 0.25f * (1.0f + vtol);
+        Ai[1] = 0.50f * (1.0f - vtol) * K;
+        Ai[2] = Ai[0] * K2;
 
-        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2]);
-        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2]);
+        const float adj = 1.0f / (Ai[0] + Ai[1] + Ai[2]);
         for (uint32_t i = 0U; i < 3U; i++) {
-          x.Ai[i] *= X_adj;
-          y.Ai[i] *= Y_adj;
+          Ai[i] *= adj;
         }
       }
       break;
 
-      case ftMotionMode_2HEI: {
+      case ftMotionShaper_2HEI: {
         max_i = 3U;
-        const float vtolx2 = sq(vtol[0]);
+        const float vtolx2 = sq(vtol);
         const float X = pow(vtolx2 * (sqrt(1.0f - vtolx2) + 1.0f), 1.0f / 3.0f);
-        x.Ai[0] = (3.0f * sq(X) + 2.0f * X + 3.0f * vtolx2) / (16.0f * X);
-        x.Ai[1] = (0.5f - x.Ai[0]) * Kx;
-        x.Ai[2] = x.Ai[1] * Kx;
-        x.Ai[3] = x.Ai[0] * cu(Kx);
-
-        const float vtoly2 = sq(vtol[1]);
-        const float Y = pow(vtoly2 * (sqrt(1.0f - vtoly2) + 1.0f), 1.0f / 3.0f);
-        y.Ai[0] = (3.0f * sq(Y) + 2.0f * Y + 3.0f * vtoly2) / (16.0f * Y);
-        y.Ai[1] = (0.5f - y.Ai[0]) * Ky;
-        y.Ai[2] = y.Ai[1] * Ky;
-        y.Ai[3] = y.Ai[0] * cu(Ky);
-
-        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3]);
-        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2] + y.Ai[3]);
+        Ai[0] = (3.0f * sq(X) + 2.0f * X + 3.0f * vtolx2) / (16.0f * X);
+        Ai[1] = (0.5f - Ai[0]) * K;
+        Ai[2] = Ai[1] * K;
+        Ai[3] = Ai[0] * K3;
+
+        const float adj = 1.0f / (Ai[0] + Ai[1] + Ai[2] + Ai[3]);
         for (uint32_t i = 0U; i < 4U; i++) {
-          x.Ai[i] *= X_adj;
-          y.Ai[i] *= Y_adj;
+          Ai[i] *= adj;
         }
       }
       break;
 
-      case ftMotionMode_3HEI: {
+      case ftMotionShaper_3HEI: {
         max_i = 4U;
-        x.Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol[0] + 2.0f * sqrt( 2.0f * ( vtol[0] + 1.0f ) * vtol[0] ) );
-        x.Ai[1] = 0.25f * ( 1.0f - vtol[0] ) * Kx;
-        x.Ai[2] = ( 0.5f * ( 1.0f + vtol[0] ) - 2.0f * x.Ai[0] ) * Kx2;
-        x.Ai[3] = x.Ai[1] * Kx2;
-        x.Ai[4] = x.Ai[0] * sq(Kx2);
-
-        y.Ai[0] = 0.0625f * (1.0f + 3.0f * vtol[1] + 2.0f * sqrt(2.0f * (vtol[1] + 1.0f) * vtol[1]));
-        y.Ai[1] = 0.25f * (1.0f - vtol[1]) * Ky;
-        y.Ai[2] = (0.5f * (1.0f + vtol[1]) - 2.0f * y.Ai[0]) * Ky2;
-        y.Ai[3] = y.Ai[1] * Ky2;
-        y.Ai[4] = y.Ai[0] * sq(Ky2);
-
-        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3] + x.Ai[4]);
-        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2] + y.Ai[3] + y.Ai[4]);
+        Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol + 2.0f * sqrt( 2.0f * ( vtol + 1.0f ) * vtol ) );
+        Ai[1] = 0.25f * ( 1.0f - vtol ) * K;
+        Ai[2] = ( 0.5f * ( 1.0f + vtol ) - 2.0f * Ai[0] ) * K2;
+        Ai[3] = Ai[1] * K2;
+        Ai[4] = Ai[0] * K4;
+
+        const float adj = 1.0f / (Ai[0] + Ai[1] + Ai[2] + Ai[3] + Ai[4]);
         for (uint32_t i = 0U; i < 5U; i++) {
-          x.Ai[i] *= X_adj;
-          y.Ai[i] *= Y_adj;
+          Ai[i] *= adj;
         }
       }
       break;
 
-      case ftMotionMode_MZV: {
+      case ftMotionShaper_MZV: {
         max_i = 2U;
-        const float Bx = 1.4142135623730950488016887242097f * Kx;
-        x.Ai[0] = 1.0f / (1.0f + Bx + Kx2);
-        x.Ai[1] = x.Ai[0] * Bx;
-        x.Ai[2] = x.Ai[0] * Kx2;
-
-        const float By = 1.4142135623730950488016887242097f * Ky;
-        y.Ai[0] = 1.0f / (1.0f + By + Ky2);
-        y.Ai[1] = y.Ai[0] * By;
-        y.Ai[2] = y.Ai[0] * Ky2;
+        const float Bx = 1.4142135623730950488016887242097f * K;
+        Ai[0] = 1.0f / (1.0f + Bx + K2);
+        Ai[1] = Ai[0] * Bx;
+        Ai[2] = Ai[0] * K2;
       }
       break;
 
       default:
-        ZERO(x.Ai);
-        ZERO(y.Ai);
+        ZERO(Ai);
         max_i = 0;
     }
 
   }
 
-  void FTMotion::updateShapingA(float zeta[]/*=cfg.zeta*/, float vtol[]/*=cfg.vtol*/) {
-    shaping.updateShapingA(zeta, vtol);
-  }
-
   // Refresh the indices used by shaping functions.
-  // To be called when frequencies change.
-
-  void FTMotion::AxisShaping::updateShapingN(const_float_t f, const_float_t df) {
-    // Protections omitted for DBZ and for index exceeding array length.
-    switch (cfg.mode) {
-      case ftMotionMode_ZV:
+  void FTMotion::AxisShaping::set_axis_shaping_N(const ftMotionShaper_t shaper, const_float_t f, const_float_t zeta) {
+    // Note that protections are omitted for DBZ and for index exceeding array length.
+    const float df = sqrt ( 1.f - sq(zeta) );
+    switch (shaper) {
+      case ftMotionShaper_ZV:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         break;
-      case ftMotionMode_ZVD:
-      case ftMotionMode_EI:
+      case ftMotionShaper_ZVD:
+      case ftMotionShaper_EI:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         break;
-      case ftMotionMode_ZVDD:
-      case ftMotionMode_2HEI:
+      case ftMotionShaper_ZVDD:
+      case ftMotionShaper_2HEI:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         Ni[3] = Ni[2] + Ni[1];
         break;
-      case ftMotionMode_ZVDDD:
-      case ftMotionMode_3HEI:
+      case ftMotionShaper_ZVDDD:
+      case ftMotionShaper_3HEI:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         Ni[3] = Ni[2] + Ni[1];
         Ni[4] = Ni[3] + Ni[1];
         break;
-      case ftMotionMode_MZV:
+      case ftMotionShaper_MZV:
         Ni[1] = round((0.375f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         break;
@@ -435,13 +347,20 @@ void FTMotion::loop() {
     }
   }
 
-  void FTMotion::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), float zeta[]/*=cfg.zeta*/) {
-    const float xdf = sqrt(1.0f - sq(zeta[0]));
-    shaping.x.updateShapingN(xf, xdf);
-
+  void FTMotion::update_shaping_params() {
+    #if HAS_X_AXIS
+      shaping.x.ena = CMPNSTR_HAS_SHAPER(X_AXIS);
+      if (shaping.x.ena) {
+        shaping.x.set_axis_shaping_A(cfg.shaper[X_AXIS], cfg.zeta[X_AXIS], cfg.vtol[X_AXIS]);
+        shaping.x.set_axis_shaping_N(cfg.shaper[X_AXIS], cfg.baseFreq[X_AXIS], cfg.zeta[X_AXIS]);
+      }
+    #endif
     #if HAS_Y_AXIS
-      const float ydf = sqrt(1.0f - sq(zeta[1]));
-      shaping.y.updateShapingN(yf, ydf);
+      shaping.y.ena =  CMPNSTR_HAS_SHAPER(Y_AXIS);
+      if (shaping.y.ena) {
+        shaping.y.set_axis_shaping_A(cfg.shaper[Y_AXIS], cfg.zeta[Y_AXIS], cfg.vtol[Y_AXIS]);
+        shaping.y.set_axis_shaping_N(cfg.shaper[Y_AXIS], cfg.baseFreq[Y_AXIS], cfg.zeta[Y_AXIS]);
+      }
     #endif
   }
 
@@ -454,17 +373,17 @@ void FTMotion::reset() {
 
   traj.reset();
 
-  blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
-  batchRdy = batchRdyForInterp = false;
-  runoutEna = false;
+  blockProcRdy = batchRdy = batchRdyForInterp = false;
 
   endPosn_prevBlock.reset();
 
-  makeVector_idx = makeVector_idx_z1 = 0;
-  makeVector_batchIdx = TERN(FTM_UNIFIED_BWS, 0, _MAX(last_batchIdx, FTM_BATCH_SIZE));
+  makeVector_idx = 0;
+  makeVector_batchIdx = TERN(FTM_UNIFIED_BWS, 0, _MIN(BATCH_SIDX_IN_WINDOW, FTM_BATCH_SIZE));
 
   steps.reset();
-  interpIdx = interpIdx_z1 = 0;
+  interpIdx = 0;
+
+  stepper.axis_did_move.reset();
 
   #if HAS_X_AXIS
     ZERO(shaping.x.d_zi);
@@ -473,13 +392,48 @@ void FTMotion::reset() {
   #endif
 
   TERN_(HAS_EXTRUDERS, e_raw_z1 = e_advanced_z1 = 0.0f);
-
-  ZERO(axis_pos_move_end_ti);
-  ZERO(axis_neg_move_end_ti);
 }
 
 // Private functions.
 
+void FTMotion::discard_planner_block_protected() {
+  if (stepper.current_block) {  // Safeguard in case current_block must not be null (it will
+                                // be null when the "block" is a runout or generated) in order
+                                // to use planner.release_current_block().
+    stepper.current_block = nullptr;
+    planner.release_current_block();  // FTM uses release_current_block() instead of discard_current_block(),
+                                      // as in block_phase_isr(). This change is to avoid invoking axis_did_move.reset().
+                                      // current_block = nullptr is added to replicate discard without axis_did_move reset.
+                                      // Note invoking axis_did_move.reset() causes no issue since FTM's stepper refreshes
+                                      // its values every ISR.
+  }
+}
+
+// Sets up a pseudo block to allow motion to settle buffers to empty. This is
+// called when the planner has only one block left. The buffers will be filled
+// with the last commanded position by setting the startPosn block variable to
+// the last position of the previous block and all ratios to zero such that no
+// axes' positions are incremented.
+void FTMotion::runoutBlock() {
+
+  startPosn = endPosn_prevBlock;
+  ratio.reset();
+
+  int32_t n_to_fill_batch = FTM_WINDOW_SIZE - makeVector_batchIdx;
+
+  // This line is to be modified for FBS use; do not optimize out.
+  int32_t n_to_settle_cmpnstr = (TERN_(HAS_X_AXIS, shaping.x.ena) || TERN_(HAS_Y_AXIS, shaping.y.ena )) ? FTM_ZMAX : 0;
+
+  int32_t n_to_fill_batch_after_settling = (n_to_settle_cmpnstr > n_to_fill_batch) ?
+    FTM_BATCH_SIZE - ((n_to_settle_cmpnstr - n_to_fill_batch) % FTM_BATCH_SIZE) : n_to_fill_batch - n_to_settle_cmpnstr;
+
+  int32_t n_to_settle_and_fill_batch = n_to_settle_cmpnstr + n_to_fill_batch_after_settling;
+
+  max_intervals = PROP_BATCHES * FTM_BATCH_SIZE + n_to_settle_and_fill_batch;
+
+  blockProcRdy = true;
+}
+
 // Auxiliary function to get number of step commands in the buffer.
 int32_t FTMotion::stepperCmdBuffItems() {
   const int32_t udiff = stepperCmdBuff_produceIdx - stepperCmdBuff_consumeIdx;
@@ -488,10 +442,7 @@ int32_t FTMotion::stepperCmdBuffItems() {
 
 // Initializes storage variables before startup.
 void FTMotion::init() {
-  #if HAS_X_AXIS
-    refreshShapingN();
-    updateShapingA();
-  #endif
+  update_shaping_params();
   reset(); // Precautionary.
 }
 
@@ -598,42 +549,6 @@ void FTMotion::loadBlockData(block_t * const current_block) {
 
   endPosn_prevBlock += moveDist;
 
-  millis_t move_end_ti = millis() + SEC_TO_MS(FTM_TS*(float)(max_intervals + num_samples_cmpnstr_settle() + (PROP_BATCHES+1)*FTM_BATCH_SIZE) + ((float)FTM_STEPPERCMD_BUFF_SIZE/(float)FTM_STEPPER_FS));
-
-  #if CORE_IS_XY
-    if (moveDist.x > 0.f)              axis_pos_move_end_ti[A_AXIS] = move_end_ti;
-    if (moveDist.y > 0.f)              axis_pos_move_end_ti[B_AXIS] = move_end_ti;
-    if (moveDist.x + moveDist.y > 0.f) axis_pos_move_end_ti[X_HEAD] = move_end_ti;
-    if (moveDist.x - moveDist.y > 0.f) axis_pos_move_end_ti[Y_HEAD] = move_end_ti;
-    if (moveDist.x < 0.f)              axis_neg_move_end_ti[A_AXIS] = move_end_ti;
-    if (moveDist.y < 0.f)              axis_neg_move_end_ti[B_AXIS] = move_end_ti;
-    if (moveDist.x + moveDist.y < 0.f) axis_neg_move_end_ti[X_HEAD] = move_end_ti;
-    if (moveDist.x - moveDist.y < 0.f) axis_neg_move_end_ti[Y_HEAD] = move_end_ti;
-  #else
-    if (moveDist.x > 0.f)              axis_pos_move_end_ti[X_AXIS] = move_end_ti;
-    if (moveDist.y > 0.f)              axis_pos_move_end_ti[Y_AXIS] = move_end_ti;
-    if (moveDist.x < 0.f)              axis_neg_move_end_ti[X_AXIS] = move_end_ti;
-    if (moveDist.y < 0.f)              axis_neg_move_end_ti[Y_AXIS] = move_end_ti;
-  #endif
-  if (moveDist.z > 0.f) axis_pos_move_end_ti[Z_AXIS] = move_end_ti;
-  if (moveDist.z < 0.f) axis_neg_move_end_ti[Z_AXIS] = move_end_ti;
-  // if (moveDist.i > 0.f) axis_pos_move_end_ti[I_AXIS] = move_end_ti;
-  // if (moveDist.i < 0.f) axis_neg_move_end_ti[I_AXIS] = move_end_ti;
-  // if (moveDist.j > 0.f) axis_pos_move_end_ti[J_AXIS] = move_end_ti;
-  // if (moveDist.j < 0.f) axis_neg_move_end_ti[J_AXIS] = move_end_ti;
-  // if (moveDist.k > 0.f) axis_pos_move_end_ti[K_AXIS] = move_end_ti;
-  // if (moveDist.k < 0.f) axis_neg_move_end_ti[K_AXIS] = move_end_ti;
-  // if (moveDist.u > 0.f) axis_pos_move_end_ti[U_AXIS] = move_end_ti;
-  // if (moveDist.u < 0.f) axis_neg_move_end_ti[U_AXIS] = move_end_ti;
-  // .
-  // .
-  // .
-
-  // If the endstop is already pressed, endstop interrupts won't invoke
-  // endstop_triggered and the move will grind. So check here for a
-  // triggered endstop, which shortly marks the block for discard.
-  endstops.update();
-
 }
 
 // Generate data points of the trajectory.
@@ -679,9 +594,14 @@ void FTMotion::makeVector() {
     #if HAS_DYNAMIC_FREQ_MM
       case dynFreqMode_Z_BASED:
         if (traj.z[makeVector_batchIdx] != 0.0f) { // Only update if Z changed.
-                 const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.z[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.z[makeVector_batchIdx]);
-          updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ) OPTARG(HAS_Y_AXIS, _MAX(yf, FTM_MIN_SHAPE_FREQ)));
+          #if HAS_X_AXIS
+            const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.z[makeVector_batchIdx];
+            shaping.x.set_axis_shaping_N(cfg.shaper[X_AXIS], _MAX(xf, FTM_MIN_SHAPE_FREQ), cfg.zeta[X_AXIS]);
+          #endif
+          #if HAS_Y_AXIS
+            const float yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.z[makeVector_batchIdx];
+            shaping.y.set_axis_shaping_N(cfg.shaper[Y_AXIS], _MAX(yf, FTM_MIN_SHAPE_FREQ), cfg.zeta[Y_AXIS]);
+          #endif
         }
         break;
     #endif
@@ -690,43 +610,49 @@ void FTMotion::makeVector() {
       case dynFreqMode_MASS_BASED:
         // Update constantly. The optimization done for Z value makes
         // less sense for E, as E is expected to constantly change.
-        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.e[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.e[makeVector_batchIdx]) );
+        #if HAS_X_AXIS
+          shaping.x.set_axis_shaping_N(cfg.shaper[X_AXIS],  cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.e[makeVector_batchIdx], cfg.zeta[X_AXIS]);
+        #endif
+        #if HAS_Y_AXIS
+          shaping.y.set_axis_shaping_N(cfg.shaper[Y_AXIS], cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.e[makeVector_batchIdx], cfg.zeta[Y_AXIS]);
+        #endif
         break;
     #endif
 
     default: break;
   }
 
-  // Apply shaping if in mode.
+  // Apply shaping if active on each axis
   #if HAS_X_AXIS
-    if (cfg.modeHasShaper()) {
-      shaping.x.d_zi[shaping.zi_idx] = traj.x[makeVector_batchIdx];
-      traj.x[makeVector_batchIdx] *= shaping.x.Ai[0];
+      if (shaping.x.ena) {
+        shaping.x.d_zi[shaping.zi_idx] = traj.x[makeVector_batchIdx];
+        traj.x[makeVector_batchIdx] *= shaping.x.Ai[0];
+        for (uint32_t i = 1U; i <= shaping.x.max_i; i++) {
+          const uint32_t udiffx = shaping.zi_idx - shaping.x.Ni[i];
+          traj.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
+        }
+      }
+
       #if HAS_Y_AXIS
-        shaping.y.d_zi[shaping.zi_idx] = traj.y[makeVector_batchIdx];
-        traj.y[makeVector_batchIdx] *= shaping.y.Ai[0];
+        if (shaping.y.ena) {
+          shaping.y.d_zi[shaping.zi_idx] = traj.y[makeVector_batchIdx];
+          traj.y[makeVector_batchIdx] *= shaping.y.Ai[0];
+          for (uint32_t i = 1U; i <= shaping.y.max_i; i++) {
+            const uint32_t udiffy = shaping.zi_idx - shaping.y.Ni[i];
+            traj.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
+          }
+        }
       #endif
-      for (uint32_t i = 1U; i <= shaping.max_i; i++) {
-        const uint32_t udiffx = shaping.zi_idx - shaping.x.Ni[i];
-        traj.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
-        #if HAS_Y_AXIS
-          const uint32_t udiffy = shaping.zi_idx - shaping.y.Ni[i];
-          traj.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
-        #endif
-      }
       if (++shaping.zi_idx == (FTM_ZMAX)) shaping.zi_idx = 0;
-    }
-  #endif
+    #endif
 
   // Filled up the queue with regular and shaped steps
   if (++makeVector_batchIdx == FTM_WINDOW_SIZE) {
-    makeVector_batchIdx = last_batchIdx;
+    makeVector_batchIdx = BATCH_SIDX_IN_WINDOW;
     batchRdy = true;
   }
 
   if (++makeVector_idx == max_intervals) {
-    blockProcDn = true;
     blockProcRdy = false;
     makeVector_idx = 0;
   }

commit 4f3ebea3a6e7eb0998cf5afb610dee8e39f61583
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sat May 18 00:47:44 2024 +0300

    üêõ Fix FT_MOTION block reference (#27063)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index f92caa7d72..e73c75b9c5 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -762,7 +762,7 @@ void FTMotion::convertToSteps(const uint32_t idx) {
   #if ENABLED(STEPS_ROUNDING)
     #define TOSTEPS(A,B) int32_t(trajMod.A[idx] * planner.settings.axis_steps_per_mm[B] + (trajMod.A[idx] < 0.0f ? -0.5f : 0.5f))
     const xyze_long_t steps_tar = LOGICAL_AXIS_ARRAY(
-      TOSTEPS(e, E_AXIS_N(current_block->extruder)), // May be eliminated if guaranteed positive.
+      TOSTEPS(e, E_AXIS_N(stepper.current_block->extruder)), // May be eliminated if guaranteed positive.
       TOSTEPS(x, X_AXIS), TOSTEPS(y, Y_AXIS), TOSTEPS(z, Z_AXIS),
       TOSTEPS(i, I_AXIS), TOSTEPS(j, J_AXIS), TOSTEPS(k, K_AXIS),
       TOSTEPS(u, U_AXIS), TOSTEPS(v, V_AXIS), TOSTEPS(w, W_AXIS)
@@ -771,7 +771,7 @@ void FTMotion::convertToSteps(const uint32_t idx) {
   #else
     #define TOSTEPS(A,B) int32_t(trajMod.A[idx] * planner.settings.axis_steps_per_mm[B]) - steps.A
     xyze_long_t delta = LOGICAL_AXIS_ARRAY(
-      TOSTEPS(e, E_AXIS_N(current_block->extruder)),
+      TOSTEPS(e, E_AXIS_N(stepper.current_block->extruder)),
       TOSTEPS(x, X_AXIS), TOSTEPS(y, Y_AXIS), TOSTEPS(z, Z_AXIS),
       TOSTEPS(i, I_AXIS), TOSTEPS(j, J_AXIS), TOSTEPS(k, K_AXIS),
       TOSTEPS(u, U_AXIS), TOSTEPS(v, V_AXIS), TOSTEPS(w, W_AXIS)

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index e912255561..f92caa7d72 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -26,6 +26,7 @@
 
 #include "ft_motion.h"
 #include "stepper.h" // Access stepper block queue function and abort status.
+#include "endstops.h"
 
 FTMotion ftMotion;
 
@@ -59,6 +60,9 @@ int32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper comman
         FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
 
 bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items and is in use.
+millis_t FTMotion::axis_pos_move_end_ti[NUM_AXIS_ENUMS] = {0},
+         FTMotion::axis_neg_move_end_ti[NUM_AXIS_ENUMS] = {0};
+
 
 // Private variables.
 
@@ -110,9 +114,9 @@ uint32_t FTMotion::interpIdx = 0,               // Index of current data point b
 #if HAS_X_AXIS
   FTMotion::shaping_t FTMotion::shaping = {
     0, 0,
-    x:{ { 0.0f }, { 0.0f }, { 0 } },            // d_zi, Ai, Ni
+    x:{ false, { 0.0f }, { 0.0f }, { 0 } },            // d_zi, Ai, Ni
     #if HAS_Y_AXIS
-      y:{ { 0.0f }, { 0.0f }, { 0 } }           // d_zi, Ai, Ni
+      y:{ false, { 0.0f }, { 0.0f }, { 0 } }           // d_zi, Ai, Ni
     #endif
   };
 #endif
@@ -131,7 +135,10 @@ constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
 
 // Public functions.
 
+static bool markBlockStart = false;
+
 // Sets controller states to begin processing a block.
+// Called by Stepper::ftMotion_blockQueueUpdate, invoked from the main loop.
 void FTMotion::startBlockProc() {
   blockProcRdy = true;
   blockProcDn = false;
@@ -166,11 +173,13 @@ void FTMotion::loop() {
 
   if (!cfg.mode) return;
 
-  // Handle block abort with the following sequence:
-  // 1. Zero out commands in stepper ISR.
-  // 2. Drain the motion buffer, stop processing until they are emptied.
-  // 3. Reset all the states / memory.
-  // 4. Signal ready for new block.
+  /**
+   * Handle block abort with the following sequence:
+   * 1. Zero out commands in stepper ISR.
+   * 2. Drain the motion buffer, stop processing until they are emptied.
+   * 3. Reset all the states / memory.
+   * 4. Signal ready for new block.
+   */
   if (stepper.abort_current_block) {
     if (sts_stepperBusy) return;          // Wait until motion buffers are emptied
     reset();
@@ -183,7 +192,10 @@ void FTMotion::loop() {
 
   if (blockProcRdy) {
     if (!blockProcRdy_z1) { // One-shot.
-      if (!blockDataIsRunout) loadBlockData(stepper.current_block);
+      if (!blockDataIsRunout) {
+        loadBlockData(stepper.current_block);
+        markBlockStart = true;
+      }
       else blockDataIsRunout = false;
     }
     while (!blockProcDn && !batchRdy && (makeVector_idx - makeVector_idx_z1 < (FTM_POINTS_PER_LOOP)))
@@ -199,22 +211,12 @@ void FTMotion::loop() {
       trajMod = traj; // Move the window to traj
     #else
       // Copy the uncompensated vectors.
-      #define TCOPY(A) memcpy(trajMod.A, traj.A, sizeof(trajMod.A))
-      LOGICAL_AXIS_CODE(
-        TCOPY(e),
-        TCOPY(x), TCOPY(y), TCOPY(z),
-        TCOPY(i), TCOPY(j), TCOPY(k),
-        TCOPY(u), TCOPY(v), TCOPY(w)
-      );
+      #define TCOPY(A) memcpy(trajMod.A, traj.A, sizeof(trajMod.A));
+      LOGICAL_AXIS_MAP_LC(TCOPY);
 
       // Shift the time series back in the window
-      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], last_batchIdx * sizeof(traj.A[0]))
-      LOGICAL_AXIS_CODE(
-        TSHIFT(e),
-        TSHIFT(x), TSHIFT(y), TSHIFT(z),
-        TSHIFT(i), TSHIFT(j), TSHIFT(k),
-        TSHIFT(u), TSHIFT(v), TSHIFT(w)
-      );
+      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], last_batchIdx * sizeof(traj.A[0]));
+      LOGICAL_AXIS_MAP_LC(TSHIFT);
     #endif
 
     // ... data is ready in trajMod.
@@ -471,6 +473,9 @@ void FTMotion::reset() {
   #endif
 
   TERN_(HAS_EXTRUDERS, e_raw_z1 = e_advanced_z1 = 0.0f);
+
+  ZERO(axis_pos_move_end_ti);
+  ZERO(axis_neg_move_end_ti);
 }
 
 // Private functions.
@@ -490,14 +495,14 @@ void FTMotion::init() {
   reset(); // Precautionary.
 }
 
-// Loads / converts block data from planner to fixed-time control variables.
+// Load / convert block data from planner to fixed-time control variables.
 void FTMotion::loadBlockData(block_t * const current_block) {
 
   const float totalLength = current_block->millimeters,
               oneOverLength = 1.0f / totalLength;
 
   startPosn = endPosn_prevBlock;
-  xyze_pos_t moveDist = LOGICAL_AXIS_ARRAY(
+  const xyze_pos_t moveDist = LOGICAL_AXIS_ARRAY(
     current_block->steps.e * planner.mm_per_step[E_AXIS_N(current_block->extruder)] * (current_block->direction_bits.e ? 1 : -1),
     current_block->steps.x * planner.mm_per_step[X_AXIS] * (current_block->direction_bits.x ? 1 : -1),
     current_block->steps.y * planner.mm_per_step[Y_AXIS] * (current_block->direction_bits.y ? 1 : -1),
@@ -574,7 +579,8 @@ void FTMotion::loadBlockData(block_t * const current_block) {
    *  f_s * T1_P : (mm) Distance traveled during the accel phase
    *  f_e * T3_P : (mm) Distance traveled during the decel phase
    */
-  F_P = (2.0f * totalLength - f_s * T1_P - f_e * T3_P) / (T1_P + 2.0f * T2_P + T3_P); // (mm/s) Feedrate at the end of the accel phase
+  const float adist = f_s * T1_P;
+  F_P = (2.0f * totalLength - adist - f_e * T3_P) / (T1_P + 2.0f * T2_P + T3_P); // (mm/s) Feedrate at the end of the accel phase
 
   // Calculate the acceleration and deceleration rates
   accel_P = N1 ? ((F_P - f_s) / T1_P) : 0.0f;
@@ -582,7 +588,7 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   decel_P = (f_e - F_P) / T3_P;
 
   // Calculate the distance traveled during the accel phase
-  s_1e = f_s * T1_P + 0.5f * accel_P * sq(T1_P);
+  s_1e = adist + 0.5f * accel_P * sq(T1_P);
 
   // Calculate the distance traveled during the decel phase
   s_2e = s_1e + F_P * T2_P;
@@ -591,6 +597,43 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   max_intervals = N1 + N2 + N3;
 
   endPosn_prevBlock += moveDist;
+
+  millis_t move_end_ti = millis() + SEC_TO_MS(FTM_TS*(float)(max_intervals + num_samples_cmpnstr_settle() + (PROP_BATCHES+1)*FTM_BATCH_SIZE) + ((float)FTM_STEPPERCMD_BUFF_SIZE/(float)FTM_STEPPER_FS));
+
+  #if CORE_IS_XY
+    if (moveDist.x > 0.f)              axis_pos_move_end_ti[A_AXIS] = move_end_ti;
+    if (moveDist.y > 0.f)              axis_pos_move_end_ti[B_AXIS] = move_end_ti;
+    if (moveDist.x + moveDist.y > 0.f) axis_pos_move_end_ti[X_HEAD] = move_end_ti;
+    if (moveDist.x - moveDist.y > 0.f) axis_pos_move_end_ti[Y_HEAD] = move_end_ti;
+    if (moveDist.x < 0.f)              axis_neg_move_end_ti[A_AXIS] = move_end_ti;
+    if (moveDist.y < 0.f)              axis_neg_move_end_ti[B_AXIS] = move_end_ti;
+    if (moveDist.x + moveDist.y < 0.f) axis_neg_move_end_ti[X_HEAD] = move_end_ti;
+    if (moveDist.x - moveDist.y < 0.f) axis_neg_move_end_ti[Y_HEAD] = move_end_ti;
+  #else
+    if (moveDist.x > 0.f)              axis_pos_move_end_ti[X_AXIS] = move_end_ti;
+    if (moveDist.y > 0.f)              axis_pos_move_end_ti[Y_AXIS] = move_end_ti;
+    if (moveDist.x < 0.f)              axis_neg_move_end_ti[X_AXIS] = move_end_ti;
+    if (moveDist.y < 0.f)              axis_neg_move_end_ti[Y_AXIS] = move_end_ti;
+  #endif
+  if (moveDist.z > 0.f) axis_pos_move_end_ti[Z_AXIS] = move_end_ti;
+  if (moveDist.z < 0.f) axis_neg_move_end_ti[Z_AXIS] = move_end_ti;
+  // if (moveDist.i > 0.f) axis_pos_move_end_ti[I_AXIS] = move_end_ti;
+  // if (moveDist.i < 0.f) axis_neg_move_end_ti[I_AXIS] = move_end_ti;
+  // if (moveDist.j > 0.f) axis_pos_move_end_ti[J_AXIS] = move_end_ti;
+  // if (moveDist.j < 0.f) axis_neg_move_end_ti[J_AXIS] = move_end_ti;
+  // if (moveDist.k > 0.f) axis_pos_move_end_ti[K_AXIS] = move_end_ti;
+  // if (moveDist.k < 0.f) axis_neg_move_end_ti[K_AXIS] = move_end_ti;
+  // if (moveDist.u > 0.f) axis_pos_move_end_ti[U_AXIS] = move_end_ti;
+  // if (moveDist.u < 0.f) axis_neg_move_end_ti[U_AXIS] = move_end_ti;
+  // .
+  // .
+  // .
+
+  // If the endstop is already pressed, endstop interrupts won't invoke
+  // endstop_triggered and the move will grind. So check here for a
+  // triggered endstop, which shortly marks the block for discard.
+  endstops.update();
+
 }
 
 // Generate data points of the trajectory.
@@ -607,7 +650,6 @@ void FTMotion::makeVector() {
   else if (makeVector_idx < (N1 + N2)) {
     // Coasting phase
     dist = s_1e + F_P * (tau - N1 * (FTM_TS));          // (mm) Distance traveled for coasting phase since start of block
-    //accel_k = 0.0f;
   }
   else {
     // Deceleration phase
@@ -616,18 +658,8 @@ void FTMotion::makeVector() {
     accel_k = decel_P;                                  // (mm/s^2) Acceleration K factor from Decel phase
   }
 
-  LOGICAL_AXIS_CODE(
-    traj.e[makeVector_batchIdx] = startPosn.e + ratio.e * dist,
-    traj.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
-    traj.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
-    traj.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
-    traj.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
-    traj.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
-    traj.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
-    traj.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
-    traj.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
-    traj.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
-  );
+  #define _FTM_TRAJ(A) traj.A[makeVector_batchIdx] = startPosn.A + ratio.A * dist;
+  LOGICAL_AXIS_MAP_LC(_FTM_TRAJ);
 
   #if HAS_EXTRUDERS
     if (cfg.linearAdvEna) {
@@ -706,7 +738,7 @@ void FTMotion::makeVector() {
  * - Tests for delta are moved outside the loop.
  * - Two functions are used for command computation with an array of function pointers.
  */
-static void (*command_set[NUM_AXES TERN0(HAS_EXTRUDERS, +1)])(int32_t&, int32_t&, ft_command_t&, int32_t, int32_t);
+static void (*command_set[SUM_TERN(HAS_EXTRUDERS, NUM_AXES, 1)])(int32_t&, int32_t&, ft_command_t&, int32_t, int32_t);
 
 static void command_set_pos(int32_t &e, int32_t &s, ft_command_t &b, int32_t bd, int32_t bs) {
   if (e < FTM_CTS_COMPARE_VAL) return;
@@ -746,40 +778,30 @@ void FTMotion::convertToSteps(const uint32_t idx) {
     );
   #endif
 
-  LOGICAL_AXIS_CODE(
-    command_set[E_AXIS_N(current_block->extruder)] = delta.e >= 0 ?  command_set_pos : command_set_neg,
-    command_set[X_AXIS] = delta.x >= 0 ?  command_set_pos : command_set_neg,
-    command_set[Y_AXIS] = delta.y >= 0 ?  command_set_pos : command_set_neg,
-    command_set[Z_AXIS] = delta.z >= 0 ?  command_set_pos : command_set_neg,
-    command_set[I_AXIS] = delta.i >= 0 ?  command_set_pos : command_set_neg,
-    command_set[J_AXIS] = delta.j >= 0 ?  command_set_pos : command_set_neg,
-    command_set[K_AXIS] = delta.k >= 0 ?  command_set_pos : command_set_neg,
-    command_set[U_AXIS] = delta.u >= 0 ?  command_set_pos : command_set_neg,
-    command_set[V_AXIS] = delta.v >= 0 ?  command_set_pos : command_set_neg,
-    command_set[W_AXIS] = delta.w >= 0 ?  command_set_pos : command_set_neg
-  );
+  #define _COMMAND_SET(AXIS) command_set[_AXIS(AXIS)] = delta[_AXIS(AXIS)] >= 0 ? command_set_pos : command_set_neg;
+  LOGICAL_AXIS_MAP(_COMMAND_SET);
 
   for (uint32_t i = 0U; i < (FTM_STEPS_PER_UNIT_TIME); i++) {
 
+    ft_command_t &cmd = stepperCmdBuff[stepperCmdBuff_produceIdx];
+
     // Init all step/dir bits to 0 (defaulting to reverse/negative motion)
-    stepperCmdBuff[stepperCmdBuff_produceIdx] = 0;
+    cmd = 0;
+
+    // Mark the start of a new block
+    if (markBlockStart) {
+      cmd = _BV(FT_BIT_START);
+      markBlockStart = false;
+    }
 
+    // Accumulate the errors for all axes
     err_P += delta;
 
     // Set up step/dir bits for all axes
-    LOGICAL_AXIS_CODE(
-      command_set[E_AXIS_N(current_block->extruder)](err_P.e, steps.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E), _BV(FT_BIT_STEP_E)),
-      command_set[X_AXIS](err_P.x, steps.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X), _BV(FT_BIT_STEP_X)),
-      command_set[Y_AXIS](err_P.y, steps.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y), _BV(FT_BIT_STEP_Y)),
-      command_set[Z_AXIS](err_P.z, steps.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z), _BV(FT_BIT_STEP_Z)),
-      command_set[I_AXIS](err_P.i, steps.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I), _BV(FT_BIT_STEP_I)),
-      command_set[J_AXIS](err_P.j, steps.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J), _BV(FT_BIT_STEP_J)),
-      command_set[K_AXIS](err_P.k, steps.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K), _BV(FT_BIT_STEP_K)),
-      command_set[U_AXIS](err_P.u, steps.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U), _BV(FT_BIT_STEP_U)),
-      command_set[V_AXIS](err_P.v, steps.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V), _BV(FT_BIT_STEP_V)),
-      command_set[W_AXIS](err_P.w, steps.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W), _BV(FT_BIT_STEP_W)),
-    );
+    #define _COMMAND_RUN(AXIS) command_set[_AXIS(AXIS)](err_P[_AXIS(AXIS)], steps[_AXIS(AXIS)], cmd, _BV(FT_BIT_DIR_##AXIS), _BV(FT_BIT_STEP_##AXIS));
+    LOGICAL_AXIS_MAP(_COMMAND_RUN);
 
+    // Next circular buffer index
     if (++stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE))
       stepperCmdBuff_produceIdx = 0;
 

commit b106f59eb495718d7158e27347eca5deb11fbe86
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jan 8 05:17:43 2024 +0100

    üêõ Refine FT Motion, I2S Stepping (#26628)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 447f372e63..e912255561 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -55,8 +55,8 @@ FTMotion ftMotion;
 ft_config_t FTMotion::cfg;
 bool FTMotion::busy; // = false
 ft_command_t FTMotion::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U}; // Stepper commands buffer.
-uint32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper command write to the buffer.
-         FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
+int32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper command write to the buffer.
+        FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
 
 bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items and is in use.
 
@@ -123,6 +123,8 @@ uint32_t FTMotion::interpIdx = 0,               // Index of current data point b
   float FTMotion::e_advanced_z1 = 0.0f;   // (ms) Unit delay of advanced extruder position.
 #endif
 
+constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
+
 //-----------------------------------------------------------------
 // Function definitions.
 //-----------------------------------------------------------------
@@ -145,8 +147,16 @@ void FTMotion::runoutBlock() {
   ratio.reset();
 
   max_intervals = cfg.modeHasShaper() ? shaper_intervals : 0;
-  if (max_intervals <= TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, min_max_intervals - (FTM_BATCH_SIZE))) max_intervals = min_max_intervals;
-  max_intervals += TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, FTM_WINDOW_SIZE) - makeVector_batchIdx;
+  if (max_intervals <= TERN(FTM_UNIFIED_BWS, FTM_BATCH_SIZE, min_max_intervals - (FTM_BATCH_SIZE)))
+    max_intervals = min_max_intervals;
+
+  max_intervals += (
+    #if ENABLED(FTM_UNIFIED_BWS)
+      FTM_WINDOW_SIZE - makeVector_batchIdx
+    #else
+      FTM_WINDOW_SIZE - ((last_batchIdx < (FTM_BATCH_SIZE)) ? 0 : makeVector_batchIdx)
+    #endif
+  );
   blockProcRdy = blockDataIsRunout = true;
   runoutEna = blockProcDn = false;
 }
@@ -198,7 +208,7 @@ void FTMotion::loop() {
       );
 
       // Shift the time series back in the window
-      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], (FTM_WINDOW_SIZE - FTM_BATCH_SIZE) * sizeof(traj.A[0]))
+      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], last_batchIdx * sizeof(traj.A[0]))
       LOGICAL_AXIS_CODE(
         TSHIFT(e),
         TSHIFT(x), TSHIFT(y), TSHIFT(z),
@@ -219,7 +229,7 @@ void FTMotion::loop() {
     && (interpIdx - interpIdx_z1 < (FTM_STEPS_PER_LOOP))
   ) {
     convertToSteps(interpIdx);
-    if (++interpIdx == TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, FTM_BATCH_SIZE)) {
+    if (++interpIdx == FTM_BATCH_SIZE) {
       batchRdyForInterp = false;
       interpIdx = 0;
     }
@@ -449,7 +459,7 @@ void FTMotion::reset() {
   endPosn_prevBlock.reset();
 
   makeVector_idx = makeVector_idx_z1 = 0;
-  makeVector_batchIdx = 0;
+  makeVector_batchIdx = TERN(FTM_UNIFIED_BWS, 0, _MAX(last_batchIdx, FTM_BATCH_SIZE));
 
   steps.reset();
   interpIdx = interpIdx_z1 = 0;
@@ -464,10 +474,11 @@ void FTMotion::reset() {
 }
 
 // Private functions.
+
 // Auxiliary function to get number of step commands in the buffer.
-uint32_t FTMotion::stepperCmdBuffItems() {
-  const uint32_t udiff = stepperCmdBuff_produceIdx - stepperCmdBuff_consumeIdx;
-  return stepperCmdBuff_produceIdx < stepperCmdBuff_consumeIdx ? (FTM_STEPPERCMD_BUFF_SIZE) + udiff : udiff;
+int32_t FTMotion::stepperCmdBuffItems() {
+  const int32_t udiff = stepperCmdBuff_produceIdx - stepperCmdBuff_consumeIdx;
+  return (udiff < 0) ? udiff + (FTM_STEPPERCMD_BUFF_SIZE) : udiff;
 }
 
 // Initializes storage variables before startup.
@@ -677,8 +688,8 @@ void FTMotion::makeVector() {
   #endif
 
   // Filled up the queue with regular and shaped steps
-  if (++makeVector_batchIdx == TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, (FTM_WINDOW_SIZE - FTM_BATCH_SIZE))) {
-    makeVector_batchIdx = 0;
+  if (++makeVector_batchIdx == FTM_WINDOW_SIZE) {
+    makeVector_batchIdx = last_batchIdx;
     batchRdy = true;
   }
 

commit 5987a5464bc8622d77ab52990b88d5ae035074e1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 7 19:34:34 2024 -0600

    üé® Use float CEIL/FLOOR

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index ba1361f922..447f372e63 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -544,9 +544,9 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   const float T1 = (F_n - f_s) * oneOverAccel,
               T3 = (F_n - f_e) * oneOverAccel;
 
-  N1 = ceil(T1 * (FTM_FS));         // Accel datapoints based on Hz frequency
-  N2 = ceil(T2 * (FTM_FS));         // Coast
-  N3 = ceil(T3 * (FTM_FS));         // Decel
+  N1 = CEIL(T1 * (FTM_FS));         // Accel datapoints based on Hz frequency
+  N2 = CEIL(T2 * (FTM_FS));         // Coast
+  N3 = CEIL(T3 * (FTM_FS));         // Decel
 
   const float T1_P = N1 * (FTM_TS), // (s) Accel datapoints x timestep resolution
               T2_P = N2 * (FTM_TS), // (s) Coast

commit 95878df30d737fd08f337491f7e19332fe7ac5ac
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Sun Dec 31 22:00:57 2023 +0100

    üêõ Fix homing with FT_MOTION (#26595)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 0e1ade69f0..ba1361f922 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -501,11 +501,13 @@ void FTMotion::loadBlockData(block_t * const current_block) {
 
   ratio = moveDist * oneOverLength;
 
-  /* Keep for comprehension
   const float spm = totalLength / current_block->step_event_count;  // (steps/mm) Distance for each step
-              f_s = spm * current_block->initial_rate,  // (steps/s) Start feedrate
-              f_e = spm * current_block->final_rate;    // (steps/s) End feedrate
 
+  f_s = spm * current_block->initial_rate;              // (steps/s) Start feedrate
+
+  const float f_e = spm * current_block->final_rate;    // (steps/s) End feedrate
+
+  /* Keep for comprehension
   const float a = current_block->acceleration,          // (mm/s^2) Same magnitude for acceleration or deceleration
               oneby2a = 1.0f / (2.0f * a),              // (s/mm) Time to accelerate or decelerate one mm (i.e., oneby2a * 2
               oneby2d = -oneby2a;                       // (s/mm) Time to accelerate or decelerate one mm (i.e., oneby2a * 2
@@ -527,10 +529,6 @@ void FTMotion::loadBlockData(block_t * const current_block) {
               T3 = (F_n - f_e) / a;                     // (s) Decel Time = difference in feedrate over acceleration
   */
 
-  const float spm = totalLength / current_block->step_event_count,
-              f_s = spm * current_block->initial_rate,
-              f_e = spm * current_block->final_rate;
-
   const float accel = current_block->acceleration,
               oneOverAccel = 1.0f / accel;
 

commit ba91fa09b7f16f788f441d6385d813cb64b5f508
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Fri Dec 29 05:41:34 2023 +0100

    ‚ö°Ô∏è Optimize FT_MOTION (#26557)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 674b66f581..0e1ade69f0 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -46,9 +46,9 @@ FTMotion ftMotion;
   static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_MASS_BASED, "dynFreqMode_MASS_BASED requires an X axis and an extruder.");
 #endif
 
-//-----------------------------------------------------------------//
+//-----------------------------------------------------------------
 // Variables.
-//-----------------------------------------------------------------//
+//-----------------------------------------------------------------
 
 // Public variables.
 
@@ -61,10 +61,10 @@ uint32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper comma
 bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items and is in use.
 
 // Private variables.
+
 // NOTE: These are sized for Ulendo FBS use.
-  xyze_trajectory_t FTMotion::traj;               // = {0.0f} Storage for fixed-time-based trajectory.
-  xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for modified fixed-time-based trajectory.
-  xyze_trajectoryWin_t FTMotion::trajWin;         // = {0.0f} Storage for fixed time trajectory window.
+xyze_trajectory_t    FTMotion::traj;            // = {0.0f} Storage for fixed-time-based trajectory.
+xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for fixed time trajectory window.
 
 bool FTMotion::blockProcRdy = false,            // Indicates a block is ready to be processed.
      FTMotion::blockProcRdy_z1 = false,         // Storage for the previous indicator.
@@ -96,23 +96,23 @@ uint32_t FTMotion::N1,                          // Number of data points in the
 uint32_t FTMotion::max_intervals;               // Total number of data points that will be generated from block.
 
 // Make vector variables.
-uint32_t FTMotion::makeVector_idx = 0,                    // Index of fixed time trajectory generation of the overall block.
-         FTMotion::makeVector_idx_z1 = 0,                 // Storage for the previously calculated index above.
-         FTMotion::makeVector_batchIdx = 0;               // Index of fixed time trajectory generation within the batch.
+uint32_t FTMotion::makeVector_idx = 0,          // Index of fixed time trajectory generation of the overall block.
+         FTMotion::makeVector_idx_z1 = 0,       // Storage for the previously calculated index above.
+         FTMotion::makeVector_batchIdx = 0;     // Index of fixed time trajectory generation within the batch.
 
 // Interpolation variables.
-xyze_long_t FTMotion::steps = { 0 };                  // Step count accumulator.
+xyze_long_t FTMotion::steps = { 0 };            // Step count accumulator.
 
-uint32_t FTMotion::interpIdx = 0,                     // Index of current data point being interpolated.
-         FTMotion::interpIdx_z1 = 0;                  // Storage for the previously calculated index above.
+uint32_t FTMotion::interpIdx = 0,               // Index of current data point being interpolated.
+         FTMotion::interpIdx_z1 = 0;            // Storage for the previously calculated index above.
 
 // Shaping variables.
 #if HAS_X_AXIS
   FTMotion::shaping_t FTMotion::shaping = {
     0, 0,
-    x:{ { 0.0f }, { 0.0f }, { 0 } },                  // d_zi, Ai, Ni
+    x:{ { 0.0f }, { 0.0f }, { 0 } },            // d_zi, Ai, Ni
     #if HAS_Y_AXIS
-      y:{ { 0.0f }, { 0.0f }, { 0 } }                 // d_zi, Ai, Ni
+      y:{ { 0.0f }, { 0.0f }, { 0 } }           // d_zi, Ai, Ni
     #endif
   };
 #endif
@@ -123,9 +123,9 @@ uint32_t FTMotion::interpIdx = 0,                     // Index of current data p
   float FTMotion::e_advanced_z1 = 0.0f;   // (ms) Unit delay of advanced extruder position.
 #endif
 
-//-----------------------------------------------------------------//
+//-----------------------------------------------------------------
 // Function definitions.
-//-----------------------------------------------------------------//
+//-----------------------------------------------------------------
 
 // Public functions.
 
@@ -186,8 +186,7 @@ void FTMotion::loop() {
     // Call Ulendo FBS here.
 
     #if ENABLED(FTM_UNIFIED_BWS)
-      trajMod = traj; // Copy the uncompensated vectors.
-      traj = trajWin; // Move the window to traj
+      trajMod = traj; // Move the window to traj
     #else
       // Copy the uncompensated vectors.
       #define TCOPY(A) memcpy(trajMod.A, traj.A, sizeof(trajMod.A))
@@ -199,7 +198,7 @@ void FTMotion::loop() {
       );
 
       // Shift the time series back in the window
-      #define TSHIFT(A) memcpy(traj.A, trajWin.A, sizeof(trajWin.A))
+      #define TSHIFT(A) memcpy(traj.A, &traj.A[FTM_BATCH_SIZE], (FTM_WINDOW_SIZE - FTM_BATCH_SIZE) * sizeof(traj.A[0]))
       LOGICAL_AXIS_CODE(
         TSHIFT(e),
         TSHIFT(x), TSHIFT(y), TSHIFT(z),
@@ -215,12 +214,11 @@ void FTMotion::loop() {
   }
 
   // Interpolation.
-  while ( batchRdyForInterp
-          && ( stepperCmdBuffItems() < (FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME) )
-          && ( interpIdx - interpIdx_z1 < (FTM_STEPS_PER_LOOP) )
+  while (batchRdyForInterp
+    && (stepperCmdBuffItems() < (FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME))
+    && (interpIdx - interpIdx_z1 < (FTM_STEPS_PER_LOOP))
   ) {
     convertToSteps(interpIdx);
-
     if (++interpIdx == TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, FTM_BATCH_SIZE)) {
       batchRdyForInterp = false;
       interpIdx = 0;
@@ -443,7 +441,6 @@ void FTMotion::reset() {
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
   traj.reset();
-  trajWin.reset();
 
   blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
   batchRdy = batchRdyForInterp = false;
@@ -611,26 +608,26 @@ void FTMotion::makeVector() {
   }
 
   LOGICAL_AXIS_CODE(
-    trajWin.e[makeVector_batchIdx] = startPosn.e + ratio.e * dist,
-    trajWin.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
-    trajWin.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
-    trajWin.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
-    trajWin.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
-    trajWin.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
-    trajWin.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
-    trajWin.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
-    trajWin.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
-    trajWin.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
+    traj.e[makeVector_batchIdx] = startPosn.e + ratio.e * dist,
+    traj.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
+    traj.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
+    traj.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
+    traj.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
+    traj.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
+    traj.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
+    traj.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
+    traj.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
+    traj.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
   );
 
   #if HAS_EXTRUDERS
     if (cfg.linearAdvEna) {
-      float dedt_adj = (trajWin.e[makeVector_batchIdx] - e_raw_z1) * (FTM_FS);
+      float dedt_adj = (traj.e[makeVector_batchIdx] - e_raw_z1) * (FTM_FS);
       if (ratio.e > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
 
-      e_raw_z1 = trajWin.e[makeVector_batchIdx];
+      e_raw_z1 = traj.e[makeVector_batchIdx];
       e_advanced_z1 += dedt_adj * (FTM_TS);
-      trajWin.e[makeVector_batchIdx] = e_advanced_z1;
+      traj.e[makeVector_batchIdx] = e_advanced_z1;
     }
   #endif
 
@@ -640,9 +637,9 @@ void FTMotion::makeVector() {
 
     #if HAS_DYNAMIC_FREQ_MM
       case dynFreqMode_Z_BASED:
-        if (trajWin.z[makeVector_batchIdx] != 0.0f) { // Only update if Z changed.
-                 const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * trajWin.z[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * trajWin.z[makeVector_batchIdx]);
+        if (traj.z[makeVector_batchIdx] != 0.0f) { // Only update if Z changed.
+                 const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.z[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.z[makeVector_batchIdx]);
           updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ) OPTARG(HAS_Y_AXIS, _MAX(yf, FTM_MIN_SHAPE_FREQ)));
         }
         break;
@@ -652,8 +649,8 @@ void FTMotion::makeVector() {
       case dynFreqMode_MASS_BASED:
         // Update constantly. The optimization done for Z value makes
         // less sense for E, as E is expected to constantly change.
-        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * trajWin.e[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * trajWin.e[makeVector_batchIdx]) );
+        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.e[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.e[makeVector_batchIdx]) );
         break;
     #endif
 
@@ -663,18 +660,18 @@ void FTMotion::makeVector() {
   // Apply shaping if in mode.
   #if HAS_X_AXIS
     if (cfg.modeHasShaper()) {
-      shaping.x.d_zi[shaping.zi_idx] = trajWin.x[makeVector_batchIdx];
-      trajWin.x[makeVector_batchIdx] *= shaping.x.Ai[0];
+      shaping.x.d_zi[shaping.zi_idx] = traj.x[makeVector_batchIdx];
+      traj.x[makeVector_batchIdx] *= shaping.x.Ai[0];
       #if HAS_Y_AXIS
-        shaping.y.d_zi[shaping.zi_idx] = trajWin.y[makeVector_batchIdx];
-        trajWin.y[makeVector_batchIdx] *= shaping.y.Ai[0];
+        shaping.y.d_zi[shaping.zi_idx] = traj.y[makeVector_batchIdx];
+        traj.y[makeVector_batchIdx] *= shaping.y.Ai[0];
       #endif
       for (uint32_t i = 1U; i <= shaping.max_i; i++) {
         const uint32_t udiffx = shaping.zi_idx - shaping.x.Ni[i];
-        trajWin.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
+        traj.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
         #if HAS_Y_AXIS
           const uint32_t udiffy = shaping.zi_idx - shaping.y.Ni[i];
-          trajWin.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
+          traj.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
         #endif
       }
       if (++shaping.zi_idx == (FTM_ZMAX)) shaping.zi_idx = 0;

commit 205b0a679e3ca7cbf7ca590279d1cd4ed0c284c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 23 04:19:23 2023 -0600

    üé® Whitespace in the rightplace

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index a2049db3b6..674b66f581 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -324,7 +324,7 @@ void FTMotion::loop() {
         x.Ai[1] = (0.5f - x.Ai[0]) * Kx;
         x.Ai[2] = x.Ai[1] * Kx;
         x.Ai[3] = x.Ai[0] * cu(Kx);
-       
+
         const float vtoly2 = sq(vtol[1]);
         const float Y = pow(vtoly2 * (sqrt(1.0f - vtoly2) + 1.0f), 1.0f / 3.0f);
         y.Ai[0] = (3.0f * sq(Y) + 2.0f * Y + 3.0f * vtoly2) / (16.0f * Y);
@@ -361,7 +361,7 @@ void FTMotion::loop() {
           x.Ai[i] *= X_adj;
           y.Ai[i] *= Y_adj;
         }
-      }    
+      }
       break;
 
       case ftMotionMode_MZV: {
@@ -375,7 +375,7 @@ void FTMotion::loop() {
         y.Ai[0] = 1.0f / (1.0f + By + Ky2);
         y.Ai[1] = y.Ai[0] * By;
         y.Ai[2] = y.Ai[0] * Ky2;
-      } 
+      }
       break;
 
       default:
@@ -383,7 +383,7 @@ void FTMotion::loop() {
         ZERO(y.Ai);
         max_i = 0;
     }
-    
+
   }
 
   void FTMotion::updateShapingA(float zeta[]/*=cfg.zeta*/, float vtol[]/*=cfg.vtol*/) {
@@ -428,7 +428,7 @@ void FTMotion::loop() {
   void FTMotion::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), float zeta[]/*=cfg.zeta*/) {
     const float xdf = sqrt(1.0f - sq(zeta[0]));
     shaping.x.updateShapingN(xf, xdf);
-    
+
     #if HAS_Y_AXIS
       const float ydf = sqrt(1.0f - sq(zeta[1]));
       shaping.y.updateShapingN(yf, ydf);

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    üêõ‚ö°Ô∏è FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index ad37e8a9b3..a2049db3b6 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -32,6 +32,8 @@ FTMotion ftMotion;
 #if !HAS_X_AXIS
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZV, "ftMotionMode_ZV requires at least one linear axis.");
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVD, "ftMotionMode_ZVD requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVDD, "ftMotionMode_ZVD requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVDDD, "ftMotionMode_ZVD requires at least one linear axis.");
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_EI, "ftMotionMode_EI requires at least one linear axis.");
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_2HEI, "ftMotionMode_2HEI requires at least one linear axis.");
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_3HEI, "ftMotionMode_3HEI requires at least one linear axis.");
@@ -52,9 +54,7 @@ FTMotion ftMotion;
 
 ft_config_t FTMotion::cfg;
 bool FTMotion::busy; // = false
-ft_command_t FTMotion::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U};               // Buffer of stepper commands.
-hal_timer_t FTMotion::stepperCmdBuff_StepRelativeTi[FTM_STEPPERCMD_BUFF_SIZE] = {0U}; // Buffer of the stepper command timing.
-uint8_t FTMotion::stepperCmdBuff_ApplyDir[FTM_STEPPERCMD_DIR_SIZE] = {0U};            // Buffer of whether DIR needs to be updated.
+ft_command_t FTMotion::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U}; // Stepper commands buffer.
 uint32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper command write to the buffer.
          FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
 
@@ -62,10 +62,10 @@ bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items
 
 // Private variables.
 // NOTE: These are sized for Ulendo FBS use.
-xyze_trajectory_t FTMotion::traj;               // = {0.0f} Storage for fixed-time-based trajectory.
-xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for modified fixed-time-based trajectory.
+  xyze_trajectory_t FTMotion::traj;               // = {0.0f} Storage for fixed-time-based trajectory.
+  xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for modified fixed-time-based trajectory.
+  xyze_trajectoryWin_t FTMotion::trajWin;         // = {0.0f} Storage for fixed time trajectory window.
 
-block_t* FTMotion::current_block_cpy = nullptr; // Pointer to current block being processed.
 bool FTMotion::blockProcRdy = false,            // Indicates a block is ready to be processed.
      FTMotion::blockProcRdy_z1 = false,         // Storage for the previous indicator.
      FTMotion::blockProcDn = false;             // Indicates current block is done being processed.
@@ -76,7 +76,7 @@ bool FTMotion::batchRdy = false;                // Indicates a batch of the fixe
 bool FTMotion::batchRdyForInterp = false;       // Indicates the batch is done being post processed,
                                                 //  if applicable, and is ready to be converted to step commands.
 bool FTMotion::runoutEna = false;               // True if runout of the block hasn't been done and is allowed.
-bool FTMotion::runout = false;                  // Indicates if runout is in progress.
+bool FTMotion::blockDataIsRunout = false;       // Indicates the last loaded block variables are for a runout.
 
 // Trapezoid data variables.
 xyze_pos_t   FTMotion::startPosn,                     // (mm) Start position of block
@@ -98,15 +98,13 @@ uint32_t FTMotion::max_intervals;               // Total number of data points t
 // Make vector variables.
 uint32_t FTMotion::makeVector_idx = 0,                    // Index of fixed time trajectory generation of the overall block.
          FTMotion::makeVector_idx_z1 = 0,                 // Storage for the previously calculated index above.
-         FTMotion::makeVector_batchIdx = FTM_BATCH_SIZE;  // Index of fixed time trajectory generation within the batch.
+         FTMotion::makeVector_batchIdx = 0;               // Index of fixed time trajectory generation within the batch.
 
 // Interpolation variables.
 xyze_long_t FTMotion::steps = { 0 };                  // Step count accumulator.
-xyze_stepDir_t FTMotion::dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET); // Memory of the currently set step direction of the axis.
 
 uint32_t FTMotion::interpIdx = 0,                     // Index of current data point being interpolated.
          FTMotion::interpIdx_z1 = 0;                  // Storage for the previously calculated index above.
-hal_timer_t FTMotion::nextStepTicks = FTM_MIN_TICKS;  // Accumulator for the next step time (in ticks).
 
 // Shaping variables.
 #if HAS_X_AXIS
@@ -125,8 +123,6 @@ hal_timer_t FTMotion::nextStepTicks = FTM_MIN_TICKS;  // Accumulator for the nex
   float FTMotion::e_advanced_z1 = 0.0f;   // (ms) Unit delay of advanced extruder position.
 #endif
 
-constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
-
 //-----------------------------------------------------------------//
 // Function definitions.
 //-----------------------------------------------------------------//
@@ -134,8 +130,7 @@ constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
 // Public functions.
 
 // Sets controller states to begin processing a block.
-void FTMotion::startBlockProc(block_t * const current_block) {
-  current_block_cpy = current_block;
+void FTMotion::startBlockProc() {
   blockProcRdy = true;
   blockProcDn = false;
   runoutEna = true;
@@ -144,30 +139,16 @@ void FTMotion::startBlockProc(block_t * const current_block) {
 // Move any free data points to the stepper buffer even if a full batch isn't ready.
 void FTMotion::runoutBlock() {
 
-  if (runoutEna && !batchRdy) {   // If the window is full already (block intervals was a multiple of
-                                  // the batch size), or runout is not enabled, no runout is needed.
-    // Fill out the trajectory window with the last position calculated.
-    if (makeVector_batchIdx > last_batchIdx)
-      for (uint32_t i = makeVector_batchIdx; i < (FTM_WINDOW_SIZE); i++) {
-        LOGICAL_AXIS_CODE(
-          traj.e[i] = traj.e[makeVector_batchIdx - 1],
-          traj.x[i] = traj.x[makeVector_batchIdx - 1],
-          traj.y[i] = traj.y[makeVector_batchIdx - 1],
-          traj.z[i] = traj.z[makeVector_batchIdx - 1],
-          traj.i[i] = traj.i[makeVector_batchIdx - 1],
-          traj.j[i] = traj.j[makeVector_batchIdx - 1],
-          traj.k[i] = traj.k[makeVector_batchIdx - 1],
-          traj.u[i] = traj.u[makeVector_batchIdx - 1],
-          traj.v[i] = traj.v[makeVector_batchIdx - 1],
-          traj.w[i] = traj.w[makeVector_batchIdx - 1]
-        );
-      }
+  if (!runoutEna) return;
 
-    makeVector_batchIdx = last_batchIdx;
-    batchRdy = true;
-    runout = true;
-  }
-  runoutEna = false;
+  startPosn = endPosn_prevBlock;
+  ratio.reset();
+
+  max_intervals = cfg.modeHasShaper() ? shaper_intervals : 0;
+  if (max_intervals <= TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, min_max_intervals - (FTM_BATCH_SIZE))) max_intervals = min_max_intervals;
+  max_intervals += TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, FTM_WINDOW_SIZE) - makeVector_batchIdx;
+  blockProcRdy = blockDataIsRunout = true;
+  runoutEna = blockProcDn = false;
 }
 
 // Controller main, to be invoked from non-isr task.
@@ -184,81 +165,63 @@ void FTMotion::loop() {
     if (sts_stepperBusy) return;          // Wait until motion buffers are emptied
     reset();
     blockProcDn = true;                   // Set queueing to look for next block.
-    runoutEna = false;                    // Disabling running out this block, since we want to halt the motion.
     stepper.abort_current_block = false;  // Abort finished.
   }
 
   // Planner processing and block conversion.
-  if (!blockProcRdy && !runout) stepper.ftMotion_BlockQueueUpdate();
+  if (!blockProcRdy) stepper.ftMotion_blockQueueUpdate();
 
   if (blockProcRdy) {
-    if (!blockProcRdy_z1) loadBlockData(current_block_cpy); // One-shot.
+    if (!blockProcRdy_z1) { // One-shot.
+      if (!blockDataIsRunout) loadBlockData(stepper.current_block);
+      else blockDataIsRunout = false;
+    }
     while (!blockProcDn && !batchRdy && (makeVector_idx - makeVector_idx_z1 < (FTM_POINTS_PER_LOOP)))
       makeVector();
   }
 
-  if (runout && !batchRdy) { // The lower half of the window has been runout.
-    // Runout the upper half of the window: the upper half has been shifted into the lower
-    // half. Fill out the upper half so another batch can be processed.
-    for (uint32_t i = last_batchIdx; i < (FTM_WINDOW_SIZE) - 1; i++) {
-      LOGICAL_AXIS_CODE(
-        traj.e[i] = traj.e[(FTM_WINDOW_SIZE) - 1],
-        traj.x[i] = traj.x[(FTM_WINDOW_SIZE) - 1],
-        traj.y[i] = traj.y[(FTM_WINDOW_SIZE) - 1],
-        traj.z[i] = traj.z[(FTM_WINDOW_SIZE) - 1],
-        traj.i[i] = traj.i[(FTM_WINDOW_SIZE) - 1],
-        traj.j[i] = traj.j[(FTM_WINDOW_SIZE) - 1],
-        traj.k[i] = traj.k[(FTM_WINDOW_SIZE) - 1],
-        traj.u[i] = traj.u[(FTM_WINDOW_SIZE) - 1],
-        traj.v[i] = traj.v[(FTM_WINDOW_SIZE) - 1],
-        traj.w[i] = traj.w[(FTM_WINDOW_SIZE) - 1]
-      );
-    }
-    batchRdy = true;
-    runout = false;
-  }
-
   // FBS / post processing.
   if (batchRdy && !batchRdyForInterp) {
 
     // Call Ulendo FBS here.
 
-    // Copy the uncompensated vectors. (XY done, other axes uncompensated)
-    LOGICAL_AXIS_CODE(
-      memcpy(trajMod.e, &traj.e[FTM_BATCH_SIZE], sizeof(trajMod.e)),
-      memcpy(trajMod.x, &traj.x[FTM_BATCH_SIZE], sizeof(trajMod.x)),
-      memcpy(trajMod.y, &traj.y[FTM_BATCH_SIZE], sizeof(trajMod.y)),
-      memcpy(trajMod.z, &traj.z[FTM_BATCH_SIZE], sizeof(trajMod.z)),
-      memcpy(trajMod.i, &traj.i[FTM_BATCH_SIZE], sizeof(trajMod.i)),
-      memcpy(trajMod.j, &traj.j[FTM_BATCH_SIZE], sizeof(trajMod.j)),
-      memcpy(trajMod.k, &traj.k[FTM_BATCH_SIZE], sizeof(trajMod.k)),
-      memcpy(trajMod.u, &traj.u[FTM_BATCH_SIZE], sizeof(trajMod.u)),
-      memcpy(trajMod.v, &traj.v[FTM_BATCH_SIZE], sizeof(trajMod.v)),
-      memcpy(trajMod.w, &traj.w[FTM_BATCH_SIZE], sizeof(trajMod.w))
-    );
-
-    // Shift the time series back in the window for (shaped) X and Y
-    TERN_(HAS_X_AXIS, memcpy(traj.x, &traj.x[FTM_BATCH_SIZE], sizeof(traj.x) / 2));
-    TERN_(HAS_Y_AXIS, memcpy(traj.y, &traj.y[FTM_BATCH_SIZE], sizeof(traj.y) / 2));
+    #if ENABLED(FTM_UNIFIED_BWS)
+      trajMod = traj; // Copy the uncompensated vectors.
+      traj = trajWin; // Move the window to traj
+    #else
+      // Copy the uncompensated vectors.
+      #define TCOPY(A) memcpy(trajMod.A, traj.A, sizeof(trajMod.A))
+      LOGICAL_AXIS_CODE(
+        TCOPY(e),
+        TCOPY(x), TCOPY(y), TCOPY(z),
+        TCOPY(i), TCOPY(j), TCOPY(k),
+        TCOPY(u), TCOPY(v), TCOPY(w)
+      );
 
-    // Z...W and E Disabled! Uncompensated so the lower half is not used.
-    //TERN_(HAS_Z_AXIS, memcpy(&traj.z[0], &traj.z[FTM_BATCH_SIZE], sizeof(traj.z) / 2));
+      // Shift the time series back in the window
+      #define TSHIFT(A) memcpy(traj.A, trajWin.A, sizeof(trajWin.A))
+      LOGICAL_AXIS_CODE(
+        TSHIFT(e),
+        TSHIFT(x), TSHIFT(y), TSHIFT(z),
+        TSHIFT(i), TSHIFT(j), TSHIFT(k),
+        TSHIFT(u), TSHIFT(v), TSHIFT(w)
+      );
+    #endif
 
     // ... data is ready in trajMod.
     batchRdyForInterp = true;
 
-    batchRdy = false; // Clear so that makeVector() may resume generating points.
-
-  } // if (batchRdy && !batchRdyForInterp)
+    batchRdy = false; // Clear so makeVector() can resume generating points.
+  }
 
   // Interpolation.
   while ( batchRdyForInterp
-          && ( stepperCmdBuffItems() < ((FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME)) )
-          && ( (interpIdx - interpIdx_z1) < (FTM_STEPS_PER_LOOP) )
+          && ( stepperCmdBuffItems() < (FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME) )
+          && ( interpIdx - interpIdx_z1 < (FTM_STEPS_PER_LOOP) )
   ) {
     convertToSteps(interpIdx);
 
-    if (++interpIdx == FTM_BATCH_SIZE) {
+    if (++interpIdx == TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, FTM_BATCH_SIZE)) {
       batchRdyForInterp = false;
       interpIdx = 0;
     }
@@ -277,76 +240,153 @@ void FTMotion::loop() {
   // Refresh the gains used by shaping functions.
   // To be called on init or mode or zeta change.
 
-  void FTMotion::Shaping::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
+  void FTMotion::Shaping::updateShapingA(float zeta[]/*=cfg.zeta*/, float vtol[]/*=cfg.vtol*/) {
 
-    const float K = exp(-zeta * M_PI / sqrt(1.0f - sq(zeta))),
-                K2 = sq(K);
+    const float Kx = exp(-zeta[0] * M_PI / sqrt(1.0f - sq(zeta[0]))),
+                Ky = exp(-zeta[1] * M_PI / sqrt(1.0f - sq(zeta[1]))),
+                Kx2 = sq(Kx),
+                Ky2 = sq(Ky);
 
     switch (cfg.mode) {
 
       case ftMotionMode_ZV:
         max_i = 1U;
-        x.Ai[0] = 1.0f / (1.0f + K);
-        x.Ai[1] = x.Ai[0] * K;
+        x.Ai[0] = 1.0f / (1.0f + Kx);
+        x.Ai[1] = x.Ai[0] * Kx;
+
+        y.Ai[0] = 1.0f / (1.0f + Ky);
+        y.Ai[1] = y.Ai[0] * Ky;
         break;
 
       case ftMotionMode_ZVD:
         max_i = 2U;
-        x.Ai[0] = 1.0f / ( 1.0f + 2.0f * K + K2 );
-        x.Ai[1] = x.Ai[0] * 2.0f * K;
-        x.Ai[2] = x.Ai[0] * K2;
+        x.Ai[0] = 1.0f / (1.0f + 2.0f * Kx + Kx2);
+        x.Ai[1] = x.Ai[0] * 2.0f * Kx;
+        x.Ai[2] = x.Ai[0] * Kx2;
+
+        y.Ai[0] = 1.0f / (1.0f + 2.0f * Ky + Ky2);
+        y.Ai[1] = y.Ai[0] * 2.0f * Ky;
+        y.Ai[2] = y.Ai[0] * Ky2;
+        break;
+
+      case ftMotionMode_ZVDD:
+        max_i = 3U;
+        x.Ai[0] = 1.0f / (1.0f + 3.0f * Kx + 3.0f * Kx2 + cu(Kx));
+        x.Ai[1] = x.Ai[0] * 3.0f * Kx;
+        x.Ai[2] = x.Ai[0] * 3.0f * Kx2;
+        x.Ai[3] = x.Ai[0] * cu(Kx);
+
+        y.Ai[0] = 1.0f / (1.0f + 3.0f * Ky + 3.0f * Ky2 + cu(Ky));
+        y.Ai[1] = y.Ai[0] * 3.0f * Ky;
+        y.Ai[2] = y.Ai[0] * 3.0f * Ky2;
+        y.Ai[3] = y.Ai[0] * cu(Ky);
+        break;
+
+      case ftMotionMode_ZVDDD:
+        max_i = 4U;
+        x.Ai[0] = 1.0f / (1.0f + 4.0f * Kx + 6.0f * Kx2 + 4.0f * cu(Kx) + sq(Kx2));
+        x.Ai[1] = x.Ai[0] * 4.0f * Kx;
+        x.Ai[2] = x.Ai[0] * 6.0f * Kx2;
+        x.Ai[3] = x.Ai[0] * 4.0f * cu(Kx);
+        x.Ai[4] = x.Ai[0] * sq(Kx2);
+
+        y.Ai[0] = 1.0f / (1.0f + 4.0f * Ky + 6.0f * Ky2 + 4.0f * cu(Ky) + sq(Ky2));
+        y.Ai[1] = y.Ai[0] * 4.0f * Ky;
+        y.Ai[2] = y.Ai[0] * 6.0f * Ky2;
+        y.Ai[3] = y.Ai[0] * 4.0f * cu(Ky);
+        y.Ai[4] = y.Ai[0] * sq(Ky2);
         break;
 
       case ftMotionMode_EI: {
         max_i = 2U;
-        x.Ai[0] = 0.25f * (1.0f + vtol);
-        x.Ai[1] = 0.50f * (1.0f - vtol) * K;
-        x.Ai[2] = x.Ai[0] * K2;
-        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2]);
-        for (uint32_t i = 0U; i < 3U; i++) { x.Ai[i] *= A_adj; }
-      } break;
+        x.Ai[0] = 0.25f * (1.0f + vtol[0]);
+        x.Ai[1] = 0.50f * (1.0f - vtol[0]) * Kx;
+        x.Ai[2] = x.Ai[0] * Kx2;
+
+        y.Ai[0] = 0.25f * (1.0f + vtol[1]);
+        y.Ai[1] = 0.50f * (1.0f - vtol[1]) * Ky;
+        y.Ai[2] = y.Ai[0] * Ky2;
+
+        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2]);
+        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2]);
+        for (uint32_t i = 0U; i < 3U; i++) {
+          x.Ai[i] *= X_adj;
+          y.Ai[i] *= Y_adj;
+        }
+      }
+      break;
 
       case ftMotionMode_2HEI: {
         max_i = 3U;
-        const float vtol2 = sq(vtol);
-        const float X = pow(vtol2 * (sqrt(1.0f - vtol2) + 1.0f), 1.0f / 3.0f);
-        x.Ai[0] = ( 3.0f * sq(X) + 2.0f * X + 3.0f * vtol2 ) / (16.0f * X);
-        x.Ai[1] = ( 0.5f - x.Ai[0] ) * K;
-        x.Ai[2] = x.Ai[1] * K;
-        x.Ai[3] = x.Ai[0] * cu(K);
-        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3]);
-        for (uint32_t i = 0U; i < 4U; i++) { x.Ai[i] *= A_adj; }
-      } break;
+        const float vtolx2 = sq(vtol[0]);
+        const float X = pow(vtolx2 * (sqrt(1.0f - vtolx2) + 1.0f), 1.0f / 3.0f);
+        x.Ai[0] = (3.0f * sq(X) + 2.0f * X + 3.0f * vtolx2) / (16.0f * X);
+        x.Ai[1] = (0.5f - x.Ai[0]) * Kx;
+        x.Ai[2] = x.Ai[1] * Kx;
+        x.Ai[3] = x.Ai[0] * cu(Kx);
+       
+        const float vtoly2 = sq(vtol[1]);
+        const float Y = pow(vtoly2 * (sqrt(1.0f - vtoly2) + 1.0f), 1.0f / 3.0f);
+        y.Ai[0] = (3.0f * sq(Y) + 2.0f * Y + 3.0f * vtoly2) / (16.0f * Y);
+        y.Ai[1] = (0.5f - y.Ai[0]) * Ky;
+        y.Ai[2] = y.Ai[1] * Ky;
+        y.Ai[3] = y.Ai[0] * cu(Ky);
+
+        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3]);
+        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2] + y.Ai[3]);
+        for (uint32_t i = 0U; i < 4U; i++) {
+          x.Ai[i] *= X_adj;
+          y.Ai[i] *= Y_adj;
+        }
+      }
+      break;
 
       case ftMotionMode_3HEI: {
         max_i = 4U;
-        x.Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol + 2.0f * sqrt( 2.0f * ( vtol + 1.0f ) * vtol ) );
-        x.Ai[1] = 0.25f * ( 1.0f - vtol ) * K;
-        x.Ai[2] = ( 0.5f * ( 1.0f + vtol ) - 2.0f * x.Ai[0] ) * K2;
-        x.Ai[3] = x.Ai[1] * K2;
-        x.Ai[4] = x.Ai[0] * sq(K2);
-        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3] + x.Ai[4]);
-        for (uint32_t i = 0U; i < 5U; i++) { x.Ai[i] *= A_adj; }
-      } break;
+        x.Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol[0] + 2.0f * sqrt( 2.0f * ( vtol[0] + 1.0f ) * vtol[0] ) );
+        x.Ai[1] = 0.25f * ( 1.0f - vtol[0] ) * Kx;
+        x.Ai[2] = ( 0.5f * ( 1.0f + vtol[0] ) - 2.0f * x.Ai[0] ) * Kx2;
+        x.Ai[3] = x.Ai[1] * Kx2;
+        x.Ai[4] = x.Ai[0] * sq(Kx2);
+
+        y.Ai[0] = 0.0625f * (1.0f + 3.0f * vtol[1] + 2.0f * sqrt(2.0f * (vtol[1] + 1.0f) * vtol[1]));
+        y.Ai[1] = 0.25f * (1.0f - vtol[1]) * Ky;
+        y.Ai[2] = (0.5f * (1.0f + vtol[1]) - 2.0f * y.Ai[0]) * Ky2;
+        y.Ai[3] = y.Ai[1] * Ky2;
+        y.Ai[4] = y.Ai[0] * sq(Ky2);
+
+        const float X_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3] + x.Ai[4]);
+        const float Y_adj = 1.0f / (y.Ai[0] + y.Ai[1] + y.Ai[2] + y.Ai[3] + y.Ai[4]);
+        for (uint32_t i = 0U; i < 5U; i++) {
+          x.Ai[i] *= X_adj;
+          y.Ai[i] *= Y_adj;
+        }
+      }    
+      break;
 
       case ftMotionMode_MZV: {
         max_i = 2U;
-        const float B = 1.4142135623730950488016887242097f * K;
-        x.Ai[0] = 1.0f / (1.0f + B + K2);
-        x.Ai[1] = x.Ai[0] * B;
-        x.Ai[2] = x.Ai[0] * K2;
-      } break;
+        const float Bx = 1.4142135623730950488016887242097f * Kx;
+        x.Ai[0] = 1.0f / (1.0f + Bx + Kx2);
+        x.Ai[1] = x.Ai[0] * Bx;
+        x.Ai[2] = x.Ai[0] * Kx2;
+
+        const float By = 1.4142135623730950488016887242097f * Ky;
+        y.Ai[0] = 1.0f / (1.0f + By + Ky2);
+        y.Ai[1] = y.Ai[0] * By;
+        y.Ai[2] = y.Ai[0] * Ky2;
+      } 
+      break;
 
       default:
-        for (uint32_t i = 0U; i < 5U; i++) x.Ai[i] = 0.0f;
+        ZERO(x.Ai);
+        ZERO(y.Ai);
         max_i = 0;
     }
-    #if HAS_Y_AXIS
-      memcpy(y.Ai, x.Ai, sizeof(x.Ai)); // For now, zeta and vtol are shared across x and y.
-    #endif
+    
   }
 
-  void FTMotion::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
+  void FTMotion::updateShapingA(float zeta[]/*=cfg.zeta*/, float vtol[]/*=cfg.vtol*/) {
     shaping.updateShapingA(zeta, vtol);
   }
 
@@ -364,11 +404,13 @@ void FTMotion::loop() {
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         break;
+      case ftMotionMode_ZVDD:
       case ftMotionMode_2HEI:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
         Ni[3] = Ni[2] + Ni[1];
         break;
+      case ftMotionMode_ZVDDD:
       case ftMotionMode_3HEI:
         Ni[1] = round((0.5f / f / df) * (FTM_FS));
         Ni[2] = Ni[1] + Ni[1];
@@ -383,10 +425,14 @@ void FTMotion::loop() {
     }
   }
 
-  void FTMotion::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=cfg.zeta*/) {
-    const float df = sqrt(1.0f - sq(zeta));
-    shaping.x.updateShapingN(xf, df);
-    TERN_(HAS_Y_AXIS, shaping.y.updateShapingN(yf, df));
+  void FTMotion::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), float zeta[]/*=cfg.zeta*/) {
+    const float xdf = sqrt(1.0f - sq(zeta[0]));
+    shaping.x.updateShapingN(xf, xdf);
+    
+    #if HAS_Y_AXIS
+      const float ydf = sqrt(1.0f - sq(zeta[1]));
+      shaping.y.updateShapingN(yf, ydf);
+    #endif
   }
 
 #endif // HAS_X_AXIS
@@ -396,27 +442,24 @@ void FTMotion::reset() {
 
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
-  traj.reset();     // Reset trajectory history
-  trajMod.reset();  // Reset modified trajectory history
+  traj.reset();
+  trajWin.reset();
 
   blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
   batchRdy = batchRdyForInterp = false;
   runoutEna = false;
-  runout = false;
 
   endPosn_prevBlock.reset();
 
   makeVector_idx = makeVector_idx_z1 = 0;
-  makeVector_batchIdx = FTM_BATCH_SIZE;
+  makeVector_batchIdx = 0;
 
   steps.reset();
   interpIdx = interpIdx_z1 = 0;
-  dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET);
-  nextStepTicks = FTM_MIN_TICKS;
 
   #if HAS_X_AXIS
-    for (uint32_t i = 0U; i < (FTM_ZMAX); i++)
-      shaping.x.d_zi[i] = TERN_(HAS_Y_AXIS, shaping.y.d_zi[i] =) 0.0f;
+    ZERO(shaping.x.d_zi);
+    TERN_(HAS_Y_AXIS, ZERO(shaping.y.d_zi));
     shaping.zi_idx = 0;
   #endif
 
@@ -445,40 +488,26 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   const float totalLength = current_block->millimeters,
               oneOverLength = 1.0f / totalLength;
 
-  const AxisBits direction = current_block->direction_bits;
-
   startPosn = endPosn_prevBlock;
   xyze_pos_t moveDist = LOGICAL_AXIS_ARRAY(
-    current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)],
-    current_block->steps.x / planner.settings.axis_steps_per_mm[X_AXIS],
-    current_block->steps.y / planner.settings.axis_steps_per_mm[Y_AXIS],
-    current_block->steps.z / planner.settings.axis_steps_per_mm[Z_AXIS],
-    current_block->steps.i / planner.settings.axis_steps_per_mm[I_AXIS],
-    current_block->steps.j / planner.settings.axis_steps_per_mm[J_AXIS],
-    current_block->steps.k / planner.settings.axis_steps_per_mm[K_AXIS],
-    current_block->steps.u / planner.settings.axis_steps_per_mm[U_AXIS],
-    current_block->steps.v / planner.settings.axis_steps_per_mm[V_AXIS],
-    current_block->steps.w / planner.settings.axis_steps_per_mm[W_AXIS]
-  );
-
-  LOGICAL_AXIS_CODE(
-    if (!direction.e) moveDist.e *= -1.0f,
-    if (!direction.x) moveDist.x *= -1.0f,
-    if (!direction.y) moveDist.y *= -1.0f,
-    if (!direction.z) moveDist.z *= -1.0f,
-    if (!direction.i) moveDist.i *= -1.0f,
-    if (!direction.j) moveDist.j *= -1.0f,
-    if (!direction.k) moveDist.k *= -1.0f,
-    if (!direction.u) moveDist.u *= -1.0f,
-    if (!direction.v) moveDist.v *= -1.0f,
-    if (!direction.w) moveDist.w *= -1.0f
+    current_block->steps.e * planner.mm_per_step[E_AXIS_N(current_block->extruder)] * (current_block->direction_bits.e ? 1 : -1),
+    current_block->steps.x * planner.mm_per_step[X_AXIS] * (current_block->direction_bits.x ? 1 : -1),
+    current_block->steps.y * planner.mm_per_step[Y_AXIS] * (current_block->direction_bits.y ? 1 : -1),
+    current_block->steps.z * planner.mm_per_step[Z_AXIS] * (current_block->direction_bits.z ? 1 : -1),
+    current_block->steps.i * planner.mm_per_step[I_AXIS] * (current_block->direction_bits.i ? 1 : -1),
+    current_block->steps.j * planner.mm_per_step[J_AXIS] * (current_block->direction_bits.j ? 1 : -1),
+    current_block->steps.k * planner.mm_per_step[K_AXIS] * (current_block->direction_bits.k ? 1 : -1),
+    current_block->steps.u * planner.mm_per_step[U_AXIS] * (current_block->direction_bits.u ? 1 : -1),
+    current_block->steps.v * planner.mm_per_step[V_AXIS] * (current_block->direction_bits.v ? 1 : -1),
+    current_block->steps.w * planner.mm_per_step[W_AXIS] * (current_block->direction_bits.w ? 1 : -1)
   );
 
   ratio = moveDist * oneOverLength;
 
+  /* Keep for comprehension
   const float spm = totalLength / current_block->step_event_count;  // (steps/mm) Distance for each step
-              f_s = spm * current_block->initial_rate;  // (steps/s) Start feedrate
-  const float f_e = spm * current_block->final_rate;    // (steps/s) End feedrate
+              f_s = spm * current_block->initial_rate,  // (steps/s) Start feedrate
+              f_e = spm * current_block->final_rate;    // (steps/s) End feedrate
 
   const float a = current_block->acceleration,          // (mm/s^2) Same magnitude for acceleration or deceleration
               oneby2a = 1.0f / (2.0f * a),              // (s/mm) Time to accelerate or decelerate one mm (i.e., oneby2a * 2
@@ -499,25 +528,46 @@ void FTMotion::loadBlockData(block_t * const current_block) {
 
   const float T1 = (F_n - f_s) / a,                     // (s) Accel Time = difference in feedrate over acceleration
               T3 = (F_n - f_e) / a;                     // (s) Decel Time = difference in feedrate over acceleration
+  */
+
+  const float spm = totalLength / current_block->step_event_count,
+              f_s = spm * current_block->initial_rate,
+              f_e = spm * current_block->final_rate;
+
+  const float accel = current_block->acceleration,
+              oneOverAccel = 1.0f / accel;
+
+  float F_n = current_block->nominal_speed;
+  const float ldiff = totalLength + 0.5f * oneOverAccel * (sq(f_s) + sq(f_e));
+
+  float T2 = ldiff / F_n - oneOverAccel * F_n;
+  if (T2 < 0.0f) {
+    T2 = 0.0f;
+    F_n = SQRT(ldiff * accel);
+  }
 
-  N1 = ceil(T1 * (FTM_FS));                       // Accel datapoints based on Hz frequency
-  N2 = ceil(T2 * (FTM_FS));                       // Coast
-  N3 = ceil(T3 * (FTM_FS));                       // Decel
-
-  const float T1_P = N1 * (FTM_TS),               // (s) Accel datapoints x timestep resolution
-              T2_P = N2 * (FTM_TS),               // (s) Coast
-              T3_P = N3 * (FTM_TS);               // (s) Decel
-
-  // Calculate the reachable feedrate at the end of the accel phase
-  // totalLength is the total distance to travel in mm
-  // f_s is the starting feedrate in mm/s
-  // f_e is the ending feedrate in mm/s
-  // T1_P is the time spent accelerating in seconds
-  // T2_P is the time spent coasting in seconds
-  // T3_P is the time spent decelerating in seconds
-  // f_s * T1_P is the distance traveled during the accel phase
-  // f_e * T3_P is the distance traveled during the decel phase
-  //
+  const float T1 = (F_n - f_s) * oneOverAccel,
+              T3 = (F_n - f_e) * oneOverAccel;
+
+  N1 = ceil(T1 * (FTM_FS));         // Accel datapoints based on Hz frequency
+  N2 = ceil(T2 * (FTM_FS));         // Coast
+  N3 = ceil(T3 * (FTM_FS));         // Decel
+
+  const float T1_P = N1 * (FTM_TS), // (s) Accel datapoints x timestep resolution
+              T2_P = N2 * (FTM_TS), // (s) Coast
+              T3_P = N3 * (FTM_TS); // (s) Decel
+
+  /**
+   * Calculate the reachable feedrate at the end of the accel phase.
+   *  totalLength is the total distance to travel in mm
+   *  f_s        : (mm/s) Starting feedrate
+   *  f_e        : (mm/s) Ending feedrate
+   *  T1_P       : (sec) Time spent accelerating
+   *  T2_P       : (sec) Time spent coasting
+   *  T3_P       : (sec) Time spent decelerating
+   *  f_s * T1_P : (mm) Distance traveled during the accel phase
+   *  f_e * T3_P : (mm) Distance traveled during the decel phase
+   */
   F_P = (2.0f * totalLength - f_s * T1_P - f_e * T3_P) / (T1_P + 2.0f * T2_P + T3_P); // (mm/s) Feedrate at the end of the accel phase
 
   // Calculate the acceleration and deceleration rates
@@ -531,77 +581,69 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   // Calculate the distance traveled during the decel phase
   s_2e = s_1e + F_P * T2_P;
 
-  // One less than (Accel + Coasting + Decel) datapoints
-  max_intervals = N1 + N2 + N3 - 1U;
+  // Accel + Coasting + Decel datapoints
+  max_intervals = N1 + N2 + N3;
 
   endPosn_prevBlock += moveDist;
 }
 
 // Generate data points of the trajectory.
 void FTMotion::makeVector() {
-  float accel_k = 0.0f;                                   // (mm/s^2) Acceleration K factor
-  float tau = (makeVector_idx + 1) * (FTM_TS);            // (s) Time since start of block
-  float dist = 0.0f;                                      // (mm) Distance traveled
+  float accel_k = 0.0f;                                 // (mm/s^2) Acceleration K factor
+  float tau = (makeVector_idx + 1) * (FTM_TS);          // (s) Time since start of block
+  float dist = 0.0f;                                    // (mm) Distance traveled
 
   if (makeVector_idx < N1) {
     // Acceleration phase
-    dist = (f_s * tau) + (0.5f * accel_P * sq(tau));      // (mm) Distance traveled for acceleration phase
-    accel_k = accel_P;                                    // (mm/s^2) Acceleration K factor from Accel phase
+    dist = (f_s * tau) + (0.5f * accel_P * sq(tau));    // (mm) Distance traveled for acceleration phase since start of block
+    accel_k = accel_P;                                  // (mm/s^2) Acceleration K factor from Accel phase
   }
-  else if (makeVector_idx >= N1 && makeVector_idx < (N1 + N2)) {
+  else if (makeVector_idx < (N1 + N2)) {
     // Coasting phase
-    dist = s_1e + F_P * (tau - N1 * (FTM_TS));            // (mm) Distance traveled for coasting phase
+    dist = s_1e + F_P * (tau - N1 * (FTM_TS));          // (mm) Distance traveled for coasting phase since start of block
     //accel_k = 0.0f;
   }
   else {
     // Deceleration phase
-    const float tau_ = tau - (N1 + N2) * (FTM_TS);        // (s) Time since start of decel phase
-    dist = s_2e + F_P * tau_ + 0.5f * decel_P * sq(tau_); // (mm) Distance traveled for deceleration phase
-    accel_k = decel_P;                                    // (mm/s^2) Acceleration K factor from Decel phase
+    tau -= (N1 + N2) * (FTM_TS);                        // (s) Time since start of decel phase
+    dist = s_2e + F_P * tau + 0.5f * decel_P * sq(tau); // (mm) Distance traveled for deceleration phase since start of block
+    accel_k = decel_P;                                  // (mm/s^2) Acceleration K factor from Decel phase
   }
 
-  NUM_AXIS_CODE(
-    traj.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
-    traj.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
-    traj.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
-    traj.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
-    traj.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
-    traj.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
-    traj.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
-    traj.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
-    traj.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
+  LOGICAL_AXIS_CODE(
+    trajWin.e[makeVector_batchIdx] = startPosn.e + ratio.e * dist,
+    trajWin.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
+    trajWin.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
+    trajWin.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
+    trajWin.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
+    trajWin.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
+    trajWin.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
+    trajWin.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
+    trajWin.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
+    trajWin.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
   );
 
   #if HAS_EXTRUDERS
-    const float new_raw_z1 = startPosn.e + ratio.e * dist;
     if (cfg.linearAdvEna) {
-      float dedt_adj = (new_raw_z1 - e_raw_z1) * (FTM_FS);
+      float dedt_adj = (trajWin.e[makeVector_batchIdx] - e_raw_z1) * (FTM_FS);
       if (ratio.e > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
 
+      e_raw_z1 = trajWin.e[makeVector_batchIdx];
       e_advanced_z1 += dedt_adj * (FTM_TS);
-      traj.e[makeVector_batchIdx] = e_advanced_z1;
-
-      e_raw_z1 = new_raw_z1;
-    }
-    else {
-      traj.e[makeVector_batchIdx] = new_raw_z1;
-      // Alternatively: ed[makeVector_batchIdx] = startPosn.e + (ratio.e * dist) / (N1 + N2 + N3);
+      trajWin.e[makeVector_batchIdx] = e_advanced_z1;
     }
   #endif
 
   // Update shaping parameters if needed.
-  #if HAS_DYNAMIC_FREQ_MM
-    static float zd_z1 = 0.0f;
-  #endif
+
   switch (cfg.dynFreqMode) {
 
     #if HAS_DYNAMIC_FREQ_MM
       case dynFreqMode_Z_BASED:
-        if (traj.z[makeVector_batchIdx] != zd_z1) { // Only update if Z changed.
-          const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.z[makeVector_batchIdx],
-                      yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.z[makeVector_batchIdx];
-          updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ), _MAX(yf, FTM_MIN_SHAPE_FREQ));
-          zd_z1 = traj.z[makeVector_batchIdx];
+        if (trajWin.z[makeVector_batchIdx] != 0.0f) { // Only update if Z changed.
+                 const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * trajWin.z[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * trajWin.z[makeVector_batchIdx]);
+          updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ) OPTARG(HAS_Y_AXIS, _MAX(yf, FTM_MIN_SHAPE_FREQ)));
         }
         break;
     #endif
@@ -610,8 +652,8 @@ void FTMotion::makeVector() {
       case dynFreqMode_MASS_BASED:
         // Update constantly. The optimization done for Z value makes
         // less sense for E, as E is expected to constantly change.
-        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.e[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.e[makeVector_batchIdx]) );
+        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * trajWin.e[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * trajWin.e[makeVector_batchIdx]) );
         break;
     #endif
 
@@ -621,18 +663,18 @@ void FTMotion::makeVector() {
   // Apply shaping if in mode.
   #if HAS_X_AXIS
     if (cfg.modeHasShaper()) {
-      shaping.x.d_zi[shaping.zi_idx] = traj.x[makeVector_batchIdx];
-      traj.x[makeVector_batchIdx] *= shaping.x.Ai[0];
+      shaping.x.d_zi[shaping.zi_idx] = trajWin.x[makeVector_batchIdx];
+      trajWin.x[makeVector_batchIdx] *= shaping.x.Ai[0];
       #if HAS_Y_AXIS
-        shaping.y.d_zi[shaping.zi_idx] = traj.y[makeVector_batchIdx];
-        traj.y[makeVector_batchIdx] *= shaping.y.Ai[0];
+        shaping.y.d_zi[shaping.zi_idx] = trajWin.y[makeVector_batchIdx];
+        trajWin.y[makeVector_batchIdx] *= shaping.y.Ai[0];
       #endif
       for (uint32_t i = 1U; i <= shaping.max_i; i++) {
         const uint32_t udiffx = shaping.zi_idx - shaping.x.Ni[i];
-        traj.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
+        trajWin.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
         #if HAS_Y_AXIS
           const uint32_t udiffy = shaping.zi_idx - shaping.y.Ni[i];
-          traj.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
+          trajWin.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
         #endif
       }
       if (++shaping.zi_idx == (FTM_ZMAX)) shaping.zi_idx = 0;
@@ -640,18 +682,38 @@ void FTMotion::makeVector() {
   #endif
 
   // Filled up the queue with regular and shaped steps
-  if (++makeVector_batchIdx == (FTM_WINDOW_SIZE)) {
-    makeVector_batchIdx = last_batchIdx;
+  if (++makeVector_batchIdx == TERN(FTM_UNIFIED_BWS, FTM_BW_SIZE, (FTM_WINDOW_SIZE - FTM_BATCH_SIZE))) {
+    makeVector_batchIdx = 0;
     batchRdy = true;
   }
 
-  if (makeVector_idx == max_intervals) {
+  if (++makeVector_idx == max_intervals) {
     blockProcDn = true;
     blockProcRdy = false;
     makeVector_idx = 0;
   }
-  else
-    makeVector_idx++;
+}
+
+/**
+ * Convert to steps
+ * - Commands are written in a bitmask with step and dir as single bits.
+ * - Tests for delta are moved outside the loop.
+ * - Two functions are used for command computation with an array of function pointers.
+ */
+static void (*command_set[NUM_AXES TERN0(HAS_EXTRUDERS, +1)])(int32_t&, int32_t&, ft_command_t&, int32_t, int32_t);
+
+static void command_set_pos(int32_t &e, int32_t &s, ft_command_t &b, int32_t bd, int32_t bs) {
+  if (e < FTM_CTS_COMPARE_VAL) return;
+  s++;
+  b |= bd | bs;
+  e -= FTM_STEPS_PER_UNIT_TIME;
+}
+
+static void command_set_neg(int32_t &e, int32_t &s, ft_command_t &b, int32_t bd, int32_t bs) {
+  if (e > -(FTM_CTS_COMPARE_VAL)) return;
+  s--;
+  b |= bs;
+  e += FTM_STEPS_PER_UNIT_TIME;
 }
 
 // Interpolates single data point to stepper commands.
@@ -660,154 +722,61 @@ void FTMotion::convertToSteps(const uint32_t idx) {
 
   //#define STEPS_ROUNDING
   #if ENABLED(STEPS_ROUNDING)
-    const xyze_float_t steps_tar = LOGICAL_AXIS_ARRAY(
-      trajMod.e[idx] * planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)] + (trajMod.e[idx] < 0.0f ? -0.5f : 0.5f), // May be eliminated if guaranteed positive.
-      trajMod.x[idx] * planner.settings.axis_steps_per_mm[X_AXIS] + (trajMod.x[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.y[idx] * planner.settings.axis_steps_per_mm[Y_AXIS] + (trajMod.y[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.z[idx] * planner.settings.axis_steps_per_mm[Z_AXIS] + (trajMod.z[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.i[idx] * planner.settings.axis_steps_per_mm[I_AXIS] + (trajMod.i[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.j[idx] * planner.settings.axis_steps_per_mm[J_AXIS] + (trajMod.j[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.k[idx] * planner.settings.axis_steps_per_mm[K_AXIS] + (trajMod.k[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.u[idx] * planner.settings.axis_steps_per_mm[U_AXIS] + (trajMod.u[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.v[idx] * planner.settings.axis_steps_per_mm[V_AXIS] + (trajMod.v[idx] < 0.0f ? -0.5f : 0.5f),
-      trajMod.w[idx] * planner.settings.axis_steps_per_mm[W_AXIS] + (trajMod.w[idx] < 0.0f ? -0.5f : 0.5f),
+    #define TOSTEPS(A,B) int32_t(trajMod.A[idx] * planner.settings.axis_steps_per_mm[B] + (trajMod.A[idx] < 0.0f ? -0.5f : 0.5f))
+    const xyze_long_t steps_tar = LOGICAL_AXIS_ARRAY(
+      TOSTEPS(e, E_AXIS_N(current_block->extruder)), // May be eliminated if guaranteed positive.
+      TOSTEPS(x, X_AXIS), TOSTEPS(y, Y_AXIS), TOSTEPS(z, Z_AXIS),
+      TOSTEPS(i, I_AXIS), TOSTEPS(j, J_AXIS), TOSTEPS(k, K_AXIS),
+      TOSTEPS(u, U_AXIS), TOSTEPS(v, V_AXIS), TOSTEPS(w, W_AXIS)
     );
-    xyze_long_t delta = xyze_long_t(steps_tar) - steps;
-    //const xyze_long_t delta = LOGICAL_AXIS_ARRAY(
-    //  int32_t(steps_tar.e) - steps.e,
-    //  int32_t(steps_tar.x) - steps.x,
-    //  int32_t(steps_tar.y) - steps.y,
-    //  int32_t(steps_tar.z) - steps.z,
-    //  int32_t(steps_tar.i) - steps.i,
-    //  int32_t(steps_tar.j) - steps.j,
-    //  int32_t(steps_tar.k) - steps.k,
-    //  int32_t(steps_tar.u) - steps.u,
-    //  int32_t(steps_tar.v) - steps.v,
-    //  int32_t(steps_tar.w) - steps.w
-    //);
+    xyze_long_t delta = steps_tar - steps;
   #else
+    #define TOSTEPS(A,B) int32_t(trajMod.A[idx] * planner.settings.axis_steps_per_mm[B]) - steps.A
     xyze_long_t delta = LOGICAL_AXIS_ARRAY(
-      int32_t(trajMod.e[idx] * planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)]) - steps.e,
-      int32_t(trajMod.x[idx] * planner.settings.axis_steps_per_mm[X_AXIS]) - steps.x,
-      int32_t(trajMod.y[idx] * planner.settings.axis_steps_per_mm[Y_AXIS]) - steps.y,
-      int32_t(trajMod.z[idx] * planner.settings.axis_steps_per_mm[Z_AXIS]) - steps.z,
-      int32_t(trajMod.i[idx] * planner.settings.axis_steps_per_mm[I_AXIS]) - steps.i,
-      int32_t(trajMod.j[idx] * planner.settings.axis_steps_per_mm[J_AXIS]) - steps.j,
-      int32_t(trajMod.k[idx] * planner.settings.axis_steps_per_mm[K_AXIS]) - steps.k,
-      int32_t(trajMod.u[idx] * planner.settings.axis_steps_per_mm[U_AXIS]) - steps.u,
-      int32_t(trajMod.v[idx] * planner.settings.axis_steps_per_mm[V_AXIS]) - steps.v,
-      int32_t(trajMod.w[idx] * planner.settings.axis_steps_per_mm[W_AXIS]) - steps.w
+      TOSTEPS(e, E_AXIS_N(current_block->extruder)),
+      TOSTEPS(x, X_AXIS), TOSTEPS(y, Y_AXIS), TOSTEPS(z, Z_AXIS),
+      TOSTEPS(i, I_AXIS), TOSTEPS(j, J_AXIS), TOSTEPS(k, K_AXIS),
+      TOSTEPS(u, U_AXIS), TOSTEPS(v, V_AXIS), TOSTEPS(w, W_AXIS)
     );
   #endif
 
-  bool any_dirChange = (false
-    LOGICAL_AXIS_GANG(
-      || (delta.e > 0 && dirState.e != stepDirState_POS) || (delta.e < 0 && dirState.e != stepDirState_NEG),
-      || (delta.x > 0 && dirState.x != stepDirState_POS) || (delta.x < 0 && dirState.x != stepDirState_NEG),
-      || (delta.y > 0 && dirState.y != stepDirState_POS) || (delta.y < 0 && dirState.y != stepDirState_NEG),
-      || (delta.z > 0 && dirState.z != stepDirState_POS) || (delta.z < 0 && dirState.z != stepDirState_NEG),
-      || (delta.i > 0 && dirState.i != stepDirState_POS) || (delta.i < 0 && dirState.i != stepDirState_NEG),
-      || (delta.j > 0 && dirState.j != stepDirState_POS) || (delta.j < 0 && dirState.j != stepDirState_NEG),
-      || (delta.k > 0 && dirState.k != stepDirState_POS) || (delta.k < 0 && dirState.k != stepDirState_NEG),
-      || (delta.u > 0 && dirState.u != stepDirState_POS) || (delta.u < 0 && dirState.u != stepDirState_NEG),
-      || (delta.v > 0 && dirState.v != stepDirState_POS) || (delta.v < 0 && dirState.v != stepDirState_NEG),
-      || (delta.w > 0 && dirState.w != stepDirState_POS) || (delta.w < 0 && dirState.w != stepDirState_NEG)
-    )
+  LOGICAL_AXIS_CODE(
+    command_set[E_AXIS_N(current_block->extruder)] = delta.e >= 0 ?  command_set_pos : command_set_neg,
+    command_set[X_AXIS] = delta.x >= 0 ?  command_set_pos : command_set_neg,
+    command_set[Y_AXIS] = delta.y >= 0 ?  command_set_pos : command_set_neg,
+    command_set[Z_AXIS] = delta.z >= 0 ?  command_set_pos : command_set_neg,
+    command_set[I_AXIS] = delta.i >= 0 ?  command_set_pos : command_set_neg,
+    command_set[J_AXIS] = delta.j >= 0 ?  command_set_pos : command_set_neg,
+    command_set[K_AXIS] = delta.k >= 0 ?  command_set_pos : command_set_neg,
+    command_set[U_AXIS] = delta.u >= 0 ?  command_set_pos : command_set_neg,
+    command_set[V_AXIS] = delta.v >= 0 ?  command_set_pos : command_set_neg,
+    command_set[W_AXIS] = delta.w >= 0 ?  command_set_pos : command_set_neg
   );
 
   for (uint32_t i = 0U; i < (FTM_STEPS_PER_UNIT_TIME); i++) {
 
-    // TODO: (?) Since the *delta variables will not change,
-    // the comparison may be done once before iterating at
-    // expense of storage and lines of code.
-
-    bool anyStep = false;
-
-    // Commands are written in a bitmask with step and dir as single bits
-    auto COMMAND_SET = [&](auto &d, auto &e, auto &s, auto &b, auto bd, auto bs) {
-      if (d >= 0) {
-        if (e + d < (FTM_CTS_COMPARE_VAL)) {
-          e += d;
-        }
-        else {
-          s++;
-          b |= bd | bs;
-          e += d - (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-      else {
-        if ((e + d) > -(FTM_CTS_COMPARE_VAL)) {
-          e += d;
-        }
-        else {
-          s--;
-          b |= bs;
-          e += d + (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-    };
-
     // Init all step/dir bits to 0 (defaulting to reverse/negative motion)
     stepperCmdBuff[stepperCmdBuff_produceIdx] = 0;
 
+    err_P += delta;
+
     // Set up step/dir bits for all axes
     LOGICAL_AXIS_CODE(
-      COMMAND_SET(delta.e, err_P.e, steps.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E), _BV(FT_BIT_STEP_E)),
-      COMMAND_SET(delta.x, err_P.x, steps.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X), _BV(FT_BIT_STEP_X)),
-      COMMAND_SET(delta.y, err_P.y, steps.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y), _BV(FT_BIT_STEP_Y)),
-      COMMAND_SET(delta.z, err_P.z, steps.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z), _BV(FT_BIT_STEP_Z)),
-      COMMAND_SET(delta.i, err_P.i, steps.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I), _BV(FT_BIT_STEP_I)),
-      COMMAND_SET(delta.j, err_P.j, steps.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J), _BV(FT_BIT_STEP_J)),
-      COMMAND_SET(delta.k, err_P.k, steps.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K), _BV(FT_BIT_STEP_K)),
-      COMMAND_SET(delta.u, err_P.u, steps.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U), _BV(FT_BIT_STEP_U)),
-      COMMAND_SET(delta.v, err_P.v, steps.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V), _BV(FT_BIT_STEP_V)),
-      COMMAND_SET(delta.w, err_P.w, steps.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W), _BV(FT_BIT_STEP_W)),
+      command_set[E_AXIS_N(current_block->extruder)](err_P.e, steps.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E), _BV(FT_BIT_STEP_E)),
+      command_set[X_AXIS](err_P.x, steps.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X), _BV(FT_BIT_STEP_X)),
+      command_set[Y_AXIS](err_P.y, steps.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y), _BV(FT_BIT_STEP_Y)),
+      command_set[Z_AXIS](err_P.z, steps.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z), _BV(FT_BIT_STEP_Z)),
+      command_set[I_AXIS](err_P.i, steps.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I), _BV(FT_BIT_STEP_I)),
+      command_set[J_AXIS](err_P.j, steps.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J), _BV(FT_BIT_STEP_J)),
+      command_set[K_AXIS](err_P.k, steps.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K), _BV(FT_BIT_STEP_K)),
+      command_set[U_AXIS](err_P.u, steps.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U), _BV(FT_BIT_STEP_U)),
+      command_set[V_AXIS](err_P.v, steps.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V), _BV(FT_BIT_STEP_V)),
+      command_set[W_AXIS](err_P.w, steps.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W), _BV(FT_BIT_STEP_W)),
     );
 
-    if (!anyStep) {
-      nextStepTicks += (FTM_MIN_TICKS);
-    }
-    else {
-      stepperCmdBuff_StepRelativeTi[stepperCmdBuff_produceIdx] = nextStepTicks;
-
-      const uint8_t dir_index = stepperCmdBuff_produceIdx >> 3,
-                    dir_bit = stepperCmdBuff_produceIdx & 0x7;
-      if (any_dirChange) {
-
-        SBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
-
-        auto DIR_SET = [&](auto &d, auto &c, auto &b, auto bd) {
-          if (d > 0) { b |= bd; c = stepDirState_POS; } else { c = stepDirState_NEG; }
-        };
-
-        LOGICAL_AXIS_CODE(
-          DIR_SET(delta.e, dirState.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E)),
-          DIR_SET(delta.x, dirState.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X)),
-          DIR_SET(delta.y, dirState.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y)),
-          DIR_SET(delta.z, dirState.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z)),
-          DIR_SET(delta.i, dirState.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I)),
-          DIR_SET(delta.j, dirState.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J)),
-          DIR_SET(delta.k, dirState.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K)),
-          DIR_SET(delta.u, dirState.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U)),
-          DIR_SET(delta.v, dirState.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V)),
-          DIR_SET(delta.w, dirState.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W)),
-        );
-
-        any_dirChange = false;
-      }
-      else { // ...no direction change.
-        CBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
-      }
+    if (++stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE))
+      stepperCmdBuff_produceIdx = 0;
 
-      if (stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE) - 1)
-        stepperCmdBuff_produceIdx = 0;
-      else
-        stepperCmdBuff_produceIdx++;
-
-      nextStepTicks = FTM_MIN_TICKS;
-    }
   } // FTM_STEPS_PER_UNIT_TIME loop
 }
 

commit 5bd39ba73f5a704ccaf370bc98201c10b380d20d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 12:14:26 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion redux

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 85ee4ca355..ad37e8a9b3 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -498,6 +498,7 @@ void FTMotion::loadBlockData(block_t * const current_block) {
   }
 
   const float T1 = (F_n - f_s) / a,                     // (s) Accel Time = difference in feedrate over acceleration
+              T3 = (F_n - f_e) / a;                     // (s) Decel Time = difference in feedrate over acceleration
 
   N1 = ceil(T1 * (FTM_FS));                       // Accel datapoints based on Hz frequency
   N2 = ceil(T2 * (FTM_FS));                       // Coast

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 385d81622e..85ee4ca355 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -27,7 +27,7 @@
 #include "ft_motion.h"
 #include "stepper.h" // Access stepper block queue function and abort status.
 
-FxdTiCtrl fxdTiCtrl;
+FTMotion ftMotion;
 
 #if !HAS_X_AXIS
   static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZV, "ftMotionMode_ZV requires at least one linear axis.");
@@ -50,66 +50,67 @@ FxdTiCtrl fxdTiCtrl;
 
 // Public variables.
 
-ft_config_t FxdTiCtrl::cfg;
-ft_command_t FxdTiCtrl::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U};                // Buffer of stepper commands.
-hal_timer_t FxdTiCtrl::stepperCmdBuff_StepRelativeTi[FTM_STEPPERCMD_BUFF_SIZE] = {0U};  // Buffer of the stepper command timing.
-uint8_t FxdTiCtrl::stepperCmdBuff_ApplyDir[FTM_STEPPERCMD_DIR_SIZE] = {0U};             // Buffer of whether DIR needs to be updated.
-uint32_t FxdTiCtrl::stepperCmdBuff_produceIdx = 0,  // Index of next stepper command write to the buffer.
-         FxdTiCtrl::stepperCmdBuff_consumeIdx = 0;  // Index of next stepper command read from the buffer.
+ft_config_t FTMotion::cfg;
+bool FTMotion::busy; // = false
+ft_command_t FTMotion::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U};               // Buffer of stepper commands.
+hal_timer_t FTMotion::stepperCmdBuff_StepRelativeTi[FTM_STEPPERCMD_BUFF_SIZE] = {0U}; // Buffer of the stepper command timing.
+uint8_t FTMotion::stepperCmdBuff_ApplyDir[FTM_STEPPERCMD_DIR_SIZE] = {0U};            // Buffer of whether DIR needs to be updated.
+uint32_t FTMotion::stepperCmdBuff_produceIdx = 0, // Index of next stepper command write to the buffer.
+         FTMotion::stepperCmdBuff_consumeIdx = 0; // Index of next stepper command read from the buffer.
 
-bool FxdTiCtrl::sts_stepperBusy = false;          // The stepper buffer has items and is in use.
+bool FTMotion::sts_stepperBusy = false;         // The stepper buffer has items and is in use.
 
 // Private variables.
 // NOTE: These are sized for Ulendo FBS use.
-xyze_trajectory_t FxdTiCtrl::traj;                // = {0.0f} Storage for fixed-time-based trajectory.
-xyze_trajectoryMod_t FxdTiCtrl::trajMod;          // = {0.0f} Storage for modified fixed-time-based trajectory.
-
-block_t* FxdTiCtrl::current_block_cpy = nullptr;  // Pointer to current block being processed.
-bool FxdTiCtrl::blockProcRdy = false,             // Indicates a block is ready to be processed.
-     FxdTiCtrl::blockProcRdy_z1 = false,          // Storage for the previous indicator.
-     FxdTiCtrl::blockProcDn = false;              // Indicates current block is done being processed.
-bool FxdTiCtrl::batchRdy = false;                 // Indicates a batch of the fixed time trajectory
-                                                  //  has been generated, is now available in the upper -
-                                                  //  half of traj.x[], y, z ... e vectors, and is ready to be
-                                                  //  post processed, if applicable, then interpolated.
-bool FxdTiCtrl::batchRdyForInterp = false;        // Indicates the batch is done being post processed,
-                                                  //  if applicable, and is ready to be converted to step commands.
-bool FxdTiCtrl::runoutEna = false;                // True if runout of the block hasn't been done and is allowed.
-bool FxdTiCtrl::runout = false;                   // Indicates if runout is in progress.
+xyze_trajectory_t FTMotion::traj;               // = {0.0f} Storage for fixed-time-based trajectory.
+xyze_trajectoryMod_t FTMotion::trajMod;         // = {0.0f} Storage for modified fixed-time-based trajectory.
+
+block_t* FTMotion::current_block_cpy = nullptr; // Pointer to current block being processed.
+bool FTMotion::blockProcRdy = false,            // Indicates a block is ready to be processed.
+     FTMotion::blockProcRdy_z1 = false,         // Storage for the previous indicator.
+     FTMotion::blockProcDn = false;             // Indicates current block is done being processed.
+bool FTMotion::batchRdy = false;                // Indicates a batch of the fixed time trajectory
+                                                //  has been generated, is now available in the upper -
+                                                //  half of traj.x[], y, z ... e vectors, and is ready to be
+                                                //  post processed, if applicable, then interpolated.
+bool FTMotion::batchRdyForInterp = false;       // Indicates the batch is done being post processed,
+                                                //  if applicable, and is ready to be converted to step commands.
+bool FTMotion::runoutEna = false;               // True if runout of the block hasn't been done and is allowed.
+bool FTMotion::runout = false;                  // Indicates if runout is in progress.
 
 // Trapezoid data variables.
-xyze_pos_t   FxdTiCtrl::startPosn,                    // (mm) Start position of block
-             FxdTiCtrl::endPosn_prevBlock = { 0.0f }; // (mm) End position of previous block
-xyze_float_t FxdTiCtrl::ratio;                        // (ratio) Axis move ratio of block
-float FxdTiCtrl::accel_P,                       // Acceleration prime of block. [mm/sec/sec]
-      FxdTiCtrl::decel_P,                       // Deceleration prime of block. [mm/sec/sec]
-      FxdTiCtrl::F_P,                           // Feedrate prime of block. [mm/sec]
-      FxdTiCtrl::f_s,                           // Starting feedrate of block. [mm/sec]
-      FxdTiCtrl::s_1e,                          // Position after acceleration phase of block.
-      FxdTiCtrl::s_2e;                          // Position after acceleration and coasting phase of block.
-
-uint32_t FxdTiCtrl::N1,                         // Number of data points in the acceleration phase.
-         FxdTiCtrl::N2,                         // Number of data points in the coasting phase.
-         FxdTiCtrl::N3;                         // Number of data points in the deceleration phase.
-
-uint32_t FxdTiCtrl::max_intervals;              // Total number of data points that will be generated from block.
+xyze_pos_t   FTMotion::startPosn,                     // (mm) Start position of block
+             FTMotion::endPosn_prevBlock = { 0.0f };  // (mm) End position of previous block
+xyze_float_t FTMotion::ratio;                         // (ratio) Axis move ratio of block
+float FTMotion::accel_P,                        // Acceleration prime of block. [mm/sec/sec]
+      FTMotion::decel_P,                        // Deceleration prime of block. [mm/sec/sec]
+      FTMotion::F_P,                            // Feedrate prime of block. [mm/sec]
+      FTMotion::f_s,                            // Starting feedrate of block. [mm/sec]
+      FTMotion::s_1e,                           // Position after acceleration phase of block.
+      FTMotion::s_2e;                           // Position after acceleration and coasting phase of block.
+
+uint32_t FTMotion::N1,                          // Number of data points in the acceleration phase.
+         FTMotion::N2,                          // Number of data points in the coasting phase.
+         FTMotion::N3;                          // Number of data points in the deceleration phase.
+
+uint32_t FTMotion::max_intervals;               // Total number of data points that will be generated from block.
 
 // Make vector variables.
-uint32_t FxdTiCtrl::makeVector_idx = 0,                     // Index of fixed time trajectory generation of the overall block.
-         FxdTiCtrl::makeVector_idx_z1 = 0,                  // Storage for the previously calculated index above.
-         FxdTiCtrl::makeVector_batchIdx = FTM_BATCH_SIZE;   // Index of fixed time trajectory generation within the batch.
+uint32_t FTMotion::makeVector_idx = 0,                    // Index of fixed time trajectory generation of the overall block.
+         FTMotion::makeVector_idx_z1 = 0,                 // Storage for the previously calculated index above.
+         FTMotion::makeVector_batchIdx = FTM_BATCH_SIZE;  // Index of fixed time trajectory generation within the batch.
 
 // Interpolation variables.
-xyze_long_t FxdTiCtrl::steps = { 0 };                                            // Step count accumulator.
-xyze_stepDir_t FxdTiCtrl::dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET); // Memory of the currently set step direction of the axis.
+xyze_long_t FTMotion::steps = { 0 };                  // Step count accumulator.
+xyze_stepDir_t FTMotion::dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET); // Memory of the currently set step direction of the axis.
 
-uint32_t FxdTiCtrl::interpIdx = 0,                    // Index of current data point being interpolated.
-         FxdTiCtrl::interpIdx_z1 = 0;                 // Storage for the previously calculated index above.
-hal_timer_t FxdTiCtrl::nextStepTicks = FTM_MIN_TICKS; // Accumulator for the next step time (in ticks).
+uint32_t FTMotion::interpIdx = 0,                     // Index of current data point being interpolated.
+         FTMotion::interpIdx_z1 = 0;                  // Storage for the previously calculated index above.
+hal_timer_t FTMotion::nextStepTicks = FTM_MIN_TICKS;  // Accumulator for the next step time (in ticks).
 
 // Shaping variables.
 #if HAS_X_AXIS
-  FxdTiCtrl::shaping_t FxdTiCtrl::shaping = {
+  FTMotion::shaping_t FTMotion::shaping = {
     0, 0,
     x:{ { 0.0f }, { 0.0f }, { 0 } },                  // d_zi, Ai, Ni
     #if HAS_Y_AXIS
@@ -120,8 +121,8 @@ hal_timer_t FxdTiCtrl::nextStepTicks = FTM_MIN_TICKS; // Accumulator for the nex
 
 #if HAS_EXTRUDERS
   // Linear advance variables.
-  float FxdTiCtrl::e_raw_z1 = 0.0f;             // (ms) Unit delay of raw extruder position.
-  float FxdTiCtrl::e_advanced_z1 = 0.0f;        // (ms) Unit delay of advanced extruder position.
+  float FTMotion::e_raw_z1 = 0.0f;        // (ms) Unit delay of raw extruder position.
+  float FTMotion::e_advanced_z1 = 0.0f;   // (ms) Unit delay of advanced extruder position.
 #endif
 
 constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
@@ -133,15 +134,15 @@ constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
 // Public functions.
 
 // Sets controller states to begin processing a block.
-void FxdTiCtrl::startBlockProc(block_t * const current_block) {
+void FTMotion::startBlockProc(block_t * const current_block) {
   current_block_cpy = current_block;
   blockProcRdy = true;
   blockProcDn = false;
   runoutEna = true;
 }
 
-// Moves any free data points to the stepper buffer even if a full batch isn't ready.
-void FxdTiCtrl::runoutBlock() {
+// Move any free data points to the stepper buffer even if a full batch isn't ready.
+void FTMotion::runoutBlock() {
 
   if (runoutEna && !batchRdy) {   // If the window is full already (block intervals was a multiple of
                                   // the batch size), or runout is not enabled, no runout is needed.
@@ -170,7 +171,7 @@ void FxdTiCtrl::runoutBlock() {
 }
 
 // Controller main, to be invoked from non-isr task.
-void FxdTiCtrl::loop() {
+void FTMotion::loop() {
 
   if (!cfg.mode) return;
 
@@ -188,7 +189,7 @@ void FxdTiCtrl::loop() {
   }
 
   // Planner processing and block conversion.
-  if (!blockProcRdy && !runout) stepper.fxdTiCtrl_BlockQueueUpdate();
+  if (!blockProcRdy && !runout) stepper.ftMotion_BlockQueueUpdate();
 
   if (blockProcRdy) {
     if (!blockProcRdy_z1) loadBlockData(current_block_cpy); // One-shot.
@@ -264,7 +265,7 @@ void FxdTiCtrl::loop() {
   }
 
   // Report busy status to planner.
-  planner.fxdTiCtrl_busy = (sts_stepperBusy || ((!blockProcDn && blockProcRdy) || batchRdy || batchRdyForInterp || runoutEna));
+  busy = (sts_stepperBusy || ((!blockProcDn && blockProcRdy) || batchRdy || batchRdyForInterp || runoutEna));
 
   blockProcRdy_z1 = blockProcRdy;
   makeVector_idx_z1 = makeVector_idx;
@@ -276,7 +277,7 @@ void FxdTiCtrl::loop() {
   // Refresh the gains used by shaping functions.
   // To be called on init or mode or zeta change.
 
-  void FxdTiCtrl::Shaping::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
+  void FTMotion::Shaping::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
 
     const float K = exp(-zeta * M_PI / sqrt(1.0f - sq(zeta))),
                 K2 = sq(K);
@@ -345,14 +346,14 @@ void FxdTiCtrl::loop() {
     #endif
   }
 
-  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
+  void FTMotion::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
     shaping.updateShapingA(zeta, vtol);
   }
 
   // Refresh the indices used by shaping functions.
   // To be called when frequencies change.
 
-  void FxdTiCtrl::AxisShaping::updateShapingN(const_float_t f, const_float_t df) {
+  void FTMotion::AxisShaping::updateShapingN(const_float_t f, const_float_t df) {
     // Protections omitted for DBZ and for index exceeding array length.
     switch (cfg.mode) {
       case ftMotionMode_ZV:
@@ -382,7 +383,7 @@ void FxdTiCtrl::loop() {
     }
   }
 
-  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=cfg.zeta*/) {
+  void FTMotion::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=cfg.zeta*/) {
     const float df = sqrt(1.0f - sq(zeta));
     shaping.x.updateShapingN(xf, df);
     TERN_(HAS_Y_AXIS, shaping.y.updateShapingN(yf, df));
@@ -391,12 +392,12 @@ void FxdTiCtrl::loop() {
 #endif // HAS_X_AXIS
 
 // Reset all trajectory processing variables.
-void FxdTiCtrl::reset() {
+void FTMotion::reset() {
 
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
-  traj.reset(); // Reset trajectory history
-  trajMod.reset(); // Reset modified trajectory history
+  traj.reset();     // Reset trajectory history
+  trajMod.reset();  // Reset modified trajectory history
 
   blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
   batchRdy = batchRdyForInterp = false;
@@ -424,13 +425,13 @@ void FxdTiCtrl::reset() {
 
 // Private functions.
 // Auxiliary function to get number of step commands in the buffer.
-uint32_t FxdTiCtrl::stepperCmdBuffItems() {
+uint32_t FTMotion::stepperCmdBuffItems() {
   const uint32_t udiff = stepperCmdBuff_produceIdx - stepperCmdBuff_consumeIdx;
   return stepperCmdBuff_produceIdx < stepperCmdBuff_consumeIdx ? (FTM_STEPPERCMD_BUFF_SIZE) + udiff : udiff;
 }
 
 // Initializes storage variables before startup.
-void FxdTiCtrl::init() {
+void FTMotion::init() {
   #if HAS_X_AXIS
     refreshShapingN();
     updateShapingA();
@@ -439,7 +440,7 @@ void FxdTiCtrl::init() {
 }
 
 // Loads / converts block data from planner to fixed-time control variables.
-void FxdTiCtrl::loadBlockData(block_t * const current_block) {
+void FTMotion::loadBlockData(block_t * const current_block) {
 
   const float totalLength = current_block->millimeters,
               oneOverLength = 1.0f / totalLength;
@@ -489,6 +490,7 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   const float fdiff = feSqByTwoD - fsSqByTwoA,          // (mm) Coasting distance if nominal speed is reached
               odiff = oneby2a - oneby2d,                // (i.e., oneby2a * 2) (mm/s) Change in speed for one second of acceleration
               ldiff = totalLength - fdiff;              // (mm) Distance to travel if nominal speed is reached
+
   float T2 = (1.0f / F_n) * (ldiff - odiff * sq(F_n));  // (s) Coasting duration after nominal speed reached
   if (T2 < 0.0f) {
     T2 = 0.0f;
@@ -496,7 +498,6 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   }
 
   const float T1 = (F_n - f_s) / a,                     // (s) Accel Time = difference in feedrate over acceleration
-              T3 = (F_n - f_e) / a;                     // (s) Decel Time = difference in feedrate over acceleration
 
   N1 = ceil(T1 * (FTM_FS));                       // Accel datapoints based on Hz frequency
   N2 = ceil(T2 * (FTM_FS));                       // Coast
@@ -536,7 +537,7 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
 }
 
 // Generate data points of the trajectory.
-void FxdTiCtrl::makeVector() {
+void FTMotion::makeVector() {
   float accel_k = 0.0f;                                   // (mm/s^2) Acceleration K factor
   float tau = (makeVector_idx + 1) * (FTM_TS);            // (s) Time since start of block
   float dist = 0.0f;                                      // (mm) Distance traveled
@@ -653,7 +654,7 @@ void FxdTiCtrl::makeVector() {
 }
 
 // Interpolates single data point to stepper commands.
-void FxdTiCtrl::convertToSteps(const uint32_t idx) {
+void FTMotion::convertToSteps(const uint32_t idx) {
   xyze_long_t err_P = { 0 };
 
   //#define STEPS_ROUNDING

commit a5e4b4bd7d18f84c29a13430c636ecae289c352a
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Aug 7 10:30:24 2023 +0200

    üö∏ FT_MOTION menu updates (#26083)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 6fe8e936e0..385d81622e 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -276,7 +276,7 @@ void FxdTiCtrl::loop() {
   // Refresh the gains used by shaping functions.
   // To be called on init or mode or zeta change.
 
-  void FxdTiCtrl::Shaping::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
+  void FxdTiCtrl::Shaping::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
 
     const float K = exp(-zeta * M_PI / sqrt(1.0f - sq(zeta))),
                 K2 = sq(K);
@@ -345,7 +345,7 @@ void FxdTiCtrl::loop() {
     #endif
   }
 
-  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
+  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=cfg.zeta*/, const_float_t vtol/*=cfg.vtol*/) {
     shaping.updateShapingA(zeta, vtol);
   }
 
@@ -382,7 +382,7 @@ void FxdTiCtrl::loop() {
     }
   }
 
-  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=FTM_SHAPING_ZETA*/) {
+  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=cfg.zeta*/) {
     const float df = sqrt(1.0f - sq(zeta));
     shaping.x.updateShapingN(xf, df);
     TERN_(HAS_Y_AXIS, shaping.y.updateShapingN(yf, df));

commit 7b23fd3548f5aabc269ba24ec947d6fdfd225072
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Fri Jun 30 00:06:05 2023 +0200

    üêõ Fix FT Motion runout in progress (#26020)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index d3c4de8962..6fe8e936e0 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -75,6 +75,7 @@ bool FxdTiCtrl::batchRdy = false;                 // Indicates a batch of the fi
 bool FxdTiCtrl::batchRdyForInterp = false;        // Indicates the batch is done being post processed,
                                                   //  if applicable, and is ready to be converted to step commands.
 bool FxdTiCtrl::runoutEna = false;                // True if runout of the block hasn't been done and is allowed.
+bool FxdTiCtrl::runout = false;                   // Indicates if runout is in progress.
 
 // Trapezoid data variables.
 xyze_pos_t   FxdTiCtrl::startPosn,                    // (mm) Start position of block
@@ -123,6 +124,8 @@ hal_timer_t FxdTiCtrl::nextStepTicks = FTM_MIN_TICKS; // Accumulator for the nex
   float FxdTiCtrl::e_advanced_z1 = 0.0f;        // (ms) Unit delay of advanced extruder position.
 #endif
 
+constexpr uint32_t last_batchIdx = (FTM_WINDOW_SIZE) - (FTM_BATCH_SIZE);
+
 //-----------------------------------------------------------------//
 // Function definitions.
 //-----------------------------------------------------------------//
@@ -143,8 +146,8 @@ void FxdTiCtrl::runoutBlock() {
   if (runoutEna && !batchRdy) {   // If the window is full already (block intervals was a multiple of
                                   // the batch size), or runout is not enabled, no runout is needed.
     // Fill out the trajectory window with the last position calculated.
-    if (makeVector_batchIdx > FTM_BATCH_SIZE)
-      for (uint32_t i = makeVector_batchIdx; i < 2 * (FTM_BATCH_SIZE); i++) {
+    if (makeVector_batchIdx > last_batchIdx)
+      for (uint32_t i = makeVector_batchIdx; i < (FTM_WINDOW_SIZE); i++) {
         LOGICAL_AXIS_CODE(
           traj.e[i] = traj.e[makeVector_batchIdx - 1],
           traj.x[i] = traj.x[makeVector_batchIdx - 1],
@@ -159,8 +162,9 @@ void FxdTiCtrl::runoutBlock() {
         );
       }
 
-    makeVector_batchIdx = FTM_BATCH_SIZE;
+    makeVector_batchIdx = last_batchIdx;
     batchRdy = true;
+    runout = true;
   }
   runoutEna = false;
 }
@@ -184,7 +188,7 @@ void FxdTiCtrl::loop() {
   }
 
   // Planner processing and block conversion.
-  if (!blockProcRdy) stepper.fxdTiCtrl_BlockQueueUpdate();
+  if (!blockProcRdy && !runout) stepper.fxdTiCtrl_BlockQueueUpdate();
 
   if (blockProcRdy) {
     if (!blockProcRdy_z1) loadBlockData(current_block_cpy); // One-shot.
@@ -192,6 +196,27 @@ void FxdTiCtrl::loop() {
       makeVector();
   }
 
+  if (runout && !batchRdy) { // The lower half of the window has been runout.
+    // Runout the upper half of the window: the upper half has been shifted into the lower
+    // half. Fill out the upper half so another batch can be processed.
+    for (uint32_t i = last_batchIdx; i < (FTM_WINDOW_SIZE) - 1; i++) {
+      LOGICAL_AXIS_CODE(
+        traj.e[i] = traj.e[(FTM_WINDOW_SIZE) - 1],
+        traj.x[i] = traj.x[(FTM_WINDOW_SIZE) - 1],
+        traj.y[i] = traj.y[(FTM_WINDOW_SIZE) - 1],
+        traj.z[i] = traj.z[(FTM_WINDOW_SIZE) - 1],
+        traj.i[i] = traj.i[(FTM_WINDOW_SIZE) - 1],
+        traj.j[i] = traj.j[(FTM_WINDOW_SIZE) - 1],
+        traj.k[i] = traj.k[(FTM_WINDOW_SIZE) - 1],
+        traj.u[i] = traj.u[(FTM_WINDOW_SIZE) - 1],
+        traj.v[i] = traj.v[(FTM_WINDOW_SIZE) - 1],
+        traj.w[i] = traj.w[(FTM_WINDOW_SIZE) - 1]
+      );
+    }
+    batchRdy = true;
+    runout = false;
+  }
+
   // FBS / post processing.
   if (batchRdy && !batchRdyForInterp) {
 
@@ -371,10 +396,12 @@ void FxdTiCtrl::reset() {
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
   traj.reset(); // Reset trajectory history
+  trajMod.reset(); // Reset modified trajectory history
 
   blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
   batchRdy = batchRdyForInterp = false;
   runoutEna = false;
+  runout = false;
 
   endPosn_prevBlock.reset();
 
@@ -611,8 +638,8 @@ void FxdTiCtrl::makeVector() {
   #endif
 
   // Filled up the queue with regular and shaped steps
-  if (++makeVector_batchIdx == 2 * (FTM_BATCH_SIZE)) {
-    makeVector_batchIdx = FTM_BATCH_SIZE;
+  if (++makeVector_batchIdx == (FTM_WINDOW_SIZE)) {
+    makeVector_batchIdx = last_batchIdx;
     batchRdy = true;
   }
 

commit 8c9172cf5d21fd57aed16edbe825a872ae064ad0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 22 02:54:21 2023 -0500

    üçª Fixed-Time Motion integration (#25719)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index d6c834cbc4..d3c4de8962 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -61,53 +61,25 @@ bool FxdTiCtrl::sts_stepperBusy = false;          // The stepper buffer has item
 
 // Private variables.
 // NOTE: These are sized for Ulendo FBS use.
-#if HAS_X_AXIS
-  float FxdTiCtrl::xd[2 * (FTM_BATCH_SIZE)],  // = {0.0f} Storage for fixed-time-based trajectory.
-        FxdTiCtrl::xm[FTM_BATCH_SIZE];        // = {0.0f} Storage for modified fixed-time-based trajectory.
-#endif
-#if HAS_Y_AXIS
-  float FxdTiCtrl::yd[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::ym[FTM_BATCH_SIZE];
-#endif
-#if HAS_Z_AXIS
-  float FxdTiCtrl::zd[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::zm[FTM_BATCH_SIZE];
-#endif
-#if HAS_EXTRUDERS
-  float FxdTiCtrl::ed[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::em[FTM_BATCH_SIZE];
-#endif
-
-block_t* FxdTiCtrl::current_block_cpy = nullptr; // Pointer to current block being processed.
-bool FxdTiCtrl::blockProcRdy = false,           // Indicates a block is ready to be processed.
-     FxdTiCtrl::blockProcRdy_z1 = false,        // Storage for the previous indicator.
-     FxdTiCtrl::blockProcDn = false;            // Indicates current block is done being processed.
-bool FxdTiCtrl::batchRdy = false;               // Indicates a batch of the fixed time trajectory
-                                                //  has been generated, is now available in the upper -
-                                                //  half of xd, yd, zd, ed vectors, and is ready to be
-                                                //  post processed, if applicable, then interpolated.
-bool FxdTiCtrl::batchRdyForInterp = false;      // Indicates the batch is done being post processed,
-                                                //  if applicable, and is ready to be converted to step commands.
-bool FxdTiCtrl::runoutEna = false;              // True if runout of the block hasn't been done and is allowed.
+xyze_trajectory_t FxdTiCtrl::traj;                // = {0.0f} Storage for fixed-time-based trajectory.
+xyze_trajectoryMod_t FxdTiCtrl::trajMod;          // = {0.0f} Storage for modified fixed-time-based trajectory.
+
+block_t* FxdTiCtrl::current_block_cpy = nullptr;  // Pointer to current block being processed.
+bool FxdTiCtrl::blockProcRdy = false,             // Indicates a block is ready to be processed.
+     FxdTiCtrl::blockProcRdy_z1 = false,          // Storage for the previous indicator.
+     FxdTiCtrl::blockProcDn = false;              // Indicates current block is done being processed.
+bool FxdTiCtrl::batchRdy = false;                 // Indicates a batch of the fixed time trajectory
+                                                  //  has been generated, is now available in the upper -
+                                                  //  half of traj.x[], y, z ... e vectors, and is ready to be
+                                                  //  post processed, if applicable, then interpolated.
+bool FxdTiCtrl::batchRdyForInterp = false;        // Indicates the batch is done being post processed,
+                                                  //  if applicable, and is ready to be converted to step commands.
+bool FxdTiCtrl::runoutEna = false;                // True if runout of the block hasn't been done and is allowed.
 
 // Trapezoid data variables.
-#if HAS_X_AXIS
-  float FxdTiCtrl::x_startPosn,                 // (mm) Start position of block
-        FxdTiCtrl::x_endPosn_prevBlock = 0.0f,  // (mm) Start position of block
-        FxdTiCtrl::x_Ratio;                     // (ratio) Axis move ratio of block
-#endif
-#if HAS_Y_AXIS
-  float FxdTiCtrl::y_startPosn,
-        FxdTiCtrl::y_endPosn_prevBlock = 0.0f,
-        FxdTiCtrl::y_Ratio;
-#endif
-#if HAS_Z_AXIS
-  float FxdTiCtrl::z_startPosn,
-        FxdTiCtrl::z_endPosn_prevBlock = 0.0f,
-        FxdTiCtrl::z_Ratio;
-#endif
-#if HAS_EXTRUDERS
-  float FxdTiCtrl::e_startPosn,
-        FxdTiCtrl::e_endPosn_prevBlock = 0.0f,
-        FxdTiCtrl::e_Ratio;
-#endif
+xyze_pos_t   FxdTiCtrl::startPosn,                    // (mm) Start position of block
+             FxdTiCtrl::endPosn_prevBlock = { 0.0f }; // (mm) End position of previous block
+xyze_float_t FxdTiCtrl::ratio;                        // (ratio) Axis move ratio of block
 float FxdTiCtrl::accel_P,                       // Acceleration prime of block. [mm/sec/sec]
       FxdTiCtrl::decel_P,                       // Deceleration prime of block. [mm/sec/sec]
       FxdTiCtrl::F_P,                           // Feedrate prime of block. [mm/sec]
@@ -127,22 +99,8 @@ uint32_t FxdTiCtrl::makeVector_idx = 0,                     // Index of fixed ti
          FxdTiCtrl::makeVector_batchIdx = FTM_BATCH_SIZE;   // Index of fixed time trajectory generation within the batch.
 
 // Interpolation variables.
-#if HAS_X_AXIS
-  int32_t FxdTiCtrl::x_steps = 0;                               // Step count accumulator.
-  stepDirState_t FxdTiCtrl::x_dirState = stepDirState_NOT_SET;  // Memory of the currently set step direction of the axis.
-#endif
-#if HAS_Y_AXIS
-  int32_t FxdTiCtrl::y_steps = 0;
-  stepDirState_t FxdTiCtrl::y_dirState = stepDirState_NOT_SET;
-#endif
-#if HAS_Z_AXIS
-  int32_t FxdTiCtrl::z_steps = 0;
-  stepDirState_t FxdTiCtrl::z_dirState = stepDirState_NOT_SET;
-#endif
-#if HAS_EXTRUDERS
-  int32_t FxdTiCtrl::e_steps = 0;
-  stepDirState_t FxdTiCtrl::e_dirState = stepDirState_NOT_SET;
-#endif
+xyze_long_t FxdTiCtrl::steps = { 0 };                                            // Step count accumulator.
+xyze_stepDir_t FxdTiCtrl::dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET); // Memory of the currently set step direction of the axis.
 
 uint32_t FxdTiCtrl::interpIdx = 0,                    // Index of current data point being interpolated.
          FxdTiCtrl::interpIdx_z1 = 0;                 // Storage for the previously calculated index above.
@@ -150,16 +108,13 @@ hal_timer_t FxdTiCtrl::nextStepTicks = FTM_MIN_TICKS; // Accumulator for the nex
 
 // Shaping variables.
 #if HAS_X_AXIS
-  uint32_t FxdTiCtrl::xy_zi_idx = 0,                  // Index of storage in the data point delay vectors.
-           FxdTiCtrl::xy_max_i = 0;                   // Vector length for the selected shaper.
-  float FxdTiCtrl::xd_zi[FTM_ZMAX] = { 0.0f };        // Data point delay vector.
-  float FxdTiCtrl::x_Ai[5];                           // Shaping gain vector.
-  uint32_t FxdTiCtrl::x_Ni[5];                        // Shaping time index vector.
-#endif
-#if HAS_Y_AXIS
-  float FxdTiCtrl::yd_zi[FTM_ZMAX] = { 0.0f };
-  float FxdTiCtrl::y_Ai[5];
-  uint32_t FxdTiCtrl::y_Ni[5];
+  FxdTiCtrl::shaping_t FxdTiCtrl::shaping = {
+    0, 0,
+    x:{ { 0.0f }, { 0.0f }, { 0 } },                  // d_zi, Ai, Ni
+    #if HAS_Y_AXIS
+      y:{ { 0.0f }, { 0.0f }, { 0 } }                 // d_zi, Ai, Ni
+    #endif
+  };
 #endif
 
 #if HAS_EXTRUDERS
@@ -188,14 +143,22 @@ void FxdTiCtrl::runoutBlock() {
   if (runoutEna && !batchRdy) {   // If the window is full already (block intervals was a multiple of
                                   // the batch size), or runout is not enabled, no runout is needed.
     // Fill out the trajectory window with the last position calculated.
-    if (makeVector_batchIdx > FTM_BATCH_SIZE) {
+    if (makeVector_batchIdx > FTM_BATCH_SIZE)
       for (uint32_t i = makeVector_batchIdx; i < 2 * (FTM_BATCH_SIZE); i++) {
-                             xd[i] = xd[makeVector_batchIdx - 1];
-        TERN_(HAS_Y_AXIS,    yd[i] = yd[makeVector_batchIdx - 1]);
-        TERN_(HAS_Y_AXIS,    zd[i] = zd[makeVector_batchIdx - 1]);
-        TERN_(HAS_EXTRUDERS, ed[i] = ed[makeVector_batchIdx - 1]);
+        LOGICAL_AXIS_CODE(
+          traj.e[i] = traj.e[makeVector_batchIdx - 1],
+          traj.x[i] = traj.x[makeVector_batchIdx - 1],
+          traj.y[i] = traj.y[makeVector_batchIdx - 1],
+          traj.z[i] = traj.z[makeVector_batchIdx - 1],
+          traj.i[i] = traj.i[makeVector_batchIdx - 1],
+          traj.j[i] = traj.j[makeVector_batchIdx - 1],
+          traj.k[i] = traj.k[makeVector_batchIdx - 1],
+          traj.u[i] = traj.u[makeVector_batchIdx - 1],
+          traj.v[i] = traj.v[makeVector_batchIdx - 1],
+          traj.w[i] = traj.w[makeVector_batchIdx - 1]
+        );
       }
-    }
+
     makeVector_batchIdx = FTM_BATCH_SIZE;
     batchRdy = true;
   }
@@ -234,23 +197,28 @@ void FxdTiCtrl::loop() {
 
     // Call Ulendo FBS here.
 
-    memcpy(xm, &xd[FTM_BATCH_SIZE], sizeof(xm));
-    TERN_(HAS_Y_AXIS, memcpy(ym, &yd[FTM_BATCH_SIZE], sizeof(ym)));
-
-    // Done compensating ...
-
-    // Copy the uncompensated vectors.
-    TERN_(HAS_Z_AXIS,    memcpy(zm, &zd[FTM_BATCH_SIZE], sizeof(zm)));
-    TERN_(HAS_EXTRUDERS, memcpy(em, &ed[FTM_BATCH_SIZE], sizeof(em)));
-
-    // Shift the time series back in the window.
-    memcpy(xd, &xd[FTM_BATCH_SIZE], sizeof(xd) / 2);
-    TERN_(HAS_Y_AXIS, memcpy(yd, &yd[FTM_BATCH_SIZE], sizeof(yd) / 2));
-    // Disabled by comment as these are uncompensated, the lower half is not used.
-    //TERN_(HAS_Z_AXIS,    memcpy(zd, &zd[FTM_BATCH_SIZE], (sizeof(zd) / 2)));
-    //TERN_(HAS_EXTRUDERS, memcpy(ed, &ed[FTM_BATCH_SIZE], (sizeof(ed) / 2)));
-
-    // ... data is ready in xm, ym, zm, em.
+    // Copy the uncompensated vectors. (XY done, other axes uncompensated)
+    LOGICAL_AXIS_CODE(
+      memcpy(trajMod.e, &traj.e[FTM_BATCH_SIZE], sizeof(trajMod.e)),
+      memcpy(trajMod.x, &traj.x[FTM_BATCH_SIZE], sizeof(trajMod.x)),
+      memcpy(trajMod.y, &traj.y[FTM_BATCH_SIZE], sizeof(trajMod.y)),
+      memcpy(trajMod.z, &traj.z[FTM_BATCH_SIZE], sizeof(trajMod.z)),
+      memcpy(trajMod.i, &traj.i[FTM_BATCH_SIZE], sizeof(trajMod.i)),
+      memcpy(trajMod.j, &traj.j[FTM_BATCH_SIZE], sizeof(trajMod.j)),
+      memcpy(trajMod.k, &traj.k[FTM_BATCH_SIZE], sizeof(trajMod.k)),
+      memcpy(trajMod.u, &traj.u[FTM_BATCH_SIZE], sizeof(trajMod.u)),
+      memcpy(trajMod.v, &traj.v[FTM_BATCH_SIZE], sizeof(trajMod.v)),
+      memcpy(trajMod.w, &traj.w[FTM_BATCH_SIZE], sizeof(trajMod.w))
+    );
+
+    // Shift the time series back in the window for (shaped) X and Y
+    TERN_(HAS_X_AXIS, memcpy(traj.x, &traj.x[FTM_BATCH_SIZE], sizeof(traj.x) / 2));
+    TERN_(HAS_Y_AXIS, memcpy(traj.y, &traj.y[FTM_BATCH_SIZE], sizeof(traj.y) / 2));
+
+    // Z...W and E Disabled! Uncompensated so the lower half is not used.
+    //TERN_(HAS_Z_AXIS, memcpy(&traj.z[0], &traj.z[FTM_BATCH_SIZE], sizeof(traj.z) / 2));
+
+    // ... data is ready in trajMod.
     batchRdyForInterp = true;
 
     batchRdy = false; // Clear so that makeVector() may resume generating points.
@@ -282,134 +250,119 @@ void FxdTiCtrl::loop() {
 
   // Refresh the gains used by shaping functions.
   // To be called on init or mode or zeta change.
-  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
 
-    const float K = exp( -zeta * M_PI / sqrt(1.0f - sq(zeta)) ),
+  void FxdTiCtrl::Shaping::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
+
+    const float K = exp(-zeta * M_PI / sqrt(1.0f - sq(zeta))),
                 K2 = sq(K);
 
     switch (cfg.mode) {
 
       case ftMotionMode_ZV:
-        xy_max_i = 1U;
-        x_Ai[0] = 1.0f / (1.0f + K);
-        x_Ai[1] = x_Ai[0] * K;
+        max_i = 1U;
+        x.Ai[0] = 1.0f / (1.0f + K);
+        x.Ai[1] = x.Ai[0] * K;
         break;
 
       case ftMotionMode_ZVD:
-        xy_max_i = 2U;
-        x_Ai[0] = 1.0f / ( 1.0f + 2.0f * K + K2 );
-        x_Ai[1] = x_Ai[0] * 2.0f * K;
-        x_Ai[2] = x_Ai[0] * K2;
+        max_i = 2U;
+        x.Ai[0] = 1.0f / ( 1.0f + 2.0f * K + K2 );
+        x.Ai[1] = x.Ai[0] * 2.0f * K;
+        x.Ai[2] = x.Ai[0] * K2;
         break;
 
       case ftMotionMode_EI: {
-        xy_max_i = 2U;
-        x_Ai[0] = 0.25f * (1.0f + vtol);
-        x_Ai[1] = 0.50f * (1.0f - vtol) * K;
-        x_Ai[2] = x_Ai[0] * K2;
-        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2]);
-        for (uint32_t i = 0U; i < 3U; i++) { x_Ai[i] *= A_adj; }
+        max_i = 2U;
+        x.Ai[0] = 0.25f * (1.0f + vtol);
+        x.Ai[1] = 0.50f * (1.0f - vtol) * K;
+        x.Ai[2] = x.Ai[0] * K2;
+        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2]);
+        for (uint32_t i = 0U; i < 3U; i++) { x.Ai[i] *= A_adj; }
       } break;
 
       case ftMotionMode_2HEI: {
-        xy_max_i = 3U;
+        max_i = 3U;
         const float vtol2 = sq(vtol);
         const float X = pow(vtol2 * (sqrt(1.0f - vtol2) + 1.0f), 1.0f / 3.0f);
-        x_Ai[0] = ( 3.0f * sq(X) + 2.0f * X + 3.0f * vtol2 ) / (16.0f * X);
-        x_Ai[1] = ( 0.5f - x_Ai[0] ) * K;
-        x_Ai[2] = x_Ai[1] * K;
-        x_Ai[3] = x_Ai[0] * cu(K);
-        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2] + x_Ai[3]);
-        for (uint32_t i = 0U; i < 4U; i++) { x_Ai[i] *= A_adj; }
+        x.Ai[0] = ( 3.0f * sq(X) + 2.0f * X + 3.0f * vtol2 ) / (16.0f * X);
+        x.Ai[1] = ( 0.5f - x.Ai[0] ) * K;
+        x.Ai[2] = x.Ai[1] * K;
+        x.Ai[3] = x.Ai[0] * cu(K);
+        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3]);
+        for (uint32_t i = 0U; i < 4U; i++) { x.Ai[i] *= A_adj; }
       } break;
 
       case ftMotionMode_3HEI: {
-        xy_max_i = 4U;
-        x_Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol + 2.0f * sqrt( 2.0f * ( vtol + 1.0f ) * vtol ) );
-        x_Ai[1] = 0.25f * ( 1.0f - vtol ) * K;
-        x_Ai[2] = ( 0.5f * ( 1.0f + vtol ) - 2.0f * x_Ai[0] ) * K2;
-        x_Ai[3] = x_Ai[1] * K2;
-        x_Ai[4] = x_Ai[0] * sq(K2);
-        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2] + x_Ai[3] + x_Ai[4]);
-        for (uint32_t i = 0U; i < 5U; i++) { x_Ai[i] *= A_adj; }
+        max_i = 4U;
+        x.Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol + 2.0f * sqrt( 2.0f * ( vtol + 1.0f ) * vtol ) );
+        x.Ai[1] = 0.25f * ( 1.0f - vtol ) * K;
+        x.Ai[2] = ( 0.5f * ( 1.0f + vtol ) - 2.0f * x.Ai[0] ) * K2;
+        x.Ai[3] = x.Ai[1] * K2;
+        x.Ai[4] = x.Ai[0] * sq(K2);
+        const float A_adj = 1.0f / (x.Ai[0] + x.Ai[1] + x.Ai[2] + x.Ai[3] + x.Ai[4]);
+        for (uint32_t i = 0U; i < 5U; i++) { x.Ai[i] *= A_adj; }
       } break;
 
       case ftMotionMode_MZV: {
-        xy_max_i = 2U;
+        max_i = 2U;
         const float B = 1.4142135623730950488016887242097f * K;
-        x_Ai[0] = 1.0f / (1.0f + B + K2);
-        x_Ai[1] = x_Ai[0] * B;
-        x_Ai[2] = x_Ai[0] * K2;
+        x.Ai[0] = 1.0f / (1.0f + B + K2);
+        x.Ai[1] = x.Ai[0] * B;
+        x.Ai[2] = x.Ai[0] * K2;
       } break;
 
       default:
-        for (uint32_t i = 0U; i < 5U; i++) x_Ai[i] = 0.0f;
-        xy_max_i = 0;
+        for (uint32_t i = 0U; i < 5U; i++) x.Ai[i] = 0.0f;
+        max_i = 0;
     }
     #if HAS_Y_AXIS
-      memcpy(y_Ai, x_Ai, sizeof(x_Ai)); // For now, zeta and vtol are shared across x and y.
+      memcpy(y.Ai, x.Ai, sizeof(x.Ai)); // For now, zeta and vtol are shared across x and y.
     #endif
   }
 
+  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
+    shaping.updateShapingA(zeta, vtol);
+  }
+
   // Refresh the indices used by shaping functions.
   // To be called when frequencies change.
-  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=FTM_SHAPING_ZETA*/) {
 
+  void FxdTiCtrl::AxisShaping::updateShapingN(const_float_t f, const_float_t df) {
     // Protections omitted for DBZ and for index exceeding array length.
-
-    const float df = sqrt(1.0f - sq(zeta));
-
     switch (cfg.mode) {
       case ftMotionMode_ZV:
-        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
-        #if HAS_Y_AXIS
-          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
-        #endif
+        Ni[1] = round((0.5f / f / df) * (FTM_FS));
         break;
       case ftMotionMode_ZVD:
       case ftMotionMode_EI:
-        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
-        x_Ni[2] = 2 * x_Ni[1];
-        #if HAS_Y_AXIS
-          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
-          y_Ni[2] = 2 * y_Ni[1];
-        #endif
+        Ni[1] = round((0.5f / f / df) * (FTM_FS));
+        Ni[2] = Ni[1] + Ni[1];
         break;
       case ftMotionMode_2HEI:
-        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
-        x_Ni[2] = 2 * x_Ni[1];
-        x_Ni[3] = 3 * x_Ni[1];
-        #if HAS_Y_AXIS
-          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
-          y_Ni[2] = 2 * y_Ni[1];
-          y_Ni[3] = 3 * y_Ni[1];
-        #endif
+        Ni[1] = round((0.5f / f / df) * (FTM_FS));
+        Ni[2] = Ni[1] + Ni[1];
+        Ni[3] = Ni[2] + Ni[1];
         break;
       case ftMotionMode_3HEI:
-        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
-        x_Ni[2] = 2 * x_Ni[1];
-        x_Ni[3] = 3 * x_Ni[1];
-        x_Ni[4] = 4 * x_Ni[1];
-        #if HAS_Y_AXIS
-          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
-          y_Ni[2] = 2 * y_Ni[1];
-          y_Ni[3] = 3 * y_Ni[1];
-          y_Ni[4] = 4 * y_Ni[1];
-        #endif
+        Ni[1] = round((0.5f / f / df) * (FTM_FS));
+        Ni[2] = Ni[1] + Ni[1];
+        Ni[3] = Ni[2] + Ni[1];
+        Ni[4] = Ni[3] + Ni[1];
         break;
       case ftMotionMode_MZV:
-        x_Ni[1] = round((0.375f / xf / df) * (FTM_FS));
-        x_Ni[2] = 2 * x_Ni[1];
-        #if HAS_Y_AXIS
-          y_Ni[1] = round((0.375f / yf / df) * (FTM_FS));
-          y_Ni[2] = 2 * y_Ni[1];
-        #endif
+        Ni[1] = round((0.375f / f / df) * (FTM_FS));
+        Ni[2] = Ni[1] + Ni[1];
         break;
-      default:
-        for (uint32_t i = 0U; i < 5U; i++) { x_Ni[i] = 0; TERN_(HAS_Y_AXIS, y_Ni[i] = 0); }
+      default: ZERO(Ni);
     }
   }
 
+  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=FTM_SHAPING_ZETA*/) {
+    const float df = sqrt(1.0f - sq(zeta));
+    shaping.x.updateShapingN(xf, df);
+    TERN_(HAS_Y_AXIS, shaping.y.updateShapingN(yf, df));
+  }
+
 #endif // HAS_X_AXIS
 
 // Reset all trajectory processing variables.
@@ -417,42 +370,26 @@ void FxdTiCtrl::reset() {
 
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
-  for (uint32_t i = 0U; i < (FTM_BATCH_SIZE); i++) { // Reset trajectory history
-    TERN_(HAS_X_AXIS,    xd[i] = 0.0f);
-    TERN_(HAS_Y_AXIS,    yd[i] = 0.0f);
-    TERN_(HAS_Z_AXIS,    zd[i] = 0.0f);
-    TERN_(HAS_EXTRUDERS, ed[i] = 0.0f);
-  }
+  traj.reset(); // Reset trajectory history
 
   blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
   batchRdy = batchRdyForInterp = false;
   runoutEna = false;
 
-  TERN_(HAS_X_AXIS,    x_endPosn_prevBlock = 0.0f);
-  TERN_(HAS_Y_AXIS,    y_endPosn_prevBlock = 0.0f);
-  TERN_(HAS_Z_AXIS,    z_endPosn_prevBlock = 0.0f);
-  TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock = 0.0f);
+  endPosn_prevBlock.reset();
 
   makeVector_idx = makeVector_idx_z1 = 0;
   makeVector_batchIdx = FTM_BATCH_SIZE;
 
-  TERN_(HAS_X_AXIS,    x_steps = 0);
-  TERN_(HAS_Y_AXIS,    y_steps = 0);
-  TERN_(HAS_Z_AXIS,    z_steps = 0);
-  TERN_(HAS_EXTRUDERS, e_steps = 0);
-
+  steps.reset();
   interpIdx = interpIdx_z1 = 0;
-
-  TERN_(HAS_X_AXIS,    x_dirState = stepDirState_NOT_SET);
-  TERN_(HAS_Y_AXIS,    y_dirState = stepDirState_NOT_SET);
-  TERN_(HAS_Z_AXIS,    z_dirState = stepDirState_NOT_SET);
-  TERN_(HAS_EXTRUDERS, e_dirState = stepDirState_NOT_SET);
-
+  dirState = LOGICAL_AXIS_ARRAY_1(stepDirState_NOT_SET);
   nextStepTicks = FTM_MIN_TICKS;
 
   #if HAS_X_AXIS
-    for (uint32_t i = 0U; i < (FTM_ZMAX); i++) { xd_zi[i] = 0.0f; TERN_(HAS_Y_AXIS, yd_zi[i] = 0.0f); }
-    xy_zi_idx = 0;
+    for (uint32_t i = 0U; i < (FTM_ZMAX); i++)
+      shaping.x.d_zi[i] = TERN_(HAS_Y_AXIS, shaping.y.d_zi[i] =) 0.0f;
+    shaping.zi_idx = 0;
   #endif
 
   TERN_(HAS_EXTRUDERS, e_raw_z1 = e_advanced_z1 = 0.0f);
@@ -482,33 +419,34 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
 
   const AxisBits direction = current_block->direction_bits;
 
-  #if HAS_X_AXIS
-    x_startPosn = x_endPosn_prevBlock;
-    float x_moveDist = current_block->steps.a / planner.settings.axis_steps_per_mm[X_AXIS];
-    if (!direction.x) x_moveDist *= -1.0f;
-    x_Ratio = x_moveDist * oneOverLength;
-  #endif
-
-  #if HAS_Y_AXIS
-    y_startPosn = y_endPosn_prevBlock;
-    float y_moveDist = current_block->steps.b / planner.settings.axis_steps_per_mm[Y_AXIS];
-    if (!direction.y) y_moveDist *= -1.0f;
-    y_Ratio = y_moveDist * oneOverLength;
-  #endif
+  startPosn = endPosn_prevBlock;
+  xyze_pos_t moveDist = LOGICAL_AXIS_ARRAY(
+    current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)],
+    current_block->steps.x / planner.settings.axis_steps_per_mm[X_AXIS],
+    current_block->steps.y / planner.settings.axis_steps_per_mm[Y_AXIS],
+    current_block->steps.z / planner.settings.axis_steps_per_mm[Z_AXIS],
+    current_block->steps.i / planner.settings.axis_steps_per_mm[I_AXIS],
+    current_block->steps.j / planner.settings.axis_steps_per_mm[J_AXIS],
+    current_block->steps.k / planner.settings.axis_steps_per_mm[K_AXIS],
+    current_block->steps.u / planner.settings.axis_steps_per_mm[U_AXIS],
+    current_block->steps.v / planner.settings.axis_steps_per_mm[V_AXIS],
+    current_block->steps.w / planner.settings.axis_steps_per_mm[W_AXIS]
+  );
 
-  #if HAS_Z_AXIS
-    z_startPosn = z_endPosn_prevBlock;
-    float z_moveDist = current_block->steps.c / planner.settings.axis_steps_per_mm[Z_AXIS];
-    if (!direction.z) z_moveDist *= -1.0f;
-    z_Ratio = z_moveDist * oneOverLength;
-  #endif
+  LOGICAL_AXIS_CODE(
+    if (!direction.e) moveDist.e *= -1.0f,
+    if (!direction.x) moveDist.x *= -1.0f,
+    if (!direction.y) moveDist.y *= -1.0f,
+    if (!direction.z) moveDist.z *= -1.0f,
+    if (!direction.i) moveDist.i *= -1.0f,
+    if (!direction.j) moveDist.j *= -1.0f,
+    if (!direction.k) moveDist.k *= -1.0f,
+    if (!direction.u) moveDist.u *= -1.0f,
+    if (!direction.v) moveDist.v *= -1.0f,
+    if (!direction.w) moveDist.w *= -1.0f
+  );
 
-  #if HAS_EXTRUDERS
-    e_startPosn = e_endPosn_prevBlock;
-    float extrusion = current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)];
-    if (!direction.e) extrusion *= -1.0f;
-    e_Ratio = extrusion * oneOverLength;
-  #endif
+  ratio = moveDist * oneOverLength;
 
   const float spm = totalLength / current_block->step_event_count;  // (steps/mm) Distance for each step
               f_s = spm * current_block->initial_rate;  // (steps/s) Start feedrate
@@ -525,7 +463,7 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
               odiff = oneby2a - oneby2d,                // (i.e., oneby2a * 2) (mm/s) Change in speed for one second of acceleration
               ldiff = totalLength - fdiff;              // (mm) Distance to travel if nominal speed is reached
   float T2 = (1.0f / F_n) * (ldiff - odiff * sq(F_n));  // (s) Coasting duration after nominal speed reached
-  if (T2 < 0.0f)  {
+  if (T2 < 0.0f) {
     T2 = 0.0f;
     F_n = SQRT(ldiff / odiff);                          // Clip by intersection if nominal speed can't be reached.
   }
@@ -567,10 +505,7 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   // One less than (Accel + Coasting + Decel) datapoints
   max_intervals = N1 + N2 + N3 - 1U;
 
-  TERN_(HAS_X_AXIS,    x_endPosn_prevBlock += x_moveDist);
-  TERN_(HAS_Y_AXIS,    y_endPosn_prevBlock += y_moveDist);
-  TERN_(HAS_Z_AXIS,    z_endPosn_prevBlock += z_moveDist);
-  TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock += extrusion);
+  endPosn_prevBlock += moveDist;
 }
 
 // Generate data points of the trajectory.
@@ -596,24 +531,32 @@ void FxdTiCtrl::makeVector() {
     accel_k = decel_P;                                    // (mm/s^2) Acceleration K factor from Decel phase
   }
 
-  TERN_(HAS_X_AXIS, xd[makeVector_batchIdx] = x_startPosn + x_Ratio * dist);  // (mm) X position for this datapoint
-  TERN_(HAS_Y_AXIS, yd[makeVector_batchIdx] = y_startPosn + y_Ratio * dist);  // (mm) Y
-  TERN_(HAS_Z_AXIS, zd[makeVector_batchIdx] = z_startPosn + z_Ratio * dist);  // (mm) Z
+  NUM_AXIS_CODE(
+    traj.x[makeVector_batchIdx] = startPosn.x + ratio.x * dist,
+    traj.y[makeVector_batchIdx] = startPosn.y + ratio.y * dist,
+    traj.z[makeVector_batchIdx] = startPosn.z + ratio.z * dist,
+    traj.i[makeVector_batchIdx] = startPosn.i + ratio.i * dist,
+    traj.j[makeVector_batchIdx] = startPosn.j + ratio.j * dist,
+    traj.k[makeVector_batchIdx] = startPosn.k + ratio.k * dist,
+    traj.u[makeVector_batchIdx] = startPosn.u + ratio.u * dist,
+    traj.v[makeVector_batchIdx] = startPosn.v + ratio.v * dist,
+    traj.w[makeVector_batchIdx] = startPosn.w + ratio.w * dist
+  );
 
   #if HAS_EXTRUDERS
-    const float new_raw_z1 = e_startPosn + e_Ratio * dist;
+    const float new_raw_z1 = startPosn.e + ratio.e * dist;
     if (cfg.linearAdvEna) {
       float dedt_adj = (new_raw_z1 - e_raw_z1) * (FTM_FS);
-      if (e_Ratio > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
+      if (ratio.e > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
 
       e_advanced_z1 += dedt_adj * (FTM_TS);
-      ed[makeVector_batchIdx] = e_advanced_z1;
+      traj.e[makeVector_batchIdx] = e_advanced_z1;
 
       e_raw_z1 = new_raw_z1;
     }
     else {
-      ed[makeVector_batchIdx] = new_raw_z1;
-      // Alternatively: ed[makeVector_batchIdx] = e_startPosn + (e_Ratio * dist) / (N1 + N2 + N3);
+      traj.e[makeVector_batchIdx] = new_raw_z1;
+      // Alternatively: ed[makeVector_batchIdx] = startPosn.e + (ratio.e * dist) / (N1 + N2 + N3);
     }
   #endif
 
@@ -625,11 +568,11 @@ void FxdTiCtrl::makeVector() {
 
     #if HAS_DYNAMIC_FREQ_MM
       case dynFreqMode_Z_BASED:
-        if (zd[makeVector_batchIdx] != zd_z1) { // Only update if Z changed.
-          const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * zd[makeVector_batchIdx],
-                      yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * zd[makeVector_batchIdx];
+        if (traj.z[makeVector_batchIdx] != zd_z1) { // Only update if Z changed.
+          const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.z[makeVector_batchIdx],
+                      yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.z[makeVector_batchIdx];
           updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ), _MAX(yf, FTM_MIN_SHAPE_FREQ));
-          zd_z1 = zd[makeVector_batchIdx];
+          zd_z1 = traj.z[makeVector_batchIdx];
         }
         break;
     #endif
@@ -638,8 +581,8 @@ void FxdTiCtrl::makeVector() {
       case dynFreqMode_MASS_BASED:
         // Update constantly. The optimization done for Z value makes
         // less sense for E, as E is expected to constantly change.
-        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * ed[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * ed[makeVector_batchIdx]) );
+        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * traj.e[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * traj.e[makeVector_batchIdx]) );
         break;
     #endif
 
@@ -648,22 +591,22 @@ void FxdTiCtrl::makeVector() {
 
   // Apply shaping if in mode.
   #if HAS_X_AXIS
-    if (WITHIN(cfg.mode, 10U, 19U)) {
-      xd_zi[xy_zi_idx] = xd[makeVector_batchIdx];
-      xd[makeVector_batchIdx] *= x_Ai[0];
+    if (cfg.modeHasShaper()) {
+      shaping.x.d_zi[shaping.zi_idx] = traj.x[makeVector_batchIdx];
+      traj.x[makeVector_batchIdx] *= shaping.x.Ai[0];
       #if HAS_Y_AXIS
-        yd_zi[xy_zi_idx] = yd[makeVector_batchIdx];
-        yd[makeVector_batchIdx] *= y_Ai[0];
+        shaping.y.d_zi[shaping.zi_idx] = traj.y[makeVector_batchIdx];
+        traj.y[makeVector_batchIdx] *= shaping.y.Ai[0];
       #endif
-      for (uint32_t i = 1U; i <= xy_max_i; i++) {
-        const uint32_t udiffx = xy_zi_idx - x_Ni[i];
-        xd[makeVector_batchIdx] += x_Ai[i] * xd_zi[x_Ni[i] > xy_zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
+      for (uint32_t i = 1U; i <= shaping.max_i; i++) {
+        const uint32_t udiffx = shaping.zi_idx - shaping.x.Ni[i];
+        traj.x[makeVector_batchIdx] += shaping.x.Ai[i] * shaping.x.d_zi[shaping.x.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
         #if HAS_Y_AXIS
-          const uint32_t udiffy = xy_zi_idx - y_Ni[i];
-          yd[makeVector_batchIdx] += y_Ai[i] * yd_zi[y_Ni[i] > xy_zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
+          const uint32_t udiffy = shaping.zi_idx - shaping.y.Ni[i];
+          traj.y[makeVector_batchIdx] += shaping.y.Ai[i] * shaping.y.d_zi[shaping.y.Ni[i] > shaping.zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
         #endif
       }
-      if (++xy_zi_idx == (FTM_ZMAX)) xy_zi_idx = 0;
+      if (++shaping.zi_idx == (FTM_ZMAX)) shaping.zi_idx = 0;
     }
   #endif
 
@@ -684,57 +627,63 @@ void FxdTiCtrl::makeVector() {
 
 // Interpolates single data point to stepper commands.
 void FxdTiCtrl::convertToSteps(const uint32_t idx) {
-  #if HAS_X_AXIS
-    int32_t x_err_P = 0;
-  #endif
-  #if HAS_Y_AXIS
-    int32_t y_err_P = 0;
-  #endif
-  #if HAS_Z_AXIS
-    int32_t z_err_P = 0;
-  #endif
-  #if HAS_EXTRUDERS
-    int32_t e_err_P = 0;
-  #endif
+  xyze_long_t err_P = { 0 };
 
   //#define STEPS_ROUNDING
   #if ENABLED(STEPS_ROUNDING)
-    #if HAS_X_AXIS
-      const float x_steps_tar = xm[idx] * planner.settings.axis_steps_per_mm[X_AXIS] + (xm[idx] < 0.0f ? -0.5f : 0.5f); // May be eliminated if guaranteed positive.
-      const int32_t x_delta = int32_t(x_steps_tar) - x_steps;
-    #endif
-    #if HAS_Y_AXIS
-      const float y_steps_tar = ym[idx] * planner.settings.axis_steps_per_mm[Y_AXIS] + (ym[idx] < 0.0f ? -0.5f : 0.5f);
-      const int32_t y_delta = int32_t(y_steps_tar) - y_steps;
-    #endif
-    #if HAS_Z_AXIS
-      const float z_steps_tar = zm[idx] * planner.settings.axis_steps_per_mm[Z_AXIS] + (zm[idx] < 0.0f ? -0.5f : 0.5f);
-      const int32_t z_delta = int32_t(z_steps_tar) - z_steps;
-    #endif
-    #if HAS_EXTRUDERS
-      const float e_steps_tar = em[idx] * planner.settings.axis_steps_per_mm[E_AXIS] + (em[idx] < 0.0f ? -0.5f : 0.5f);
-      const int32_t e_delta = int32_t(e_steps_tar) - e_steps;
-    #endif
+    const xyze_float_t steps_tar = LOGICAL_AXIS_ARRAY(
+      trajMod.e[idx] * planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)] + (trajMod.e[idx] < 0.0f ? -0.5f : 0.5f), // May be eliminated if guaranteed positive.
+      trajMod.x[idx] * planner.settings.axis_steps_per_mm[X_AXIS] + (trajMod.x[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.y[idx] * planner.settings.axis_steps_per_mm[Y_AXIS] + (trajMod.y[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.z[idx] * planner.settings.axis_steps_per_mm[Z_AXIS] + (trajMod.z[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.i[idx] * planner.settings.axis_steps_per_mm[I_AXIS] + (trajMod.i[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.j[idx] * planner.settings.axis_steps_per_mm[J_AXIS] + (trajMod.j[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.k[idx] * planner.settings.axis_steps_per_mm[K_AXIS] + (trajMod.k[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.u[idx] * planner.settings.axis_steps_per_mm[U_AXIS] + (trajMod.u[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.v[idx] * planner.settings.axis_steps_per_mm[V_AXIS] + (trajMod.v[idx] < 0.0f ? -0.5f : 0.5f),
+      trajMod.w[idx] * planner.settings.axis_steps_per_mm[W_AXIS] + (trajMod.w[idx] < 0.0f ? -0.5f : 0.5f),
+    );
+    xyze_long_t delta = xyze_long_t(steps_tar) - steps;
+    //const xyze_long_t delta = LOGICAL_AXIS_ARRAY(
+    //  int32_t(steps_tar.e) - steps.e,
+    //  int32_t(steps_tar.x) - steps.x,
+    //  int32_t(steps_tar.y) - steps.y,
+    //  int32_t(steps_tar.z) - steps.z,
+    //  int32_t(steps_tar.i) - steps.i,
+    //  int32_t(steps_tar.j) - steps.j,
+    //  int32_t(steps_tar.k) - steps.k,
+    //  int32_t(steps_tar.u) - steps.u,
+    //  int32_t(steps_tar.v) - steps.v,
+    //  int32_t(steps_tar.w) - steps.w
+    //);
   #else
-    #if HAS_X_AXIS
-      const int32_t x_delta = int32_t(xm[idx] * planner.settings.axis_steps_per_mm[X_AXIS]) - x_steps;
-    #endif
-    #if HAS_Y_AXIS
-      const int32_t y_delta = int32_t(ym[idx] * planner.settings.axis_steps_per_mm[Y_AXIS]) - y_steps;
-    #endif
-    #if HAS_Z_AXIS
-      const int32_t z_delta = int32_t(zm[idx] * planner.settings.axis_steps_per_mm[Z_AXIS]) - z_steps;
-    #endif
-    #if HAS_EXTRUDERS
-      const int32_t e_delta = int32_t(em[idx] * planner.settings.axis_steps_per_mm[E_AXIS]) - e_steps;
-    #endif
+    xyze_long_t delta = LOGICAL_AXIS_ARRAY(
+      int32_t(trajMod.e[idx] * planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)]) - steps.e,
+      int32_t(trajMod.x[idx] * planner.settings.axis_steps_per_mm[X_AXIS]) - steps.x,
+      int32_t(trajMod.y[idx] * planner.settings.axis_steps_per_mm[Y_AXIS]) - steps.y,
+      int32_t(trajMod.z[idx] * planner.settings.axis_steps_per_mm[Z_AXIS]) - steps.z,
+      int32_t(trajMod.i[idx] * planner.settings.axis_steps_per_mm[I_AXIS]) - steps.i,
+      int32_t(trajMod.j[idx] * planner.settings.axis_steps_per_mm[J_AXIS]) - steps.j,
+      int32_t(trajMod.k[idx] * planner.settings.axis_steps_per_mm[K_AXIS]) - steps.k,
+      int32_t(trajMod.u[idx] * planner.settings.axis_steps_per_mm[U_AXIS]) - steps.u,
+      int32_t(trajMod.v[idx] * planner.settings.axis_steps_per_mm[V_AXIS]) - steps.v,
+      int32_t(trajMod.w[idx] * planner.settings.axis_steps_per_mm[W_AXIS]) - steps.w
+    );
   #endif
 
   bool any_dirChange = (false
-    || TERN0(HAS_X_AXIS,    (x_delta > 0 && x_dirState != stepDirState_POS) || (x_delta < 0 && x_dirState != stepDirState_NEG))
-    || TERN0(HAS_Y_AXIS,    (y_delta > 0 && y_dirState != stepDirState_POS) || (y_delta < 0 && y_dirState != stepDirState_NEG))
-    || TERN0(HAS_Z_AXIS,    (z_delta > 0 && z_dirState != stepDirState_POS) || (z_delta < 0 && z_dirState != stepDirState_NEG))
-    || TERN0(HAS_EXTRUDERS, (e_delta > 0 && e_dirState != stepDirState_POS) || (e_delta < 0 && e_dirState != stepDirState_NEG))
+    LOGICAL_AXIS_GANG(
+      || (delta.e > 0 && dirState.e != stepDirState_POS) || (delta.e < 0 && dirState.e != stepDirState_NEG),
+      || (delta.x > 0 && dirState.x != stepDirState_POS) || (delta.x < 0 && dirState.x != stepDirState_NEG),
+      || (delta.y > 0 && dirState.y != stepDirState_POS) || (delta.y < 0 && dirState.y != stepDirState_NEG),
+      || (delta.z > 0 && dirState.z != stepDirState_POS) || (delta.z < 0 && dirState.z != stepDirState_NEG),
+      || (delta.i > 0 && dirState.i != stepDirState_POS) || (delta.i < 0 && dirState.i != stepDirState_NEG),
+      || (delta.j > 0 && dirState.j != stepDirState_POS) || (delta.j < 0 && dirState.j != stepDirState_NEG),
+      || (delta.k > 0 && dirState.k != stepDirState_POS) || (delta.k < 0 && dirState.k != stepDirState_NEG),
+      || (delta.u > 0 && dirState.u != stepDirState_POS) || (delta.u < 0 && dirState.u != stepDirState_NEG),
+      || (delta.v > 0 && dirState.v != stepDirState_POS) || (delta.v < 0 && dirState.v != stepDirState_NEG),
+      || (delta.w > 0 && dirState.w != stepDirState_POS) || (delta.w < 0 && dirState.w != stepDirState_NEG)
+    )
   );
 
   for (uint32_t i = 0U; i < (FTM_STEPS_PER_UNIT_TIME); i++) {
@@ -745,109 +694,48 @@ void FxdTiCtrl::convertToSteps(const uint32_t idx) {
 
     bool anyStep = false;
 
-    stepperCmdBuff[stepperCmdBuff_produceIdx] = 0;
-
-    // Commands are written in the format:
-    // |X_step|X_direction|Y_step|Y_direction|Z_step|Z_direction|E_step|E_direction|
-    #if HAS_X_AXIS
-      if (x_delta >= 0) {
-        if ((x_err_P + x_delta) < (FTM_CTS_COMPARE_VAL)) {
-          x_err_P += x_delta;
-        }
-        else {
-          x_steps++;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_X) | _BV(FT_BIT_STEP_X);
-          x_err_P += x_delta - (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-      else {
-        if ((x_err_P + x_delta) > -(FTM_CTS_COMPARE_VAL)) {
-          x_err_P += x_delta;
-        }
-        else {
-          x_steps--;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_X);
-          x_err_P += x_delta + (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-    #endif // HAS_X_AXIS
-
-    #if HAS_Y_AXIS
-      if (y_delta >= 0) {
-        if ((y_err_P + y_delta) < (FTM_CTS_COMPARE_VAL)) {
-          y_err_P += y_delta;
+    // Commands are written in a bitmask with step and dir as single bits
+    auto COMMAND_SET = [&](auto &d, auto &e, auto &s, auto &b, auto bd, auto bs) {
+      if (d >= 0) {
+        if (e + d < (FTM_CTS_COMPARE_VAL)) {
+          e += d;
         }
         else {
-          y_steps++;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Y) | _BV(FT_BIT_STEP_Y);
-          y_err_P += y_delta - (FTM_STEPS_PER_UNIT_TIME);
+          s++;
+          b |= bd | bs;
+          e += d - (FTM_STEPS_PER_UNIT_TIME);
           anyStep = true;
         }
       }
       else {
-        if ((y_err_P + y_delta) > -(FTM_CTS_COMPARE_VAL)) {
-          y_err_P += y_delta;
+        if ((e + d) > -(FTM_CTS_COMPARE_VAL)) {
+          e += d;
         }
         else {
-          y_steps--;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_Y);
-          y_err_P += y_delta + (FTM_STEPS_PER_UNIT_TIME);
+          s--;
+          b |= bs;
+          e += d + (FTM_STEPS_PER_UNIT_TIME);
           anyStep = true;
         }
       }
-    #endif // HAS_Y_AXIS
+    };
 
-    #if HAS_Z_AXIS
-      if (z_delta >= 0) {
-        if ((z_err_P + z_delta) < (FTM_CTS_COMPARE_VAL)) {
-          z_err_P += z_delta;
-        }
-        else {
-          z_steps++;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Z) | _BV(FT_BIT_STEP_Z);
-          z_err_P += z_delta - (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-      else {
-        if ((z_err_P + z_delta) > -(FTM_CTS_COMPARE_VAL)) {
-          z_err_P += z_delta;
-        }
-        else {
-          z_steps--;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_Z);
-          z_err_P += z_delta + (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-    #endif // HAS_Z_AXIS
+    // Init all step/dir bits to 0 (defaulting to reverse/negative motion)
+    stepperCmdBuff[stepperCmdBuff_produceIdx] = 0;
 
-    #if HAS_EXTRUDERS
-      if (e_delta >= 0) {
-        if ((e_err_P + e_delta) < (FTM_CTS_COMPARE_VAL)) {
-          e_err_P += e_delta;
-        }
-        else {
-          e_steps++;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_E) | _BV(FT_BIT_STEP_E);
-          e_err_P += e_delta - (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-      else {
-        if ((e_err_P + e_delta) > -(FTM_CTS_COMPARE_VAL)) {
-          e_err_P += e_delta;
-        }
-        else {
-          e_steps--;
-          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_E);
-          e_err_P += e_delta + (FTM_STEPS_PER_UNIT_TIME);
-          anyStep = true;
-        }
-      }
-    #endif // HAS_EXTRUDERS
+    // Set up step/dir bits for all axes
+    LOGICAL_AXIS_CODE(
+      COMMAND_SET(delta.e, err_P.e, steps.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E), _BV(FT_BIT_STEP_E)),
+      COMMAND_SET(delta.x, err_P.x, steps.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X), _BV(FT_BIT_STEP_X)),
+      COMMAND_SET(delta.y, err_P.y, steps.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y), _BV(FT_BIT_STEP_Y)),
+      COMMAND_SET(delta.z, err_P.z, steps.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z), _BV(FT_BIT_STEP_Z)),
+      COMMAND_SET(delta.i, err_P.i, steps.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I), _BV(FT_BIT_STEP_I)),
+      COMMAND_SET(delta.j, err_P.j, steps.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J), _BV(FT_BIT_STEP_J)),
+      COMMAND_SET(delta.k, err_P.k, steps.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K), _BV(FT_BIT_STEP_K)),
+      COMMAND_SET(delta.u, err_P.u, steps.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U), _BV(FT_BIT_STEP_U)),
+      COMMAND_SET(delta.v, err_P.v, steps.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V), _BV(FT_BIT_STEP_V)),
+      COMMAND_SET(delta.w, err_P.w, steps.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W), _BV(FT_BIT_STEP_W)),
+    );
 
     if (!anyStep) {
       nextStepTicks += (FTM_MIN_TICKS);
@@ -858,46 +746,25 @@ void FxdTiCtrl::convertToSteps(const uint32_t idx) {
       const uint8_t dir_index = stepperCmdBuff_produceIdx >> 3,
                     dir_bit = stepperCmdBuff_produceIdx & 0x7;
       if (any_dirChange) {
-        SBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
-        #if HAS_X_AXIS
-          if (x_delta > 0) {
-            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_X);
-            x_dirState = stepDirState_POS;
-          }
-          else {
-            x_dirState = stepDirState_NEG;
-          }
-        #endif
-
-        #if HAS_Y_AXIS
-          if (y_delta > 0) {
-            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Y);
-            y_dirState = stepDirState_POS;
-          }
-          else {
-            y_dirState = stepDirState_NEG;
-          }
-        #endif
 
-        #if HAS_Z_AXIS
-          if (z_delta > 0) {
-            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Z);
-            z_dirState = stepDirState_POS;
-          }
-          else {
-            z_dirState = stepDirState_NEG;
-          }
-        #endif
+        SBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
 
-        #if HAS_EXTRUDERS
-          if (e_delta > 0) {
-            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_E);
-            e_dirState = stepDirState_POS;
-          }
-          else {
-            e_dirState = stepDirState_NEG;
-          }
-        #endif
+        auto DIR_SET = [&](auto &d, auto &c, auto &b, auto bd) {
+          if (d > 0) { b |= bd; c = stepDirState_POS; } else { c = stepDirState_NEG; }
+        };
+
+        LOGICAL_AXIS_CODE(
+          DIR_SET(delta.e, dirState.e, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_E)),
+          DIR_SET(delta.x, dirState.x, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_X)),
+          DIR_SET(delta.y, dirState.y, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Y)),
+          DIR_SET(delta.z, dirState.z, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_Z)),
+          DIR_SET(delta.i, dirState.i, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_I)),
+          DIR_SET(delta.j, dirState.j, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_J)),
+          DIR_SET(delta.k, dirState.k, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_K)),
+          DIR_SET(delta.u, dirState.u, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_U)),
+          DIR_SET(delta.v, dirState.v, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_V)),
+          DIR_SET(delta.w, dirState.w, stepperCmdBuff[stepperCmdBuff_produceIdx], _BV(FT_BIT_DIR_W)),
+        );
 
         any_dirChange = false;
       }
@@ -905,12 +772,10 @@ void FxdTiCtrl::convertToSteps(const uint32_t idx) {
         CBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
       }
 
-      if (stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE) - 1) {
+      if (stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE) - 1)
         stepperCmdBuff_produceIdx = 0;
-      }
-      else {
+      else
         stepperCmdBuff_produceIdx++;
-      }
 
       nextStepTicks = FTM_MIN_TICKS;
     }

commit ed66f498eb713f59f14d000f8bfa550b34ce8528
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:38:24 2023 -0500

    üö∏ Fixed-Time Motion EEPROM and Menu (#25835)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 407296f030..d6c834cbc4 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -29,32 +29,28 @@
 
 FxdTiCtrl fxdTiCtrl;
 
-//-----------------------------------------------------------------//
-// Variables.
-//-----------------------------------------------------------------//
-
-// Public variables.
-ftMotionMode_t FxdTiCtrl::cfg_mode = FTM_DEFAULT_MODE;                // Mode / active compensation mode configuration.
-
-#if HAS_EXTRUDERS
-  bool FxdTiCtrl::cfg_linearAdvEna = FTM_LINEAR_ADV_DEFAULT_ENA;      // Linear advance enable configuration.
-  float FxdTiCtrl::cfg_linearAdvK = FTM_LINEAR_ADV_DEFAULT_K;         // Linear advance gain.
+#if !HAS_X_AXIS
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZV, "ftMotionMode_ZV requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_ZVD, "ftMotionMode_ZVD requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_EI, "ftMotionMode_EI requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_2HEI, "ftMotionMode_2HEI requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_3HEI, "ftMotionMode_3HEI requires at least one linear axis.");
+  static_assert(FTM_DEFAULT_MODE == ftMotionMode_MZV, "ftMotionMode_MZV requires at least one linear axis.");
 #endif
-
-dynFreqMode_t FxdTiCtrl::cfg_dynFreqMode = FTM_DEFAULT_DYNFREQ_MODE;  // Dynamic frequency mode configuration.
-#if !HAS_Z_AXIS
+#if !HAS_DYNAMIC_FREQ_MM
   static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_Z_BASED, "dynFreqMode_Z_BASED requires a Z axis.");
 #endif
-#if !(HAS_X_AXIS && HAS_EXTRUDERS)
+#if !HAS_DYNAMIC_FREQ_G
   static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_MASS_BASED, "dynFreqMode_MASS_BASED requires an X axis and an extruder.");
 #endif
 
-#if HAS_X_AXIS
-  float FxdTiCtrl::cfg_baseFreq[] = {  FTM_SHAPING_DEFAULT_X_FREQ     // Base frequency. [Hz]
-                    OPTARG(HAS_Y_AXIS, FTM_SHAPING_DEFAULT_Y_FREQ) };
-  float FxdTiCtrl::cfg_dynFreqK[] = { 0.0f OPTARG(HAS_Y_AXIS, 0.0f) };      // Scaling / gain for dynamic frequency. [Hz/mm] or [Hz/g]
-#endif
+//-----------------------------------------------------------------//
+// Variables.
+//-----------------------------------------------------------------//
 
+// Public variables.
+
+ft_config_t FxdTiCtrl::cfg;
 ft_command_t FxdTiCtrl::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U};                // Buffer of stepper commands.
 hal_timer_t FxdTiCtrl::stepperCmdBuff_StepRelativeTi[FTM_STEPPERCMD_BUFF_SIZE] = {0U};  // Buffer of the stepper command timing.
 uint8_t FxdTiCtrl::stepperCmdBuff_ApplyDir[FTM_STEPPERCMD_DIR_SIZE] = {0U};             // Buffer of whether DIR needs to be updated.
@@ -209,7 +205,7 @@ void FxdTiCtrl::runoutBlock() {
 // Controller main, to be invoked from non-isr task.
 void FxdTiCtrl::loop() {
 
-  if (!cfg_mode) return;
+  if (!cfg.mode) return;
 
   // Handle block abort with the following sequence:
   // 1. Zero out commands in stepper ISR.
@@ -291,7 +287,7 @@ void FxdTiCtrl::loop() {
     const float K = exp( -zeta * M_PI / sqrt(1.0f - sq(zeta)) ),
                 K2 = sq(K);
 
-    switch (cfg_mode) {
+    switch (cfg.mode) {
 
       case ftMotionMode_ZV:
         xy_max_i = 1U;
@@ -363,7 +359,7 @@ void FxdTiCtrl::loop() {
 
     const float df = sqrt(1.0f - sq(zeta));
 
-    switch (cfg_mode) {
+    switch (cfg.mode) {
       case ftMotionMode_ZV:
         x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
         #if HAS_Y_AXIS
@@ -472,8 +468,8 @@ uint32_t FxdTiCtrl::stepperCmdBuffItems() {
 // Initializes storage variables before startup.
 void FxdTiCtrl::init() {
   #if HAS_X_AXIS
-    updateShapingN(cfg_baseFreq[0] OPTARG(HAS_Y_AXIS, cfg_baseFreq[1]));
-    updateShapingA(FTM_SHAPING_ZETA, FTM_SHAPING_V_TOL);
+    refreshShapingN();
+    updateShapingA();
   #endif
   reset(); // Precautionary.
 }
@@ -606,9 +602,9 @@ void FxdTiCtrl::makeVector() {
 
   #if HAS_EXTRUDERS
     const float new_raw_z1 = e_startPosn + e_Ratio * dist;
-    if (cfg_linearAdvEna) {
+    if (cfg.linearAdvEna) {
       float dedt_adj = (new_raw_z1 - e_raw_z1) * (FTM_FS);
-      if (e_Ratio > 0.0f) dedt_adj += accel_k * cfg_linearAdvK;
+      if (e_Ratio > 0.0f) dedt_adj += accel_k * cfg.linearAdvK;
 
       e_advanced_z1 += dedt_adj * (FTM_TS);
       ed[makeVector_batchIdx] = e_advanced_z1;
@@ -622,28 +618,28 @@ void FxdTiCtrl::makeVector() {
   #endif
 
   // Update shaping parameters if needed.
-  #if HAS_Z_AXIS
+  #if HAS_DYNAMIC_FREQ_MM
     static float zd_z1 = 0.0f;
   #endif
-  switch (cfg_dynFreqMode) {
+  switch (cfg.dynFreqMode) {
 
-    #if HAS_Z_AXIS
+    #if HAS_DYNAMIC_FREQ_MM
       case dynFreqMode_Z_BASED:
         if (zd[makeVector_batchIdx] != zd_z1) { // Only update if Z changed.
-          const float xf = cfg_baseFreq[0] + cfg_dynFreqK[0] * zd[makeVector_batchIdx],
-                      yf = cfg_baseFreq[1] + cfg_dynFreqK[1] * zd[makeVector_batchIdx];
+          const float xf = cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * zd[makeVector_batchIdx],
+                      yf = cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * zd[makeVector_batchIdx];
           updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ), _MAX(yf, FTM_MIN_SHAPE_FREQ));
           zd_z1 = zd[makeVector_batchIdx];
         }
         break;
     #endif
 
-    #if HAS_X_AXIS && HAS_EXTRUDERS
+    #if HAS_DYNAMIC_FREQ_G
       case dynFreqMode_MASS_BASED:
         // Update constantly. The optimization done for Z value makes
         // less sense for E, as E is expected to constantly change.
-        updateShapingN(      cfg_baseFreq[0] + cfg_dynFreqK[0] * ed[makeVector_batchIdx]
-          OPTARG(HAS_Y_AXIS, cfg_baseFreq[1] + cfg_dynFreqK[1] * ed[makeVector_batchIdx]) );
+        updateShapingN(      cfg.baseFreq[X_AXIS] + cfg.dynFreqK[X_AXIS] * ed[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, cfg.baseFreq[Y_AXIS] + cfg.dynFreqK[Y_AXIS] * ed[makeVector_batchIdx]) );
         break;
     #endif
 
@@ -652,7 +648,7 @@ void FxdTiCtrl::makeVector() {
 
   // Apply shaping if in mode.
   #if HAS_X_AXIS
-    if (WITHIN(cfg_mode, 10U, 19U)) {
+    if (WITHIN(cfg.mode, 10U, 19U)) {
       xd_zi[xy_zi_idx] = xd[makeVector_batchIdx];
       xd[makeVector_batchIdx] *= x_Ai[0];
       #if HAS_Y_AXIS

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 97dae881f8..407296f030 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -422,9 +422,9 @@ void FxdTiCtrl::reset() {
   stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
 
   for (uint32_t i = 0U; i < (FTM_BATCH_SIZE); i++) { // Reset trajectory history
-    TERN_(HAS_X_AXIS, xd[i] = 0.0f);
-    TERN_(HAS_Y_AXIS, yd[i] = 0.0f);
-    TERN_(HAS_Z_AXIS, zd[i] = 0.0f);
+    TERN_(HAS_X_AXIS,    xd[i] = 0.0f);
+    TERN_(HAS_Y_AXIS,    yd[i] = 0.0f);
+    TERN_(HAS_Z_AXIS,    zd[i] = 0.0f);
     TERN_(HAS_EXTRUDERS, ed[i] = 0.0f);
   }
 
@@ -432,23 +432,26 @@ void FxdTiCtrl::reset() {
   batchRdy = batchRdyForInterp = false;
   runoutEna = false;
 
-  TERN_(HAS_X_AXIS, x_endPosn_prevBlock = 0.0f);
-  TERN_(HAS_Y_AXIS, y_endPosn_prevBlock = 0.0f);
-  TERN_(HAS_Z_AXIS, z_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_X_AXIS,    x_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_Y_AXIS,    y_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_Z_AXIS,    z_endPosn_prevBlock = 0.0f);
   TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock = 0.0f);
 
   makeVector_idx = makeVector_idx_z1 = 0;
   makeVector_batchIdx = FTM_BATCH_SIZE;
 
-  TERN_(HAS_X_AXIS, x_steps = 0);
-  TERN_(HAS_Y_AXIS, y_steps = 0);
-  TERN_(HAS_Z_AXIS, z_steps = 0);
+  TERN_(HAS_X_AXIS,    x_steps = 0);
+  TERN_(HAS_Y_AXIS,    y_steps = 0);
+  TERN_(HAS_Z_AXIS,    z_steps = 0);
   TERN_(HAS_EXTRUDERS, e_steps = 0);
+
   interpIdx = interpIdx_z1 = 0;
-  TERN_(HAS_X_AXIS, x_dirState = stepDirState_NOT_SET);
-  TERN_(HAS_Y_AXIS, y_dirState = stepDirState_NOT_SET);
-  TERN_(HAS_Z_AXIS, z_dirState = stepDirState_NOT_SET);
+
+  TERN_(HAS_X_AXIS,    x_dirState = stepDirState_NOT_SET);
+  TERN_(HAS_Y_AXIS,    y_dirState = stepDirState_NOT_SET);
+  TERN_(HAS_Z_AXIS,    z_dirState = stepDirState_NOT_SET);
   TERN_(HAS_EXTRUDERS, e_dirState = stepDirState_NOT_SET);
+
   nextStepTicks = FTM_MIN_TICKS;
 
   #if HAS_X_AXIS
@@ -486,28 +489,28 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   #if HAS_X_AXIS
     x_startPosn = x_endPosn_prevBlock;
     float x_moveDist = current_block->steps.a / planner.settings.axis_steps_per_mm[X_AXIS];
-    if (direction.x) x_moveDist *= -1.0f;
+    if (!direction.x) x_moveDist *= -1.0f;
     x_Ratio = x_moveDist * oneOverLength;
   #endif
 
   #if HAS_Y_AXIS
     y_startPosn = y_endPosn_prevBlock;
     float y_moveDist = current_block->steps.b / planner.settings.axis_steps_per_mm[Y_AXIS];
-    if (direction.y) y_moveDist *= -1.0f;
+    if (!direction.y) y_moveDist *= -1.0f;
     y_Ratio = y_moveDist * oneOverLength;
   #endif
 
   #if HAS_Z_AXIS
     z_startPosn = z_endPosn_prevBlock;
     float z_moveDist = current_block->steps.c / planner.settings.axis_steps_per_mm[Z_AXIS];
-    if (direction.z) z_moveDist *= -1.0f;
+    if (!direction.z) z_moveDist *= -1.0f;
     z_Ratio = z_moveDist * oneOverLength;
   #endif
 
   #if HAS_EXTRUDERS
     e_startPosn = e_endPosn_prevBlock;
     float extrusion = current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)];
-    if (direction.e) extrusion *= -1.0f;
+    if (!direction.e) extrusion *= -1.0f;
     e_Ratio = extrusion * oneOverLength;
   #endif
 
@@ -568,31 +571,31 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   // One less than (Accel + Coasting + Decel) datapoints
   max_intervals = N1 + N2 + N3 - 1U;
 
-  TERN_(HAS_X_AXIS, x_endPosn_prevBlock += x_moveDist);
-  TERN_(HAS_Y_AXIS, y_endPosn_prevBlock += y_moveDist);
-  TERN_(HAS_Z_AXIS, z_endPosn_prevBlock += z_moveDist);
+  TERN_(HAS_X_AXIS,    x_endPosn_prevBlock += x_moveDist);
+  TERN_(HAS_Y_AXIS,    y_endPosn_prevBlock += y_moveDist);
+  TERN_(HAS_Z_AXIS,    z_endPosn_prevBlock += z_moveDist);
   TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock += extrusion);
 }
 
 // Generate data points of the trajectory.
 void FxdTiCtrl::makeVector() {
-  float accel_k = 0.0f;                              // (mm/s^2) Acceleration K factor
-  float tau = (makeVector_idx + 1) * (FTM_TS); // (s) Time since start of block
-  float dist = 0.0f;                                 // (mm) Distance traveled
+  float accel_k = 0.0f;                                   // (mm/s^2) Acceleration K factor
+  float tau = (makeVector_idx + 1) * (FTM_TS);            // (s) Time since start of block
+  float dist = 0.0f;                                      // (mm) Distance traveled
 
   if (makeVector_idx < N1) {
     // Acceleration phase
-    dist = (f_s * tau) + (0.5f * accel_P * sq(tau)); // (mm) Distance traveled for acceleration phase
-    accel_k = accel_P;                               // (mm/s^2) Acceleration K factor from Accel phase
+    dist = (f_s * tau) + (0.5f * accel_P * sq(tau));      // (mm) Distance traveled for acceleration phase
+    accel_k = accel_P;                                    // (mm/s^2) Acceleration K factor from Accel phase
   }
   else if (makeVector_idx >= N1 && makeVector_idx < (N1 + N2)) {
     // Coasting phase
-    dist = s_1e + F_P * (tau - N1 * (FTM_TS)); // (mm) Distance traveled for coasting phase
+    dist = s_1e + F_P * (tau - N1 * (FTM_TS));            // (mm) Distance traveled for coasting phase
     //accel_k = 0.0f;
   }
   else {
     // Deceleration phase
-    const float tau_ = tau - (N1 + N2) * (FTM_TS);  // (s) Time since start of decel phase
+    const float tau_ = tau - (N1 + N2) * (FTM_TS);        // (s) Time since start of decel phase
     dist = s_2e + F_P * tau_ + 0.5f * decel_P * sq(tau_); // (mm) Distance traveled for deceleration phase
     accel_k = decel_P;                                    // (mm/s^2) Acceleration K factor from Decel phase
   }
@@ -614,7 +617,7 @@ void FxdTiCtrl::makeVector() {
     }
     else {
       ed[makeVector_batchIdx] = new_raw_z1;
-      // Alternatively: coordArray_e[makeVector_batchIdx] = e_startDist + extrusion / (N1 + N2 + N3);
+      // Alternatively: ed[makeVector_batchIdx] = e_startPosn + (e_Ratio * dist) / (N1 + N2 + N3);
     }
   #endif
 

commit 70efb515b16a9c8b5ebd0dae7348a0194841c4e3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 8 05:27:55 2023 -0500

    üßë‚Äçüíª PI => M_PI

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index bc6ba8d3e3..97dae881f8 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -288,7 +288,7 @@ void FxdTiCtrl::loop() {
   // To be called on init or mode or zeta change.
   void FxdTiCtrl::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
 
-    const float K = exp( -zeta * PI / sqrt(1.0f - sq(zeta)) ),
+    const float K = exp( -zeta * M_PI / sqrt(1.0f - sq(zeta)) ),
                 K2 = sq(K);
 
     switch (cfg_mode) {

commit af4ba2b1ced98066b89dde7636b052b075f96621
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 17:42:56 2023 -0500

    üêõ Minor Fixed-Time Motion patches

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index 2fe3802529..bc6ba8d3e3 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -211,9 +211,6 @@ void FxdTiCtrl::loop() {
 
   if (!cfg_mode) return;
 
-  static bool initd = false;
-  if (!initd) { init(); initd = true; }
-
   // Handle block abort with the following sequence:
   // 1. Zero out commands in stepper ISR.
   // 2. Drain the motion buffer, stop processing until they are emptied.

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    üßë‚Äçüíª Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
index dfef961c79..2fe3802529 100644
--- a/Marlin/src/module/ft_motion.cpp
+++ b/Marlin/src/module/ft_motion.cpp
@@ -484,33 +484,33 @@ void FxdTiCtrl::loadBlockData(block_t * const current_block) {
   const float totalLength = current_block->millimeters,
               oneOverLength = 1.0f / totalLength;
 
-  const axis_bits_t direction = current_block->direction_bits;
+  const AxisBits direction = current_block->direction_bits;
 
   #if HAS_X_AXIS
     x_startPosn = x_endPosn_prevBlock;
     float x_moveDist = current_block->steps.a / planner.settings.axis_steps_per_mm[X_AXIS];
-    if (TEST(direction, X_AXIS)) x_moveDist *= -1.0f;
+    if (direction.x) x_moveDist *= -1.0f;
     x_Ratio = x_moveDist * oneOverLength;
   #endif
 
   #if HAS_Y_AXIS
     y_startPosn = y_endPosn_prevBlock;
     float y_moveDist = current_block->steps.b / planner.settings.axis_steps_per_mm[Y_AXIS];
-    if (TEST(direction, Y_AXIS)) y_moveDist *= -1.0f;
+    if (direction.y) y_moveDist *= -1.0f;
     y_Ratio = y_moveDist * oneOverLength;
   #endif
 
   #if HAS_Z_AXIS
     z_startPosn = z_endPosn_prevBlock;
     float z_moveDist = current_block->steps.c / planner.settings.axis_steps_per_mm[Z_AXIS];
-    if (TEST(direction, Z_AXIS)) z_moveDist *= -1.0f;
+    if (direction.z) z_moveDist *= -1.0f;
     z_Ratio = z_moveDist * oneOverLength;
   #endif
 
   #if HAS_EXTRUDERS
     e_startPosn = e_endPosn_prevBlock;
     float extrusion = current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)];
-    if (TEST(direction, E_AXIS_N(current_block->extruder))) extrusion *= -1.0f;
+    if (direction.e) extrusion *= -1.0f;
     e_Ratio = extrusion * oneOverLength;
   #endif
 

commit c37fa3cc9097a9aa7fad5f168e335caabf23278e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 21:18:37 2023 -0500

    ‚ú® Fixed-Time Motion with Input Shaping by Ulendo (#25394)
    
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/ft_motion.cpp b/Marlin/src/module/ft_motion.cpp
new file mode 100644
index 0000000000..dfef961c79
--- /dev/null
+++ b/Marlin/src/module/ft_motion.cpp
@@ -0,0 +1,924 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2023 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#if ENABLED(FT_MOTION)
+
+#include "ft_motion.h"
+#include "stepper.h" // Access stepper block queue function and abort status.
+
+FxdTiCtrl fxdTiCtrl;
+
+//-----------------------------------------------------------------//
+// Variables.
+//-----------------------------------------------------------------//
+
+// Public variables.
+ftMotionMode_t FxdTiCtrl::cfg_mode = FTM_DEFAULT_MODE;                // Mode / active compensation mode configuration.
+
+#if HAS_EXTRUDERS
+  bool FxdTiCtrl::cfg_linearAdvEna = FTM_LINEAR_ADV_DEFAULT_ENA;      // Linear advance enable configuration.
+  float FxdTiCtrl::cfg_linearAdvK = FTM_LINEAR_ADV_DEFAULT_K;         // Linear advance gain.
+#endif
+
+dynFreqMode_t FxdTiCtrl::cfg_dynFreqMode = FTM_DEFAULT_DYNFREQ_MODE;  // Dynamic frequency mode configuration.
+#if !HAS_Z_AXIS
+  static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_Z_BASED, "dynFreqMode_Z_BASED requires a Z axis.");
+#endif
+#if !(HAS_X_AXIS && HAS_EXTRUDERS)
+  static_assert(FTM_DEFAULT_DYNFREQ_MODE != dynFreqMode_MASS_BASED, "dynFreqMode_MASS_BASED requires an X axis and an extruder.");
+#endif
+
+#if HAS_X_AXIS
+  float FxdTiCtrl::cfg_baseFreq[] = {  FTM_SHAPING_DEFAULT_X_FREQ     // Base frequency. [Hz]
+                    OPTARG(HAS_Y_AXIS, FTM_SHAPING_DEFAULT_Y_FREQ) };
+  float FxdTiCtrl::cfg_dynFreqK[] = { 0.0f OPTARG(HAS_Y_AXIS, 0.0f) };      // Scaling / gain for dynamic frequency. [Hz/mm] or [Hz/g]
+#endif
+
+ft_command_t FxdTiCtrl::stepperCmdBuff[FTM_STEPPERCMD_BUFF_SIZE] = {0U};                // Buffer of stepper commands.
+hal_timer_t FxdTiCtrl::stepperCmdBuff_StepRelativeTi[FTM_STEPPERCMD_BUFF_SIZE] = {0U};  // Buffer of the stepper command timing.
+uint8_t FxdTiCtrl::stepperCmdBuff_ApplyDir[FTM_STEPPERCMD_DIR_SIZE] = {0U};             // Buffer of whether DIR needs to be updated.
+uint32_t FxdTiCtrl::stepperCmdBuff_produceIdx = 0,  // Index of next stepper command write to the buffer.
+         FxdTiCtrl::stepperCmdBuff_consumeIdx = 0;  // Index of next stepper command read from the buffer.
+
+bool FxdTiCtrl::sts_stepperBusy = false;          // The stepper buffer has items and is in use.
+
+// Private variables.
+// NOTE: These are sized for Ulendo FBS use.
+#if HAS_X_AXIS
+  float FxdTiCtrl::xd[2 * (FTM_BATCH_SIZE)],  // = {0.0f} Storage for fixed-time-based trajectory.
+        FxdTiCtrl::xm[FTM_BATCH_SIZE];        // = {0.0f} Storage for modified fixed-time-based trajectory.
+#endif
+#if HAS_Y_AXIS
+  float FxdTiCtrl::yd[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::ym[FTM_BATCH_SIZE];
+#endif
+#if HAS_Z_AXIS
+  float FxdTiCtrl::zd[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::zm[FTM_BATCH_SIZE];
+#endif
+#if HAS_EXTRUDERS
+  float FxdTiCtrl::ed[2 * (FTM_BATCH_SIZE)], FxdTiCtrl::em[FTM_BATCH_SIZE];
+#endif
+
+block_t* FxdTiCtrl::current_block_cpy = nullptr; // Pointer to current block being processed.
+bool FxdTiCtrl::blockProcRdy = false,           // Indicates a block is ready to be processed.
+     FxdTiCtrl::blockProcRdy_z1 = false,        // Storage for the previous indicator.
+     FxdTiCtrl::blockProcDn = false;            // Indicates current block is done being processed.
+bool FxdTiCtrl::batchRdy = false;               // Indicates a batch of the fixed time trajectory
+                                                //  has been generated, is now available in the upper -
+                                                //  half of xd, yd, zd, ed vectors, and is ready to be
+                                                //  post processed, if applicable, then interpolated.
+bool FxdTiCtrl::batchRdyForInterp = false;      // Indicates the batch is done being post processed,
+                                                //  if applicable, and is ready to be converted to step commands.
+bool FxdTiCtrl::runoutEna = false;              // True if runout of the block hasn't been done and is allowed.
+
+// Trapezoid data variables.
+#if HAS_X_AXIS
+  float FxdTiCtrl::x_startPosn,                 // (mm) Start position of block
+        FxdTiCtrl::x_endPosn_prevBlock = 0.0f,  // (mm) Start position of block
+        FxdTiCtrl::x_Ratio;                     // (ratio) Axis move ratio of block
+#endif
+#if HAS_Y_AXIS
+  float FxdTiCtrl::y_startPosn,
+        FxdTiCtrl::y_endPosn_prevBlock = 0.0f,
+        FxdTiCtrl::y_Ratio;
+#endif
+#if HAS_Z_AXIS
+  float FxdTiCtrl::z_startPosn,
+        FxdTiCtrl::z_endPosn_prevBlock = 0.0f,
+        FxdTiCtrl::z_Ratio;
+#endif
+#if HAS_EXTRUDERS
+  float FxdTiCtrl::e_startPosn,
+        FxdTiCtrl::e_endPosn_prevBlock = 0.0f,
+        FxdTiCtrl::e_Ratio;
+#endif
+float FxdTiCtrl::accel_P,                       // Acceleration prime of block. [mm/sec/sec]
+      FxdTiCtrl::decel_P,                       // Deceleration prime of block. [mm/sec/sec]
+      FxdTiCtrl::F_P,                           // Feedrate prime of block. [mm/sec]
+      FxdTiCtrl::f_s,                           // Starting feedrate of block. [mm/sec]
+      FxdTiCtrl::s_1e,                          // Position after acceleration phase of block.
+      FxdTiCtrl::s_2e;                          // Position after acceleration and coasting phase of block.
+
+uint32_t FxdTiCtrl::N1,                         // Number of data points in the acceleration phase.
+         FxdTiCtrl::N2,                         // Number of data points in the coasting phase.
+         FxdTiCtrl::N3;                         // Number of data points in the deceleration phase.
+
+uint32_t FxdTiCtrl::max_intervals;              // Total number of data points that will be generated from block.
+
+// Make vector variables.
+uint32_t FxdTiCtrl::makeVector_idx = 0,                     // Index of fixed time trajectory generation of the overall block.
+         FxdTiCtrl::makeVector_idx_z1 = 0,                  // Storage for the previously calculated index above.
+         FxdTiCtrl::makeVector_batchIdx = FTM_BATCH_SIZE;   // Index of fixed time trajectory generation within the batch.
+
+// Interpolation variables.
+#if HAS_X_AXIS
+  int32_t FxdTiCtrl::x_steps = 0;                               // Step count accumulator.
+  stepDirState_t FxdTiCtrl::x_dirState = stepDirState_NOT_SET;  // Memory of the currently set step direction of the axis.
+#endif
+#if HAS_Y_AXIS
+  int32_t FxdTiCtrl::y_steps = 0;
+  stepDirState_t FxdTiCtrl::y_dirState = stepDirState_NOT_SET;
+#endif
+#if HAS_Z_AXIS
+  int32_t FxdTiCtrl::z_steps = 0;
+  stepDirState_t FxdTiCtrl::z_dirState = stepDirState_NOT_SET;
+#endif
+#if HAS_EXTRUDERS
+  int32_t FxdTiCtrl::e_steps = 0;
+  stepDirState_t FxdTiCtrl::e_dirState = stepDirState_NOT_SET;
+#endif
+
+uint32_t FxdTiCtrl::interpIdx = 0,                    // Index of current data point being interpolated.
+         FxdTiCtrl::interpIdx_z1 = 0;                 // Storage for the previously calculated index above.
+hal_timer_t FxdTiCtrl::nextStepTicks = FTM_MIN_TICKS; // Accumulator for the next step time (in ticks).
+
+// Shaping variables.
+#if HAS_X_AXIS
+  uint32_t FxdTiCtrl::xy_zi_idx = 0,                  // Index of storage in the data point delay vectors.
+           FxdTiCtrl::xy_max_i = 0;                   // Vector length for the selected shaper.
+  float FxdTiCtrl::xd_zi[FTM_ZMAX] = { 0.0f };        // Data point delay vector.
+  float FxdTiCtrl::x_Ai[5];                           // Shaping gain vector.
+  uint32_t FxdTiCtrl::x_Ni[5];                        // Shaping time index vector.
+#endif
+#if HAS_Y_AXIS
+  float FxdTiCtrl::yd_zi[FTM_ZMAX] = { 0.0f };
+  float FxdTiCtrl::y_Ai[5];
+  uint32_t FxdTiCtrl::y_Ni[5];
+#endif
+
+#if HAS_EXTRUDERS
+  // Linear advance variables.
+  float FxdTiCtrl::e_raw_z1 = 0.0f;             // (ms) Unit delay of raw extruder position.
+  float FxdTiCtrl::e_advanced_z1 = 0.0f;        // (ms) Unit delay of advanced extruder position.
+#endif
+
+//-----------------------------------------------------------------//
+// Function definitions.
+//-----------------------------------------------------------------//
+
+// Public functions.
+
+// Sets controller states to begin processing a block.
+void FxdTiCtrl::startBlockProc(block_t * const current_block) {
+  current_block_cpy = current_block;
+  blockProcRdy = true;
+  blockProcDn = false;
+  runoutEna = true;
+}
+
+// Moves any free data points to the stepper buffer even if a full batch isn't ready.
+void FxdTiCtrl::runoutBlock() {
+
+  if (runoutEna && !batchRdy) {   // If the window is full already (block intervals was a multiple of
+                                  // the batch size), or runout is not enabled, no runout is needed.
+    // Fill out the trajectory window with the last position calculated.
+    if (makeVector_batchIdx > FTM_BATCH_SIZE) {
+      for (uint32_t i = makeVector_batchIdx; i < 2 * (FTM_BATCH_SIZE); i++) {
+                             xd[i] = xd[makeVector_batchIdx - 1];
+        TERN_(HAS_Y_AXIS,    yd[i] = yd[makeVector_batchIdx - 1]);
+        TERN_(HAS_Y_AXIS,    zd[i] = zd[makeVector_batchIdx - 1]);
+        TERN_(HAS_EXTRUDERS, ed[i] = ed[makeVector_batchIdx - 1]);
+      }
+    }
+    makeVector_batchIdx = FTM_BATCH_SIZE;
+    batchRdy = true;
+  }
+  runoutEna = false;
+}
+
+// Controller main, to be invoked from non-isr task.
+void FxdTiCtrl::loop() {
+
+  if (!cfg_mode) return;
+
+  static bool initd = false;
+  if (!initd) { init(); initd = true; }
+
+  // Handle block abort with the following sequence:
+  // 1. Zero out commands in stepper ISR.
+  // 2. Drain the motion buffer, stop processing until they are emptied.
+  // 3. Reset all the states / memory.
+  // 4. Signal ready for new block.
+  if (stepper.abort_current_block) {
+    if (sts_stepperBusy) return;          // Wait until motion buffers are emptied
+    reset();
+    blockProcDn = true;                   // Set queueing to look for next block.
+    runoutEna = false;                    // Disabling running out this block, since we want to halt the motion.
+    stepper.abort_current_block = false;  // Abort finished.
+  }
+
+  // Planner processing and block conversion.
+  if (!blockProcRdy) stepper.fxdTiCtrl_BlockQueueUpdate();
+
+  if (blockProcRdy) {
+    if (!blockProcRdy_z1) loadBlockData(current_block_cpy); // One-shot.
+    while (!blockProcDn && !batchRdy && (makeVector_idx - makeVector_idx_z1 < (FTM_POINTS_PER_LOOP)))
+      makeVector();
+  }
+
+  // FBS / post processing.
+  if (batchRdy && !batchRdyForInterp) {
+
+    // Call Ulendo FBS here.
+
+    memcpy(xm, &xd[FTM_BATCH_SIZE], sizeof(xm));
+    TERN_(HAS_Y_AXIS, memcpy(ym, &yd[FTM_BATCH_SIZE], sizeof(ym)));
+
+    // Done compensating ...
+
+    // Copy the uncompensated vectors.
+    TERN_(HAS_Z_AXIS,    memcpy(zm, &zd[FTM_BATCH_SIZE], sizeof(zm)));
+    TERN_(HAS_EXTRUDERS, memcpy(em, &ed[FTM_BATCH_SIZE], sizeof(em)));
+
+    // Shift the time series back in the window.
+    memcpy(xd, &xd[FTM_BATCH_SIZE], sizeof(xd) / 2);
+    TERN_(HAS_Y_AXIS, memcpy(yd, &yd[FTM_BATCH_SIZE], sizeof(yd) / 2));
+    // Disabled by comment as these are uncompensated, the lower half is not used.
+    //TERN_(HAS_Z_AXIS,    memcpy(zd, &zd[FTM_BATCH_SIZE], (sizeof(zd) / 2)));
+    //TERN_(HAS_EXTRUDERS, memcpy(ed, &ed[FTM_BATCH_SIZE], (sizeof(ed) / 2)));
+
+    // ... data is ready in xm, ym, zm, em.
+    batchRdyForInterp = true;
+
+    batchRdy = false; // Clear so that makeVector() may resume generating points.
+
+  } // if (batchRdy && !batchRdyForInterp)
+
+  // Interpolation.
+  while ( batchRdyForInterp
+          && ( stepperCmdBuffItems() < ((FTM_STEPPERCMD_BUFF_SIZE) - (FTM_STEPS_PER_UNIT_TIME)) )
+          && ( (interpIdx - interpIdx_z1) < (FTM_STEPS_PER_LOOP) )
+  ) {
+    convertToSteps(interpIdx);
+
+    if (++interpIdx == FTM_BATCH_SIZE) {
+      batchRdyForInterp = false;
+      interpIdx = 0;
+    }
+  }
+
+  // Report busy status to planner.
+  planner.fxdTiCtrl_busy = (sts_stepperBusy || ((!blockProcDn && blockProcRdy) || batchRdy || batchRdyForInterp || runoutEna));
+
+  blockProcRdy_z1 = blockProcRdy;
+  makeVector_idx_z1 = makeVector_idx;
+  interpIdx_z1 = interpIdx;
+}
+
+#if HAS_X_AXIS
+
+  // Refresh the gains used by shaping functions.
+  // To be called on init or mode or zeta change.
+  void FxdTiCtrl::updateShapingA(const_float_t zeta/*=FTM_SHAPING_ZETA*/, const_float_t vtol/*=FTM_SHAPING_V_TOL*/) {
+
+    const float K = exp( -zeta * PI / sqrt(1.0f - sq(zeta)) ),
+                K2 = sq(K);
+
+    switch (cfg_mode) {
+
+      case ftMotionMode_ZV:
+        xy_max_i = 1U;
+        x_Ai[0] = 1.0f / (1.0f + K);
+        x_Ai[1] = x_Ai[0] * K;
+        break;
+
+      case ftMotionMode_ZVD:
+        xy_max_i = 2U;
+        x_Ai[0] = 1.0f / ( 1.0f + 2.0f * K + K2 );
+        x_Ai[1] = x_Ai[0] * 2.0f * K;
+        x_Ai[2] = x_Ai[0] * K2;
+        break;
+
+      case ftMotionMode_EI: {
+        xy_max_i = 2U;
+        x_Ai[0] = 0.25f * (1.0f + vtol);
+        x_Ai[1] = 0.50f * (1.0f - vtol) * K;
+        x_Ai[2] = x_Ai[0] * K2;
+        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2]);
+        for (uint32_t i = 0U; i < 3U; i++) { x_Ai[i] *= A_adj; }
+      } break;
+
+      case ftMotionMode_2HEI: {
+        xy_max_i = 3U;
+        const float vtol2 = sq(vtol);
+        const float X = pow(vtol2 * (sqrt(1.0f - vtol2) + 1.0f), 1.0f / 3.0f);
+        x_Ai[0] = ( 3.0f * sq(X) + 2.0f * X + 3.0f * vtol2 ) / (16.0f * X);
+        x_Ai[1] = ( 0.5f - x_Ai[0] ) * K;
+        x_Ai[2] = x_Ai[1] * K;
+        x_Ai[3] = x_Ai[0] * cu(K);
+        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2] + x_Ai[3]);
+        for (uint32_t i = 0U; i < 4U; i++) { x_Ai[i] *= A_adj; }
+      } break;
+
+      case ftMotionMode_3HEI: {
+        xy_max_i = 4U;
+        x_Ai[0] = 0.0625f * ( 1.0f + 3.0f * vtol + 2.0f * sqrt( 2.0f * ( vtol + 1.0f ) * vtol ) );
+        x_Ai[1] = 0.25f * ( 1.0f - vtol ) * K;
+        x_Ai[2] = ( 0.5f * ( 1.0f + vtol ) - 2.0f * x_Ai[0] ) * K2;
+        x_Ai[3] = x_Ai[1] * K2;
+        x_Ai[4] = x_Ai[0] * sq(K2);
+        const float A_adj = 1.0f / (x_Ai[0] + x_Ai[1] + x_Ai[2] + x_Ai[3] + x_Ai[4]);
+        for (uint32_t i = 0U; i < 5U; i++) { x_Ai[i] *= A_adj; }
+      } break;
+
+      case ftMotionMode_MZV: {
+        xy_max_i = 2U;
+        const float B = 1.4142135623730950488016887242097f * K;
+        x_Ai[0] = 1.0f / (1.0f + B + K2);
+        x_Ai[1] = x_Ai[0] * B;
+        x_Ai[2] = x_Ai[0] * K2;
+      } break;
+
+      default:
+        for (uint32_t i = 0U; i < 5U; i++) x_Ai[i] = 0.0f;
+        xy_max_i = 0;
+    }
+    #if HAS_Y_AXIS
+      memcpy(y_Ai, x_Ai, sizeof(x_Ai)); // For now, zeta and vtol are shared across x and y.
+    #endif
+  }
+
+  // Refresh the indices used by shaping functions.
+  // To be called when frequencies change.
+  void FxdTiCtrl::updateShapingN(const_float_t xf OPTARG(HAS_Y_AXIS, const_float_t yf), const_float_t zeta/*=FTM_SHAPING_ZETA*/) {
+
+    // Protections omitted for DBZ and for index exceeding array length.
+
+    const float df = sqrt(1.0f - sq(zeta));
+
+    switch (cfg_mode) {
+      case ftMotionMode_ZV:
+        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
+        #if HAS_Y_AXIS
+          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
+        #endif
+        break;
+      case ftMotionMode_ZVD:
+      case ftMotionMode_EI:
+        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
+        x_Ni[2] = 2 * x_Ni[1];
+        #if HAS_Y_AXIS
+          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
+          y_Ni[2] = 2 * y_Ni[1];
+        #endif
+        break;
+      case ftMotionMode_2HEI:
+        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
+        x_Ni[2] = 2 * x_Ni[1];
+        x_Ni[3] = 3 * x_Ni[1];
+        #if HAS_Y_AXIS
+          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
+          y_Ni[2] = 2 * y_Ni[1];
+          y_Ni[3] = 3 * y_Ni[1];
+        #endif
+        break;
+      case ftMotionMode_3HEI:
+        x_Ni[1] = round((0.5f / xf / df) * (FTM_FS));
+        x_Ni[2] = 2 * x_Ni[1];
+        x_Ni[3] = 3 * x_Ni[1];
+        x_Ni[4] = 4 * x_Ni[1];
+        #if HAS_Y_AXIS
+          y_Ni[1] = round((0.5f / yf / df) * (FTM_FS));
+          y_Ni[2] = 2 * y_Ni[1];
+          y_Ni[3] = 3 * y_Ni[1];
+          y_Ni[4] = 4 * y_Ni[1];
+        #endif
+        break;
+      case ftMotionMode_MZV:
+        x_Ni[1] = round((0.375f / xf / df) * (FTM_FS));
+        x_Ni[2] = 2 * x_Ni[1];
+        #if HAS_Y_AXIS
+          y_Ni[1] = round((0.375f / yf / df) * (FTM_FS));
+          y_Ni[2] = 2 * y_Ni[1];
+        #endif
+        break;
+      default:
+        for (uint32_t i = 0U; i < 5U; i++) { x_Ni[i] = 0; TERN_(HAS_Y_AXIS, y_Ni[i] = 0); }
+    }
+  }
+
+#endif // HAS_X_AXIS
+
+// Reset all trajectory processing variables.
+void FxdTiCtrl::reset() {
+
+  stepperCmdBuff_produceIdx = stepperCmdBuff_consumeIdx = 0;
+
+  for (uint32_t i = 0U; i < (FTM_BATCH_SIZE); i++) { // Reset trajectory history
+    TERN_(HAS_X_AXIS, xd[i] = 0.0f);
+    TERN_(HAS_Y_AXIS, yd[i] = 0.0f);
+    TERN_(HAS_Z_AXIS, zd[i] = 0.0f);
+    TERN_(HAS_EXTRUDERS, ed[i] = 0.0f);
+  }
+
+  blockProcRdy = blockProcRdy_z1 = blockProcDn = false;
+  batchRdy = batchRdyForInterp = false;
+  runoutEna = false;
+
+  TERN_(HAS_X_AXIS, x_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_Y_AXIS, y_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_Z_AXIS, z_endPosn_prevBlock = 0.0f);
+  TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock = 0.0f);
+
+  makeVector_idx = makeVector_idx_z1 = 0;
+  makeVector_batchIdx = FTM_BATCH_SIZE;
+
+  TERN_(HAS_X_AXIS, x_steps = 0);
+  TERN_(HAS_Y_AXIS, y_steps = 0);
+  TERN_(HAS_Z_AXIS, z_steps = 0);
+  TERN_(HAS_EXTRUDERS, e_steps = 0);
+  interpIdx = interpIdx_z1 = 0;
+  TERN_(HAS_X_AXIS, x_dirState = stepDirState_NOT_SET);
+  TERN_(HAS_Y_AXIS, y_dirState = stepDirState_NOT_SET);
+  TERN_(HAS_Z_AXIS, z_dirState = stepDirState_NOT_SET);
+  TERN_(HAS_EXTRUDERS, e_dirState = stepDirState_NOT_SET);
+  nextStepTicks = FTM_MIN_TICKS;
+
+  #if HAS_X_AXIS
+    for (uint32_t i = 0U; i < (FTM_ZMAX); i++) { xd_zi[i] = 0.0f; TERN_(HAS_Y_AXIS, yd_zi[i] = 0.0f); }
+    xy_zi_idx = 0;
+  #endif
+
+  TERN_(HAS_EXTRUDERS, e_raw_z1 = e_advanced_z1 = 0.0f);
+}
+
+// Private functions.
+// Auxiliary function to get number of step commands in the buffer.
+uint32_t FxdTiCtrl::stepperCmdBuffItems() {
+  const uint32_t udiff = stepperCmdBuff_produceIdx - stepperCmdBuff_consumeIdx;
+  return stepperCmdBuff_produceIdx < stepperCmdBuff_consumeIdx ? (FTM_STEPPERCMD_BUFF_SIZE) + udiff : udiff;
+}
+
+// Initializes storage variables before startup.
+void FxdTiCtrl::init() {
+  #if HAS_X_AXIS
+    updateShapingN(cfg_baseFreq[0] OPTARG(HAS_Y_AXIS, cfg_baseFreq[1]));
+    updateShapingA(FTM_SHAPING_ZETA, FTM_SHAPING_V_TOL);
+  #endif
+  reset(); // Precautionary.
+}
+
+// Loads / converts block data from planner to fixed-time control variables.
+void FxdTiCtrl::loadBlockData(block_t * const current_block) {
+
+  const float totalLength = current_block->millimeters,
+              oneOverLength = 1.0f / totalLength;
+
+  const axis_bits_t direction = current_block->direction_bits;
+
+  #if HAS_X_AXIS
+    x_startPosn = x_endPosn_prevBlock;
+    float x_moveDist = current_block->steps.a / planner.settings.axis_steps_per_mm[X_AXIS];
+    if (TEST(direction, X_AXIS)) x_moveDist *= -1.0f;
+    x_Ratio = x_moveDist * oneOverLength;
+  #endif
+
+  #if HAS_Y_AXIS
+    y_startPosn = y_endPosn_prevBlock;
+    float y_moveDist = current_block->steps.b / planner.settings.axis_steps_per_mm[Y_AXIS];
+    if (TEST(direction, Y_AXIS)) y_moveDist *= -1.0f;
+    y_Ratio = y_moveDist * oneOverLength;
+  #endif
+
+  #if HAS_Z_AXIS
+    z_startPosn = z_endPosn_prevBlock;
+    float z_moveDist = current_block->steps.c / planner.settings.axis_steps_per_mm[Z_AXIS];
+    if (TEST(direction, Z_AXIS)) z_moveDist *= -1.0f;
+    z_Ratio = z_moveDist * oneOverLength;
+  #endif
+
+  #if HAS_EXTRUDERS
+    e_startPosn = e_endPosn_prevBlock;
+    float extrusion = current_block->steps.e / planner.settings.axis_steps_per_mm[E_AXIS_N(current_block->extruder)];
+    if (TEST(direction, E_AXIS_N(current_block->extruder))) extrusion *= -1.0f;
+    e_Ratio = extrusion * oneOverLength;
+  #endif
+
+  const float spm = totalLength / current_block->step_event_count;  // (steps/mm) Distance for each step
+              f_s = spm * current_block->initial_rate;  // (steps/s) Start feedrate
+  const float f_e = spm * current_block->final_rate;    // (steps/s) End feedrate
+
+  const float a = current_block->acceleration,          // (mm/s^2) Same magnitude for acceleration or deceleration
+              oneby2a = 1.0f / (2.0f * a),              // (s/mm) Time to accelerate or decelerate one mm (i.e., oneby2a * 2
+              oneby2d = -oneby2a;                       // (s/mm) Time to accelerate or decelerate one mm (i.e., oneby2a * 2
+  const float fsSqByTwoA = sq(f_s) * oneby2a,           // (mm) Distance to accelerate from start speed to nominal speed
+              feSqByTwoD = sq(f_e) * oneby2d;           // (mm) Distance to decelerate from nominal speed to end speed
+
+  float F_n = current_block->nominal_speed;             // (mm/s) Speed we hope to achieve, if possible
+  const float fdiff = feSqByTwoD - fsSqByTwoA,          // (mm) Coasting distance if nominal speed is reached
+              odiff = oneby2a - oneby2d,                // (i.e., oneby2a * 2) (mm/s) Change in speed for one second of acceleration
+              ldiff = totalLength - fdiff;              // (mm) Distance to travel if nominal speed is reached
+  float T2 = (1.0f / F_n) * (ldiff - odiff * sq(F_n));  // (s) Coasting duration after nominal speed reached
+  if (T2 < 0.0f)  {
+    T2 = 0.0f;
+    F_n = SQRT(ldiff / odiff);                          // Clip by intersection if nominal speed can't be reached.
+  }
+
+  const float T1 = (F_n - f_s) / a,                     // (s) Accel Time = difference in feedrate over acceleration
+              T3 = (F_n - f_e) / a;                     // (s) Decel Time = difference in feedrate over acceleration
+
+  N1 = ceil(T1 * (FTM_FS));                       // Accel datapoints based on Hz frequency
+  N2 = ceil(T2 * (FTM_FS));                       // Coast
+  N3 = ceil(T3 * (FTM_FS));                       // Decel
+
+  const float T1_P = N1 * (FTM_TS),               // (s) Accel datapoints x timestep resolution
+              T2_P = N2 * (FTM_TS),               // (s) Coast
+              T3_P = N3 * (FTM_TS);               // (s) Decel
+
+  // Calculate the reachable feedrate at the end of the accel phase
+  // totalLength is the total distance to travel in mm
+  // f_s is the starting feedrate in mm/s
+  // f_e is the ending feedrate in mm/s
+  // T1_P is the time spent accelerating in seconds
+  // T2_P is the time spent coasting in seconds
+  // T3_P is the time spent decelerating in seconds
+  // f_s * T1_P is the distance traveled during the accel phase
+  // f_e * T3_P is the distance traveled during the decel phase
+  //
+  F_P = (2.0f * totalLength - f_s * T1_P - f_e * T3_P) / (T1_P + 2.0f * T2_P + T3_P); // (mm/s) Feedrate at the end of the accel phase
+
+  // Calculate the acceleration and deceleration rates
+  accel_P = N1 ? ((F_P - f_s) / T1_P) : 0.0f;
+
+  decel_P = (f_e - F_P) / T3_P;
+
+  // Calculate the distance traveled during the accel phase
+  s_1e = f_s * T1_P + 0.5f * accel_P * sq(T1_P);
+
+  // Calculate the distance traveled during the decel phase
+  s_2e = s_1e + F_P * T2_P;
+
+  // One less than (Accel + Coasting + Decel) datapoints
+  max_intervals = N1 + N2 + N3 - 1U;
+
+  TERN_(HAS_X_AXIS, x_endPosn_prevBlock += x_moveDist);
+  TERN_(HAS_Y_AXIS, y_endPosn_prevBlock += y_moveDist);
+  TERN_(HAS_Z_AXIS, z_endPosn_prevBlock += z_moveDist);
+  TERN_(HAS_EXTRUDERS, e_endPosn_prevBlock += extrusion);
+}
+
+// Generate data points of the trajectory.
+void FxdTiCtrl::makeVector() {
+  float accel_k = 0.0f;                              // (mm/s^2) Acceleration K factor
+  float tau = (makeVector_idx + 1) * (FTM_TS); // (s) Time since start of block
+  float dist = 0.0f;                                 // (mm) Distance traveled
+
+  if (makeVector_idx < N1) {
+    // Acceleration phase
+    dist = (f_s * tau) + (0.5f * accel_P * sq(tau)); // (mm) Distance traveled for acceleration phase
+    accel_k = accel_P;                               // (mm/s^2) Acceleration K factor from Accel phase
+  }
+  else if (makeVector_idx >= N1 && makeVector_idx < (N1 + N2)) {
+    // Coasting phase
+    dist = s_1e + F_P * (tau - N1 * (FTM_TS)); // (mm) Distance traveled for coasting phase
+    //accel_k = 0.0f;
+  }
+  else {
+    // Deceleration phase
+    const float tau_ = tau - (N1 + N2) * (FTM_TS);  // (s) Time since start of decel phase
+    dist = s_2e + F_P * tau_ + 0.5f * decel_P * sq(tau_); // (mm) Distance traveled for deceleration phase
+    accel_k = decel_P;                                    // (mm/s^2) Acceleration K factor from Decel phase
+  }
+
+  TERN_(HAS_X_AXIS, xd[makeVector_batchIdx] = x_startPosn + x_Ratio * dist);  // (mm) X position for this datapoint
+  TERN_(HAS_Y_AXIS, yd[makeVector_batchIdx] = y_startPosn + y_Ratio * dist);  // (mm) Y
+  TERN_(HAS_Z_AXIS, zd[makeVector_batchIdx] = z_startPosn + z_Ratio * dist);  // (mm) Z
+
+  #if HAS_EXTRUDERS
+    const float new_raw_z1 = e_startPosn + e_Ratio * dist;
+    if (cfg_linearAdvEna) {
+      float dedt_adj = (new_raw_z1 - e_raw_z1) * (FTM_FS);
+      if (e_Ratio > 0.0f) dedt_adj += accel_k * cfg_linearAdvK;
+
+      e_advanced_z1 += dedt_adj * (FTM_TS);
+      ed[makeVector_batchIdx] = e_advanced_z1;
+
+      e_raw_z1 = new_raw_z1;
+    }
+    else {
+      ed[makeVector_batchIdx] = new_raw_z1;
+      // Alternatively: coordArray_e[makeVector_batchIdx] = e_startDist + extrusion / (N1 + N2 + N3);
+    }
+  #endif
+
+  // Update shaping parameters if needed.
+  #if HAS_Z_AXIS
+    static float zd_z1 = 0.0f;
+  #endif
+  switch (cfg_dynFreqMode) {
+
+    #if HAS_Z_AXIS
+      case dynFreqMode_Z_BASED:
+        if (zd[makeVector_batchIdx] != zd_z1) { // Only update if Z changed.
+          const float xf = cfg_baseFreq[0] + cfg_dynFreqK[0] * zd[makeVector_batchIdx],
+                      yf = cfg_baseFreq[1] + cfg_dynFreqK[1] * zd[makeVector_batchIdx];
+          updateShapingN(_MAX(xf, FTM_MIN_SHAPE_FREQ), _MAX(yf, FTM_MIN_SHAPE_FREQ));
+          zd_z1 = zd[makeVector_batchIdx];
+        }
+        break;
+    #endif
+
+    #if HAS_X_AXIS && HAS_EXTRUDERS
+      case dynFreqMode_MASS_BASED:
+        // Update constantly. The optimization done for Z value makes
+        // less sense for E, as E is expected to constantly change.
+        updateShapingN(      cfg_baseFreq[0] + cfg_dynFreqK[0] * ed[makeVector_batchIdx]
+          OPTARG(HAS_Y_AXIS, cfg_baseFreq[1] + cfg_dynFreqK[1] * ed[makeVector_batchIdx]) );
+        break;
+    #endif
+
+    default: break;
+  }
+
+  // Apply shaping if in mode.
+  #if HAS_X_AXIS
+    if (WITHIN(cfg_mode, 10U, 19U)) {
+      xd_zi[xy_zi_idx] = xd[makeVector_batchIdx];
+      xd[makeVector_batchIdx] *= x_Ai[0];
+      #if HAS_Y_AXIS
+        yd_zi[xy_zi_idx] = yd[makeVector_batchIdx];
+        yd[makeVector_batchIdx] *= y_Ai[0];
+      #endif
+      for (uint32_t i = 1U; i <= xy_max_i; i++) {
+        const uint32_t udiffx = xy_zi_idx - x_Ni[i];
+        xd[makeVector_batchIdx] += x_Ai[i] * xd_zi[x_Ni[i] > xy_zi_idx ? (FTM_ZMAX) + udiffx : udiffx];
+        #if HAS_Y_AXIS
+          const uint32_t udiffy = xy_zi_idx - y_Ni[i];
+          yd[makeVector_batchIdx] += y_Ai[i] * yd_zi[y_Ni[i] > xy_zi_idx ? (FTM_ZMAX) + udiffy : udiffy];
+        #endif
+      }
+      if (++xy_zi_idx == (FTM_ZMAX)) xy_zi_idx = 0;
+    }
+  #endif
+
+  // Filled up the queue with regular and shaped steps
+  if (++makeVector_batchIdx == 2 * (FTM_BATCH_SIZE)) {
+    makeVector_batchIdx = FTM_BATCH_SIZE;
+    batchRdy = true;
+  }
+
+  if (makeVector_idx == max_intervals) {
+    blockProcDn = true;
+    blockProcRdy = false;
+    makeVector_idx = 0;
+  }
+  else
+    makeVector_idx++;
+}
+
+// Interpolates single data point to stepper commands.
+void FxdTiCtrl::convertToSteps(const uint32_t idx) {
+  #if HAS_X_AXIS
+    int32_t x_err_P = 0;
+  #endif
+  #if HAS_Y_AXIS
+    int32_t y_err_P = 0;
+  #endif
+  #if HAS_Z_AXIS
+    int32_t z_err_P = 0;
+  #endif
+  #if HAS_EXTRUDERS
+    int32_t e_err_P = 0;
+  #endif
+
+  //#define STEPS_ROUNDING
+  #if ENABLED(STEPS_ROUNDING)
+    #if HAS_X_AXIS
+      const float x_steps_tar = xm[idx] * planner.settings.axis_steps_per_mm[X_AXIS] + (xm[idx] < 0.0f ? -0.5f : 0.5f); // May be eliminated if guaranteed positive.
+      const int32_t x_delta = int32_t(x_steps_tar) - x_steps;
+    #endif
+    #if HAS_Y_AXIS
+      const float y_steps_tar = ym[idx] * planner.settings.axis_steps_per_mm[Y_AXIS] + (ym[idx] < 0.0f ? -0.5f : 0.5f);
+      const int32_t y_delta = int32_t(y_steps_tar) - y_steps;
+    #endif
+    #if HAS_Z_AXIS
+      const float z_steps_tar = zm[idx] * planner.settings.axis_steps_per_mm[Z_AXIS] + (zm[idx] < 0.0f ? -0.5f : 0.5f);
+      const int32_t z_delta = int32_t(z_steps_tar) - z_steps;
+    #endif
+    #if HAS_EXTRUDERS
+      const float e_steps_tar = em[idx] * planner.settings.axis_steps_per_mm[E_AXIS] + (em[idx] < 0.0f ? -0.5f : 0.5f);
+      const int32_t e_delta = int32_t(e_steps_tar) - e_steps;
+    #endif
+  #else
+    #if HAS_X_AXIS
+      const int32_t x_delta = int32_t(xm[idx] * planner.settings.axis_steps_per_mm[X_AXIS]) - x_steps;
+    #endif
+    #if HAS_Y_AXIS
+      const int32_t y_delta = int32_t(ym[idx] * planner.settings.axis_steps_per_mm[Y_AXIS]) - y_steps;
+    #endif
+    #if HAS_Z_AXIS
+      const int32_t z_delta = int32_t(zm[idx] * planner.settings.axis_steps_per_mm[Z_AXIS]) - z_steps;
+    #endif
+    #if HAS_EXTRUDERS
+      const int32_t e_delta = int32_t(em[idx] * planner.settings.axis_steps_per_mm[E_AXIS]) - e_steps;
+    #endif
+  #endif
+
+  bool any_dirChange = (false
+    || TERN0(HAS_X_AXIS,    (x_delta > 0 && x_dirState != stepDirState_POS) || (x_delta < 0 && x_dirState != stepDirState_NEG))
+    || TERN0(HAS_Y_AXIS,    (y_delta > 0 && y_dirState != stepDirState_POS) || (y_delta < 0 && y_dirState != stepDirState_NEG))
+    || TERN0(HAS_Z_AXIS,    (z_delta > 0 && z_dirState != stepDirState_POS) || (z_delta < 0 && z_dirState != stepDirState_NEG))
+    || TERN0(HAS_EXTRUDERS, (e_delta > 0 && e_dirState != stepDirState_POS) || (e_delta < 0 && e_dirState != stepDirState_NEG))
+  );
+
+  for (uint32_t i = 0U; i < (FTM_STEPS_PER_UNIT_TIME); i++) {
+
+    // TODO: (?) Since the *delta variables will not change,
+    // the comparison may be done once before iterating at
+    // expense of storage and lines of code.
+
+    bool anyStep = false;
+
+    stepperCmdBuff[stepperCmdBuff_produceIdx] = 0;
+
+    // Commands are written in the format:
+    // |X_step|X_direction|Y_step|Y_direction|Z_step|Z_direction|E_step|E_direction|
+    #if HAS_X_AXIS
+      if (x_delta >= 0) {
+        if ((x_err_P + x_delta) < (FTM_CTS_COMPARE_VAL)) {
+          x_err_P += x_delta;
+        }
+        else {
+          x_steps++;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_X) | _BV(FT_BIT_STEP_X);
+          x_err_P += x_delta - (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+      else {
+        if ((x_err_P + x_delta) > -(FTM_CTS_COMPARE_VAL)) {
+          x_err_P += x_delta;
+        }
+        else {
+          x_steps--;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_X);
+          x_err_P += x_delta + (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+    #endif // HAS_X_AXIS
+
+    #if HAS_Y_AXIS
+      if (y_delta >= 0) {
+        if ((y_err_P + y_delta) < (FTM_CTS_COMPARE_VAL)) {
+          y_err_P += y_delta;
+        }
+        else {
+          y_steps++;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Y) | _BV(FT_BIT_STEP_Y);
+          y_err_P += y_delta - (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+      else {
+        if ((y_err_P + y_delta) > -(FTM_CTS_COMPARE_VAL)) {
+          y_err_P += y_delta;
+        }
+        else {
+          y_steps--;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_Y);
+          y_err_P += y_delta + (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+    #endif // HAS_Y_AXIS
+
+    #if HAS_Z_AXIS
+      if (z_delta >= 0) {
+        if ((z_err_P + z_delta) < (FTM_CTS_COMPARE_VAL)) {
+          z_err_P += z_delta;
+        }
+        else {
+          z_steps++;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Z) | _BV(FT_BIT_STEP_Z);
+          z_err_P += z_delta - (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+      else {
+        if ((z_err_P + z_delta) > -(FTM_CTS_COMPARE_VAL)) {
+          z_err_P += z_delta;
+        }
+        else {
+          z_steps--;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_Z);
+          z_err_P += z_delta + (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+    #endif // HAS_Z_AXIS
+
+    #if HAS_EXTRUDERS
+      if (e_delta >= 0) {
+        if ((e_err_P + e_delta) < (FTM_CTS_COMPARE_VAL)) {
+          e_err_P += e_delta;
+        }
+        else {
+          e_steps++;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_E) | _BV(FT_BIT_STEP_E);
+          e_err_P += e_delta - (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+      else {
+        if ((e_err_P + e_delta) > -(FTM_CTS_COMPARE_VAL)) {
+          e_err_P += e_delta;
+        }
+        else {
+          e_steps--;
+          stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_STEP_E);
+          e_err_P += e_delta + (FTM_STEPS_PER_UNIT_TIME);
+          anyStep = true;
+        }
+      }
+    #endif // HAS_EXTRUDERS
+
+    if (!anyStep) {
+      nextStepTicks += (FTM_MIN_TICKS);
+    }
+    else {
+      stepperCmdBuff_StepRelativeTi[stepperCmdBuff_produceIdx] = nextStepTicks;
+
+      const uint8_t dir_index = stepperCmdBuff_produceIdx >> 3,
+                    dir_bit = stepperCmdBuff_produceIdx & 0x7;
+      if (any_dirChange) {
+        SBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
+        #if HAS_X_AXIS
+          if (x_delta > 0) {
+            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_X);
+            x_dirState = stepDirState_POS;
+          }
+          else {
+            x_dirState = stepDirState_NEG;
+          }
+        #endif
+
+        #if HAS_Y_AXIS
+          if (y_delta > 0) {
+            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Y);
+            y_dirState = stepDirState_POS;
+          }
+          else {
+            y_dirState = stepDirState_NEG;
+          }
+        #endif
+
+        #if HAS_Z_AXIS
+          if (z_delta > 0) {
+            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_Z);
+            z_dirState = stepDirState_POS;
+          }
+          else {
+            z_dirState = stepDirState_NEG;
+          }
+        #endif
+
+        #if HAS_EXTRUDERS
+          if (e_delta > 0) {
+            stepperCmdBuff[stepperCmdBuff_produceIdx] |= _BV(FT_BIT_DIR_E);
+            e_dirState = stepDirState_POS;
+          }
+          else {
+            e_dirState = stepDirState_NEG;
+          }
+        #endif
+
+        any_dirChange = false;
+      }
+      else { // ...no direction change.
+        CBI(stepperCmdBuff_ApplyDir[dir_index], dir_bit);
+      }
+
+      if (stepperCmdBuff_produceIdx == (FTM_STEPPERCMD_BUFF_SIZE) - 1) {
+        stepperCmdBuff_produceIdx = 0;
+      }
+      else {
+        stepperCmdBuff_produceIdx++;
+      }
+
+      nextStepTicks = FTM_MIN_TICKS;
+    }
+  } // FTM_STEPS_PER_UNIT_TIME loop
+}
+
+#endif // FT_MOTION
