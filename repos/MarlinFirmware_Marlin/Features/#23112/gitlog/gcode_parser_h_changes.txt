commit 5fea79fd07e5d874fbd217d8d9e8afceec60ef9e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 23 16:02:33 2024 -0600

    üîß Fix ROTATIONAL_AXIS_GANG
    
    Co-Authored-By: DerAndere <26200979+DerAndere1@users.noreply.github.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5d162c0a41..94c5b284e0 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -281,65 +281,69 @@ public:
   static millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 
   // Reduce to fewer bits
   static int16_t value_int() { return (int16_t)value_long(); }
   static uint16_t value_ushort() { return (uint16_t)value_long(); }
   static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static bool value_bool() { return !has_value() || !!value_byte(); }
 
+  static constexpr bool axis_is_rotational(const AxisEnum axis) {
+    return (false
+      || TERN0(AXIS4_ROTATES, axis == I_AXIS)
+      || TERN0(AXIS5_ROTATES, axis == J_AXIS)
+      || TERN0(AXIS6_ROTATES, axis == K_AXIS)
+      || TERN0(AXIS7_ROTATES, axis == U_AXIS)
+      || TERN0(AXIS8_ROTATES, axis == V_AXIS)
+      || TERN0(AXIS9_ROTATES, axis == W_AXIS)
+    );
+  }
+
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
     static float mm_to_linear_unit(const_float_t mm)     { return mm / linear_unit_factor; }
     static float mm_to_volumetric_unit(const_float_t mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
     static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
         case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static float axis_unit_factor(const AxisEnum axis) {
-      if (false
-        || TERN0(AXIS4_ROTATES, axis == I_AXIS)
-        || TERN0(AXIS5_ROTATES, axis == J_AXIS)
-        || TERN0(AXIS6_ROTATES, axis == K_AXIS)
-        || TERN0(AXIS7_ROTATES, axis == U_AXIS)
-        || TERN0(AXIS8_ROTATES, axis == V_AXIS)
-        || TERN0(AXIS9_ROTATES, axis == W_AXIS)
-      ) return 1.0f;
+      if (axis_is_rotational(axis)) return 1.0f;
       #if HAS_EXTRUDERS
         if (axis >= E_AXIS && volumetric_enabled) return volumetric_unit_factor;
       #endif
       return linear_unit_factor;
     }
 
     static float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
     static float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
     static float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
-    static float mm_to_linear_unit(const_float_t mm)     { return mm; }
-    static float mm_to_volumetric_unit(const_float_t mm) { return mm; }
+    static constexpr float mm_to_linear_unit(const_float_t mm)     { return mm; }
+    static constexpr float mm_to_volumetric_unit(const_float_t mm) { return mm; }
 
-    static float linear_value_to_mm(const_float_t v)             { return v; }
-    static float axis_value_to_mm(const AxisEnum, const float v) { return v; }
-    static float per_axis_value(const AxisEnum, const float v)   { return v; }
+    static constexpr float linear_value_to_mm(const_float_t v)             { return v; }
+    static constexpr float axis_value_to_mm(const AxisEnum, const float v) { return v; }
+    static constexpr float per_axis_value(const AxisEnum, const float v)   { return v; }
 
   #endif
 
   static bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
 
   #define IN_TO_MM(I)        ((I) * 25.4f)
   #define MM_TO_IN(M)        ((M) / 25.4f)
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
@@ -395,21 +399,21 @@ public:
         default:
         case TEMPUNIT_C:
         case TEMPUNIT_K: break;
         case TEMPUNIT_F: f *= 0.5555555556f;
       }
       return LROUND(f);
     }
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
-    static float to_temp_units(int16_t c) { return (float)c; }
+    static constexpr float to_temp_units(int16_t c) { return (float)c; }
 
     static celsius_t value_celsius()      { return value_int(); }
     static celsius_t value_celsius_diff() { return value_int(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   static feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_warning();
 

commit 4744997c164931f8c1f8753ba4112e466b7c83a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 12:14:57 2023 -0500

    üìù GCode => G-Code

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index c05d6f32c5..5d162c0a41 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -15,42 +15,42 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
- * parser.h - Parser for a GCode line, providing a parameter interface.
- *           Codes like M149 control the way the GCode parser behaves,
+ * parser.h - Parser for a G-Code line, providing a parameter interface.
+ *           Codes like M149 control the way the G-Code parser behaves,
  *           so settings for these codes are located in this class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 #if ENABLED(DEBUG_GCODE_PARSER)
   #include "../libs/hex_print.h"
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
 #endif
 
 /**
- * GCode parser
+ * G-Code parser
  *
  *  - Parse a single G-code line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
  *    - Parameter value in different units and types
  */
@@ -61,21 +61,21 @@ private:
 
   #if ENABLED(FASTER_GCODE_PARSER)
     static uint32_t codebits;       // Parameters pre-scanned
     static uint8_t param[26];       // For A-Z, offsets into command args
   #else
     static char *command_args;      // Args start here, for slow scan
   #endif
 
 public:
 
-  // Global states for GCode-level units features
+  // Global states for G-Code-level units features
 
   static bool volumetric_enabled;
 
   #if ENABLED(INCH_MODE_SUPPORT)
     static float linear_unit_factor, volumetric_unit_factor;
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
@@ -226,21 +226,21 @@ public:
 
   // Seen any axis parameter
   static bool seen_axis() { return seen(STR_AXES_LOGICAL); }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
-  // Populate all fields by parsing a single line of GCode
+  // Populate all fields by parsing a single line of G-Code
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // Test whether the parsed command matches the input
   static bool is_command(const char ltr, const uint16_t num) { return command_letter == ltr && codenum == num; }

commit af1c7e1a81f969a60c24be71b6a35b2d010166ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 18 13:03:17 2022 -0500

    ü©π Fix strtof interpreting a hex value
    
    Bug introduced in #21532

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 3f5290e81c..c05d6f32c5 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -249,36 +249,34 @@ public:
   FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
   static bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
   static char* value_string() { return value_ptr; }
 
   // Float removes 'E' to prevent scientific notation interpretation
   static float value_float() {
-    if (value_ptr) {
-      char *e = value_ptr;
-      for (;;) {
-        const char c = *e;
-        if (c == '\0' || c == ' ') break;
-        if (c == 'E' || c == 'e') {
-          *e = '\0';
-          const float ret = strtof(value_ptr, nullptr);
-          *e = c;
-          return ret;
-        }
-        ++e;
+    if (!value_ptr) return 0;
+    char *e = value_ptr;
+    for (;;) {
+      const char c = *e;
+      if (c == '\0' || c == ' ') break;
+      if (c == 'E' || c == 'e' || c == 'X' || c == 'x') {
+        *e = '\0';
+        const float ret = strtof(value_ptr, nullptr);
+        *e = c;
+        return ret;
       }
-      return strtof(value_ptr, nullptr);
+      ++e;
     }
-    return 0;
+    return strtof(value_ptr, nullptr);
   }
 
   // Code value as a long or ulong
   static int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
   static uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
 
   // Code value for use as time
   static millis_t value_millis() { return value_ulong(); }
   static millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 

commit 58ce5182c2ea93e79ccaef4c912c68aa554e637e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 31 12:43:44 2022 -0500

    üé® Fix spelling, whitespace

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 3b46cde631..3f5290e81c 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -38,21 +38,21 @@
   typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
 #endif
 
 /**
  * GCode parser
  *
- *  - Parse a single gcode line for its letter, code, subcode, and parameters
+ *  - Parse a single G-code line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
  *    - Parameter value in different units and types
  */
 class GCodeParser {
 

commit 31413a7d773e384753dd889ca2f5dcd8aa1fdeca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 23 21:59:36 2022 -0500

    üßë‚Äçüíª Combined axis strings

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index c91a0de5f2..3b46cde631 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -218,21 +218,21 @@ public:
     // At least one of a list of code letters was seen
     static bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
-  static bool seen_axis() { return seen(LOGICAL_AXES_STRING); }
+  static bool seen_axis() { return seen(STR_AXES_LOGICAL); }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 1487c083ec..c91a0de5f2 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -302,27 +302,32 @@ public:
     static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
         case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static float axis_unit_factor(const AxisEnum axis) {
-      return (
-        #if HAS_EXTRUDERS
-          axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor
-        #else
-          linear_unit_factor
-        #endif
-      );
+      if (false
+        || TERN0(AXIS4_ROTATES, axis == I_AXIS)
+        || TERN0(AXIS5_ROTATES, axis == J_AXIS)
+        || TERN0(AXIS6_ROTATES, axis == K_AXIS)
+        || TERN0(AXIS7_ROTATES, axis == U_AXIS)
+        || TERN0(AXIS8_ROTATES, axis == V_AXIS)
+        || TERN0(AXIS9_ROTATES, axis == W_AXIS)
+      ) return 1.0f;
+      #if HAS_EXTRUDERS
+        if (axis >= E_AXIS && volumetric_enabled) return volumetric_unit_factor;
+      #endif
+      return linear_unit_factor;
     }
 
     static float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
     static float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
     static float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
     static float mm_to_linear_unit(const_float_t mm)     { return mm; }
     static float mm_to_volumetric_unit(const_float_t mm) { return mm; }
@@ -333,20 +338,27 @@ public:
 
   #endif
 
   static bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
 
   #define IN_TO_MM(I)        ((I) * 25.4f)
   #define MM_TO_IN(M)        ((M) / 25.4f)
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
+  #define I_AXIS_UNIT(V) TERN(AXIS4_ROTATES, (V), LINEAR_UNIT(V))
+  #define J_AXIS_UNIT(V) TERN(AXIS5_ROTATES, (V), LINEAR_UNIT(V))
+  #define K_AXIS_UNIT(V) TERN(AXIS6_ROTATES, (V), LINEAR_UNIT(V))
+  #define U_AXIS_UNIT(V) TERN(AXIS7_ROTATES, (V), LINEAR_UNIT(V))
+  #define V_AXIS_UNIT(V) TERN(AXIS8_ROTATES, (V), LINEAR_UNIT(V))
+  #define W_AXIS_UNIT(V) TERN(AXIS9_ROTATES, (V), LINEAR_UNIT(V))
+
   static float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
     static char temp_units_code() {
       return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index bd08467298..1487c083ec 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -348,32 +348,32 @@ public:
 
     static void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
     static char temp_units_code() {
       return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
     }
     static FSTR_P temp_units_name() {
       return input_temp_units == TEMPUNIT_K ? F("Kelvin") : input_temp_units == TEMPUNIT_F ? F("Fahrenheit") : F("Celsius");
     }
 
-    #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
+    #if HAS_MARLINUI_MENU && DISABLED(DISABLE_M503)
 
       static float to_temp_units(celsius_t c) {
         switch (input_temp_units) {
           default:
           case TEMPUNIT_C: return c;
           case TEMPUNIT_K: return c + 273.15f;
           case TEMPUNIT_F: return c * 0.5555555556f + 32;
         }
       }
 
-    #endif // HAS_LCD_MENU && !DISABLE_M503
+    #endif // HAS_MARLINUI_MENU && !DISABLE_M503
 
     static celsius_t value_celsius() {
       float f = value_float();
       switch (input_temp_units) {
         default:
         case TEMPUNIT_C: break;
         case TEMPUNIT_K: f -= 273.15f;
         case TEMPUNIT_F: f = (f - 32) * 0.5555555556f;
       }
       return LROUND(f);

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 83fda54836..bd08467298 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -119,37 +119,37 @@ public:
     return valid_float(p);
   }
 
   #if ENABLED(FASTER_GCODE_PARSER)
 
     FORCE_INLINE static bool valid_int(const char * const p) {
       return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
     }
 
     // Set the flag and pointer for a parameter
-    static inline void set(const char c, char * const ptr) {
+    static void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
           SERIAL_ECHOPGM("Set bit ", ind, " of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
           SERIAL_ECHOLNPGM(") | param = ", param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
-    static inline bool seen(const char c) {
+    static bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);
       if (b) {
         if (param[ind]) {
           char * const ptr = command_ptr + param[ind];
           value_ptr = valid_number(ptr) ? ptr : nullptr;
         }
         else
           value_ptr = nullptr;
@@ -176,266 +176,266 @@ public:
       FORCE_INLINE static bool seen(const char * const str) { return !!(codebits & letter_bits(str)); }
     #else
       FORCE_INLINE static bool seen(const char * const str) {
         const uint32_t letrbits = letter_bits(str);
         const uint8_t * const cb = (uint8_t*)&codebits;
         const uint8_t * const lb = (uint8_t*)&letrbits;
         return (cb[0] & lb[0]) || (cb[1] & lb[1]) || (cb[2] & lb[2]) || (cb[3] & lb[3]);
       }
     #endif
 
-    static inline bool seen_any() { return !!codebits; }
+    static bool seen_any() { return !!codebits; }
 
     FORCE_INLINE static bool seen_test(const char c) { return TEST32(codebits, LETTER_BIT(c)); }
 
   #else // !FASTER_GCODE_PARSER
 
     #if ENABLED(GCODE_CASE_INSENSITIVE)
       FORCE_INLINE static char* strgchr(char *p, char g) {
         auto uppercase = [](char c) {
           return c + (WITHIN(c, 'a', 'z') ? 'A' - 'a' : 0);
         };
         const char d = uppercase(g);
         for (char cc; (cc = uppercase(*p)); p++) if (cc == d) return p;
         return nullptr;
       }
     #else
       #define strgchr strchr
     #endif
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
-    static inline bool seen(const char c) {
+    static bool seen(const char c) {
       char *p = strgchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = valid_number(&p[1]) ? &p[1] : nullptr;
       return b;
     }
 
-    static inline bool seen_any() { return *command_args == '\0'; }
+    static bool seen_any() { return *command_args == '\0'; }
 
     FORCE_INLINE static bool seen_test(const char c) { return (bool)strgchr(command_args, c); }
 
     // At least one of a list of code letters was seen
-    static inline bool seen(const char * const str) {
+    static bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
-  static inline bool seen_axis() { return seen(LOGICAL_AXES_STRING); }
+  static bool seen_axis() { return seen(LOGICAL_AXES_STRING); }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // Test whether the parsed command matches the input
-  static inline bool is_command(const char ltr, const uint16_t num) { return command_letter == ltr && codenum == num; }
+  static bool is_command(const char ltr, const uint16_t num) { return command_letter == ltr && codenum == num; }
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
-  static inline bool seenval(const char c) { return seen(c) && has_value(); }
+  static bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
-  static inline char* value_string() { return value_ptr; }
+  static char* value_string() { return value_ptr; }
 
   // Float removes 'E' to prevent scientific notation interpretation
-  static inline float value_float() {
+  static float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {
           *e = '\0';
           const float ret = strtof(value_ptr, nullptr);
           *e = c;
           return ret;
         }
         ++e;
       }
       return strtof(value_ptr, nullptr);
     }
     return 0;
   }
 
   // Code value as a long or ulong
-  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
-  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
+  static int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
+  static uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
 
   // Code value for use as time
-  static inline millis_t value_millis() { return value_ulong(); }
-  static inline millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
+  static millis_t value_millis() { return value_ulong(); }
+  static millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 
   // Reduce to fewer bits
-  static inline int16_t value_int() { return (int16_t)value_long(); }
-  static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
-  static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
+  static int16_t value_int() { return (int16_t)value_long(); }
+  static uint16_t value_ushort() { return (uint16_t)value_long(); }
+  static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
-  static inline bool value_bool() { return !has_value() || !!value_byte(); }
+  static bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
-    static inline float mm_to_linear_unit(const_float_t mm)     { return mm / linear_unit_factor; }
-    static inline float mm_to_volumetric_unit(const_float_t mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
+    static float mm_to_linear_unit(const_float_t mm)     { return mm / linear_unit_factor; }
+    static float mm_to_volumetric_unit(const_float_t mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
-    static inline void set_input_linear_units(const LinearUnit units) {
+    static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
         case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
-    static inline float axis_unit_factor(const AxisEnum axis) {
+    static float axis_unit_factor(const AxisEnum axis) {
       return (
         #if HAS_EXTRUDERS
           axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor
         #else
           linear_unit_factor
         #endif
       );
     }
 
-    static inline float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
-    static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
-    static inline float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
+    static float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
+    static float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
+    static float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
-    static inline float mm_to_linear_unit(const_float_t mm)     { return mm; }
-    static inline float mm_to_volumetric_unit(const_float_t mm) { return mm; }
+    static float mm_to_linear_unit(const_float_t mm)     { return mm; }
+    static float mm_to_volumetric_unit(const_float_t mm) { return mm; }
 
-    static inline float linear_value_to_mm(const_float_t v)             { return v; }
-    static inline float axis_value_to_mm(const AxisEnum, const float v) { return v; }
-    static inline float per_axis_value(const AxisEnum, const float v)   { return v; }
+    static float linear_value_to_mm(const_float_t v)             { return v; }
+    static float axis_value_to_mm(const AxisEnum, const float v) { return v; }
+    static float per_axis_value(const AxisEnum, const float v)   { return v; }
 
   #endif
 
-  static inline bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
+  static bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
 
   #define IN_TO_MM(I)        ((I) * 25.4f)
   #define MM_TO_IN(M)        ((M) / 25.4f)
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
-  static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
-  static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
-  static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
+  static float value_linear_units()                      { return linear_value_to_mm(value_float()); }
+  static float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
+  static float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
-    static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
+    static void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
-    static inline char temp_units_code() {
+    static char temp_units_code() {
       return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
     }
-    static inline FSTR_P temp_units_name() {
+    static FSTR_P temp_units_name() {
       return input_temp_units == TEMPUNIT_K ? F("Kelvin") : input_temp_units == TEMPUNIT_F ? F("Fahrenheit") : F("Celsius");
     }
 
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
-      static inline float to_temp_units(celsius_t c) {
+      static float to_temp_units(celsius_t c) {
         switch (input_temp_units) {
           default:
           case TEMPUNIT_C: return c;
           case TEMPUNIT_K: return c + 273.15f;
           case TEMPUNIT_F: return c * 0.5555555556f + 32;
         }
       }
 
     #endif // HAS_LCD_MENU && !DISABLE_M503
 
-    static inline celsius_t value_celsius() {
+    static celsius_t value_celsius() {
       float f = value_float();
       switch (input_temp_units) {
         default:
         case TEMPUNIT_C: break;
         case TEMPUNIT_K: f -= 273.15f;
         case TEMPUNIT_F: f = (f - 32) * 0.5555555556f;
       }
       return LROUND(f);
     }
 
-    static inline celsius_t value_celsius_diff() {
+    static celsius_t value_celsius_diff() {
       float f = value_float();
       switch (input_temp_units) {
         default:
         case TEMPUNIT_C:
         case TEMPUNIT_K: break;
         case TEMPUNIT_F: f *= 0.5555555556f;
       }
       return LROUND(f);
     }
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
-    static inline float to_temp_units(int16_t c) { return (float)c; }
+    static float to_temp_units(int16_t c) { return (float)c; }
 
-    static inline celsius_t value_celsius()      { return value_int(); }
-    static inline celsius_t value_celsius_diff() { return value_int(); }
+    static celsius_t value_celsius()      { return value_int(); }
+    static celsius_t value_celsius_diff() { return value_int(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
-  static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
+  static feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_warning();
 
   // Provide simple value accessors with default option
-  static inline char*     stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
-  static inline float     floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  static inline bool      boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
-  static inline uint8_t   byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
-  static inline int16_t   intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
-  static inline uint16_t  ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
-  static inline int32_t   longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
-  static inline uint32_t  ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  static inline float     linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
-  static inline float     axisunitsval(const char c, const AxisEnum a, const float dval=0)
+  static char*     stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
+  static float     floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  static bool      boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
+  static uint8_t   byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  static int16_t   intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  static uint16_t  ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  static int32_t   longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  static uint32_t  ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  static float     linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
+  static float     axisunitsval(const char c, const AxisEnum a, const float dval=0)
                                                                          { return seenval(c) ? value_axis_units(a)  : dval; }
-  static inline celsius_t celsiusval(const char c, const celsius_t dval=0)    { return seenval(c) ? value_celsius() : dval; }
-  static inline feedRate_t feedrateval(const char c, const feedRate_t dval=0) { return seenval(c) ? value_feedrate() : dval; }
+  static celsius_t celsiusval(const char c, const celsius_t dval=0)    { return seenval(c) ? value_celsius() : dval; }
+  static feedRate_t feedrateval(const char c, const feedRate_t dval=0) { return seenval(c) ? value_feedrate() : dval; }
 
   #if ENABLED(MARLIN_DEV_MODE)
 
-    static inline uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
+    static uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
       if (!seen(c) || *value_ptr != 'x') return dval;
       uint8_t *out = nullptr;
       for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
         out = (uint8_t*)((uintptr_t(out) << 8) | HEXCHR(*vp));
       return out;
     }
 
-    static inline uint16_t hex_val(const char c, uint16_t const dval=0) {
+    static uint16_t hex_val(const char c, uint16_t const dval=0) {
       if (!seen(c) || *value_ptr != 'x') return dval;
       uint16_t out = 0;
       for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
         out = ((out) << 8) | HEXCHR(*vp);
       return out;
     }
 
   #endif
 };
 

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index ad550765ec..83fda54836 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -344,22 +344,22 @@ public:
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
     static inline char temp_units_code() {
       return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
     }
-    static inline PGM_P temp_units_name() {
-      return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
+    static inline FSTR_P temp_units_name() {
+      return input_temp_units == TEMPUNIT_K ? F("Kelvin") : input_temp_units == TEMPUNIT_F ? F("Fahrenheit") : F("Celsius");
     }
 
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
       static inline float to_temp_units(celsius_t c) {
         switch (input_temp_units) {
           default:
           case TEMPUNIT_C: return c;
           case TEMPUNIT_K: return c + 273.15f;
           case TEMPUNIT_F: return c * 0.5555555556f + 32;

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index f8fb890695..ad550765ec 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -126,23 +126,23 @@ public:
     }
 
     // Set the flag and pointer for a parameter
     static inline void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
-          SERIAL_ECHOPAIR("Set bit ", ind, " of codebits (", hex_address((void*)(codebits >> 16)));
+          SERIAL_ECHOPGM("Set bit ", ind, " of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
-          SERIAL_ECHOLNPAIR(") | param = ", param[ind]);
+          SERIAL_ECHOLNPGM(") | param = ", param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index a819de6127..f8fb890695 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -218,23 +218,21 @@ public:
     // At least one of a list of code letters was seen
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
-  static inline bool seen_axis() {
-    return seen(LOGICAL_AXIS_GANG("E", "X", "Y", "Z", AXIS4_STR, AXIS5_STR, AXIS6_STR));
-  }
+  static inline bool seen_axis() { return seen(LOGICAL_AXES_STRING); }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
@@ -343,28 +341,29 @@ public:
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
+    static inline char temp_units_code() {
+      return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
+    }
+    static inline PGM_P temp_units_name() {
+      return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
+    }
+
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
-      static inline char temp_units_code() {
-        return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
-      }
-      static inline PGM_P temp_units_name() {
-        return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
-      }
       static inline float to_temp_units(celsius_t c) {
         switch (input_temp_units) {
           default:
           case TEMPUNIT_C: return c;
           case TEMPUNIT_K: return c + 273.15f;
           case TEMPUNIT_F: return c * 0.5555555556f + 32;
         }
       }
 
     #endif // HAS_LCD_MENU && !DISABLE_M503

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 08cf10004a..a819de6127 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -409,21 +409,22 @@ public:
   static inline float     floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool      boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t   byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t   intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t  ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t   longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   static inline uint32_t  ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   static inline float     linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
   static inline float     axisunitsval(const char c, const AxisEnum a, const float dval=0)
                                                                          { return seenval(c) ? value_axis_units(a)  : dval; }
-  static inline celsius_t celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
+  static inline celsius_t celsiusval(const char c, const celsius_t dval=0)    { return seenval(c) ? value_celsius() : dval; }
+  static inline feedRate_t feedrateval(const char c, const feedRate_t dval=0) { return seenval(c) ? value_feedrate() : dval; }
 
   #if ENABLED(MARLIN_DEV_MODE)
 
     static inline uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
       if (!seen(c) || *value_ptr != 'x') return dval;
       uint8_t *out = nullptr;
       for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
         out = (uint8_t*)((uintptr_t(out) << 8) | HEXCHR(*vp));
       return out;
     }

commit de4b3498c71c5666477b15544d1561fabee3d499
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Mon Jun 21 13:36:06 2021 -0700

    üêõ Fix IJK axis references, E stepper indices (#22176)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5a1748cc4d..08cf10004a 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -304,21 +304,27 @@ public:
     static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
         case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static inline float axis_unit_factor(const AxisEnum axis) {
-      return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
+      return (
+        #if HAS_EXTRUDERS
+          axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor
+        #else
+          linear_unit_factor
+        #endif
+      );
     }
 
     static inline float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
     static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
     static inline float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
     static inline float mm_to_linear_unit(const_float_t mm)     { return mm; }
     static inline float mm_to_volumetric_unit(const_float_t mm) { return mm; }

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index dc3f3c35fb..5a1748cc4d 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -219,21 +219,21 @@ public:
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
   static inline bool seen_axis() {
-    return seen(LOGICAL_AXIS_GANG("E", "X", "Y", "Z"));
+    return seen(LOGICAL_AXIS_GANG("E", "X", "Y", "Z", AXIS4_STR, AXIS5_STR, AXIS6_STR));
   }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 4270e04c9f..dc3f3c35fb 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -219,21 +219,21 @@ public:
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
   static inline bool seen_axis() {
-    return seen("XYZE");
+    return seen(LOGICAL_AXIS_GANG("E", "X", "Y", "Z"));
   }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 3aec17554b..4270e04c9f 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -219,21 +219,21 @@ public:
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
         if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
   static inline bool seen_axis() {
-    return seen_test('X') || seen_test('Y') || seen_test('Z') || seen_test('E');
+    return seen("XYZE");
   }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index b3625ec05e..3aec17554b 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -401,20 +401,22 @@ public:
   // Provide simple value accessors with default option
   static inline char*     stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
   static inline float     floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool      boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t   byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t   intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t  ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t   longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   static inline uint32_t  ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   static inline float     linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
+  static inline float     axisunitsval(const char c, const AxisEnum a, const float dval=0)
+                                                                         { return seenval(c) ? value_axis_units(a)  : dval; }
   static inline celsius_t celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
   #if ENABLED(MARLIN_DEV_MODE)
 
     static inline uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
       if (!seen(c) || *value_ptr != 'x') return dval;
       uint8_t *out = nullptr;
       for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
         out = (uint8_t*)((uintptr_t(out) << 8) | HEXCHR(*vp));
       return out;

commit 30c299fd26af803da9e5b5bb216e80677b9440fe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 2 15:55:20 2021 -0500

    Fix parser temperature rounding

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 8523630098..b3625ec05e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -364,32 +364,32 @@ public:
     #endif // HAS_LCD_MENU && !DISABLE_M503
 
     static inline celsius_t value_celsius() {
       float f = value_float();
       switch (input_temp_units) {
         default:
         case TEMPUNIT_C: break;
         case TEMPUNIT_K: f -= 273.15f;
         case TEMPUNIT_F: f = (f - 32) * 0.5555555556f;
       }
-      return LROUND(f + 0.5f);
+      return LROUND(f);
     }
 
     static inline celsius_t value_celsius_diff() {
       float f = value_float();
       switch (input_temp_units) {
         default:
         case TEMPUNIT_C:
         case TEMPUNIT_K: break;
         case TEMPUNIT_F: f *= 0.5555555556f;
       }
-      return LROUND(f + 0.5f);
+      return LROUND(f);
     }
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
     static inline float to_temp_units(int16_t c) { return (float)c; }
 
     static inline celsius_t value_celsius()      { return value_int(); }
     static inline celsius_t value_celsius_diff() { return value_int(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT

commit 98b2b45264c142053b6ddb015472d4fe2a08c78d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Apr 4 18:35:58 2021 -0400

    Revert "Optimized string-to-number functions" (#21532)
    
    This reverts #21484

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index a0fc67b9e5..8523630098 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -35,24 +35,20 @@
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
 #endif
 
-
-int32_t parse_int32(const char *buf);
-float parse_float(const char *buf);
-
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
@@ -253,26 +249,43 @@ public:
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
   static inline char* value_string() { return value_ptr; }
 
-  // Code value as float
-  static inline float value_float() { return value_ptr ? parse_float(value_ptr) : 0.0; }
+  // Float removes 'E' to prevent scientific notation interpretation
+  static inline float value_float() {
+    if (value_ptr) {
+      char *e = value_ptr;
+      for (;;) {
+        const char c = *e;
+        if (c == '\0' || c == ' ') break;
+        if (c == 'E' || c == 'e') {
+          *e = '\0';
+          const float ret = strtof(value_ptr, nullptr);
+          *e = c;
+          return ret;
+        }
+        ++e;
+      }
+      return strtof(value_ptr, nullptr);
+    }
+    return 0;
+  }
 
   // Code value as a long or ulong
-  static inline int32_t value_long() { return value_ptr ? parse_int32(value_ptr) : 0L; }
-  static inline uint32_t value_ulong() { return value_ptr ? parse_int32(value_ptr) : 0UL; }
+  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
+  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
 
   // Code value for use as time
   static inline millis_t value_millis() { return value_ulong(); }
   static inline millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 
   // Reduce to fewer bits
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index ed503f8a90..a0fc67b9e5 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -275,49 +275,49 @@ public:
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
-    static inline float mm_to_linear_unit(const float mm)     { return mm / linear_unit_factor; }
-    static inline float mm_to_volumetric_unit(const float mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
+    static inline float mm_to_linear_unit(const_float_t mm)     { return mm / linear_unit_factor; }
+    static inline float mm_to_volumetric_unit(const_float_t mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
     static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
         case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static inline float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
-    static inline float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
+    static inline float linear_value_to_mm(const_float_t v)                  { return v * linear_unit_factor; }
     static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
     static inline float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
-    static inline float mm_to_linear_unit(const float mm)     { return mm; }
-    static inline float mm_to_volumetric_unit(const float mm) { return mm; }
+    static inline float mm_to_linear_unit(const_float_t mm)     { return mm; }
+    static inline float mm_to_volumetric_unit(const_float_t mm) { return mm; }
 
-    static inline float linear_value_to_mm(const float v)               { return v; }
+    static inline float linear_value_to_mm(const_float_t v)             { return v; }
     static inline float axis_value_to_mm(const AxisEnum, const float v) { return v; }
     static inline float per_axis_value(const AxisEnum, const float v)   { return v; }
 
   #endif
 
   static inline bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
 
   #define IN_TO_MM(I)        ((I) * 25.4f)
   #define MM_TO_IN(M)        ((M) / 25.4f)
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)

commit 20d2061f22790bb30cf3b934bef2be54d931293e
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Wed Mar 31 04:20:33 2021 +0200

    Optimized string-to-number functions (#21484)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index b21c930cfa..ed503f8a90 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -35,20 +35,24 @@
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
 #endif
 
+
+int32_t parse_int32(const char *buf);
+float parse_float(const char *buf);
+
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
@@ -249,43 +253,26 @@ public:
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
   static inline char* value_string() { return value_ptr; }
 
-  // Float removes 'E' to prevent scientific notation interpretation
-  static inline float value_float() {
-    if (value_ptr) {
-      char *e = value_ptr;
-      for (;;) {
-        const char c = *e;
-        if (c == '\0' || c == ' ') break;
-        if (c == 'E' || c == 'e') {
-          *e = '\0';
-          const float ret = strtof(value_ptr, nullptr);
-          *e = c;
-          return ret;
-        }
-        ++e;
-      }
-      return strtof(value_ptr, nullptr);
-    }
-    return 0;
-  }
+  // Code value as float
+  static inline float value_float() { return value_ptr ? parse_float(value_ptr) : 0.0; }
 
   // Code value as a long or ulong
-  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
-  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
+  static inline int32_t value_long() { return value_ptr ? parse_int32(value_ptr) : 0L; }
+  static inline uint32_t value_ulong() { return value_ptr ? parse_int32(value_ptr) : 0UL; }
 
   // Code value for use as time
   static inline millis_t value_millis() { return value_ulong(); }
   static inline millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 
   // Reduce to fewer bits
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 221500e076..b21c930cfa 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -345,82 +345,77 @@ public:
     static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
       static inline char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       static inline PGM_P temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
-      static inline float to_temp_units(const float &f) {
+      static inline float to_temp_units(celsius_t c) {
         switch (input_temp_units) {
-          case TEMPUNIT_F:
-            return f * 0.5555555556f + 32;
-          case TEMPUNIT_K:
-            return f + 273.15f;
-          case TEMPUNIT_C:
           default:
-            return f;
+          case TEMPUNIT_C: return c;
+          case TEMPUNIT_K: return c + 273.15f;
+          case TEMPUNIT_F: return c * 0.5555555556f + 32;
         }
       }
 
     #endif // HAS_LCD_MENU && !DISABLE_M503
 
-    static inline float value_celsius() {
-      const float f = value_float();
+    static inline celsius_t value_celsius() {
+      float f = value_float();
       switch (input_temp_units) {
-        case TEMPUNIT_F:
-          return (f - 32) * 0.5555555556f;
-        case TEMPUNIT_K:
-          return f - 273.15f;
-        case TEMPUNIT_C:
         default:
-          return f;
+        case TEMPUNIT_C: break;
+        case TEMPUNIT_K: f -= 273.15f;
+        case TEMPUNIT_F: f = (f - 32) * 0.5555555556f;
       }
+      return LROUND(f + 0.5f);
     }
 
-    static inline float value_celsius_diff() {
+    static inline celsius_t value_celsius_diff() {
+      float f = value_float();
       switch (input_temp_units) {
-        case TEMPUNIT_F:
-          return value_float() * 0.5555555556f;
-        case TEMPUNIT_C:
-        case TEMPUNIT_K:
         default:
-          return value_float();
+        case TEMPUNIT_C:
+        case TEMPUNIT_K: break;
+        case TEMPUNIT_F: f *= 0.5555555556f;
       }
+      return LROUND(f + 0.5f);
     }
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
     static inline float to_temp_units(int16_t c) { return (float)c; }
 
-    static inline float value_celsius()      { return value_float(); }
-    static inline float value_celsius_diff() { return value_float(); }
+    static inline celsius_t value_celsius()      { return value_int(); }
+    static inline celsius_t value_celsius_diff() { return value_int(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_warning();
 
   // Provide simple value accessors with default option
-  static inline char*    stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
-  static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
-  static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
-  static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
-  static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
-  static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
-  static inline uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  static inline float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
-  static inline float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
+  static inline char*     stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
+  static inline float     floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  static inline bool      boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
+  static inline uint8_t   byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  static inline int16_t   intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  static inline uint16_t  ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  static inline int32_t   longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  static inline uint32_t  ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  static inline float     linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
+  static inline celsius_t celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
   #if ENABLED(MARLIN_DEV_MODE)
 
     static inline uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
       if (!seen(c) || *value_ptr != 'x') return dval;
       uint8_t *out = nullptr;
       for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
         out = (uint8_t*)((uintptr_t(out) << 8) | HEXCHR(*vp));
       return out;
     }

commit cfa6c7d45ba72d1a0b26e6308191e008dcd0d9c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:34:10 2021 -0500

    Improve max temp / target

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5a31a9943e..221500e076 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -383,29 +383,27 @@ public:
       switch (input_temp_units) {
         case TEMPUNIT_F:
           return value_float() * 0.5555555556f;
         case TEMPUNIT_C:
         case TEMPUNIT_K:
         default:
           return value_float();
       }
     }
 
-    #define TEMP_UNIT(N) parser.to_temp_units(N)
-
   #else // !TEMPERATURE_UNITS_SUPPORT
 
+    static inline float to_temp_units(int16_t c) { return (float)c; }
+
     static inline float value_celsius()      { return value_float(); }
     static inline float value_celsius_diff() { return value_float(); }
 
-    #define TEMP_UNIT(N) (N)
-
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_warning();
 
   // Provide simple value accessors with default option
   static inline char*    stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
   static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }

commit 27f9437d3141635e290b11109b5f6d0929962194
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 23 16:08:00 2021 -0600

    G92, subcodes flag cleanup

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index d60b21a906..5a31a9943e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -78,27 +78,27 @@ public:
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed
               *string_arg,                // string of command line
               command_letter;             // G, M, or T
   static uint16_t codenum;                // 123
-  #if ENABLED(USE_GCODE_SUBCODES)
+  #if USE_GCODE_SUBCODES
     static uint8_t subcode;               // .1
   #endif
 
   #if ENABLED(GCODE_MOTION_MODES)
     static int16_t motion_mode_codenum;
-    #if ENABLED(USE_GCODE_SUBCODES)
+    #if USE_GCODE_SUBCODES
       static uint8_t motion_mode_subcode;
     #endif
     FORCE_INLINE static void cancel_motion_mode() { motion_mode_codenum = -1; }
   #endif
 
   #if ENABLED(DEBUG_GCODE_PARSER)
     static void debug();
   #endif
 
   // Reset is done before parsing

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index cf531c4e47..d60b21a906 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -126,23 +126,23 @@ public:
     }
 
     // Set the flag and pointer for a parameter
     static inline void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
-          SERIAL_ECHOPAIR("Set bit ", (int)ind, " of codebits (", hex_address((void*)(codebits >> 16)));
+          SERIAL_ECHOPAIR("Set bit ", ind, " of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
-          SERIAL_ECHOLNPAIR(") | param = ", (int)param[ind]);
+          SERIAL_ECHOLNPAIR(") | param = ", param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);

commit b8186b50817d33999a414400d82d876da7b40ee9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 25 08:32:58 2021 -0600

    Apply SEC_TO_MS and other fixes

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 8633d2b1e9..cf531c4e47 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -275,21 +275,21 @@ public:
     }
     return 0;
   }
 
   // Code value as a long or ulong
   static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
   static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
 
   // Code value for use as time
   static inline millis_t value_millis() { return value_ulong(); }
-  static inline millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
+  static inline millis_t value_millis_from_seconds() { return (millis_t)SEC_TO_MS(value_float()); }
 
   // Reduce to fewer bits
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin

commit 62680bb356b4449661145ecbd6978d286c639a23
Author: rdhoggattjr <64983896+rdhoggattjr@users.noreply.github.com>
Date:   Mon Nov 23 23:02:54 2020 -0600

    LCD position in current units (#20145)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 69bbdaf02d..8633d2b1e9 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -322,20 +322,24 @@ public:
 
     static inline float mm_to_linear_unit(const float mm)     { return mm; }
     static inline float mm_to_volumetric_unit(const float mm) { return mm; }
 
     static inline float linear_value_to_mm(const float v)               { return v; }
     static inline float axis_value_to_mm(const AxisEnum, const float v) { return v; }
     static inline float per_axis_value(const AxisEnum, const float v)   { return v; }
 
   #endif
 
+  static inline bool using_inch_units() { return mm_to_linear_unit(1.0f) != 1.0f; }
+
+  #define IN_TO_MM(I)        ((I) * 25.4f)
+  #define MM_TO_IN(M)        ((M) / 25.4f)
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }

commit c5e411f49218535cd71c92b26bc226f9a9146e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 14 18:09:17 2020 -0600

    Add parser.is_command(letter, code)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 17fb084388..69bbdaf02d 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -77,21 +77,21 @@ public:
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed
               *string_arg,                // string of command line
               command_letter;             // G, M, or T
-  static int codenum;                     // 123
+  static uint16_t codenum;                // 123
   #if ENABLED(USE_GCODE_SUBCODES)
     static uint8_t subcode;               // .1
   #endif
 
   #if ENABLED(GCODE_MOTION_MODES)
     static int16_t motion_mode_codenum;
     #if ENABLED(USE_GCODE_SUBCODES)
       static uint8_t motion_mode_subcode;
     #endif
     FORCE_INLINE static void cancel_motion_mode() { motion_mode_codenum = -1; }
@@ -237,20 +237,23 @@ public:
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
+  // Test whether the parsed command matches the input
+  static inline bool is_command(const char ltr, const uint16_t num) { return command_letter == ltr && codenum == num; }
+
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
   static inline char* value_string() { return value_ptr; }
 
   // Float removes 'E' to prevent scientific notation interpretation

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 42b85ca271..17fb084388 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -238,21 +238,21 @@ public:
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // The code value pointer was set
-  FORCE_INLINE static bool has_value() { return value_ptr != nullptr; }
+  FORCE_INLINE static bool has_value() { return !!value_ptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // The value as a string
   static inline char* value_string() { return value_ptr; }
 
   // Float removes 'E' to prevent scientific notation interpretation
   static inline float value_float() {
     if (value_ptr) {

commit 631457ffea46debd43079137e09bc2d36b5d4fe4
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 9 08:25:23 2020 -0300

    Support for Debug Codes - Dnnn (#19225)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index eb614c33b4..42b85ca271 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -107,20 +107,25 @@ public:
   #define LETTER_BIT(N) ((N) - 'A')
 
   FORCE_INLINE static bool valid_signless(const char * const p) {
     return NUMERIC(p[0]) || (p[0] == '.' && NUMERIC(p[1])); // .?[0-9]
   }
 
   FORCE_INLINE static bool valid_float(const char * const p) {
     return valid_signless(p) || ((p[0] == '-' || p[0] == '+') && valid_signless(&p[1])); // [-+]?.?[0-9]
   }
 
+  FORCE_INLINE static bool valid_number(const char * const p) {
+    // TODO: With MARLIN_DEV_MODE allow HEX values starting with "x"
+    return valid_float(p);
+  }
+
   #if ENABLED(FASTER_GCODE_PARSER)
 
     FORCE_INLINE static bool valid_int(const char * const p) {
       return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
     }
 
     // Set the flag and pointer for a parameter
     static inline void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
@@ -135,22 +140,26 @@ public:
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);
       if (b) {
-        char * const ptr = command_ptr + param[ind];
-        value_ptr = param[ind] && valid_float(ptr) ? ptr : nullptr;
+        if (param[ind]) {
+          char * const ptr = command_ptr + param[ind];
+          value_ptr = valid_number(ptr) ? ptr : nullptr;
+        }
+        else
+          value_ptr = nullptr;
       }
       return b;
     }
 
     FORCE_INLINE static constexpr uint32_t letter_bits(const char * const str) {
       return  (str[0] ? _BV32(LETTER_BIT(str[0])) |
               (str[1] ? _BV32(LETTER_BIT(str[1])) |
               (str[2] ? _BV32(LETTER_BIT(str[2])) |
               (str[3] ? _BV32(LETTER_BIT(str[3])) |
               (str[4] ? _BV32(LETTER_BIT(str[4])) |
@@ -191,21 +200,21 @@ public:
       }
     #else
       #define strgchr strchr
     #endif
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       char *p = strgchr(command_args, c);
       const bool b = !!p;
-      if (b) value_ptr = valid_float(&p[1]) ? &p[1] : nullptr;
+      if (b) value_ptr = valid_number(&p[1]) ? &p[1] : nullptr;
       return b;
     }
 
     static inline bool seen_any() { return *command_args == '\0'; }
 
     FORCE_INLINE static bool seen_test(const char c) { return (bool)strgchr(command_args, c); }
 
     // At least one of a list of code letters was seen
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
@@ -394,13 +403,32 @@ public:
   static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   static inline uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   static inline float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
   static inline float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
+  #if ENABLED(MARLIN_DEV_MODE)
+
+    static inline uint8_t* hex_adr_val(const char c, uint8_t * const dval=nullptr) {
+      if (!seen(c) || *value_ptr != 'x') return dval;
+      uint8_t *out = nullptr;
+      for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
+        out = (uint8_t*)((uintptr_t(out) << 8) | HEXCHR(*vp));
+      return out;
+    }
+
+    static inline uint16_t hex_val(const char c, uint16_t const dval=0) {
+      if (!seen(c) || *value_ptr != 'x') return dval;
+      uint16_t out = 0;
+      for (char *vp = value_ptr + 1; HEXCHR(*vp) >= 0; vp++)
+        out = ((out) << 8) | HEXCHR(*vp);
+      return out;
+    }
+
+  #endif
 };
 
 extern GCodeParser parser;

commit d69c2a90b7721c2b779d31572faff5fd848d8ea0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Aug 5 23:21:41 2020 -0500

    Simple rename of hex_print

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5474e5e5f3..eb614c33b4 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -24,21 +24,21 @@
 /**
  * parser.h - Parser for a GCode line, providing a parameter interface.
  *           Codes like M149 control the way the GCode parser behaves,
  *           so settings for these codes are located in this class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 #if ENABLED(DEBUG_GCODE_PARSER)
-  #include "../libs/hex_print_routines.h"
+  #include "../libs/hex_print.h"
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
 #endif
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 06e41ccf13..5474e5e5f3 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * parser.h - Parser for a GCode line, providing a parameter interface.
  *           Codes like M149 control the way the GCode parser behaves,
  *           so settings for these codes are located in this class.
  */
 

commit bafe8d920a780bc5f5c0ad41437a09ffa823432d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 12:02:54 2020 -0600

    Handle print completed LED event in M0

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 7c5e1518b3..06e41ccf13 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -234,21 +234,21 @@ public:
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return value_ptr != nullptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
-  // Float removes 'E' to prevent scientific notation interpretation
+  // The value as a string
   static inline char* value_string() { return value_ptr; }
 
   // Float removes 'E' to prevent scientific notation interpretation
   static inline float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {

commit 832951ec4493da96772386f1177a34ff9c936aee
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 26 09:23:55 2020 -0600

    Case-insensitive g-code option (#16932)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 70eb85e31e..7c5e1518b3 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -159,60 +159,72 @@ public:
               (str[7] ? _BV32(LETTER_BIT(str[7])) |
               (str[8] ? _BV32(LETTER_BIT(str[8])) |
               (str[9] ? _BV32(LETTER_BIT(str[9]))
             : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0);
     }
 
     // At least one of a list of code letters was seen
     #ifdef CPU_32_BIT
       FORCE_INLINE static bool seen(const char * const str) { return !!(codebits & letter_bits(str)); }
     #else
-      // At least one of a list of code letters was seen
       FORCE_INLINE static bool seen(const char * const str) {
         const uint32_t letrbits = letter_bits(str);
         const uint8_t * const cb = (uint8_t*)&codebits;
         const uint8_t * const lb = (uint8_t*)&letrbits;
         return (cb[0] & lb[0]) || (cb[1] & lb[1]) || (cb[2] & lb[2]) || (cb[3] & lb[3]);
       }
     #endif
 
     static inline bool seen_any() { return !!codebits; }
 
-    #define SEEN_TEST(L) TEST32(codebits, LETTER_BIT(L))
+    FORCE_INLINE static bool seen_test(const char c) { return TEST32(codebits, LETTER_BIT(c)); }
 
   #else // !FASTER_GCODE_PARSER
 
+    #if ENABLED(GCODE_CASE_INSENSITIVE)
+      FORCE_INLINE static char* strgchr(char *p, char g) {
+        auto uppercase = [](char c) {
+          return c + (WITHIN(c, 'a', 'z') ? 'A' - 'a' : 0);
+        };
+        const char d = uppercase(g);
+        for (char cc; (cc = uppercase(*p)); p++) if (cc == d) return p;
+        return nullptr;
+      }
+    #else
+      #define strgchr strchr
+    #endif
+
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
-      char *p = strchr(command_args, c);
+      char *p = strgchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = valid_float(&p[1]) ? &p[1] : nullptr;
       return b;
     }
 
     static inline bool seen_any() { return *command_args == '\0'; }
 
-    #define SEEN_TEST(L) !!strchr(command_args, L)
+    FORCE_INLINE static bool seen_test(const char c) { return (bool)strgchr(command_args, c); }
 
     // At least one of a list of code letters was seen
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
-        if (SEEN_TEST(c)) return true;
+        if (seen_test(c)) return true;
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
   static inline bool seen_axis() {
-    return SEEN_TEST('X') || SEEN_TEST('Y') || SEEN_TEST('Z') || SEEN_TEST('E');
+    return seen_test('X') || seen_test('Y') || seen_test('Z') || seen_test('E');
   }
 
   #if ENABLED(GCODE_QUOTED_STRINGS)
     static char* unescape_string(char* &src);
   #else
     FORCE_INLINE static char* unescape_string(char* &src) { return src; }
   #endif
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value

commit 0ba18848af83d66aa14ca8f5d387ab9f630d450e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 10 16:22:38 2020 -0600

    Allow USE_GCODE_SUBCODES for debugging

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 08f8613c17..70eb85e31e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -78,27 +78,27 @@ public:
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed
               *string_arg,                // string of command line
               command_letter;             // G, M, or T
   static int codenum;                     // 123
-  #if USE_GCODE_SUBCODES
+  #if ENABLED(USE_GCODE_SUBCODES)
     static uint8_t subcode;               // .1
   #endif
 
   #if ENABLED(GCODE_MOTION_MODES)
     static int16_t motion_mode_codenum;
-    #if USE_GCODE_SUBCODES
+    #if ENABLED(USE_GCODE_SUBCODES)
       static uint8_t motion_mode_subcode;
     #endif
     FORCE_INLINE static void cancel_motion_mode() { motion_mode_codenum = -1; }
   #endif
 
   #if ENABLED(DEBUG_GCODE_PARSER)
     static void debug();
   #endif
 
   // Reset is done before parsing

commit 3bef7a445080fcb133dfa49aefddc0f28057b226
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 10 14:52:15 2020 -0600

    Add g-code quoted strings, improve stream code (#16818)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index cce8abe5fd..08f8613c17 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -201,35 +201,44 @@ public:
       return false;
     }
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
   static inline bool seen_axis() {
     return SEEN_TEST('X') || SEEN_TEST('Y') || SEEN_TEST('Z') || SEEN_TEST('E');
   }
 
+  #if ENABLED(GCODE_QUOTED_STRINGS)
+    static char* unescape_string(char* &src);
+  #else
+    FORCE_INLINE static char* unescape_string(char* &src) { return src; }
+  #endif
+
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return value_ptr != nullptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
+  // Float removes 'E' to prevent scientific notation interpretation
+  static inline char* value_string() { return value_ptr; }
+
   // Float removes 'E' to prevent scientific notation interpretation
   static inline float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {
           *e = '\0';
           const float ret = strtof(value_ptr, nullptr);
@@ -362,20 +371,21 @@ public:
 
     #define TEMP_UNIT(N) (N)
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_warning();
 
   // Provide simple value accessors with default option
+  static inline char*    stringval(const char c, char * const dval=nullptr) { return seenval(c) ? value_string()   : dval; }
   static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   static inline uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   static inline float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
   static inline float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 

commit 38873596ece459ae1d3b65bb8d7905287c3dae6a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 8 23:11:45 2020 -0600

    Tweak parser warning

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index b4a18b364b..cce8abe5fd 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -359,21 +359,21 @@ public:
 
     static inline float value_celsius()      { return value_float(); }
     static inline float value_celsius_diff() { return value_float(); }
 
     #define TEMP_UNIT(N) (N)
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
-  void unknown_command_error();
+  void unknown_command_warning();
 
   // Provide simple value accessors with default option
   static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   static inline uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   static inline float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 2e91216a64..b4a18b364b 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index a4fd629b16..2e91216a64 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -283,23 +283,23 @@ public:
 
     static inline float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
     static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
     static inline float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
     static inline float mm_to_linear_unit(const float mm)     { return mm; }
     static inline float mm_to_volumetric_unit(const float mm) { return mm; }
 
-    static inline float linear_value_to_mm(const float v)                    { return v; }
-    static inline float axis_value_to_mm(const AxisEnum axis, const float v) { UNUSED(axis); return v; }
-    static inline float per_axis_value(const AxisEnum axis, const float v)   { UNUSED(axis); return v; }
+    static inline float linear_value_to_mm(const float v)               { return v; }
+    static inline float axis_value_to_mm(const AxisEnum, const float v) { return v; }
+    static inline float per_axis_value(const AxisEnum, const float v)   { return v; }
 
   #endif
 
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 4f5128bb9c..a4fd629b16 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -357,21 +357,21 @@ public:
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
     static inline float value_celsius()      { return value_float(); }
     static inline float value_celsius_diff() { return value_float(); }
 
     #define TEMP_UNIT(N) (N)
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
-  static inline float value_feedrate() { return value_linear_units(); }
+  static inline feedRate_t value_feedrate() { return MMM_TO_MMS(value_linear_units()); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 1917faa741..4f5128bb9c 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -27,20 +27,28 @@
  *           so settings for these codes are located in this class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 #if ENABLED(DEBUG_GCODE_PARSER)
   #include "../libs/hex_print_routines.h"
 #endif
 
+#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+  typedef enum : uint8_t { TEMPUNIT_C, TEMPUNIT_K, TEMPUNIT_F } TempUnit;
+#endif
+
+#if ENABLED(INCH_MODE_SUPPORT)
+  typedef enum : uint8_t { LINEARUNIT_MM, LINEARUNIT_INCH } LinearUnit;
+#endif
+
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
@@ -247,21 +255,20 @@ public:
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
-
     static inline float mm_to_linear_unit(const float mm)     { return mm / linear_unit_factor; }
     static inline float mm_to_volumetric_unit(const float mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
     static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         default:
         case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
@@ -291,21 +298,21 @@ public:
 
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
-    static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
+    static inline void set_input_temp_units(const TempUnit units) { input_temp_units = units; }
 
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
       static inline char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       static inline PGM_P temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       static inline float to_temp_units(const float &f) {

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 8798ed486a..1917faa741 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -256,27 +256,23 @@ public:
   #if ENABLED(INCH_MODE_SUPPORT)
 
     static inline float mm_to_linear_unit(const float mm)     { return mm / linear_unit_factor; }
     static inline float mm_to_volumetric_unit(const float mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
     static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
-        case LINEARUNIT_INCH:
-          linear_unit_factor = 25.4f;
-          break;
-        case LINEARUNIT_MM:
         default:
-          linear_unit_factor = 1;
-          break;
+        case LINEARUNIT_MM:   linear_unit_factor =  1.0f; break;
+        case LINEARUNIT_INCH: linear_unit_factor = 25.4f; break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static inline float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
     static inline float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
     static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index ddd9e00809..8798ed486a 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index c5a473df6e..ddd9e00809 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -128,21 +128,21 @@ public:
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);
       if (b) {
         char * const ptr = command_ptr + param[ind];
-        value_ptr = param[ind] && valid_float(ptr) ? ptr : (char*)NULL;
+        value_ptr = param[ind] && valid_float(ptr) ? ptr : nullptr;
       }
       return b;
     }
 
     FORCE_INLINE static constexpr uint32_t letter_bits(const char * const str) {
       return  (str[0] ? _BV32(LETTER_BIT(str[0])) |
               (str[1] ? _BV32(LETTER_BIT(str[1])) |
               (str[2] ? _BV32(LETTER_BIT(str[2])) |
               (str[3] ? _BV32(LETTER_BIT(str[3])) |
               (str[4] ? _BV32(LETTER_BIT(str[4])) |
@@ -171,21 +171,21 @@ public:
 
     #define SEEN_TEST(L) TEST32(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       char *p = strchr(command_args, c);
       const bool b = !!p;
-      if (b) value_ptr = valid_float(&p[1]) ? &p[1] : (char*)NULL;
+      if (b) value_ptr = valid_float(&p[1]) ? &p[1] : nullptr;
       return b;
     }
 
     static inline bool seen_any() { return *command_args == '\0'; }
 
     #define SEEN_TEST(L) !!strchr(command_args, L)
 
     // At least one of a list of code letters was seen
     static inline bool seen(const char * const str) {
       for (uint8_t i = 0; const char c = str[i]; i++)
@@ -203,48 +203,48 @@ public:
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // The code value pointer was set
-  FORCE_INLINE static bool has_value() { return value_ptr != NULL; }
+  FORCE_INLINE static bool has_value() { return value_ptr != nullptr; }
 
   // Seen a parameter with a value
   static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // Float removes 'E' to prevent scientific notation interpretation
   static inline float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {
           *e = '\0';
-          const float ret = strtof(value_ptr, NULL);
+          const float ret = strtof(value_ptr, nullptr);
           *e = c;
           return ret;
         }
         ++e;
       }
-      return strtof(value_ptr, NULL);
+      return strtof(value_ptr, nullptr);
     }
     return 0;
   }
 
   // Code value as a long or ulong
-  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
-  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
+  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, nullptr, 10) : 0L; }
+  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, nullptr, 10) : 0UL; }
 
   // Code value for use as time
   static inline millis_t value_millis() { return value_ulong(); }
   static inline millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
 
   // Reduce to fewer bits
   static inline int16_t value_int() { return (int16_t)value_long(); }
   static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 73adfafccb..c5a473df6e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -113,22 +113,21 @@ public:
     }
 
     // Set the flag and pointer for a parameter
     static inline void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
-          SERIAL_ECHOPAIR("Set bit ", (int)ind);
-          SERIAL_ECHOPAIR(" of codebits (", hex_address((void*)(codebits >> 16)));
+          SERIAL_ECHOPAIR("Set bit ", (int)ind, " of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
           SERIAL_ECHOLNPAIR(") | param = ", (int)param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index c13da8a28c..73adfafccb 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 471f403a671e7d095477be9a0cf2ed18d6dcbbd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 11 07:51:39 2018 -0600

    Reduce code size with plain inlines

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 38a5455b64..c13da8a28c 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -234,26 +234,26 @@ public:
       return strtof(value_ptr, NULL);
     }
     return 0;
   }
 
   // Code value as a long or ulong
   static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
   static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
 
   // Code value for use as time
-  FORCE_INLINE static millis_t value_millis() { return value_ulong(); }
-  FORCE_INLINE static millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
+  static inline millis_t value_millis() { return value_ulong(); }
+  static inline millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
 
   // Reduce to fewer bits
-  FORCE_INLINE static int16_t value_int() { return (int16_t)value_long(); }
-  FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
+  static inline int16_t value_int() { return (int16_t)value_long(); }
+  static inline uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
     static inline float mm_to_linear_unit(const float mm)     { return mm / linear_unit_factor; }
@@ -272,52 +272,52 @@ public:
           linear_unit_factor = 1;
           break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static inline float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
-    FORCE_INLINE static float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
-    FORCE_INLINE static float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
-    FORCE_INLINE static float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
+    static inline float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
+    static inline float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
+    static inline float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
-    FORCE_INLINE static float mm_to_linear_unit(const float mm)     { return mm; }
-    FORCE_INLINE static float mm_to_volumetric_unit(const float mm) { return mm; }
+    static inline float mm_to_linear_unit(const float mm)     { return mm; }
+    static inline float mm_to_volumetric_unit(const float mm) { return mm; }
 
-    FORCE_INLINE static float linear_value_to_mm(const float v)                    { return v; }
-    FORCE_INLINE static float axis_value_to_mm(const AxisEnum axis, const float v) { UNUSED(axis); return v; }
-    FORCE_INLINE static float per_axis_value(const AxisEnum axis, const float v)   { UNUSED(axis); return v; }
+    static inline float linear_value_to_mm(const float v)                    { return v; }
+    static inline float axis_value_to_mm(const AxisEnum axis, const float v) { UNUSED(axis); return v; }
+    static inline float per_axis_value(const AxisEnum axis, const float v)   { UNUSED(axis); return v; }
 
   #endif
 
   #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
     #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
-      FORCE_INLINE static char temp_units_code() {
+      static inline char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
-      FORCE_INLINE static PGM_P temp_units_name() {
+      static inline PGM_P temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       static inline float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
             return f * 0.5555555556f + 32;
           case TEMPUNIT_K:
             return f + 273.15f;
           case TEMPUNIT_C:
           default:
@@ -348,35 +348,35 @@ public:
         case TEMPUNIT_K:
         default:
           return value_float();
       }
     }
 
     #define TEMP_UNIT(N) parser.to_temp_units(N)
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
-    FORCE_INLINE static float value_celsius()      { return value_float(); }
-    FORCE_INLINE static float value_celsius_diff() { return value_float(); }
+    static inline float value_celsius()      { return value_float(); }
+    static inline float value_celsius_diff() { return value_float(); }
 
     #define TEMP_UNIT(N) (N)
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
-  FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
+  static inline float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
-  FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
-  FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
-  FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
-  FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
-  FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
-  FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  FORCE_INLINE static float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
-  FORCE_INLINE static float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
+  static inline float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  static inline bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
+  static inline uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  static inline int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  static inline uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  static inline int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  static inline uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  static inline float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
+  static inline float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;

commit e4cf175163054b9e4c3ffe78876289822cb9a923
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 3 01:16:37 2018 -0500

    Synchronize on M204, M205 (#12302)
    
    * Add parser.seen for multiple parameters
    * Fix M666, use !seen for report
    * Synchronize on M204, M205

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 9c9f479974..38a5455b64 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -12,30 +12,28 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 /**
  * parser.h - Parser for a GCode line, providing a parameter interface.
  *           Codes like M149 control the way the GCode parser behaves,
  *           so settings for these codes are located in this class.
  */
 
-#ifndef _PARSER_H_
-#define _PARSER_H_
-
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 #if ENABLED(DEBUG_GCODE_PARSER)
   #include "../libs/hex_print_routines.h"
 #endif
 
 /**
  * GCode parser
  *
@@ -108,71 +106,105 @@ public:
     return valid_signless(p) || ((p[0] == '-' || p[0] == '+') && valid_signless(&p[1])); // [-+]?.?[0-9]
   }
 
   #if ENABLED(FASTER_GCODE_PARSER)
 
     FORCE_INLINE static bool valid_int(const char * const p) {
       return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
     }
 
     // Set the flag and pointer for a parameter
-    static void set(const char c, char * const ptr) {
+    static inline void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
           SERIAL_ECHOPAIR("Set bit ", (int)ind);
           SERIAL_ECHOPAIR(" of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
           SERIAL_ECHOLNPAIR(") | param = ", (int)param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
-    static bool seen(const char c) {
+    static inline bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
       const bool b = TEST32(codebits, ind);
       if (b) {
         char * const ptr = command_ptr + param[ind];
         value_ptr = param[ind] && valid_float(ptr) ? ptr : (char*)NULL;
       }
       return b;
     }
 
-    static bool seen_any() { return !!codebits; }
+    FORCE_INLINE static constexpr uint32_t letter_bits(const char * const str) {
+      return  (str[0] ? _BV32(LETTER_BIT(str[0])) |
+              (str[1] ? _BV32(LETTER_BIT(str[1])) |
+              (str[2] ? _BV32(LETTER_BIT(str[2])) |
+              (str[3] ? _BV32(LETTER_BIT(str[3])) |
+              (str[4] ? _BV32(LETTER_BIT(str[4])) |
+              (str[5] ? _BV32(LETTER_BIT(str[5])) |
+              (str[6] ? _BV32(LETTER_BIT(str[6])) |
+              (str[7] ? _BV32(LETTER_BIT(str[7])) |
+              (str[8] ? _BV32(LETTER_BIT(str[8])) |
+              (str[9] ? _BV32(LETTER_BIT(str[9]))
+            : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0) : 0);
+    }
+
+    // At least one of a list of code letters was seen
+    #ifdef CPU_32_BIT
+      FORCE_INLINE static bool seen(const char * const str) { return !!(codebits & letter_bits(str)); }
+    #else
+      // At least one of a list of code letters was seen
+      FORCE_INLINE static bool seen(const char * const str) {
+        const uint32_t letrbits = letter_bits(str);
+        const uint8_t * const cb = (uint8_t*)&codebits;
+        const uint8_t * const lb = (uint8_t*)&letrbits;
+        return (cb[0] & lb[0]) || (cb[1] & lb[1]) || (cb[2] & lb[2]) || (cb[3] & lb[3]);
+      }
+    #endif
+
+    static inline bool seen_any() { return !!codebits; }
 
     #define SEEN_TEST(L) TEST32(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
-    static bool seen(const char c) {
+    static inline bool seen(const char c) {
       char *p = strchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = valid_float(&p[1]) ? &p[1] : (char*)NULL;
       return b;
     }
 
-    static bool seen_any() { return *command_args == '\0'; }
+    static inline bool seen_any() { return *command_args == '\0'; }
 
     #define SEEN_TEST(L) !!strchr(command_args, L)
 
+    // At least one of a list of code letters was seen
+    static inline bool seen(const char * const str) {
+      for (uint8_t i = 0; const char c = str[i]; i++)
+        if (SEEN_TEST(c)) return true;
+      return false;
+    }
+
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
-  static bool seen_axis() {
+  static inline bool seen_axis() {
     return SEEN_TEST('X') || SEEN_TEST('Y') || SEEN_TEST('Z') || SEEN_TEST('E');
   }
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
@@ -341,12 +373,10 @@ public:
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   FORCE_INLINE static float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
   FORCE_INLINE static float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;
-
-#endif // _PARSER_H_

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 6123bc90fc..9c9f479974 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -266,41 +266,41 @@ public:
   #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
 
   static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
   static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
   static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
-    #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
+    #if HAS_LCD_MENU && DISABLED(DISABLE_M503)
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       FORCE_INLINE static PGM_P temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       static inline float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
             return f * 0.5555555556f + 32;
           case TEMPUNIT_K:
             return f + 273.15f;
           case TEMPUNIT_C:
           default:
             return f;
         }
       }
 
-    #endif // ULTIPANEL && !DISABLE_M503
+    #endif // HAS_LCD_MENU && !DISABLE_M503
 
     static inline float value_celsius() {
       const float f = value_float();
       switch (input_temp_units) {
         case TEMPUNIT_F:
           return (f - 32) * 0.5555555556f;
         case TEMPUNIT_K:
           return f - 273.15f;
         case TEMPUNIT_C:
         default:

commit 951b25163e8b9e09212594b47c26434f23dc1a1e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 13 23:08:20 2018 -0500

    Extend M217 with configurable park/raise (#12076)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index d70c286204..6123bc90fc 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -217,52 +217,65 @@ public:
   FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
   static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
+    static inline float mm_to_linear_unit(const float mm)     { return mm / linear_unit_factor; }
+    static inline float mm_to_volumetric_unit(const float mm) { return mm / (volumetric_enabled ? volumetric_unit_factor : linear_unit_factor); }
+
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
     static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         case LINEARUNIT_INCH:
           linear_unit_factor = 25.4f;
           break;
         case LINEARUNIT_MM:
         default:
           linear_unit_factor = 1;
           break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     static inline float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
-    static inline float value_linear_units()                     { return value_float() * linear_unit_factor; }
-    static inline float value_axis_units(const AxisEnum axis)    { return value_float() * axis_unit_factor(axis); }
-    static inline float value_per_axis_unit(const AxisEnum axis) { return value_float() / axis_unit_factor(axis); }
+    FORCE_INLINE static float linear_value_to_mm(const float v)                    { return v * linear_unit_factor; }
+    FORCE_INLINE static float axis_value_to_mm(const AxisEnum axis, const float v) { return v * axis_unit_factor(axis); }
+    FORCE_INLINE static float per_axis_value(const AxisEnum axis, const float v)   { return v / axis_unit_factor(axis); }
 
   #else
 
-    FORCE_INLINE static float value_linear_units()                  {            return value_float(); }
-    FORCE_INLINE static float value_axis_units(const AxisEnum a)    { UNUSED(a); return value_float(); }
-    FORCE_INLINE static float value_per_axis_unit(const AxisEnum a) { UNUSED(a); return value_float(); }
+    FORCE_INLINE static float mm_to_linear_unit(const float mm)     { return mm; }
+    FORCE_INLINE static float mm_to_volumetric_unit(const float mm) { return mm; }
+
+    FORCE_INLINE static float linear_value_to_mm(const float v)                    { return v; }
+    FORCE_INLINE static float axis_value_to_mm(const AxisEnum axis, const float v) { UNUSED(axis); return v; }
+    FORCE_INLINE static float per_axis_value(const AxisEnum axis, const float v)   { UNUSED(axis); return v; }
 
   #endif
 
+  #define LINEAR_UNIT(V)     parser.mm_to_linear_unit(V)
+  #define VOLUMETRIC_UNIT(V) parser.mm_to_volumetric_unit(V)
+
+  static inline float value_linear_units()                      { return linear_value_to_mm(value_float()); }
+  static inline float value_axis_units(const AxisEnum axis)     { return axis_value_to_mm(axis, value_float()); }
+  static inline float value_per_axis_units(const AxisEnum axis) { return per_axis_value(axis, value_float()); }
+
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
     #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       FORCE_INLINE static PGM_P temp_units_name() {
@@ -299,25 +312,29 @@ public:
       switch (input_temp_units) {
         case TEMPUNIT_F:
           return value_float() * 0.5555555556f;
         case TEMPUNIT_C:
         case TEMPUNIT_K:
         default:
           return value_float();
       }
     }
 
+    #define TEMP_UNIT(N) parser.to_temp_units(N)
+
   #else // !TEMPERATURE_UNITS_SUPPORT
 
     FORCE_INLINE static float value_celsius()      { return value_float(); }
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
+    #define TEMP_UNIT(N) (N)
+
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index b6044b216e..d70c286204 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -318,18 +318,18 @@ public:
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  FORCE_INLINE static float    linearval(const char c, const float dval=0) { return seenval(c) ? value_linear_units() : dval; }
-  FORCE_INLINE static float    celsiusval(const char c, const float dval=0){ return seenval(c) ? value_celsius()      : dval; }
+  FORCE_INLINE static float    linearval(const char c, const float dval=0)    { return seenval(c) ? value_linear_units() : dval; }
+  FORCE_INLINE static float    celsiusval(const char c, const float dval=0)   { return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;
 
 #endif // _PARSER_H_

commit 52a37913c16ab50a0c35e34a4c597bd1428edc7e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 5 18:19:45 2018 -0500

    Extend and apply some corrections

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5939ea8a77..b6044b216e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -69,37 +69,35 @@ public:
   #if ENABLED(INCH_MODE_SUPPORT)
     static float linear_unit_factor, volumetric_unit_factor;
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed
-              *string_arg;                // string of command line
-
-
-
-  static char command_letter;             // G, M, or T
+              *string_arg,                // string of command line
+              command_letter;             // G, M, or T
   static int codenum;                     // 123
   #if USE_GCODE_SUBCODES
     static uint8_t subcode;               // .1
   #endif
 
-  #if ENABLED(STICKY_MOVE_MODE)
-    static int current_motion_mode_codenum;	
-    #if USE_GCODE_SUBCODES		  
-      static uint8_t current_motion_mode_subcode;	
+  #if ENABLED(GCODE_MOTION_MODES)
+    static int16_t motion_mode_codenum;
+    #if USE_GCODE_SUBCODES
+      static uint8_t motion_mode_subcode;
     #endif
+    FORCE_INLINE static void cancel_motion_mode() { motion_mode_codenum = -1; }
   #endif
-  
+
   #if ENABLED(DEBUG_GCODE_PARSER)
     static void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
   #define LETTER_BIT(N) ((N) - 'A')
 
   FORCE_INLINE static bool valid_signless(const char * const p) {

commit e09c144674fffa39a0077a6af0bd6093eaa138b0
Author: thesfreader <thesfreader@gmail.com>
Date:   Fri Oct 5 09:35:55 2018 +0200

    Add CNC-like G-code options

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index eb67bf14a7..5939ea8a77 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -71,26 +71,35 @@ public:
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed
               *string_arg;                // string of command line
 
+
+
   static char command_letter;             // G, M, or T
   static int codenum;                     // 123
   #if USE_GCODE_SUBCODES
     static uint8_t subcode;               // .1
   #endif
 
+  #if ENABLED(STICKY_MOVE_MODE)
+    static int current_motion_mode_codenum;	
+    #if USE_GCODE_SUBCODES		  
+      static uint8_t current_motion_mode_subcode;	
+    #endif
+  #endif
+  
   #if ENABLED(DEBUG_GCODE_PARSER)
     static void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
   #define LETTER_BIT(N) ((N) - 'A')
 
   FORCE_INLINE static bool valid_signless(const char * const p) {

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 1665304f77..eb67bf14a7 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -251,21 +251,21 @@ public:
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
     #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
-      FORCE_INLINE static const char* temp_units_name() {
+      FORCE_INLINE static PGM_P temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       static inline float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
             return f * 0.5555555556f + 32;
           case TEMPUNIT_K:
             return f + 273.15f;
           case TEMPUNIT_C:
           default:

commit a4b01483650ce50e3916d4bc16553429825603ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 23:55:12 2018 -0500

    Easier to find 'static inline'

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 82843d6226..1665304f77 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -168,134 +168,134 @@ public:
 
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
     // Parse the next parameter as a new command
     static bool chain();
   #endif
 
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return value_ptr != NULL; }
 
   // Seen a parameter with a value
-  inline static bool seenval(const char c) { return seen(c) && has_value(); }
+  static inline bool seenval(const char c) { return seen(c) && has_value(); }
 
   // Float removes 'E' to prevent scientific notation interpretation
-  inline static float value_float() {
+  static inline float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {
           *e = '\0';
           const float ret = strtof(value_ptr, NULL);
           *e = c;
           return ret;
         }
         ++e;
       }
       return strtof(value_ptr, NULL);
     }
     return 0;
   }
 
   // Code value as a long or ulong
-  inline static int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
-  inline static uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
+  static inline int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
+  static inline uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
 
   // Code value for use as time
   FORCE_INLINE static millis_t value_millis() { return value_ulong(); }
   FORCE_INLINE static millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
 
   // Reduce to fewer bits
   FORCE_INLINE static int16_t value_int() { return (int16_t)value_long(); }
   FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
-  inline static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
+  static inline uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
-  inline static bool value_bool() { return !has_value() || !!value_byte(); }
+  static inline bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
     // Init linear units by constructor
     GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
 
-    inline static void set_input_linear_units(const LinearUnit units) {
+    static inline void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         case LINEARUNIT_INCH:
           linear_unit_factor = 25.4f;
           break;
         case LINEARUNIT_MM:
         default:
           linear_unit_factor = 1;
           break;
       }
       volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
-    inline static float axis_unit_factor(const AxisEnum axis) {
+    static inline float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
-    inline static float value_linear_units()                     { return value_float() * linear_unit_factor; }
-    inline static float value_axis_units(const AxisEnum axis)    { return value_float() * axis_unit_factor(axis); }
-    inline static float value_per_axis_unit(const AxisEnum axis) { return value_float() / axis_unit_factor(axis); }
+    static inline float value_linear_units()                     { return value_float() * linear_unit_factor; }
+    static inline float value_axis_units(const AxisEnum axis)    { return value_float() * axis_unit_factor(axis); }
+    static inline float value_per_axis_unit(const AxisEnum axis) { return value_float() / axis_unit_factor(axis); }
 
   #else
 
     FORCE_INLINE static float value_linear_units()                  {            return value_float(); }
     FORCE_INLINE static float value_axis_units(const AxisEnum a)    { UNUSED(a); return value_float(); }
     FORCE_INLINE static float value_per_axis_unit(const AxisEnum a) { UNUSED(a); return value_float(); }
 
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
-    inline static void set_input_temp_units(TempUnit units) { input_temp_units = units; }
+    static inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
     #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       FORCE_INLINE static const char* temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
-      inline static float to_temp_units(const float &f) {
+      static inline float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
             return f * 0.5555555556f + 32;
           case TEMPUNIT_K:
             return f + 273.15f;
           case TEMPUNIT_C:
           default:
             return f;
         }
       }
 
     #endif // ULTIPANEL && !DISABLE_M503
 
-    inline static float value_celsius() {
+    static inline float value_celsius() {
       const float f = value_float();
       switch (input_temp_units) {
         case TEMPUNIT_F:
           return (f - 32) * 0.5555555556f;
         case TEMPUNIT_K:
           return f - 273.15f;
         case TEMPUNIT_C:
         default:
           return f;
       }
     }
 
-    inline static float value_celsius_diff() {
+    static inline float value_celsius_diff() {
       switch (input_temp_units) {
         case TEMPUNIT_F:
           return value_float() * 0.5555555556f;
         case TEMPUNIT_C:
         case TEMPUNIT_K:
         default:
           return value_float();
       }
     }
 

commit aed1d17a2d0495234f015eece3d035d07212673e
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Wed Jul 18 02:37:30 2018 +0200

    Initialize default units (#11295)
    
    When `INCH_MODE_SUPPORT` is enabled no default unit is set. This fixes it.

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index e14889d62f..82843d6226 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -78,21 +78,21 @@ public:
   static char *command_ptr,               // The command, so it can be echoed
               *string_arg;                // string of command line
 
   static char command_letter;             // G, M, or T
   static int codenum;                     // 123
   #if USE_GCODE_SUBCODES
     static uint8_t subcode;               // .1
   #endif
 
   #if ENABLED(DEBUG_GCODE_PARSER)
-    void debug();
+    static void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
   #define LETTER_BIT(N) ((N) - 'A')
 
   FORCE_INLINE static bool valid_signless(const char * const p) {
     return NUMERIC(p[0]) || (p[0] == '.' && NUMERIC(p[1])); // .?[0-9]
   }
@@ -210,20 +210,23 @@ public:
   FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
   inline static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   inline static bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
+    // Init linear units by constructor
+    GCodeParser() { set_input_linear_units(LINEARUNIT_MM); }
+
     inline static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         case LINEARUNIT_INCH:
           linear_unit_factor = 25.4f;
           break;
         case LINEARUNIT_MM:
         default:
           linear_unit_factor = 1;
           break;
       }

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index e355856709..e14889d62f 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -179,62 +179,62 @@ public:
 
   // Float removes 'E' to prevent scientific notation interpretation
   inline static float value_float() {
     if (value_ptr) {
       char *e = value_ptr;
       for (;;) {
         const char c = *e;
         if (c == '\0' || c == ' ') break;
         if (c == 'E' || c == 'e') {
           *e = '\0';
-          const float ret = strtod(value_ptr, NULL);
+          const float ret = strtof(value_ptr, NULL);
           *e = c;
           return ret;
         }
         ++e;
       }
-      return strtod(value_ptr, NULL);
+      return strtof(value_ptr, NULL);
     }
-    return 0.0;
+    return 0;
   }
 
   // Code value as a long or ulong
   inline static int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
   inline static uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
 
   // Code value for use as time
   FORCE_INLINE static millis_t value_millis() { return value_ulong(); }
-  FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
+  FORCE_INLINE static millis_t value_millis_from_seconds() { return (millis_t)(value_float() * 1000); }
 
   // Reduce to fewer bits
   FORCE_INLINE static int16_t value_int() { return (int16_t)value_long(); }
   FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
   inline static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
   inline static bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
     inline static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         case LINEARUNIT_INCH:
-          linear_unit_factor = 25.4;
+          linear_unit_factor = 25.4f;
           break;
         case LINEARUNIT_MM:
         default:
-          linear_unit_factor = 1.0;
+          linear_unit_factor = 1;
           break;
       }
-      volumetric_unit_factor = POW(linear_unit_factor, 3.0);
+      volumetric_unit_factor = POW(linear_unit_factor, 3);
     }
 
     inline static float axis_unit_factor(const AxisEnum axis) {
       return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
     }
 
     inline static float value_linear_units()                     { return value_float() * linear_unit_factor; }
     inline static float value_axis_units(const AxisEnum axis)    { return value_float() * axis_unit_factor(axis); }
     inline static float value_per_axis_unit(const AxisEnum axis) { return value_float() / axis_unit_factor(axis); }
 
@@ -254,48 +254,48 @@ public:
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
       FORCE_INLINE static const char* temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       inline static float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
-            return f * 0.5555555556 + 32.0;
+            return f * 0.5555555556f + 32;
           case TEMPUNIT_K:
-            return f + 273.15;
+            return f + 273.15f;
           case TEMPUNIT_C:
           default:
             return f;
         }
       }
 
     #endif // ULTIPANEL && !DISABLE_M503
 
     inline static float value_celsius() {
       const float f = value_float();
       switch (input_temp_units) {
         case TEMPUNIT_F:
-          return (f - 32.0) * 0.5555555556;
+          return (f - 32) * 0.5555555556f;
         case TEMPUNIT_K:
-          return f - 273.15;
+          return f - 273.15f;
         case TEMPUNIT_C:
         default:
           return f;
       }
     }
 
     inline static float value_celsius_diff() {
       switch (input_temp_units) {
         case TEMPUNIT_F:
-          return value_float() * 0.5555555556;
+          return value_float() * 0.5555555556f;
         case TEMPUNIT_C:
         case TEMPUNIT_K:
         default:
           return value_float();
       }
     }
 
   #else // !TEMPERATURE_UNITS_SUPPORT
 
     FORCE_INLINE static float value_celsius()      { return value_float(); }
@@ -308,18 +308,18 @@ public:
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
   FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
-  FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
+  FORCE_INLINE static float    linearval(const char c, const float dval=0) { return seenval(c) ? value_linear_units() : dval; }
+  FORCE_INLINE static float    celsiusval(const char c, const float dval=0){ return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;
 
 #endif // _PARSER_H_

commit 645df23eb0cb11f67ec69959cbd75807e24ea225
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 25 06:45:42 2018 -0500

    Fix warning with FASTER_GCODE_PARSER disabled

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 5c942b70b7..e355856709 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -138,21 +138,21 @@ public:
 
     static bool seen_any() { return !!codebits; }
 
     #define SEEN_TEST(L) TEST32(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
-      const char *p = strchr(command_args, c);
+      char *p = strchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = valid_float(&p[1]) ? &p[1] : (char*)NULL;
       return b;
     }
 
     static bool seen_any() { return *command_args == '\0'; }
 
     #define SEEN_TEST(L) !!strchr(command_args, L)
 
   #endif // !FASTER_GCODE_PARSER

commit 230ae6a14385b8385dc66c2b3831e29ad3ce89f3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 23 16:20:06 2018 -0500

    Default G30 to engage / disengage

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 378435c0f2..5c942b70b7 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -302,21 +302,21 @@ public:
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
+  FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seenval(c) ? value_bool()         : (seen(c) ? true : dval); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
   FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
 
 };
 

commit 21179f8300c152053460807ebdb7448e383966e1
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Mon Jan 29 16:45:44 2018 -0600

    Fix the "slow" version of the G-code parser

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index d4bd897fba..378435c0f2 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -25,20 +25,23 @@
  *           Codes like M149 control the way the GCode parser behaves,
  *           so settings for these codes are located in this class.
  */
 
 #ifndef _PARSER_H_
 #define _PARSER_H_
 
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
+#if ENABLED(DEBUG_GCODE_PARSER)
+  #include "../libs/hex_print_routines.h"
+#endif
 
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
@@ -83,29 +86,29 @@ public:
 
   #if ENABLED(DEBUG_GCODE_PARSER)
     void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
   #define LETTER_BIT(N) ((N) - 'A')
 
-  #if ENABLED(FASTER_GCODE_PARSER)
+  FORCE_INLINE static bool valid_signless(const char * const p) {
+    return NUMERIC(p[0]) || (p[0] == '.' && NUMERIC(p[1])); // .?[0-9]
+  }
 
-    FORCE_INLINE static bool valid_signless(const char * const p) {
-      return NUMERIC(p[0]) || (p[0] == '.' && NUMERIC(p[1])); // .?[0-9]
-    }
+  FORCE_INLINE static bool valid_float(const char * const p) {
+    return valid_signless(p) || ((p[0] == '-' || p[0] == '+') && valid_signless(&p[1])); // [-+]?.?[0-9]
+  }
 
-    FORCE_INLINE static bool valid_float(const char * const p) {
-      return valid_signless(p) || ((p[0] == '-' || p[0] == '+') && valid_signless(&p[1])); // [-+]?.?[0-9]
-    }
+  #if ENABLED(FASTER_GCODE_PARSER)
 
     FORCE_INLINE static bool valid_int(const char * const p) {
       return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
     }
 
     // Set the flag and pointer for a parameter
     static void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI32(codebits, ind);                      // parameter exists

commit f5cfdf6efee4c50ee89cf77dbf10271c161250c7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 1 00:06:44 2018 -0600

    Use _BV32 to avoid name conflict

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 8d5582a4e4..d4bd897fba 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -101,48 +101,48 @@ public:
     }
 
     FORCE_INLINE static bool valid_int(const char * const p) {
       return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
     }
 
     // Set the flag and pointer for a parameter
     static void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
-      SBI(codebits, ind);                        // parameter exists
+      SBI32(codebits, ind);                      // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
           SERIAL_ECHOPAIR("Set bit ", (int)ind);
           SERIAL_ECHOPAIR(" of codebits (", hex_address((void*)(codebits >> 16)));
           print_hex_word((uint16_t)(codebits & 0xFFFF));
           SERIAL_ECHOLNPAIR(") | param = ", (int)param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
-      const bool b = TEST(codebits, ind);
+      const bool b = TEST32(codebits, ind);
       if (b) {
         char * const ptr = command_ptr + param[ind];
         value_ptr = param[ind] && valid_float(ptr) ? ptr : (char*)NULL;
       }
       return b;
     }
 
     static bool seen_any() { return !!codebits; }
 
-    #define SEEN_TEST(L) TEST(codebits, LETTER_BIT(L))
+    #define SEEN_TEST(L) TEST32(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
       const char *p = strchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = valid_float(&p[1]) ? &p[1] : (char*)NULL;
       return b;

commit 399bca316a5abe64f18ce202699822fcd9738b98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 20:49:31 2018 -0600

    Fix has_value with FASTER_GCODE_PARSER

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 62fd4cd7cf..8d5582a4e4 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -85,20 +85,32 @@ public:
     void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
   #define LETTER_BIT(N) ((N) - 'A')
 
   #if ENABLED(FASTER_GCODE_PARSER)
 
+    FORCE_INLINE static bool valid_signless(const char * const p) {
+      return NUMERIC(p[0]) || (p[0] == '.' && NUMERIC(p[1])); // .?[0-9]
+    }
+
+    FORCE_INLINE static bool valid_float(const char * const p) {
+      return valid_signless(p) || ((p[0] == '-' || p[0] == '+') && valid_signless(&p[1])); // [-+]?.?[0-9]
+    }
+
+    FORCE_INLINE static bool valid_int(const char * const p) {
+      return NUMERIC(p[0]) || ((p[0] == '-' || p[0] == '+') && NUMERIC(p[1])); // [-+]?[0-9]
+    }
+
     // Set the flag and pointer for a parameter
     static void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI(codebits, ind);                        // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
           SERIAL_ECHOPAIR("Set bit ", (int)ind);
           SERIAL_ECHOPAIR(" of codebits (", hex_address((void*)(codebits >> 16)));
@@ -123,23 +135,23 @@ public:
 
     static bool seen_any() { return !!codebits; }
 
     #define SEEN_TEST(L) TEST(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
-      char *p = strchr(command_args, c);
+      const char *p = strchr(command_args, c);
       const bool b = !!p;
-      if (b) value_ptr = DECIMAL_SIGNED(p[1]) ? &p[1] : (char*)NULL;
+      if (b) value_ptr = valid_float(&p[1]) ? &p[1] : (char*)NULL;
       return b;
     }
 
     static bool seen_any() { return *command_args == '\0'; }
 
     #define SEEN_TEST(L) !!strchr(command_args, L)
 
   #endif // !FASTER_GCODE_PARSER
 
   // Seen any axis parameter
@@ -189,21 +201,21 @@ public:
   // Code value for use as time
   FORCE_INLINE static millis_t value_millis() { return value_ulong(); }
   FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
 
   // Reduce to fewer bits
   FORCE_INLINE static int16_t value_int() { return (int16_t)value_long(); }
   FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
   inline static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
 
   // Bool is true with no value or non-zero
-  inline static bool value_bool() { return !has_value() || value_byte(); }
+  inline static bool value_bool() { return !has_value() || !!value_byte(); }
 
   // Units modes: Inches, Fahrenheit, Kelvin
 
   #if ENABLED(INCH_MODE_SUPPORT)
 
     inline static void set_input_linear_units(const LinearUnit units) {
       switch (units) {
         case LINEARUNIT_INCH:
           linear_unit_factor = 25.4;
           break;

commit 80d3ded89523b741cec40c43cc09673411eaf168
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 20:49:01 2018 -0600

    Change parser codebits from array to int32_t

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 0d33462904..62fd4cd7cf 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -44,21 +44,21 @@
  *    - Parameter exists
  *    - Parameter has value
  *    - Parameter value in different units and types
  */
 class GCodeParser {
 
 private:
   static char *value_ptr;           // Set by seen, used to fetch the value
 
   #if ENABLED(FASTER_GCODE_PARSER)
-    static byte codebits[4];        // Parameters pre-scanned
+    static uint32_t codebits;       // Parameters pre-scanned
     static uint8_t param[26];       // For A-Z, offsets into command args
   #else
     static char *command_args;      // Args start here, for slow scan
   #endif
 
 public:
 
   // Global states for GCode-level units features
 
   static bool volumetric_enabled;
@@ -81,57 +81,56 @@ public:
     static uint8_t subcode;               // .1
   #endif
 
   #if ENABLED(DEBUG_GCODE_PARSER)
     void debug();
   #endif
 
   // Reset is done before parsing
   static void reset();
 
-  // Index so that 'X' falls on index 24
-  #define PARAM_IND(N)  ((N) >> 3)
-  #define PARAM_BIT(N)  ((N) & 0x7)
-  #define LETTER_OFF(N) ((N) - 'A')
-  #define LETTER_IND(N) PARAM_IND(LETTER_OFF(N))
-  #define LETTER_BIT(N) PARAM_BIT(LETTER_OFF(N))
+  #define LETTER_BIT(N) ((N) - 'A')
 
   #if ENABLED(FASTER_GCODE_PARSER)
 
     // Set the flag and pointer for a parameter
     static void set(const char c, char * const ptr) {
-      const uint8_t ind = LETTER_OFF(c);
+      const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
-      SBI(codebits[PARAM_IND(ind)], PARAM_BIT(ind));        // parameter exists
+      SBI(codebits, ind);                        // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
         if (codenum == 800) {
-          SERIAL_ECHOPAIR("Set bit ", (int)PARAM_BIT(ind));
-          SERIAL_ECHOPAIR(" of index ", (int)PARAM_IND(ind));
-          SERIAL_ECHOLNPAIR(" | param = ", (int)param[ind]);
+          SERIAL_ECHOPAIR("Set bit ", (int)ind);
+          SERIAL_ECHOPAIR(" of codebits (", hex_address((void*)(codebits >> 16)));
+          print_hex_word((uint16_t)(codebits & 0xFFFF));
+          SERIAL_ECHOLNPAIR(") | param = ", (int)param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
-      const uint8_t ind = LETTER_OFF(c);
+      const uint8_t ind = LETTER_BIT(c);
       if (ind >= COUNT(param)) return false; // Only A-Z
-      const bool b = TEST(codebits[PARAM_IND(ind)], PARAM_BIT(ind));
-      if (b) value_ptr = param[ind] ? command_ptr + param[ind] : (char*)NULL;
+      const bool b = TEST(codebits, ind);
+      if (b) {
+        char * const ptr = command_ptr + param[ind];
+        value_ptr = param[ind] && valid_float(ptr) ? ptr : (char*)NULL;
+      }
       return b;
     }
 
-    static bool seen_any() { return codebits[3] || codebits[2] || codebits[1] || codebits[0]; }
+    static bool seen_any() { return !!codebits; }
 
-    #define SEEN_TEST(L) TEST(codebits[LETTER_IND(L)], LETTER_BIT(L))
+    #define SEEN_TEST(L) TEST(codebits, LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
       char *p = strchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = DECIMAL_SIGNED(p[1]) ? &p[1] : (char*)NULL;
       return b;

commit 053b1371c71334b8ff36f8dc3b4e100c112e7338
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 23:42:28 2018 -0600

    Simplify G-code debug option

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 49215c08fc..0d33462904 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -91,31 +91,27 @@ public:
   // Index so that 'X' falls on index 24
   #define PARAM_IND(N)  ((N) >> 3)
   #define PARAM_BIT(N)  ((N) & 0x7)
   #define LETTER_OFF(N) ((N) - 'A')
   #define LETTER_IND(N) PARAM_IND(LETTER_OFF(N))
   #define LETTER_BIT(N) PARAM_BIT(LETTER_OFF(N))
 
   #if ENABLED(FASTER_GCODE_PARSER)
 
     // Set the flag and pointer for a parameter
-    static void set(const char c, char * const ptr
-      #if ENABLED(DEBUG_GCODE_PARSER)
-        , const bool debug=false
-      #endif
-    ) {
+    static void set(const char c, char * const ptr) {
       const uint8_t ind = LETTER_OFF(c);
       if (ind >= COUNT(param)) return;           // Only A-Z
       SBI(codebits[PARAM_IND(ind)], PARAM_BIT(ind));        // parameter exists
       param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
       #if ENABLED(DEBUG_GCODE_PARSER)
-        if (debug) {
+        if (codenum == 800) {
           SERIAL_ECHOPAIR("Set bit ", (int)PARAM_BIT(ind));
           SERIAL_ECHOPAIR(" of index ", (int)PARAM_IND(ind));
           SERIAL_ECHOLNPAIR(" | param = ", (int)param[ind]);
         }
       #endif
     }
 
     // Code seen bit was set. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {

commit 608f8b10da653cfcd3ab4ed70969728b4dd01c4c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 20:59:16 2018 -0600

    Parser val method parity with 1.1.x

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 922e5829e9..49215c08fc 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -291,26 +291,25 @@ public:
     FORCE_INLINE static float value_celsius()      { return value_float(); }
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
-  FORCE_INLINE static float       floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool        boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
-  FORCE_INLINE static uint8_t     byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
-  FORCE_INLINE static int16_t     intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
-  FORCE_INLINE static uint16_t    ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
-  FORCE_INLINE static int32_t     longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
-  FORCE_INLINE static uint32_t    ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  FORCE_INLINE static float       linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
-  FORCE_INLINE static float       celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
-  FORCE_INLINE static const char* strval(const char c)                           { return seenval(c) ? value_ptr            : NULL; }
+  FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
+  FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
+  FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;
 
 #endif // _PARSER_H_

commit 1b40e9c46475a9f9c712eba5588c72256f7dd584
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 16:36:41 2017 -0500

    Implement CNC_COORDINATE_SYSTEMS

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index d872b21d8e..922e5829e9 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -149,20 +149,25 @@ public:
 
   // Seen any axis parameter
   static bool seen_axis() {
     return SEEN_TEST('X') || SEEN_TEST('Y') || SEEN_TEST('Z') || SEEN_TEST('E');
   }
 
   // Populate all fields by parsing a single line of GCode
   // This uses 54 bytes of SRAM to speed up seen/value
   static void parse(char * p);
 
+  #if ENABLED(CNC_COORDINATE_SYSTEMS)
+    // Parse the next parameter as a new command
+    static bool chain();
+  #endif
+
   // The code value pointer was set
   FORCE_INLINE static bool has_value() { return value_ptr != NULL; }
 
   // Seen a parameter with a value
   inline static bool seenval(const char c) { return seen(c) && has_value(); }
 
   // Float removes 'E' to prevent scientific notation interpretation
   inline static float value_float() {
     if (value_ptr) {
       char *e = value_ptr;

commit 9e699811d25918fe64793824b2a2fdbccdf3b7bd
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Oct 26 13:37:26 2017 -0500

    Make LPC1768 pinmapping not specific to Re-ARM (#8063)
    
    * Merging early because of build failures.  See #8105
    
    * Make LPC1768 pinmapping not specific to Re-ARM
    
    * Add HAL_PIN_TYPE and LPC1768 pin features
    
    * M43 Updates
    
    * Move pin map into pinsDebug_LPC1768.h
    
    * Incorporate comments and M226
    
    * Fix persistent store compilation issues
    
    * Update pin features
    
    * Update MKS SBASE pins
    
    * Use native LPC1768 pin numbers in M42, M43, and M226

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index dcd019a99c..d872b21d8e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -286,25 +286,26 @@ public:
     FORCE_INLINE static float value_celsius()      { return value_float(); }
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
-  FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
-  FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
-  FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
-  FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
-  FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
-  FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
-  FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
-  FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
+  FORCE_INLINE static float       floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  FORCE_INLINE static bool        boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
+  FORCE_INLINE static uint8_t     byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  FORCE_INLINE static int16_t     intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  FORCE_INLINE static uint16_t    ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  FORCE_INLINE static int32_t     longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  FORCE_INLINE static uint32_t    ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  FORCE_INLINE static float       linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
+  FORCE_INLINE static float       celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
+  FORCE_INLINE static const char* strval(const char c)                           { return seenval(c) ? value_ptr            : NULL; }
 
 };
 
 extern GCodeParser parser;
 
 #endif // _PARSER_H_

commit 51fafccc16f4e58814b1e6e601a3e8f449f54f89
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Tue Oct 24 17:28:33 2017 -0500

    [2.0.x] Enable hardware serial ports on LPC1768 (#8004)
    
    * Enable hardware serial ports on LPC1768
    
    * Fix compilation errors with other HALs
    
    * FIx order of includes in LPC1768 HAL main.cpp
    
    * Add support for RX_BUFFER_SIZE and TX_BUFFER_SIZE options in Configuration_adv.h

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index a8b7a54e8d..dcd019a99c 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -128,21 +128,21 @@ public:
 
     static bool seen_any() { return codebits[3] || codebits[2] || codebits[1] || codebits[0]; }
 
     #define SEEN_TEST(L) TEST(codebits[LETTER_IND(L)], LETTER_BIT(L))
 
   #else // !FASTER_GCODE_PARSER
 
     // Code is found in the string. If not found, value_ptr is unchanged.
     // This allows "if (seen('A')||seen('B'))" to use the last-found value.
     static bool seen(const char c) {
-      const char *p = strchr(command_args, c);
+      char *p = strchr(command_args, c);
       const bool b = !!p;
       if (b) value_ptr = DECIMAL_SIGNED(p[1]) ? &p[1] : (char*)NULL;
       return b;
     }
 
     static bool seen_any() { return *command_args == '\0'; }
 
     #define SEEN_TEST(L) !!strchr(command_args, L)
 
   #endif // !FASTER_GCODE_PARSER

commit 543935828134831a3129247fcfcf3cb071048011
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Oct 19 10:44:45 2017 -0500

    Basic UBL operations working on 32-bit platforms (#8024)
    
    * 32-bit work for UBL
    
    * Update FT i3-2020 reference file

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index e792c07a2e..a8b7a54e8d 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -287,21 +287,21 @@ public:
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()      : seen(c); }
+  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()         : seen(c); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
   FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
 
 };
 

commit 3986a84f77110643b5873a3bd8a748eb246e6f66
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Wed Oct 18 21:03:17 2017 +0200

    boolval revisited (#8016)

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index c829e66c98..e792c07a2e 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -287,21 +287,21 @@ public:
     FORCE_INLINE static float value_celsius_diff() { return value_float(); }
 
   #endif // !TEMPERATURE_UNITS_SUPPORT
 
   FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
 
   void unknown_command_error();
 
   // Provide simple value accessors with default option
   FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
-  FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seen(c)    ? value_bool()         : dval; }
+  FORCE_INLINE static bool     boolval(const char c)                          { return seenval(c) ? value_bool()      : seen(c); }
   FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
   FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
   FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
 
 };
 

commit 63228fc45355232ba2c6a7838666ed76958623f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 11:41:12 2017 -0500

    Move volumetric flag to GCodeParser

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 9743a7bb99..c829e66c98 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -26,24 +26,20 @@
  *           so settings for these codes are located in this class.
  */
 
 #ifndef _PARSER_H_
 #define _PARSER_H_
 
 #include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 
-#if ENABLED(INCH_MODE_SUPPORT)
-  extern bool volumetric_enabled;
-#endif
-
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
  *    - Stores value offsets (1 byte each)
  *  - Provide accessors for parameters:
  *    - Parameter exists
  *    - Parameter has value
@@ -58,20 +54,22 @@ private:
     static byte codebits[4];        // Parameters pre-scanned
     static uint8_t param[26];       // For A-Z, offsets into command args
   #else
     static char *command_args;      // Args start here, for slow scan
   #endif
 
 public:
 
   // Global states for GCode-level units features
 
+  static bool volumetric_enabled;
+
   #if ENABLED(INCH_MODE_SUPPORT)
     static float linear_unit_factor, volumetric_unit_factor;
   #endif
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
     static TempUnit input_temp_units;
   #endif
 
   // Command line state
   static char *command_ptr,               // The command, so it can be echoed

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 2a9a81c6db..9743a7bb99 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -235,21 +235,21 @@ public:
 
   #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
 
     inline static void set_input_temp_units(TempUnit units) { input_temp_units = units; }
 
     #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
 
       FORCE_INLINE static char temp_units_code() {
         return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
       }
-      FORCE_INLINE static char* temp_units_name() {
+      FORCE_INLINE static const char* temp_units_name() {
         return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
       }
       inline static float to_temp_units(const float &f) {
         switch (input_temp_units) {
           case TEMPUNIT_F:
             return f * 0.5555555556 + 32.0;
           case TEMPUNIT_K:
             return f + 273.15;
           case TEMPUNIT_C:
           default:

commit 4231faf7796ca8adb9ca861b014b65e79f67b376
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Initial split-up of G-code handlers by category

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
index 36549b851f..2a9a81c6db 100644
--- a/Marlin/src/gcode/parser.h
+++ b/Marlin/src/gcode/parser.h
@@ -14,43 +14,32 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
- * gcode.h - Parser for a GCode line, providing a parameter interface.
+ * parser.h - Parser for a GCode line, providing a parameter interface.
  *           Codes like M149 control the way the GCode parser behaves,
  *           so settings for these codes are located in this class.
  */
 
-#ifndef GCODE_H
-#define GCODE_H
+#ifndef _PARSER_H_
+#define _PARSER_H_
 
-#include "enum.h"
-#include "types.h"
-#include "MarlinConfig.h"
+#include "../inc/MarlinConfig.h"
 
 //#define DEBUG_GCODE_PARSER
 
-#if ENABLED(DEBUG_GCODE_PARSER)
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    extern char* hex_address(const void * const w);
-  #else
-    #include "hex_print_routines.h"
-  #endif
-  #include "serial.h"
-#endif
-
 #if ENABLED(INCH_MODE_SUPPORT)
   extern bool volumetric_enabled;
 #endif
 
 /**
  * GCode parser
  *
  *  - Parse a single gcode line for its letter, code, subcode, and parameters
  *  - FASTER_GCODE_PARSER:
  *    - Flags existing params (1 bit each)
@@ -313,11 +302,11 @@ public:
   FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
   FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
   FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
   FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
   FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
 
 };
 
 extern GCodeParser parser;
 
-#endif // GCODE_H
+#endif // _PARSER_H_

commit 9ea2ff950a8741d685823bc5220c335f655f63e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'gcode' files

diff --git a/Marlin/src/gcode/parser.h b/Marlin/src/gcode/parser.h
new file mode 100644
index 0000000000..36549b851f
--- /dev/null
+++ b/Marlin/src/gcode/parser.h
@@ -0,0 +1,323 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * gcode.h - Parser for a GCode line, providing a parameter interface.
+ *           Codes like M149 control the way the GCode parser behaves,
+ *           so settings for these codes are located in this class.
+ */
+
+#ifndef GCODE_H
+#define GCODE_H
+
+#include "enum.h"
+#include "types.h"
+#include "MarlinConfig.h"
+
+//#define DEBUG_GCODE_PARSER
+
+#if ENABLED(DEBUG_GCODE_PARSER)
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    extern char* hex_address(const void * const w);
+  #else
+    #include "hex_print_routines.h"
+  #endif
+  #include "serial.h"
+#endif
+
+#if ENABLED(INCH_MODE_SUPPORT)
+  extern bool volumetric_enabled;
+#endif
+
+/**
+ * GCode parser
+ *
+ *  - Parse a single gcode line for its letter, code, subcode, and parameters
+ *  - FASTER_GCODE_PARSER:
+ *    - Flags existing params (1 bit each)
+ *    - Stores value offsets (1 byte each)
+ *  - Provide accessors for parameters:
+ *    - Parameter exists
+ *    - Parameter has value
+ *    - Parameter value in different units and types
+ */
+class GCodeParser {
+
+private:
+  static char *value_ptr;           // Set by seen, used to fetch the value
+
+  #if ENABLED(FASTER_GCODE_PARSER)
+    static byte codebits[4];        // Parameters pre-scanned
+    static uint8_t param[26];       // For A-Z, offsets into command args
+  #else
+    static char *command_args;      // Args start here, for slow scan
+  #endif
+
+public:
+
+  // Global states for GCode-level units features
+
+  #if ENABLED(INCH_MODE_SUPPORT)
+    static float linear_unit_factor, volumetric_unit_factor;
+  #endif
+
+  #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+    static TempUnit input_temp_units;
+  #endif
+
+  // Command line state
+  static char *command_ptr,               // The command, so it can be echoed
+              *string_arg;                // string of command line
+
+  static char command_letter;             // G, M, or T
+  static int codenum;                     // 123
+  #if USE_GCODE_SUBCODES
+    static uint8_t subcode;               // .1
+  #endif
+
+  #if ENABLED(DEBUG_GCODE_PARSER)
+    void debug();
+  #endif
+
+  // Reset is done before parsing
+  static void reset();
+
+  // Index so that 'X' falls on index 24
+  #define PARAM_IND(N)  ((N) >> 3)
+  #define PARAM_BIT(N)  ((N) & 0x7)
+  #define LETTER_OFF(N) ((N) - 'A')
+  #define LETTER_IND(N) PARAM_IND(LETTER_OFF(N))
+  #define LETTER_BIT(N) PARAM_BIT(LETTER_OFF(N))
+
+  #if ENABLED(FASTER_GCODE_PARSER)
+
+    // Set the flag and pointer for a parameter
+    static void set(const char c, char * const ptr
+      #if ENABLED(DEBUG_GCODE_PARSER)
+        , const bool debug=false
+      #endif
+    ) {
+      const uint8_t ind = LETTER_OFF(c);
+      if (ind >= COUNT(param)) return;           // Only A-Z
+      SBI(codebits[PARAM_IND(ind)], PARAM_BIT(ind));        // parameter exists
+      param[ind] = ptr ? ptr - command_ptr : 0;  // parameter offset or 0
+      #if ENABLED(DEBUG_GCODE_PARSER)
+        if (debug) {
+          SERIAL_ECHOPAIR("Set bit ", (int)PARAM_BIT(ind));
+          SERIAL_ECHOPAIR(" of index ", (int)PARAM_IND(ind));
+          SERIAL_ECHOLNPAIR(" | param = ", (int)param[ind]);
+        }
+      #endif
+    }
+
+    // Code seen bit was set. If not found, value_ptr is unchanged.
+    // This allows "if (seen('A')||seen('B'))" to use the last-found value.
+    static bool seen(const char c) {
+      const uint8_t ind = LETTER_OFF(c);
+      if (ind >= COUNT(param)) return false; // Only A-Z
+      const bool b = TEST(codebits[PARAM_IND(ind)], PARAM_BIT(ind));
+      if (b) value_ptr = param[ind] ? command_ptr + param[ind] : (char*)NULL;
+      return b;
+    }
+
+    static bool seen_any() { return codebits[3] || codebits[2] || codebits[1] || codebits[0]; }
+
+    #define SEEN_TEST(L) TEST(codebits[LETTER_IND(L)], LETTER_BIT(L))
+
+  #else // !FASTER_GCODE_PARSER
+
+    // Code is found in the string. If not found, value_ptr is unchanged.
+    // This allows "if (seen('A')||seen('B'))" to use the last-found value.
+    static bool seen(const char c) {
+      const char *p = strchr(command_args, c);
+      const bool b = !!p;
+      if (b) value_ptr = DECIMAL_SIGNED(p[1]) ? &p[1] : (char*)NULL;
+      return b;
+    }
+
+    static bool seen_any() { return *command_args == '\0'; }
+
+    #define SEEN_TEST(L) !!strchr(command_args, L)
+
+  #endif // !FASTER_GCODE_PARSER
+
+  // Seen any axis parameter
+  static bool seen_axis() {
+    return SEEN_TEST('X') || SEEN_TEST('Y') || SEEN_TEST('Z') || SEEN_TEST('E');
+  }
+
+  // Populate all fields by parsing a single line of GCode
+  // This uses 54 bytes of SRAM to speed up seen/value
+  static void parse(char * p);
+
+  // The code value pointer was set
+  FORCE_INLINE static bool has_value() { return value_ptr != NULL; }
+
+  // Seen a parameter with a value
+  inline static bool seenval(const char c) { return seen(c) && has_value(); }
+
+  // Float removes 'E' to prevent scientific notation interpretation
+  inline static float value_float() {
+    if (value_ptr) {
+      char *e = value_ptr;
+      for (;;) {
+        const char c = *e;
+        if (c == '\0' || c == ' ') break;
+        if (c == 'E' || c == 'e') {
+          *e = '\0';
+          const float ret = strtod(value_ptr, NULL);
+          *e = c;
+          return ret;
+        }
+        ++e;
+      }
+      return strtod(value_ptr, NULL);
+    }
+    return 0.0;
+  }
+
+  // Code value as a long or ulong
+  inline static int32_t value_long() { return value_ptr ? strtol(value_ptr, NULL, 10) : 0L; }
+  inline static uint32_t value_ulong() { return value_ptr ? strtoul(value_ptr, NULL, 10) : 0UL; }
+
+  // Code value for use as time
+  FORCE_INLINE static millis_t value_millis() { return value_ulong(); }
+  FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
+
+  // Reduce to fewer bits
+  FORCE_INLINE static int16_t value_int() { return (int16_t)value_long(); }
+  FORCE_INLINE static uint16_t value_ushort() { return (uint16_t)value_long(); }
+  inline static uint8_t value_byte() { return (uint8_t)constrain(value_long(), 0, 255); }
+
+  // Bool is true with no value or non-zero
+  inline static bool value_bool() { return !has_value() || value_byte(); }
+
+  // Units modes: Inches, Fahrenheit, Kelvin
+
+  #if ENABLED(INCH_MODE_SUPPORT)
+
+    inline static void set_input_linear_units(const LinearUnit units) {
+      switch (units) {
+        case LINEARUNIT_INCH:
+          linear_unit_factor = 25.4;
+          break;
+        case LINEARUNIT_MM:
+        default:
+          linear_unit_factor = 1.0;
+          break;
+      }
+      volumetric_unit_factor = POW(linear_unit_factor, 3.0);
+    }
+
+    inline static float axis_unit_factor(const AxisEnum axis) {
+      return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
+    }
+
+    inline static float value_linear_units()                     { return value_float() * linear_unit_factor; }
+    inline static float value_axis_units(const AxisEnum axis)    { return value_float() * axis_unit_factor(axis); }
+    inline static float value_per_axis_unit(const AxisEnum axis) { return value_float() / axis_unit_factor(axis); }
+
+  #else
+
+    FORCE_INLINE static float value_linear_units()                  {            return value_float(); }
+    FORCE_INLINE static float value_axis_units(const AxisEnum a)    { UNUSED(a); return value_float(); }
+    FORCE_INLINE static float value_per_axis_unit(const AxisEnum a) { UNUSED(a); return value_float(); }
+
+  #endif
+
+  #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+
+    inline static void set_input_temp_units(TempUnit units) { input_temp_units = units; }
+
+    #if ENABLED(ULTIPANEL) && DISABLED(DISABLE_M503)
+
+      FORCE_INLINE static char temp_units_code() {
+        return input_temp_units == TEMPUNIT_K ? 'K' : input_temp_units == TEMPUNIT_F ? 'F' : 'C';
+      }
+      FORCE_INLINE static char* temp_units_name() {
+        return input_temp_units == TEMPUNIT_K ? PSTR("Kelvin") : input_temp_units == TEMPUNIT_F ? PSTR("Fahrenheit") : PSTR("Celsius");
+      }
+      inline static float to_temp_units(const float &f) {
+        switch (input_temp_units) {
+          case TEMPUNIT_F:
+            return f * 0.5555555556 + 32.0;
+          case TEMPUNIT_K:
+            return f + 273.15;
+          case TEMPUNIT_C:
+          default:
+            return f;
+        }
+      }
+
+    #endif // ULTIPANEL && !DISABLE_M503
+
+    inline static float value_celsius() {
+      const float f = value_float();
+      switch (input_temp_units) {
+        case TEMPUNIT_F:
+          return (f - 32.0) * 0.5555555556;
+        case TEMPUNIT_K:
+          return f - 273.15;
+        case TEMPUNIT_C:
+        default:
+          return f;
+      }
+    }
+
+    inline static float value_celsius_diff() {
+      switch (input_temp_units) {
+        case TEMPUNIT_F:
+          return value_float() * 0.5555555556;
+        case TEMPUNIT_C:
+        case TEMPUNIT_K:
+        default:
+          return value_float();
+      }
+    }
+
+  #else // !TEMPERATURE_UNITS_SUPPORT
+
+    FORCE_INLINE static float value_celsius()      { return value_float(); }
+    FORCE_INLINE static float value_celsius_diff() { return value_float(); }
+
+  #endif // !TEMPERATURE_UNITS_SUPPORT
+
+  FORCE_INLINE static float value_feedrate() { return value_linear_units(); }
+
+  void unknown_command_error();
+
+  // Provide simple value accessors with default option
+  FORCE_INLINE static float    floatval(const char c, const float dval=0.0)   { return seenval(c) ? value_float()        : dval; }
+  FORCE_INLINE static bool     boolval(const char c, const bool dval=false)   { return seen(c)    ? value_bool()         : dval; }
+  FORCE_INLINE static uint8_t  byteval(const char c, const uint8_t dval=0)    { return seenval(c) ? value_byte()         : dval; }
+  FORCE_INLINE static int16_t  intval(const char c, const int16_t dval=0)     { return seenval(c) ? value_int()          : dval; }
+  FORCE_INLINE static uint16_t ushortval(const char c, const uint16_t dval=0) { return seenval(c) ? value_ushort()       : dval; }
+  FORCE_INLINE static int32_t  longval(const char c, const int32_t dval=0)    { return seenval(c) ? value_long()         : dval; }
+  FORCE_INLINE static uint32_t ulongval(const char c, const uint32_t dval=0)  { return seenval(c) ? value_ulong()        : dval; }
+  FORCE_INLINE static float    linearval(const char c, const float dval=0.0)  { return seenval(c) ? value_linear_units() : dval; }
+  FORCE_INLINE static float    celsiusval(const char c, const float dval=0.0) { return seenval(c) ? value_celsius()      : dval; }
+
+};
+
+extern GCodeParser parser;
+
+#endif // GCODE_H
