commit a4d20031ec730fd6285b9877d675f544fee70e1c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 5 02:33:45 2024 +0100

    üêõ Fix backlash intial direction (#27208)
    
    Fix regression from #25791

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 07fa7725a0..3b9d78cb2e 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -164,27 +164,28 @@ void Backlash::add_correction_steps(const xyze_long_t &dist, const AxisBits dm,
     block->millimeters += TERN(IS_KINEMATIC, millimeters_delta * block->millimeters / sqr_stepper_space_mm, millimeters_delta / block->millimeters);
 }
 
 int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   if (axis >= NUM_AXES) return 0;
 
   const bool forward = last_direction_bits[axis];
 
   const int32_t residual_error_axis = residual_error[axis];
 
-  // At startup it is assumed the last move was forward.
-  // So the applied steps will always be negative.
+  // At startup, when no steps are applied, it is assumed the last move was backwards.
+  // So the applied steps will always be zero (when moving backwards) or a positive
+  // number (when moving forwards).
 
-  if (forward) return -residual_error_axis;
+  if (!forward) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
-  const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+  const int32_t full_error_axis = f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
 class Backlash::StepAdjuster {
   private:
     xyz_long_t applied_steps;
   public:
     StepAdjuster() {
       LOOP_NUM_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
     }

commit cac742009c1b44f3789e6bd8c400d9ee5763521b
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Nov 4 04:12:33 2023 +0000

    üêõ Fix Backlash Compensation layer shift (#26392)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index c6eb0d33f3..07fa7725a0 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -56,78 +56,93 @@ Backlash backlash;
 
 /**
  * To minimize seams in the printed part, backlash correction only adds
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
-void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const AxisBits dm, block_t * const block) {
+void Backlash::add_correction_steps(const xyze_long_t &dist, const AxisBits dm, block_t * const block) {
   AxisBits changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
   #if DISABLED(CORE_BACKLASH) || ANY(MARKFORGED_XY, MARKFORGED_YX)
-    if (!da)        changed_dir.x = false;
-    if (!db)        changed_dir.y = false;
-    if (!dc)        changed_dir.z = false;
+    if (!dist.a)            changed_dir.x = false;
+    if (!dist.b)            changed_dir.y = false;
+    if (!dist.c)            changed_dir.z = false;
   #elif CORE_IS_XY
-    if (!(da + db)) changed_dir.x = false;
-    if (!(da - db)) changed_dir.y = false;
-    if (!dc)        changed_dir.z = false;
+    if (!(dist.a + dist.b)) changed_dir.x = false;
+    if (!(dist.a - dist.b)) changed_dir.y = false;
+    if (!dist.c)            changed_dir.z = false;
   #elif CORE_IS_XZ
-    if (!(da + dc)) changed_dir.x = false;
-    if (!(da - dc)) changed_dir.z = false;
-    if (!db)        changed_dir.y = false;
+    if (!(dist.a + dist.c)) changed_dir.x = false;
+    if (!(dist.a - dist.c)) changed_dir.z = false;
+    if (!dist.b)            changed_dir.y = false;
   #elif CORE_IS_YZ
-    if (!(db + dc)) changed_dir.y = false;
-    if (!(db - dc)) changed_dir.z = false;
-    if (!da)        changed_dir.x = false;
+    if (!(dist.b + dist.c)) changed_dir.y = false;
+    if (!(dist.b - dist.c)) changed_dir.z = false;
+    if (!dist.a)            changed_dir.x = false;
   #endif
   last_direction_bits ^= changed_dir;
 
   if (!correction && !residual_error) return;
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
   #endif
 
   const float f_corr = float(correction) / all_on;
 
+  bool changed = false;
+  float millimeters_delta = 0.0f;
+  #if IS_KINEMATIC
+    float sqr_stepper_space_mm = 0.0f;
+  #endif
+
   LOOP_NUM_AXES(axis) {
+    TERN_(IS_KINEMATIC, sqr_stepper_space_mm += sq(dist[axis] * planner.mm_per_step[axis]));
+
     if (distance_mm[axis]) {
       const bool forward = dm[axis];
 
       // When an axis changes direction, add axis backlash to the residual error
       if (changed_dir[axis])
         residual_error[axis] += (forward ? f_corr : -f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
-      if (forward == (error_correction < 0))
-        error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
 
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment
           if (segment_proportion == 0) segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
           error_correction = CEIL(segment_proportion * error_correction);
         }
       #endif
 
+      // Don't correct backlash in the opposite direction to movement on this axis and for accuracy in
+      // updating block->millimeters, don't add too many steps to the movement on this axis
+      if (forward)
+        LIMIT(error_correction, 0, dist[axis]);
+      else
+        LIMIT(error_correction, dist[axis], 0);
+
       // This correction reduces the residual error and adds block steps
       if (error_correction) {
+        changed = true;
         block->steps[axis] += ABS(error_correction);
+        millimeters_delta += dist[axis] * error_correction * sq(planner.mm_per_step[axis]);
         #if ENABLED(CORE_BACKLASH)
           switch (axis) {
             case CORE_AXIS_1:
               //block->steps[CORE_AXIS_2] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_2];
               //SERIAL_ECHOLNPGM("CORE_AXIS_1 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
               //  " da=", da, " db=", db, " block->steps[axis]=", block->steps[axis], " err_corr=", error_correction);
               break;
             case CORE_AXIS_2:
               //block->steps[CORE_AXIS_1] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_1];;
               //SERIAL_ECHOLNPGM("CORE_AXIS_2 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
@@ -135,31 +150,36 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
               break;
             case NORMAL_AXIS: break;
           }
           residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
         #else
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
+
+  // If backlash correction steps were added modify block->millimeters with a linear approximation
+  // See https://github.com/MarlinFirmware/Marlin/pull/26392
+  if (changed)
+    block->millimeters += TERN(IS_KINEMATIC, millimeters_delta * block->millimeters / sqr_stepper_space_mm, millimeters_delta / block->millimeters);
 }
 
 int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   if (axis >= NUM_AXES) return 0;
 
   const bool forward = last_direction_bits[axis];
 
   const int32_t residual_error_axis = residual_error[axis];
 
-  // At startup it is assumed the last move was forwards. So the applied
-  // steps will always be a non-positive number.
+  // At startup it is assumed the last move was forward.
+  // So the applied steps will always be negative.
 
   if (forward) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
 class Backlash::StepAdjuster {
   private:

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 8d180c7a4a..c6eb0d33f3 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -59,21 +59,21 @@ Backlash backlash;
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
 void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const AxisBits dm, block_t * const block) {
   AxisBits changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
-  #if DISABLED(CORE_BACKLASH) || EITHER(MARKFORGED_XY, MARKFORGED_YX)
+  #if DISABLED(CORE_BACKLASH) || ANY(MARKFORGED_XY, MARKFORGED_YX)
     if (!da)        changed_dir.x = false;
     if (!db)        changed_dir.y = false;
     if (!dc)        changed_dir.z = false;
   #elif CORE_IS_XY
     if (!(da + db)) changed_dir.x = false;
     if (!(da - db)) changed_dir.y = false;
     if (!dc)        changed_dir.z = false;
   #elif CORE_IS_XZ
     if (!(da + dc)) changed_dir.x = false;
     if (!(da - dc)) changed_dir.z = false;

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 256488762a..8d180c7a4a 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -92,29 +92,29 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
   #endif
 
   const float f_corr = float(correction) / all_on;
 
   LOOP_NUM_AXES(axis) {
     if (distance_mm[axis]) {
-      const bool reverse = dm[axis];
+      const bool forward = dm[axis];
 
       // When an axis changes direction, add axis backlash to the residual error
       if (changed_dir[axis])
-        residual_error[axis] += (reverse ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+        residual_error[axis] += (forward ? f_corr : -f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
-      if (reverse != (error_correction < 0))
+      if (forward == (error_correction < 0))
         error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
 
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment
           if (segment_proportion == 0) segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
           error_correction = CEIL(segment_proportion * error_correction);
         }
       #endif
 
@@ -140,28 +140,28 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
 }
 
 int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   if (axis >= NUM_AXES) return 0;
 
-  const bool reverse = last_direction_bits[axis];
+  const bool forward = last_direction_bits[axis];
 
   const int32_t residual_error_axis = residual_error[axis];
 
   // At startup it is assumed the last move was forwards. So the applied
   // steps will always be a non-positive number.
 
-  if (!reverse) return -residual_error_axis;
+  if (forward) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
 class Backlash::StepAdjuster {
   private:
     xyz_long_t applied_steps;
   public:

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    üßë‚Äçüíª Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 13e2cd99ec..256488762a 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -22,21 +22,21 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"
 #include "../module/planner.h"
 
-axis_bits_t Backlash::last_direction_bits;
+AxisBits Backlash::last_direction_bits;
 xyz_long_t Backlash::residual_error{0};
 
 #ifdef BACKLASH_DISTANCE_MM
   #if ENABLED(BACKLASH_GCODE)
     xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #else
     const xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #endif
 #endif
 
@@ -56,60 +56,60 @@ Backlash backlash;
 
 /**
  * To minimize seams in the printed part, backlash correction only adds
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
-void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const axis_bits_t dm, block_t * const block) {
-  axis_bits_t changed_dir = last_direction_bits ^ dm;
+void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const AxisBits dm, block_t * const block) {
+  AxisBits changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
   #if DISABLED(CORE_BACKLASH) || EITHER(MARKFORGED_XY, MARKFORGED_YX)
-    if (!da) CBI(changed_dir, X_AXIS);
-    if (!db) CBI(changed_dir, Y_AXIS);
-    if (!dc) CBI(changed_dir, Z_AXIS);
+    if (!da)        changed_dir.x = false;
+    if (!db)        changed_dir.y = false;
+    if (!dc)        changed_dir.z = false;
   #elif CORE_IS_XY
-    if (!(da + db)) CBI(changed_dir, X_AXIS);
-    if (!(da - db)) CBI(changed_dir, Y_AXIS);
-    if (!dc)        CBI(changed_dir, Z_AXIS);
+    if (!(da + db)) changed_dir.x = false;
+    if (!(da - db)) changed_dir.y = false;
+    if (!dc)        changed_dir.z = false;
   #elif CORE_IS_XZ
-    if (!(da + dc)) CBI(changed_dir, X_AXIS);
-    if (!(da - dc)) CBI(changed_dir, Z_AXIS);
-    if (!db)        CBI(changed_dir, Y_AXIS);
+    if (!(da + dc)) changed_dir.x = false;
+    if (!(da - dc)) changed_dir.z = false;
+    if (!db)        changed_dir.y = false;
   #elif CORE_IS_YZ
-    if (!(db + dc)) CBI(changed_dir, Y_AXIS);
-    if (!(db - dc)) CBI(changed_dir, Z_AXIS);
-    if (!da)        CBI(changed_dir, X_AXIS);
+    if (!(db + dc)) changed_dir.y = false;
+    if (!(db - dc)) changed_dir.z = false;
+    if (!da)        changed_dir.x = false;
   #endif
   last_direction_bits ^= changed_dir;
 
   if (!correction && !residual_error) return;
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
   #endif
 
   const float f_corr = float(correction) / all_on;
 
   LOOP_NUM_AXES(axis) {
     if (distance_mm[axis]) {
-      const bool reverse = TEST(dm, axis);
+      const bool reverse = dm[axis];
 
       // When an axis changes direction, add axis backlash to the residual error
-      if (TEST(changed_dir, axis))
+      if (changed_dir[axis])
         residual_error[axis] += (reverse ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       if (reverse != (error_correction < 0))
         error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
 
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment
@@ -140,21 +140,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
 }
 
 int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   if (axis >= NUM_AXES) return 0;
 
-  const bool reverse = TEST(last_direction_bits, axis);
+  const bool reverse = last_direction_bits[axis];
 
   const int32_t residual_error_axis = residual_error[axis];
 
   // At startup it is assumed the last move was forwards. So the applied
   // steps will always be a non-positive number.
 
   if (!reverse) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];

commit 6a05702c2048bcfac1acd5203013de612990404d
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Apr 23 21:16:15 2022 +1200

    üêõ Fix BACKLASH_COMPENSATION compile (#24072)
    
    Followup to #23826

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 876d28a8fe..13e2cd99ec 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -155,46 +155,51 @@ int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   // steps will always be a non-positive number.
 
   if (!reverse) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
 class Backlash::StepAdjuster {
-  xyz_long_t applied_steps;
-public:
-  StepAdjuster() {
-    LOOP_NUM_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
-  }
-  ~StepAdjuster() {
-    // after backlash compensation parameter changes, ensure applied step count does not change
-    LOOP_NUM_AXES(axis) residual_error[axis] += backlash.get_applied_steps((AxisEnum)axis) - applied_steps[axis];
-  }
+  private:
+    xyz_long_t applied_steps;
+  public:
+    StepAdjuster() {
+      LOOP_NUM_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
+    }
+    ~StepAdjuster() {
+      // after backlash compensation parameter changes, ensure applied step count does not change
+      LOOP_NUM_AXES(axis) residual_error[axis] += backlash.get_applied_steps((AxisEnum)axis) - applied_steps[axis];
+    }
 };
 
-void Backlash::set_correction_uint8(const uint8_t v) {
-  StepAdjuster adjuster;
-  correction = v;
-}
+#if ENABLED(BACKLASH_GCODE)
 
-void Backlash::set_distance_mm(const AxisEnum axis, const float v) {
-  StepAdjuster adjuster;
-  distance_mm[axis] = v;
-}
+  void Backlash::set_correction_uint8(const uint8_t v) {
+    StepAdjuster adjuster;
+    correction = v;
+  }
 
-#ifdef BACKLASH_SMOOTHING_MM
-  void Backlash::set_smoothing_mm(const float v) {
+  void Backlash::set_distance_mm(const AxisEnum axis, const float v) {
     StepAdjuster adjuster;
-    smoothing_mm = v;
+    distance_mm[axis] = v;
   }
+
+  #ifdef BACKLASH_SMOOTHING_MM
+    void Backlash::set_smoothing_mm(const float v) {
+      StepAdjuster adjuster;
+      smoothing_mm = v;
+    }
+  #endif
+
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
 
   #include "../module/probe.h"
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
     if (measured_count.z == 255) return;
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 84382cf856..876d28a8fe 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -90,21 +90,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
   #endif
 
   const float f_corr = float(correction) / all_on;
 
-  LOOP_LINEAR_AXES(axis) {
+  LOOP_NUM_AXES(axis) {
     if (distance_mm[axis]) {
       const bool reverse = TEST(dm, axis);
 
       // When an axis changes direction, add axis backlash to the residual error
       if (TEST(changed_dir, axis))
         residual_error[axis] += (reverse ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       if (reverse != (error_correction < 0))
@@ -138,45 +138,45 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
         #else
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
 }
 
 int32_t Backlash::get_applied_steps(const AxisEnum axis) {
-  if (axis >= LINEAR_AXES) return 0;
+  if (axis >= NUM_AXES) return 0;
 
   const bool reverse = TEST(last_direction_bits, axis);
 
   const int32_t residual_error_axis = residual_error[axis];
 
   // At startup it is assumed the last move was forwards. So the applied
   // steps will always be a non-positive number.
 
   if (!reverse) return -residual_error_axis;
 
   const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
 class Backlash::StepAdjuster {
   xyz_long_t applied_steps;
 public:
   StepAdjuster() {
-    LOOP_LINEAR_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
+    LOOP_NUM_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
   }
   ~StepAdjuster() {
     // after backlash compensation parameter changes, ensure applied step count does not change
-    LOOP_LINEAR_AXES(axis) residual_error[axis] += backlash.get_applied_steps((AxisEnum)axis) - applied_steps[axis];
+    LOOP_NUM_AXES(axis) residual_error[axis] += backlash.get_applied_steps((AxisEnum)axis) - applied_steps[axis];
   }
 };
 
 void Backlash::set_correction_uint8(const uint8_t v) {
   StepAdjuster adjuster;
   correction = v;
 }
 
 void Backlash::set_distance_mm(const AxisEnum axis, const float v) {
   StepAdjuster adjuster;

commit 6b7868d943cd08b83af085ea0d507cc8433799c6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Mar 1 22:14:52 2022 +0000

    üêõ Fix backlash applied steps when config changes (#23826)
    
    Followup to #23814

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 23458cf86c..84382cf856 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -23,34 +23,32 @@
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"
 #include "../module/planner.h"
 
 axis_bits_t Backlash::last_direction_bits;
-#ifdef BACKLASH_SMOOTHING_MM
-  xyz_long_t Backlash::residual_error{0};
-#endif
+xyz_long_t Backlash::residual_error{0};
 
 #ifdef BACKLASH_DISTANCE_MM
   #if ENABLED(BACKLASH_GCODE)
     xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #else
     const xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #endif
 #endif
 
 #if ENABLED(BACKLASH_GCODE)
-  uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
+  uint8_t Backlash::correction = (BACKLASH_CORRECTION) * all_on;
   #ifdef BACKLASH_SMOOTHING_MM
     float Backlash::smoothing_mm = BACKLASH_SMOOTHING_MM;
   #endif
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   xyz_float_t Backlash::measured_mm{0};
   xyz_uint8_t Backlash::measured_count{0};
 #endif
 
@@ -80,57 +78,50 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
     if (!(da + dc)) CBI(changed_dir, X_AXIS);
     if (!(da - dc)) CBI(changed_dir, Z_AXIS);
     if (!db)        CBI(changed_dir, Y_AXIS);
   #elif CORE_IS_YZ
     if (!(db + dc)) CBI(changed_dir, Y_AXIS);
     if (!(db - dc)) CBI(changed_dir, Z_AXIS);
     if (!da)        CBI(changed_dir, X_AXIS);
   #endif
   last_direction_bits ^= changed_dir;
 
-  if (correction == 0) return;
+  if (!correction && !residual_error) return;
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
-  #else
-    // No direction change, no correction.
-    if (!changed_dir) return;
-    // No leftover residual error from segment to segment
-    xyz_long_t residual_error{0};
   #endif
 
-  const float f_corr = float(correction) / 255.0f;
+  const float f_corr = float(correction) / all_on;
 
   LOOP_LINEAR_AXES(axis) {
     if (distance_mm[axis]) {
-      const bool reversing = TEST(dm,axis);
+      const bool reverse = TEST(dm, axis);
 
       // When an axis changes direction, add axis backlash to the residual error
       if (TEST(changed_dir, axis))
-        residual_error[axis] += (reversing ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+        residual_error[axis] += (reverse ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
+      if (reverse != (error_correction < 0))
+        error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
+
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
-          // Take up a portion of the residual_error in this segment, but only when
-          // the current segment travels in the same direction as the correction
-          if (reversing == (error_correction < 0)) {
-            if (segment_proportion == 0) segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
-            error_correction = CEIL(segment_proportion * error_correction);
-          }
-          else
-            error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
+          // Take up a portion of the residual_error in this segment
+          if (segment_proportion == 0) segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
+          error_correction = CEIL(segment_proportion * error_correction);
         }
       #endif
 
       // This correction reduces the residual error and adds block steps
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         #if ENABLED(CORE_BACKLASH)
           switch (axis) {
             case CORE_AXIS_1:
               //block->steps[CORE_AXIS_2] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_2];
@@ -146,41 +137,66 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           }
           residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
         #else
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
 }
 
-int32_t Backlash::applied_steps(const AxisEnum axis) {
+int32_t Backlash::get_applied_steps(const AxisEnum axis) {
   if (axis >= LINEAR_AXES) return 0;
 
-  const bool reversing = TEST(last_direction_bits, axis);
+  const bool reverse = TEST(last_direction_bits, axis);
 
-  #ifdef BACKLASH_SMOOTHING_MM
-    const int32_t residual_error_axis = residual_error[axis];
-  #else
-    constexpr int32_t residual_error_axis = 0;
-  #endif
+  const int32_t residual_error_axis = residual_error[axis];
 
   // At startup it is assumed the last move was forwards. So the applied
   // steps will always be a non-positive number.
 
-  if (!reversing) return -residual_error_axis;
+  if (!reverse) return -residual_error_axis;
 
-  const float f_corr = float(correction) / 255.0f;
+  const float f_corr = float(correction) / all_on;
   const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
   return full_error_axis - residual_error_axis;
 }
 
+class Backlash::StepAdjuster {
+  xyz_long_t applied_steps;
+public:
+  StepAdjuster() {
+    LOOP_LINEAR_AXES(axis) applied_steps[axis] = backlash.get_applied_steps((AxisEnum)axis);
+  }
+  ~StepAdjuster() {
+    // after backlash compensation parameter changes, ensure applied step count does not change
+    LOOP_LINEAR_AXES(axis) residual_error[axis] += backlash.get_applied_steps((AxisEnum)axis) - applied_steps[axis];
+  }
+};
+
+void Backlash::set_correction_uint8(const uint8_t v) {
+  StepAdjuster adjuster;
+  correction = v;
+}
+
+void Backlash::set_distance_mm(const AxisEnum axis, const float v) {
+  StepAdjuster adjuster;
+  distance_mm[axis] = v;
+}
+
+#ifdef BACKLASH_SMOOTHING_MM
+  void Backlash::set_smoothing_mm(const float v) {
+    StepAdjuster adjuster;
+    smoothing_mm = v;
+  }
+#endif
+
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
 
   #include "../module/probe.h"
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
     if (measured_count.z == 255) return;
 
     const float start_height = current_position.z;
     while (current_position.z < (start_height + BACKLASH_MEASUREMENT_LIMIT) && PROBE_TRIGGERED())

commit 87c4cd20e514b9fc94450e9503e268cc014490e8
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Feb 26 20:30:33 2022 +0000

    üêõ Fix steps-to-mm with backlash (#23814)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 24c0f2ca0c..23458cf86c 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -22,20 +22,25 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"
 #include "../module/planner.h"
 
+axis_bits_t Backlash::last_direction_bits;
+#ifdef BACKLASH_SMOOTHING_MM
+  xyz_long_t Backlash::residual_error{0};
+#endif
+
 #ifdef BACKLASH_DISTANCE_MM
   #if ENABLED(BACKLASH_GCODE)
     xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #else
     const xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #endif
 #endif
 
 #if ENABLED(BACKLASH_GCODE)
   uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
@@ -54,21 +59,20 @@ Backlash backlash;
 /**
  * To minimize seams in the printed part, backlash correction only adds
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
 void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const axis_bits_t dm, block_t * const block) {
-  static axis_bits_t last_direction_bits;
   axis_bits_t changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
   #if DISABLED(CORE_BACKLASH) || EITHER(MARKFORGED_XY, MARKFORGED_YX)
     if (!da) CBI(changed_dir, X_AXIS);
     if (!db) CBI(changed_dir, Y_AXIS);
     if (!dc) CBI(changed_dir, Z_AXIS);
   #elif CORE_IS_XY
     if (!(da + db)) CBI(changed_dir, X_AXIS);
     if (!(da - db)) CBI(changed_dir, Y_AXIS);
     if (!dc)        CBI(changed_dir, Z_AXIS);
@@ -84,24 +88,20 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
   last_direction_bits ^= changed_dir;
 
   if (correction == 0) return;
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
-
-    // Residual error carried forward across multiple segments, so correction can be applied
-    // to segments where there is no direction change.
-    static xyz_long_t residual_error{0};
   #else
     // No direction change, no correction.
     if (!changed_dir) return;
     // No leftover residual error from segment to segment
     xyz_long_t residual_error{0};
   #endif
 
   const float f_corr = float(correction) / 255.0f;
 
   LOOP_LINEAR_AXES(axis) {
@@ -146,20 +146,41 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           }
           residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
         #else
           residual_error[axis] -= error_correction;
         #endif
       }
     }
   }
 }
 
+int32_t Backlash::applied_steps(const AxisEnum axis) {
+  if (axis >= LINEAR_AXES) return 0;
+
+  const bool reversing = TEST(last_direction_bits, axis);
+
+  #ifdef BACKLASH_SMOOTHING_MM
+    const int32_t residual_error_axis = residual_error[axis];
+  #else
+    constexpr int32_t residual_error_axis = 0;
+  #endif
+
+  // At startup it is assumed the last move was forwards. So the applied
+  // steps will always be a non-positive number.
+
+  if (!reversing) return -residual_error_axis;
+
+  const float f_corr = float(correction) / 255.0f;
+  const int32_t full_error_axis = -f_corr * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+  return full_error_axis - residual_error_axis;
+}
+
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
 
   #include "../module/probe.h"
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
     if (measured_count.z == 255) return;
 
     const float start_height = current_position.z;
     while (current_position.z < (start_height + BACKLASH_MEASUREMENT_LIMIT) && PROBE_TRIGGERED())

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ‚ú® MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index b646e19f15..24c0f2ca0c 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -57,21 +57,21 @@ Backlash backlash;
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
 void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const axis_bits_t dm, block_t * const block) {
   static axis_bits_t last_direction_bits;
   axis_bits_t changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
-  #if DISABLED(CORE_BACKLASH) || ENABLED(MARKFORGED_XY)
+  #if DISABLED(CORE_BACKLASH) || EITHER(MARKFORGED_XY, MARKFORGED_YX)
     if (!da) CBI(changed_dir, X_AXIS);
     if (!db) CBI(changed_dir, Y_AXIS);
     if (!dc) CBI(changed_dir, Z_AXIS);
   #elif CORE_IS_XY
     if (!(da + db)) CBI(changed_dir, X_AXIS);
     if (!(da - db)) CBI(changed_dir, Y_AXIS);
     if (!dc)        CBI(changed_dir, Z_AXIS);
   #elif CORE_IS_XZ
     if (!(da + dc)) CBI(changed_dir, X_AXIS);
     if (!(da - dc)) CBI(changed_dir, Z_AXIS);

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 23dc973049..b646e19f15 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -53,23 +53,23 @@ Backlash backlash;
 
 /**
  * To minimize seams in the printed part, backlash correction only adds
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
-void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const uint8_t dm, block_t * const block) {
-  static uint8_t last_direction_bits;
-  uint8_t changed_dir = last_direction_bits ^ dm;
+void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const axis_bits_t dm, block_t * const block) {
+  static axis_bits_t last_direction_bits;
+  axis_bits_t changed_dir = last_direction_bits ^ dm;
   // Ignore direction change unless steps are taken in that direction
   #if DISABLED(CORE_BACKLASH) || ENABLED(MARKFORGED_XY)
     if (!da) CBI(changed_dir, X_AXIS);
     if (!db) CBI(changed_dir, Y_AXIS);
     if (!dc) CBI(changed_dir, Z_AXIS);
   #elif CORE_IS_XY
     if (!(da + db)) CBI(changed_dir, X_AXIS);
     if (!(da - db)) CBI(changed_dir, Y_AXIS);
     if (!dc)        CBI(changed_dir, Z_AXIS);
   #elif CORE_IS_XZ

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 5ab95d1577..23dc973049 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -127,26 +127,26 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
         }
       #endif
 
       // This correction reduces the residual error and adds block steps
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         #if ENABLED(CORE_BACKLASH)
           switch (axis) {
             case CORE_AXIS_1:
               //block->steps[CORE_AXIS_2] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_2];
-              //SERIAL_ECHOLNPAIR("CORE_AXIS_1 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
+              //SERIAL_ECHOLNPGM("CORE_AXIS_1 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
               //  " da=", da, " db=", db, " block->steps[axis]=", block->steps[axis], " err_corr=", error_correction);
               break;
             case CORE_AXIS_2:
               //block->steps[CORE_AXIS_1] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_1];;
-              //SERIAL_ECHOLNPAIR("CORE_AXIS_2 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
+              //SERIAL_ECHOLNPGM("CORE_AXIS_2 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
               //  " da=", da, " db=", db, " block->steps[axis]=", block->steps[axis], " err_corr=", error_correction);
               break;
             case NORMAL_AXIS: break;
           }
           residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
         #else
           residual_error[axis] -= error_correction;
         #endif
       }
     }

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 610cfcb565..5ab95d1577 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -97,21 +97,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
     static xyz_long_t residual_error{0};
   #else
     // No direction change, no correction.
     if (!changed_dir) return;
     // No leftover residual error from segment to segment
     xyz_long_t residual_error{0};
   #endif
 
   const float f_corr = float(correction) / 255.0f;
 
-  LOOP_XYZ(axis) {
+  LOOP_LINEAR_AXES(axis) {
     if (distance_mm[axis]) {
       const bool reversing = TEST(dm,axis);
 
       // When an axis changes direction, add axis backlash to the residual error
       if (TEST(changed_dir, axis))
         residual_error[axis] += (reversing ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       #ifdef BACKLASH_SMOOTHING_MM

commit 6f5800bd74e3e2e7db372c4fc4b51a36a7b7b351
Author: Nikolay March <palladin82@yandex.ru>
Date:   Sat Apr 24 12:38:00 2021 +0300

    Backlash Compensation for COREnn (#21612)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index b848214f0c..610cfcb565 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -56,24 +56,38 @@ Backlash backlash;
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
  * spread over multiple segments, smoothing out artifacts even more.
  */
 
 void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const uint8_t dm, block_t * const block) {
   static uint8_t last_direction_bits;
   uint8_t changed_dir = last_direction_bits ^ dm;
-  // Ignore direction change if no steps are taken in that direction
-  if (da == 0) CBI(changed_dir, X_AXIS);
-  if (db == 0) CBI(changed_dir, Y_AXIS);
-  if (dc == 0) CBI(changed_dir, Z_AXIS);
+  // Ignore direction change unless steps are taken in that direction
+  #if DISABLED(CORE_BACKLASH) || ENABLED(MARKFORGED_XY)
+    if (!da) CBI(changed_dir, X_AXIS);
+    if (!db) CBI(changed_dir, Y_AXIS);
+    if (!dc) CBI(changed_dir, Z_AXIS);
+  #elif CORE_IS_XY
+    if (!(da + db)) CBI(changed_dir, X_AXIS);
+    if (!(da - db)) CBI(changed_dir, Y_AXIS);
+    if (!dc)        CBI(changed_dir, Z_AXIS);
+  #elif CORE_IS_XZ
+    if (!(da + dc)) CBI(changed_dir, X_AXIS);
+    if (!(da - dc)) CBI(changed_dir, Z_AXIS);
+    if (!db)        CBI(changed_dir, Y_AXIS);
+  #elif CORE_IS_YZ
+    if (!(db + dc)) CBI(changed_dir, Y_AXIS);
+    if (!(db - dc)) CBI(changed_dir, Z_AXIS);
+    if (!da)        CBI(changed_dir, X_AXIS);
+  #endif
   last_direction_bits ^= changed_dir;
 
   if (correction == 0) return;
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
@@ -98,32 +112,49 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
       if (TEST(changed_dir, axis))
         residual_error[axis] += (reversing ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment, but only when
           // the current segment travels in the same direction as the correction
           if (reversing == (error_correction < 0)) {
-            if (segment_proportion == 0)
-              segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
+            if (segment_proportion == 0) segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
             error_correction = CEIL(segment_proportion * error_correction);
           }
           else
             error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
         }
       #endif
-      // Making a correction reduces the residual error and adds block steps
+
+      // This correction reduces the residual error and adds block steps
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
-        residual_error[axis] -= error_correction;
+        #if ENABLED(CORE_BACKLASH)
+          switch (axis) {
+            case CORE_AXIS_1:
+              //block->steps[CORE_AXIS_2] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_2];
+              //SERIAL_ECHOLNPAIR("CORE_AXIS_1 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
+              //  " da=", da, " db=", db, " block->steps[axis]=", block->steps[axis], " err_corr=", error_correction);
+              break;
+            case CORE_AXIS_2:
+              //block->steps[CORE_AXIS_1] += influence_distance_mm[axis] * planner.settings.axis_steps_per_mm[CORE_AXIS_1];;
+              //SERIAL_ECHOLNPAIR("CORE_AXIS_2 dir change. distance=", distance_mm[axis], " r.err=", residual_error[axis],
+              //  " da=", da, " db=", db, " block->steps[axis]=", block->steps[axis], " err_corr=", error_correction);
+              break;
+            case NORMAL_AXIS: break;
+          }
+          residual_error[axis] = 0; // No residual_error needed for next CORE block, I think...
+        #else
+          residual_error[axis] -= error_correction;
+        #endif
       }
     }
   }
 }
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
 
   #include "../module/probe.h"
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates

commit 58ac815822b4c04f29b66ddf076156e6b4994749
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Thu Nov 26 10:58:19 2020 -0300

    Level Corners with Probe option (#20241)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 867e9cdd21..b848214f0c 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -116,31 +116,29 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
       // Making a correction reduces the residual error and adds block steps
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         residual_error[axis] -= error_correction;
       }
     }
   }
 }
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-  #if HAS_CUSTOM_PROBE_PIN
-    #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
-  #else
-    #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
-  #endif
+
+  #include "../module/probe.h"
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
     if (measured_count.z == 255) return;
 
     const float start_height = current_position.z;
-    while (current_position.z < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
+    while (current_position.z < (start_height + BACKLASH_MEASUREMENT_LIMIT) && PROBE_TRIGGERED())
       do_blocking_move_to_z(current_position.z + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
 
     // The backlash from all probe points is averaged, so count the number of measurements
     measured_mm.z += current_position.z - start_height;
     measured_count.z++;
   }
+
 #endif
 
 #endif // BACKLASH_COMPENSATION

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index bc33ae3185..867e9cdd21 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"

commit adb6334ba031166e33f256344fc2b01e909cd99f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 17:55:36 2020 -0500

    Use "dist" instead of "delta" for clarity

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 84cd0a85b7..bc33ae3185 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -106,21 +106,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
           // the current segment travels in the same direction as the correction
           if (reversing == (error_correction < 0)) {
             if (segment_proportion == 0)
               segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
             error_correction = CEIL(segment_proportion * error_correction);
           }
           else
             error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
         }
       #endif
-      // Making a correction reduces the residual error and modifies delta_mm
+      // Making a correction reduces the residual error and adds block steps
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         residual_error[axis] -= error_correction;
       }
     }
   }
 }
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #if HAS_CUSTOM_PROBE_PIN

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 43e6d36bec..84cd0a85b7 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit fe4c69b64abc74bc1ee1eb16d3d3771e3afbf25d
Author: Piotr <peter_k@tut.by>
Date:   Tue Oct 15 21:28:04 2019 +0300

    Poll *all* enabled endstop pins (#15525)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index f1a14df49d..43e6d36bec 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -116,21 +116,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
       // Making a correction reduces the residual error and modifies delta_mm
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         residual_error[axis] -= error_correction;
       }
     }
   }
 }
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   #else
     #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   #endif
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
     if (measured_count.z == 255) return;
 
     const float start_height = current_position.z;

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 8f708c14f6..f1a14df49d 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -24,36 +24,36 @@
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"
 #include "../module/planner.h"
 
 #ifdef BACKLASH_DISTANCE_MM
   #if ENABLED(BACKLASH_GCODE)
-    float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
+    xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #else
-    const float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
+    const xyz_float_t Backlash::distance_mm = BACKLASH_DISTANCE_MM;
   #endif
 #endif
 
 #if ENABLED(BACKLASH_GCODE)
   uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
   #ifdef BACKLASH_SMOOTHING_MM
     float Backlash::smoothing_mm = BACKLASH_SMOOTHING_MM;
   #endif
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
-  float Backlash::measured_mm[XYZ] = { 0 };
-  uint8_t Backlash::measured_count[XYZ] = { 0 };
+  xyz_float_t Backlash::measured_mm{0};
+  xyz_uint8_t Backlash::measured_count{0};
 #endif
 
 Backlash backlash;
 
 /**
  * To minimize seams in the printed part, backlash correction only adds
  * steps to the current segment (instead of creating a new segment, which
  * causes discontinuities and print artifacts).
  *
  * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
@@ -73,26 +73,26 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
 
   #ifdef BACKLASH_SMOOTHING_MM
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
 
     // Residual error carried forward across multiple segments, so correction can be applied
     // to segments where there is no direction change.
-    static int32_t residual_error[XYZ] = { 0 };
+    static xyz_long_t residual_error{0};
   #else
     // No direction change, no correction.
     if (!changed_dir) return;
     // No leftover residual error from segment to segment
-    int32_t residual_error[XYZ] = { 0 };
+    xyz_long_t residual_error{0};
   #endif
 
   const float f_corr = float(correction) / 255.0f;
 
   LOOP_XYZ(axis) {
     if (distance_mm[axis]) {
       const bool reversing = TEST(dm,axis);
 
       // When an axis changes direction, add axis backlash to the residual error
       if (TEST(changed_dir, axis))
@@ -124,23 +124,23 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   #if USES_Z_MIN_PROBE_ENDSTOP
     #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   #else
     #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   #endif
 
   // Measure Z backlash by raising nozzle in increments until probe deactivates
   void Backlash::measure_with_probe() {
-    if (measured_count[Z_AXIS] == 255) return;
+    if (measured_count.z == 255) return;
 
-    float start_height = current_position[Z_AXIS];
-    while (current_position[Z_AXIS] < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
-      do_blocking_move_to_z(current_position[Z_AXIS] + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
+    const float start_height = current_position.z;
+    while (current_position.z < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
+      do_blocking_move_to_z(current_position.z + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
 
     // The backlash from all probe points is averaged, so count the number of measurements
-    measured_mm[Z_AXIS] += current_position[Z_AXIS] - start_height;
-    measured_count[Z_AXIS]++;
+    measured_mm.z += current_position.z - start_height;
+    measured_count.z++;
   }
 #endif
 
 #endif // BACKLASH_COMPENSATION

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 772d823b7b..8f708c14f6 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -99,21 +99,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
         residual_error[axis] += (reversing ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment, but only when
           // the current segment travels in the same direction as the correction
           if (reversing == (error_correction < 0)) {
             if (segment_proportion == 0)
-              segment_proportion = MIN(1.0f, block->millimeters / smoothing_mm);
+              segment_proportion = _MIN(1.0f, block->millimeters / smoothing_mm);
             error_correction = CEIL(segment_proportion * error_correction);
           }
           else
             error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
         }
       #endif
       // Making a correction reduces the residual error and modifies delta_mm
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         residual_error[axis] -= error_correction;

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 56701991e0..772d823b7b 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit cfca07852a8cfa5f15527b19d60093641f3063d4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 20 21:34:23 2019 -0500

    Backlash linker error workaround
    
    Fix #14045

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 67a4afb326..56701991e0 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -22,25 +22,30 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
 
 #include "../module/motion.h"
 #include "../module/planner.h"
 
-#if ENABLED(BACKLASH_GCODE)
-  uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
-  #ifdef BACKLASH_DISTANCE_MM
+#ifdef BACKLASH_DISTANCE_MM
+  #if ENABLED(BACKLASH_GCODE)
     float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
+  #else
+    const float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
   #endif
+#endif
+
+#if ENABLED(BACKLASH_GCODE)
+  uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
   #ifdef BACKLASH_SMOOTHING_MM
     float Backlash::smoothing_mm = BACKLASH_SMOOTHING_MM;
   #endif
 #endif
 
 #if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
   float Backlash::measured_mm[XYZ] = { 0 };
   uint8_t Backlash::measured_count[XYZ] = { 0 };
 #endif
 

commit aeec9ef76be19640dc0ca70c26fffadc445eba11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 20 21:34:08 2019 -0500

    Update backlash code

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
index 3254fb3f3c..67a4afb326 100644
--- a/Marlin/src/feature/backlash.cpp
+++ b/Marlin/src/feature/backlash.cpp
@@ -13,25 +13,27 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
-#include "../Marlin.h"
+#include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
 
 #include "backlash.h"
+
+#include "../module/motion.h"
 #include "../module/planner.h"
 
 #if ENABLED(BACKLASH_GCODE)
   uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
   #ifdef BACKLASH_DISTANCE_MM
     float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
   #endif
   #ifdef BACKLASH_SMOOTHING_MM
     float Backlash::smoothing_mm = BACKLASH_SMOOTHING_MM;
   #endif
@@ -68,24 +70,24 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
     // The segment proportion is a value greater than 0.0 indicating how much residual_error
     // is corrected for in this segment. The contribution is based on segment length and the
     // smoothing distance. Since the computation of this proportion involves a floating point
     // division, defer computation until needed.
     float segment_proportion = 0;
 
     // Residual error carried forward across multiple segments, so correction can be applied
     // to segments where there is no direction change.
     static int32_t residual_error[XYZ] = { 0 };
   #else
-    // No leftover residual error from segment to segment
-    int32_t residual_error[XYZ] = { 0 };
     // No direction change, no correction.
     if (!changed_dir) return;
+    // No leftover residual error from segment to segment
+    int32_t residual_error[XYZ] = { 0 };
   #endif
 
   const float f_corr = float(correction) / 255.0f;
 
   LOOP_XYZ(axis) {
     if (distance_mm[axis]) {
       const bool reversing = TEST(dm,axis);
 
       // When an axis changes direction, add axis backlash to the residual error
       if (TEST(changed_dir, axis))
@@ -93,21 +95,21 @@ void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const
 
       // Decide how much of the residual error to correct in this segment
       int32_t error_correction = residual_error[axis];
       #ifdef BACKLASH_SMOOTHING_MM
         if (error_correction && smoothing_mm != 0) {
           // Take up a portion of the residual_error in this segment, but only when
           // the current segment travels in the same direction as the correction
           if (reversing == (error_correction < 0)) {
             if (segment_proportion == 0)
               segment_proportion = MIN(1.0f, block->millimeters / smoothing_mm);
-            error_correction = ceil(segment_proportion * error_correction);
+            error_correction = CEIL(segment_proportion * error_correction);
           }
           else
             error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
         }
       #endif
       // Making a correction reduces the residual error and modifies delta_mm
       if (error_correction) {
         block->steps[axis] += ABS(error_correction);
         residual_error[axis] -= error_correction;
       }

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    ‚Ä¶And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/feature/backlash.cpp b/Marlin/src/feature/backlash.cpp
new file mode 100644
index 0000000000..3254fb3f3c
--- /dev/null
+++ b/Marlin/src/feature/backlash.cpp
@@ -0,0 +1,139 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../Marlin.h"
+
+#if ENABLED(BACKLASH_COMPENSATION)
+
+#include "backlash.h"
+#include "../module/planner.h"
+
+#if ENABLED(BACKLASH_GCODE)
+  uint8_t Backlash::correction = (BACKLASH_CORRECTION) * 0xFF;
+  #ifdef BACKLASH_DISTANCE_MM
+    float Backlash::distance_mm[XYZ] = BACKLASH_DISTANCE_MM;
+  #endif
+  #ifdef BACKLASH_SMOOTHING_MM
+    float Backlash::smoothing_mm = BACKLASH_SMOOTHING_MM;
+  #endif
+#endif
+
+#if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
+  float Backlash::measured_mm[XYZ] = { 0 };
+  uint8_t Backlash::measured_count[XYZ] = { 0 };
+#endif
+
+Backlash backlash;
+
+/**
+ * To minimize seams in the printed part, backlash correction only adds
+ * steps to the current segment (instead of creating a new segment, which
+ * causes discontinuities and print artifacts).
+ *
+ * With a non-zero BACKLASH_SMOOTHING_MM value the backlash correction is
+ * spread over multiple segments, smoothing out artifacts even more.
+ */
+
+void Backlash::add_correction_steps(const int32_t &da, const int32_t &db, const int32_t &dc, const uint8_t dm, block_t * const block) {
+  static uint8_t last_direction_bits;
+  uint8_t changed_dir = last_direction_bits ^ dm;
+  // Ignore direction change if no steps are taken in that direction
+  if (da == 0) CBI(changed_dir, X_AXIS);
+  if (db == 0) CBI(changed_dir, Y_AXIS);
+  if (dc == 0) CBI(changed_dir, Z_AXIS);
+  last_direction_bits ^= changed_dir;
+
+  if (correction == 0) return;
+
+  #ifdef BACKLASH_SMOOTHING_MM
+    // The segment proportion is a value greater than 0.0 indicating how much residual_error
+    // is corrected for in this segment. The contribution is based on segment length and the
+    // smoothing distance. Since the computation of this proportion involves a floating point
+    // division, defer computation until needed.
+    float segment_proportion = 0;
+
+    // Residual error carried forward across multiple segments, so correction can be applied
+    // to segments where there is no direction change.
+    static int32_t residual_error[XYZ] = { 0 };
+  #else
+    // No leftover residual error from segment to segment
+    int32_t residual_error[XYZ] = { 0 };
+    // No direction change, no correction.
+    if (!changed_dir) return;
+  #endif
+
+  const float f_corr = float(correction) / 255.0f;
+
+  LOOP_XYZ(axis) {
+    if (distance_mm[axis]) {
+      const bool reversing = TEST(dm,axis);
+
+      // When an axis changes direction, add axis backlash to the residual error
+      if (TEST(changed_dir, axis))
+        residual_error[axis] += (reversing ? -f_corr : f_corr) * distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+
+      // Decide how much of the residual error to correct in this segment
+      int32_t error_correction = residual_error[axis];
+      #ifdef BACKLASH_SMOOTHING_MM
+        if (error_correction && smoothing_mm != 0) {
+          // Take up a portion of the residual_error in this segment, but only when
+          // the current segment travels in the same direction as the correction
+          if (reversing == (error_correction < 0)) {
+            if (segment_proportion == 0)
+              segment_proportion = MIN(1.0f, block->millimeters / smoothing_mm);
+            error_correction = ceil(segment_proportion * error_correction);
+          }
+          else
+            error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
+        }
+      #endif
+      // Making a correction reduces the residual error and modifies delta_mm
+      if (error_correction) {
+        block->steps[axis] += ABS(error_correction);
+        residual_error[axis] -= error_correction;
+      }
+    }
+  }
+}
+
+#if ENABLED(MEASURE_BACKLASH_WHEN_PROBING)
+  #if USES_Z_MIN_PROBE_ENDSTOP
+    #define TEST_PROBE_PIN (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
+  #else
+    #define TEST_PROBE_PIN (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+  #endif
+
+  // Measure Z backlash by raising nozzle in increments until probe deactivates
+  void Backlash::measure_with_probe() {
+    if (measured_count[Z_AXIS] == 255) return;
+
+    float start_height = current_position[Z_AXIS];
+    while (current_position[Z_AXIS] < (start_height + BACKLASH_MEASUREMENT_LIMIT) && TEST_PROBE_PIN)
+      do_blocking_move_to_z(current_position[Z_AXIS] + BACKLASH_MEASUREMENT_RESOLUTION, MMM_TO_MMS(BACKLASH_MEASUREMENT_FEEDRATE));
+
+    // The backlash from all probe points is averaged, so count the number of measurements
+    measured_mm[Z_AXIS] += current_position[Z_AXIS] - start_height;
+    measured_count[Z_AXIS]++;
+  }
+#endif
+
+#endif // BACKLASH_COMPENSATION
