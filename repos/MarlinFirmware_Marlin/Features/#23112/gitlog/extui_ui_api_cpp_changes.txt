commit 4aff10785ee96a35eb4777c08b81722a59cecf68
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 18:46:38 2024 -0500

    üßë‚Äçüíª Use "enum class"

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1fcfabdd72..d89a09d8ad 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1212,21 +1212,21 @@ namespace ExtUI {
       strcpy_P(msg, FTOP(fstr));
       onStatusChanged(msg);
     #else
       onStatusChanged(FTOP(fstr));
     #endif
   }
 
   void onSurviveInKilled() {
     thermalManager.disable_all_heaters();
     flags.printer_killed = 0;
-    marlin_state = MF_RUNNING;
+    marlin_state = MarlinState::MF_RUNNING;
     //SERIAL_ECHOLNPGM("survived at: ", millis());
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if HAS_MEDIA
       if (!skip_range_check && (pos + 1) > count()) return false;

commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    üö∏ MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 29f9b34fe4..1fcfabdd72 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1272,20 +1272,23 @@ namespace ExtUI {
   }
 
 } // namespace ExtUI
 
 //
 // MarlinUI passthroughs to ExtUI
 //
 #if DISABLED(HAS_DWIN_E3V2)
   void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
+  void MarlinUI::clear_lcd() {}
+  void MarlinUI::clear_for_drawing() {}
+
   void MarlinUI::update() { ExtUI::onIdle(); }
 
   void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
     using namespace ExtUI;
     if (!flags.printer_killed) {
       flags.printer_killed = true;
       onPrinterKilled(error, component);
     }
   }
 #endif

commit ab0173b7e6843f1a6328658e2de742b3bc52ce1b
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 2 15:45:19 2024 -0400

    üö∏ ExtUI: Shaping, Probing limits (#26754)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 5c7246d4cd..29f9b34fe4 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -758,20 +758,38 @@ namespace ExtUI {
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[E_INDEX_N(extruder - E0)] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const_float_t value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[E_INDEX_N(extruder - E0)] = constrain(value, 0, 10);
     }
   #endif
 
+  #if HAS_SHAPING
+    float getShapingZeta(const axis_t axis) {
+      return stepper.get_shaping_damping_ratio(AxisEnum(axis));
+    }
+    void setShapingZeta(const float zeta, const axis_t axis) {
+      if (!WITHIN(zeta, 0, 1)) return;
+      stepper.set_shaping_damping_ratio(AxisEnum(axis), zeta);
+    }
+    float getShapingFrequency(const axis_t axis) {
+      return stepper.get_shaping_frequency(AxisEnum(axis));
+    }
+    void setShapingFrequency(const float freq, const axis_t axis) {
+      constexpr float min_freq = float(uint32_t(STEPPER_TIMER_RATE) / 2) / shaping_time_t(-2);
+      if (freq == 0.0f || freq > min_freq)
+        stepper.set_shaping_frequency(AxisEnum(axis), freq);
+    }
+  #endif
+
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() { return planner.junction_deviation_mm; }
 
     void setJunctionDeviation_mm(const_float_t value) {
       planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
@@ -926,20 +944,21 @@ namespace ExtUI {
     void normalizeNozzleOffset(const axis_t axis) {
       const float offs = hotend_offset[0][axis];
       HOTEND_LOOP() hotend_offset[e][axis] -= offs;
     }
 
   #endif // HAS_HOTEND_OFFSET
 
   #if HAS_BED_PROBE
     float getProbeOffset_mm(const axis_t axis) { return probe.offset.pos[axis]; }
     void setProbeOffset_mm(const_float_t val, const axis_t axis) { probe.offset.pos[axis] = val; }
+    probe_limits_t getBedProbeLimits() { return probe_limits_t({ probe.min_x(), probe.min_y(), probe.max_x(), probe.max_y() }); }
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash.get_distance_mm((AxisEnum)axis); }
     void setAxisBacklash_mm(const_float_t value, const axis_t axis)
                                                       { backlash.set_distance_mm((AxisEnum)axis, constrain(value,0,5)); }
 
     float getBacklashCorrection_percent()             { return backlash.get_correction() * 100.0f; }
     void setBacklashCorrection_percent(const_float_t value) { backlash.set_correction(constrain(value, 0, 100) / 100.0f); }
 

commit 521e7eafce4921a36532e0a89f2cc7417c2c4e21
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 21 15:42:56 2024 -0500

    üßë‚Äçüíª Clarify media "mounted"

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 74463bdf5c..5c7246d4cd 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1162,21 +1162,21 @@ namespace ExtUI {
   bool isPrintingFromMedia() { return TERN0(HAS_MEDIA, IS_SD_PRINTING() || IS_SD_PAUSED()); }
 
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
-  bool isMediaInserted() { return TERN0(HAS_MEDIA, IS_SD_INSERTED()); }
+  bool isMediaMounted() { return TERN0(HAS_MEDIA, card.isMounted()); }
 
   // Pause/Resume/Stop are implemented in MarlinUI
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
   // Simplest approach is to make an SRAM copy
   void onUserConfirmRequired(FSTR_P const fstr) {
     #ifdef __AVR__
       char msg[strlen_P(FTOP(fstr)) + 1];

commit 5f96dffb9b50baf1e730c21405a573ad45b45e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 15 15:21:39 2024 -0500

    üßë‚Äçüíª FLOAT_SQ macro

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index ec9b05318c..74463bdf5c 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -336,21 +336,21 @@ namespace ExtUI {
 
   void setAxisPosition_mm(const_float_t position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
-        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
+        max = SQRT(FLOAT_SQ(PRINTABLE_RADIUS) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
     line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
   void setAxisPosition_mm(const_float_t position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 9d0b7e2723..ec9b05318c 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -99,21 +99,21 @@
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "../../feature/babystep.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
-#if M600_PURGE_MORE_RESUMABLE
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../../feature/pause.h"
 #endif
 
 namespace ExtUI {
   static struct {
     bool printer_killed : 1;
     #if ENABLED(JOYSTICK)
       bool jogging : 1;
     #endif
   } flags;
@@ -1109,24 +1109,53 @@ namespace ExtUI {
 
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() { thermalManager.cooldown(); }
 
   bool awaitingUserConfirm() {
     return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || TERN0(HOST_KEEPALIVE_FEATURE, getHostKeepaliveIsPaused());
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
-  #if M600_PURGE_MORE_RESUMABLE
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
-    PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
     PauseMode getPauseMode() { return pause_mode; }
+
+    PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
+
+    void stdOnPauseMode(
+      const PauseMessage message,
+      const PauseMode mode/*=PAUSE_MODE_SAME*/,
+      const uint8_t extruder/*=active_extruder*/
+    ) {
+      if (mode != PAUSE_MODE_SAME) pause_mode = mode;
+      pauseModeStatus = message;
+      switch (message) {
+        case PAUSE_MESSAGE_PARKING:  onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING)); break;
+        case PAUSE_MESSAGE_CHANGING: onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT)); break;
+        case PAUSE_MESSAGE_UNLOAD:   onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
+        case PAUSE_MESSAGE_WAITING:  onUserConfirmRequired(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING)); break;
+        case PAUSE_MESSAGE_INSERT:   onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
+        case PAUSE_MESSAGE_LOAD:     onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD)); break;
+        case PAUSE_MESSAGE_PURGE:    onUserConfirmRequired(
+                                       GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE))
+                                     );
+                                     break;
+        case PAUSE_MESSAGE_RESUME:   onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
+        case PAUSE_MESSAGE_HEAT:     onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT)); break;
+        case PAUSE_MESSAGE_HEATING:  onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
+        case PAUSE_MESSAGE_OPTION:   onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_OPTION_HEADER)); break;
+        case PAUSE_MESSAGE_STATUS:   break;
+        default: break;
+      }
+    }
+
   #endif
 
   void printFile(const char *filename) {
     TERN(HAS_MEDIA, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
     return TERN0(HAS_MEDIA, IS_SD_PAUSED());
   }
 
@@ -1221,24 +1250,37 @@ namespace ExtUI {
 
   void FileList::changeDir(const char * const dirname) {
     TERN(HAS_MEDIA, card.cd(dirname), UNUSED(dirname));
   }
 
 } // namespace ExtUI
 
 //
 // MarlinUI passthroughs to ExtUI
 //
+#if DISABLED(HAS_DWIN_E3V2)
+  void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
-void MarlinUI::init_lcd() { ExtUI::onStartup(); }
+  void MarlinUI::update() { ExtUI::onIdle(); }
 
-void MarlinUI::update() { ExtUI::onIdle(); }
+  void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
+    using namespace ExtUI;
+    if (!flags.printer_killed) {
+      flags.printer_killed = true;
+      onPrinterKilled(error, component);
+    }
+  }
+#endif
 
-void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
-  using namespace ExtUI;
-  if (!flags.printer_killed) {
-    flags.printer_killed = true;
-    onPrinterKilled(error, component);
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void MarlinUI::pause_show_message(
+    const PauseMessage message,
+    const PauseMode mode/*=PAUSE_MODE_SAME*/,
+    const uint8_t extruder/*=active_extruder*/
+  ) {
+    ExtUI::onPauseMode(message, mode, extruder);
   }
-}
+
+#endif
 
 #endif // EXTENSIBLE_UI

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 2ba01a694d..9d0b7e2723 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -13,23 +13,23 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
-/**************
- * ui_api.cpp *
- **************/
+/*************************************
+ * ui_api.cpp - Shared ExtUI methods *
+ *************************************/
 
 /****************************************************************************
  *   Written By Marcio Teixeira 2018 - Aleph Objects, Inc.                  *
  *                                                                          *
  *   This program is free software: you can redistribute it and/or modify   *
  *   it under the terms of the GNU General Public License as published by   *
  *   the Free Software Foundation, either version 3 of the License, or      *
  *   (at your option) any later version.                                    *
  *                                                                          *
  *   This program is distributed in the hope that it will be useful,        *
@@ -1112,21 +1112,21 @@ namespace ExtUI {
   void coolDown() { thermalManager.cooldown(); }
 
   bool awaitingUserConfirm() {
     return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || TERN0(HOST_KEEPALIVE_FEATURE, getHostKeepaliveIsPaused());
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
     PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
-    PauseMode getPauseMode() { return pause_mode;}
+    PauseMode getPauseMode() { return pause_mode; }
   #endif
 
   void printFile(const char *filename) {
     TERN(HAS_MEDIA, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
     return TERN0(HAS_MEDIA, IS_SD_PAUSED());
   }
 
@@ -1218,21 +1218,23 @@ namespace ExtUI {
   void FileList::upDir() {
     TERN_(HAS_MEDIA, card.cdup());
   }
 
   void FileList::changeDir(const char * const dirname) {
     TERN(HAS_MEDIA, card.cd(dirname), UNUSED(dirname));
   }
 
 } // namespace ExtUI
 
-// At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
+//
+// MarlinUI passthroughs to ExtUI
+//
 
 void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ‚ú® EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 19f4903cc6..2ba01a694d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -665,30 +665,32 @@ namespace ExtUI {
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
-  void setAxisSteps_per_mm(const_float_t value, const axis_t axis) {
-    planner.settings.axis_steps_per_mm[axis] = value;
-    planner.refresh_positioning();
-  }
+  #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+    void setAxisSteps_per_mm(const_float_t value, const axis_t axis) {
+      planner.settings.axis_steps_per_mm[axis] = value;
+      planner.refresh_positioning();
+    }
 
-  void setAxisSteps_per_mm(const_float_t value, const extruder_t extruder) {
-    UNUSED(extruder);
-    planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
-    planner.refresh_positioning();
-  }
+    void setAxisSteps_per_mm(const_float_t value, const extruder_t extruder) {
+      UNUSED(extruder);
+      planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
+      planner.refresh_positioning();
+    }
+  #endif
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(extruder - E0)];
   }
 

commit cb044d989c397fcbf6f106502df69a7e5c41d34b
Author: Vladimir Sitnikov <sitnikov.vladimir@gmail.com>
Date:   Sun Nov 5 09:46:57 2023 +0300

    ‚ú® Probe XY Offset value limits (#26267)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index bccc543b7f..19f4903cc6 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -888,21 +888,21 @@ namespace ExtUI {
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
         planner.mm_per_step[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #else
         0.0f
       #endif
     );
   }
 
   void setZOffset_mm(const_float_t value) {
     #if HAS_BED_PROBE
-      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
+      if (WITHIN(value, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, value - getZOffset_mm());
     #else
       UNUSED(value);
     #endif
   }
 
   #if HAS_HOTEND_OFFSET
 

commit be031e18509884c42051fba6849af06e089e383f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 3 14:57:07 2023 -0500

    üìù More ExtUI documentation

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7f21610728..bccc543b7f 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -165,49 +165,20 @@ namespace ExtUI {
     if (flags.printer_killed)
       DELAY_US(ms * 1000);
     else
       safe_delay(ms);
   }
 
   void yield() {
     if (!flags.printer_killed) thermalManager.task();
   }
 
-  void enableHeater(const extruder_t extruder) {
-    #if HAS_HOTEND && HEATER_IDLE_HANDLER
-      thermalManager.reset_hotend_idle_timer(extruder - E0);
-    #else
-      UNUSED(extruder);
-    #endif
-  }
-
-  void enableHeater(const heater_t heater) {
-    #if HEATER_IDLE_HANDLER
-      switch (heater) {
-        #if HAS_HEATED_BED
-          case BED: thermalManager.reset_bed_idle_timer(); return;
-        #endif
-        #if HAS_HEATED_CHAMBER
-          case CHAMBER: return; // Chamber has no idle timer
-        #endif
-        #if HAS_COOLER
-          case COOLER: return;  // Cooler has no idle timer
-        #endif
-        default:
-          TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
-          break;
-      }
-    #else
-      UNUSED(heater);
-    #endif
-  }
-
   #if ENABLED(JOYSTICK)
     /**
      * Jogs in the direction given by the vector (dx, dy, dz).
      * The values range from -1 to 1 mapping to the maximum
      * feedrate for an axis.
      *
      * The axis will continue to jog until this function is
      * called with all zeros.
      */
     void jog(const xyz_float_t &dir) {
@@ -230,20 +201,53 @@ namespace ExtUI {
           // ran GCODE that wrote a position to destination.
           // To prevent a disaster, stop jogging.
           flags.jogging = false;
           return;
         }
         norm_jog = destination;
       }
     }
   #endif
 
+  //
+  // Heaters locked / idle
+  //
+
+  void enableHeater(const extruder_t extruder) {
+    #if HAS_HOTEND && HEATER_IDLE_HANDLER
+      thermalManager.reset_hotend_idle_timer(extruder - E0);
+    #else
+      UNUSED(extruder);
+    #endif
+  }
+
+  void enableHeater(const heater_t heater) {
+    #if HEATER_IDLE_HANDLER
+      switch (heater) {
+        #if HAS_HEATED_BED
+          case BED: thermalManager.reset_bed_idle_timer(); return;
+        #endif
+        #if HAS_HEATED_CHAMBER
+          case CHAMBER: return; // Chamber has no idle timer
+        #endif
+        #if HAS_COOLER
+          case COOLER: return;  // Cooler has no idle timer
+        #endif
+        default:
+          TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
+          break;
+      }
+    #else
+      UNUSED(heater);
+    #endif
+  }
+
   bool isHeaterIdle(const extruder_t extruder) {
     #if HAS_HOTEND && HEATER_IDLE_HANDLER
       return thermalManager.heater_idle[extruder - E0].timed_out;
     #else
       UNUSED(extruder);
       return false;
     #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
@@ -295,30 +299,36 @@ namespace ExtUI {
         case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   celsius_float_t getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
+  //
+  // Fan target/actual speed
+  //
   float getTargetFan_percent(const fan_t fan) {
     UNUSED(fan);
     return TERN0(HAS_FAN, thermalManager.fanSpeedPercent(fan - FAN0));
   }
 
   float getActualFan_percent(const fan_t fan) {
     UNUSED(fan);
     return TERN0(HAS_FAN, thermalManager.scaledFanSpeedPercent(fan - FAN0));
   }
 
+  //
+  // High level axis and extruder positions
+  //
   float getAxisPosition_mm(const axis_t axis) {
     return current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN0(JOYSTICK, flags.jogging) ? destination.e : current_position.e;
     setActiveTool(old_tool, true);
     return epos;
@@ -342,20 +352,23 @@ namespace ExtUI {
     line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
   void setAxisPosition_mm(const_float_t position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
     line_to_current_position(feedrate ?: manual_feedrate_mm_s.e);
   }
 
+  //
+  // Tool changing
+  //
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if HAS_MULTI_EXTRUDER
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);
       UNUSED(no_move);
     #endif
   }
@@ -363,49 +376,69 @@ namespace ExtUI {
   extruder_t getTool(const uint8_t extruder) {
     switch (extruder) {
       default:
       case 0: return E0; case 1: return E1; case 2: return E2; case 3: return E3;
       case 4: return E4; case 5: return E5; case 6: return E6; case 7: return E7;
     }
   }
 
   extruder_t getActiveTool() { return getTool(active_extruder); }
 
+  //
+  // Moving axes and extruders
+  //
   bool isMoving() { return planner.has_blocks_queued(); }
 
+  //
+  // Motion might be blocked by NO_MOTION_BEFORE_HOMING
+  //
   bool canMove(const axis_t axis) {
     switch (axis) {
-      #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
+      #if ANY(IS_KINEMATIC, NO_MOTION_BEFORE_HOMING)
         OPTCODE(HAS_X_AXIS, case X: return !axis_should_home(X_AXIS))
         OPTCODE(HAS_Y_AXIS, case Y: return !axis_should_home(Y_AXIS))
         OPTCODE(HAS_Z_AXIS, case Z: return !axis_should_home(Z_AXIS))
       #else
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
+  //
+  // E Motion might be prevented by cold material
+  //
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
+  //
+  // Host Keepalive, used by awaitingUserConfirm
+  //
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     GcodeSuite::MarlinBusyState getHostKeepaliveState() { return gcode.busy_state; }
     bool getHostKeepaliveIsPaused() { return gcode.host_keepalive_is_paused(); }
   #endif
 
+  //
+  // Soft Endstops Enabled/Disabled State
+  //
+
   #if HAS_SOFTWARE_ENDSTOPS
     bool getSoftEndstopState() { return soft_endstop._enabled; }
     void setSoftEndstopState(const bool value) { soft_endstop._enabled = value; }
   #endif
 
+  //
+  // Trinamic Current / Bump Sensitivity
+  //
+
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: return stepperX.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y)
           case Y: return stepperY.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
@@ -619,20 +652,24 @@ namespace ExtUI {
         #endif
         #if Z4_SENSORLESS
           case Z4: stepperZ4.homing_threshold(value); break;
         #endif
         default: break;
       }
       UNUSED(value);
     }
   #endif
 
+  //
+  // Planner Accessors / Setters
+  //
+
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisSteps_per_mm(const_float_t value, const axis_t axis) {
@@ -1096,20 +1133,21 @@ namespace ExtUI {
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(HAS_MEDIA, IS_SD_INSERTED()); }
 
+  // Pause/Resume/Stop are implemented in MarlinUI
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
   // Simplest approach is to make an SRAM copy
   void onUserConfirmRequired(FSTR_P const fstr) {
     #ifdef __AVR__
       char msg[strlen_P(FTOP(fstr)) + 1];
       strcpy_P(msg, FTOP(fstr));
       onUserConfirmRequired(msg);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1d917df7cd..7f21610728 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -926,21 +926,21 @@ namespace ExtUI {
       bed_mesh_t& getMeshArray() { return bedlevel.z_values; }
       float getMeshPoint(const xy_uint8_t &pos) { return bedlevel.z_values[pos.x][pos.y]; }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
           bedlevel.z_values[pos.x][pos.y] = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bedlevel.refresh_bed_level());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
-        #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
+        #if ANY(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           REMEMBER(fr, feedrate_mm_s);
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position.x || y_target != current_position.y) {
             // If moving across bed, raise nozzle to safe height over bed
             feedrate_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
             destination.set(current_position.x, current_position.y, Z_CLEARANCE_BETWEEN_PROBES);
             prepare_line_to_destination();
             feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
             destination.set(x_target, y_target);

commit 9e0dcd4a2b6d0262ee2b09170aff0c1f21d9175e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 1 16:53:02 2023 -0500

    üßë‚Äçüíª ExtUI::onLevelingStart/Done for all leveling (#25913)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index fb77be94af..1d917df7cd 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -912,21 +912,21 @@ namespace ExtUI {
 
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
 
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
-    bool getMeshValid() { return leveling_is_valid(); }
+    bool getLevelingIsValid() { return leveling_is_valid(); }
 
     #if HAS_MESH
 
       bed_mesh_t& getMeshArray() { return bedlevel.z_values; }
       float getMeshPoint(const xy_uint8_t &pos) { return bedlevel.z_values[pos.x][pos.y]; }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
           bedlevel.z_values[pos.x][pos.y] = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bedlevel.refresh_bed_level());
         }

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index a742a82a5b..fb77be94af 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -368,21 +368,21 @@ namespace ExtUI {
     }
   }
 
   extruder_t getActiveTool() { return getTool(active_extruder); }
 
   bool isMoving() { return planner.has_blocks_queued(); }
 
   bool canMove(const axis_t axis) {
     switch (axis) {
       #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-        case X: return !axis_should_home(X_AXIS);
+        OPTCODE(HAS_X_AXIS, case X: return !axis_should_home(X_AXIS))
         OPTCODE(HAS_Y_AXIS, case Y: return !axis_should_home(Y_AXIS))
         OPTCODE(HAS_Z_AXIS, case Z: return !axis_should_home(Z_AXIS))
       #else
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
@@ -766,21 +766,23 @@ namespace ExtUI {
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const_float_t acc) { planner.settings.acceleration = acc; }
   void setRetractAcceleration_mm_s2(const_float_t acc) { planner.settings.retract_acceleration = acc; }
   void setTravelAcceleration_mm_s2(const_float_t acc)  { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
 
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
-          case X: babystep.add_steps(X_AXIS, steps); break;
+          #if HAS_X_AXIS
+            case X: babystep.add_steps(X_AXIS, steps); break;
+          #endif
           #if HAS_Y_AXIS
             case Y: babystep.add_steps(Y_AXIS, steps); break;
           #endif
         #endif
         #if HAS_Z_AXIS
           case Z: babystep.add_steps(Z_AXIS, steps); break;
         #endif
         default: return false;
       };
       return true;
@@ -811,21 +813,21 @@ namespace ExtUI {
         /**
          * When linked_nozzles is false, as an axis is babystepped
          * adjust the hotend offsets so that the other nozzles are
          * unaffected by the babystepping of the active nozzle.
          */
         if (!linked_nozzles) {
           HOTEND_LOOP()
             if (e != active_extruder)
               hotend_offset[e][axis] += mm;
 
-          normalizeNozzleOffset(X);
+          TERN_(HAS_X_AXIS, normalizeNozzleOffset(X));
           TERN_(HAS_Y_AXIS, normalizeNozzleOffset(Y));
           TERN_(HAS_Z_AXIS, normalizeNozzleOffset(Z));
         }
       #else
         UNUSED(linked_nozzles);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 2b1f05d2bc..a742a82a5b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1075,38 +1075,38 @@ namespace ExtUI {
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
     PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
     PauseMode getPauseMode() { return pause_mode;}
   #endif
 
   void printFile(const char *filename) {
-    TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
+    TERN(HAS_MEDIA, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
-    return TERN0(SDSUPPORT, IS_SD_PAUSED());
+    return TERN0(HAS_MEDIA, IS_SD_PAUSED());
   }
 
-  bool isPrintingFromMedia() { return TERN0(SDSUPPORT, IS_SD_PRINTING() || IS_SD_PAUSED()); }
+  bool isPrintingFromMedia() { return TERN0(HAS_MEDIA, IS_SD_PRINTING() || IS_SD_PAUSED()); }
 
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
-  bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED()); }
+  bool isMediaInserted() { return TERN0(HAS_MEDIA, IS_SD_INSERTED()); }
 
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
   // Simplest approach is to make an SRAM copy
   void onUserConfirmRequired(FSTR_P const fstr) {
     #ifdef __AVR__
       char msg[strlen_P(FTOP(fstr)) + 1];
       strcpy_P(msg, FTOP(fstr));
@@ -1131,61 +1131,61 @@ namespace ExtUI {
     flags.printer_killed = 0;
     marlin_state = MF_RUNNING;
     //SERIAL_ECHOLNPGM("survived at: ", millis());
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       if (!skip_range_check && (pos + 1) > count()) return false;
       card.selectFileByIndexSorted(pos);
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
-    return TERN(SDSUPPORT, card.longest_filename(), "");
+    return TERN(HAS_MEDIA, card.longest_filename(), "");
   }
 
   const char* FileList::shortFilename() {
-    return TERN(SDSUPPORT, card.filename, "");
+    return TERN(HAS_MEDIA, card.filename, "");
   }
 
   const char* FileList::longFilename() {
-    return TERN(SDSUPPORT, card.longFilename, "");
+    return TERN(HAS_MEDIA, card.longFilename, "");
   }
 
   bool FileList::isDir() {
-    return TERN0(SDSUPPORT, card.flag.filenameIsDir);
+    return TERN0(HAS_MEDIA, card.flag.filenameIsDir);
   }
 
   uint16_t FileList::count() {
-    return TERN0(SDSUPPORT, card.get_num_items());
+    return TERN0(HAS_MEDIA, card.get_num_items());
   }
 
   bool FileList::isAtRootDir() {
-    return TERN1(SDSUPPORT, card.flag.workDirIsRoot);
+    return TERN1(HAS_MEDIA, card.flag.workDirIsRoot);
   }
 
   void FileList::upDir() {
-    TERN_(SDSUPPORT, card.cdup());
+    TERN_(HAS_MEDIA, card.cdup());
   }
 
   void FileList::changeDir(const char * const dirname) {
-    TERN(SDSUPPORT, card.cd(dirname), UNUSED(dirname));
+    TERN(HAS_MEDIA, card.cd(dirname), UNUSED(dirname));
   }
 
 } // namespace ExtUI
 
 // At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
 
 void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 

commit 161b99cb54f5d6d183877902581d3d77e8a1fa78
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 01:08:51 2023 -0500

    üêõ Fix some bad feedrates (#25672)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7e47bef9c1..2b1f05d2bc 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -925,36 +925,35 @@ namespace ExtUI {
       float getMeshPoint(const xy_uint8_t &pos) { return bedlevel.z_values[pos.x][pos.y]; }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
           bedlevel.z_values[pos.x][pos.y] = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bedlevel.refresh_bed_level());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
-          const feedRate_t old_feedrate = feedrate_mm_s;
+          REMEMBER(fr, feedrate_mm_s);
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position.x || y_target != current_position.y) {
             // If moving across bed, raise nozzle to safe height over bed
-            feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
+            feedrate_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
             destination.set(current_position.x, current_position.y, Z_CLEARANCE_BETWEEN_PROBES);
             prepare_line_to_destination();
-            feedrate_mm_s = XY_PROBE_FEEDRATE;
+            feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
             destination.set(x_target, y_target);
             prepare_line_to_destination();
           }
-          feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
+          feedrate_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
           destination.z = z;
           prepare_line_to_destination();
-          feedrate_mm_s = old_feedrate;
         #else
           UNUSED(pos);
           UNUSED(z);
         #endif
       }
 
     #endif // HAS_MESH
 
   #endif // HAS_LEVELING
 

commit 06e5273d24776219253a9229621c034ab263cba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 18:18:25 2023 -0500

    üßë‚Äçüíª CardReader adjustments (#25611)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 5c27b345c4..7e47bef9c1 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1129,26 +1129,26 @@ namespace ExtUI {
 
   void onSurviveInKilled() {
     thermalManager.disable_all_heaters();
     flags.printer_killed = 0;
     marlin_state = MF_RUNNING;
     //SERIAL_ECHOLNPGM("survived at: ", millis());
   }
 
   FileList::FileList() { refresh(); }
 
-  void FileList::refresh() { num_files = 0xFFFF; }
+  void FileList::refresh() { }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
-      card.getfilename_sorted(SD_ORDER(pos, count()));
+      card.selectFileByIndexSorted(pos);
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
     return TERN(SDSUPPORT, card.longest_filename(), "");
@@ -1160,41 +1160,33 @@ namespace ExtUI {
 
   const char* FileList::longFilename() {
     return TERN(SDSUPPORT, card.longFilename, "");
   }
 
   bool FileList::isDir() {
     return TERN0(SDSUPPORT, card.flag.filenameIsDir);
   }
 
   uint16_t FileList::count() {
-    return TERN0(SDSUPPORT, (num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)));
+    return TERN0(SDSUPPORT, card.get_num_items());
   }
 
   bool FileList::isAtRootDir() {
     return TERN1(SDSUPPORT, card.flag.workDirIsRoot);
   }
 
   void FileList::upDir() {
-    #if ENABLED(SDSUPPORT)
-      card.cdup();
-      num_files = 0xFFFF;
-    #endif
+    TERN_(SDSUPPORT, card.cdup());
   }
 
   void FileList::changeDir(const char * const dirname) {
-    #if ENABLED(SDSUPPORT)
-      card.cd(dirname);
-      num_files = 0xFFFF;
-    #else
-      UNUSED(dirname);
-    #endif
+    TERN(SDSUPPORT, card.cd(dirname), UNUSED(dirname));
   }
 
 } // namespace ExtUI
 
 // At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
 
 void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 

commit 0021a58943721a81b1ef23fa5e7366cfd80a3d28
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 26 04:07:25 2023 -0500

    ‚ú® AnyCubic Vyper / Vyper LCD (#25405)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1075816c43..5c27b345c4 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -105,23 +105,23 @@
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 #if M600_PURGE_MORE_RESUMABLE
   #include "../../feature/pause.h"
 #endif
 
 namespace ExtUI {
   static struct {
-    uint8_t printer_killed : 1;
+    bool printer_killed : 1;
     #if ENABLED(JOYSTICK)
-      uint8_t jogging : 1;
+      bool jogging : 1;
     #endif
   } flags;
 
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
      * within an ISR (such as when the printer is killed).
      *
      * To keep proper time, must be called at least every 1s.
      */
@@ -919,21 +919,21 @@ namespace ExtUI {
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
 
     #if HAS_MESH
 
       bed_mesh_t& getMeshArray() { return bedlevel.z_values; }
       float getMeshPoint(const xy_uint8_t &pos) { return bedlevel.z_values[pos.x][pos.y]; }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
           bedlevel.z_values[pos.x][pos.y] = zoff;
-          TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
+          TERN_(ABL_BILINEAR_SUBDIVISION, bedlevel.refresh_bed_level());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position.x || y_target != current_position.y) {
             // If moving across bed, raise nozzle to safe height over bed
@@ -1120,20 +1120,27 @@ namespace ExtUI {
   void onStatusChanged(FSTR_P const fstr) {
     #ifdef __AVR__
       char msg[strlen_P(FTOP(fstr)) + 1];
       strcpy_P(msg, FTOP(fstr));
       onStatusChanged(msg);
     #else
       onStatusChanged(FTOP(fstr));
     #endif
   }
 
+  void onSurviveInKilled() {
+    thermalManager.disable_all_heaters();
+    flags.printer_killed = 0;
+    marlin_state = MF_RUNNING;
+    //SERIAL_ECHOLNPGM("survived at: ", millis());
+  }
+
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
       card.getfilename_sorted(SD_ORDER(pos, count()));
       return card.filename[0] != '\0';
     #else

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index da04c9bc8b..1075816c43 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -836,25 +836,27 @@ namespace ExtUI {
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
 
     float mmFromWholeSteps(int16_t steps, const axis_t axis) {
       return steps * planner.mm_per_step[axis];
     }
 
   #endif // BABYSTEPPING
 
   float getZOffset_mm() {
-    return (0.0f
+    return (
       #if HAS_BED_PROBE
-        + probe.offset.z
+        probe.offset.z
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-        + planner.mm_per_step[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
+        planner.mm_per_step[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
+      #else
+        0.0f
       #endif
     );
   }
 
   void setZOffset_mm(const_float_t value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, value - getZOffset_mm());

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 4422e8115d..da04c9bc8b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -326,21 +326,21 @@ namespace ExtUI {
 
   void setAxisPosition_mm(const_float_t position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
-        max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
+        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
     line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
   void setAxisPosition_mm(const_float_t position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);

commit e3e07354d5ff98293f87d532fdd1c384d8e0b2e2
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon Nov 21 16:25:56 2022 -0700

    Fix FAST_PWM_FAN / TouchUI with NO_MOTION_BEFORE_HOMING (#25005)
    
    Fix regressions from #20323, #23463

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 967fb1021d..4422e8115d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -368,23 +368,23 @@ namespace ExtUI {
     }
   }
 
   extruder_t getActiveTool() { return getTool(active_extruder); }
 
   bool isMoving() { return planner.has_blocks_queued(); }
 
   bool canMove(const axis_t axis) {
     switch (axis) {
       #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-        case X: return axis_should_home(X_AXIS);
-        OPTCODE(HAS_Y_AXIS, case Y: return axis_should_home(Y_AXIS))
-        OPTCODE(HAS_Z_AXIS, case Z: return axis_should_home(Z_AXIS))
+        case X: return !axis_should_home(X_AXIS);
+        OPTCODE(HAS_Y_AXIS, case Y: return !axis_should_home(Y_AXIS))
+        OPTCODE(HAS_Z_AXIS, case Z: return !axis_should_home(Z_AXIS))
       #else
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }

commit efde96131d9e9288dc2ea28b548f691a184fb33e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Oct 10 20:49:37 2022 +0200

    ‚ú® ADVANCE_K per-extruder (#24821)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index f4d02d8cca..967fb1021d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -705,31 +705,31 @@ namespace ExtUI {
       float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
       void setCaseLightBrightness_percent(const_float_t value) {
          caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
          caselight.update_brightness();
       }
     #endif
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     bool getPowerLossRecoveryEnabled()                 { return recovery.enabled; }
-    void setPowerLossRecoveryEnabled(const bool value) {  recovery.enable(value); }
+    void setPowerLossRecoveryEnabled(const bool value) { recovery.enable(value); }
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
-      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
+      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[E_INDEX_N(extruder - E0)] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const_float_t value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
-        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
+        planner.extruder_advance_K[E_INDEX_N(extruder - E0)] = constrain(value, 0, 10);
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() { return planner.junction_deviation_mm; }
 
     void setJunctionDeviation_mm(const_float_t value) {
       planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index a711e6dd57..f4d02d8cca 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -969,46 +969,40 @@ namespace ExtUI {
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
       return buffer;
     }
   #endif
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
   #if ENABLED(PIDTEMP)
-    float getPIDValues_Kp(const extruder_t tool) { return PID_PARAM(Kp, tool); }
-    float getPIDValues_Ki(const extruder_t tool) { return unscalePID_i(PID_PARAM(Ki, tool)); }
-    float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
-
-    void setPIDValues(const_float_t p, const_float_t i, const_float_t d, extruder_t tool) {
-      thermalManager.temp_hotend[tool].pid.Kp = p;
-      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
-      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
-      thermalManager.updatePID();
+    float getPID_Kp(const extruder_t tool) { return thermalManager.temp_hotend[tool].pid.p(); }
+    float getPID_Ki(const extruder_t tool) { return thermalManager.temp_hotend[tool].pid.i(); }
+    float getPID_Kd(const extruder_t tool) { return thermalManager.temp_hotend[tool].pid.d(); }
+
+    void setPID(const_float_t p, const_float_t i, const_float_t d, extruder_t tool) {
+      thermalManager.setPID(uint8_t(tool), p, i, d);
     }
 
     void startPIDTune(const celsius_t temp, extruder_t tool) {
-      thermalManager.PID_autotune(temp, (heater_id_t)tool, 8, true);
+      thermalManager.PID_autotune(temp, heater_id_t(tool), 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
-    float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
-    float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
-    float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
-
-    void setBedPIDValues(const_float_t p, const_float_t i, const_float_t d) {
-      thermalManager.temp_bed.pid.Kp = p;
-      thermalManager.temp_bed.pid.Ki = scalePID_i(i);
-      thermalManager.temp_bed.pid.Kd = scalePID_d(d);
-      thermalManager.updatePID();
+    float getBedPID_Kp() { return thermalManager.temp_bed.pid.p(); }
+    float getBedPID_Ki() { return thermalManager.temp_bed.pid.i(); }
+    float getBedPID_Kd() { return thermalManager.temp_bed.pid.d(); }
+
+    void setBedPID(const_float_t p, const_float_t i, const_float_t d) {
+      thermalManager.temp_bed.pid.set(p, i, d);
     }
 
     void startBedPIDTune(const celsius_t temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
   void injectCommands(char * const gcode)  { queue.inject(gcode); }
 

commit 90b56452238f8ab673f564b657b979fd6a3a224b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 26 21:15:44 2022 -0500

    ü©π Fix lcd_preheat compile

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 57822279c5..a711e6dd57 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1069,21 +1069,21 @@ namespace ExtUI {
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() { thermalManager.cooldown(); }
 
   bool awaitingUserConfirm() {
-    return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || getHostKeepaliveIsPaused();
+    return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || TERN0(HOST_KEEPALIVE_FEATURE, getHostKeepaliveIsPaused());
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
     PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
     PauseMode getPauseMode() { return pause_mode;}
   #endif
 
   void printFile(const char *filename) {

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 68b0a81fe5..57822279c5 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -162,21 +162,21 @@ namespace ExtUI {
   void delay_us(uint32_t us) { DELAY_US(us); }
 
   void delay_ms(uint32_t ms) {
     if (flags.printer_killed)
       DELAY_US(ms * 1000);
     else
       safe_delay(ms);
   }
 
   void yield() {
-    if (!flags.printer_killed) thermalManager.manage_heater();
+    if (!flags.printer_killed) thermalManager.task();
   }
 
   void enableHeater(const extruder_t extruder) {
     #if HAS_HOTEND && HEATER_IDLE_HANDLER
       thermalManager.reset_hotend_idle_timer(extruder - E0);
     #else
       UNUSED(extruder);
     #endif
   }
 

commit 640282b8dc5de4ccdfb607b99e795d3eaa1334a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 13 20:43:23 2022 -0500

    üßë‚Äçüíª Apply F() to some LCD / TFT strings
    
    Followup to #24228

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 143f240c2d..68b0a81fe5 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1105,29 +1105,37 @@ namespace ExtUI {
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED()); }
 
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
   // Simplest approach is to make an SRAM copy
   void onUserConfirmRequired(FSTR_P const fstr) {
-    char msg[strlen_P(FTOP(fstr)) + 1];
-    strcpy_P(msg, FTOP(fstr));
-    onUserConfirmRequired(msg);
+    #ifdef __AVR__
+      char msg[strlen_P(FTOP(fstr)) + 1];
+      strcpy_P(msg, FTOP(fstr));
+      onUserConfirmRequired(msg);
+    #else
+      onUserConfirmRequired(FTOP(fstr));
+    #endif
   }
 
   void onStatusChanged(FSTR_P const fstr) {
-    char msg[strlen_P(FTOP(fstr)) + 1];
-    strcpy_P(msg, FTOP(fstr));
-    onStatusChanged(msg);
+    #ifdef __AVR__
+      char msg[strlen_P(FTOP(fstr)) + 1];
+      strcpy_P(msg, FTOP(fstr));
+      onStatusChanged(msg);
+    #else
+      onStatusChanged(FTOP(fstr));
+    #endif
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
       card.getfilename_sorted(SD_ORDER(pos, count()));

commit a59766195cd19e6cded497499044bed76137d8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 28 15:24:09 2022 -0500

    üé® Use pos.set method

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index bba03fc6d4..143f240c2d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -929,26 +929,24 @@ namespace ExtUI {
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position.x || y_target != current_position.y) {
             // If moving across bed, raise nozzle to safe height over bed
             feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
-            destination = current_position;
-            destination.z = Z_CLEARANCE_BETWEEN_PROBES;
+            destination.set(current_position.x, current_position.y, Z_CLEARANCE_BETWEEN_PROBES);
             prepare_line_to_destination();
             feedrate_mm_s = XY_PROBE_FEEDRATE;
-            destination.x = x_target;
-            destination.y = y_target;
+            destination.set(x_target, y_target);
             prepare_line_to_destination();
           }
           feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
           destination.z = z;
           prepare_line_to_destination();
           feedrate_mm_s = old_feedrate;
         #else
           UNUSED(pos);
           UNUSED(z);
         #endif

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 5d25be938c..bba03fc6d4 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -912,25 +912,25 @@ namespace ExtUI {
   }
 
   #if HAS_LEVELING
 
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
 
     #if HAS_MESH
 
-      bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
-      float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
+      bed_mesh_t& getMeshArray() { return bedlevel.z_values; }
+      float getMeshPoint(const xy_uint8_t &pos) { return bedlevel.z_values[pos.x][pos.y]; }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
-          Z_VALUES(pos.x, pos.y) = zoff;
+          bedlevel.z_values[pos.x][pos.y] = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position.x || y_target != current_position.y) {

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1da46d7e47..5d25be938c 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -649,39 +649,39 @@ namespace ExtUI {
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
-    planner.set_max_feedrate(axis, value);
+    planner.set_max_feedrate((AxisEnum)axis, value);
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
     UNUSED(extruder);
     planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
   }
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxAcceleration_mm_s2(const_float_t value, const axis_t axis) {
-    planner.set_max_acceleration(axis, value);
+    planner.set_max_acceleration((AxisEnum)axis, value);
   }
 
   void setAxisMaxAcceleration_mm_s2(const_float_t value, const extruder_t extruder) {
     UNUSED(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 0dad675cb7..1da46d7e47 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -413,20 +413,29 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(I)
           case I: return stepperI.getMilliamps();
         #endif
         #if AXIS_IS_TMC(J)
           case J: return stepperJ.getMilliamps();
         #endif
         #if AXIS_IS_TMC(K)
           case K: return stepperK.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(U)
+          case U: return stepperU.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(V)
+          case V: return stepperV.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(W)
+          case W: return stepperW.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(X2)
           case X2: return stepperX2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: return stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: return stepperZ2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z3)
@@ -482,20 +491,29 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(I)
           case I: stepperI.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(J)
           case J: stepperJ.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(K)
           case K: stepperK.rms_current(constrain(mA, 400, 1500)); break;
         #endif
+        #if AXIS_IS_TMC(U)
+          case U: stepperU.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(V)
+          case V: stepperV.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(W)
+          case W: stepperW.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: stepperY2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z3)
@@ -539,20 +557,23 @@ namespace ExtUI {
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
         OPTCODE(X_SENSORLESS,  case X:  return stepperX.homing_threshold())
         OPTCODE(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold())
         OPTCODE(Z_SENSORLESS,  case Z:  return stepperZ.homing_threshold())
         OPTCODE(I_SENSORLESS,  case I:  return stepperI.homing_threshold())
         OPTCODE(J_SENSORLESS,  case J:  return stepperJ.homing_threshold())
         OPTCODE(K_SENSORLESS,  case K:  return stepperK.homing_threshold())
+        OPTCODE(U_SENSORLESS,  case U:  return stepperU.homing_threshold())
+        OPTCODE(V_SENSORLESS,  case V:  return stepperV.homing_threshold())
+        OPTCODE(W_SENSORLESS,  case W:  return stepperW.homing_threshold())
         OPTCODE(X2_SENSORLESS, case X2: return stepperX2.homing_threshold())
         OPTCODE(Y2_SENSORLESS, case Y2: return stepperY2.homing_threshold())
         OPTCODE(Z2_SENSORLESS, case Z2: return stepperZ2.homing_threshold())
         OPTCODE(Z3_SENSORLESS, case Z3: return stepperZ3.homing_threshold())
         OPTCODE(Z4_SENSORLESS, case Z4: return stepperZ4.homing_threshold())
         default: return 0;
       }
     }
 
     void setTMCBumpSensitivity(const_float_t value, const axis_t axis) {
@@ -568,20 +589,29 @@ namespace ExtUI {
         #endif
         #if I_SENSORLESS
           case I: stepperI.homing_threshold(value); break;
         #endif
         #if J_SENSORLESS
           case J: stepperJ.homing_threshold(value); break;
         #endif
         #if K_SENSORLESS
           case K: stepperK.homing_threshold(value); break;
         #endif
+        #if U_SENSORLESS
+          case U: stepperU.homing_threshold(value); break;
+        #endif
+        #if V_SENSORLESS
+          case V: stepperV.homing_threshold(value); break;
+        #endif
+        #if W_SENSORLESS
+          case W: stepperW.homing_threshold(value); break;
+        #endif
         #if X2_SENSORLESS
           case X2: stepperX2.homing_threshold(value); break;
         #endif
         #if Y2_SENSORLESS
           case Y2: stepperY2.homing_threshold(value); break;
         #endif
         #if Z2_SENSORLESS
           case Z2: stepperZ2.homing_threshold(value); break;
         #endif
         #if Z3_SENSORLESS

commit de87f5309da712a94da984d611bf1265bdce880c
Author: Julien Staub <atsju2@yahoo.fr>
Date:   Sun Mar 13 23:09:32 2022 +0100

    ü©π Fix ExtUI build with Host Keepalive disabled (#23898)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index bfcbc39d7b..0dad675cb7 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -382,22 +382,24 @@ namespace ExtUI {
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
-  GcodeSuite::MarlinBusyState getHostKeepaliveState() { return TERN0(HOST_KEEPALIVE_FEATURE, gcode.busy_state); }
-  bool getHostKeepaliveIsPaused() { return TERN0(HOST_KEEPALIVE_FEATURE, gcode.host_keepalive_is_paused()); }
+  #if ENABLED(HOST_KEEPALIVE_FEATURE)
+    GcodeSuite::MarlinBusyState getHostKeepaliveState() { return gcode.busy_state; }
+    bool getHostKeepaliveIsPaused() { return gcode.host_keepalive_is_paused(); }
+  #endif
 
   #if HAS_SOFTWARE_ENDSTOPS
     bool getSoftEndstopState() { return soft_endstop._enabled; }
     void setSoftEndstopState(const bool value) { soft_endstop._enabled = value; }
   #endif
 
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)

commit 6b7868d943cd08b83af085ea0d507cc8433799c6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Mar 1 22:14:52 2022 +0000

    üêõ Fix backlash applied steps when config changes (#23826)
    
    Followup to #23814

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index f44e8bf720..bfcbc39d7b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -854,30 +854,30 @@ namespace ExtUI {
     }
 
   #endif // HAS_HOTEND_OFFSET
 
   #if HAS_BED_PROBE
     float getProbeOffset_mm(const axis_t axis) { return probe.offset.pos[axis]; }
     void setProbeOffset_mm(const_float_t val, const axis_t axis) { probe.offset.pos[axis] = val; }
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
-    float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
+    float getAxisBacklash_mm(const axis_t axis)       { return backlash.get_distance_mm((AxisEnum)axis); }
     void setAxisBacklash_mm(const_float_t value, const axis_t axis)
-                                                      { backlash.distance_mm[axis] = constrain(value,0,5); }
+                                                      { backlash.set_distance_mm((AxisEnum)axis, constrain(value,0,5)); }
 
-    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
-    void setBacklashCorrection_percent(const_float_t value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
+    float getBacklashCorrection_percent()             { return backlash.get_correction() * 100.0f; }
+    void setBacklashCorrection_percent(const_float_t value) { backlash.set_correction(constrain(value, 0, 100) / 100.0f); }
 
     #ifdef BACKLASH_SMOOTHING_MM
-      float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
-      void setBacklashSmoothing_mm(const_float_t value) { backlash.smoothing_mm = constrain(value, 0, 999); }
+      float getBacklashSmoothing_mm()                 { return backlash.get_smoothing_mm(); }
+      void setBacklashSmoothing_mm(const_float_t value) { backlash.set_smoothing_mm(constrain(value, 0, 999)); }
     #endif
   #endif
 
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
 

commit c2fa7e594200a18856e61dcaaa8ef1a689a5121c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Feb 7 17:24:18 2022 -0500

    PLR accessors for Ext UI (#23687)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index f2763c893f..f44e8bf720 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -87,20 +87,24 @@
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "../../feature/runout.h"
 #endif
 
 #if ENABLED(CASE_LIGHT_ENABLE)
   #include "../../feature/caselight.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../feature/powerloss.h"
+#endif
+
 #if ENABLED(BABYSTEPPING)
   #include "../../feature/babystep.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 #if M600_PURGE_MORE_RESUMABLE
   #include "../../feature/pause.h"
@@ -667,20 +671,25 @@ namespace ExtUI {
 
     #if CASELIGHT_USES_BRIGHTNESS
       float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
       void setCaseLightBrightness_percent(const_float_t value) {
          caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
          caselight.update_brightness();
       }
     #endif
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    bool getPowerLossRecoveryEnabled()                 { return recovery.enabled; }
+    void setPowerLossRecoveryEnabled(const bool value) {  recovery.enable(value); }
+  #endif
+
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const_float_t value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
     }
   #endif

commit d5f2334140e6f8ead29d3648b371547ebe72c7aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 22 10:14:47 2022 -0600

    ‚ôªÔ∏è Adjust LCD init, contrast default, settings load

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 54e7db55c2..f2763c893f 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1137,21 +1137,21 @@ namespace ExtUI {
       num_files = 0xFFFF;
     #else
       UNUSED(dirname);
     #endif
   }
 
 } // namespace ExtUI
 
 // At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
 
-void MarlinUI::init() { ExtUI::onStartup(); }
+void MarlinUI::init_lcd() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 
 void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);
   }
 }

commit 70e31bff45165dd07375cd6140fc0a72468e0894
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:36:06 2021 -0500

    üé® Standard 'cooldown' method

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7ce89c922a..54e7db55c2 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1027,24 +1027,21 @@ namespace ExtUI {
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
-  void coolDown() {
-    thermalManager.disable_all_heaters();
-    TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
-  }
+  void coolDown() { thermalManager.cooldown(); }
 
   bool awaitingUserConfirm() {
     return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || getHostKeepaliveIsPaused();
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
     PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
     PauseMode getPauseMode() { return pause_mode;}

commit b09038fcc72bc8df4ec8a7014597586e0b0390ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 20:01:44 2021 -0500

    üé® Standard material presets behavior

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7358cbce23..7ce89c922a 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1028,24 +1028,21 @@ namespace ExtUI {
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() {
-    #if HAS_HOTEND
-      HOTEND_LOOP() thermalManager.setTargetHotend(0, e);
-    #endif
-    TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
+    thermalManager.disable_all_heaters();
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
   bool awaitingUserConfirm() {
     return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || getHostKeepaliveIsPaused();
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }

commit 1d80464ba77bc576426f15af28a633bf48d769ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:15:58 2021 -0500

    üé® Define HAS_PREHEAT conditional

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 72dab6f35e..7358cbce23 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -698,21 +698,21 @@ namespace ExtUI {
     float getAxisMaxJerk_mm_s(const axis_t axis) { return planner.max_jerk[axis]; }
     float getAxisMaxJerk_mm_s(const extruder_t) { return planner.max_jerk.e; }
     void setAxisMaxJerk_mm_s(const_float_t value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
     void setAxisMaxJerk_mm_s(const_float_t value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     uint8_t getIDEX_Mode() { return dual_x_carriage_mode; }
   #endif
 
-  #if PREHEAT_COUNT
+  #if HAS_PREHEAT
     uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
     #if HAS_HEATED_BED
       uint16_t getMaterial_preset_B(const uint16_t index) { return ui.material_preset[index].bed_temp; }
     #endif
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
   int16_t getFlow_percent(const extruder_t extr)      { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }

commit ee28a14e8e7f6b33fe5813dbedcd85380207c345
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 15 00:24:08 2021 -0500

    üé® Refactor Host Actions as singleton

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 8e588ef8c2..72dab6f35e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -911,21 +911,21 @@ namespace ExtUI {
           UNUSED(pos);
           UNUSED(z);
         #endif
       }
 
     #endif // HAS_MESH
 
   #endif // HAS_LEVELING
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
-    void setHostResponse(const uint8_t response) { host_response_handler(response); }
+    void setHostResponse(const uint8_t response) { hostui.handle_response(response); }
   #endif
 
   #if ENABLED(PRINTCOUNTER)
     char* getFailedPrints_str(char buffer[21])   { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints - print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }
     char* getLongestPrint_str(char buffer[21])   { return duration_t(print_job_timer.getStats().longestPrint).toString(buffer); }
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index afd762a470..8e588ef8c2 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1070,20 +1070,21 @@ namespace ExtUI {
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED()); }
 
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
+  // Simplest approach is to make an SRAM copy
   void onUserConfirmRequired(FSTR_P const fstr) {
     char msg[strlen_P(FTOP(fstr)) + 1];
     strcpy_P(msg, FTOP(fstr));
     onUserConfirmRequired(msg);
   }
 
   void onStatusChanged(FSTR_P const fstr) {
     char msg[strlen_P(FTOP(fstr)) + 1];
     strcpy_P(msg, FTOP(fstr));
     onStatusChanged(msg);
@@ -1146,19 +1147,19 @@ namespace ExtUI {
   }
 
 } // namespace ExtUI
 
 // At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
 
 void MarlinUI::init() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 
-void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
+void MarlinUI::kill_screen(FSTR_P const error, FSTR_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);
   }
 }
 
 #endif // EXTENSIBLE_UI

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    üé® Apply F() to some ExtUI functions

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index d37b277110..afd762a470 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1070,29 +1070,29 @@ namespace ExtUI {
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED()); }
 
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
-  void onUserConfirmRequired_P(PGM_P const pstr) {
-    char msg[strlen_P(pstr) + 1];
-    strcpy_P(msg, pstr);
+  void onUserConfirmRequired(FSTR_P const fstr) {
+    char msg[strlen_P(FTOP(fstr)) + 1];
+    strcpy_P(msg, FTOP(fstr));
     onUserConfirmRequired(msg);
   }
 
-  void onStatusChanged_P(PGM_P const pstr) {
-    char msg[strlen_P(pstr) + 1];
-    strcpy_P(msg, pstr);
+  void onStatusChanged(FSTR_P const fstr) {
+    char msg[strlen_P(FTOP(fstr)) + 1];
+    strcpy_P(msg, FTOP(fstr));
     onStatusChanged(msg);
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 97b1ab885b..d37b277110 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -748,21 +748,21 @@ namespace ExtUI {
     /**
      * This function adjusts an axis during a print.
      *
      * When linked_nozzles is false, each nozzle in a multi-nozzle
      * printer can be babystepped independently of the others. This
      * lets the user to fine tune the Z-offset and Nozzle Offsets
      * while observing the first layer of a print, regardless of
      * what nozzle is printing.
      */
     void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
-      const float mm = steps * planner.steps_to_mm[axis];
+      const float mm = steps * planner.mm_per_step[axis];
       UNUSED(mm);
 
       if (!babystepAxis_steps(steps, axis)) return;
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         // Make it so babystepping in Z adjusts the Z probe offset.
         if (axis == Z && TERN1(HAS_MULTI_EXTRUDER, (linked_nozzles || active_extruder == 0)))
           probe.offset.z += mm;
       #endif
 
@@ -784,36 +784,36 @@ namespace ExtUI {
       #else
         UNUSED(linked_nozzles);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
     int16_t mmToWholeSteps(const_float_t mm, const axis_t axis) {
-      const float steps = mm / planner.steps_to_mm[axis];
+      const float steps = mm / planner.mm_per_step[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
 
     float mmFromWholeSteps(int16_t steps, const axis_t axis) {
-      return steps * planner.steps_to_mm[axis];
+      return steps * planner.mm_per_step[axis];
     }
 
   #endif // BABYSTEPPING
 
   float getZOffset_mm() {
     return (0.0f
       #if HAS_BED_PROBE
         + probe.offset.z
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-        + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
+        + planner.mm_per_step[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #endif
     );
   }
 
   void setZOffset_mm(const_float_t value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, value - getZOffset_mm());

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index b838299b18..97b1ab885b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -416,20 +416,26 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: return stepperX2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: return stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: return stepperZ2.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(Z3)
+          case Z3: return stepperZ3.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z4)
+          case Z4: return stepperZ4.getMilliamps();
+        #endif
         default: return NAN;
       };
     }
 
     float getAxisCurrent_mA(const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: return stepperE0.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E1)
@@ -479,20 +485,26 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: stepperY2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
+        #if AXIS_IS_TMC(Z3)
+          case Z3: stepperZ3.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Z4)
+          case Z4: stepperZ4.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
         default: break;
       };
     }
 
     void setAxisCurrent_mA(const_float_t mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: stepperE0.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E1)

commit 08a40c43750eb49521849792520d8d819c0fcd29
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Sep 16 03:46:16 2021 -0400

    ‚ú® Improve pause/filament change for ExtUI (#22655)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 4ef96251bc..b838299b18 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1030,20 +1030,22 @@ namespace ExtUI {
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
   bool awaitingUserConfirm() {
     return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || getHostKeepaliveIsPaused();
   }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   #if M600_PURGE_MORE_RESUMABLE
     void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
+    PauseMessage pauseModeStatus = PAUSE_MESSAGE_STATUS;
+    PauseMode getPauseMode() { return pause_mode;}
   #endif
 
   void printFile(const char *filename) {
     TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
     return TERN0(SDSUPPORT, IS_SD_PAUSED());
   }
 

commit 315a722b420226be0c07c05abf95a5b666caf1e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 12 22:52:17 2021 -0500

    üêõ TM3D fixes and improvements
    
    Co-Authored-By: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7173790262..4ef96251bc 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1050,21 +1050,21 @@ namespace ExtUI {
   bool isPrintingFromMedia() { return TERN0(SDSUPPORT, IS_SD_PRINTING() || IS_SD_PAUSED()); }
 
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
-  bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED() && card.isMounted()); }
+  bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED()); }
 
   void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint()   { ui.abort_print(); }
 
   void onUserConfirmRequired_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);
     onUserConfirmRequired(msg);
   }

commit 3ba5eda0b28498a3e557669496e0d6ffec875876
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Jul 9 19:24:14 2021 -0400

    üì∫ ExtUI pause state response (#22164)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index df73527812..7173790262 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -95,20 +95,24 @@
 #endif
 
 #if ENABLED(BABYSTEPPING)
   #include "../../feature/babystep.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
+#if M600_PURGE_MORE_RESUMABLE
+  #include "../../feature/pause.h"
+#endif
+
 namespace ExtUI {
   static struct {
     uint8_t printer_killed : 1;
     #if ENABLED(JOYSTICK)
       uint8_t jogging : 1;
     #endif
   } flags;
 
   #ifdef __SAM3X8E__
     /**
@@ -374,21 +378,22 @@ namespace ExtUI {
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
-  GcodeSuite::MarlinBusyState getMachineBusyState() { return TERN0(HOST_KEEPALIVE_FEATURE, GcodeSuite::busy_state); }
+  GcodeSuite::MarlinBusyState getHostKeepaliveState() { return TERN0(HOST_KEEPALIVE_FEATURE, gcode.busy_state); }
+  bool getHostKeepaliveIsPaused() { return TERN0(HOST_KEEPALIVE_FEATURE, gcode.host_keepalive_is_paused()); }
 
   #if HAS_SOFTWARE_ENDSTOPS
     bool getSoftEndstopState() { return soft_endstop._enabled; }
     void setSoftEndstopState(const bool value) { soft_endstop._enabled = value; }
   #endif
 
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
@@ -1018,23 +1023,29 @@ namespace ExtUI {
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() {
     #if HAS_HOTEND
       HOTEND_LOOP() thermalManager.setTargetHotend(0, e);
     #endif
     TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
-  bool awaitingUserConfirm() { return TERN0(HAS_RESUME_CONTINUE, wait_for_user); }
+  bool awaitingUserConfirm() {
+    return TERN0(HAS_RESUME_CONTINUE, wait_for_user) || getHostKeepaliveIsPaused();
+  }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
+  #if M600_PURGE_MORE_RESUMABLE
+    void setPauseMenuResponse(PauseMenuResponse response) { pause_menu_response = response; }
+  #endif
+
   void printFile(const char *filename) {
     TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
     return TERN0(SDSUPPORT, IS_SD_PAUSED());
   }
 
   bool isPrintingFromMedia() { return TERN0(SDSUPPORT, IS_SD_PRINTING() || IS_SD_PAUSED()); }
 

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    üé® Check flags without ENABLED

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 00b785e680..df73527812 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -171,24 +171,24 @@ namespace ExtUI {
       UNUSED(extruder);
     #endif
   }
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
           case BED: thermalManager.reset_bed_idle_timer(); return;
         #endif
-        #if ENABLED(HAS_HEATED_CHAMBER)
+        #if HAS_HEATED_CHAMBER
           case CHAMBER: return; // Chamber has no idle timer
         #endif
-        #if ENABLED(HAS_COOLER)
+        #if HAS_COOLER
           case COOLER: return;  // Cooler has no idle timer
         #endif
         default:
           TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
@@ -234,63 +234,63 @@ namespace ExtUI {
       return thermalManager.heater_idle[extruder - E0].timed_out;
     #else
       UNUSED(extruder);
       return false;
     #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
-        #if ENABLED(HAS_HEATED_BED)
+        #if HAS_HEATED_BED
           case BED: return thermalManager.heater_idle[thermalManager.IDLE_INDEX_BED].timed_out;
         #endif
-        #if ENABLED(HAS_HEATED_CHAMBER)
+        #if HAS_HEATED_CHAMBER
           case CHAMBER: return false; // Chamber has no idle timer
         #endif
         default:
           return TERN0(HAS_HOTEND, thermalManager.heater_idle[heater - H0].timed_out);
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) (float(A) / (TOUCH_UI_LCD_TEMP_SCALING))
   #else
     #define GET_TEMP_ADJUSTMENT(A) A
   #endif
 
   celsius_float_t getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
-      #if ENABLED(HAS_HEATED_BED)
+      #if HAS_HEATED_BED
         case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
       #endif
-      #if ENABLED(HAS_HEATED_CHAMBER)
+      #if HAS_HEATED_CHAMBER
         case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
   }
 
   celsius_float_t getActualTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
   }
 
   celsius_float_t getTargetTemp_celsius(const heater_t heater) {
     switch (heater) {
-      #if ENABLED(HAS_HEATED_BED)
+      #if HAS_HEATED_BED
         case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
       #endif
-      #if ENABLED(HAS_HEATED_CHAMBER)
+      #if HAS_HEATED_CHAMBER
         case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   celsius_float_t getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 

commit a37cc76cb93c4e8c1337ec8ecd8f966b0c33d555
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Fri Jun 25 22:38:27 2021 -0600

    üé® Fix and improve FTDI Eve Touch UI (#22223)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 53eb6d399e..00b785e680 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -298,21 +298,21 @@ namespace ExtUI {
     UNUSED(fan);
     return TERN0(HAS_FAN, thermalManager.fanSpeedPercent(fan - FAN0));
   }
 
   float getActualFan_percent(const fan_t fan) {
     UNUSED(fan);
     return TERN0(HAS_FAN, thermalManager.scaledFanSpeedPercent(fan - FAN0));
   }
 
   float getAxisPosition_mm(const axis_t axis) {
-    return TERN0(JOYSTICK, flags.jogging) ? destination[axis] : current_position[axis];
+    return current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN0(JOYSTICK, flags.jogging) ? destination.e : current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 

commit 0f5126acb23a9a363c97a3c6a387c6842f2c55cd
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon Jun 21 15:38:28 2021 -0600

    üé® Fix and enhance FTDI Eve Touch UI (#22189)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index ddeb02e3be..53eb6d399e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1026,24 +1026,24 @@ namespace ExtUI {
   }
 
   bool awaitingUserConfirm() { return TERN0(HAS_RESUME_CONTINUE, wait_for_user); }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   void printFile(const char *filename) {
     TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
-    return TERN0(SDSUPPORT, isPrintingFromMedia() && printingIsPaused());
+    return TERN0(SDSUPPORT, IS_SD_PAUSED());
   }
 
-  bool isPrintingFromMedia() { return IS_SD_PRINTING(); }
+  bool isPrintingFromMedia() { return TERN0(SDSUPPORT, IS_SD_PRINTING() || IS_SD_PAUSED()); }
 
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED() && card.isMounted()); }

commit a3e8bb99e472042c7db0b2d0be8d515ee715cf28
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 13 23:08:46 2021 -0400

    üé® ExtUI "user click" and other tweaks (#22122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index b0def618fd..ddeb02e3be 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -40,20 +40,21 @@
  *   To view a copy of the GNU General Public License, go to the following  *
  *   location: <https://www.gnu.org/licenses/>.                             *
  ****************************************************************************/
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(EXTENSIBLE_UI)
 
 #include "../marlinui.h"
 #include "../../gcode/queue.h"
+#include "../../gcode/gcode.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
 #include "../../MarlinCore.h"
 #include "../../sd/cardreader.h"
 
@@ -346,75 +347,81 @@ namespace ExtUI {
       if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);
       UNUSED(no_move);
     #endif
   }
 
   extruder_t getTool(const uint8_t extruder) {
     switch (extruder) {
-      case 7:  return E7;
-      case 6:  return E6;
-      case 5:  return E5;
-      case 4:  return E4;
-      case 3:  return E3;
-      case 2:  return E2;
-      case 1:  return E1;
-      default: return E0;
+      default:
+      case 0: return E0; case 1: return E1; case 2: return E2; case 3: return E3;
+      case 4: return E4; case 5: return E5; case 6: return E6; case 7: return E7;
     }
   }
 
   extruder_t getActiveTool() { return getTool(active_extruder); }
 
   bool isMoving() { return planner.has_blocks_queued(); }
 
   bool canMove(const axis_t axis) {
     switch (axis) {
       #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
         case X: return axis_should_home(X_AXIS);
-        case Y: return axis_should_home(Y_AXIS);
-        case Z: return axis_should_home(Z_AXIS);
+        OPTCODE(HAS_Y_AXIS, case Y: return axis_should_home(Y_AXIS))
+        OPTCODE(HAS_Z_AXIS, case Z: return axis_should_home(Z_AXIS))
       #else
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
+  GcodeSuite::MarlinBusyState getMachineBusyState() { return TERN0(HOST_KEEPALIVE_FEATURE, GcodeSuite::busy_state); }
+
   #if HAS_SOFTWARE_ENDSTOPS
     bool getSoftEndstopState() { return soft_endstop._enabled; }
     void setSoftEndstopState(const bool value) { soft_endstop._enabled = value; }
   #endif
 
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: return stepperX.getMilliamps();
         #endif
-        #if AXIS_IS_TMC(X2)
-          case X2: return stepperX2.getMilliamps();
-        #endif
         #if AXIS_IS_TMC(Y)
           case Y: return stepperY.getMilliamps();
         #endif
-        #if AXIS_IS_TMC(Y2)
-          case Y2: return stepperY2.getMilliamps();
-        #endif
         #if AXIS_IS_TMC(Z)
           case Z: return stepperZ.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(I)
+          case I: return stepperI.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(J)
+          case J: return stepperJ.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(K)
+          case K: return stepperK.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(X2)
+          case X2: return stepperX2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          case Y2: return stepperY2.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: return stepperZ2.getMilliamps();
         #endif
         default: return NAN;
       };
     }
 
     float getAxisCurrent_mA(const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
@@ -443,32 +450,41 @@ namespace ExtUI {
         #endif
         default: return NAN;
       };
     }
 
     void setAxisCurrent_mA(const_float_t mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
         #endif
-        #if AXIS_IS_TMC(X2)
-          case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
-        #endif
         #if AXIS_IS_TMC(Y)
           case Y: stepperY.rms_current(constrain(mA, 400, 1500)); break;
         #endif
-        #if AXIS_IS_TMC(Y2)
-          case Y2: stepperY2.rms_current(constrain(mA, 400, 1500)); break;
-        #endif
         #if AXIS_IS_TMC(Z)
           case Z: stepperZ.rms_current(constrain(mA, 400, 1500)); break;
         #endif
+        #if AXIS_IS_TMC(I)
+          case I: stepperI.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(J)
+          case J: stepperJ.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(K)
+          case K: stepperK.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(X2)
+          case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          case Y2: stepperY2.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
     void setAxisCurrent_mA(const_float_t mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
@@ -494,80 +510,73 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: stepperE7.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
-        #if ENABLED(X_SENSORLESS)
-          case X:  return stepperX.homing_threshold();
+        OPTCODE(X_SENSORLESS,  case X:  return stepperX.homing_threshold())
+        OPTCODE(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold())
+        OPTCODE(Z_SENSORLESS,  case Z:  return stepperZ.homing_threshold())
+        OPTCODE(I_SENSORLESS,  case I:  return stepperI.homing_threshold())
+        OPTCODE(J_SENSORLESS,  case J:  return stepperJ.homing_threshold())
+        OPTCODE(K_SENSORLESS,  case K:  return stepperK.homing_threshold())
+        OPTCODE(X2_SENSORLESS, case X2: return stepperX2.homing_threshold())
+        OPTCODE(Y2_SENSORLESS, case Y2: return stepperY2.homing_threshold())
+        OPTCODE(Z2_SENSORLESS, case Z2: return stepperZ2.homing_threshold())
+        OPTCODE(Z3_SENSORLESS, case Z3: return stepperZ3.homing_threshold())
+        OPTCODE(Z4_SENSORLESS, case Z4: return stepperZ4.homing_threshold())
+        default: return 0;
+      }
+    }
+
+    void setTMCBumpSensitivity(const_float_t value, const axis_t axis) {
+      switch (axis) {
+        #if X_SENSORLESS
+          case X: stepperX.homing_threshold(value); break;
         #endif
-        #if ENABLED(X2_SENSORLESS)
-          case X2: return stepperX2.homing_threshold();
+        #if Y_SENSORLESS
+          case Y: stepperY.homing_threshold(value); break;
         #endif
-        #if ENABLED(Y_SENSORLESS)
-          case Y:  return stepperY.homing_threshold();
+        #if Z_SENSORLESS
+          case Z: stepperZ.homing_threshold(value); break;
         #endif
-        #if ENABLED(Y2_SENSORLESS)
-          case Y2: return stepperY2.homing_threshold();
+        #if I_SENSORLESS
+          case I: stepperI.homing_threshold(value); break;
         #endif
-        #if ENABLED(Z_SENSORLESS)
-          case Z:  return stepperZ.homing_threshold();
+        #if J_SENSORLESS
+          case J: stepperJ.homing_threshold(value); break;
         #endif
-        #if ENABLED(Z2_SENSORLESS)
-          case Z2: return stepperZ2.homing_threshold();
+        #if K_SENSORLESS
+          case K: stepperK.homing_threshold(value); break;
         #endif
-        #if ENABLED(Z3_SENSORLESS)
-          case Z3: return stepperZ3.homing_threshold();
+        #if X2_SENSORLESS
+          case X2: stepperX2.homing_threshold(value); break;
         #endif
-        #if ENABLED(Z4_SENSORLESS)
-          case Z4: return stepperZ4.homing_threshold();
+        #if Y2_SENSORLESS
+          case Y2: stepperY2.homing_threshold(value); break;
         #endif
-        default: return 0;
-      }
-    }
-
-    void setTMCBumpSensitivity(const_float_t value, const axis_t axis) {
-      switch (axis) {
-        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
-          #if X_SENSORLESS
-            case X:  stepperX.homing_threshold(value);  break;
-          #endif
-          #if X2_SENSORLESS
-            case X2: stepperX2.homing_threshold(value); break;
-          #endif
-          #if Y_SENSORLESS
-            case Y: stepperY.homing_threshold(value); break;
-          #endif
-          #if Y2_SENSORLESS
-            case Y2: stepperY2.homing_threshold(value); break;
-          #endif
-          #if Z_SENSORLESS
-            case Z: stepperZ.homing_threshold(value); break;
-          #endif
-          #if Z2_SENSORLESS
-            case Z2: stepperZ2.homing_threshold(value); break;
-          #endif
-          #if Z3_SENSORLESS
-            case Z3: stepperZ3.homing_threshold(value); break;
-          #endif
-          #if Z4_SENSORLESS
-            case Z4: stepperZ4.homing_threshold(value); break;
-          #endif
-        #else
-          UNUSED(value);
+        #if Z2_SENSORLESS
+          case Z2: stepperZ2.homing_threshold(value); break;
+        #endif
+        #if Z3_SENSORLESS
+          case Z3: stepperZ3.homing_threshold(value); break;
+        #endif
+        #if Z4_SENSORLESS
+          case Z4: stepperZ4.homing_threshold(value); break;
         #endif
         default: break;
       }
+      UNUSED(value);
     }
   #endif
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
@@ -654,42 +663,40 @@ namespace ExtUI {
     }
 
     void setLinearAdvance_mm_mm_s(const_float_t value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
-    float getJunctionDeviation_mm() {
-      return planner.junction_deviation_mm;
-    }
+    float getJunctionDeviation_mm() { return planner.junction_deviation_mm; }
 
     void setJunctionDeviation_mm(const_float_t value) {
       planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
     float getAxisMaxJerk_mm_s(const axis_t axis) { return planner.max_jerk[axis]; }
     float getAxisMaxJerk_mm_s(const extruder_t) { return planner.max_jerk.e; }
     void setAxisMaxJerk_mm_s(const_float_t value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
     void setAxisMaxJerk_mm_s(const_float_t value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     uint8_t getIDEX_Mode() { return dual_x_carriage_mode; }
   #endif
 
   #if PREHEAT_COUNT
-      uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
+    uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
     #if HAS_HEATED_BED
       uint16_t getMaterial_preset_B(const uint16_t index) { return ui.material_preset[index].bed_temp; }
     #endif
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
   int16_t getFlow_percent(const extruder_t extr)      { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
@@ -702,23 +709,27 @@ namespace ExtUI {
   void setPrintingAcceleration_mm_s2(const_float_t acc) { planner.settings.acceleration = acc; }
   void setRetractAcceleration_mm_s2(const_float_t acc) { planner.settings.retract_acceleration = acc; }
   void setTravelAcceleration_mm_s2(const_float_t acc)  { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
 
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
           case X: babystep.add_steps(X_AXIS, steps); break;
-          case Y: babystep.add_steps(Y_AXIS, steps); break;
+          #if HAS_Y_AXIS
+            case Y: babystep.add_steps(Y_AXIS, steps); break;
+          #endif
+        #endif
+        #if HAS_Z_AXIS
+          case Z: babystep.add_steps(Z_AXIS, steps); break;
         #endif
-        case Z: babystep.add_steps(Z_AXIS, steps); break;
         default: return false;
       };
       return true;
     }
 
     /**
      * This function adjusts an axis during a print.
      *
      * When linked_nozzles is false, each nozzle in a multi-nozzle
      * printer can be babystepped independently of the others. This
@@ -743,22 +754,22 @@ namespace ExtUI {
          * When linked_nozzles is false, as an axis is babystepped
          * adjust the hotend offsets so that the other nozzles are
          * unaffected by the babystepping of the active nozzle.
          */
         if (!linked_nozzles) {
           HOTEND_LOOP()
             if (e != active_extruder)
               hotend_offset[e][axis] += mm;
 
           normalizeNozzleOffset(X);
-          normalizeNozzleOffset(Y);
-          normalizeNozzleOffset(Z);
+          TERN_(HAS_Y_AXIS, normalizeNozzleOffset(Y));
+          TERN_(HAS_Z_AXIS, normalizeNozzleOffset(Z));
         }
       #else
         UNUSED(linked_nozzles);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
@@ -1007,22 +1018,21 @@ namespace ExtUI {
   void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() {
     #if HAS_HOTEND
       HOTEND_LOOP() thermalManager.setTargetHotend(0, e);
     #endif
     TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
-  bool awaitingUserConfirm() { return wait_for_user; }
-
+  bool awaitingUserConfirm() { return TERN0(HAS_RESUME_CONTINUE, wait_for_user); }
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   void printFile(const char *filename) {
     TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
     return TERN0(SDSUPPORT, isPrintingFromMedia() && printingIsPaused());
   }
 
@@ -1031,23 +1041,23 @@ namespace ExtUI {
   bool isPrinting() {
     return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED() && card.isMounted()); }
 
-  void pausePrint() { ui.pause_print(); }
+  void pausePrint()  { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
-  void stopPrint() { ui.abort_print(); }
+  void stopPrint()   { ui.abort_print(); }
 
   void onUserConfirmRequired_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);
     onUserConfirmRequired(msg);
   }
 
   void onStatusChanged_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);

commit 6d2c7aa227a5868badc9ab748bbd799a95ed7740
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Jun 10 02:17:39 2021 -0600

    üé® Fix and improve FTDI Eve Touch UI (#22093)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index fff31f099b..b0def618fd 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -760,20 +760,24 @@ namespace ExtUI {
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
     int16_t mmToWholeSteps(const_float_t mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
 
+    float mmFromWholeSteps(int16_t steps, const axis_t axis) {
+      return steps * planner.steps_to_mm[axis];
+    }
+
   #endif // BABYSTEPPING
 
   float getZOffset_mm() {
     return (0.0f
       #if HAS_BED_PROBE
         + probe.offset.z
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
         + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #endif
     );

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index faa23665bb..fff31f099b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -562,68 +562,68 @@ namespace ExtUI {
         default: break;
       }
     }
   #endif
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisSteps_per_mm(const_float_t value, const axis_t axis) {
     planner.settings.axis_steps_per_mm[axis] = value;
     planner.refresh_positioning();
   }
 
   void setAxisSteps_per_mm(const_float_t value, const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
     planner.refresh_positioning();
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
     planner.set_max_feedrate(axis, value);
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
   }
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxAcceleration_mm_s2(const_float_t value, const axis_t axis) {
     planner.set_max_acceleration(axis, value);
   }
 
   void setAxisMaxAcceleration_mm_s2(const_float_t value, const extruder_t extruder) {
-    UNUSED_E(extruder);
+    UNUSED(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 9cc8b9962c..faa23665bb 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -47,20 +47,21 @@
 
 #include "../marlinui.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
+#include "../../MarlinCore.h"
 #include "../../sd/cardreader.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
   #include "../../libs/numtostr.h"
 #endif
 
 #if HAS_MULTI_EXTRUDER
   #include "../../module/tool_change.h"
 #endif
@@ -99,23 +100,20 @@
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 namespace ExtUI {
   static struct {
     uint8_t printer_killed : 1;
     #if ENABLED(JOYSTICK)
       uint8_t jogging : 1;
     #endif
-    #if ENABLED(SDSUPPORT)
-      uint8_t was_sd_printing : 1;
-    #endif
   } flags;
 
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
      * within an ISR (such as when the printer is killed).
      *
      * To keep proper time, must be called at least every 1s.
      */
     uint32_t safe_millis() {
@@ -1010,41 +1008,31 @@ namespace ExtUI {
     #endif
     TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
   bool awaitingUserConfirm() { return wait_for_user; }
 
   void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   void printFile(const char *filename) {
-    UNUSED(filename);
-    TERN_(SDSUPPORT, card.openAndPrintFile(filename));
+    TERN(SDSUPPORT, card.openAndPrintFile(filename), UNUSED(filename));
   }
 
   bool isPrintingFromMediaPaused() {
-    return TERN0(SDSUPPORT, isPrintingFromMedia() && !IS_SD_PRINTING());
+    return TERN0(SDSUPPORT, isPrintingFromMedia() && printingIsPaused());
   }
 
-  bool isPrintingFromMedia() {
-    #if ENABLED(SDSUPPORT)
-      // Account for when IS_SD_PRINTING() reports the end of the
-      // print when there is still SD card data in the planner.
-      flags.was_sd_printing = card.isFileOpen() || (flags.was_sd_printing && commandsInQueue());
-      return flags.was_sd_printing;
-    #else
-      return false;
-    #endif
-  }
+  bool isPrintingFromMedia() { return IS_SD_PRINTING(); }
 
   bool isPrinting() {
-    return (commandsInQueue() || isPrintingFromMedia() || TERN0(SDSUPPORT, IS_SD_PRINTING())) || print_job_timer.isRunning() || print_job_timer.isPaused();
+    return commandsInQueue() || isPrintingFromMedia() || printJobOngoing() || printingIsPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED() && card.isMounted()); }
 
   void pausePrint() { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }

commit 9c7344487a04940c845d9c39215f0d28ac26208f
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon Apr 26 22:40:59 2021 -0600

    FTDI EVE Touch UI fixes (#21706)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index accca50d1e..9cc8b9962c 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -684,21 +684,21 @@ namespace ExtUI {
   #endif
 
   #if PREHEAT_COUNT
       uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
     #if HAS_HEATED_BED
       uint16_t getMaterial_preset_B(const uint16_t index) { return ui.material_preset[index].bed_temp; }
     #endif
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
-  int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
+  int16_t getFlow_percent(const extruder_t extr)      { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
   void setFlow_percent(const int16_t flow, const extruder_t extr) { planner.set_flow(extr, flow); }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const_float_t acc) { planner.settings.acceleration = acc; }

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 23cf26a8ca..accca50d1e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -911,38 +911,38 @@ namespace ExtUI {
     float getPIDValues_Ki(const extruder_t tool) { return unscalePID_i(PID_PARAM(Ki, tool)); }
     float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
 
     void setPIDValues(const_float_t p, const_float_t i, const_float_t d, extruder_t tool) {
       thermalManager.temp_hotend[tool].pid.Kp = p;
       thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
       thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startPIDTune(const_float_t temp, extruder_t tool) {
+    void startPIDTune(const celsius_t temp, extruder_t tool) {
       thermalManager.PID_autotune(temp, (heater_id_t)tool, 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
     float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
     float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
 
     void setBedPIDValues(const_float_t p, const_float_t i, const_float_t d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startBedPIDTune(const_float_t temp) {
+    void startBedPIDTune(const celsius_t temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
   void injectCommands(char * const gcode)  { queue.inject(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) { return axis_is_trusted((AxisEnum)axis); }

commit 3bddbb1110b6ca13a291de426553839b99cae102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:06:55 2021 -0500

    Clean up formatting, wrap macros

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c2f51b3265..23cf26a8ca 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -289,35 +289,27 @@ namespace ExtUI {
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   celsius_float_t getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
-    #if HAS_FAN
-      return thermalManager.fanSpeedPercent(fan - FAN0);
-    #else
-      UNUSED(fan);
-      return 0;
-    #endif
+    UNUSED(fan);
+    return TERN0(HAS_FAN, thermalManager.fanSpeedPercent(fan - FAN0));
   }
 
   float getActualFan_percent(const fan_t fan) {
-    #if HAS_FAN
-      return thermalManager.scaledFanSpeedPercent(fan - FAN0);
-    #else
-      UNUSED(fan);
-      return 0;
-    #endif
+    UNUSED(fan);
+    return TERN0(HAS_FAN, thermalManager.scaledFanSpeedPercent(fan - FAN0));
   }
 
   float getAxisPosition_mm(const axis_t axis) {
     return TERN0(JOYSTICK, flags.jogging) ? destination[axis] : current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN0(JOYSTICK, flags.jogging) ? destination.e : current_position.e;

commit 72e3d2492f2085efe9c5fb0b33d67c24baf8a4bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:14:49 2021 -0500

    Update temperature types

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 66bc10c411..c2f51b3265 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -256,49 +256,49 @@ namespace ExtUI {
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) (float(A) / (TOUCH_UI_LCD_TEMP_SCALING))
   #else
     #define GET_TEMP_ADJUSTMENT(A) A
   #endif
 
-  float getActualTemp_celsius(const heater_t heater) {
+  celsius_float_t getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
       #if ENABLED(HAS_HEATED_BED)
         case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
       #endif
       #if ENABLED(HAS_HEATED_CHAMBER)
         case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
   }
 
-  float getActualTemp_celsius(const extruder_t extruder) {
+  celsius_float_t getActualTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
   }
 
-  float getTargetTemp_celsius(const heater_t heater) {
+  celsius_float_t getTargetTemp_celsius(const heater_t heater) {
     switch (heater) {
       #if ENABLED(HAS_HEATED_BED)
         case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
       #endif
       #if ENABLED(HAS_HEATED_CHAMBER)
         case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
       #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
-  float getTargetTemp_celsius(const extruder_t extruder) {
+  celsius_float_t getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
     #if HAS_FAN
       return thermalManager.fanSpeedPercent(fan - FAN0);
     #else
       UNUSED(fan);
       return 0;
     #endif

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c03a10fcd3..66bc10c411 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -414,21 +414,21 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: return stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
           case Z: return stepperZ.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: return stepperZ2.getMilliamps();
         #endif
-        default: return MFNAN;
+        default: return NAN;
       };
     }
 
     float getAxisCurrent_mA(const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: return stepperE0.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E1)
           case E1: return stepperE1.getMilliamps();
@@ -444,21 +444,21 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E5)
           case E5: return stepperE5.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E6)
           case E6: return stepperE6.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: return stepperE7.getMilliamps();
         #endif
-        default: return MFNAN;
+        default: return NAN;
       };
     }
 
     void setAxisCurrent_mA(const_float_t mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;

commit fd99ea09ecb41bc1dfc5e4109e0d6c7de1f87424
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 04:00:39 2021 -0500

    Add fan percent accessors

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 17e869d44f..c03a10fcd3 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -290,30 +290,30 @@ namespace ExtUI {
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
     #if HAS_FAN
-      return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
+      return thermalManager.fanSpeedPercent(fan - FAN0);
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getActualFan_percent(const fan_t fan) {
     #if HAS_FAN
-      return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
+      return thermalManager.scaledFanSpeedPercent(fan - FAN0);
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getAxisPosition_mm(const axis_t axis) {
     return TERN0(JOYSTICK, flags.jogging) ? destination[axis] : current_position[axis];
   }
 

commit 4a1d2d816c4dff8b3c3e472f7b8022362e1ad109
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 12 19:34:31 2021 -0500

    Update old-style axis indexes

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 9d89447e3e..17e869d44f 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -863,33 +863,33 @@ namespace ExtUI {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
-          if (x_target != current_position[X_AXIS] || y_target != current_position[Y_AXIS]) {
+          if (x_target != current_position.x || y_target != current_position.y) {
             // If moving across bed, raise nozzle to safe height over bed
             feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
             destination = current_position;
-            destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
+            destination.z = Z_CLEARANCE_BETWEEN_PROBES;
             prepare_line_to_destination();
             feedrate_mm_s = XY_PROBE_FEEDRATE;
-            destination[X_AXIS] = x_target;
-            destination[Y_AXIS] = y_target;
+            destination.x = x_target;
+            destination.y = y_target;
             prepare_line_to_destination();
           }
           feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
-          destination[Z_AXIS] = z;
+          destination.z = z;
           prepare_line_to_destination();
           feedrate_mm_s = old_feedrate;
         #else
           UNUSED(pos);
           UNUSED(z);
         #endif
       }
 
     #endif // HAS_MESH
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 2cac0f8e77..9d89447e3e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -414,21 +414,21 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(Y2)
           case Y2: return stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
           case Z: return stepperZ.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: return stepperZ2.getMilliamps();
         #endif
-        default: return NAN;
+        default: return MFNAN;
       };
     }
 
     float getAxisCurrent_mA(const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: return stepperE0.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E1)
           case E1: return stepperE1.getMilliamps();
@@ -444,21 +444,21 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E5)
           case E5: return stepperE5.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E6)
           case E6: return stepperE6.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: return stepperE7.getMilliamps();
         #endif
-        default: return NAN;
+        default: return MFNAN;
       };
     }
 
     void setAxisCurrent_mA(const_float_t mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 2eecda9df0..2cac0f8e77 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -852,21 +852,21 @@ namespace ExtUI {
 
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
 
     #if HAS_MESH
 
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
       void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
-        if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
+        if (WITHIN(pos.x, 0, (GRID_MAX_POINTS_X) - 1) && WITHIN(pos.y, 0, (GRID_MAX_POINTS_Y) - 1)) {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
 
       void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 23930c04f3..2eecda9df0 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -318,39 +318,39 @@ namespace ExtUI {
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN0(JOYSTICK, flags.jogging) ? destination.e : current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
-  void setAxisPosition_mm(const float &position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
+  void setAxisPosition_mm(const_float_t position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
         max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
     line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
-  void setAxisPosition_mm(const float &position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
+  void setAxisPosition_mm(const_float_t position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
     line_to_current_position(feedrate ?: manual_feedrate_mm_s.e);
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if HAS_MULTI_EXTRUDER
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
@@ -448,21 +448,21 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E6)
           case E6: return stepperE6.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: return stepperE7.getMilliamps();
         #endif
         default: return NAN;
       };
     }
 
-    void setAxisCurrent_mA(const float &mA, const axis_t axis) {
+    void setAxisCurrent_mA(const_float_t mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y)
           case Y: stepperY.rms_current(constrain(mA, 400, 1500)); break;
         #endif
@@ -472,21 +472,21 @@ namespace ExtUI {
         #if AXIS_IS_TMC(Z)
           case Z: stepperZ.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
-    void setAxisCurrent_mA(const float &mA, const extruder_t extruder) {
+    void setAxisCurrent_mA(const_float_t mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: stepperE0.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E1)
           case E1: stepperE1.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E2)
           case E2: stepperE2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
@@ -532,21 +532,21 @@ namespace ExtUI {
         #if ENABLED(Z3_SENSORLESS)
           case Z3: return stepperZ3.homing_threshold();
         #endif
         #if ENABLED(Z4_SENSORLESS)
           case Z4: return stepperZ4.homing_threshold();
         #endif
         default: return 0;
       }
     }
 
-    void setTMCBumpSensitivity(const float &value, const axis_t axis) {
+    void setTMCBumpSensitivity(const_float_t value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           #if X_SENSORLESS
             case X:  stepperX.homing_threshold(value);  break;
           #endif
           #if X2_SENSORLESS
             case X2: stepperX2.homing_threshold(value); break;
           #endif
           #if Y_SENSORLESS
             case Y: stepperY.homing_threshold(value); break;
@@ -576,26 +576,26 @@ namespace ExtUI {
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
-  void setAxisSteps_per_mm(const float &value, const axis_t axis) {
+  void setAxisSteps_per_mm(const_float_t value, const axis_t axis) {
     planner.settings.axis_steps_per_mm[axis] = value;
     planner.refresh_positioning();
   }
 
-  void setAxisSteps_per_mm(const float &value, const extruder_t extruder) {
+  void setAxisSteps_per_mm(const_float_t value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
     planner.refresh_positioning();
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
@@ -614,84 +614,84 @@ namespace ExtUI {
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
-  void setAxisMaxAcceleration_mm_s2(const float &value, const axis_t axis) {
+  void setAxisMaxAcceleration_mm_s2(const_float_t value, const axis_t axis) {
     planner.set_max_acceleration(axis, value);
   }
 
-  void setAxisMaxAcceleration_mm_s2(const float &value, const extruder_t extruder) {
+  void setAxisMaxAcceleration_mm_s2(const_float_t value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
-      void setFilamentRunoutDistance_mm(const float &value) { runout.set_runout_distance(constrain(value, 0, 999)); }
+      void setFilamentRunoutDistance_mm(const_float_t value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
   #if ENABLED(CASE_LIGHT_ENABLE)
     bool getCaseLightState()                 { return caselight.on; }
     void setCaseLightState(const bool value) {
       caselight.on = value;
       caselight.update_enabled();
     }
 
     #if CASELIGHT_USES_BRIGHTNESS
       float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
-      void setCaseLightBrightness_percent(const float &value) {
+      void setCaseLightBrightness_percent(const_float_t value) {
          caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
          caselight.update_brightness();
       }
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
-    void setLinearAdvance_mm_mm_s(const float &value, const extruder_t extruder) {
+    void setLinearAdvance_mm_mm_s(const_float_t value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
-    void setJunctionDeviation_mm(const float &value) {
+    void setJunctionDeviation_mm(const_float_t value) {
       planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
     float getAxisMaxJerk_mm_s(const axis_t axis) { return planner.max_jerk[axis]; }
     float getAxisMaxJerk_mm_s(const extruder_t) { return planner.max_jerk.e; }
-    void setAxisMaxJerk_mm_s(const float &value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
-    void setAxisMaxJerk_mm_s(const float &value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
+    void setAxisMaxJerk_mm_s(const_float_t value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
+    void setAxisMaxJerk_mm_s(const_float_t value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     uint8_t getIDEX_Mode() { return dual_x_carriage_mode; }
   #endif
 
   #if PREHEAT_COUNT
       uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
     #if HAS_HEATED_BED
       uint16_t getMaterial_preset_B(const uint16_t index) { return ui.material_preset[index].bed_temp; }
@@ -702,23 +702,23 @@ namespace ExtUI {
   int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
   void setFlow_percent(const int16_t flow, const extruder_t extr) { planner.set_flow(extr, flow); }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
-  void setPrintingAcceleration_mm_s2(const float &acc) { planner.settings.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float &acc) { planner.settings.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float &acc)  { planner.settings.travel_acceleration = acc; }
+  void setPrintingAcceleration_mm_s2(const_float_t acc) { planner.settings.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const_float_t acc) { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const_float_t acc)  { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
 
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
           case X: babystep.add_steps(X_AXIS, steps); break;
           case Y: babystep.add_steps(Y_AXIS, steps); break;
         #endif
         case Z: babystep.add_steps(Z_AXIS, steps); break;
@@ -765,114 +765,114 @@ namespace ExtUI {
         }
       #else
         UNUSED(linked_nozzles);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
-    int16_t mmToWholeSteps(const float &mm, const axis_t axis) {
+    int16_t mmToWholeSteps(const_float_t mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
 
   #endif // BABYSTEPPING
 
   float getZOffset_mm() {
     return (0.0f
       #if HAS_BED_PROBE
         + probe.offset.z
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
         + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #endif
     );
   }
 
-  void setZOffset_mm(const float &value) {
+  void setZOffset_mm(const_float_t value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, value - getZOffset_mm());
     #else
       UNUSED(value);
     #endif
   }
 
   #if HAS_HOTEND_OFFSET
 
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
       return hotend_offset[extruder - E0][axis];
     }
 
-    void setNozzleOffset_mm(const float &value, const axis_t axis, const extruder_t extruder) {
+    void setNozzleOffset_mm(const_float_t value, const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return;
       hotend_offset[extruder - E0][axis] = value;
     }
 
     /**
      * The UI should call this if needs to guarantee the first
      * nozzle offset is zero (such as when it doesn't allow the
      * user to edit the offset the first nozzle).
      */
     void normalizeNozzleOffset(const axis_t axis) {
       const float offs = hotend_offset[0][axis];
       HOTEND_LOOP() hotend_offset[e][axis] -= offs;
     }
 
   #endif // HAS_HOTEND_OFFSET
 
   #if HAS_BED_PROBE
     float getProbeOffset_mm(const axis_t axis) { return probe.offset.pos[axis]; }
-    void setProbeOffset_mm(const float &val, const axis_t axis) { probe.offset.pos[axis] = val; }
+    void setProbeOffset_mm(const_float_t val, const axis_t axis) { probe.offset.pos[axis] = val; }
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
-    void setAxisBacklash_mm(const float &value, const axis_t axis)
+    void setAxisBacklash_mm(const_float_t value, const axis_t axis)
                                                       { backlash.distance_mm[axis] = constrain(value,0,5); }
 
     float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
-    void setBacklashCorrection_percent(const float &value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
+    void setBacklashCorrection_percent(const_float_t value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
       float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
-      void setBacklashSmoothing_mm(const float &value) { backlash.smoothing_mm = constrain(value, 0, 999); }
+      void setBacklashSmoothing_mm(const_float_t value) { backlash.smoothing_mm = constrain(value, 0, 999); }
     #endif
   #endif
 
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
 
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
 
     #if HAS_MESH
 
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
-      void setMeshPoint(const xy_uint8_t &pos, const float &zoff) {
+      void setMeshPoint(const xy_uint8_t &pos, const_float_t zoff) {
         if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
 
-      void moveToMeshPoint(const xy_uint8_t &pos, const float &z) {
+      void moveToMeshPoint(const xy_uint8_t &pos, const_float_t z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
           const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
                       y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
           if (x_target != current_position[X_AXIS] || y_target != current_position[Y_AXIS]) {
             // If moving across bed, raise nozzle to safe height over bed
             feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
             destination = current_position;
             destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
             prepare_line_to_destination();
@@ -912,65 +912,65 @@ namespace ExtUI {
     }
   #endif
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
   #if ENABLED(PIDTEMP)
     float getPIDValues_Kp(const extruder_t tool) { return PID_PARAM(Kp, tool); }
     float getPIDValues_Ki(const extruder_t tool) { return unscalePID_i(PID_PARAM(Ki, tool)); }
     float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
 
-    void setPIDValues(const float &p, const float &i, const float &d, extruder_t tool) {
+    void setPIDValues(const_float_t p, const_float_t i, const_float_t d, extruder_t tool) {
       thermalManager.temp_hotend[tool].pid.Kp = p;
       thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
       thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startPIDTune(const float &temp, extruder_t tool) {
+    void startPIDTune(const_float_t temp, extruder_t tool) {
       thermalManager.PID_autotune(temp, (heater_id_t)tool, 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
     float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
     float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
 
-    void setBedPIDValues(const float &p, const float &i, const float &d) {
+    void setBedPIDValues(const_float_t p, const_float_t i, const_float_t d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startBedPIDTune(const float &temp) {
+    void startBedPIDTune(const_float_t temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
   void injectCommands(char * const gcode)  { queue.inject(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) { return axis_is_trusted((AxisEnum)axis); }
   bool isAxisPositionKnown(const extruder_t) { return axis_is_trusted(E_AXIS); }
   bool isPositionKnown() { return all_axes_trusted(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
     static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);
     return firmware_name;
   }
 
-  void setTargetTemp_celsius(const float &inval, const heater_t heater) {
+  void setTargetTemp_celsius(const_float_t inval, const heater_t heater) {
     float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
     switch (heater) {
       #if HAS_HEATED_CHAMBER
         case CHAMBER: thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAX_TARGET))); break;
       #endif
       #if HAS_COOLER
@@ -981,43 +981,43 @@ namespace ExtUI {
       #endif
       default: {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.hotend_max_target(e))), e);
         #endif
       } break;
     }
   }
 
-  void setTargetTemp_celsius(const float &inval, const extruder_t extruder) {
+  void setTargetTemp_celsius(const_float_t inval, const extruder_t extruder) {
     float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.hotend_max_target(e))), e);
     #endif
   }
 
-  void setTargetFan_percent(const float &value, const fan_t fan) {
+  void setTargetFan_percent(const_float_t value, const fan_t fan) {
     #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
-  void setFeedrate_percent(const float &value) { feedrate_percentage = constrain(value, 10, 500); }
+  void setFeedrate_percent(const_float_t value) { feedrate_percentage = constrain(value, 10, 500); }
 
   void coolDown() {
     #if HAS_HOTEND
       HOTEND_LOOP() thermalManager.setTargetHotend(0, e);
     #endif
     TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
     TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
   bool awaitingUserConfirm() { return wait_for_user; }

commit c45b91aa94c7008e3fd8ea297df57948af9158a3
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Mar 27 21:57:12 2021 -0600

    Refactor Hilbert curve. Enhance Touch UI Bed Level Screen. (#21453)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index cfd48e5dd9..23930c04f3 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -842,54 +842,65 @@ namespace ExtUI {
       void setBacklashSmoothing_mm(const float &value) { backlash.smoothing_mm = constrain(value, 0, 999); }
     #endif
   #endif
 
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
+
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
+
     #if HAS_MESH
+
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
       void setMeshPoint(const xy_uint8_t &pos, const float &zoff) {
         if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
+
       void moveToMeshPoint(const xy_uint8_t &pos, const float &z) {
         #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
           const feedRate_t old_feedrate = feedrate_mm_s;
-          feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
-          destination = current_position;
-          destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
-          prepare_line_to_destination();
-          feedrate_mm_s = XY_PROBE_FEEDRATE;
-          destination[X_AXIS] = MESH_MIN_X + pos.x * MESH_X_DIST;
-          destination[Y_AXIS] = MESH_MIN_Y + pos.y * MESH_Y_DIST;
-          prepare_line_to_destination();
+          const float x_target = MESH_MIN_X + pos.x * (MESH_X_DIST),
+                      y_target = MESH_MIN_Y + pos.y * (MESH_Y_DIST);
+          if (x_target != current_position[X_AXIS] || y_target != current_position[Y_AXIS]) {
+            // If moving across bed, raise nozzle to safe height over bed
+            feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
+            destination = current_position;
+            destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
+            prepare_line_to_destination();
+            feedrate_mm_s = XY_PROBE_FEEDRATE;
+            destination[X_AXIS] = x_target;
+            destination[Y_AXIS] = y_target;
+            prepare_line_to_destination();
+          }
           feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
           destination[Z_AXIS] = z;
           prepare_line_to_destination();
           feedrate_mm_s = old_feedrate;
         #else
           UNUSED(pos);
           UNUSED(z);
         #endif
       }
-    #endif
-  #endif
+
+    #endif // HAS_MESH
+
+  #endif // HAS_LEVELING
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
     void setHostResponse(const uint8_t response) { host_response_handler(response); }
   #endif
 
   #if ENABLED(PRINTCOUNTER)
     char* getFailedPrints_str(char buffer[21])   { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints - print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 9e5e0b6a62..cfd48e5dd9 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -96,22 +96,26 @@
   #include "../../feature/babystep.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 namespace ExtUI {
   static struct {
     uint8_t printer_killed : 1;
-    TERN_(JOYSTICK, uint8_t jogging : 1);
-    TERN_(SDSUPPORT, uint8_t was_sd_printing : 1);
+    #if ENABLED(JOYSTICK)
+      uint8_t jogging : 1;
+    #endif
+    #if ENABLED(SDSUPPORT)
+      uint8_t was_sd_printing : 1;
+    #endif
   } flags;
 
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
      * within an ISR (such as when the printer is killed).
      *
      * To keep proper time, must be called at least every 1s.
      */
     uint32_t safe_millis() {
@@ -168,22 +172,26 @@ namespace ExtUI {
       UNUSED(extruder);
     #endif
   }
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
           case BED: thermalManager.reset_bed_idle_timer(); return;
         #endif
-        TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return); // Chamber has no idle timer
-        TERN_(HAS_COOLER, case COOLER: return); // Cooler has no idle timer
+        #if ENABLED(HAS_HEATED_CHAMBER)
+          case CHAMBER: return; // Chamber has no idle timer
+        #endif
+        #if ENABLED(HAS_COOLER)
+          case COOLER: return;  // Cooler has no idle timer
+        #endif
         default:
           TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
 
   #if ENABLED(JOYSTICK)
@@ -227,53 +235,65 @@ namespace ExtUI {
       return thermalManager.heater_idle[extruder - E0].timed_out;
     #else
       UNUSED(extruder);
       return false;
     #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
-        TERN_(HAS_HEATED_BED, case BED: return thermalManager.heater_idle[thermalManager.IDLE_INDEX_BED].timed_out);
-        TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return false); // Chamber has no idle timer
+        #if ENABLED(HAS_HEATED_BED)
+          case BED: return thermalManager.heater_idle[thermalManager.IDLE_INDEX_BED].timed_out;
+        #endif
+        #if ENABLED(HAS_HEATED_CHAMBER)
+          case CHAMBER: return false; // Chamber has no idle timer
+        #endif
         default:
           return TERN0(HAS_HOTEND, thermalManager.heater_idle[heater - H0].timed_out);
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) (float(A) / (TOUCH_UI_LCD_TEMP_SCALING))
   #else
     #define GET_TEMP_ADJUSTMENT(A) A
   #endif
 
   float getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
-      TERN_(HAS_HEATED_BED, case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed()));
-      TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber()));
+      #if ENABLED(HAS_HEATED_BED)
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
+      #endif
+      #if ENABLED(HAS_HEATED_CHAMBER)
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
+      #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
   }
 
   float getActualTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
   }
 
   float getTargetTemp_celsius(const heater_t heater) {
     switch (heater) {
-      TERN_(HAS_HEATED_BED, case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed()));
-      TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber()));
+      #if ENABLED(HAS_HEATED_BED)
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
+      #endif
+      #if ENABLED(HAS_HEATED_CHAMBER)
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
+      #endif
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
     #if HAS_FAN
@@ -287,27 +307,27 @@ namespace ExtUI {
   float getActualFan_percent(const fan_t fan) {
     #if HAS_FAN
       return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getAxisPosition_mm(const axis_t axis) {
-    return TERN_(JOYSTICK, flags.jogging ? destination[axis] :) current_position[axis];
+    return TERN0(JOYSTICK, flags.jogging) ? destination[axis] : current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
-    const float epos = TERN_(JOYSTICK, flags.jogging ? destination.e :) current_position.e;
+    const float epos = TERN0(JOYSTICK, flags.jogging) ? destination.e : current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
   void setAxisPosition_mm(const float &position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
@@ -484,28 +504,44 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: stepperE7.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
-        TERN_(X_SENSORLESS,  case X:  return stepperX.homing_threshold());
-        TERN_(X2_SENSORLESS, case X2: return stepperX2.homing_threshold());
-        TERN_(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold());
-        TERN_(Y2_SENSORLESS, case Y2: return stepperY2.homing_threshold());
-        TERN_(Z_SENSORLESS,  case Z:  return stepperZ.homing_threshold());
-        TERN_(Z2_SENSORLESS, case Z2: return stepperZ2.homing_threshold());
-        TERN_(Z3_SENSORLESS, case Z3: return stepperZ3.homing_threshold());
-        TERN_(Z4_SENSORLESS, case Z4: return stepperZ4.homing_threshold());
+        #if ENABLED(X_SENSORLESS)
+          case X:  return stepperX.homing_threshold();
+        #endif
+        #if ENABLED(X2_SENSORLESS)
+          case X2: return stepperX2.homing_threshold();
+        #endif
+        #if ENABLED(Y_SENSORLESS)
+          case Y:  return stepperY.homing_threshold();
+        #endif
+        #if ENABLED(Y2_SENSORLESS)
+          case Y2: return stepperY2.homing_threshold();
+        #endif
+        #if ENABLED(Z_SENSORLESS)
+          case Z:  return stepperZ.homing_threshold();
+        #endif
+        #if ENABLED(Z2_SENSORLESS)
+          case Z2: return stepperZ2.homing_threshold();
+        #endif
+        #if ENABLED(Z3_SENSORLESS)
+          case Z3: return stepperZ3.homing_threshold();
+        #endif
+        #if ENABLED(Z4_SENSORLESS)
+          case Z4: return stepperZ4.homing_threshold();
+        #endif
         default: return 0;
       }
     }
 
     void setTMCBumpSensitivity(const float &value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           #if X_SENSORLESS
             case X:  stepperX.homing_threshold(value);  break;
           #endif

commit cfa6c7d45ba72d1a0b26e6308191e008dcd0d9c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:34:10 2021 -0500

    Improve max temp / target

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 90f9e0b0bf..9e5e0b6a62 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -917,46 +917,46 @@ namespace ExtUI {
   }
 
   void setTargetTemp_celsius(const float &inval, const heater_t heater) {
     float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
     switch (heater) {
       #if HAS_HEATED_CHAMBER
-        case CHAMBER: thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10))); break;
+        case CHAMBER: thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAX_TARGET))); break;
       #endif
       #if HAS_COOLER
         case COOLER: thermalManager.setTargetCooler(LROUND(constrain(value, 0, COOLER_MAXTEMP))); break;
       #endif
       #if HAS_HEATED_BED
         case BED: thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET))); break;
       #endif
       default: {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
+          thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.hotend_max_target(e))), e);
         #endif
       } break;
     }
   }
 
   void setTargetTemp_celsius(const float &inval, const extruder_t extruder) {
     float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
-      thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
+      thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.hotend_max_target(e))), e);
     #endif
   }
 
   void setTargetFan_percent(const float &value, const fan_t fan) {
     #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);

commit 3e7d830f570ece878f18732072de1b34156cdd66
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon Mar 22 23:51:03 2021 -0600

    Mesh Editor for FTDI Eve Touch UI (#21381)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 73e5bc092d..90f9e0b0bf 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -818,20 +818,40 @@ namespace ExtUI {
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
       void setMeshPoint(const xy_uint8_t &pos, const float &zoff) {
         if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
+      void moveToMeshPoint(const xy_uint8_t &pos, const float &z) {
+        #if EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
+          const feedRate_t old_feedrate = feedrate_mm_s;
+          feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
+          destination = current_position;
+          destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
+          prepare_line_to_destination();
+          feedrate_mm_s = XY_PROBE_FEEDRATE;
+          destination[X_AXIS] = MESH_MIN_X + pos.x * MESH_X_DIST;
+          destination[Y_AXIS] = MESH_MIN_Y + pos.y * MESH_Y_DIST;
+          prepare_line_to_destination();
+          feedrate_mm_s = Z_PROBE_FEEDRATE_FAST;
+          destination[Z_AXIS] = z;
+          prepare_line_to_destination();
+          feedrate_mm_s = old_feedrate;
+        #else
+          UNUSED(pos);
+          UNUSED(z);
+        #endif
+      }
     #endif
   #endif
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
     void setHostResponse(const uint8_t response) { host_response_handler(response); }
   #endif
 
   #if ENABLED(PRINTCOUNTER)
     char* getFailedPrints_str(char buffer[21])   { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints - print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }

commit b51aed8aa54f41cc5897485d3b34b019ce38343d
Author: Skorpi08 <skorpik08@gmail.com>
Date:   Fri Mar 19 02:51:19 2021 +0100

    Nextion TFT touch screen (#21324)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 97d4ec2b08..73e5bc092d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -644,34 +644,45 @@ namespace ExtUI {
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
     float getAxisMaxJerk_mm_s(const axis_t axis) { return planner.max_jerk[axis]; }
     float getAxisMaxJerk_mm_s(const extruder_t) { return planner.max_jerk.e; }
     void setAxisMaxJerk_mm_s(const float &value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
     void setAxisMaxJerk_mm_s(const float &value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
   #endif
 
+  #if ENABLED(DUAL_X_CARRIAGE)
+    uint8_t getIDEX_Mode() { return dual_x_carriage_mode; }
+  #endif
+
+  #if PREHEAT_COUNT
+      uint16_t getMaterial_preset_E(const uint16_t index) { return ui.material_preset[index].hotend_temp; }
+    #if HAS_HEATED_BED
+      uint16_t getMaterial_preset_B(const uint16_t index) { return ui.material_preset[index].bed_temp; }
+    #endif
+  #endif
+
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
   int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
   void setFlow_percent(const int16_t flow, const extruder_t extr) { planner.set_flow(extr, flow); }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const float &acc) { planner.settings.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float &acc)  { planner.settings.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float &acc)   { planner.settings.travel_acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float &acc) { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float &acc)  { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
 
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
           case X: babystep.add_steps(X_AXIS, steps); break;
           case Y: babystep.add_steps(Y_AXIS, steps); break;
         #endif
         case Z: babystep.add_steps(Z_AXIS, steps); break;

commit 9823a37362c86f8f722c01af2147075d70234ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 16 15:12:28 2021 -0500

    E1+ Autotemp and Planner comments

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index d83b921648..97d4ec2b08 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -580,27 +580,25 @@ namespace ExtUI {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxAcceleration_mm_s2(const float &value, const axis_t axis) {
     planner.set_max_acceleration(axis, value);
-    planner.reset_acceleration_rates();
   }
 
   void setAxisMaxAcceleration_mm_s2(const float &value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
-    planner.reset_acceleration_rates();
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }

commit 1affbe2100c32f79d469b059be3eddd364a80431
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 12 06:54:42 2021 -0600

    Clean up, optimize ExtUI/TFT code (#21333)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c5c35321ca..d83b921648 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -298,39 +298,39 @@ namespace ExtUI {
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN_(JOYSTICK, flags.jogging ? destination.e :) current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
-  void setAxisPosition_mm(const float position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
+  void setAxisPosition_mm(const float &position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
         max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
     line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
-  void setAxisPosition_mm(const float position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
+  void setAxisPosition_mm(const float &position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
     line_to_current_position(feedrate ?: manual_feedrate_mm_s.e);
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if HAS_MULTI_EXTRUDER
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
@@ -428,21 +428,21 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E6)
           case E6: return stepperE6.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: return stepperE7.getMilliamps();
         #endif
         default: return NAN;
       };
     }
 
-    void  setAxisCurrent_mA(const float mA, const axis_t axis) {
+    void setAxisCurrent_mA(const float &mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y)
           case Y: stepperY.rms_current(constrain(mA, 400, 1500)); break;
         #endif
@@ -452,21 +452,21 @@ namespace ExtUI {
         #if AXIS_IS_TMC(Z)
           case Z: stepperZ.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z2)
           case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
-    void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
+    void setAxisCurrent_mA(const float &mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: stepperE0.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E1)
           case E1: stepperE1.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E2)
           case E2: stepperE2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
@@ -496,21 +496,21 @@ namespace ExtUI {
         TERN_(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold());
         TERN_(Y2_SENSORLESS, case Y2: return stepperY2.homing_threshold());
         TERN_(Z_SENSORLESS,  case Z:  return stepperZ.homing_threshold());
         TERN_(Z2_SENSORLESS, case Z2: return stepperZ2.homing_threshold());
         TERN_(Z3_SENSORLESS, case Z3: return stepperZ3.homing_threshold());
         TERN_(Z4_SENSORLESS, case Z4: return stepperZ4.homing_threshold());
         default: return 0;
       }
     }
 
-    void setTMCBumpSensitivity(const float value, const axis_t axis) {
+    void setTMCBumpSensitivity(const float &value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           #if X_SENSORLESS
             case X:  stepperX.homing_threshold(value);  break;
           #endif
           #if X2_SENSORLESS
             case X2: stepperX2.homing_threshold(value); break;
           #endif
           #if Y_SENSORLESS
             case Y: stepperY.homing_threshold(value); break;
@@ -540,26 +540,26 @@ namespace ExtUI {
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
-  void setAxisSteps_per_mm(const float value, const axis_t axis) {
+  void setAxisSteps_per_mm(const float &value, const axis_t axis) {
     planner.settings.axis_steps_per_mm[axis] = value;
     planner.refresh_positioning();
   }
 
-  void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
+  void setAxisSteps_per_mm(const float &value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
     planner.refresh_positioning();
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
@@ -578,116 +578,105 @@ namespace ExtUI {
 
   float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
-  void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
+  void setAxisMaxAcceleration_mm_s2(const float &value, const axis_t axis) {
     planner.set_max_acceleration(axis, value);
     planner.reset_acceleration_rates();
   }
 
-  void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
+  void setAxisMaxAcceleration_mm_s2(const float &value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
     planner.reset_acceleration_rates();
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
-      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
+      void setFilamentRunoutDistance_mm(const float &value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
   #if ENABLED(CASE_LIGHT_ENABLE)
     bool getCaseLightState()                 { return caselight.on; }
     void setCaseLightState(const bool value) {
       caselight.on = value;
       caselight.update_enabled();
     }
 
     #if CASELIGHT_USES_BRIGHTNESS
       float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
-      void setCaseLightBrightness_percent(const float value) {
+      void setCaseLightBrightness_percent(const float &value) {
          caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
          caselight.update_brightness();
       }
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
-    void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
+    void setLinearAdvance_mm_mm_s(const float &value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
-    void setJunctionDeviation_mm(const float value) {
+    void setJunctionDeviation_mm(const float &value) {
       planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
-
-    float getAxisMaxJerk_mm_s(const axis_t axis) {
-      return planner.max_jerk[axis];
-    }
-
-    float getAxisMaxJerk_mm_s(const extruder_t) {
-      return planner.max_jerk.e;
-    }
-
-    void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
-      planner.set_max_jerk((AxisEnum)axis, value);
-    }
-
-    void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
-      planner.set_max_jerk(E_AXIS, value);
-    }
+    float getAxisMaxJerk_mm_s(const axis_t axis) { return planner.max_jerk[axis]; }
+    float getAxisMaxJerk_mm_s(const extruder_t) { return planner.max_jerk.e; }
+    void setAxisMaxJerk_mm_s(const float &value, const axis_t axis) { planner.set_max_jerk((AxisEnum)axis, value); }
+    void setAxisMaxJerk_mm_s(const float &value, const extruder_t) { planner.set_max_jerk(E_AXIS, value); }
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
   int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
   void setFlow_percent(const int16_t flow, const extruder_t extr) { planner.set_flow(extr, flow); }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
-  void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
-  void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
-  void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
+  void setPrintingAcceleration_mm_s2(const float &acc) { planner.settings.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float &acc)  { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float &acc)   { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
+
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)
           case X: babystep.add_steps(X_AXIS, steps); break;
           case Y: babystep.add_steps(Y_AXIS, steps); break;
         #endif
         case Z: babystep.add_steps(Z_AXIS, steps); break;
         default: return false;
       };
       return true;
@@ -731,183 +720,182 @@ namespace ExtUI {
         }
       #else
         UNUSED(linked_nozzles);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
-    int16_t mmToWholeSteps(const float mm, const axis_t axis) {
+    int16_t mmToWholeSteps(const float &mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
-  #endif
+
+  #endif // BABYSTEPPING
 
   float getZOffset_mm() {
     return (0.0f
       #if HAS_BED_PROBE
         + probe.offset.z
       #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
         + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #endif
     );
   }
 
-  void setZOffset_mm(const float value) {
+  void setZOffset_mm(const float &value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, value - getZOffset_mm());
     #else
       UNUSED(value);
     #endif
   }
 
   #if HAS_HOTEND_OFFSET
 
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
       return hotend_offset[extruder - E0][axis];
     }
 
-    void setNozzleOffset_mm(const float value, const axis_t axis, const extruder_t extruder) {
+    void setNozzleOffset_mm(const float &value, const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return;
       hotend_offset[extruder - E0][axis] = value;
     }
 
     /**
      * The UI should call this if needs to guarantee the first
      * nozzle offset is zero (such as when it doesn't allow the
      * user to edit the offset the first nozzle).
      */
     void normalizeNozzleOffset(const axis_t axis) {
       const float offs = hotend_offset[0][axis];
       HOTEND_LOOP() hotend_offset[e][axis] -= offs;
     }
 
   #endif // HAS_HOTEND_OFFSET
 
   #if HAS_BED_PROBE
-    float getProbeOffset_mm(const axis_t axis) {
-      return probe.offset.pos[axis];
-    }
-    void setProbeOffset_mm(const float val, const axis_t axis) {
-      probe.offset.pos[axis] = val;
-    }
+    float getProbeOffset_mm(const axis_t axis) { return probe.offset.pos[axis]; }
+    void setProbeOffset_mm(const float &val, const axis_t axis) { probe.offset.pos[axis] = val; }
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
     float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
-    void setAxisBacklash_mm(const float value, const axis_t axis)
+    void setAxisBacklash_mm(const float &value, const axis_t axis)
                                                       { backlash.distance_mm[axis] = constrain(value,0,5); }
 
     float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
-    void setBacklashCorrection_percent(const float value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
+    void setBacklashCorrection_percent(const float &value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
       float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
-      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = constrain(value, 0, 999); }
+      void setBacklashSmoothing_mm(const float &value) { backlash.smoothing_mm = constrain(value, 0, 999); }
     #endif
   #endif
 
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
-      void setMeshPoint(const xy_uint8_t &pos, const float zoff) {
+      void setMeshPoint(const xy_uint8_t &pos, const float &zoff) {
         if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(pos.x, pos.y) = zoff;
           TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
     #endif
   #endif
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
     void setHostResponse(const uint8_t response) { host_response_handler(response); }
   #endif
 
   #if ENABLED(PRINTCOUNTER)
+    char* getFailedPrints_str(char buffer[21])   { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints - print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
     char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
     char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }
     char* getLongestPrint_str(char buffer[21])   { return duration_t(print_job_timer.getStats().longestPrint).toString(buffer); }
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
       return buffer;
     }
   #endif
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
   #if ENABLED(PIDTEMP)
     float getPIDValues_Kp(const extruder_t tool) { return PID_PARAM(Kp, tool); }
     float getPIDValues_Ki(const extruder_t tool) { return unscalePID_i(PID_PARAM(Ki, tool)); }
     float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
 
-    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
+    void setPIDValues(const float &p, const float &i, const float &d, extruder_t tool) {
       thermalManager.temp_hotend[tool].pid.Kp = p;
       thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
       thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startPIDTune(const float temp, extruder_t tool) {
+    void startPIDTune(const float &temp, extruder_t tool) {
       thermalManager.PID_autotune(temp, (heater_id_t)tool, 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
     float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
     float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
 
-    void setBedPIDValues(const float p, const float i, const float d) {
+    void setBedPIDValues(const float &p, const float &i, const float &d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startBedPIDTune(const float temp) {
+    void startBedPIDTune(const float &temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
   void injectCommands(char * const gcode)  { queue.inject(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) { return axis_is_trusted((AxisEnum)axis); }
   bool isAxisPositionKnown(const extruder_t) { return axis_is_trusted(E_AXIS); }
   bool isPositionKnown() { return all_axes_trusted(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
     static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);
     return firmware_name;
   }
 
-  void setTargetTemp_celsius(float value, const heater_t heater) {
+  void setTargetTemp_celsius(const float &inval, const heater_t heater) {
+    float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
     switch (heater) {
       #if HAS_HEATED_CHAMBER
         case CHAMBER: thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10))); break;
       #endif
       #if HAS_COOLER
         case COOLER: thermalManager.setTargetCooler(LROUND(constrain(value, 0, COOLER_MAXTEMP))); break;
@@ -917,84 +905,85 @@ namespace ExtUI {
       #endif
       default: {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
         #endif
       } break;
     }
   }
 
-  void setTargetTemp_celsius(float value, const extruder_t extruder) {
+  void setTargetTemp_celsius(const float &inval, const extruder_t extruder) {
+    float value = inval;
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
     #endif
   }
 
-  void setTargetFan_percent(const float value, const fan_t fan) {
+  void setTargetFan_percent(const float &value, const fan_t fan) {
     #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
-  void setFeedrate_percent(const float value) {
-    feedrate_percentage = constrain(value, 10, 500);
-  }
+  void setFeedrate_percent(const float &value) { feedrate_percentage = constrain(value, 10, 500); }
 
-  bool awaitingUserConfirm() {
-    return wait_for_user;
+  void coolDown() {
+    #if HAS_HOTEND
+      HOTEND_LOOP() thermalManager.setTargetHotend(0, e);
+    #endif
+    TERN_(HAS_HEATED_BED, thermalManager.setTargetBed(0));
+    TERN_(HAS_FAN, thermalManager.zero_fan_speeds());
   }
 
-  void setUserConfirmed() {
-    TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
-  }
+  bool awaitingUserConfirm() { return wait_for_user; }
+
+  void setUserConfirmed() { TERN_(HAS_RESUME_CONTINUE, wait_for_user = false); }
 
   void printFile(const char *filename) {
     UNUSED(filename);
-    IFSD(card.openAndPrintFile(filename), NOOP);
+    TERN_(SDSUPPORT, card.openAndPrintFile(filename));
   }
 
   bool isPrintingFromMediaPaused() {
-    return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
+    return TERN0(SDSUPPORT, isPrintingFromMedia() && !IS_SD_PRINTING());
   }
 
   bool isPrintingFromMedia() {
     #if ENABLED(SDSUPPORT)
       // Account for when IS_SD_PRINTING() reports the end of the
       // print when there is still SD card data in the planner.
       flags.was_sd_printing = card.isFileOpen() || (flags.was_sd_printing && commandsInQueue());
       return flags.was_sd_printing;
     #else
       return false;
     #endif
   }
 
   bool isPrinting() {
-    return (commandsInQueue() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false)) || print_job_timer.isRunning() || print_job_timer.isPaused();
+    return (commandsInQueue() || isPrintingFromMedia() || TERN0(SDSUPPORT, IS_SD_PRINTING())) || print_job_timer.isRunning() || print_job_timer.isPaused();
   }
 
   bool isPrintingPaused() {
     return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
-  bool isMediaInserted() {
-    return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
-  }
+  bool isMediaInserted() { return TERN0(SDSUPPORT, IS_SD_INSERTED() && card.isMounted()); }
 
   void pausePrint() { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint() { ui.abort_print(); }
 
   void onUserConfirmRequired_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);
     onUserConfirmRequired(msg);
   }
@@ -1015,41 +1004,41 @@ namespace ExtUI {
       card.getfilename_sorted(SD_ORDER(pos, count()));
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
-    return IFSD(card.longest_filename(), "");
+    return TERN(SDSUPPORT, card.longest_filename(), "");
   }
 
   const char* FileList::shortFilename() {
-    return IFSD(card.filename, "");
+    return TERN(SDSUPPORT, card.filename, "");
   }
 
   const char* FileList::longFilename() {
-    return IFSD(card.longFilename, "");
+    return TERN(SDSUPPORT, card.longFilename, "");
   }
 
   bool FileList::isDir() {
-    return IFSD(card.flag.filenameIsDir, false);
+    return TERN0(SDSUPPORT, card.flag.filenameIsDir);
   }
 
   uint16_t FileList::count() {
-    return IFSD((num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)), 0);
+    return TERN0(SDSUPPORT, (num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)));
   }
 
   bool FileList::isAtRootDir() {
-    return IFSD(card.flag.workDirIsRoot, true);
+    return TERN1(SDSUPPORT, card.flag.workDirIsRoot);
   }
 
   void FileList::upDir() {
     #if ENABLED(SDSUPPORT)
       card.cdup();
       num_files = 0xFFFF;
     #endif
   }
 
   void FileList::changeDir(const char * const dirname) {

commit b95e548ddbcbc1c088eabc17992d0a06f82ac167
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Mar 6 14:13:28 2021 -0600

    Cooler (for Laser) - M143, M193 (#21255)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7c178a0339..c5c35321ca 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -169,20 +169,21 @@ namespace ExtUI {
     #endif
   }
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
           case BED: thermalManager.reset_bed_idle_timer(); return;
         #endif
         TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return); // Chamber has no idle timer
+        TERN_(HAS_COOLER, case COOLER: return); // Cooler has no idle timer
         default:
           TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
 
   #if ENABLED(JOYSTICK)
@@ -897,36 +898,37 @@ namespace ExtUI {
   PGM_P getFirmwareName_str() {
     static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);
     return firmware_name;
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
-    #if HAS_HEATED_CHAMBER
-      if (heater == CHAMBER)
-        thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
-      else
-    #endif
-    #if HAS_HEATED_BED
-      if (heater == BED)
-        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET)));
-      else
-    #endif
-      {
+    switch (heater) {
+      #if HAS_HEATED_CHAMBER
+        case CHAMBER: thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10))); break;
+      #endif
+      #if HAS_COOLER
+        case COOLER: thermalManager.setTargetCooler(LROUND(constrain(value, 0, COOLER_MAXTEMP))); break;
+      #endif
+      #if HAS_HEATED_BED
+        case BED: thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET))); break;
+      #endif
+      default: {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
         #endif
-      }
+      } break;
+    }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);

commit 1aa421efe54eef40a5ba2ba7706908a4ca384586
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:50:17 2021 -0600

    Filament sensor cleanup

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index d1ffb4c437..7c178a0339 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -333,31 +333,35 @@ namespace ExtUI {
     #if HAS_MULTI_EXTRUDER
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);
       UNUSED(no_move);
     #endif
   }
 
-  extruder_t getActiveTool() {
-    switch (active_extruder) {
+  extruder_t getTool(const uint8_t extruder) {
+    switch (extruder) {
+      case 7:  return E7;
+      case 6:  return E6;
       case 5:  return E5;
       case 4:  return E4;
       case 3:  return E3;
       case 2:  return E2;
       case 1:  return E1;
       default: return E0;
     }
   }
 
+  extruder_t getActiveTool() { return getTool(active_extruder); }
+
   bool isMoving() { return planner.has_blocks_queued(); }
 
   bool canMove(const axis_t axis) {
     switch (axis) {
       #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
         case X: return axis_should_home(X_AXIS);
         case Y: return axis_should_home(Y_AXIS);
         case Z: return axis_should_home(Z_AXIS);
       #else
         case X: case Y: case Z: return true;

commit 9d0e64a725290233d6002017147c578ffd32c504
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 28 20:40:20 2021 -0600

    AutoReport class (Temperature, Cardreader) (#20913)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 18689fe36d..d1ffb4c437 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -116,21 +116,21 @@ namespace ExtUI {
      */
     uint32_t safe_millis() {
       // Not killed? Just call millis()
       if (!flags.printer_killed) return millis();
 
       static uint32_t currTimeHI = 0; /* Current time */
 
       // Machine was killed, reinit SysTick so we are able to compute time without ISRs
       if (currTimeHI == 0) {
         // Get the last time the Arduino time computed (from CMSIS) and convert it to SysTick
-        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU / 8000)) >> 24);
+        currTimeHI = uint32_t((GetTickCount() * uint64_t(F_CPU / 8000)) >> 24);
 
         // Reinit the SysTick timer to maximize its period
         SysTick->LOAD  = SysTick_LOAD_RELOAD_Msk;                    // get the full range for the systick timer
         SysTick->VAL   = 0;                                          // Load the SysTick Counter Value
         SysTick->CTRL  = // MCLK/8 as source
                          // No interrupts
                          SysTick_CTRL_ENABLE_Msk;                    // Enable SysTick Timer
      }
 
       // Check if there was a timer overflow from the last read
@@ -141,23 +141,23 @@ namespace ExtUI {
 
       // Calculate current time in milliseconds
       uint32_t currTimeLO = SysTick_LOAD_RELOAD_Msk - SysTick->VAL; // (in MCLK/8)
       uint64_t currTime = ((uint64_t)currTimeLO) | (((uint64_t)currTimeHI) << 24);
 
       // The ms count is
       return (uint32_t)(currTime / (F_CPU / 8000));
     }
   #endif // __SAM3X8E__
 
-  void delay_us(unsigned long us) { DELAY_US(us); }
+  void delay_us(uint32_t us) { DELAY_US(us); }
 
-  void delay_ms(unsigned long ms) {
+  void delay_ms(uint32_t ms) {
     if (flags.printer_killed)
       DELAY_US(ms * 1000);
     else
       safe_delay(ms);
   }
 
   void yield() {
     if (!flags.printer_killed) thermalManager.manage_heater();
   }
 

commit d03c3980de30e593e3336737f6da45f3bfc7d42e
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Fri Jan 15 12:59:27 2021 -0700

    Improve filament runout handling in FTDI EVE Touch UI
    
    - On filament runout, take the user to the tune menu where they can initiate a filament change or resume the print.

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7611dbb98a..18689fe36d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -936,20 +936,24 @@ namespace ExtUI {
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const float value) {
     feedrate_percentage = constrain(value, 10, 500);
   }
 
+  bool awaitingUserConfirm() {
+    return wait_for_user;
+  }
+
   void setUserConfirmed() {
     TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
   }
 
   void printFile(const char *filename) {
     UNUSED(filename);
     IFSD(card.openAndPrintFile(filename), NOOP);
   }
 
   bool isPrintingFromMediaPaused() {

commit 2d88a2cfb7a85104414154ae66a92b2d63dda352
Author: LinFor <linfor@gmail.com>
Date:   Thu Dec 24 01:37:17 2020 +0300

    Remaining Time for FTDI EVE, bp for ExtUI (#20549)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 3bf06a68c2..7611dbb98a 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -238,21 +238,21 @@ namespace ExtUI {
         default:
           return TERN0(HAS_HOTEND, thermalManager.heater_idle[heater - H0].timed_out);
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
-    #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
+    #define GET_TEMP_ADJUSTMENT(A) (float(A) / (TOUCH_UI_LCD_TEMP_SCALING))
   #else
     #define GET_TEMP_ADJUSTMENT(A) A
   #endif
 
   float getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
       TERN_(HAS_HEATED_BED, case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed()));
       TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber()));
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
@@ -800,24 +800,20 @@ namespace ExtUI {
 
     float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
     void setBacklashCorrection_percent(const float value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
 
     #ifdef BACKLASH_SMOOTHING_MM
       float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
       void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = constrain(value, 0, 999); }
     #endif
   #endif
 
-  uint8_t getProgress_percent() {
-    return ui.get_progress_percent();
-  }
-
   uint32_t getProgress_seconds_elapsed() {
     const duration_t elapsed = print_job_timer.duration();
     return elapsed.value;
   }
 
   #if HAS_LEVELING
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH

commit 6af6a35d9d5b1af8cb12002fd71e986f625920ae
Author: LinFor <linfor@gmail.com>
Date:   Wed Dec 23 09:51:59 2020 +0300

    FTDI EVE: Cyrillic font, some minor fixes (#20517)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1877914bfb..3bf06a68c2 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1009,21 +1009,21 @@ namespace ExtUI {
       card.getfilename_sorted(SD_ORDER(pos, count()));
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
-    return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");
+    return IFSD(card.longest_filename(), "");
   }
 
   const char* FileList::shortFilename() {
     return IFSD(card.filename, "");
   }
 
   const char* FileList::longFilename() {
     return IFSD(card.longFilename, "");
   }
 

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1583db41e9..1877914bfb 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -349,23 +349,23 @@ namespace ExtUI {
       case 1:  return E1;
       default: return E0;
     }
   }
 
   bool isMoving() { return planner.has_blocks_queued(); }
 
   bool canMove(const axis_t axis) {
     switch (axis) {
       #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-        case X: return TEST(axis_homed, X_AXIS);
-        case Y: return TEST(axis_homed, Y_AXIS);
-        case Z: return TEST(axis_homed, Z_AXIS);
+        case X: return axis_should_home(X_AXIS);
+        case Y: return axis_should_home(Y_AXIS);
+        case Z: return axis_should_home(Z_AXIS);
       #else
         case X: case Y: case Z: return true;
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
@@ -882,23 +882,23 @@ namespace ExtUI {
     void startBedPIDTune(const float temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
   void injectCommands(char * const gcode)  { queue.inject(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
-  bool isAxisPositionKnown(const axis_t axis) { return TEST(axis_known_position, axis); }
-  bool isAxisPositionKnown(const extruder_t) { return TEST(axis_known_position, E_AXIS); }
-  bool isPositionKnown() { return all_axes_known(); }
+  bool isAxisPositionKnown(const axis_t axis) { return axis_is_trusted((AxisEnum)axis); }
+  bool isAxisPositionKnown(const extruder_t) { return axis_is_trusted(E_AXIS); }
+  bool isPositionKnown() { return all_axes_trusted(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
     static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);
     return firmware_name;
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;

commit caeac3851ab74ff16bd57003135d30272b25da5f
Author: Philippe Cayrol <58492957+phcay@users.noreply.github.com>
Date:   Wed Nov 18 06:56:51 2020 +0100

    Better edit range for Linear Advance K (#20155)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index ac8e6ebf88..1583db41e9 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -619,21 +619,21 @@ namespace ExtUI {
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
-        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 999);
+        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 10);
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
     void setJunctionDeviation_mm(const float value) {

commit af75e24c2e4bb380dc9496cba5fd397f056ad0ab
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 6 19:09:29 2020 -0600

    Clean up corrected urls

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 80033e911b..ac8e6ebf88 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -31,21 +31,21 @@
  *   it under the terms of the GNU General Public License as published by   *
  *   the Free Software Foundation, either version 3 of the License, or      *
  *   (at your option) any later version.                                    *
  *                                                                          *
  *   This program is distributed in the hope that it will be useful,        *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
  *   GNU General Public License for more details.                           *
  *                                                                          *
  *   To view a copy of the GNU General Public License, go to the following  *
- *   location: <https://www.gnu.org/licenses/>.                              *
+ *   location: <https://www.gnu.org/licenses/>.                             *
  ****************************************************************************/
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(EXTENSIBLE_UI)
 
 #include "../marlinui.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"

commit b6856dcb999b51077c89eb30c5ec102c507152c0
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Wed Oct 28 11:23:46 2020 -0600

    Improvement and fixes to FTDI touch UI
    
    - Fixed incorrect LCD text string
    - Fixed incorrect refresh of filament change screens
    - Allow host control via touch UI
    - Updates to leveling menu
    - Modified ExtUI::isPrinting() to check if the job timer is running
    - Added ExtUI method to check whether a host print is paused

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 33b5d5458e..80033e911b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -965,21 +965,25 @@ namespace ExtUI {
       // Account for when IS_SD_PRINTING() reports the end of the
       // print when there is still SD card data in the planner.
       flags.was_sd_printing = card.isFileOpen() || (flags.was_sd_printing && commandsInQueue());
       return flags.was_sd_printing;
     #else
       return false;
     #endif
   }
 
   bool isPrinting() {
-    return (commandsInQueue() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
+    return (commandsInQueue() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false)) || print_job_timer.isRunning() || print_job_timer.isPaused();
+  }
+
+  bool isPrintingPaused() {
+    return isPrinting() && (isPrintingFromMediaPaused() || print_job_timer.isPaused());
   }
 
   bool isMediaInserted() {
     return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
   }
 
   void pausePrint() { ui.pause_print(); }
   void resumePrint() { ui.resume_print(); }
   void stopPrint() { ui.abort_print(); }
 

commit 0ffee29a11eeaa488bc3f64c773e86c5944ec286
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 22:31:48 2020 -0500

    Case light brightness cleanup (#19856)
    
    Co-authored-by: Chris <chris@chrisnovoa.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 8151828a08..33b5d5458e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -603,21 +603,21 @@ namespace ExtUI {
     #endif
   #endif
 
   #if ENABLED(CASE_LIGHT_ENABLE)
     bool getCaseLightState()                 { return caselight.on; }
     void setCaseLightState(const bool value) {
       caselight.on = value;
       caselight.update_enabled();
     }
 
-    #if DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+    #if CASELIGHT_USES_BRIGHTNESS
       float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
       void setCaseLightBrightness_percent(const float value) {
          caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
          caselight.update_brightness();
       }
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 30cf696f3e..8151828a08 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -38,21 +38,21 @@
  *   GNU General Public License for more details.                           *
  *                                                                          *
  *   To view a copy of the GNU General Public License, go to the following  *
  *   location: <https://www.gnu.org/licenses/>.                              *
  ****************************************************************************/
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(EXTENSIBLE_UI)
 
-#include "../ultralcd.h"
+#include "../marlinui.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
 #include "../../sd/cardreader.h"
 
@@ -1046,25 +1046,23 @@ namespace ExtUI {
     #if ENABLED(SDSUPPORT)
       card.cd(dirname);
       num_files = 0xFFFF;
     #else
       UNUSED(dirname);
     #endif
   }
 
 } // namespace ExtUI
 
-// At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
+// At the moment we hook into MarlinUI methods, but this could be cleaned up in the future
 
-void MarlinUI::init() {
-  ExtUI::onStartup();
-}
+void MarlinUI::init() { ExtUI::onStartup(); }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 
 void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);
   }
 }

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 0acfc9c025..30cf696f3e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -298,41 +298,23 @@ namespace ExtUI {
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN_(JOYSTICK, flags.jogging ? destination.e :) current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
   void setAxisPosition_mm(const float position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
-    // Start with no limits to movement
-    float min = current_position[axis] - 1000,
-          max = current_position[axis] + 1000;
-
-    // Limit to software endstops, if enabled
-    #if HAS_SOFTWARE_ENDSTOPS
-      if (soft_endstops_enabled) switch (axis) {
-        case X_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_X, min = soft_endstop.min.x);
-          TERN_(MAX_SOFTWARE_ENDSTOP_X, max = soft_endstop.max.x);
-          break;
-        case Y_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_Y, min = soft_endstop.min.y);
-          TERN_(MAX_SOFTWARE_ENDSTOP_Y, max = soft_endstop.max.y);
-          break;
-        case Z_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_Z, min = soft_endstop.min.z);
-          TERN_(MAX_SOFTWARE_ENDSTOP_Z, max = soft_endstop.max.z);
-        default: break;
-      }
-    #endif // HAS_SOFTWARE_ENDSTOPS
+    // Get motion limit from software endstops, if any
+    float min, max;
+    soft_endstop.get_manual_axis_limits((AxisEnum)axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
         max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
@@ -382,22 +364,22 @@ namespace ExtUI {
       #endif
       default: return false;
     }
   }
 
   bool canMove(const extruder_t extruder) {
     return !thermalManager.tooColdToExtrude(extruder - E0);
   }
 
   #if HAS_SOFTWARE_ENDSTOPS
-    bool getSoftEndstopState() { return soft_endstops_enabled; }
-    void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
+    bool getSoftEndstopState() { return soft_endstop._enabled; }
+    void setSoftEndstopState(const bool value) { soft_endstop._enabled = value; }
   #endif
 
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: return stepperX.getMilliamps();
         #endif
         #if AXIS_IS_TMC(X2)
           case X2: return stepperX2.getMilliamps();

commit d06bcd6dd39b48dcf23a26feaf7d6a07cc67da68
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Fri Oct 2 16:30:32 2020 -0600

    Touch UI support for X2, Y2 and Z2 (#19538)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1270e3d649..0acfc9c025 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -392,26 +392,35 @@ namespace ExtUI {
     bool getSoftEndstopState() { return soft_endstops_enabled; }
     void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
   #endif
 
   #if HAS_TRINAMIC_CONFIG
     float getAxisCurrent_mA(const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
           case X: return stepperX.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(X2)
+          case X2: return stepperX2.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(Y)
           case Y: return stepperY.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(Y2)
+          case Y2: return stepperY2.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(Z)
           case Z: return stepperZ.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(Z2)
+          case Z2: return stepperZ2.getMilliamps();
+        #endif
         default: return NAN;
       };
     }
 
     float getAxisCurrent_mA(const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
           case E0: return stepperE0.getMilliamps();
         #endif
         #if AXIS_IS_TMC(E1)
@@ -435,57 +444,66 @@ namespace ExtUI {
         #if AXIS_IS_TMC(E7)
           case E7: return stepperE7.getMilliamps();
         #endif
         default: return NAN;
       };
     }
 
     void  setAxisCurrent_mA(const float mA, const axis_t axis) {
       switch (axis) {
         #if AXIS_IS_TMC(X)
-          case X: stepperX.rms_current(constrain(mA, 500, 1500)); break;
+          case X: stepperX.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(X2)
+          case X2: stepperX2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Y)
-          case Y: stepperY.rms_current(constrain(mA, 500, 1500)); break;
+          case Y: stepperY.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          case Y2: stepperY2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(Z)
-          case Z: stepperZ.rms_current(constrain(mA, 500, 1500)); break;
+          case Z: stepperZ.rms_current(constrain(mA, 400, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          case Z2: stepperZ2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
     void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
       switch (extruder) {
         #if AXIS_IS_TMC(E0)
-          case E0: stepperE0.rms_current(constrain(mA, 500, 1500)); break;
+          case E0: stepperE0.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E1)
-          case E1: stepperE1.rms_current(constrain(mA, 500, 1500)); break;
+          case E1: stepperE1.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E2)
-          case E2: stepperE2.rms_current(constrain(mA, 500, 1500)); break;
+          case E2: stepperE2.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E3)
-          case E3: stepperE3.rms_current(constrain(mA, 500, 1500)); break;
+          case E3: stepperE3.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E4)
-          case E4: stepperE4.rms_current(constrain(mA, 500, 1500)); break;
+          case E4: stepperE4.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E5)
-          case E5: stepperE5.rms_current(constrain(mA, 500, 1500)); break;
+          case E5: stepperE5.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E6)
-          case E6: stepperE6.rms_current(constrain(mA, 500, 1500)); break;
+          case E6: stepperE6.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         #if AXIS_IS_TMC(E7)
-          case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
+          case E7: stepperE7.rms_current(constrain(mA, 400, 1500)); break;
         #endif
         default: break;
       };
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
         TERN_(X_SENSORLESS,  case X:  return stepperX.homing_threshold());
         TERN_(X2_SENSORLESS, case X2: return stepperX2.homing_threshold());
         TERN_(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold());

commit 5f5f76956f11c7c58278fd449f6ad85e07cd6e10
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 22 19:58:06 2020 -0500

    Fix up tests, warnings

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index afc9c6692e..1270e3d649 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -698,21 +698,21 @@ namespace ExtUI {
      * what nozzle is printing.
      */
     void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
       const float mm = steps * planner.steps_to_mm[axis];
       UNUSED(mm);
 
       if (!babystepAxis_steps(steps, axis)) return;
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         // Make it so babystepping in Z adjusts the Z probe offset.
-        if (axis == Z && TERN1(HAS_MULTI_EXTRUDER, linked_nozzles || active_extruder == 0))
+        if (axis == Z && TERN1(HAS_MULTI_EXTRUDER, (linked_nozzles || active_extruder == 0)))
           probe.offset.z += mm;
       #endif
 
       #if HAS_MULTI_EXTRUDER && HAS_HOTEND_OFFSET
         /**
          * When linked_nozzles is false, as an axis is babystepped
          * adjust the hotend offsets so that the other nozzles are
          * unaffected by the babystepping of the active nozzle.
          */
         if (!linked_nozzles) {

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1637d32877..afc9c6692e 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -54,21 +54,21 @@
 #include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
 #include "../../sd/cardreader.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
   #include "../../libs/numtostr.h"
 #endif
 
-#if EXTRUDERS > 1
+#if HAS_MULTI_EXTRUDER
   #include "../../module/tool_change.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../../feature/e_parser.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../../feature/tmc_util.h"
   #include "../../module/stepper/indirection.h"
@@ -341,21 +341,21 @@ namespace ExtUI {
   }
 
   void setAxisPosition_mm(const float position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
     line_to_current_position(feedrate ?: manual_feedrate_mm_s.e);
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
-    #if EXTRUDERS > 1
+    #if HAS_MULTI_EXTRUDER
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);
       UNUSED(no_move);
     #endif
   }
 
   extruder_t getActiveTool() {
@@ -692,52 +692,47 @@ namespace ExtUI {
      * This function adjusts an axis during a print.
      *
      * When linked_nozzles is false, each nozzle in a multi-nozzle
      * printer can be babystepped independently of the others. This
      * lets the user to fine tune the Z-offset and Nozzle Offsets
      * while observing the first layer of a print, regardless of
      * what nozzle is printing.
      */
     void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
       const float mm = steps * planner.steps_to_mm[axis];
+      UNUSED(mm);
 
       if (!babystepAxis_steps(steps, axis)) return;
 
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         // Make it so babystepping in Z adjusts the Z probe offset.
-        if (axis == Z
-          #if EXTRUDERS > 1
-            && (linked_nozzles || active_extruder == 0)
-          #endif
-        ) probe.offset.z += mm;
-      #else
-        UNUSED(mm);
+        if (axis == Z && TERN1(HAS_MULTI_EXTRUDER, linked_nozzles || active_extruder == 0))
+          probe.offset.z += mm;
       #endif
 
-      #if EXTRUDERS > 1 && HAS_HOTEND_OFFSET
+      #if HAS_MULTI_EXTRUDER && HAS_HOTEND_OFFSET
         /**
          * When linked_nozzles is false, as an axis is babystepped
          * adjust the hotend offsets so that the other nozzles are
          * unaffected by the babystepping of the active nozzle.
          */
         if (!linked_nozzles) {
           HOTEND_LOOP()
             if (e != active_extruder)
               hotend_offset[e][axis] += mm;
 
           normalizeNozzleOffset(X);
           normalizeNozzleOffset(Y);
           normalizeNozzleOffset(Z);
         }
       #else
         UNUSED(linked_nozzles);
-        UNUSED(mm);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
     int16_t mmToWholeSteps(const float mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);

commit 0f9eb480aa7309e6b876e2643cd26a9425f5fd88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 14 02:48:45 2020 -0500

    Allow E3 V2 DWIN without EEPROM, POWER_LOSS_RECOVERY

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 4d65429bf1..1637d32877 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -752,21 +752,21 @@ namespace ExtUI {
         + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
       #endif
     );
   }
 
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
+      babystep.add_mm(Z_AXIS, value - getZOffset_mm());
     #else
       UNUSED(value);
     #endif
   }
 
   #if HAS_HOTEND_OFFSET
 
     float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
       if (extruder - E0 >= HOTENDS) return 0;
       return hotend_offset[extruder - E0][axis];

commit 979876e958e73e642b51eb655461c92947fe1deb
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Sep 14 16:58:39 2020 +1200

    Improve temperature runaway, idle timeout (#19339)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 53b7dc6279..4d65429bf1 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -216,34 +216,34 @@ namespace ExtUI {
           flags.jogging = false;
           return;
         }
         norm_jog = destination;
       }
     }
   #endif
 
   bool isHeaterIdle(const extruder_t extruder) {
     #if HAS_HOTEND && HEATER_IDLE_HANDLER
-      return thermalManager.hotend_idle[extruder - E0].timed_out;
+      return thermalManager.heater_idle[extruder - E0].timed_out;
     #else
       UNUSED(extruder);
       return false;
     #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
-        TERN_(HAS_HEATED_BED, case BED: return thermalManager.bed_idle.timed_out);
+        TERN_(HAS_HEATED_BED, case BED: return thermalManager.heater_idle[thermalManager.IDLE_INDEX_BED].timed_out);
         TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return false); // Chamber has no idle timer
         default:
-          return TERN0(HAS_HOTEND, thermalManager.hotend_idle[heater - H0].timed_out);
+          return TERN0(HAS_HOTEND, thermalManager.heater_idle[heater - H0].timed_out);
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
   #else

commit 49ca16c3fb103e8e29f64107ba664aa82917b9f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 13 18:06:14 2020 -0500

    heater_ind_t => heater_id_t

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c2eab2ba06..53b7dc6279 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -861,21 +861,21 @@ namespace ExtUI {
     float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
 
     void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
       thermalManager.temp_hotend[tool].pid.Kp = p;
       thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
       thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
     void startPIDTune(const float temp, extruder_t tool) {
-      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
+      thermalManager.PID_autotune(temp, (heater_id_t)tool, 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
     float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
     float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
     float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
 
     void setBedPIDValues(const float p, const float i, const float d) {
       thermalManager.temp_bed.pid.Kp = p;

commit 872516f9f903157fbd927bf6083996da70ab4e63
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Sep 12 22:32:00 2020 -0600

    Touch UI "Leveling" menu, misc. fixes (#19349)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c40a869421..c2eab2ba06 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -537,25 +537,27 @@ namespace ExtUI {
     return planner.settings.axis_steps_per_mm[axis];
   }
 
   float getAxisSteps_per_mm(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisSteps_per_mm(const float value, const axis_t axis) {
     planner.settings.axis_steps_per_mm[axis] = value;
+    planner.refresh_positioning();
   }
 
   void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
+    planner.refresh_positioning();
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_feedrate_mm_s[E_AXIS_N(extruder - E0)];
   }
@@ -573,25 +575,27 @@ namespace ExtUI {
     return planner.settings.max_acceleration_mm_per_s2[axis];
   }
 
   float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
     UNUSED_E(extruder);
     return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
     planner.set_max_acceleration(axis, value);
+    planner.reset_acceleration_rates();
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
+    planner.reset_acceleration_rates();
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }

commit 328d8b59529edcdc1beae4287ec6827fae3cab82
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Tue Sep 8 14:31:20 2020 -0600

    Fix ExtUI SD sorting, compile issues

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 31449fcef4..c40a869421 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -996,21 +996,21 @@ namespace ExtUI {
     onStatusChanged(msg);
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
-      card.getfilename_sorted(pos);
+      card.getfilename_sorted(SD_ORDER(pos, count()));
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
     return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");

commit 646d90f3da2feda848dc4a50fe3661701dc881d1
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Aug 25 22:43:33 2020 -0700

    Fix SD pins for SKR Pro and GTR (#19047)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 3df9c17f6b..31449fcef4 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1050,24 +1050,20 @@ namespace ExtUI {
     #else
       UNUSED(dirname);
     #endif
   }
 
 } // namespace ExtUI
 
 // At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
 
 void MarlinUI::init() {
-  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
-    SET_INPUT_PULLUP(SD_DETECT_PIN);
-  #endif
-
   ExtUI::onStartup();
 }
 
 void MarlinUI::update() { ExtUI::onIdle(); }
 
 void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);

commit 8f730cfb6e474f98f4ac284d443bac061634c497
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 14 08:45:48 2020 -0500

    Fix ExtUI base methods

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index c192754495..3df9c17f6b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -541,30 +541,30 @@ namespace ExtUI {
     UNUSED_E(extruder);
     return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisSteps_per_mm(const float value, const axis_t axis) {
     planner.settings.axis_steps_per_mm[axis] = value;
   }
 
   void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
     UNUSED_E(extruder);
-    planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
+    planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)] = value;
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
     return planner.settings.max_feedrate_mm_s[axis];
   }
 
   feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
     UNUSED_E(extruder);
-    return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
+    return planner.settings.max_feedrate_mm_s[E_AXIS_N(extruder - E0)];
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
     planner.set_max_feedrate(axis, value);
   }
 
   void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
   }

commit 99ba866d8d3c9abc16558ca12ba34efb9a7922e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 6 08:14:00 2020 -0500

    Optimize G-code / feature dependencies (#18919)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 451aa1f12a..c192754495 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -592,32 +592,32 @@ namespace ExtUI {
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
     bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
     void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
       void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
-  #if HAS_CASE_LIGHT
-    bool getCaseLightState()                 { return case_light_on; }
+  #if ENABLED(CASE_LIGHT_ENABLE)
+    bool getCaseLightState()                 { return caselight.on; }
     void setCaseLightState(const bool value) {
-      case_light_on = value;
-      update_case_light();
+      caselight.on = value;
+      caselight.update_enabled();
     }
 
     #if DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
-      float getCaseLightBrightness_percent()                 { return ui8_to_percent(case_light_brightness); }
+      float getCaseLightBrightness_percent()                 { return ui8_to_percent(caselight.brightness); }
       void setCaseLightBrightness_percent(const float value) {
-         case_light_brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
-         update_case_light();
+         caselight.brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
+         caselight.update_brightness();
       }
     #endif
   #endif
 
   #if ENABLED(LIN_ADVANCE)
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {

commit 6bcfb58cd4b208cf042fa4a66faf14f382d33d07
Author: Marco Burato <zmaster.adsl@gmail.com>
Date:   Thu Aug 6 12:38:18 2020 +0200

    More Anycubic + Trigorilla mappings, ExtUI (#18903)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index b5dbb11a06..451aa1f12a 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -297,21 +297,21 @@ namespace ExtUI {
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
     const float epos = TERN_(JOYSTICK, flags.jogging ? destination.e :) current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
-  void setAxisPosition_mm(const float position, const axis_t axis) {
+  void setAxisPosition_mm(const float position, const axis_t axis, const feedRate_t feedrate/*=0*/) {
     // Start with no limits to movement
     float min = current_position[axis] - 1000,
           max = current_position[axis] + 1000;
 
     // Limit to software endstops, if enabled
     #if HAS_SOFTWARE_ENDSTOPS
       if (soft_endstops_enabled) switch (axis) {
         case X_AXIS:
           TERN_(MIN_SOFTWARE_ENDSTOP_X, min = soft_endstop.min.x);
           TERN_(MAX_SOFTWARE_ENDSTOP_X, max = soft_endstop.max.x);
@@ -330,28 +330,28 @@ namespace ExtUI {
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z) {
         max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
-    line_to_current_position(manual_feedrate_mm_s[axis]);
+    line_to_current_position(feedrate ?: manual_feedrate_mm_s[axis]);
   }
 
-  void setAxisPosition_mm(const float position, const extruder_t extruder) {
+  void setAxisPosition_mm(const float position, const extruder_t extruder, const feedRate_t feedrate/*=0*/) {
     setActiveTool(extruder, true);
 
     current_position.e = position;
-    line_to_current_position(manual_feedrate_mm_s.e);
+    line_to_current_position(feedrate ?: manual_feedrate_mm_s.e);
   }
 
   void setActiveTool(const extruder_t extruder, bool no_move) {
     #if EXTRUDERS > 1
       const uint8_t e = extruder - E0;
       if (e != active_extruder) tool_change(e, no_move);
       active_extruder = e;
     #else
       UNUSED(extruder);
       UNUSED(no_move);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 5e1f2cfacf..b5dbb11a06 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**************
  * ui_api.cpp *
  **************/
 
 /****************************************************************************
  *   Written By Marcio Teixeira 2018 - Aleph Objects, Inc.                  *
  *                                                                          *
@@ -31,21 +31,21 @@
  *   it under the terms of the GNU General Public License as published by   *
  *   the Free Software Foundation, either version 3 of the License, or      *
  *   (at your option) any later version.                                    *
  *                                                                          *
  *   This program is distributed in the hope that it will be useful,        *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
  *   GNU General Public License for more details.                           *
  *                                                                          *
  *   To view a copy of the GNU General Public License, go to the following  *
- *   location: <http://www.gnu.org/licenses/>.                              *
+ *   location: <https://www.gnu.org/licenses/>.                              *
  ****************************************************************************/
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(EXTENSIBLE_UI)
 
 #include "../ultralcd.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"

commit 3b80690a71c0a97f75efb1721fc007ef5a018c1c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jun 27 23:02:28 2020 -0400

    ExtUI additions (#18447)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 65518908cb..5e1f2cfacf 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -583,20 +583,22 @@ namespace ExtUI {
   }
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
+    bool getFilamentRunoutState()                   { return runout.filament_ran_out; }
+    void setFilamentRunoutState(const bool value)   { runout.filament_ran_out = value; }
 
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
       void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
   #if HAS_CASE_LIGHT
     bool getCaseLightState()                 { return case_light_on; }
     void setCaseLightState(const bool value) {
@@ -877,20 +879,21 @@ namespace ExtUI {
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
     void startBedPIDTune(const float temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
+  void injectCommands(char * const gcode)  { queue.inject(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) { return TEST(axis_known_position, axis); }
   bool isAxisPositionKnown(const extruder_t) { return TEST(axis_known_position, E_AXIS); }
   bool isPositionKnown() { return all_axes_known(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
     static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);

commit cfd31ff70ee949eb5eea61bf30eac24aef9fcb9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 23:18:23 2020 -0500

    Add HAS_FILAMENT_RUNOUT_DISTANCE

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index e1c8dd9ac6..65518908cb 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -584,21 +584,21 @@ namespace ExtUI {
 
   void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
     UNUSED_E(extruder);
     planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
   }
 
   #if HAS_FILAMENT_SENSOR
     bool getFilamentRunoutEnabled()                 { return runout.enabled; }
     void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
 
-    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
+    #if HAS_FILAMENT_RUNOUT_DISTANCE
       float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
       void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
     #endif
   #endif
 
   #if HAS_CASE_LIGHT
     bool getCaseLightState()                 { return case_light_on; }
     void setCaseLightState(const bool value) {
       case_light_on = value;
       update_case_light();

commit 929b3f6af9cc6ae551f67ad9ed844ceb80cec9d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 23 22:19:45 2020 -0500

    Don't re-reverse sort

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 12df06c852..e1c8dd9ac6 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -993,21 +993,21 @@ namespace ExtUI {
     onStatusChanged(msg);
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
-      card.getfilename_sorted(SD_ORDER(pos, count()));
+      card.getfilename_sorted(pos);
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
     return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");

commit a4c981469e317b30ff21fba109e1b126e5dcafcf
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Wed May 6 10:04:04 2020 +0530

    Extended reporting options (#16741)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 95f630f7ec..12df06c852 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -886,21 +886,21 @@ namespace ExtUI {
   void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
   bool isAxisPositionKnown(const axis_t axis) { return TEST(axis_known_position, axis); }
   bool isAxisPositionKnown(const extruder_t) { return TEST(axis_known_position, E_AXIS); }
   bool isPositionKnown() { return all_axes_known(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
-    static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
+    static PGMSTR(firmware_name, "Marlin " SHORT_BUILD_VERSION);
     return firmware_name;
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
     #if HAS_HEATED_CHAMBER
       if (heater == CHAMBER)

commit 38d1587091ba7b7258a194f6ad950e80c1490225
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 4 14:37:43 2020 -0500

    Malyan M200 V2 (#17840)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 937a435d7d..95f630f7ec 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -323,22 +323,22 @@ namespace ExtUI {
         case Z_AXIS:
           TERN_(MIN_SOFTWARE_ENDSTOP_Z, min = soft_endstop.min.z);
           TERN_(MAX_SOFTWARE_ENDSTOP_Z, max = soft_endstop.max.z);
         default: break;
       }
     #endif // HAS_SOFTWARE_ENDSTOPS
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
-      if (axis != Z_AXIS) {
-        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+      if (axis != Z) {
+        max = SQRT(sq(float(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y - axis])); // (Y - axis) == the other axis
         min = -max;
       }
     #endif
 
     current_position[axis] = constrain(position, min, max);
     line_to_current_position(manual_feedrate_mm_s[axis]);
   }
 
   void setAxisPosition_mm(const float position, const extruder_t extruder) {
     setActiveTool(extruder, true);

commit 2a959cde6fdd5edea5c9ff20d613db024eb96749
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Mon May 4 12:57:12 2020 -0600

    Fix undefined/unused, Touch UI (#17874)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 2b72eca047..937a435d7d 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -47,38 +47,35 @@
 
 #include "../ultralcd.h"
 #include "../../gcode/queue.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../libs/duration_t.h"
 #include "../../HAL/shared/Delay.h"
+#include "../../sd/cardreader.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "../../core/utility.h"
   #include "../../libs/numtostr.h"
 #endif
 
 #if EXTRUDERS > 1
   #include "../../module/tool_change.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../../feature/e_parser.h"
 #endif
 
-#if ENABLED(SDSUPPORT)
-  #include "../../sd/cardreader.h"
-#endif
-
 #if HAS_TRINAMIC_CONFIG
   #include "../../feature/tmc_util.h"
   #include "../../module/stepper/indirection.h"
 #endif
 
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
   #include "../../feature/backlash.h"
 #endif

commit a226b281aff5d569bc18afb9879149e0e89d29df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 30 22:52:33 2020 -0500

    UI and stall reset for extra TMC axes (#17818)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index de043a3198..2b72eca047 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -482,39 +482,59 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         default: break;
       };
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
-        TERN_(X_SENSORLESS, case X: return stepperX.homing_threshold());
-        TERN_(Y_SENSORLESS, case Y: return stepperY.homing_threshold());
-        TERN_(Z_SENSORLESS, case Z: return stepperZ.homing_threshold());
+        TERN_(X_SENSORLESS,  case X:  return stepperX.homing_threshold());
+        TERN_(X2_SENSORLESS, case X2: return stepperX2.homing_threshold());
+        TERN_(Y_SENSORLESS,  case Y:  return stepperY.homing_threshold());
+        TERN_(Y2_SENSORLESS, case Y2: return stepperY2.homing_threshold());
+        TERN_(Z_SENSORLESS,  case Z:  return stepperZ.homing_threshold());
+        TERN_(Z2_SENSORLESS, case Z2: return stepperZ2.homing_threshold());
+        TERN_(Z3_SENSORLESS, case Z3: return stepperZ3.homing_threshold());
+        TERN_(Z4_SENSORLESS, case Z4: return stepperZ4.homing_threshold());
         default: return 0;
       }
     }
 
     void setTMCBumpSensitivity(const float value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           #if X_SENSORLESS
-            case X: stepperX.homing_threshold(value); break;
+            case X:  stepperX.homing_threshold(value);  break;
+          #endif
+          #if X2_SENSORLESS
+            case X2: stepperX2.homing_threshold(value); break;
           #endif
           #if Y_SENSORLESS
             case Y: stepperY.homing_threshold(value); break;
           #endif
+          #if Y2_SENSORLESS
+            case Y2: stepperY2.homing_threshold(value); break;
+          #endif
           #if Z_SENSORLESS
             case Z: stepperZ.homing_threshold(value); break;
           #endif
+          #if Z2_SENSORLESS
+            case Z2: stepperZ2.homing_threshold(value); break;
+          #endif
+          #if Z3_SENSORLESS
+            case Z3: stepperZ3.homing_threshold(value); break;
+          #endif
+          #if Z4_SENSORLESS
+            case Z4: stepperZ4.homing_threshold(value); break;
+          #endif
         #else
           UNUSED(value);
         #endif
         default: break;
       }
     }
   #endif
 
   float getAxisSteps_per_mm(const axis_t axis) {
     return planner.settings.axis_steps_per_mm[axis];

commit 2fbce229100c0be54fa918a43c2d8fdb5654d5f4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 29 01:47:31 2020 -0500

    Cleanup followup

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index e23674f2cf..de043a3198 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -219,21 +219,21 @@ namespace ExtUI {
           flags.jogging = false;
           return;
         }
         norm_jog = destination;
       }
     }
   #endif
 
   bool isHeaterIdle(const extruder_t extruder) {
     #if HAS_HOTEND && HEATER_IDLE_HANDLER
-      return thermalManager.hotend_idle[extruder - E0].timed_out
+      return thermalManager.hotend_idle[extruder - E0].timed_out;
     #else
       UNUSED(extruder);
       return false;
     #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         TERN_(HAS_HEATED_BED, case BED: return thermalManager.bed_idle.timed_out);

commit 3d3d2a923b733be0b9ad4aa2c5c596a6bb5f93f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 19:14:43 2020 -0500

    Cleanup with updated macros

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index a9536c68cd..e23674f2cf 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -63,23 +63,20 @@
 #if EXTRUDERS > 1
   #include "../../module/tool_change.h"
 #endif
 
 #if ENABLED(EMERGENCY_PARSER)
   #include "../../feature/e_parser.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   #include "../../sd/cardreader.h"
-  #define IFSD(A,B) (A)
-#else
-  #define IFSD(A,B) (B)
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../../feature/tmc_util.h"
   #include "../../module/stepper/indirection.h"
 #endif
 
 #include "ui_api.h"
 
 #if ENABLED(BACKLASH_GCODE)
@@ -157,43 +154,38 @@ namespace ExtUI {
   void delay_us(unsigned long us) { DELAY_US(us); }
 
   void delay_ms(unsigned long ms) {
     if (flags.printer_killed)
       DELAY_US(ms * 1000);
     else
       safe_delay(ms);
   }
 
   void yield() {
-    if (!flags.printer_killed)
-      thermalManager.manage_heater();
+    if (!flags.printer_killed) thermalManager.manage_heater();
   }
 
   void enableHeater(const extruder_t extruder) {
     #if HAS_HOTEND && HEATER_IDLE_HANDLER
       thermalManager.reset_hotend_idle_timer(extruder - E0);
     #else
       UNUSED(extruder);
     #endif
   }
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
-          case BED:
-            thermalManager.reset_bed_idle_timer();
-            return;
-        #endif
-        #if HAS_HEATED_CHAMBER
-          case CHAMBER: return; // Chamber has no idle timer
+          case BED: thermalManager.reset_bed_idle_timer(); return;
         #endif
+        TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return); // Chamber has no idle timer
         default:
           TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
 
   #if ENABLED(JOYSTICK)
@@ -226,42 +218,35 @@ namespace ExtUI {
           // To prevent a disaster, stop jogging.
           flags.jogging = false;
           return;
         }
         norm_jog = destination;
       }
     }
   #endif
 
   bool isHeaterIdle(const extruder_t extruder) {
-    return false
-      #if HAS_HOTEND && HEATER_IDLE_HANDLER
-        || thermalManager.hotend_idle[extruder - E0].timed_out
-      #else
-        ; UNUSED(extruder)
-      #endif
-    ;
+    #if HAS_HOTEND && HEATER_IDLE_HANDLER
+      return thermalManager.hotend_idle[extruder - E0].timed_out
+    #else
+      UNUSED(extruder);
+      return false;
+    #endif
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         TERN_(HAS_HEATED_BED, case BED: return thermalManager.bed_idle.timed_out);
-        #if HAS_HEATED_CHAMBER
-          case CHAMBER: return false; // Chamber has no idle timer
-        #endif
+        TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return false); // Chamber has no idle timer
         default:
-          #if HAS_HOTEND
-            return thermalManager.hotend_idle[heater - H0].timed_out;
-          #else
-            return false;
-          #endif
+          return TERN0(HAS_HOTEND, thermalManager.hotend_idle[heater - H0].timed_out);
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
   #else
@@ -304,36 +289,27 @@ namespace ExtUI {
   float getActualFan_percent(const fan_t fan) {
     #if HAS_FAN
       return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getAxisPosition_mm(const axis_t axis) {
-    return
-      #if ENABLED(JOYSTICK)
-        flags.jogging ? destination[axis] :
-      #endif
-      current_position[axis];
+    return TERN_(JOYSTICK, flags.jogging ? destination[axis] :) current_position[axis];
   }
 
   float getAxisPosition_mm(const extruder_t extruder) {
     const extruder_t old_tool = getActiveTool();
     setActiveTool(extruder, true);
-    const float epos = (
-      #if ENABLED(JOYSTICK)
-        flags.jogging ? destination.e :
-      #endif
-      current_position.e
-    );
+    const float epos = TERN_(JOYSTICK, flags.jogging ? destination.e :) current_position.e;
     setActiveTool(old_tool, true);
     return epos;
   }
 
   void setAxisPosition_mm(const float position, const axis_t axis) {
     // Start with no limits to movement
     float min = current_position[axis] - 1000,
           max = current_position[axis] + 1000;
 
     // Limit to software endstops, if enabled
@@ -1030,25 +1006,21 @@ namespace ExtUI {
 
   bool FileList::isDir() {
     return IFSD(card.flag.filenameIsDir, false);
   }
 
   uint16_t FileList::count() {
     return IFSD((num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)), 0);
   }
 
   bool FileList::isAtRootDir() {
-    return (true
-      #if ENABLED(SDSUPPORT)
-        && card.flag.workDirIsRoot
-      #endif
-    );
+    return IFSD(card.flag.workDirIsRoot, true);
   }
 
   void FileList::upDir() {
     #if ENABLED(SDSUPPORT)
       card.cdup();
       num_files = 0xFFFF;
     #endif
   }
 
   void FileList::changeDir(const char * const dirname) {

commit 01c646a892c9cd36baf577ca9be344e3490a7727
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 22:35:25 2020 -0500

    Apply more HAS_HOTEND

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index ab5aa887e7..a9536c68cd 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -162,21 +162,21 @@ namespace ExtUI {
     else
       safe_delay(ms);
   }
 
   void yield() {
     if (!flags.printer_killed)
       thermalManager.manage_heater();
   }
 
   void enableHeater(const extruder_t extruder) {
-    #if HOTENDS && HEATER_IDLE_HANDLER
+    #if HAS_HOTEND && HEATER_IDLE_HANDLER
       thermalManager.reset_hotend_idle_timer(extruder - E0);
     #else
       UNUSED(extruder);
     #endif
   }
 
   void enableHeater(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
@@ -227,21 +227,21 @@ namespace ExtUI {
           flags.jogging = false;
           return;
         }
         norm_jog = destination;
       }
     }
   #endif
 
   bool isHeaterIdle(const extruder_t extruder) {
     return false
-      #if HOTENDS && HEATER_IDLE_HANDLER
+      #if HAS_HOTEND && HEATER_IDLE_HANDLER
         || thermalManager.hotend_idle[extruder - E0].timed_out
       #else
         ; UNUSED(extruder)
       #endif
     ;
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
@@ -739,27 +739,27 @@ namespace ExtUI {
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
     int16_t mmToWholeSteps(const float mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
       return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
   #endif
 
   float getZOffset_mm() {
-    #if HAS_BED_PROBE
-      return probe.offset.z;
-    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
-      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]);
-    #else
-      return 0.0;
-    #endif
+    return (0.0f
+      #if HAS_BED_PROBE
+        + probe.offset.z
+      #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
+        + planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]
+      #endif
+    );
   }
 
   void setZOffset_mm(const float value) {
     #if HAS_BED_PROBE
       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
         probe.offset.z = value;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
     #else
       UNUSED(value);
@@ -850,83 +850,59 @@ namespace ExtUI {
     char* getFilamentUsed_str(char buffer[21])   {
       printStatistics stats = print_job_timer.getStats();
       sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
       return buffer;
     }
   #endif
 
   float getFeedrate_percent() { return feedrate_percentage; }
 
   #if ENABLED(PIDTEMP)
-    float getPIDValues_Kp(const extruder_t tool) {
-      return PID_PARAM(Kp, tool);
-    }
-
-    float getPIDValues_Ki(const extruder_t tool) {
-      return unscalePID_i(PID_PARAM(Ki, tool));
-    }
-
-    float getPIDValues_Kd(const extruder_t tool) {
-      return unscalePID_d(PID_PARAM(Kd, tool));
-    }
+    float getPIDValues_Kp(const extruder_t tool) { return PID_PARAM(Kp, tool); }
+    float getPIDValues_Ki(const extruder_t tool) { return unscalePID_i(PID_PARAM(Ki, tool)); }
+    float getPIDValues_Kd(const extruder_t tool) { return unscalePID_d(PID_PARAM(Kd, tool)); }
 
     void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
       thermalManager.temp_hotend[tool].pid.Kp = p;
       thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
       thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
-    void startPIDTune(const float temp, extruder_t tool){
+    void startPIDTune(const float temp, extruder_t tool) {
       thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
     }
   #endif
 
   #if ENABLED(PIDTEMPBED)
-    float getBedPIDValues_Kp() {
-      return thermalManager.temp_bed.pid.Kp;
-    }
-
-    float getBedPIDValues_Ki() {
-      return unscalePID_i(thermalManager.temp_bed.pid.Ki);
-    }
-
-    float getBedPIDValues_Kd() {
-      return unscalePID_d(thermalManager.temp_bed.pid.Kd);
-    }
+    float getBedPIDValues_Kp() { return thermalManager.temp_bed.pid.Kp; }
+    float getBedPIDValues_Ki() { return unscalePID_i(thermalManager.temp_bed.pid.Ki); }
+    float getBedPIDValues_Kd() { return unscalePID_d(thermalManager.temp_bed.pid.Kd); }
 
     void setBedPIDValues(const float p, const float i, const float d) {
       thermalManager.temp_bed.pid.Kp = p;
       thermalManager.temp_bed.pid.Ki = scalePID_i(i);
       thermalManager.temp_bed.pid.Kd = scalePID_d(d);
       thermalManager.updatePID();
     }
 
     void startBedPIDTune(const float temp) {
       thermalManager.PID_autotune(temp, H_BED, 4, true);
     }
   #endif
 
-  void injectCommands_P(PGM_P const gcode) {
-    queue.inject_P(gcode);
-  }
+  void injectCommands_P(PGM_P const gcode) { queue.inject_P(gcode); }
 
   bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
 
-  bool isAxisPositionKnown(const axis_t axis) {
-    return TEST(axis_known_position, axis);
-  }
-
-  bool isAxisPositionKnown(const extruder_t) {
-    return TEST(axis_known_position, E_AXIS);
-  }
-
+  bool isAxisPositionKnown(const axis_t axis) { return TEST(axis_known_position, axis); }
+  bool isAxisPositionKnown(const extruder_t) { return TEST(axis_known_position, E_AXIS); }
   bool isPositionKnown() { return all_axes_known(); }
   bool isMachineHomed() { return all_axes_homed(); }
 
   PGM_P getFirmwareName_str() {
     static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
     return firmware_name;
   }
 
   void setTargetTemp_celsius(float value, const heater_t heater) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
@@ -1001,31 +977,23 @@ namespace ExtUI {
   }
 
   bool isPrinting() {
     return (commandsInQueue() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
   }
 
   bool isMediaInserted() {
     return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
   }
 
-  void pausePrint() {
-    ui.pause_print();
-  }
-
-  void resumePrint() {
-    ui.resume_print();
-  }
-
-  void stopPrint() {
-    ui.abort_print();
-  }
+  void pausePrint() { ui.pause_print(); }
+  void resumePrint() { ui.resume_print(); }
+  void stopPrint() { ui.abort_print(); }
 
   void onUserConfirmRequired_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);
     onUserConfirmRequired(msg);
   }
 
   void onStatusChanged_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);

commit 37176ed2b9c3af5fbb2436d72a090b6d880f921e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 07:53:58 2020 -0500

    Apply maxtemp patch

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 9301a2ae3b..ab5aa887e7 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -939,33 +939,33 @@ namespace ExtUI {
       else
     #endif
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET)));
       else
     #endif
       {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
+          thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
         #endif
       }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
-      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
+      thermalManager.setTargetHotend(LROUND(constrain(value, 0, thermalManager.heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);

commit 967c1d853489619e09381dddfecdac44a8fc1805
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 25 18:39:47 2020 -0500

    Do SD sort order in CardReader

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 4d6815d638..9301a2ae3b 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1032,27 +1032,21 @@ namespace ExtUI {
     onStatusChanged(msg);
   }
 
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
-      const uint16_t nr =
-        #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
-          count() - 1 -
-        #endif
-      pos;
-
-      card.getfilename_sorted(nr);
+      card.getfilename_sorted(SD_ORDER(pos, count()));
       return card.filename[0] != '\0';
     #else
       UNUSED(pos);
       UNUSED(skip_range_check);
       return false;
     #endif
   }
 
   const char* FileList::filename() {
     return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");

commit 33217b0dd0e2117905813e3a45632fdc9c66d04f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:48:11 2020 -0500

    Add HOTEND_OVERSHOOT

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index fe2d680994..4d6815d638 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -939,33 +939,33 @@ namespace ExtUI {
       else
     #endif
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET)));
       else
     #endif
       {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
-          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
+          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
         #endif
       }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
-      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
+      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - HOTEND_OVERSHOOT)), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 7a1c0fb251..fe2d680994 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -286,30 +286,30 @@ namespace ExtUI {
       TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber()));
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getActualFan_percent(const fan_t fan) {
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
     #else
       UNUSED(fan);
       return 0;
     #endif
   }
 
   float getAxisPosition_mm(const axis_t axis) {
     return
       #if ENABLED(JOYSTICK)
@@ -933,21 +933,21 @@ namespace ExtUI {
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     enableHeater(heater);
     #if HAS_HEATED_CHAMBER
       if (heater == CHAMBER)
         thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
       else
     #endif
     #if HAS_HEATED_BED
       if (heater == BED)
-        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
+        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAX_TARGET)));
       else
     #endif
       {
         #if HAS_HOTEND
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
         #endif
       }
   }
 
@@ -956,21 +956,21 @@ namespace ExtUI {
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
     #else
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const float value) {
     feedrate_percentage = constrain(value, 10, 500);

commit 3d45a4bd232c83450c269bb3f0fefa6fc67c788d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:35:20 2020 -0500

    Encapsulate Temperature items

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 0e33dc5835..7a1c0fb251 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -938,33 +938,31 @@ namespace ExtUI {
         thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
       else
     #endif
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
       else
     #endif
       {
         #if HAS_HOTEND
-          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
         #endif
       }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
     #if HAS_HOTEND
-      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     #if FAN_COUNT > 0
       if (fan < FAN_COUNT)
         thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));

commit cf8c14b1b0092e87aebe29c79bae0f54850c21d9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 24 01:14:34 2020 -0500

    ExtUI allow small JD mm

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 1ae9edb7e3..0e33dc5835 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -631,21 +631,21 @@ namespace ExtUI {
     }
   #endif
 
   #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
     void setJunctionDeviation_mm(const float value) {
-      planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
+      planner.junction_deviation_mm = constrain(value, 0.001, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
 
     float getAxisMaxJerk_mm_s(const axis_t axis) {
       return planner.max_jerk[axis];
     }
 
     float getAxisMaxJerk_mm_s(const extruder_t) {

commit 55d66fb8971d9e5dbfb15e7ae5c952839b488f59
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 20:49:11 2020 -0500

    Add HAS_JUNCTION_DEVIATION

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index dd5ddd3b66..1ae9edb7e3 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -624,21 +624,21 @@ namespace ExtUI {
     float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
       return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
     }
 
     void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
       if (extruder < EXTRUDERS)
         planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 999);
     }
   #endif
 
-  #if DISABLED(CLASSIC_JERK)
+  #if HAS_JUNCTION_DEVIATION
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
     void setJunctionDeviation_mm(const float value) {
       planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
       TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 

commit 2f6262c27b11598293839f6d46f3b340ee6a1f4c
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Thu Apr 23 04:03:28 2020 +0200

    Automatic Tool Migration feature (#17248)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index b272d9d496..dd5ddd3b66 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -662,24 +662,21 @@ namespace ExtUI {
   #endif
 
   feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
   int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
   feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
   feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
   float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
   float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
   float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
   void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
-  void setFlow_percent(const int16_t flow, const extruder_t extr) {
-    planner.flow_percentage[extr] = flow;
-    planner.refresh_e_factor(extr);
-  }
+  void setFlow_percent(const int16_t flow, const extruder_t extr) { planner.set_flow(extr, flow); }
   void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
   void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
   void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
   void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
   void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
 
   #if ENABLED(BABYSTEPPING)
     bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
       switch (axis) {
         #if ENABLED(BABYSTEP_XY)

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 55ae020616..b272d9d496 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -102,26 +102,22 @@
   #include "../../feature/babystep.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 namespace ExtUI {
   static struct {
     uint8_t printer_killed : 1;
-    #if ENABLED(JOYSTICK)
-      uint8_t jogging : 1;
-    #endif
-    #if ENABLED(SDSUPPORT)
-      uint8_t was_sd_printing : 1;
-    #endif
+    TERN_(JOYSTICK, uint8_t jogging : 1);
+    TERN_(SDSUPPORT, uint8_t was_sd_printing : 1);
   } flags;
 
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
      * within an ISR (such as when the printer is killed).
      *
      * To keep proper time, must be called at least every 1s.
      */
     uint32_t safe_millis() {
@@ -185,23 +181,21 @@ namespace ExtUI {
       switch (heater) {
         #if HAS_HEATED_BED
           case BED:
             thermalManager.reset_bed_idle_timer();
             return;
         #endif
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return; // Chamber has no idle timer
         #endif
         default:
-          #if HAS_HOTEND
-            thermalManager.reset_hotend_idle_timer(heater - H0);
-          #endif
+          TERN_(HAS_HOTEND, thermalManager.reset_hotend_idle_timer(heater - H0));
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
 
   #if ENABLED(JOYSTICK)
     /**
      * Jogs in the direction given by the vector (dx, dy, dz).
@@ -244,23 +238,21 @@ namespace ExtUI {
         || thermalManager.hotend_idle[extruder - E0].timed_out
       #else
         ; UNUSED(extruder)
       #endif
     ;
   }
 
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
-        #if HAS_HEATED_BED
-          case BED: return thermalManager.bed_idle.timed_out;
-        #endif
+        TERN_(HAS_HEATED_BED, case BED: return thermalManager.bed_idle.timed_out);
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return false; // Chamber has no idle timer
         #endif
         default:
           #if HAS_HOTEND
             return thermalManager.hotend_idle[heater - H0].timed_out;
           #else
             return false;
           #endif
       }
@@ -271,42 +263,34 @@ namespace ExtUI {
   }
 
   #ifdef TOUCH_UI_LCD_TEMP_SCALING
     #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
   #else
     #define GET_TEMP_ADJUSTMENT(A) A
   #endif
 
   float getActualTemp_celsius(const heater_t heater) {
     switch (heater) {
-      #if HAS_HEATED_BED
-        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
-      #endif
-      #if HAS_HEATED_CHAMBER
-        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
-      #endif
+      TERN_(HAS_HEATED_BED, case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed()));
+      TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber()));
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
     }
   }
 
   float getActualTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
   }
 
   float getTargetTemp_celsius(const heater_t heater) {
     switch (heater) {
-      #if HAS_HEATED_BED
-        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
-      #endif
-      #if HAS_HEATED_CHAMBER
-        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
-      #endif
+      TERN_(HAS_HEATED_BED, case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed()));
+      TERN_(HAS_HEATED_CHAMBER, case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber()));
       default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
     }
   }
 
   float getTargetTemp_celsius(const extruder_t extruder) {
     return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
   }
 
   float getTargetFan_percent(const fan_t fan) {
     #if FAN_COUNT > 0
@@ -349,42 +333,30 @@ namespace ExtUI {
 
   void setAxisPosition_mm(const float position, const axis_t axis) {
     // Start with no limits to movement
     float min = current_position[axis] - 1000,
           max = current_position[axis] + 1000;
 
     // Limit to software endstops, if enabled
     #if HAS_SOFTWARE_ENDSTOPS
       if (soft_endstops_enabled) switch (axis) {
         case X_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-            min = soft_endstop.min.x;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-            max = soft_endstop.max.x;
-          #endif
+          TERN_(MIN_SOFTWARE_ENDSTOP_X, min = soft_endstop.min.x);
+          TERN_(MAX_SOFTWARE_ENDSTOP_X, max = soft_endstop.max.x);
           break;
         case Y_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-            min = soft_endstop.min.y;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-            max = soft_endstop.max.y;
-          #endif
+          TERN_(MIN_SOFTWARE_ENDSTOP_Y, min = soft_endstop.min.y);
+          TERN_(MAX_SOFTWARE_ENDSTOP_Y, max = soft_endstop.max.y);
           break;
         case Z_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-            min = soft_endstop.min.z;
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-            max = soft_endstop.max.z;
-          #endif
+          TERN_(MIN_SOFTWARE_ENDSTOP_Z, min = soft_endstop.min.z);
+          TERN_(MAX_SOFTWARE_ENDSTOP_Z, max = soft_endstop.max.z);
         default: break;
       }
     #endif // HAS_SOFTWARE_ENDSTOPS
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS) {
         max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
@@ -534,29 +506,23 @@ namespace ExtUI {
         #endif
         #if AXIS_IS_TMC(E7)
           case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
         #endif
         default: break;
       };
     }
 
     int getTMCBumpSensitivity(const axis_t axis) {
       switch (axis) {
-        #if X_SENSORLESS
-          case X: return stepperX.homing_threshold();
-        #endif
-        #if Y_SENSORLESS
-          case Y: return stepperY.homing_threshold();
-        #endif
-        #if Z_SENSORLESS
-          case Z: return stepperZ.homing_threshold();
-        #endif
+        TERN_(X_SENSORLESS, case X: return stepperX.homing_threshold());
+        TERN_(Y_SENSORLESS, case Y: return stepperY.homing_threshold());
+        TERN_(Z_SENSORLESS, case Z: return stepperZ.homing_threshold());
         default: return 0;
       }
     }
 
     void setTMCBumpSensitivity(const float value, const axis_t axis) {
       switch (axis) {
         #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
           #if X_SENSORLESS
             case X: stepperX.homing_threshold(value); break;
           #endif
@@ -666,23 +632,21 @@ namespace ExtUI {
   #endif
 
   #if DISABLED(CLASSIC_JERK)
 
     float getJunctionDeviation_mm() {
       return planner.junction_deviation_mm;
     }
 
     void setJunctionDeviation_mm(const float value) {
       planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
-      #if ENABLED(LIN_ADVANCE)
-        planner.recalculate_max_e_jerk();
-      #endif
+      TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk());
     }
 
   #else
 
     float getAxisMaxJerk_mm_s(const axis_t axis) {
       return planner.max_jerk[axis];
     }
 
     float getAxisMaxJerk_mm_s(const extruder_t) {
       return planner.max_jerk.e;
@@ -864,23 +828,21 @@ namespace ExtUI {
   #if HAS_LEVELING
     bool getLevelingActive() { return planner.leveling_active; }
     void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
     bool getMeshValid() { return leveling_is_valid(); }
     #if HAS_MESH
       bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
       float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
       void setMeshPoint(const xy_uint8_t &pos, const float zoff) {
         if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
           Z_VALUES(pos.x, pos.y) = zoff;
-          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-            bed_level_virt_interpolate();
-          #endif
+          TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
         }
       }
     #endif
   #endif
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
     void setHostResponse(const uint8_t response) { host_response_handler(response); }
   #endif
 
   #if ENABLED(PRINTCOUNTER)
@@ -1013,23 +975,21 @@ namespace ExtUI {
       UNUSED(value);
       UNUSED(fan);
     #endif
   }
 
   void setFeedrate_percent(const float value) {
     feedrate_percentage = constrain(value, 10, 500);
   }
 
   void setUserConfirmed() {
-    #if HAS_RESUME_CONTINUE
-      wait_for_user = false;
-    #endif
+    TERN_(HAS_RESUME_CONTINUE, wait_for_user = false);
   }
 
   void printFile(const char *filename) {
     UNUSED(filename);
     IFSD(card.openAndPrintFile(filename), NOOP);
   }
 
   bool isPrintingFromMediaPaused() {
     return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
   }

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index b5f94539fe..55ae020616 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -185,21 +185,21 @@ namespace ExtUI {
       switch (heater) {
         #if HAS_HEATED_BED
           case BED:
             thermalManager.reset_bed_idle_timer();
             return;
         #endif
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return; // Chamber has no idle timer
         #endif
         default:
-          #if HOTENDS
+          #if HAS_HOTEND
             thermalManager.reset_hotend_idle_timer(heater - H0);
           #endif
           break;
       }
     #else
       UNUSED(heater);
     #endif
   }
 
   #if ENABLED(JOYSTICK)
@@ -251,21 +251,21 @@ namespace ExtUI {
   bool isHeaterIdle(const heater_t heater) {
     #if HEATER_IDLE_HANDLER
       switch (heater) {
         #if HAS_HEATED_BED
           case BED: return thermalManager.bed_idle.timed_out;
         #endif
         #if HAS_HEATED_CHAMBER
           case CHAMBER: return false; // Chamber has no idle timer
         #endif
         default:
-          #if HOTENDS
+          #if HAS_HOTEND
             return thermalManager.hotend_idle[heater - H0].timed_out;
           #else
             return false;
           #endif
       }
     #else
       UNUSED(heater);
       return false;
     #endif
   }
@@ -978,33 +978,33 @@ namespace ExtUI {
       if (heater == CHAMBER)
         thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
       else
     #endif
     #if HAS_HEATED_BED
       if (heater == BED)
         thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
       else
     #endif
       {
-        #if HOTENDS
+        #if HAS_HOTEND
           static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
           const int16_t e = heater - H0;
           thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
         #endif
       }
   }
 
   void setTargetTemp_celsius(float value, const extruder_t extruder) {
     #ifdef TOUCH_UI_LCD_TEMP_SCALING
       value *= TOUCH_UI_LCD_TEMP_SCALING;
     #endif
-    #if HOTENDS
+    #if HAS_HOTEND
       constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
       const int16_t e = extruder - E0;
       enableHeater(extruder);
       thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
     #endif
   }
 
   void setTargetFan_percent(const float value, const fan_t fan) {
     #if FAN_COUNT > 0
       if (fan < FAN_COUNT)

commit 4a5a3d27ed29d7bab3de9b64b1a1728fd65c755f
Author: grauerfuchs <42082416+grauerfuchs@users.noreply.github.com>
Date:   Sat Apr 18 23:56:23 2020 -0400

    Option to use raw digipot values (#17536)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index ddb9cfc3bb..b5f94539fe 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -773,21 +773,21 @@ namespace ExtUI {
         UNUSED(mm);
       #endif
     }
 
     /**
      * Converts a mm displacement to a number of whole number of
      * steps that is at least mm long.
      */
     int16_t mmToWholeSteps(const float mm, const axis_t axis) {
       const float steps = mm / planner.steps_to_mm[axis];
-      return steps > 0 ? ceil(steps) : floor(steps);
+      return steps > 0 ? CEIL(steps) : FLOOR(steps);
     }
   #endif
 
   float getZOffset_mm() {
     #if HAS_BED_PROBE
       return probe.offset.z;
     #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
       return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]);
     #else
       return 0.0;

commit 2824e67d95a115ae8bde00608c5768cfd4cccd5f
Author: Desuuuu <contact@desuuuu.com>
Date:   Thu Apr 16 07:33:31 2020 +0200

    Add ExtUI::onStatusChanged_P (#17543)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index d57adadfef..ddb9cfc3bb 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1064,20 +1064,26 @@ namespace ExtUI {
   void stopPrint() {
     ui.abort_print();
   }
 
   void onUserConfirmRequired_P(PGM_P const pstr) {
     char msg[strlen_P(pstr) + 1];
     strcpy_P(msg, pstr);
     onUserConfirmRequired(msg);
   }
 
+  void onStatusChanged_P(PGM_P const pstr) {
+    char msg[strlen_P(pstr) + 1];
+    strcpy_P(msg, pstr);
+    onStatusChanged(msg);
+  }
+
   FileList::FileList() { refresh(); }
 
   void FileList::refresh() { num_files = 0xFFFF; }
 
   bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
     #if ENABLED(SDSUPPORT)
       if (!skip_range_check && (pos + 1) > count()) return false;
       const uint16_t nr =
         #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
           count() - 1 -

commit 65f6a373b0a77da23f0758d5d1520e404436cec0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 4 00:08:25 2020 -0500

    Refactor SD detect handler (#17380)
    
    Co-Authored-By: Eric Ptak <trouch@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index a5b1460c90..d57adadfef 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -1142,42 +1142,21 @@ namespace ExtUI {
 // At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
 
 void MarlinUI::init() {
   #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
     SET_INPUT_PULLUP(SD_DETECT_PIN);
   #endif
 
   ExtUI::onStartup();
 }
 
-void MarlinUI::update() {
-  #if ENABLED(SDSUPPORT)
-    static bool last_sd_status;
-    const bool sd_status = IS_SD_INSERTED();
-    if (sd_status != last_sd_status) {
-      last_sd_status = sd_status;
-      if (sd_status) {
-        card.mount();
-        if (card.isMounted())
-          ExtUI::onMediaInserted();
-        else
-          ExtUI::onMediaError();
-      }
-      else {
-        const bool ok = card.isMounted();
-        card.release();
-        if (ok) ExtUI::onMediaRemoved();
-      }
-    }
-  #endif // SDSUPPORT
-  ExtUI::onIdle();
-}
+void MarlinUI::update() { ExtUI::onIdle(); }
 
 void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
   using namespace ExtUI;
   if (!flags.printer_killed) {
     flags.printer_killed = true;
     onPrinterKilled(error, component);
   }
 }
 
 #endif // EXTENSIBLE_UI

commit be0e313c078c7425de7bc45a0371756ee2571056
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 2 13:24:55 2020 -0600

    Touch UI additions, bug fixes (#17379)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
index 79e12f36d1..a5b1460c90 100644
--- a/Marlin/src/lcd/extui/ui_api.cpp
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -105,20 +105,23 @@
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../../feature/host_actions.h"
 #endif
 
 namespace ExtUI {
   static struct {
     uint8_t printer_killed : 1;
     #if ENABLED(JOYSTICK)
       uint8_t jogging : 1;
     #endif
+    #if ENABLED(SDSUPPORT)
+      uint8_t was_sd_printing : 1;
+    #endif
   } flags;
 
   #ifdef __SAM3X8E__
     /**
      * Implement a special millis() to allow time measurement
      * within an ISR (such as when the printer is killed).
      *
      * To keep proper time, must be called at least every 1s.
      */
     uint32_t safe_millis() {
@@ -1025,25 +1028,32 @@ namespace ExtUI {
   void printFile(const char *filename) {
     UNUSED(filename);
     IFSD(card.openAndPrintFile(filename), NOOP);
   }
 
   bool isPrintingFromMediaPaused() {
     return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
   }
 
   bool isPrintingFromMedia() {
-    return IFSD(card.isFileOpen(), false);
+    #if ENABLED(SDSUPPORT)
+      // Account for when IS_SD_PRINTING() reports the end of the
+      // print when there is still SD card data in the planner.
+      flags.was_sd_printing = card.isFileOpen() || (flags.was_sd_printing && commandsInQueue());
+      return flags.was_sd_printing;
+    #else
+      return false;
+    #endif
   }
 
   bool isPrinting() {
-    return (planner.movesplanned() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
+    return (commandsInQueue() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
   }
 
   bool isMediaInserted() {
     return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
   }
 
   void pausePrint() {
     ui.pause_print();
   }
 

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/lcd/extui/ui_api.cpp b/Marlin/src/lcd/extui/ui_api.cpp
new file mode 100644
index 0000000000..79e12f36d1
--- /dev/null
+++ b/Marlin/src/lcd/extui/ui_api.cpp
@@ -0,0 +1,1173 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**************
+ * ui_api.cpp *
+ **************/
+
+/****************************************************************************
+ *   Written By Marcio Teixeira 2018 - Aleph Objects, Inc.                  *
+ *                                                                          *
+ *   This program is free software: you can redistribute it and/or modify   *
+ *   it under the terms of the GNU General Public License as published by   *
+ *   the Free Software Foundation, either version 3 of the License, or      *
+ *   (at your option) any later version.                                    *
+ *                                                                          *
+ *   This program is distributed in the hope that it will be useful,        *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
+ *   GNU General Public License for more details.                           *
+ *                                                                          *
+ *   To view a copy of the GNU General Public License, go to the following  *
+ *   location: <http://www.gnu.org/licenses/>.                              *
+ ****************************************************************************/
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(EXTENSIBLE_UI)
+
+#include "../ultralcd.h"
+#include "../../gcode/queue.h"
+#include "../../module/motion.h"
+#include "../../module/planner.h"
+#include "../../module/probe.h"
+#include "../../module/temperature.h"
+#include "../../module/printcounter.h"
+#include "../../libs/duration_t.h"
+#include "../../HAL/shared/Delay.h"
+
+#if ENABLED(PRINTCOUNTER)
+  #include "../../core/utility.h"
+  #include "../../libs/numtostr.h"
+#endif
+
+#if EXTRUDERS > 1
+  #include "../../module/tool_change.h"
+#endif
+
+#if ENABLED(EMERGENCY_PARSER)
+  #include "../../feature/e_parser.h"
+#endif
+
+#if ENABLED(SDSUPPORT)
+  #include "../../sd/cardreader.h"
+  #define IFSD(A,B) (A)
+#else
+  #define IFSD(A,B) (B)
+#endif
+
+#if HAS_TRINAMIC_CONFIG
+  #include "../../feature/tmc_util.h"
+  #include "../../module/stepper/indirection.h"
+#endif
+
+#include "ui_api.h"
+
+#if ENABLED(BACKLASH_GCODE)
+  #include "../../feature/backlash.h"
+#endif
+
+#if HAS_LEVELING
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  #include "../../feature/runout.h"
+#endif
+
+#if ENABLED(CASE_LIGHT_ENABLE)
+  #include "../../feature/caselight.h"
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  #include "../../feature/babystep.h"
+#endif
+
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../../feature/host_actions.h"
+#endif
+
+namespace ExtUI {
+  static struct {
+    uint8_t printer_killed : 1;
+    #if ENABLED(JOYSTICK)
+      uint8_t jogging : 1;
+    #endif
+  } flags;
+
+  #ifdef __SAM3X8E__
+    /**
+     * Implement a special millis() to allow time measurement
+     * within an ISR (such as when the printer is killed).
+     *
+     * To keep proper time, must be called at least every 1s.
+     */
+    uint32_t safe_millis() {
+      // Not killed? Just call millis()
+      if (!flags.printer_killed) return millis();
+
+      static uint32_t currTimeHI = 0; /* Current time */
+
+      // Machine was killed, reinit SysTick so we are able to compute time without ISRs
+      if (currTimeHI == 0) {
+        // Get the last time the Arduino time computed (from CMSIS) and convert it to SysTick
+        currTimeHI = (uint32_t)((GetTickCount() * (uint64_t)(F_CPU / 8000)) >> 24);
+
+        // Reinit the SysTick timer to maximize its period
+        SysTick->LOAD  = SysTick_LOAD_RELOAD_Msk;                    // get the full range for the systick timer
+        SysTick->VAL   = 0;                                          // Load the SysTick Counter Value
+        SysTick->CTRL  = // MCLK/8 as source
+                         // No interrupts
+                         SysTick_CTRL_ENABLE_Msk;                    // Enable SysTick Timer
+     }
+
+      // Check if there was a timer overflow from the last read
+      if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
+        // There was. This means (SysTick_LOAD_RELOAD_Msk * 1000 * 8)/F_CPU ms has elapsed
+        currTimeHI++;
+      }
+
+      // Calculate current time in milliseconds
+      uint32_t currTimeLO = SysTick_LOAD_RELOAD_Msk - SysTick->VAL; // (in MCLK/8)
+      uint64_t currTime = ((uint64_t)currTimeLO) | (((uint64_t)currTimeHI) << 24);
+
+      // The ms count is
+      return (uint32_t)(currTime / (F_CPU / 8000));
+    }
+  #endif // __SAM3X8E__
+
+  void delay_us(unsigned long us) { DELAY_US(us); }
+
+  void delay_ms(unsigned long ms) {
+    if (flags.printer_killed)
+      DELAY_US(ms * 1000);
+    else
+      safe_delay(ms);
+  }
+
+  void yield() {
+    if (!flags.printer_killed)
+      thermalManager.manage_heater();
+  }
+
+  void enableHeater(const extruder_t extruder) {
+    #if HOTENDS && HEATER_IDLE_HANDLER
+      thermalManager.reset_hotend_idle_timer(extruder - E0);
+    #else
+      UNUSED(extruder);
+    #endif
+  }
+
+  void enableHeater(const heater_t heater) {
+    #if HEATER_IDLE_HANDLER
+      switch (heater) {
+        #if HAS_HEATED_BED
+          case BED:
+            thermalManager.reset_bed_idle_timer();
+            return;
+        #endif
+        #if HAS_HEATED_CHAMBER
+          case CHAMBER: return; // Chamber has no idle timer
+        #endif
+        default:
+          #if HOTENDS
+            thermalManager.reset_hotend_idle_timer(heater - H0);
+          #endif
+          break;
+      }
+    #else
+      UNUSED(heater);
+    #endif
+  }
+
+  #if ENABLED(JOYSTICK)
+    /**
+     * Jogs in the direction given by the vector (dx, dy, dz).
+     * The values range from -1 to 1 mapping to the maximum
+     * feedrate for an axis.
+     *
+     * The axis will continue to jog until this function is
+     * called with all zeros.
+     */
+    void jog(const xyz_float_t &dir) {
+      // The "destination" variable is used as a scratchpad in
+      // Marlin by GCODE routines, but should remain untouched
+      // during manual jogging, allowing us to reuse the space
+      // for our direction vector.
+      destination = dir;
+      flags.jogging = !NEAR_ZERO(dir.x) || !NEAR_ZERO(dir.y) || !NEAR_ZERO(dir.z);
+    }
+
+    // Called by the polling routine in "joystick.cpp"
+    void _joystick_update(xyz_float_t &norm_jog) {
+      if (flags.jogging) {
+        #define OUT_OF_RANGE(VALUE) (VALUE < -1.0f || VALUE > 1.0f)
+
+        if (OUT_OF_RANGE(destination.x) || OUT_OF_RANGE(destination.y) || OUT_OF_RANGE(destination.z)) {
+          // If destination on any axis is out of range, it
+          // probably means the UI forgot to stop jogging and
+          // ran GCODE that wrote a position to destination.
+          // To prevent a disaster, stop jogging.
+          flags.jogging = false;
+          return;
+        }
+        norm_jog = destination;
+      }
+    }
+  #endif
+
+  bool isHeaterIdle(const extruder_t extruder) {
+    return false
+      #if HOTENDS && HEATER_IDLE_HANDLER
+        || thermalManager.hotend_idle[extruder - E0].timed_out
+      #else
+        ; UNUSED(extruder)
+      #endif
+    ;
+  }
+
+  bool isHeaterIdle(const heater_t heater) {
+    #if HEATER_IDLE_HANDLER
+      switch (heater) {
+        #if HAS_HEATED_BED
+          case BED: return thermalManager.bed_idle.timed_out;
+        #endif
+        #if HAS_HEATED_CHAMBER
+          case CHAMBER: return false; // Chamber has no idle timer
+        #endif
+        default:
+          #if HOTENDS
+            return thermalManager.hotend_idle[heater - H0].timed_out;
+          #else
+            return false;
+          #endif
+      }
+    #else
+      UNUSED(heater);
+      return false;
+    #endif
+  }
+
+  #ifdef TOUCH_UI_LCD_TEMP_SCALING
+    #define GET_TEMP_ADJUSTMENT(A) float(A)/TOUCH_UI_LCD_TEMP_SCALING
+  #else
+    #define GET_TEMP_ADJUSTMENT(A) A
+  #endif
+
+  float getActualTemp_celsius(const heater_t heater) {
+    switch (heater) {
+      #if HAS_HEATED_BED
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degBed());
+      #endif
+      #if HAS_HEATED_CHAMBER
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degChamber());
+      #endif
+      default: return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(heater - H0));
+    }
+  }
+
+  float getActualTemp_celsius(const extruder_t extruder) {
+    return GET_TEMP_ADJUSTMENT(thermalManager.degHotend(extruder - E0));
+  }
+
+  float getTargetTemp_celsius(const heater_t heater) {
+    switch (heater) {
+      #if HAS_HEATED_BED
+        case BED: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetBed());
+      #endif
+      #if HAS_HEATED_CHAMBER
+        case CHAMBER: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetChamber());
+      #endif
+      default: return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(heater - H0));
+    }
+  }
+
+  float getTargetTemp_celsius(const extruder_t extruder) {
+    return GET_TEMP_ADJUSTMENT(thermalManager.degTargetHotend(extruder - E0));
+  }
+
+  float getTargetFan_percent(const fan_t fan) {
+    #if FAN_COUNT > 0
+      return thermalManager.fanPercent(thermalManager.fan_speed[fan - FAN0]);
+    #else
+      UNUSED(fan);
+      return 0;
+    #endif
+  }
+
+  float getActualFan_percent(const fan_t fan) {
+    #if FAN_COUNT > 0
+      return thermalManager.fanPercent(thermalManager.scaledFanSpeed(fan - FAN0));
+    #else
+      UNUSED(fan);
+      return 0;
+    #endif
+  }
+
+  float getAxisPosition_mm(const axis_t axis) {
+    return
+      #if ENABLED(JOYSTICK)
+        flags.jogging ? destination[axis] :
+      #endif
+      current_position[axis];
+  }
+
+  float getAxisPosition_mm(const extruder_t extruder) {
+    const extruder_t old_tool = getActiveTool();
+    setActiveTool(extruder, true);
+    const float epos = (
+      #if ENABLED(JOYSTICK)
+        flags.jogging ? destination.e :
+      #endif
+      current_position.e
+    );
+    setActiveTool(old_tool, true);
+    return epos;
+  }
+
+  void setAxisPosition_mm(const float position, const axis_t axis) {
+    // Start with no limits to movement
+    float min = current_position[axis] - 1000,
+          max = current_position[axis] + 1000;
+
+    // Limit to software endstops, if enabled
+    #if HAS_SOFTWARE_ENDSTOPS
+      if (soft_endstops_enabled) switch (axis) {
+        case X_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+            min = soft_endstop.min.x;
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+            max = soft_endstop.max.x;
+          #endif
+          break;
+        case Y_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+            min = soft_endstop.min.y;
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+            max = soft_endstop.max.y;
+          #endif
+          break;
+        case Z_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+            min = soft_endstop.min.z;
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+            max = soft_endstop.max.z;
+          #endif
+        default: break;
+      }
+    #endif // HAS_SOFTWARE_ENDSTOPS
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS) {
+        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
+    #endif
+
+    current_position[axis] = constrain(position, min, max);
+    line_to_current_position(manual_feedrate_mm_s[axis]);
+  }
+
+  void setAxisPosition_mm(const float position, const extruder_t extruder) {
+    setActiveTool(extruder, true);
+
+    current_position.e = position;
+    line_to_current_position(manual_feedrate_mm_s.e);
+  }
+
+  void setActiveTool(const extruder_t extruder, bool no_move) {
+    #if EXTRUDERS > 1
+      const uint8_t e = extruder - E0;
+      if (e != active_extruder) tool_change(e, no_move);
+      active_extruder = e;
+    #else
+      UNUSED(extruder);
+      UNUSED(no_move);
+    #endif
+  }
+
+  extruder_t getActiveTool() {
+    switch (active_extruder) {
+      case 5:  return E5;
+      case 4:  return E4;
+      case 3:  return E3;
+      case 2:  return E2;
+      case 1:  return E1;
+      default: return E0;
+    }
+  }
+
+  bool isMoving() { return planner.has_blocks_queued(); }
+
+  bool canMove(const axis_t axis) {
+    switch (axis) {
+      #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
+        case X: return TEST(axis_homed, X_AXIS);
+        case Y: return TEST(axis_homed, Y_AXIS);
+        case Z: return TEST(axis_homed, Z_AXIS);
+      #else
+        case X: case Y: case Z: return true;
+      #endif
+      default: return false;
+    }
+  }
+
+  bool canMove(const extruder_t extruder) {
+    return !thermalManager.tooColdToExtrude(extruder - E0);
+  }
+
+  #if HAS_SOFTWARE_ENDSTOPS
+    bool getSoftEndstopState() { return soft_endstops_enabled; }
+    void setSoftEndstopState(const bool value) { soft_endstops_enabled = value; }
+  #endif
+
+  #if HAS_TRINAMIC_CONFIG
+    float getAxisCurrent_mA(const axis_t axis) {
+      switch (axis) {
+        #if AXIS_IS_TMC(X)
+          case X: return stepperX.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y)
+          case Y: return stepperY.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z)
+          case Z: return stepperZ.getMilliamps();
+        #endif
+        default: return NAN;
+      };
+    }
+
+    float getAxisCurrent_mA(const extruder_t extruder) {
+      switch (extruder) {
+        #if AXIS_IS_TMC(E0)
+          case E0: return stepperE0.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E1)
+          case E1: return stepperE1.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E2)
+          case E2: return stepperE2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E3)
+          case E3: return stepperE3.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E4)
+          case E4: return stepperE4.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E5)
+          case E5: return stepperE5.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E6)
+          case E6: return stepperE6.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E7)
+          case E7: return stepperE7.getMilliamps();
+        #endif
+        default: return NAN;
+      };
+    }
+
+    void  setAxisCurrent_mA(const float mA, const axis_t axis) {
+      switch (axis) {
+        #if AXIS_IS_TMC(X)
+          case X: stepperX.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Y)
+          case Y: stepperY.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(Z)
+          case Z: stepperZ.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        default: break;
+      };
+    }
+
+    void  setAxisCurrent_mA(const float mA, const extruder_t extruder) {
+      switch (extruder) {
+        #if AXIS_IS_TMC(E0)
+          case E0: stepperE0.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E1)
+          case E1: stepperE1.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E2)
+          case E2: stepperE2.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E3)
+          case E3: stepperE3.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E4)
+          case E4: stepperE4.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E5)
+          case E5: stepperE5.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E6)
+          case E6: stepperE6.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        #if AXIS_IS_TMC(E7)
+          case E7: stepperE7.rms_current(constrain(mA, 500, 1500)); break;
+        #endif
+        default: break;
+      };
+    }
+
+    int getTMCBumpSensitivity(const axis_t axis) {
+      switch (axis) {
+        #if X_SENSORLESS
+          case X: return stepperX.homing_threshold();
+        #endif
+        #if Y_SENSORLESS
+          case Y: return stepperY.homing_threshold();
+        #endif
+        #if Z_SENSORLESS
+          case Z: return stepperZ.homing_threshold();
+        #endif
+        default: return 0;
+      }
+    }
+
+    void setTMCBumpSensitivity(const float value, const axis_t axis) {
+      switch (axis) {
+        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
+          #if X_SENSORLESS
+            case X: stepperX.homing_threshold(value); break;
+          #endif
+          #if Y_SENSORLESS
+            case Y: stepperY.homing_threshold(value); break;
+          #endif
+          #if Z_SENSORLESS
+            case Z: stepperZ.homing_threshold(value); break;
+          #endif
+        #else
+          UNUSED(value);
+        #endif
+        default: break;
+      }
+    }
+  #endif
+
+  float getAxisSteps_per_mm(const axis_t axis) {
+    return planner.settings.axis_steps_per_mm[axis];
+  }
+
+  float getAxisSteps_per_mm(const extruder_t extruder) {
+    UNUSED_E(extruder);
+    return planner.settings.axis_steps_per_mm[E_AXIS_N(extruder - E0)];
+  }
+
+  void setAxisSteps_per_mm(const float value, const axis_t axis) {
+    planner.settings.axis_steps_per_mm[axis] = value;
+  }
+
+  void setAxisSteps_per_mm(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
+    planner.settings.axis_steps_per_mm[E_AXIS_N(axis - E0)] = value;
+  }
+
+  feedRate_t getAxisMaxFeedrate_mm_s(const axis_t axis) {
+    return planner.settings.max_feedrate_mm_s[axis];
+  }
+
+  feedRate_t getAxisMaxFeedrate_mm_s(const extruder_t extruder) {
+    UNUSED_E(extruder);
+    return planner.settings.max_feedrate_mm_s[E_AXIS_N(axis - E0)];
+  }
+
+  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const axis_t axis) {
+    planner.set_max_feedrate(axis, value);
+  }
+
+  void setAxisMaxFeedrate_mm_s(const feedRate_t value, const extruder_t extruder) {
+    UNUSED_E(extruder);
+    planner.set_max_feedrate(E_AXIS_N(extruder - E0), value);
+  }
+
+  float getAxisMaxAcceleration_mm_s2(const axis_t axis) {
+    return planner.settings.max_acceleration_mm_per_s2[axis];
+  }
+
+  float getAxisMaxAcceleration_mm_s2(const extruder_t extruder) {
+    UNUSED_E(extruder);
+    return planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(extruder - E0)];
+  }
+
+  void setAxisMaxAcceleration_mm_s2(const float value, const axis_t axis) {
+    planner.set_max_acceleration(axis, value);
+  }
+
+  void setAxisMaxAcceleration_mm_s2(const float value, const extruder_t extruder) {
+    UNUSED_E(extruder);
+    planner.set_max_acceleration(E_AXIS_N(extruder - E0), value);
+  }
+
+  #if HAS_FILAMENT_SENSOR
+    bool getFilamentRunoutEnabled()                 { return runout.enabled; }
+    void setFilamentRunoutEnabled(const bool value) { runout.enabled = value; }
+
+    #ifdef FILAMENT_RUNOUT_DISTANCE_MM
+      float getFilamentRunoutDistance_mm()                 { return runout.runout_distance(); }
+      void setFilamentRunoutDistance_mm(const float value) { runout.set_runout_distance(constrain(value, 0, 999)); }
+    #endif
+  #endif
+
+  #if HAS_CASE_LIGHT
+    bool getCaseLightState()                 { return case_light_on; }
+    void setCaseLightState(const bool value) {
+      case_light_on = value;
+      update_case_light();
+    }
+
+    #if DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+      float getCaseLightBrightness_percent()                 { return ui8_to_percent(case_light_brightness); }
+      void setCaseLightBrightness_percent(const float value) {
+         case_light_brightness = map(constrain(value, 0, 100), 0, 100, 0, 255);
+         update_case_light();
+      }
+    #endif
+  #endif
+
+  #if ENABLED(LIN_ADVANCE)
+    float getLinearAdvance_mm_mm_s(const extruder_t extruder) {
+      return (extruder < EXTRUDERS) ? planner.extruder_advance_K[extruder - E0] : 0;
+    }
+
+    void setLinearAdvance_mm_mm_s(const float value, const extruder_t extruder) {
+      if (extruder < EXTRUDERS)
+        planner.extruder_advance_K[extruder - E0] = constrain(value, 0, 999);
+    }
+  #endif
+
+  #if DISABLED(CLASSIC_JERK)
+
+    float getJunctionDeviation_mm() {
+      return planner.junction_deviation_mm;
+    }
+
+    void setJunctionDeviation_mm(const float value) {
+      planner.junction_deviation_mm = constrain(value, 0.01, 0.3);
+      #if ENABLED(LIN_ADVANCE)
+        planner.recalculate_max_e_jerk();
+      #endif
+    }
+
+  #else
+
+    float getAxisMaxJerk_mm_s(const axis_t axis) {
+      return planner.max_jerk[axis];
+    }
+
+    float getAxisMaxJerk_mm_s(const extruder_t) {
+      return planner.max_jerk.e;
+    }
+
+    void setAxisMaxJerk_mm_s(const float value, const axis_t axis) {
+      planner.set_max_jerk((AxisEnum)axis, value);
+    }
+
+    void setAxisMaxJerk_mm_s(const float value, const extruder_t) {
+      planner.set_max_jerk(E_AXIS, value);
+    }
+  #endif
+
+  feedRate_t getFeedrate_mm_s()                       { return feedrate_mm_s; }
+  int16_t getFlowPercentage(const extruder_t extr)    { return planner.flow_percentage[extr]; }
+  feedRate_t getMinFeedrate_mm_s()                    { return planner.settings.min_feedrate_mm_s; }
+  feedRate_t getMinTravelFeedrate_mm_s()              { return planner.settings.min_travel_feedrate_mm_s; }
+  float getPrintingAcceleration_mm_s2()               { return planner.settings.acceleration; }
+  float getRetractAcceleration_mm_s2()                { return planner.settings.retract_acceleration; }
+  float getTravelAcceleration_mm_s2()                 { return planner.settings.travel_acceleration; }
+  void setFeedrate_mm_s(const feedRate_t fr)          { feedrate_mm_s = fr; }
+  void setFlow_percent(const int16_t flow, const extruder_t extr) {
+    planner.flow_percentage[extr] = flow;
+    planner.refresh_e_factor(extr);
+  }
+  void setMinFeedrate_mm_s(const feedRate_t fr)       { planner.settings.min_feedrate_mm_s = fr; }
+  void setMinTravelFeedrate_mm_s(const feedRate_t fr) { planner.settings.min_travel_feedrate_mm_s = fr; }
+  void setPrintingAcceleration_mm_s2(const float acc) { planner.settings.acceleration = acc; }
+  void setRetractAcceleration_mm_s2(const float acc)  { planner.settings.retract_acceleration = acc; }
+  void setTravelAcceleration_mm_s2(const float acc)   { planner.settings.travel_acceleration = acc; }
+
+  #if ENABLED(BABYSTEPPING)
+    bool babystepAxis_steps(const int16_t steps, const axis_t axis) {
+      switch (axis) {
+        #if ENABLED(BABYSTEP_XY)
+          case X: babystep.add_steps(X_AXIS, steps); break;
+          case Y: babystep.add_steps(Y_AXIS, steps); break;
+        #endif
+        case Z: babystep.add_steps(Z_AXIS, steps); break;
+        default: return false;
+      };
+      return true;
+    }
+
+    /**
+     * This function adjusts an axis during a print.
+     *
+     * When linked_nozzles is false, each nozzle in a multi-nozzle
+     * printer can be babystepped independently of the others. This
+     * lets the user to fine tune the Z-offset and Nozzle Offsets
+     * while observing the first layer of a print, regardless of
+     * what nozzle is printing.
+     */
+    void smartAdjustAxis_steps(const int16_t steps, const axis_t axis, bool linked_nozzles) {
+      const float mm = steps * planner.steps_to_mm[axis];
+
+      if (!babystepAxis_steps(steps, axis)) return;
+
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        // Make it so babystepping in Z adjusts the Z probe offset.
+        if (axis == Z
+          #if EXTRUDERS > 1
+            && (linked_nozzles || active_extruder == 0)
+          #endif
+        ) probe.offset.z += mm;
+      #else
+        UNUSED(mm);
+      #endif
+
+      #if EXTRUDERS > 1 && HAS_HOTEND_OFFSET
+        /**
+         * When linked_nozzles is false, as an axis is babystepped
+         * adjust the hotend offsets so that the other nozzles are
+         * unaffected by the babystepping of the active nozzle.
+         */
+        if (!linked_nozzles) {
+          HOTEND_LOOP()
+            if (e != active_extruder)
+              hotend_offset[e][axis] += mm;
+
+          normalizeNozzleOffset(X);
+          normalizeNozzleOffset(Y);
+          normalizeNozzleOffset(Z);
+        }
+      #else
+        UNUSED(linked_nozzles);
+        UNUSED(mm);
+      #endif
+    }
+
+    /**
+     * Converts a mm displacement to a number of whole number of
+     * steps that is at least mm long.
+     */
+    int16_t mmToWholeSteps(const float mm, const axis_t axis) {
+      const float steps = mm / planner.steps_to_mm[axis];
+      return steps > 0 ? ceil(steps) : floor(steps);
+    }
+  #endif
+
+  float getZOffset_mm() {
+    #if HAS_BED_PROBE
+      return probe.offset.z;
+    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
+      return (planner.steps_to_mm[Z_AXIS] * babystep.axis_total[BS_AXIS_IND(Z_AXIS)]);
+    #else
+      return 0.0;
+    #endif
+  }
+
+  void setZOffset_mm(const float value) {
+    #if HAS_BED_PROBE
+      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX))
+        probe.offset.z = value;
+    #elif ENABLED(BABYSTEP_DISPLAY_TOTAL)
+      babystep.add_mm(Z_AXIS, (value - getZOffset_mm()));
+    #else
+      UNUSED(value);
+    #endif
+  }
+
+  #if HAS_HOTEND_OFFSET
+
+    float getNozzleOffset_mm(const axis_t axis, const extruder_t extruder) {
+      if (extruder - E0 >= HOTENDS) return 0;
+      return hotend_offset[extruder - E0][axis];
+    }
+
+    void setNozzleOffset_mm(const float value, const axis_t axis, const extruder_t extruder) {
+      if (extruder - E0 >= HOTENDS) return;
+      hotend_offset[extruder - E0][axis] = value;
+    }
+
+    /**
+     * The UI should call this if needs to guarantee the first
+     * nozzle offset is zero (such as when it doesn't allow the
+     * user to edit the offset the first nozzle).
+     */
+    void normalizeNozzleOffset(const axis_t axis) {
+      const float offs = hotend_offset[0][axis];
+      HOTEND_LOOP() hotend_offset[e][axis] -= offs;
+    }
+
+  #endif // HAS_HOTEND_OFFSET
+
+  #if HAS_BED_PROBE
+    float getProbeOffset_mm(const axis_t axis) {
+      return probe.offset.pos[axis];
+    }
+    void setProbeOffset_mm(const float val, const axis_t axis) {
+      probe.offset.pos[axis] = val;
+    }
+  #endif
+
+  #if ENABLED(BACKLASH_GCODE)
+    float getAxisBacklash_mm(const axis_t axis)       { return backlash.distance_mm[axis]; }
+    void setAxisBacklash_mm(const float value, const axis_t axis)
+                                                      { backlash.distance_mm[axis] = constrain(value,0,5); }
+
+    float getBacklashCorrection_percent()             { return ui8_to_percent(backlash.correction); }
+    void setBacklashCorrection_percent(const float value) { backlash.correction = map(constrain(value, 0, 100), 0, 100, 0, 255); }
+
+    #ifdef BACKLASH_SMOOTHING_MM
+      float getBacklashSmoothing_mm()                 { return backlash.smoothing_mm; }
+      void setBacklashSmoothing_mm(const float value) { backlash.smoothing_mm = constrain(value, 0, 999); }
+    #endif
+  #endif
+
+  uint8_t getProgress_percent() {
+    return ui.get_progress_percent();
+  }
+
+  uint32_t getProgress_seconds_elapsed() {
+    const duration_t elapsed = print_job_timer.duration();
+    return elapsed.value;
+  }
+
+  #if HAS_LEVELING
+    bool getLevelingActive() { return planner.leveling_active; }
+    void setLevelingActive(const bool state) { set_bed_leveling_enabled(state); }
+    bool getMeshValid() { return leveling_is_valid(); }
+    #if HAS_MESH
+      bed_mesh_t& getMeshArray() { return Z_VALUES_ARR; }
+      float getMeshPoint(const xy_uint8_t &pos) { return Z_VALUES(pos.x, pos.y); }
+      void setMeshPoint(const xy_uint8_t &pos, const float zoff) {
+        if (WITHIN(pos.x, 0, GRID_MAX_POINTS_X) && WITHIN(pos.y, 0, GRID_MAX_POINTS_Y)) {
+          Z_VALUES(pos.x, pos.y) = zoff;
+          #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+            bed_level_virt_interpolate();
+          #endif
+        }
+      }
+    #endif
+  #endif
+
+  #if ENABLED(HOST_PROMPT_SUPPORT)
+    void setHostResponse(const uint8_t response) { host_response_handler(response); }
+  #endif
+
+  #if ENABLED(PRINTCOUNTER)
+    char* getTotalPrints_str(char buffer[21])    { strcpy(buffer,i16tostr3left(print_job_timer.getStats().totalPrints));    return buffer; }
+    char* getFinishedPrints_str(char buffer[21]) { strcpy(buffer,i16tostr3left(print_job_timer.getStats().finishedPrints)); return buffer; }
+    char* getTotalPrintTime_str(char buffer[21]) { return duration_t(print_job_timer.getStats().printTime).toString(buffer); }
+    char* getLongestPrint_str(char buffer[21])   { return duration_t(print_job_timer.getStats().longestPrint).toString(buffer); }
+    char* getFilamentUsed_str(char buffer[21])   {
+      printStatistics stats = print_job_timer.getStats();
+      sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
+      return buffer;
+    }
+  #endif
+
+  float getFeedrate_percent() { return feedrate_percentage; }
+
+  #if ENABLED(PIDTEMP)
+    float getPIDValues_Kp(const extruder_t tool) {
+      return PID_PARAM(Kp, tool);
+    }
+
+    float getPIDValues_Ki(const extruder_t tool) {
+      return unscalePID_i(PID_PARAM(Ki, tool));
+    }
+
+    float getPIDValues_Kd(const extruder_t tool) {
+      return unscalePID_d(PID_PARAM(Kd, tool));
+    }
+
+    void setPIDValues(const float p, const float i, const float d, extruder_t tool) {
+      thermalManager.temp_hotend[tool].pid.Kp = p;
+      thermalManager.temp_hotend[tool].pid.Ki = scalePID_i(i);
+      thermalManager.temp_hotend[tool].pid.Kd = scalePID_d(d);
+      thermalManager.updatePID();
+    }
+
+    void startPIDTune(const float temp, extruder_t tool){
+      thermalManager.PID_autotune(temp, (heater_ind_t)tool, 8, true);
+    }
+  #endif
+
+  #if ENABLED(PIDTEMPBED)
+    float getBedPIDValues_Kp() {
+      return thermalManager.temp_bed.pid.Kp;
+    }
+
+    float getBedPIDValues_Ki() {
+      return unscalePID_i(thermalManager.temp_bed.pid.Ki);
+    }
+
+    float getBedPIDValues_Kd() {
+      return unscalePID_d(thermalManager.temp_bed.pid.Kd);
+    }
+
+    void setBedPIDValues(const float p, const float i, const float d) {
+      thermalManager.temp_bed.pid.Kp = p;
+      thermalManager.temp_bed.pid.Ki = scalePID_i(i);
+      thermalManager.temp_bed.pid.Kd = scalePID_d(d);
+      thermalManager.updatePID();
+    }
+
+    void startBedPIDTune(const float temp) {
+      thermalManager.PID_autotune(temp, H_BED, 4, true);
+    }
+  #endif
+
+  void injectCommands_P(PGM_P const gcode) {
+    queue.inject_P(gcode);
+  }
+
+  bool commandsInQueue() { return (planner.movesplanned() || queue.has_commands_queued()); }
+
+  bool isAxisPositionKnown(const axis_t axis) {
+    return TEST(axis_known_position, axis);
+  }
+
+  bool isAxisPositionKnown(const extruder_t) {
+    return TEST(axis_known_position, E_AXIS);
+  }
+
+  bool isPositionKnown() { return all_axes_known(); }
+  bool isMachineHomed() { return all_axes_homed(); }
+
+  PGM_P getFirmwareName_str() {
+    static const char firmware_name[] PROGMEM = "Marlin " SHORT_BUILD_VERSION;
+    return firmware_name;
+  }
+
+  void setTargetTemp_celsius(float value, const heater_t heater) {
+    #ifdef TOUCH_UI_LCD_TEMP_SCALING
+      value *= TOUCH_UI_LCD_TEMP_SCALING;
+    #endif
+    enableHeater(heater);
+    #if HAS_HEATED_CHAMBER
+      if (heater == CHAMBER)
+        thermalManager.setTargetChamber(LROUND(constrain(value, 0, CHAMBER_MAXTEMP - 10)));
+      else
+    #endif
+    #if HAS_HEATED_BED
+      if (heater == BED)
+        thermalManager.setTargetBed(LROUND(constrain(value, 0, BED_MAXTEMP - 10)));
+      else
+    #endif
+      {
+        #if HOTENDS
+          static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+          const int16_t e = heater - H0;
+          thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
+        #endif
+      }
+  }
+
+  void setTargetTemp_celsius(float value, const extruder_t extruder) {
+    #ifdef TOUCH_UI_LCD_TEMP_SCALING
+      value *= TOUCH_UI_LCD_TEMP_SCALING;
+    #endif
+    #if HOTENDS
+      constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+      const int16_t e = extruder - E0;
+      enableHeater(extruder);
+      thermalManager.setTargetHotend(LROUND(constrain(value, 0, heater_maxtemp[e] - 15)), e);
+    #endif
+  }
+
+  void setTargetFan_percent(const float value, const fan_t fan) {
+    #if FAN_COUNT > 0
+      if (fan < FAN_COUNT)
+        thermalManager.set_fan_speed(fan - FAN0, map(constrain(value, 0, 100), 0, 100, 0, 255));
+    #else
+      UNUSED(value);
+      UNUSED(fan);
+    #endif
+  }
+
+  void setFeedrate_percent(const float value) {
+    feedrate_percentage = constrain(value, 10, 500);
+  }
+
+  void setUserConfirmed() {
+    #if HAS_RESUME_CONTINUE
+      wait_for_user = false;
+    #endif
+  }
+
+  void printFile(const char *filename) {
+    UNUSED(filename);
+    IFSD(card.openAndPrintFile(filename), NOOP);
+  }
+
+  bool isPrintingFromMediaPaused() {
+    return IFSD(isPrintingFromMedia() && !IS_SD_PRINTING(), false);
+  }
+
+  bool isPrintingFromMedia() {
+    return IFSD(card.isFileOpen(), false);
+  }
+
+  bool isPrinting() {
+    return (planner.movesplanned() || isPrintingFromMedia() || IFSD(IS_SD_PRINTING(), false));
+  }
+
+  bool isMediaInserted() {
+    return IFSD(IS_SD_INSERTED() && card.isMounted(), false);
+  }
+
+  void pausePrint() {
+    ui.pause_print();
+  }
+
+  void resumePrint() {
+    ui.resume_print();
+  }
+
+  void stopPrint() {
+    ui.abort_print();
+  }
+
+  void onUserConfirmRequired_P(PGM_P const pstr) {
+    char msg[strlen_P(pstr) + 1];
+    strcpy_P(msg, pstr);
+    onUserConfirmRequired(msg);
+  }
+
+  FileList::FileList() { refresh(); }
+
+  void FileList::refresh() { num_files = 0xFFFF; }
+
+  bool FileList::seek(const uint16_t pos, const bool skip_range_check) {
+    #if ENABLED(SDSUPPORT)
+      if (!skip_range_check && (pos + 1) > count()) return false;
+      const uint16_t nr =
+        #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
+          count() - 1 -
+        #endif
+      pos;
+
+      card.getfilename_sorted(nr);
+      return card.filename[0] != '\0';
+    #else
+      UNUSED(pos);
+      UNUSED(skip_range_check);
+      return false;
+    #endif
+  }
+
+  const char* FileList::filename() {
+    return IFSD(card.longFilename[0] ? card.longFilename : card.filename, "");
+  }
+
+  const char* FileList::shortFilename() {
+    return IFSD(card.filename, "");
+  }
+
+  const char* FileList::longFilename() {
+    return IFSD(card.longFilename, "");
+  }
+
+  bool FileList::isDir() {
+    return IFSD(card.flag.filenameIsDir, false);
+  }
+
+  uint16_t FileList::count() {
+    return IFSD((num_files = (num_files == 0xFFFF ? card.get_num_Files() : num_files)), 0);
+  }
+
+  bool FileList::isAtRootDir() {
+    return (true
+      #if ENABLED(SDSUPPORT)
+        && card.flag.workDirIsRoot
+      #endif
+    );
+  }
+
+  void FileList::upDir() {
+    #if ENABLED(SDSUPPORT)
+      card.cdup();
+      num_files = 0xFFFF;
+    #endif
+  }
+
+  void FileList::changeDir(const char * const dirname) {
+    #if ENABLED(SDSUPPORT)
+      card.cd(dirname);
+      num_files = 0xFFFF;
+    #else
+      UNUSED(dirname);
+    #endif
+  }
+
+} // namespace ExtUI
+
+// At the moment, we piggy-back off the ultralcd calls, but this could be cleaned up in the future
+
+void MarlinUI::init() {
+  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)
+    SET_INPUT_PULLUP(SD_DETECT_PIN);
+  #endif
+
+  ExtUI::onStartup();
+}
+
+void MarlinUI::update() {
+  #if ENABLED(SDSUPPORT)
+    static bool last_sd_status;
+    const bool sd_status = IS_SD_INSERTED();
+    if (sd_status != last_sd_status) {
+      last_sd_status = sd_status;
+      if (sd_status) {
+        card.mount();
+        if (card.isMounted())
+          ExtUI::onMediaInserted();
+        else
+          ExtUI::onMediaError();
+      }
+      else {
+        const bool ok = card.isMounted();
+        card.release();
+        if (ok) ExtUI::onMediaRemoved();
+      }
+    }
+  #endif // SDSUPPORT
+  ExtUI::onIdle();
+}
+
+void MarlinUI::kill_screen(PGM_P const error, PGM_P const component) {
+  using namespace ExtUI;
+  if (!flags.printer_killed) {
+    flags.printer_killed = true;
+    onPrinterKilled(error, component);
+  }
+}
+
+#endif // EXTENSIBLE_UI
