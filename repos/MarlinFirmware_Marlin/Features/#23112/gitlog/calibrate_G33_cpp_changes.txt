commit b7c07f13293cd0cd1e8ddd67801b168f509d9721
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Mon Jul 8 17:13:21 2024 -0700

    🚸 Fix G33 display precision (3 digits) (#27186)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 59e0db132a..12aed86316 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -627,21 +627,21 @@ void GcodeSuite::G33() {
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_ECHOPGM("rolling back.");
           else
         #endif
           {
             SERIAL_ECHOPGM("std dev:", p_float_t(zero_std_dev_min, 3));
           }
         SERIAL_EOL();
 
-        MString<20> msg(F("Calibration sd:"));
+        MString<21> msg(F("Calibration sd:"));
         if (zero_std_dev_min < 1)
           msg.appendf(F("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
           msg.appendf(F("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(msg);
         print_calibration_settings(_endstop_results, _angle_results);
         SERIAL_ECHOLNPGM("Save with M500 and/or copy to Configuration.h");
       }
       else { // !end iterations
         SString<15> msg;

commit 669814d0d408a622f020a55971ba04030e4fa4bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 23:40:54 2024 -0600

    ✨ MARLIN_SMALL_BUILD option (#26775)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 223beb4ddf..59e0db132a 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -383,52 +383,52 @@ static float auto_tune_a(const float dcr) {
  *   Z   Don't activate stallguard on Z.
  *
  *   S   Save offset_sensorless_adj
  */
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
-    SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(P)oints implausible (0-10)."));
     return;
   }
 
   const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.seen_test('O')),
                   towers_set = !parser.seen_test('T');
 
   // The calibration radius is set to a calculated value
   float dcr = probe_at_offset ? PRINTABLE_RADIUS : PRINTABLE_RADIUS - PROBING_MARGIN;
   #if HAS_PROBE_XY_OFFSET
     const float total_offset = HYPOT(probe.offset_xy.x, probe.offset_xy.y);
     dcr -= probe_at_offset ? _MAX(total_offset, PROBING_MARGIN) : total_offset;
   #endif
   NOMORE(dcr, PRINTABLE_RADIUS);
   if (parser.seenval('R')) dcr -= _MAX(parser.value_float(), 0.0f);
   TERN_(HAS_DELTA_SENSORLESS_PROBING, dcr *= sensorless_radius_factor);
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
-    SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(C)alibration precision implausible (>=0)."));
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
-    SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(F)orce iteration implausible (0-30)."));
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
-    SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(V)erbose level implausible (0-3)."));
     return;
   }
 
   const bool stow_after_each = parser.seen_test('E');
 
   #if HAS_DELTA_SENSORLESS_PROBING
     probe.test_sensitivity = { !parser.seen_test('X'), !parser.seen_test('Y'), !parser.seen_test('Z') };
     const bool do_save_offset_adj = parser.seen_test('S');
   #endif
 

commit 52693f72afca243ace00a7a57365301f5f8c42c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 13:01:45 2024 -0600

    🎨 Clean up some checks & includes

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index d8f104bfce..223beb4ddf 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -28,24 +28,20 @@
 #include "../../module/delta.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/endstops.h"
 #include "../../lcd/marlinui.h"
 
 #if HAS_BED_PROBE
   #include "../../module/probe.h"
 #endif
 
-#if HAS_MULTI_HOTEND
-  #include "../../module/tool_change.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
                   _4P_STEP = _7P_STEP * 2,   // 4-point step
                   NPP      = _7P_STEP * 6;   // number of calibration points on the radius
 enum CalEnum : char {                        // the 7 main calibration points - add definitions if needed
   CEN      = 0,
   __A      = 1,

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    🧑‍💻 AS_CHAR => C (#26569)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 0cddf484eb..d8f104bfce 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -85,21 +85,21 @@ void ac_setup(const bool reset_bed) {
 }
 
 void ac_cleanup() {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_BED_PROBE, probe.use_probing_tool(false));
 }
 
 void print_signed_float(FSTR_P const prefix, const_float_t f) {
-  SERIAL_ECHO(F("  "), prefix, AS_CHAR(':'));
+  SERIAL_ECHO(F("  "), prefix, C(':'));
   serial_offset(f);
 }
 
 /**
  * - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(F("Ex"), delta_endstop_adj.a);

commit 4cab75115fe559e702ebe7a8dc040ebe0d6d4d0b
Author: Orel <37673727+0r31@users.noreply.github.com>
Date:   Sat Oct 7 08:10:22 2023 +0200

    🩹 Fix G33 output (#26299)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 23753e077f..0cddf484eb 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -452,23 +452,22 @@ void GcodeSuite::G33() {
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   // Report settings
-  PGM_P const checkingac = PSTR("Checking... AC");
-  SERIAL_ECHOPGM_P(checkingac);
-  SERIAL_ECHOPGM(" at radius:", dcr);
+  FSTR_P const checkingac = F("Checking... AC");
+  SERIAL_ECHO(checkingac, F(" at radius:"), dcr);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 

commit 4f691e622f3dc1de5a64bcaf42d3de56c9808322
Author: Ari-SSO <85907917+Ari-SSO@users.noreply.github.com>
Date:   Mon Aug 7 06:35:22 2023 -0300

    🩹 PROBING_TOOL followup (#26122)
    
    Followup to #24411
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 10f5afca2d..23753e077f 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -77,34 +77,34 @@ void ac_setup(const bool reset_bed) {
   TERN_(HAS_BED_PROBE, probe.use_probing_tool());
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
-void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
+void ac_cleanup() {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_BED_PROBE, probe.use_probing_tool(false));
 }
 
 void print_signed_float(FSTR_P const prefix, const_float_t f) {
   SERIAL_ECHO(F("  "), prefix, AS_CHAR(':'));
   serial_offset(f);
 }
 
 /**
- *  - Print the delta settings
+ * - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(F("Ex"), delta_endstop_adj.a);
     print_signed_float(F("Ey"), delta_endstop_adj.b);
     print_signed_float(F("Ez"), delta_endstop_adj.c);
   }
   if (end_stops && tower_angles) {
     SERIAL_ECHOLNPGM("  Radius:", delta_radius);
@@ -116,21 +116,21 @@ static void print_calibration_settings(const bool end_stops, const bool tower_an
     print_signed_float(F("Ty"), delta_tower_angle_trim.b);
     print_signed_float(F("Tz"), delta_tower_angle_trim.c);
   }
   if (end_stops != tower_angles)
     SERIAL_ECHOPGM("  Radius:", delta_radius);
 
   SERIAL_EOL();
 }
 
 /**
- *  - Print the probe results
+ * - Print the probe results
  */
 static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_ECHOPGM(".    ");
   print_signed_float(F("c"), z_pt[CEN]);
   if (tower_points) {
     print_signed_float(F(" x"), z_pt[__A]);
     print_signed_float(F(" y"), z_pt[__B]);
     print_signed_float(F(" z"), z_pt[__C]);
   }
   if (tower_points && opposite_points) {
@@ -140,51 +140,51 @@ static void print_calibration_results(const float z_pt[NPP + 1], const bool towe
   }
   if (opposite_points) {
     print_signed_float(F("yz"), z_pt[_BC]);
     print_signed_float(F("zx"), z_pt[_CA]);
     print_signed_float(F("xy"), z_pt[_AB]);
   }
   SERIAL_EOL();
 }
 
 /**
- *  - Calculate the standard deviation from the zero plane
+ * - Calculate the standard deviation from the zero plane
  */
 static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool _1p_cal, const bool _4p_cal, const bool _4p_opp) {
   if (!_0p_cal) {
     float S2 = sq(z_pt[CEN]);
     int16_t N = 1;
     if (!_1p_cal) { // std dev from zero plane
       LOOP_CAL_ACT(rad, _4p_cal, _4p_opp) {
         S2 += sq(z_pt[rad]);
         N++;
       }
       return LROUND(SQRT(S2 / N) * 1000.0f) / 1000.0f + 0.00001f;
     }
   }
   return 0.00001f;
 }
 
 /**
- *  - Probe a point
+ * - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow, const bool probe_at_offset) {
   #if HAS_BED_PROBE
     return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, probe_at_offset, false, Z_PROBE_LOW_POINT, Z_TWEEN_SAFE_CLEARANCE, true);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
- *  - Probe a grid
+ * - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const float dcr, const bool towers_set, const bool stow_after_each, const bool probe_at_offset) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
@@ -494,21 +494,21 @@ void GcodeSuite::G33() {
 
     float z_at_pt[NPP + 1] = { 0.0f };
 
     test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
     if (!probe_calibration_points(z_at_pt, probe_points, dcr, towers_set, stow_after_each, probe_at_offset)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
-      return ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
+      return ac_cleanup();
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
         test_precision = 0.0f; // forced end
       #endif
@@ -671,19 +671,19 @@ void GcodeSuite::G33() {
       if (zero_std_dev < 1)
         msg.appendf(F("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         msg.appendf(F("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(msg);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
-  ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
+  ac_cleanup();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
   #if HAS_DELTA_SENSORLESS_PROBING
     probe.test_sensitivity = { true, true, true };
   #endif
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    🔧 More endstops refactoring (#25758)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 7530737dde..10f5afca2d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -60,23 +60,23 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
-  TERN_(SENSORLESS_HOMING, endstops.set_homing_current(true));
+  TERN_(SENSORLESS_HOMING, endstops.set_z_sensorless_current(true));
   home_delta();
-  TERN_(SENSORLESS_HOMING, endstops.set_homing_current(false));
+  TERN_(SENSORLESS_HOMING, endstops.set_z_sensorless_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_BED_PROBE, probe.use_probing_tool());
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING

commit 6379d4dbca389b264cf5b404bd6fd9f5c3221be8
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Jul 22 15:05:04 2023 +1200

    🩹 Suppress G33 string warning (#26095)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index a3cb7f0b9d..7530737dde 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -642,21 +642,21 @@ void GcodeSuite::G33() {
         MString<20> msg(F("Calibration sd:"));
         if (zero_std_dev_min < 1)
           msg.appendf(F("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
           msg.appendf(F("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(msg);
         print_calibration_settings(_endstop_results, _angle_results);
         SERIAL_ECHOLNPGM("Save with M500 and/or copy to Configuration.h");
       }
       else { // !end iterations
-        SString<14> msg;
+        SString<15> msg;
         if (iterations < 31)
           msg.setf(F("Iteration : %02i"), (unsigned int)iterations);
         else
           msg.set(F("No convergence"));
         msg.echo();
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPGM("std dev:", p_float_t(zero_std_dev, 3));
         ui.set_status(msg);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ♻️ String helper class (#24390)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ba6cccffab..a3cb7f0b9d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -631,58 +631,55 @@ void GcodeSuite::G33() {
         SERIAL_ECHO_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_ECHOPGM("rolling back.");
           else
         #endif
           {
             SERIAL_ECHOPGM("std dev:", p_float_t(zero_std_dev_min, 3));
           }
         SERIAL_EOL();
-        char mess[21];
-        strcpy_P(mess, PSTR("Calibration sd:"));
+
+        MString<20> msg(F("Calibration sd:"));
         if (zero_std_dev_min < 1)
-          sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
+          msg.appendf(F("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
-          sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
-        ui.set_status(mess);
+          msg.appendf(F("%03i.x"), (int)LROUND(zero_std_dev_min));
+        ui.set_status(msg);
         print_calibration_settings(_endstop_results, _angle_results);
         SERIAL_ECHOLNPGM("Save with M500 and/or copy to Configuration.h");
       }
       else { // !end iterations
-        char mess[15];
+        SString<14> msg;
         if (iterations < 31)
-          sprintf_P(mess, PSTR("Iteration : %02i"), (unsigned int)iterations);
+          msg.setf(F("Iteration : %02i"), (unsigned int)iterations);
         else
-          strcpy_P(mess, PSTR("No convergence"));
-        SERIAL_ECHO(mess);
+          msg.set(F("No convergence"));
+        msg.echo();
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPGM("std dev:", p_float_t(zero_std_dev, 3));
-        ui.set_status(mess);
+        ui.set_status(msg);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       FSTR_P const enddryrun = F("End DRY-RUN");
       SERIAL_ECHO(enddryrun);
       SERIAL_ECHO_SP(35);
       SERIAL_ECHOLNPGM("std dev:", p_float_t(zero_std_dev, 3));
-
-      char mess[21];
-      strcpy_P(mess, FTOP(enddryrun));
-      strcpy_P(&mess[11], PSTR(" sd:"));
+      MString<30> msg(enddryrun, F(" sd:"));
       if (zero_std_dev < 1)
-        sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
+        msg.appendf(F("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
-        sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
-      ui.set_status(mess);
+        msg.appendf(F("%03i.x"), (int)LROUND(zero_std_dev));
+      ui.set_status(msg);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
   #if HAS_DELTA_SENSORLESS_PROBING
     probe.test_sensitivity = { true, true, true };

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ♻️ Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 226570acce..ba6cccffab 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -85,22 +85,21 @@ void ac_setup(const bool reset_bed) {
 }
 
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_BED_PROBE, probe.use_probing_tool(false));
 }
 
 void print_signed_float(FSTR_P const prefix, const_float_t f) {
-  SERIAL_ECHOPGM("  ");
-  SERIAL_ECHOF(prefix, AS_CHAR(':'));
+  SERIAL_ECHO(F("  "), prefix, AS_CHAR(':'));
   serial_offset(f);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(F("Ex"), delta_endstop_adj.a);
@@ -629,52 +628,52 @@ void GcodeSuite::G33() {
     if (verbose_level != 0) { // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) { // end iterations
         SERIAL_ECHOPGM("Calibration OK");
         SERIAL_ECHO_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_ECHOPGM("rolling back.");
           else
         #endif
           {
-            SERIAL_ECHOPAIR_F("std dev:", zero_std_dev_min, 3);
+            SERIAL_ECHOPGM("std dev:", p_float_t(zero_std_dev_min, 3));
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         SERIAL_ECHOLNPGM("Save with M500 and/or copy to Configuration.h");
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (unsigned int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
-        SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
+        SERIAL_ECHOLNPGM("std dev:", p_float_t(zero_std_dev, 3));
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       FSTR_P const enddryrun = F("End DRY-RUN");
-      SERIAL_ECHOF(enddryrun);
+      SERIAL_ECHO(enddryrun);
       SERIAL_ECHO_SP(35);
-      SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
+      SERIAL_ECHOLNPGM("std dev:", p_float_t(zero_std_dev, 3));
 
       char mess[21];
       strcpy_P(mess, FTOP(enddryrun));
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    🧑‍💻 Endstops preliminary work (#25780)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 08734073d6..226570acce 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -469,22 +469,21 @@ void GcodeSuite::G33() {
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   #if HAS_DELTA_SENSORLESS_PROBING
     if (verbose_level > 0 && do_save_offset_adj) {
       offset_sensorless_adj.reset();
-
-      auto caltower = [&](Probe::sense_bool_t s){
+      auto caltower = [&](Probe::sense_bool_t s) {
         float z_at_pt[NPP + 1];
         LOOP_CAL_ALL(rad) z_at_pt[rad] = 0.0f;
         probe.test_sensitivity = s;
         if (probe_calibration_points(z_at_pt, 1, dcr, false, false, probe_at_offset))
           probe.set_offset_sensorless_adj(z_at_pt[CEN]);
       };
       caltower({ true, false, false }); // A
       caltower({ false, true, false }); // B
       caltower({ false, false, true }); // C
 

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    🐛 Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 61320c0576..08734073d6 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -163,21 +163,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow, const bool probe_at_offset) {
   #if HAS_BED_PROBE
-    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, probe_at_offset, false);
+    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, probe_at_offset, false, Z_PROBE_LOW_POINT, Z_TWEEN_SAFE_CLEARANCE, true);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const float dcr, const bool towers_set, const bool stow_after_each, const bool probe_at_offset) {

commit 06cfd9c54af1537adf458a719b840cd501395278
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Mar 22 02:15:51 2023 +0200

    ✨ PROBING_TOOL (#24411)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 836d5c867b..61320c0576 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -56,50 +56,46 @@ enum CalEnum : char {                        // the 7 main calibration points -
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
-#if HAS_MULTI_HOTEND
-  const uint8_t old_tool_index = active_extruder;
-#endif
-
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
   TERN_(SENSORLESS_HOMING, endstops.set_homing_current(true));
   home_delta();
   TERN_(SENSORLESS_HOMING, endstops.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
-  TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
+  TERN_(HAS_BED_PROBE, probe.use_probing_tool());
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
-  TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
+  TERN_(HAS_BED_PROBE, probe.use_probing_tool(false));
 }
 
 void print_signed_float(FSTR_P const prefix, const_float_t f) {
   SERIAL_ECHOPGM("  ");
   SERIAL_ECHOF(prefix, AS_CHAR(':'));
   serial_offset(f);
 }
 
 /**
  *  - Print the delta settings

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ✨ Polar Kinematics (#25214)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 656c23cb78..836d5c867b 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -400,26 +400,26 @@ void GcodeSuite::G33() {
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
   const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.seen_test('O')),
                   towers_set = !parser.seen_test('T');
 
   // The calibration radius is set to a calculated value
-  float dcr = probe_at_offset ? DELTA_PRINTABLE_RADIUS : DELTA_PRINTABLE_RADIUS - PROBING_MARGIN;
+  float dcr = probe_at_offset ? PRINTABLE_RADIUS : PRINTABLE_RADIUS - PROBING_MARGIN;
   #if HAS_PROBE_XY_OFFSET
     const float total_offset = HYPOT(probe.offset_xy.x, probe.offset_xy.y);
     dcr -= probe_at_offset ? _MAX(total_offset, PROBING_MARGIN) : total_offset;
   #endif
-  NOMORE(dcr, DELTA_PRINTABLE_RADIUS);
+  NOMORE(dcr, PRINTABLE_RADIUS);
   if (parser.seenval('R')) dcr -= _MAX(parser.value_float(), 0.0f);
   TERN_(HAS_DELTA_SENSORLESS_PROBING, dcr *= sensorless_radius_factor);
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    🧑‍💻  Update planner/stepper includes

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ffe53b63fb..656c23cb78 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -20,21 +20,21 @@
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DELTA_AUTO_CALIBRATION)
 
 #include "../gcode.h"
 #include "../../module/delta.h"
 #include "../../module/motion.h"
-#include "../../module/stepper.h"
+#include "../../module/planner.h"
 #include "../../module/endstops.h"
 #include "../../lcd/marlinui.h"
 
 #if HAS_BED_PROBE
   #include "../../module/probe.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif

commit 3b142e531ce6dcd15e5a32cc94bd6c4d5fa8fb46
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jun 7 02:22:17 2022 +0200

    🩹 Fix G33 Delta Sensorless Probing compile (#24291)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 810fb734dc..ffe53b63fb 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -430,21 +430,21 @@ void GcodeSuite::G33() {
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen_test('E');
 
   #if HAS_DELTA_SENSORLESS_PROBING
-    probe.test_sensitivity.set(!parser.seen_test('X'), !parser.seen_test('Y'), !parser.seen_test('Z'));
+    probe.test_sensitivity = { !parser.seen_test('X'), !parser.seen_test('Y'), !parser.seen_test('Z') };
     const bool do_save_offset_adj = parser.seen_test('S');
   #endif
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ⚡️ Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 7f487abd6b..810fb734dc 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -64,23 +64,23 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 #if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
-  TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(true));
+  TERN_(SENSORLESS_HOMING, endstops.set_homing_current(true));
   home_delta();
-  TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(false));
+  TERN_(SENSORLESS_HOMING, endstops.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
@@ -383,20 +383,22 @@ static float auto_tune_a(const float dcr) {
  *
  *   E   Engage the probe for each point
  *
  *   O   Probe at offsetted probe positions (this is wrong but it seems to work)
  *
  * With SENSORLESS_PROBING:
  *   Use these flags to calibrate stall sensitivity: (e.g., `G33 P1 Y Z` to calibrate X only.)
  *   X   Don't activate stallguard on X.
  *   Y   Don't activate stallguard on Y.
  *   Z   Don't activate stallguard on Z.
+ *
+ *   S   Save offset_sensorless_adj
  */
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
@@ -404,21 +406,22 @@ void GcodeSuite::G33() {
   const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.seen_test('O')),
                   towers_set = !parser.seen_test('T');
 
   // The calibration radius is set to a calculated value
   float dcr = probe_at_offset ? DELTA_PRINTABLE_RADIUS : DELTA_PRINTABLE_RADIUS - PROBING_MARGIN;
   #if HAS_PROBE_XY_OFFSET
     const float total_offset = HYPOT(probe.offset_xy.x, probe.offset_xy.y);
     dcr -= probe_at_offset ? _MAX(total_offset, PROBING_MARGIN) : total_offset;
   #endif
   NOMORE(dcr, DELTA_PRINTABLE_RADIUS);
-  if (parser.seenval('R')) dcr -= _MAX(parser.value_float(),0);
+  if (parser.seenval('R')) dcr -= _MAX(parser.value_float(), 0.0f);
+  TERN_(HAS_DELTA_SENSORLESS_PROBING, dcr *= sensorless_radius_factor);
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
@@ -427,23 +430,22 @@ void GcodeSuite::G33() {
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen_test('E');
 
   #if HAS_DELTA_SENSORLESS_PROBING
-    probe.test_sensitivity.x = !parser.seen_test('X');
-    TERN_(HAS_Y_AXIS, probe.test_sensitivity.y = !parser.seen_test('Y'));
-    TERN_(HAS_Z_AXIS, probe.test_sensitivity.z = !parser.seen_test('Z'));
+    probe.test_sensitivity.set(!parser.seen_test('X'), !parser.seen_test('Y'), !parser.seen_test('Z'));
+    const bool do_save_offset_adj = parser.seen_test('S');
   #endif
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
@@ -468,20 +470,39 @@ void GcodeSuite::G33() {
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
+  #if HAS_DELTA_SENSORLESS_PROBING
+    if (verbose_level > 0 && do_save_offset_adj) {
+      offset_sensorless_adj.reset();
+
+      auto caltower = [&](Probe::sense_bool_t s){
+        float z_at_pt[NPP + 1];
+        LOOP_CAL_ALL(rad) z_at_pt[rad] = 0.0f;
+        probe.test_sensitivity = s;
+        if (probe_calibration_points(z_at_pt, 1, dcr, false, false, probe_at_offset))
+          probe.set_offset_sensorless_adj(z_at_pt[CEN]);
+      };
+      caltower({ true, false, false }); // A
+      caltower({ false, true, false }); // B
+      caltower({ false, false, true }); // C
+
+      probe.test_sensitivity = { true, true, true }; // reset to all
+    }
+  #endif
+
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0f };
 
     test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
     if (!probe_calibration_points(z_at_pt, probe_points, dcr, towers_set, stow_after_each, probe_at_offset)) {
@@ -591,22 +612,31 @@ void GcodeSuite::G33() {
       // adjust delta_height and endstops by the max amount
       const float z_temp = _MAX(delta_endstop_adj.a, delta_endstop_adj.b, delta_endstop_adj.c);
       delta_height -= z_temp;
       LOOP_NUM_AXES(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
-    if (verbose_level == 3 || verbose_level == 0)
+    if (verbose_level == 3 || verbose_level == 0) {
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);
+      #if HAS_DELTA_SENSORLESS_PROBING
+        if (verbose_level == 0 && probe_points == 1) {
+          if (do_save_offset_adj)
+            probe.set_offset_sensorless_adj(z_at_pt[CEN]);
+          else
+            probe.refresh_largest_sensorless_adj();
+        }
+      #endif
+    }
 
     if (verbose_level != 0) { // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) { // end iterations
         SERIAL_ECHOPGM("Calibration OK");
         SERIAL_ECHO_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_ECHOPGM("rolling back.");
           else
         #endif
@@ -653,13 +683,16 @@ void GcodeSuite::G33() {
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
+  #if HAS_DELTA_SENSORLESS_PROBING
+    probe.test_sensitivity = { true, true, true };
+  #endif
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ✨ Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 506f367947..7f487abd6b 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -336,21 +336,21 @@ static float auto_tune_r(const float dcr) {
   r_fac = diff / r_fac / 3.0f; // 1/(3*delta_Z)
   return r_fac;
 }
 
 static float auto_tune_a(const float dcr) {
   constexpr float diff = 0.01f, delta_r = 0.0f;
   float a_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
   delta_t.reset();
-  LOOP_LINEAR_AXES(axis) {
+  LOOP_NUM_AXES(axis) {
     delta_t[axis] = diff;
     calc_kinematics_diff_probe_points(z_pt, dcr, delta_e, delta_r, delta_t);
     delta_t[axis] = 0;
     a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0f;
     a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0f;
   }
   a_fac = diff / a_fac / 3.0f; // 1/(3*delta_Z)
   return a_fac;
 }
 
@@ -529,21 +529,21 @@ void GcodeSuite::G33() {
       a_factor = auto_tune_a(dcr);
       if (_7p_9_center) dcr /= 0.9f;
 
       switch (probe_points) {
         case 0:
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
-          LOOP_LINEAR_AXES(axis) e_delta[axis] = +Z4(CEN);
+          LOOP_NUM_AXES(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:
           if (towers_set) { // see 4 point calibration (towers) matrix
             e_delta.set((+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN),
                         (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN),
                         (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN));
             r_delta   = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
           }
           else { // see 4 point calibration (opposites) matrix
@@ -577,28 +577,28 @@ void GcodeSuite::G33() {
       delta_radius = r_old;
       delta_height = h_old;
       delta_tower_angle_trim = a_old;
     }
 
     if (verbose_level != 0) {                                    // !dry run
 
       // Normalize angles to least-squares
       if (_angle_results) {
         float a_sum = 0.0f;
-        LOOP_LINEAR_AXES(axis) a_sum += delta_tower_angle_trim[axis];
-        LOOP_LINEAR_AXES(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
+        LOOP_NUM_AXES(axis) a_sum += delta_tower_angle_trim[axis];
+        LOOP_NUM_AXES(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = _MAX(delta_endstop_adj.a, delta_endstop_adj.b, delta_endstop_adj.c);
       delta_height -= z_temp;
-      LOOP_LINEAR_AXES(axis) delta_endstop_adj[axis] -= z_temp;
+      LOOP_NUM_AXES(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3 || verbose_level == 0)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) { // !dry run

commit df4e022a48667369fcc94dfda56505eb3ba2019f
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Sat Mar 12 00:12:03 2022 +0100

    🚸 Fix, extend X Axis Twist Compensation (#23745)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index a4b9aec01b..506f367947 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -91,22 +91,21 @@ void ac_setup(const bool reset_bed) {
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
 }
 
 void print_signed_float(FSTR_P const prefix, const_float_t f) {
   SERIAL_ECHOPGM("  ");
   SERIAL_ECHOF(prefix, AS_CHAR(':'));
-  if (f >= 0) SERIAL_CHAR('+');
-  SERIAL_ECHO_F(f, 2);
+  serial_offset(f);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(F("Ex"), delta_endstop_adj.a);
     print_signed_float(F("Ey"), delta_endstop_adj.b);

commit 629498f8d43be6675674671927456b8b6b4ac47b
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Tue Nov 16 16:24:53 2021 +0100

    🐛 Fix G33, Delta radii, reachable (#22795)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 779ae99d0a..a4b9aec01b 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -62,22 +62,20 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 #if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
-float dcr;
-
 void ac_home() {
   endstops.enable(true);
   TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(true));
   home_delta();
   TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
@@ -170,31 +168,31 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow, const bool probe_at_offset) {
   #if HAS_BED_PROBE
-    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true, probe_at_offset);
+    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, probe_at_offset, false);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
-static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each, const bool probe_at_offset) {
+static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const float dcr, const bool towers_set, const bool stow_after_each, const bool probe_at_offset) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
@@ -264,98 +262,98 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
   }
   return true;
 }
 
 /**
  * kinematics routines and auto tune matrix scaling parameters:
  * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
  *  - formulae for approximative forward kinematics in the end-stop displacement matrix
  *  - definition of the matrix scaling parameters
  */
-static void reverse_kinematics_probe_points(float z_pt[NPP + 1], abc_float_t mm_at_pt_axis[NPP + 1]) {
+static void reverse_kinematics_probe_points(float z_pt[NPP + 1], abc_float_t mm_at_pt_axis[NPP + 1], const float dcr) {
   xyz_pos_t pos{0};
 
   LOOP_CAL_ALL(rad) {
     const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                 r = (rad == CEN ? 0.0f : dcr);
     pos.set(cos(a) * r, sin(a) * r, z_pt[rad]);
     inverse_kinematics(pos);
     mm_at_pt_axis[rad] = delta;
   }
 }
 
-static void forward_kinematics_probe_points(abc_float_t mm_at_pt_axis[NPP + 1], float z_pt[NPP + 1]) {
+static void forward_kinematics_probe_points(abc_float_t mm_at_pt_axis[NPP + 1], float z_pt[NPP + 1], const float dcr) {
   const float r_quot = dcr / delta_radius;
 
   #define ZPP(N,I,A) (((1.0f + r_quot * (N)) / 3.0f) * mm_at_pt_axis[I].A)
   #define Z00(I, A) ZPP( 0, I, A)
   #define Zp1(I, A) ZPP(+1, I, A)
   #define Zm1(I, A) ZPP(-1, I, A)
   #define Zp2(I, A) ZPP(+2, I, A)
   #define Zm2(I, A) ZPP(-2, I, A)
 
   z_pt[CEN] = Z00(CEN, a) + Z00(CEN, b) + Z00(CEN, c);
   z_pt[__A] = Zp2(__A, a) + Zm1(__A, b) + Zm1(__A, c);
   z_pt[__B] = Zm1(__B, a) + Zp2(__B, b) + Zm1(__B, c);
   z_pt[__C] = Zm1(__C, a) + Zm1(__C, b) + Zp2(__C, c);
   z_pt[_BC] = Zm2(_BC, a) + Zp1(_BC, b) + Zp1(_BC, c);
   z_pt[_CA] = Zp1(_CA, a) + Zm2(_CA, b) + Zp1(_CA, c);
   z_pt[_AB] = Zp1(_AB, a) + Zp1(_AB, b) + Zm2(_AB, c);
 }
 
-static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], abc_float_t delta_e, const float delta_r, abc_float_t delta_t) {
+static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], const float dcr, abc_float_t delta_e, const float delta_r, abc_float_t delta_t) {
   const float z_center = z_pt[CEN];
   abc_float_t diff_mm_at_pt_axis[NPP + 1], new_mm_at_pt_axis[NPP + 1];
 
-  reverse_kinematics_probe_points(z_pt, diff_mm_at_pt_axis);
+  reverse_kinematics_probe_points(z_pt, diff_mm_at_pt_axis, dcr);
 
   delta_radius += delta_r;
   delta_tower_angle_trim += delta_t;
   recalc_delta_settings();
-  reverse_kinematics_probe_points(z_pt, new_mm_at_pt_axis);
+  reverse_kinematics_probe_points(z_pt, new_mm_at_pt_axis, dcr);
 
   LOOP_CAL_ALL(rad) diff_mm_at_pt_axis[rad] -= new_mm_at_pt_axis[rad] + delta_e;
-  forward_kinematics_probe_points(diff_mm_at_pt_axis, z_pt);
+  forward_kinematics_probe_points(diff_mm_at_pt_axis, z_pt, dcr);
 
   LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
   z_pt[CEN] = z_center;
 
   delta_radius -= delta_r;
   delta_tower_angle_trim -= delta_t;
   recalc_delta_settings();
 }
 
-static float auto_tune_h() {
+static float auto_tune_h(const float dcr) {
   const float r_quot = dcr / delta_radius;
   return RECIPROCAL(r_quot / (2.0f / 3.0f));  // (2/3)/CR
 }
 
-static float auto_tune_r() {
+static float auto_tune_r(const float dcr) {
   constexpr float diff = 0.01f, delta_r = diff;
   float r_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
-  calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
+  calc_kinematics_diff_probe_points(z_pt, dcr, delta_e, delta_r, delta_t);
   r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0f;
   r_fac = diff / r_fac / 3.0f; // 1/(3*delta_Z)
   return r_fac;
 }
 
-static float auto_tune_a() {
+static float auto_tune_a(const float dcr) {
   constexpr float diff = 0.01f, delta_r = 0.0f;
   float a_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
   delta_t.reset();
   LOOP_LINEAR_AXES(axis) {
     delta_t[axis] = diff;
-    calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
+    calc_kinematics_diff_probe_points(z_pt, dcr, delta_e, delta_r, delta_t);
     delta_t[axis] = 0;
     a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0f;
     a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0f;
   }
   a_fac = diff / a_fac / 3.0f; // 1/(3*delta_Z)
   return a_fac;
 }
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
@@ -363,75 +361,65 @@ static float auto_tune_a() {
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *      P0       Normalizes calibration.
  *      P1       Calibrates height only with center probe.
  *      P2       Probe center and towers. Calibrate height, endstops and delta radius.
  *      P3       Probe all positions: center, towers and opposite towers. Calibrate all.
  *      P4-P10   Probe all positions at different intermediate locations and average them.
  *
- *   Rn.nn  override default calibration Radius
+ *   Rn.nn  Temporary reduce the probe grid by the specified amount (mm)
  *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and take the best result
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  *
- *   O   Probe at offset points (this is wrong but it seems to work)
+ *   O   Probe at offsetted probe positions (this is wrong but it seems to work)
  *
  * With SENSORLESS_PROBING:
  *   Use these flags to calibrate stall sensitivity: (e.g., `G33 P1 Y Z` to calibrate X only.)
  *   X   Don't activate stallguard on X.
  *   Y   Don't activate stallguard on Y.
  *   Z   Don't activate stallguard on Z.
  */
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
-  const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.boolval('O')),
+  const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.seen_test('O')),
                   towers_set = !parser.seen_test('T');
 
-  float max_dcr = dcr = DELTA_PRINTABLE_RADIUS;
+  // The calibration radius is set to a calculated value
+  float dcr = probe_at_offset ? DELTA_PRINTABLE_RADIUS : DELTA_PRINTABLE_RADIUS - PROBING_MARGIN;
   #if HAS_PROBE_XY_OFFSET
-    // For offset probes the calibration radius is set to a safe but non-optimal value
-    dcr -= HYPOT(probe.offset_xy.x, probe.offset_xy.y);
-    if (probe_at_offset) {
-      // With probe positions both probe and nozzle need to be within the printable area
-      max_dcr = dcr;
-    }
-    // else with nozzle positions there is a risk of the probe being outside the bed
-    // but as long the nozzle stays within the printable area there is no risk of
-    // the effector crashing into the towers.
+    const float total_offset = HYPOT(probe.offset_xy.x, probe.offset_xy.y);
+    dcr -= probe_at_offset ? _MAX(total_offset, PROBING_MARGIN) : total_offset;
   #endif
-
-  if (parser.seenval('R')) dcr = parser.value_float();
-  if (!WITHIN(dcr, 0, max_dcr)) {
-    SERIAL_ECHOLNPGM("?calibration (R)adius implausible.");
-    return;
-  }
+  NOMORE(dcr, DELTA_PRINTABLE_RADIUS);
+  if (parser.seenval('R')) dcr -= _MAX(parser.value_float(),0);
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
@@ -468,42 +456,43 @@ void GcodeSuite::G33() {
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   // Report settings
-  FSTR_P const checkingac = F("Checking... AC");
-  SERIAL_ECHOF(checkingac);
+  PGM_P const checkingac = PSTR("Checking... AC");
+  SERIAL_ECHOPGM_P(checkingac);
+  SERIAL_ECHOPGM(" at radius:", dcr);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0f };
 
     test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
-    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each, probe_at_offset)) {
+    if (!probe_calibration_points(z_at_pt, probe_points, dcr, towers_set, stow_after_each, probe_at_offset)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
       return ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
@@ -529,24 +518,24 @@ void GcodeSuite::G33() {
        */
       #define ZP(N,I) ((N) * z_at_pt[I] / 4.0f) // 4.0 = divider to normalize to integers
       #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
       #define Z0(I) ZP(0, I)
 
       // calculate factors
       if (_7p_9_center) dcr *= 0.9f;
-      h_factor = auto_tune_h();
-      r_factor = auto_tune_r();
-      a_factor = auto_tune_a();
-      dcr /= 0.9f;
+      h_factor = auto_tune_h(dcr);
+      r_factor = auto_tune_r(dcr);
+      a_factor = auto_tune_a(dcr);
+      if (_7p_9_center) dcr /= 0.9f;
 
       switch (probe_points) {
         case 0:
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
           LOOP_LINEAR_AXES(axis) e_delta[axis] = +Z4(CEN);
           break;

commit 02dc7a6387fdc3b9bd1659b3aa400802bacb7828
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Oct 13 14:28:45 2021 +1300

    🐛 Fix G33 homing current (#22909)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 8a9de49880..779ae99d0a 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -66,23 +66,23 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 float dcr;
 
 void ac_home() {
   endstops.enable(true);
-  TERN_(SENSORLESS_HOMING, probe.set_homing_current(true));
+  TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(true));
   home_delta();
-  TERN_(SENSORLESS_HOMING, probe.set_homing_current(false));
+  TERN_(HAS_DELTA_SENSORLESS_PROBING, probe.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    🎨 Apply F() to various reports

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 39494cde24..8a9de49880 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -90,75 +90,73 @@ void ac_setup(const bool reset_bed) {
   #endif
 }
 
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
 }
 
-void print_signed_float(PGM_P const prefix, const_float_t f) {
+void print_signed_float(FSTR_P const prefix, const_float_t f) {
   SERIAL_ECHOPGM("  ");
-  SERIAL_ECHOPGM_P(prefix);
-  SERIAL_CHAR(':');
+  SERIAL_ECHOF(prefix, AS_CHAR(':'));
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
-    print_signed_float(PSTR("Ex"), delta_endstop_adj.a);
-    print_signed_float(PSTR("Ey"), delta_endstop_adj.b);
-    print_signed_float(PSTR("Ez"), delta_endstop_adj.c);
+    print_signed_float(F("Ex"), delta_endstop_adj.a);
+    print_signed_float(F("Ey"), delta_endstop_adj.b);
+    print_signed_float(F("Ez"), delta_endstop_adj.c);
   }
   if (end_stops && tower_angles) {
-    SERIAL_ECHOPGM("  Radius:", delta_radius);
-    SERIAL_EOL();
+    SERIAL_ECHOLNPGM("  Radius:", delta_radius);
     SERIAL_CHAR('.');
     SERIAL_ECHO_SP(13);
   }
   if (tower_angles) {
-    print_signed_float(PSTR("Tx"), delta_tower_angle_trim.a);
-    print_signed_float(PSTR("Ty"), delta_tower_angle_trim.b);
-    print_signed_float(PSTR("Tz"), delta_tower_angle_trim.c);
+    print_signed_float(F("Tx"), delta_tower_angle_trim.a);
+    print_signed_float(F("Ty"), delta_tower_angle_trim.b);
+    print_signed_float(F("Tz"), delta_tower_angle_trim.c);
   }
-  if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
+  if (end_stops != tower_angles)
     SERIAL_ECHOPGM("  Radius:", delta_radius);
-  }
+
   SERIAL_EOL();
 }
 
 /**
  *  - Print the probe results
  */
 static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_ECHOPGM(".    ");
-  print_signed_float(PSTR("c"), z_pt[CEN]);
+  print_signed_float(F("c"), z_pt[CEN]);
   if (tower_points) {
-    print_signed_float(PSTR(" x"), z_pt[__A]);
-    print_signed_float(PSTR(" y"), z_pt[__B]);
-    print_signed_float(PSTR(" z"), z_pt[__C]);
+    print_signed_float(F(" x"), z_pt[__A]);
+    print_signed_float(F(" y"), z_pt[__B]);
+    print_signed_float(F(" z"), z_pt[__C]);
   }
   if (tower_points && opposite_points) {
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_ECHO_SP(13);
   }
   if (opposite_points) {
-    print_signed_float(PSTR("yz"), z_pt[_BC]);
-    print_signed_float(PSTR("zx"), z_pt[_CA]);
-    print_signed_float(PSTR("xy"), z_pt[_AB]);
+    print_signed_float(F("yz"), z_pt[_BC]);
+    print_signed_float(F("zx"), z_pt[_CA]);
+    print_signed_float(F("xy"), z_pt[_AB]);
   }
   SERIAL_EOL();
 }
 
 /**
  *  - Calculate the standard deviation from the zero plane
  */
 static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool _1p_cal, const bool _4p_cal, const bool _4p_opp) {
   if (!_0p_cal) {
     float S2 = sq(z_pt[CEN]);
@@ -646,27 +644,27 @@ void GcodeSuite::G33() {
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
-      PGM_P const enddryrun = PSTR("End DRY-RUN");
-      SERIAL_ECHOPGM_P(enddryrun);
+      FSTR_P const enddryrun = F("End DRY-RUN");
+      SERIAL_ECHOF(enddryrun);
       SERIAL_ECHO_SP(35);
       SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
 
       char mess[21];
-      strcpy_P(mess, enddryrun);
+      strcpy_P(mess, FTOP(enddryrun));
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    🎨 Apply F() to status message

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 8867c168d2..39494cde24 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -470,25 +470,25 @@ void GcodeSuite::G33() {
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   // Report settings
-  PGM_P const checkingac = PSTR("Checking... AC");
-  SERIAL_ECHOPGM_P(checkingac);
+  FSTR_P const checkingac = F("Checking... AC");
+  SERIAL_ECHOF(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
-  ui.set_status_P(checkingac);
+  ui.set_status(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0f };

commit 37c488fda1176e9e50531d0ea7e9d66c74cef2d4
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Mon Sep 13 02:35:37 2021 +0200

    🚸 G33 R and O options (#22707)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 95a862b5f7..8867c168d2 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -62,20 +62,22 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 #if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
+float dcr;
+
 void ac_home() {
   endstops.enable(true);
   TERN_(SENSORLESS_HOMING, probe.set_homing_current(true));
   home_delta();
   TERN_(SENSORLESS_HOMING, probe.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
@@ -168,33 +170,33 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
       }
       return LROUND(SQRT(S2 / N) * 1000.0f) / 1000.0f + 0.00001f;
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
-static float calibration_probe(const xy_pos_t &xy, const bool stow) {
+static float calibration_probe(const xy_pos_t &xy, const bool stow, const bool probe_at_offset) {
   #if HAS_BED_PROBE
-    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true, false);
+    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true, probe_at_offset);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
-static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
+static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each, const bool probe_at_offset) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
@@ -202,36 +204,34 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_center         = probe_points >= 5 && probe_points <= 7,
              _7p_9_center         = probe_points >= 8;
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
-    const float dcr = delta_calibration_radius();
-
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       const xy_pos_t center{0};
-      z_pt[CEN] += calibration_probe(center, stow_after_each);
+      z_pt[CEN] += calibration_probe(center, stow_after_each, probe_at_offset);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = dcr * 0.1;
         const xy_pos_t vec = { cos(a), sin(a) };
-        z_pt[CEN] += calibration_probe(vec * r, stow_after_each);
+        z_pt[CEN] += calibration_probe(vec * r, stow_after_each, probe_at_offset);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0f : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0f : //  9r * 6 + 10c = 64
@@ -242,21 +242,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = dcr * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
           const xy_pos_t vec = { cos(a), sin(a) };
-          const float z_temp = calibration_probe(vec * r, stow_after_each);
+          const float z_temp = calibration_probe(vec * r, stow_after_each, probe_at_offset);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
@@ -269,32 +269,31 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
 
 /**
  * kinematics routines and auto tune matrix scaling parameters:
  * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
  *  - formulae for approximative forward kinematics in the end-stop displacement matrix
  *  - definition of the matrix scaling parameters
  */
 static void reverse_kinematics_probe_points(float z_pt[NPP + 1], abc_float_t mm_at_pt_axis[NPP + 1]) {
   xyz_pos_t pos{0};
 
-  const float dcr = delta_calibration_radius();
   LOOP_CAL_ALL(rad) {
     const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                 r = (rad == CEN ? 0.0f : dcr);
     pos.set(cos(a) * r, sin(a) * r, z_pt[rad]);
     inverse_kinematics(pos);
     mm_at_pt_axis[rad] = delta;
   }
 }
 
 static void forward_kinematics_probe_points(abc_float_t mm_at_pt_axis[NPP + 1], float z_pt[NPP + 1]) {
-  const float r_quot = delta_calibration_radius() / delta_radius;
+  const float r_quot = dcr / delta_radius;
 
   #define ZPP(N,I,A) (((1.0f + r_quot * (N)) / 3.0f) * mm_at_pt_axis[I].A)
   #define Z00(I, A) ZPP( 0, I, A)
   #define Zp1(I, A) ZPP(+1, I, A)
   #define Zm1(I, A) ZPP(-1, I, A)
   #define Zp2(I, A) ZPP(+2, I, A)
   #define Zm2(I, A) ZPP(-2, I, A)
 
   z_pt[CEN] = Z00(CEN, a) + Z00(CEN, b) + Z00(CEN, c);
   z_pt[__A] = Zp2(__A, a) + Zm1(__A, b) + Zm1(__A, c);
@@ -321,21 +320,21 @@ static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], abc_float_t d
 
   LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
   z_pt[CEN] = z_center;
 
   delta_radius -= delta_r;
   delta_tower_angle_trim -= delta_t;
   recalc_delta_settings();
 }
 
 static float auto_tune_h() {
-  const float r_quot = delta_calibration_radius() / delta_radius;
+  const float r_quot = dcr / delta_radius;
   return RECIPROCAL(r_quot / (2.0f / 3.0f));  // (2/3)/CR
 }
 
 static float auto_tune_r() {
   constexpr float diff = 0.01f, delta_r = diff;
   float r_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
   calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
   r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0f;
@@ -366,51 +365,75 @@ static float auto_tune_a() {
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *      P0       Normalizes calibration.
  *      P1       Calibrates height only with center probe.
  *      P2       Probe center and towers. Calibrate height, endstops and delta radius.
  *      P3       Probe all positions: center, towers and opposite towers. Calibrate all.
  *      P4-P10   Probe all positions at different intermediate locations and average them.
  *
+ *   Rn.nn  override default calibration Radius
+ *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and take the best result
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  *
+ *   O   Probe at offset points (this is wrong but it seems to work)
+ *
  * With SENSORLESS_PROBING:
  *   Use these flags to calibrate stall sensitivity: (e.g., `G33 P1 Y Z` to calibrate X only.)
  *   X   Don't activate stallguard on X.
  *   Y   Don't activate stallguard on Y.
  *   Z   Don't activate stallguard on Z.
  */
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
-  const bool towers_set = !parser.seen_test('T');
+  const bool probe_at_offset = TERN0(HAS_PROBE_XY_OFFSET, parser.boolval('O')),
+                  towers_set = !parser.seen_test('T');
+
+  float max_dcr = dcr = DELTA_PRINTABLE_RADIUS;
+  #if HAS_PROBE_XY_OFFSET
+    // For offset probes the calibration radius is set to a safe but non-optimal value
+    dcr -= HYPOT(probe.offset_xy.x, probe.offset_xy.y);
+    if (probe_at_offset) {
+      // With probe positions both probe and nozzle need to be within the printable area
+      max_dcr = dcr;
+    }
+    // else with nozzle positions there is a risk of the probe being outside the bed
+    // but as long the nozzle stays within the printable area there is no risk of
+    // the effector crashing into the towers.
+  #endif
+
+  if (parser.seenval('R')) dcr = parser.value_float();
+  if (!WITHIN(dcr, 0, max_dcr)) {
+    SERIAL_ECHOLNPGM("?calibration (R)adius implausible.");
+    return;
+  }
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
@@ -446,32 +469,20 @@ void GcodeSuite::G33() {
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
-  const float dcr = delta_calibration_radius();
-
-  if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
-    LOOP_CAL_RAD(axis) {
-      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1));
-      if (!position_is_reachable(cos(a) * dcr, sin(a) * dcr)) {
-        SERIAL_ECHOLNPGM("?Bed calibration radius implausible.");
-        return;
-      }
-    }
-  }
-
   // Report settings
   PGM_P const checkingac = PSTR("Checking... AC");
   SERIAL_ECHOPGM_P(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
@@ -480,21 +491,21 @@ void GcodeSuite::G33() {
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0f };
 
     test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
-    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each)) {
+    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each, probe_at_offset)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
       return ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
@@ -519,25 +530,25 @@ void GcodeSuite::G33() {
        *  - matrices for 4 and 7 point calibration
        */
       #define ZP(N,I) ((N) * z_at_pt[I] / 4.0f) // 4.0 = divider to normalize to integers
       #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
       #define Z0(I) ZP(0, I)
 
       // calculate factors
-      if (_7p_9_center) calibration_radius_factor = 0.9f;
+      if (_7p_9_center) dcr *= 0.9f;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
-      calibration_radius_factor = 1.0f;
+      dcr /= 0.9f;
 
       switch (probe_points) {
         case 0:
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
           LOOP_LINEAR_AXES(axis) e_delta[axis] = +Z4(CEN);
           break;

commit 08e581d5d7c6cfcedf400862fcfcd146c6ce837f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 15:41:42 2021 -0500

    🎨 Apply more HAS_DELTA_SENSORLESS_PROBING

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 597801cf52..95a862b5f7 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -418,21 +418,21 @@ void GcodeSuite::G33() {
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen_test('E');
 
-  #if ENABLED(SENSORLESS_PROBING)
+  #if HAS_DELTA_SENSORLESS_PROBING
     probe.test_sensitivity.x = !parser.seen_test('X');
     TERN_(HAS_Y_AXIS, probe.test_sensitivity.y = !parser.seen_test('Y'));
     TERN_(HAS_Z_AXIS, probe.test_sensitivity.z = !parser.seen_test('Z'));
   #endif
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index a897a10115..597801cf52 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -100,39 +100,39 @@ void print_signed_float(PGM_P const prefix, const_float_t f) {
   SERIAL_ECHOPGM_P(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
-  SERIAL_ECHOPAIR(".Height:", delta_height);
+  SERIAL_ECHOPGM(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(PSTR("Ex"), delta_endstop_adj.a);
     print_signed_float(PSTR("Ey"), delta_endstop_adj.b);
     print_signed_float(PSTR("Ez"), delta_endstop_adj.c);
   }
   if (end_stops && tower_angles) {
-    SERIAL_ECHOPAIR("  Radius:", delta_radius);
+    SERIAL_ECHOPGM("  Radius:", delta_radius);
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_ECHO_SP(13);
   }
   if (tower_angles) {
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim.a);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim.b);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim.c);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
-    SERIAL_ECHOPAIR("  Radius:", delta_radius);
+    SERIAL_ECHOPGM("  Radius:", delta_radius);
   }
   SERIAL_EOL();
 }
 
 /**
  *  - Print the probe results
  */
 static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_ECHOPGM(".    ");
   print_signed_float(PSTR("c"), z_pt[CEN]);

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ⚡️ Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 0737c91668..a897a10115 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -64,21 +64,23 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 #if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
+  TERN_(SENSORLESS_HOMING, probe.set_homing_current(true));
   home_delta();
+  TERN_(SENSORLESS_HOMING, probe.set_homing_current(false));
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
@@ -377,20 +379,26 @@ static float auto_tune_a() {
  *
  *   Fn  Force to run at least n iterations and take the best result
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
+ *
+ * With SENSORLESS_PROBING:
+ *   Use these flags to calibrate stall sensitivity: (e.g., `G33 P1 Y Z` to calibrate X only.)
+ *   X   Don't activate stallguard on X.
+ *   Y   Don't activate stallguard on Y.
+ *   Z   Don't activate stallguard on Z.
  */
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
@@ -410,20 +418,26 @@ void GcodeSuite::G33() {
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen_test('E');
 
+  #if ENABLED(SENSORLESS_PROBING)
+    probe.test_sensitivity.x = !parser.seen_test('X');
+    TERN_(HAS_Y_AXIS, probe.test_sensitivity.y = !parser.seen_test('Y'));
+    TERN_(HAS_Z_AXIS, probe.test_sensitivity.z = !parser.seen_test('Z'));
+  #endif
+
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3 && towers_set;
   int8_t iterations = 0;
@@ -580,21 +594,21 @@ void GcodeSuite::G33() {
       // adjust delta_height and endstops by the max amount
       const float z_temp = _MAX(delta_endstop_adj.a, delta_endstop_adj.b, delta_endstop_adj.c);
       delta_height -= z_temp;
       LOOP_LINEAR_AXES(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
-    if (verbose_level == 3)
+    if (verbose_level == 3 || verbose_level == 0)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) { // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) { // end iterations
         SERIAL_ECHOPGM("Calibration OK");
         SERIAL_ECHO_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_ECHOPGM("rolling back.");
           else

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    🎨 Check flags without ENABLED

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 14ac53aeba..0737c91668 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -56,21 +56,21 @@ enum CalEnum : char {                        // the 7 main calibration points -
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
-#if ENABLED(HAS_MULTI_HOTEND)
+#if HAS_MULTI_HOTEND
   const uint8_t old_tool_index = active_extruder;
 #endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
   home_delta();
   endstops.not_homing();
 }

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ♻️ Refactor axis counts and loops

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index a8de519335..14ac53aeba 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -340,21 +340,21 @@ static float auto_tune_r() {
   r_fac = diff / r_fac / 3.0f; // 1/(3*delta_Z)
   return r_fac;
 }
 
 static float auto_tune_a() {
   constexpr float diff = 0.01f, delta_r = 0.0f;
   float a_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
   delta_t.reset();
-  LOOP_XYZ(axis) {
+  LOOP_LINEAR_AXES(axis) {
     delta_t[axis] = diff;
     calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
     delta_t[axis] = 0;
     a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0f;
     a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0f;
   }
   a_fac = diff / a_fac / 3.0f; // 1/(3*delta_Z)
   return a_fac;
 }
 
@@ -518,21 +518,21 @@ void GcodeSuite::G33() {
       a_factor = auto_tune_a();
       calibration_radius_factor = 1.0f;
 
       switch (probe_points) {
         case 0:
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
-          LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
+          LOOP_LINEAR_AXES(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:
           if (towers_set) { // see 4 point calibration (towers) matrix
             e_delta.set((+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN),
                         (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN),
                         (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN));
             r_delta   = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
           }
           else { // see 4 point calibration (opposites) matrix
@@ -566,28 +566,28 @@ void GcodeSuite::G33() {
       delta_radius = r_old;
       delta_height = h_old;
       delta_tower_angle_trim = a_old;
     }
 
     if (verbose_level != 0) {                                    // !dry run
 
       // Normalize angles to least-squares
       if (_angle_results) {
         float a_sum = 0.0f;
-        LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
-        LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
+        LOOP_LINEAR_AXES(axis) a_sum += delta_tower_angle_trim[axis];
+        LOOP_LINEAR_AXES(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = _MAX(delta_endstop_adj.a, delta_endstop_adj.b, delta_endstop_adj.c);
       delta_height -= z_temp;
-      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
+      LOOP_LINEAR_AXES(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) { // !dry run

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index d60099a330..a8de519335 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -388,41 +388,41 @@ static float auto_tune_a() {
 void GcodeSuite::G33() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
-  const bool towers_set = !parser.seen('T');
+  const bool towers_set = !parser.seen_test('T');
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
-  const bool stow_after_each = parser.seen('E');
+  const bool stow_after_each = parser.seen_test('E');
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3 && towers_set;

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index db1d456d70..d60099a330 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -205,32 +205,32 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
     const float dcr = delta_calibration_radius();
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       const xy_pos_t center{0};
       z_pt[CEN] += calibration_probe(center, stow_after_each);
-      if (ISNAN(z_pt[CEN])) return false;
+      if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = dcr * 0.1;
         const xy_pos_t vec = { cos(a), sin(a) };
         z_pt[CEN] += calibration_probe(vec * r, stow_after_each);
-        if (ISNAN(z_pt[CEN])) return false;
+        if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0f : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0f : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0f : //  7r * 6 +  7c = 49
@@ -241,21 +241,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = dcr * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
           const xy_pos_t vec = { cos(a), sin(a) };
           const float z_temp = calibration_probe(vec * r, stow_after_each);
-          if (ISNAN(z_temp)) return false;
+          if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
 

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 0bcab206af..db1d456d70 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -380,20 +380,22 @@ static float auto_tune_a() {
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_PROBE));
+
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
   const bool towers_set = !parser.seen('T');
 
   const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
@@ -638,13 +640,15 @@ void GcodeSuite::G33() {
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
+
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 1b8eb889c6..0bcab206af 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -205,32 +205,32 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
     const float dcr = delta_calibration_radius();
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       const xy_pos_t center{0};
       z_pt[CEN] += calibration_probe(center, stow_after_each);
-      if (isnan(z_pt[CEN])) return false;
+      if (ISNAN(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = dcr * 0.1;
         const xy_pos_t vec = { cos(a), sin(a) };
         z_pt[CEN] += calibration_probe(vec * r, stow_after_each);
-        if (isnan(z_pt[CEN])) return false;
+        if (ISNAN(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0f : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0f : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0f : //  7r * 6 +  7c = 49
@@ -241,21 +241,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = dcr * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
           const xy_pos_t vec = { cos(a), sin(a) };
           const float z_temp = calibration_probe(vec * r, stow_after_each);
-          if (isnan(z_temp)) return false;
+          if (ISNAN(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 902711397d..1b8eb889c6 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -86,21 +86,21 @@ void ac_setup(const bool reset_bed) {
   #endif
 }
 
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
 }
 
-void print_signed_float(PGM_P const prefix, const float &f) {
+void print_signed_float(PGM_P const prefix, const_float_t f) {
   SERIAL_ECHOPGM("  ");
   SERIAL_ECHOPGM_P(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 5530bc7089..902711397d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -56,21 +56,23 @@ enum CalEnum : char {                        // the 7 main calibration points -
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
-TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
+#if ENABLED(HAS_MULTI_HOTEND)
+  const uint8_t old_tool_index = active_extruder;
+#endif
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
   home_delta();
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 77cc45771c..5530bc7089 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -86,21 +86,21 @@ void ac_setup(const bool reset_bed) {
 
 void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
   TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
   TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_ECHOPGM("  ");
-  serialprintPGM(prefix);
+  SERIAL_ECHOPGM_P(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPAIR(".Height:", delta_height);
@@ -442,21 +442,21 @@ void GcodeSuite::G33() {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1));
       if (!position_is_reachable(cos(a) * dcr, sin(a) * dcr)) {
         SERIAL_ECHOLNPGM("?Bed calibration radius implausible.");
         return;
       }
     }
   }
 
   // Report settings
   PGM_P const checkingac = PSTR("Checking... AC");
-  serialprintPGM(checkingac);
+  SERIAL_ECHOPGM_P(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
@@ -618,21 +618,21 @@ void GcodeSuite::G33() {
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       PGM_P const enddryrun = PSTR("End DRY-RUN");
-      serialprintPGM(enddryrun);
+      SERIAL_ECHOPGM_P(enddryrun);
       SERIAL_ECHO_SP(35);
       SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 53af04d528..77cc45771c 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -22,21 +22,21 @@
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DELTA_AUTO_CALIBRATION)
 
 #include "../gcode.h"
 #include "../../module/delta.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
-#include "../../lcd/ultralcd.h"
+#include "../../lcd/marlinui.h"
 
 #if HAS_BED_PROBE
   #include "../../module/probe.h"
 #endif
 
 #if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 58afb67402..53af04d528 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DELTA_AUTO_CALIBRATION)
 
 #include "../gcode.h"
 #include "../../module/delta.h"
 #include "../../module/motion.h"

commit a4c981469e317b30ff21fba109e1b126e5dcafcf
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Wed May 6 10:04:04 2020 +0530

    Extended reporting options (#16741)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index d7112de506..58afb67402 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -441,21 +441,21 @@ void GcodeSuite::G33() {
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1));
       if (!position_is_reachable(cos(a) * dcr, sin(a) * dcr)) {
         SERIAL_ECHOLNPGM("?Bed calibration radius implausible.");
         return;
       }
     }
   }
 
   // Report settings
-  PGM_P checkingac = PSTR("Checking... AC");
+  PGM_P const checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
@@ -617,21 +617,21 @@ void GcodeSuite::G33() {
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
-      PGM_P enddryrun = PSTR("End DRY-RUN");
+      PGM_P const enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_ECHO_SP(35);
       SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 6f0f8a5562..d7112de506 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -56,63 +56,46 @@ enum CalEnum : char {                        // the 7 main calibration points -
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
-#if HOTENDS > 1
-  const uint8_t old_tool_index = active_extruder;
-  #define AC_CLEANUP() ac_cleanup(old_tool_index)
-#else
-  #define AC_CLEANUP() ac_cleanup()
-#endif
+TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
 float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
   home_delta();
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
-  #if HOTENDS > 1
-    tool_change(0, true);
-  #endif
+  TERN_(HAS_MULTI_HOTEND, tool_change(0, true));
 
   planner.synchronize();
   remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
-void ac_cleanup(
-  #if HOTENDS > 1
-    const uint8_t old_tool_index
-  #endif
-) {
-  #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
-    do_blocking_move_to_z(delta_clip_start_height);
-  #endif
-  #if HAS_BED_PROBE
-    probe.stow();
-  #endif
+void ac_cleanup(TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index)) {
+  TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
+  TERN_(HAS_BED_PROBE, probe.stow());
   restore_feedrate_and_scaling();
-  #if HOTENDS > 1
-    tool_change(old_tool_index, true);
-  #endif
+  TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, true));
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_ECHOPGM("  ");
   serialprintPGM(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
@@ -481,21 +464,21 @@ void GcodeSuite::G33() {
 
     float z_at_pt[NPP + 1] = { 0.0f };
 
     test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
     if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
-      return AC_CLEANUP();
+      return ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
         test_precision = 0.0f; // forced end
       #endif
@@ -652,14 +635,14 @@ void GcodeSuite::G33() {
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
-  AC_CLEANUP();
+  ac_cleanup(TERN_(HAS_MULTI_HOTEND, old_tool_index));
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ac2cdf7d4d..6f0f8a5562 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -28,21 +28,21 @@
 #include "../../module/delta.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 #include "../../lcd/ultralcd.h"
 
 #if HAS_BED_PROBE
   #include "../../module/probe.h"
 #endif
 
-#if HOTENDS > 1
+#if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
                   _4P_STEP = _7P_STEP * 2,   // 4-point step
                   NPP      = _7P_STEP * 6;   // number of calibration points on the radius

commit cf597e2bb1de6acab4753dde82221f5cfd8eb1c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 05:33:48 2020 -0600

    Allow weird probe values in G33

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index acf668f940..ac2cdf7d4d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -183,21 +183,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow) {
   #if HAS_BED_PROBE
-    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
+    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true, false);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index bfcf9153ea..acf668f940 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 2ce45359d3..bfcf9153ea 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -93,21 +93,21 @@ void ac_setup(const bool reset_bed) {
 
 void ac_cleanup(
   #if HOTENDS > 1
     const uint8_t old_tool_index
   #endif
 ) {
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   #if HAS_BED_PROBE
-    STOW_PROBE();
+    probe.stow();
   #endif
   restore_feedrate_and_scaling();
   #if HOTENDS > 1
     tool_change(old_tool_index, true);
   #endif
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_ECHOPGM("  ");
   serialprintPGM(prefix);
@@ -183,21 +183,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
+    return probe.probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {

commit 50889c0f94778c378357bcc4d4a966fa869bc5c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:23 2020 -0600

    Move L64XX index_to_axis to progmem (#16697)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 1931d226af..2ce45359d3 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -432,21 +432,20 @@ void GcodeSuite::G33() {
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3 && towers_set;
-  static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0f : 0.0f), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
@@ -618,22 +617,21 @@ void GcodeSuite::G33() {
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
-        serialprintPGM(save_message);
-        SERIAL_EOL();
+        SERIAL_ECHOLNPGM("Save with M500 and/or copy to Configuration.h");
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (unsigned int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);

commit b904ba0f291cdcb9759464f064f85ba066b778ce
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 21 01:26:00 2019 -0800

    Improve Delta probing / calibration (#15887)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index f961302fb5..1931d226af 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -183,21 +183,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const xy_pos_t &xy, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
   #else
     UNUSED(stow);
     return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
@@ -215,32 +215,34 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_center         = probe_points >= 5 && probe_points <= 7,
              _7p_9_center         = probe_points >= 8;
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
+    const float dcr = delta_calibration_radius();
+
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       const xy_pos_t center{0};
       z_pt[CEN] += calibration_probe(center, stow_after_each);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
-                    r = delta_calibration_radius * 0.1;
+                    r = dcr * 0.1;
         const xy_pos_t vec = { cos(a), sin(a) };
         z_pt[CEN] += calibration_probe(vec * r, stow_after_each);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
@@ -250,21 +252,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _7p_4_intermediates  ? _7P_STEP /  5.0f : //  5r * 6 +  6c = 36
                              _7p_2_intermediates  ? _7P_STEP /  3.0f : //  3r * 6 +  7c = 25
                              _7p_1_intermediates  ? _7P_STEP /  2.0f : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
-                      r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
+                      r = dcr * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
           const xy_pos_t vec = { cos(a), sin(a) };
           const float z_temp = calibration_probe(vec * r, stow_after_each);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
@@ -280,31 +282,32 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
 
 /**
  * kinematics routines and auto tune matrix scaling parameters:
  * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
  *  - formulae for approximative forward kinematics in the end-stop displacement matrix
  *  - definition of the matrix scaling parameters
  */
 static void reverse_kinematics_probe_points(float z_pt[NPP + 1], abc_float_t mm_at_pt_axis[NPP + 1]) {
   xyz_pos_t pos{0};
 
+  const float dcr = delta_calibration_radius();
   LOOP_CAL_ALL(rad) {
     const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
-                r = (rad == CEN ? 0.0f : delta_calibration_radius);
+                r = (rad == CEN ? 0.0f : dcr);
     pos.set(cos(a) * r, sin(a) * r, z_pt[rad]);
     inverse_kinematics(pos);
     mm_at_pt_axis[rad] = delta;
   }
 }
 
 static void forward_kinematics_probe_points(abc_float_t mm_at_pt_axis[NPP + 1], float z_pt[NPP + 1]) {
-  const float r_quot = delta_calibration_radius / delta_radius;
+  const float r_quot = delta_calibration_radius() / delta_radius;
 
   #define ZPP(N,I,A) (((1.0f + r_quot * (N)) / 3.0f) * mm_at_pt_axis[I].A)
   #define Z00(I, A) ZPP( 0, I, A)
   #define Zp1(I, A) ZPP(+1, I, A)
   #define Zm1(I, A) ZPP(-1, I, A)
   #define Zp2(I, A) ZPP(+2, I, A)
   #define Zm2(I, A) ZPP(-2, I, A)
 
   z_pt[CEN] = Z00(CEN, a) + Z00(CEN, b) + Z00(CEN, c);
   z_pt[__A] = Zp2(__A, a) + Zm1(__A, b) + Zm1(__A, c);
@@ -331,21 +334,21 @@ static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], abc_float_t d
 
   LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
   z_pt[CEN] = z_center;
 
   delta_radius -= delta_r;
   delta_tower_angle_trim -= delta_t;
   recalc_delta_settings();
 }
 
 static float auto_tune_h() {
-  const float r_quot = delta_calibration_radius / delta_radius;
+  const float r_quot = delta_calibration_radius() / delta_radius;
   return RECIPROCAL(r_quot / (2.0f / 3.0f));  // (2/3)/CR
 }
 
 static float auto_tune_r() {
   constexpr float diff = 0.01f, delta_r = diff;
   float r_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
   abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
 
   calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
   r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0f;
@@ -443,26 +446,27 @@ void GcodeSuite::G33() {
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor, r_factor, a_factor,
         r_old = delta_radius,
         h_old = delta_height;
 
   abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
+  const float dcr = delta_calibration_radius();
+
   if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
-      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
-                  r = delta_calibration_radius;
-      if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
-        SERIAL_ECHOLNPGM("?(M665 B)ed radius implausible.");
+      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1));
+      if (!position_is_reachable(cos(a) * dcr, sin(a) * dcr)) {
+        SERIAL_ECHOLNPGM("?Bed calibration radius implausible.");
         return;
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();
@@ -515,26 +519,25 @@ void GcodeSuite::G33() {
        *  - matrices for 4 and 7 point calibration
        */
       #define ZP(N,I) ((N) * z_at_pt[I] / 4.0f) // 4.0 = divider to normalize to integers
       #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
       #define Z0(I) ZP(0, I)
 
       // calculate factors
-      const float cr_old = delta_calibration_radius;
-      if (_7p_9_center) delta_calibration_radius *= 0.9f;
+      if (_7p_9_center) calibration_radius_factor = 0.9f;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
-      delta_calibration_radius = cr_old;
+      calibration_radius_factor = 1.0f;
 
       switch (probe_points) {
         case 0:
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
           break;

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 1e3e84a1e4..f961302fb5 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -63,21 +63,21 @@ enum CalEnum : char {                        // the 7 main calibration points -
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 #if HOTENDS > 1
   const uint8_t old_tool_index = active_extruder;
   #define AC_CLEANUP() ac_cleanup(old_tool_index)
 #else
   #define AC_CLEANUP() ac_cleanup()
 #endif
 
-float lcd_probe_pt(const float &rx, const float &ry);
+float lcd_probe_pt(const xy_pos_t &xy);
 
 void ac_home() {
   endstops.enable(true);
   home_delta();
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   #if HOTENDS > 1
     tool_change(0, true);
@@ -115,34 +115,34 @@ void print_signed_float(PGM_P const prefix, const float &f) {
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_ECHOPAIR(".Height:", delta_height);
   if (end_stops) {
-    print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
-    print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
-    print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
+    print_signed_float(PSTR("Ex"), delta_endstop_adj.a);
+    print_signed_float(PSTR("Ey"), delta_endstop_adj.b);
+    print_signed_float(PSTR("Ez"), delta_endstop_adj.c);
   }
   if (end_stops && tower_angles) {
     SERIAL_ECHOPAIR("  Radius:", delta_radius);
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_ECHO_SP(13);
   }
   if (tower_angles) {
-    print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
-    print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
-    print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
+    print_signed_float(PSTR("Tx"), delta_tower_angle_trim.a);
+    print_signed_float(PSTR("Ty"), delta_tower_angle_trim.b);
+    print_signed_float(PSTR("Tz"), delta_tower_angle_trim.c);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
     SERIAL_ECHOPAIR("  Radius:", delta_radius);
   }
   SERIAL_EOL();
 }
 
 /**
  *  - Print the probe results
  */
@@ -181,26 +181,26 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
       }
       return LROUND(SQRT(S2 / N) * 1000.0f) / 1000.0f + 0.00001f;
     }
   }
   return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
-static float calibration_probe(const float &nx, const float &ny, const bool stow) {
+static float calibration_probe(const xy_pos_t &xy, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_at_point(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_at_point(xy, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
-    return lcd_probe_pt(nx, ny);
+    return lcd_probe_pt(xy);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
@@ -216,31 +216,33 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_center         = probe_points >= 5 && probe_points <= 7,
              _7p_9_center         = probe_points >= 8;
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
-      z_pt[CEN] += calibration_probe(0, 0, stow_after_each);
+      const xy_pos_t center{0};
+      z_pt[CEN] += calibration_probe(center, stow_after_each);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = delta_calibration_radius * 0.1;
-        z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
+        const xy_pos_t vec = { cos(a), sin(a) };
+        z_pt[CEN] += calibration_probe(vec * r, stow_after_each);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0f : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0f : //  9r * 6 + 10c = 64
@@ -250,21 +252,22 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _7p_1_intermediates  ? _7P_STEP /  2.0f : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
-          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
+          const xy_pos_t vec = { cos(a), sin(a) };
+          const float z_temp = calibration_probe(vec * r, stow_after_each);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
@@ -274,109 +277,95 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
   }
   return true;
 }
 
 /**
  * kinematics routines and auto tune matrix scaling parameters:
  * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
  *  - formulae for approximative forward kinematics in the end-stop displacement matrix
  *  - definition of the matrix scaling parameters
  */
-static void reverse_kinematics_probe_points(float z_pt[NPP + 1], float mm_at_pt_axis[NPP + 1][ABC]) {
-  float pos[XYZ] = { 0.0 };
+static void reverse_kinematics_probe_points(float z_pt[NPP + 1], abc_float_t mm_at_pt_axis[NPP + 1]) {
+  xyz_pos_t pos{0};
 
   LOOP_CAL_ALL(rad) {
     const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                 r = (rad == CEN ? 0.0f : delta_calibration_radius);
-    pos[X_AXIS] = cos(a) * r;
-    pos[Y_AXIS] = sin(a) * r;
-    pos[Z_AXIS] = z_pt[rad];
+    pos.set(cos(a) * r, sin(a) * r, z_pt[rad]);
     inverse_kinematics(pos);
-    LOOP_XYZ(axis) mm_at_pt_axis[rad][axis] = delta[axis];
+    mm_at_pt_axis[rad] = delta;
   }
 }
 
-static void forward_kinematics_probe_points(float mm_at_pt_axis[NPP + 1][ABC], float z_pt[NPP + 1]) {
+static void forward_kinematics_probe_points(abc_float_t mm_at_pt_axis[NPP + 1], float z_pt[NPP + 1]) {
   const float r_quot = delta_calibration_radius / delta_radius;
 
-  #define ZPP(N,I,A) ((1 / 3.0f + r_quot * (N) / 3.0f ) * mm_at_pt_axis[I][A])
+  #define ZPP(N,I,A) (((1.0f + r_quot * (N)) / 3.0f) * mm_at_pt_axis[I].A)
   #define Z00(I, A) ZPP( 0, I, A)
   #define Zp1(I, A) ZPP(+1, I, A)
   #define Zm1(I, A) ZPP(-1, I, A)
   #define Zp2(I, A) ZPP(+2, I, A)
   #define Zm2(I, A) ZPP(-2, I, A)
 
-  z_pt[CEN] = Z00(CEN, A_AXIS) + Z00(CEN, B_AXIS) + Z00(CEN, C_AXIS);
-  z_pt[__A] = Zp2(__A, A_AXIS) + Zm1(__A, B_AXIS) + Zm1(__A, C_AXIS);
-  z_pt[__B] = Zm1(__B, A_AXIS) + Zp2(__B, B_AXIS) + Zm1(__B, C_AXIS);
-  z_pt[__C] = Zm1(__C, A_AXIS) + Zm1(__C, B_AXIS) + Zp2(__C, C_AXIS);
-  z_pt[_BC] = Zm2(_BC, A_AXIS) + Zp1(_BC, B_AXIS) + Zp1(_BC, C_AXIS);
-  z_pt[_CA] = Zp1(_CA, A_AXIS) + Zm2(_CA, B_AXIS) + Zp1(_CA, C_AXIS);
-  z_pt[_AB] = Zp1(_AB, A_AXIS) + Zp1(_AB, B_AXIS) + Zm2(_AB, C_AXIS);
+  z_pt[CEN] = Z00(CEN, a) + Z00(CEN, b) + Z00(CEN, c);
+  z_pt[__A] = Zp2(__A, a) + Zm1(__A, b) + Zm1(__A, c);
+  z_pt[__B] = Zm1(__B, a) + Zp2(__B, b) + Zm1(__B, c);
+  z_pt[__C] = Zm1(__C, a) + Zm1(__C, b) + Zp2(__C, c);
+  z_pt[_BC] = Zm2(_BC, a) + Zp1(_BC, b) + Zp1(_BC, c);
+  z_pt[_CA] = Zp1(_CA, a) + Zm2(_CA, b) + Zp1(_CA, c);
+  z_pt[_AB] = Zp1(_AB, a) + Zp1(_AB, b) + Zm2(_AB, c);
 }
 
-static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], float delta_e[ABC], float delta_r, float delta_t[ABC]) {
+static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], abc_float_t delta_e, const float delta_r, abc_float_t delta_t) {
   const float z_center = z_pt[CEN];
-  float diff_mm_at_pt_axis[NPP + 1][ABC],
-        new_mm_at_pt_axis[NPP + 1][ABC];
+  abc_float_t diff_mm_at_pt_axis[NPP + 1], new_mm_at_pt_axis[NPP + 1];
 
   reverse_kinematics_probe_points(z_pt, diff_mm_at_pt_axis);
 
   delta_radius += delta_r;
-  LOOP_XYZ(axis) delta_tower_angle_trim[axis] += delta_t[axis];
+  delta_tower_angle_trim += delta_t;
   recalc_delta_settings();
   reverse_kinematics_probe_points(z_pt, new_mm_at_pt_axis);
 
-  LOOP_XYZ(axis) LOOP_CAL_ALL(rad) diff_mm_at_pt_axis[rad][axis] -= new_mm_at_pt_axis[rad][axis] + delta_e[axis];
+  LOOP_CAL_ALL(rad) diff_mm_at_pt_axis[rad] -= new_mm_at_pt_axis[rad] + delta_e;
   forward_kinematics_probe_points(diff_mm_at_pt_axis, z_pt);
 
   LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
   z_pt[CEN] = z_center;
 
   delta_radius -= delta_r;
-  LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= delta_t[axis];
+  delta_tower_angle_trim -= delta_t;
   recalc_delta_settings();
 }
 
 static float auto_tune_h() {
   const float r_quot = delta_calibration_radius / delta_radius;
-  float h_fac = 0.0f;
-
-  h_fac = r_quot / (2.0f / 3.0f);
-  h_fac = 1.0f / h_fac; // (2/3)/CR
-  return h_fac;
+  return RECIPROCAL(r_quot / (2.0f / 3.0f));  // (2/3)/CR
 }
 
 static float auto_tune_r() {
-  const float diff = 0.01f;
-  float r_fac = 0.0f,
-        z_pt[NPP + 1] = { 0.0f },
-        delta_e[ABC] = { 0.0f },
-        delta_r = { 0.0f },
-        delta_t[ABC] = { 0.0f };
-
-  delta_r = diff;
+  constexpr float diff = 0.01f, delta_r = diff;
+  float r_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
+  abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
+
   calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
   r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0f;
   r_fac = diff / r_fac / 3.0f; // 1/(3*delta_Z)
   return r_fac;
 }
 
 static float auto_tune_a() {
-  const float diff = 0.01f;
-  float a_fac = 0.0f,
-        z_pt[NPP + 1] = { 0.0f },
-        delta_e[ABC] = { 0.0f },
-        delta_r = { 0.0f },
-        delta_t[ABC] = { 0.0f };
-
-  ZERO(delta_t);
+  constexpr float diff = 0.01f, delta_r = 0.0f;
+  float a_fac = 0.0f, z_pt[NPP + 1] = { 0.0f };
+  abc_float_t delta_e = { 0.0f }, delta_t = { 0.0f };
+
+  delta_t.reset();
   LOOP_XYZ(axis) {
     delta_t[axis] = diff;
     calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
     delta_t[axis] = 0;
     a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0f;
     a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0f;
   }
   a_fac = diff / a_fac / 3.0f; // 1/(3*delta_Z)
   return a_fac;
 }
@@ -446,35 +435,25 @@ void GcodeSuite::G33() {
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3 && towers_set;
   static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0f : 0.0f), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
-        h_factor,
-        r_factor,
-        a_factor,
-        e_old[ABC] = {
-          delta_endstop_adj[A_AXIS],
-          delta_endstop_adj[B_AXIS],
-          delta_endstop_adj[C_AXIS]
-        },
+        h_factor, r_factor, a_factor,
         r_old = delta_radius,
-        h_old = delta_height,
-        a_old[ABC] = {
-          delta_tower_angle_trim[A_AXIS],
-          delta_tower_angle_trim[B_AXIS],
-          delta_tower_angle_trim[C_AXIS]
-        };
+        h_old = delta_height;
+
+  abc_pos_t e_old = delta_endstop_adj, a_old = delta_tower_angle_trim;
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
         SERIAL_ECHOLNPGM("?(M665 B)ed radius implausible.");
         return;
@@ -513,29 +492,28 @@ void GcodeSuite::G33() {
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
         test_precision = 0.0f; // forced end
       #endif
 
       if (zero_std_dev < zero_std_dev_min) {
         // set roll-back point
-        COPY(e_old, delta_endstop_adj);
+        e_old = delta_endstop_adj;
         r_old = delta_radius;
         h_old = delta_height;
-        COPY(a_old, delta_tower_angle_trim);
+        a_old = delta_tower_angle_trim;
       }
 
-      float e_delta[ABC] = { 0.0f },
-            r_delta = 0.0f,
-            t_delta[ABC] = { 0.0f };
+      abc_float_t e_delta = { 0.0f }, t_delta = { 0.0f };
+      float r_delta = 0.0f;
 
       /**
        * convergence matrices:
        * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
        *  - definition of the matrix scaling parameters
        *  - matrices for 4 and 7 point calibration
        */
       #define ZP(N,I) ((N) * z_at_pt[I] / 4.0f) // 4.0 = divider to normalize to integers
       #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
@@ -556,69 +534,69 @@ void GcodeSuite::G33() {
           test_precision = 0.0f; // forced end
           break;
 
         case 1:
           test_precision = 0.0f; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:
           if (towers_set) { // see 4 point calibration (towers) matrix
-            e_delta[A_AXIS] = (+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN);
-            e_delta[B_AXIS] = (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN);
-            e_delta[C_AXIS] = (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN);
-            r_delta         = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
+            e_delta.set((+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN),
+                        (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN),
+                        (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN));
+            r_delta   = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
           }
           else { // see 4 point calibration (opposites) matrix
-            e_delta[A_AXIS] = (-Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor  +Z4(CEN);
-            e_delta[B_AXIS] = (+Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor  +Z4(CEN);
-            e_delta[C_AXIS] = (+Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor  +Z4(CEN);
-            r_delta         = (+Z4(_BC) +Z4(_CA) +Z4(_AB) -Z12(CEN)) * r_factor;
+            e_delta.set((-Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor  +Z4(CEN),
+                        (+Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor  +Z4(CEN),
+                        (+Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor  +Z4(CEN));
+            r_delta   = (+Z4(_BC) +Z4(_CA) +Z4(_AB) -Z12(CEN)) * r_factor;
           }
           break;
 
         default: // see 7 point calibration (towers & opposites) matrix
-          e_delta[A_AXIS] = (+Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor  +Z4(CEN);
-          e_delta[B_AXIS] = (-Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor  +Z4(CEN);
-          e_delta[C_AXIS] = (-Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor  +Z4(CEN);
-          r_delta         = (+Z2(__A) +Z2(__B) +Z2(__C) +Z2(_BC) +Z2(_CA) +Z2(_AB) -Z12(CEN)) * r_factor;
+          e_delta.set((+Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor  +Z4(CEN),
+                      (-Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor  +Z4(CEN),
+                      (-Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor  +Z4(CEN));
+          r_delta   = (+Z2(__A) +Z2(__B) +Z2(__C) +Z2(_BC) +Z2(_CA) +Z2(_AB) -Z12(CEN)) * r_factor;
 
           if (towers_set) { // see 7 point tower angle calibration (towers & opposites) matrix
-            t_delta[A_AXIS] = (+Z0(__A) -Z4(__B) +Z4(__C) +Z0(_BC) -Z4(_CA) +Z4(_AB) +Z0(CEN)) * a_factor;
-            t_delta[B_AXIS] = (+Z4(__A) +Z0(__B) -Z4(__C) +Z4(_BC) +Z0(_CA) -Z4(_AB) +Z0(CEN)) * a_factor;
-            t_delta[C_AXIS] = (-Z4(__A) +Z4(__B) +Z0(__C) -Z4(_BC) +Z4(_CA) +Z0(_AB) +Z0(CEN)) * a_factor;
+            t_delta.set((+Z0(__A) -Z4(__B) +Z4(__C) +Z0(_BC) -Z4(_CA) +Z4(_AB) +Z0(CEN)) * a_factor,
+                        (+Z4(__A) +Z0(__B) -Z4(__C) +Z4(_BC) +Z0(_CA) -Z4(_AB) +Z0(CEN)) * a_factor,
+                        (-Z4(__A) +Z4(__B) +Z0(__C) -Z4(_BC) +Z4(_CA) +Z0(_AB) +Z0(CEN)) * a_factor);
           }
           break;
       }
-      LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
+      delta_endstop_adj += e_delta;
       delta_radius += r_delta;
-      LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
+      delta_tower_angle_trim += t_delta;
     }
     else if (zero_std_dev >= test_precision) {
       // roll back
-      COPY(delta_endstop_adj, e_old);
+      delta_endstop_adj = e_old;
       delta_radius = r_old;
       delta_height = h_old;
-      COPY(delta_tower_angle_trim, a_old);
+      delta_tower_angle_trim = a_old;
     }
 
     if (verbose_level != 0) {                                    // !dry run
 
       // Normalize angles to least-squares
       if (_angle_results) {
         float a_sum = 0.0f;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
       }
 
       // adjust delta_height and endstops by the max amount
-      const float z_temp = _MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      const float z_temp = _MAX(delta_endstop_adj.a, delta_endstop_adj.b, delta_endstop_adj.c);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 8bbdba9bb7..1e3e84a1e4 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -77,39 +77,39 @@ void ac_home() {
   home_delta();
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   #if HOTENDS > 1
     tool_change(0, true);
   #endif
 
   planner.synchronize();
-  setup_for_endstop_or_probe_move();
+  remember_feedrate_scaling_off();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
 void ac_cleanup(
   #if HOTENDS > 1
     const uint8_t old_tool_index
   #endif
 ) {
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   #if HAS_BED_PROBE
     STOW_PROBE();
   #endif
-  clean_up_after_endstop_or_probe_move();
+  restore_feedrate_and_scaling();
   #if HOTENDS > 1
     tool_change(old_tool_index, true);
   #endif
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_ECHOPGM("  ");
   serialprintPGM(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');

commit b71a755a30ae658bfc9209693f0a19fc1695133d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 17 23:10:19 2019 -0500

    Add float suffix in G33

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 08045d8cb8..8bbdba9bb7 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -172,24 +172,24 @@ static void print_calibration_results(const float z_pt[NPP + 1], const bool towe
  */
 static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool _1p_cal, const bool _4p_cal, const bool _4p_opp) {
   if (!_0p_cal) {
     float S2 = sq(z_pt[CEN]);
     int16_t N = 1;
     if (!_1p_cal) { // std dev from zero plane
       LOOP_CAL_ACT(rad, _4p_cal, _4p_opp) {
         S2 += sq(z_pt[rad]);
         N++;
       }
-      return LROUND(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+      return LROUND(SQRT(S2 / N) * 1000.0f) / 1000.0f + 0.00001f;
     }
   }
-  return 0.00001;
+  return 0.00001f;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const float &nx, const float &ny, const bool stow) {
   #if HAS_BED_PROBE
     return probe_at_point(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
@@ -211,50 +211,50 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
              _7p_8_intermediates  = probe_points == 8,
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_center         = probe_points >= 5 && probe_points <= 7,
              _7p_9_center         = probe_points >= 8;
 
-  LOOP_CAL_ALL(rad) z_pt[rad] = 0.0;
+  LOOP_CAL_ALL(rad) z_pt[rad] = 0.0f;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       z_pt[CEN] += calibration_probe(0, 0, stow_after_each);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
-      const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0 : _7p_6_center ? float(_CA) : float(__C),
-                  steps  = _7p_9_center ? _4P_STEP / 3.0 : _7p_6_center ? _7P_STEP : _4P_STEP;
+      const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0f : _7p_6_center ? float(_CA) : float(__C),
+                  steps  = _7p_9_center ? _4P_STEP / 3.0f : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = delta_calibration_radius * 0.1;
         z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
-      const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
-                             _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
-                             _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
-                             _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
-                             _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
-                             _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
-                             _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
+      const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0f : // 15r * 6 + 10c = 100
+                             _7p_11_intermediates ? _7P_STEP / 12.0f : // 12r * 6 +  9c = 81
+                             _7p_8_intermediates  ? _7P_STEP /  9.0f : //  9r * 6 + 10c = 64
+                             _7p_6_intermediates  ? _7P_STEP /  7.0f : //  7r * 6 +  7c = 49
+                             _7p_4_intermediates  ? _7P_STEP /  5.0f : //  5r * 6 +  6c = 36
+                             _7p_2_intermediates  ? _7P_STEP /  3.0f : //  3r * 6 +  7c = 25
+                             _7p_1_intermediates  ? _7P_STEP /  2.0f : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
           const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
@@ -262,50 +262,50 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
 
-      do_blocking_move_to_xy(0.0, 0.0);
+      do_blocking_move_to_xy(0.0f, 0.0f);
     }
   }
   return true;
 }
 
 /**
  * kinematics routines and auto tune matrix scaling parameters:
  * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
  *  - formulae for approximative forward kinematics in the end-stop displacement matrix
  *  - definition of the matrix scaling parameters
  */
 static void reverse_kinematics_probe_points(float z_pt[NPP + 1], float mm_at_pt_axis[NPP + 1][ABC]) {
   float pos[XYZ] = { 0.0 };
 
   LOOP_CAL_ALL(rad) {
     const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
-                r = (rad == CEN ? 0.0 : delta_calibration_radius);
+                r = (rad == CEN ? 0.0f : delta_calibration_radius);
     pos[X_AXIS] = cos(a) * r;
     pos[Y_AXIS] = sin(a) * r;
     pos[Z_AXIS] = z_pt[rad];
     inverse_kinematics(pos);
     LOOP_XYZ(axis) mm_at_pt_axis[rad][axis] = delta[axis];
   }
 }
 
 static void forward_kinematics_probe_points(float mm_at_pt_axis[NPP + 1][ABC], float z_pt[NPP + 1]) {
   const float r_quot = delta_calibration_radius / delta_radius;
 
-  #define ZPP(N,I,A) ((1 / 3.0 + r_quot * (N) / 3.0 ) * mm_at_pt_axis[I][A])
+  #define ZPP(N,I,A) ((1 / 3.0f + r_quot * (N) / 3.0f ) * mm_at_pt_axis[I][A])
   #define Z00(I, A) ZPP( 0, I, A)
   #define Zp1(I, A) ZPP(+1, I, A)
   #define Zm1(I, A) ZPP(-1, I, A)
   #define Zp2(I, A) ZPP(+2, I, A)
   #define Zm2(I, A) ZPP(-2, I, A)
 
   z_pt[CEN] = Z00(CEN, A_AXIS) + Z00(CEN, B_AXIS) + Z00(CEN, C_AXIS);
   z_pt[__A] = Zp2(__A, A_AXIS) + Zm1(__A, B_AXIS) + Zm1(__A, C_AXIS);
   z_pt[__B] = Zm1(__B, A_AXIS) + Zp2(__B, B_AXIS) + Zm1(__B, C_AXIS);
   z_pt[__C] = Zm1(__C, A_AXIS) + Zm1(__C, B_AXIS) + Zp2(__C, C_AXIS);
@@ -332,59 +332,59 @@ static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], float delta_e
   LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
   z_pt[CEN] = z_center;
 
   delta_radius -= delta_r;
   LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= delta_t[axis];
   recalc_delta_settings();
 }
 
 static float auto_tune_h() {
   const float r_quot = delta_calibration_radius / delta_radius;
-  float h_fac = 0.0;
+  float h_fac = 0.0f;
 
-  h_fac = r_quot / (2.0 / 3.0);
+  h_fac = r_quot / (2.0f / 3.0f);
   h_fac = 1.0f / h_fac; // (2/3)/CR
   return h_fac;
 }
 
 static float auto_tune_r() {
-  const float diff = 0.01;
-  float r_fac = 0.0,
-        z_pt[NPP + 1] = { 0.0 },
-        delta_e[ABC] = {0.0},
-        delta_r = {0.0},
-        delta_t[ABC] = {0.0};
+  const float diff = 0.01f;
+  float r_fac = 0.0f,
+        z_pt[NPP + 1] = { 0.0f },
+        delta_e[ABC] = { 0.0f },
+        delta_r = { 0.0f },
+        delta_t[ABC] = { 0.0f };
 
   delta_r = diff;
   calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
-  r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0;
-  r_fac = diff / r_fac / 3.0; // 1/(3*delta_Z)
+  r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0f;
+  r_fac = diff / r_fac / 3.0f; // 1/(3*delta_Z)
   return r_fac;
 }
 
 static float auto_tune_a() {
-  const float diff = 0.01;
-  float a_fac = 0.0,
-        z_pt[NPP + 1] = { 0.0 },
-        delta_e[ABC] = {0.0},
-        delta_r = {0.0},
-        delta_t[ABC] = {0.0};
+  const float diff = 0.01f;
+  float a_fac = 0.0f,
+        z_pt[NPP + 1] = { 0.0f },
+        delta_e[ABC] = { 0.0f },
+        delta_r = { 0.0f },
+        delta_t[ABC] = { 0.0f };
 
   ZERO(delta_t);
   LOOP_XYZ(axis) {
     delta_t[axis] = diff;
     calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
     delta_t[axis] = 0;
-    a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0;
-    a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0;
+    a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0f;
+    a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0f;
   }
-  a_fac = diff / a_fac / 3.0; // 1/(3*delta_Z)
+  a_fac = diff / a_fac / 3.0f; // 1/(3*delta_Z)
   return a_fac;
 }
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, z_offset, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
@@ -411,21 +411,21 @@ static float auto_tune_a() {
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
   const bool towers_set = !parser.seen('T');
 
-  const float calibration_precision = parser.floatval('C', 0.0);
+  const float calibration_precision = parser.floatval('C', 0.0f);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
     return;
   }
@@ -443,21 +443,21 @@ void GcodeSuite::G33() {
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3 && towers_set;
   static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
-        zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
+        zero_std_dev = (verbose_level ? 999.0f : 0.0f), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor,
         r_factor,
         a_factor,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
@@ -490,81 +490,81 @@ void GcodeSuite::G33() {
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
-    float z_at_pt[NPP + 1] = { 0.0 };
+    float z_at_pt[NPP + 1] = { 0.0f };
 
-    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+    test_precision = zero_std_dev_old != 999.0f ? (zero_std_dev + zero_std_dev_old) / 2.0f : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
     if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
       return AC_CLEANUP();
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
-        test_precision = 0.00; // forced end
+        test_precision = 0.0f; // forced end
       #endif
 
       if (zero_std_dev < zero_std_dev_min) {
         // set roll-back point
         COPY(e_old, delta_endstop_adj);
         r_old = delta_radius;
         h_old = delta_height;
         COPY(a_old, delta_tower_angle_trim);
       }
 
-      float e_delta[ABC] = { 0.0 },
-            r_delta = 0.0,
-            t_delta[ABC] = { 0.0 };
+      float e_delta[ABC] = { 0.0f },
+            r_delta = 0.0f,
+            t_delta[ABC] = { 0.0f };
 
       /**
        * convergence matrices:
        * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
        *  - definition of the matrix scaling parameters
        *  - matrices for 4 and 7 point calibration
        */
-      #define ZP(N,I) ((N) * z_at_pt[I] / 4.0) // 4.0 = divider to normalize to integers
+      #define ZP(N,I) ((N) * z_at_pt[I] / 4.0f) // 4.0 = divider to normalize to integers
       #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
       #define Z0(I) ZP(0, I)
 
       // calculate factors
       const float cr_old = delta_calibration_radius;
-      if (_7p_9_center) delta_calibration_radius *= 0.9;
+      if (_7p_9_center) delta_calibration_radius *= 0.9f;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
       delta_calibration_radius = cr_old;
 
       switch (probe_points) {
         case 0:
-          test_precision = 0.00; // forced end
+          test_precision = 0.0f; // forced end
           break;
 
         case 1:
-          test_precision = 0.00; // forced end
+          test_precision = 0.0f; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:
           if (towers_set) { // see 4 point calibration (towers) matrix
             e_delta[A_AXIS] = (+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN);
             e_delta[B_AXIS] = (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN);
             e_delta[C_AXIS] = (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN);
             r_delta         = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
           }
@@ -598,23 +598,23 @@ void GcodeSuite::G33() {
       COPY(delta_endstop_adj, e_old);
       delta_radius = r_old;
       delta_height = h_old;
       COPY(delta_tower_angle_trim, a_old);
     }
 
     if (verbose_level != 0) {                                    // !dry run
 
       // Normalize angles to least-squares
       if (_angle_results) {
-        float a_sum = 0.0;
+        float a_sum = 0.0f;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
-        LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
+        LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0f;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = _MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
@@ -632,21 +632,21 @@ void GcodeSuite::G33() {
             SERIAL_ECHOPGM("rolling back.");
           else
         #endif
           {
             SERIAL_ECHOPAIR_F("std dev:", zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
-          sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0));
+          sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0f));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
@@ -664,21 +664,21 @@ void GcodeSuite::G33() {
     else { // dry run
       PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_ECHO_SP(35);
       SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
-        sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0));
+        sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0f));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   AC_CLEANUP();
 }

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 455b5b2677..08045d8cb8 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -183,21 +183,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
     }
   }
   return 0.00001;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const float &nx, const float &ny, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_at_point(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
 /**
  *  - Probe a grid
  */
 static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index effffac3dd..455b5b2677 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -362,24 +362,25 @@ static float auto_tune_r() {
 }
 
 static float auto_tune_a() {
   const float diff = 0.01;
   float a_fac = 0.0,
         z_pt[NPP + 1] = { 0.0 },
         delta_e[ABC] = {0.0},
         delta_r = {0.0},
         delta_t[ABC] = {0.0};
 
+  ZERO(delta_t);
   LOOP_XYZ(axis) {
-    LOOP_XYZ(axis_2) delta_t[axis_2] = 0.0;
     delta_t[axis] = diff;
     calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
+    delta_t[axis] = 0;
     a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0;
     a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0;
   }
   a_fac = diff / a_fac / 3.0; // 1/(3*delta_Z)
   return a_fac;
 }
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, z_offset, endstops, delta radius, and tower angles.

commit f9992c5f33d954da1a70a03acf8b58d86def601b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 11 02:46:52 2019 -0500

    Implausible

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 5eaadeb77d..effffac3dd 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -404,41 +404,41 @@ static float auto_tune_a() {
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
-    SERIAL_ECHOLNPGM("?(P)oints is implausible (0-10).");
+    SERIAL_ECHOLNPGM("?(P)oints implausible (0-10).");
     return;
   }
 
   const bool towers_set = !parser.seen('T');
 
   const float calibration_precision = parser.floatval('C', 0.0);
   if (calibration_precision < 0) {
-    SERIAL_ECHOLNPGM("?(C)alibration precision is implausible (>=0).");
+    SERIAL_ECHOLNPGM("?(C)alibration precision implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
-    SERIAL_ECHOLNPGM("?(F)orce iteration is implausible (0-30).");
+    SERIAL_ECHOLNPGM("?(F)orce iteration implausible (0-30).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
-    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-3).");
+    SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen('E');
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
@@ -468,21 +468,21 @@ void GcodeSuite::G33() {
           delta_tower_angle_trim[C_AXIS]
         };
 
   SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
-        SERIAL_ECHOLNPGM("?(M665 B)ed radius is implausible.");
+        SERIAL_ECHOLNPGM("?(M665 B)ed radius implausible.");
         return;
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
   SERIAL_EOL();

commit 274934ad81ee6cd9b4f686e55107966cc4e23bd7
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Aug 16 17:34:13 2019 -0600

    Add LULZBOT_TOUCH_UI (#14967)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 397f5d2f75..5eaadeb77d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -438,21 +438,21 @@ void GcodeSuite::G33() {
   const bool stow_after_each = parser.seen('E');
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
-             _angle_results       = probe_points >= 3  && towers_set;
+             _angle_results       = probe_points >= 3 && towers_set;
   static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor,
         r_factor,
         a_factor,
         e_old[ABC] = {

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index a76900f6c0..397f5d2f75 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -603,21 +603,21 @@ void GcodeSuite::G33() {
     if (verbose_level != 0) {                                    // !dry run
 
       // Normalize angles to least-squares
       if (_angle_results) {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
-      const float z_temp = MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      const float z_temp = _MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 78816903fd..a76900f6c0 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit aa0383a83b7bc45b86753ef9f5adb41da09c76df
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 23 21:00:48 2019 -0400

    Enhance IDEX toolchange auto-return w/ no park, full control (#14117)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index b3488766b6..78816903fd 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -73,21 +73,21 @@ enum CalEnum : char {                        // the 7 main calibration points -
 float lcd_probe_pt(const float &rx, const float &ry);
 
 void ac_home() {
   endstops.enable(true);
   home_delta();
   endstops.not_homing();
 }
 
 void ac_setup(const bool reset_bed) {
   #if HOTENDS > 1
-    tool_change(0, 0, true);
+    tool_change(0, true);
   #endif
 
   planner.synchronize();
   setup_for_endstop_or_probe_move();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
@@ -97,21 +97,21 @@ void ac_cleanup(
   #endif
 ) {
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   #if HAS_BED_PROBE
     STOW_PROBE();
   #endif
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
-    tool_change(old_tool_index, 0, true);
+    tool_change(old_tool_index, true);
   #endif
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_ECHOPGM("  ");
   serialprintPGM(prefix);
   SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_ECHO_F(f, 2);
 }

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index db70ddd205..b3488766b6 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 814d93c7cfa45a3ce093f75c8d3a5f767c23bf7b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Fri Dec 28 01:05:42 2018 +0100

    Fix G33 sprintf output warning (#12738)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ece1e4aab3..db70ddd205 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -642,21 +642,21 @@ void GcodeSuite::G33() {
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
-          sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
+          sprintf_P(mess, PSTR("Iteration : %02i"), (unsigned int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_ECHO(mess);
         SERIAL_ECHO_SP(32);
         SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }

commit c6e09c2689df184e60c572a628312ad9842582d9
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Tue Dec 18 19:43:38 2018 +0100

    [2.0.x] G33 clean up (#12648)
    
    Remove obsolete workarounds in G33 for the now fixed zprobe_zoffset bug

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 6843b57ec4..ece1e4aab3 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -133,26 +133,20 @@ static void print_calibration_settings(const bool end_stops, const bool tower_an
     SERIAL_ECHO_SP(13);
   }
   if (tower_angles) {
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
     SERIAL_ECHOPAIR("  Radius:", delta_radius);
   }
-  #if HAS_BED_PROBE
-    if (!end_stops && !tower_angles) {
-      SERIAL_ECHO_SP(30);
-      print_signed_float(PSTR("Offset"), zprobe_zoffset);
-    }
-  #endif
   SERIAL_EOL();
 }
 
 /**
  *  - Print the probe results
  */
 static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_ECHOPGM(".    ");
   print_signed_float(PSTR("c"), z_pt[CEN]);
   if (tower_points) {
@@ -187,44 +181,33 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
       }
       return LROUND(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
     }
   }
   return 0.00001;
 }
 
 /**
  *  - Probe a point
  */
-static float calibration_probe(const float &nx, const float &ny, const bool stow, const bool set_up) {
+static float calibration_probe(const float &nx, const float &ny, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, set_up ? PROBE_PT_BIG_RAISE : stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
-    UNUSED(set_up);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
-#if HAS_BED_PROBE && HAS_LCD_MENU
-  static float probe_z_shift(const float center) {
-    STOW_PROBE();
-    endstops.enable_z_probe(false);
-    float z_shift = lcd_probe_pt(0, 0) - center;
-    endstops.enable_z_probe(true);
-    return z_shift;
-  }
-#endif
-
 /**
  *  - Probe a grid
  */
-static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each, const bool set_up) {
+static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
@@ -233,31 +216,31 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_center         = probe_points >= 5 && probe_points <= 7,
              _7p_9_center         = probe_points >= 8;
 
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
-      z_pt[CEN] += calibration_probe(0, 0, stow_after_each, set_up);
+      z_pt[CEN] += calibration_probe(0, 0, stow_after_each);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0 : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0 : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = delta_calibration_radius * 0.1;
-        z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
+        z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
@@ -267,21 +250,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = FMOD(rad, 1);
-          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
+          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
@@ -396,24 +379,21 @@ static float auto_tune_a() {
   a_fac = diff / a_fac / 3.0; // 1/(3*delta_Z)
   return a_fac;
 }
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, z_offset, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
- *   S   Setup mode; disables probe protection
- *
  *   Pn  Number of probe points:
- *      P-1      Checks the z_offset with a center probe and paper test.
  *      P0       Normalizes calibration.
  *      P1       Calibrates height only with center probe.
  *      P2       Probe center and towers. Calibrate height, endstops and delta radius.
  *      P3       Probe all positions: center, towers and opposite towers. Calibrate all.
  *      P4-P10   Probe all positions at different intermediate locations and average them.
  *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
@@ -422,63 +402,48 @@ static float auto_tune_a() {
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
-  const bool set_up =
-    #if HAS_BED_PROBE
-      parser.seen('S');
-    #else
-      false;
-    #endif
-
-  const int8_t probe_points = set_up ? 2 : parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
-  if (!WITHIN(probe_points, -1, 10)) {
-    SERIAL_ECHOLNPGM("?(P)oints is implausible (-1 - 10).");
+  const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
+  if (!WITHIN(probe_points, 0, 10)) {
+    SERIAL_ECHOLNPGM("?(P)oints is implausible (0-10).");
     return;
   }
 
   const bool towers_set = !parser.seen('T');
 
-  const float calibration_precision = set_up ? Z_CLEARANCE_BETWEEN_PROBES / 5.0 : parser.floatval('C', 0.0);
+  const float calibration_precision = parser.floatval('C', 0.0);
   if (calibration_precision < 0) {
     SERIAL_ECHOLNPGM("?(C)alibration precision is implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
-    SERIAL_ECHOLNPGM("?(F)orce iteration is implausible (0 - 30).");
+    SERIAL_ECHOLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
-    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0 - 3).");
+    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-3).");
     return;
   }
 
   const bool stow_after_each = parser.seen('E');
 
-  if (set_up) {
-    delta_height = 999.99;
-    delta_radius = DELTA_PRINTABLE_RADIUS;
-    ZERO(delta_endstop_adj);
-    ZERO(delta_tower_angle_trim);
-    recalc_delta_settings();
-  }
-
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3  && towers_set;
   static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
@@ -513,40 +478,39 @@ void GcodeSuite::G33() {
         SERIAL_ECHOLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
-  if (set_up) SERIAL_ECHOPGM("  (SET-UP)");
   SERIAL_EOL();
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0 };
 
     test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
-    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each, set_up)) {
+    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each)) {
       SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
       return AC_CLEANUP();
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
@@ -580,25 +544,20 @@ void GcodeSuite::G33() {
 
       // calculate factors
       const float cr_old = delta_calibration_radius;
       if (_7p_9_center) delta_calibration_radius *= 0.9;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
       delta_calibration_radius = cr_old;
 
       switch (probe_points) {
-        case -1:
-          #if HAS_BED_PROBE && HAS_LCD_MENU
-            zprobe_zoffset += probe_z_shift(z_at_pt[CEN]);
-          #endif
-
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 359f7dfe30..6843b57ec4 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -102,75 +102,75 @@ void ac_cleanup(
   #if HAS_BED_PROBE
     STOW_PROBE();
   #endif
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
 void print_signed_float(PGM_P const prefix, const float &f) {
-  SERIAL_PROTOCOLPGM("  ");
+  SERIAL_ECHOPGM("  ");
   serialprintPGM(prefix);
-  SERIAL_PROTOCOLCHAR(':');
+  SERIAL_CHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
-  SERIAL_PROTOCOL_F(f, 2);
+  SERIAL_ECHO_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
 static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
-  SERIAL_PROTOCOLPAIR(".Height:", delta_height);
+  SERIAL_ECHOPAIR(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
     print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
     print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   }
   if (end_stops && tower_angles) {
-    SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
+    SERIAL_ECHOPAIR("  Radius:", delta_radius);
     SERIAL_EOL();
     SERIAL_CHAR('.');
-    SERIAL_PROTOCOL_SP(13);
+    SERIAL_ECHO_SP(13);
   }
   if (tower_angles) {
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
-    SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
+    SERIAL_ECHOPAIR("  Radius:", delta_radius);
   }
   #if HAS_BED_PROBE
     if (!end_stops && !tower_angles) {
-      SERIAL_PROTOCOL_SP(30);
+      SERIAL_ECHO_SP(30);
       print_signed_float(PSTR("Offset"), zprobe_zoffset);
     }
   #endif
   SERIAL_EOL();
 }
 
 /**
  *  - Print the probe results
  */
 static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
-  SERIAL_PROTOCOLPGM(".    ");
+  SERIAL_ECHOPGM(".    ");
   print_signed_float(PSTR("c"), z_pt[CEN]);
   if (tower_points) {
     print_signed_float(PSTR(" x"), z_pt[__A]);
     print_signed_float(PSTR(" y"), z_pt[__B]);
     print_signed_float(PSTR(" z"), z_pt[__C]);
   }
   if (tower_points && opposite_points) {
     SERIAL_EOL();
     SERIAL_CHAR('.');
-    SERIAL_PROTOCOL_SP(13);
+    SERIAL_ECHO_SP(13);
   }
   if (opposite_points) {
     print_signed_float(PSTR("yz"), z_pt[_BC]);
     print_signed_float(PSTR("zx"), z_pt[_CA]);
     print_signed_float(PSTR("xy"), z_pt[_AB]);
   }
   SERIAL_EOL();
 }
 
 /**
@@ -431,41 +431,41 @@ void GcodeSuite::G33() {
 
   const bool set_up =
     #if HAS_BED_PROBE
       parser.seen('S');
     #else
       false;
     #endif
 
   const int8_t probe_points = set_up ? 2 : parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, -1, 10)) {
-    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (-1 - 10).");
+    SERIAL_ECHOLNPGM("?(P)oints is implausible (-1 - 10).");
     return;
   }
 
   const bool towers_set = !parser.seen('T');
 
   const float calibration_precision = set_up ? Z_CLEARANCE_BETWEEN_PROBES / 5.0 : parser.floatval('C', 0.0);
   if (calibration_precision < 0) {
-    SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
+    SERIAL_ECHOLNPGM("?(C)alibration precision is implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
-    SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0 - 30).");
+    SERIAL_ECHOLNPGM("?(F)orce iteration is implausible (0 - 30).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 3)) {
-    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0 - 3).");
+    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0 - 3).");
     return;
   }
 
   const bool stow_after_each = parser.seen('E');
 
   if (set_up) {
     delta_height = 999.99;
     delta_radius = DELTA_PRINTABLE_RADIUS;
     ZERO(delta_endstop_adj);
     ZERO(delta_tower_angle_trim);
@@ -496,58 +496,58 @@ void GcodeSuite::G33() {
           delta_endstop_adj[C_AXIS]
         },
         r_old = delta_radius,
         h_old = delta_height,
         a_old[ABC] = {
           delta_tower_angle_trim[A_AXIS],
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
-  SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
+  SERIAL_ECHOLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
-        SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
+        SERIAL_ECHOLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
-  if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
-  if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
+  if (verbose_level == 0) SERIAL_ECHOPGM(" (DRY-RUN)");
+  if (set_up) SERIAL_ECHOPGM("  (SET-UP)");
   SERIAL_EOL();
   ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0 };
 
     test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
     if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each, set_up)) {
-      SERIAL_PROTOCOLLNPGM("Correct delta settings with M665 and M666");
+      SERIAL_ECHOLNPGM("Correct delta settings with M665 and M666");
       return AC_CLEANUP();
     }
     zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
 
       #if !HAS_BED_PROBE
         test_precision = 0.00; // forced end
@@ -658,66 +658,61 @@ void GcodeSuite::G33() {
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) { // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) { // end iterations
-        SERIAL_PROTOCOLPGM("Calibration OK");
-        SERIAL_PROTOCOL_SP(32);
+        SERIAL_ECHOPGM("Calibration OK");
+        SERIAL_ECHO_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
-            SERIAL_PROTOCOLPGM("rolling back.");
+            SERIAL_ECHOPGM("rolling back.");
           else
         #endif
           {
-            SERIAL_PROTOCOLPGM("std dev:");
-            SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
+            SERIAL_ECHOPAIR_F("std dev:", zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
-        SERIAL_PROTOCOL(mess);
-        SERIAL_PROTOCOL_SP(32);
-        SERIAL_PROTOCOLPGM("std dev:");
-        SERIAL_PROTOCOL_F(zero_std_dev, 3);
-        SERIAL_EOL();
+        SERIAL_ECHO(mess);
+        SERIAL_ECHO_SP(32);
+        SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
         ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
-      SERIAL_PROTOCOL_SP(35);
-      SERIAL_PROTOCOLPGM("std dev:");
-      SERIAL_PROTOCOL_F(zero_std_dev, 3);
-      SERIAL_EOL();
+      SERIAL_ECHO_SP(35);
+      SERIAL_ECHOLNPAIR_F("std dev:", zero_std_dev, 3);
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       ui.set_status(mess);
     }

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index bb515a6ea3..359f7dfe30 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -515,21 +515,21 @@ void GcodeSuite::G33() {
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
-  ui.setstatusPGM(checkingac);
+  ui.set_status_P(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0 };
@@ -676,56 +676,56 @@ void GcodeSuite::G33() {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
-        ui.setstatus(mess);
+        ui.set_status(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
-        ui.setstatus(mess);
+        ui.set_status(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
-      ui.setstatus(mess);
+      ui.set_status(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   AC_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 3aba869824..bb515a6ea3 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -515,21 +515,21 @@ void GcodeSuite::G33() {
       }
     }
   }
 
   // Report settings
   PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
-  lcd_setstatusPGM(checkingac);
+  ui.setstatusPGM(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0 };
@@ -676,56 +676,56 @@ void GcodeSuite::G33() {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
-        lcd_setstatus(mess);
+        ui.setstatus(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
-        lcd_setstatus(mess);
+        ui.setstatus(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
       PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
-      lcd_setstatus(mess);
+      ui.setstatus(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   AC_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 7ec76c1126..3aba869824 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -197,21 +197,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
 static float calibration_probe(const float &nx, const float &ny, const bool stow, const bool set_up) {
   #if HAS_BED_PROBE
     return probe_pt(nx, ny, set_up ? PROBE_PT_BIG_RAISE : stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
     UNUSED(set_up);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
-#if HAS_BED_PROBE && ENABLED(ULTIPANEL)
+#if HAS_BED_PROBE && HAS_LCD_MENU
   static float probe_z_shift(const float center) {
     STOW_PROBE();
     endstops.enable_z_probe(false);
     float z_shift = lcd_probe_pt(0, 0) - center;
     endstops.enable_z_probe(true);
     return z_shift;
   }
 #endif
 
 /**
@@ -581,21 +581,21 @@ void GcodeSuite::G33() {
       // calculate factors
       const float cr_old = delta_calibration_radius;
       if (_7p_9_center) delta_calibration_radius *= 0.9;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
       delta_calibration_radius = cr_old;
 
       switch (probe_points) {
         case -1:
-          #if HAS_BED_PROBE && ENABLED(ULTIPANEL)
+          #if HAS_BED_PROBE && HAS_LCD_MENU
             zprobe_zoffset += probe_z_shift(z_at_pt[CEN]);
           #endif
 
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 047874a9f9..7ec76c1126 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -636,21 +636,21 @@ void GcodeSuite::G33() {
     else if (zero_std_dev >= test_precision) {
       // roll back
       COPY(delta_endstop_adj, e_old);
       delta_radius = r_old;
       delta_height = h_old;
       COPY(delta_tower_angle_trim, a_old);
     }
 
     if (verbose_level != 0) {                                    // !dry run
 
-      // normalise angles to least squares
+      // Normalize angles to least-squares
       if (_angle_results) {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 086a51a0e4..047874a9f9 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -101,21 +101,21 @@ void ac_cleanup(
   #endif
   #if HAS_BED_PROBE
     STOW_PROBE();
   #endif
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
-void print_signed_float(const char * const prefix, const float &f) {
+void print_signed_float(PGM_P const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
 /**
  *  - Print the delta settings
  */
@@ -510,21 +510,21 @@ void GcodeSuite::G33() {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   // Report settings
-  const char* checkingac = PSTR("Checking... AC");
+  PGM_P checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
@@ -698,21 +698,21 @@ void GcodeSuite::G33() {
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
         if (verbose_level > 1)
           print_calibration_settings(_endstop_results, _angle_results);
       }
     }
     else { // dry run
-      const char *enddryrun = PSTR("End DRY-RUN");
+      PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)

commit b30ca652aed417be0ba8857922c1cf2b4df26f2d
Author: AnoNymous <dgdanielf@gmail.com>
Date:   Sun Sep 30 11:59:14 2018 +0200

    Replace MIN# / MAX# with variadic MIN / MAX (#11960)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index c2aac6d1ae..086a51a0e4 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -644,21 +644,21 @@ void GcodeSuite::G33() {
     if (verbose_level != 0) {                                    // !dry run
 
       // normalise angles to least squares
       if (_angle_results) {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
-      const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      const float z_temp = MAX(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level == 3)
       print_calibration_results(z_at_pt, _tower_results, _opposite_results);

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index e9ae4eca44..c2aac6d1ae 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -266,21 +266,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
                              _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
                              _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
-                      interpol = fmod(rad, 1);
+                      interpol = FMOD(rad, 1);
           const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
           z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)

commit 0af22549a6780d3486da895be7a920bd6c02927f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 11 22:31:58 2018 -0500

    Allow G33 to compile with no LCD

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 404da70d4f..e9ae4eca44 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -197,21 +197,21 @@ static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool
 static float calibration_probe(const float &nx, const float &ny, const bool stow, const bool set_up) {
   #if HAS_BED_PROBE
     return probe_pt(nx, ny, set_up ? PROBE_PT_BIG_RAISE : stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
     UNUSED(set_up);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
-#if HAS_BED_PROBE
+#if HAS_BED_PROBE && ENABLED(ULTIPANEL)
   static float probe_z_shift(const float center) {
     STOW_PROBE();
     endstops.enable_z_probe(false);
     float z_shift = lcd_probe_pt(0, 0) - center;
     endstops.enable_z_probe(true);
     return z_shift;
   }
 #endif
 
 /**
@@ -581,21 +581,21 @@ void GcodeSuite::G33() {
       // calculate factors
       const float cr_old = delta_calibration_radius;
       if (_7p_9_center) delta_calibration_radius *= 0.9;
       h_factor = auto_tune_h();
       r_factor = auto_tune_r();
       a_factor = auto_tune_a();
       delta_calibration_radius = cr_old;
 
       switch (probe_points) {
         case -1:
-          #if HAS_BED_PROBE
+          #if HAS_BED_PROBE && ENABLED(ULTIPANEL)
             zprobe_zoffset += probe_z_shift(z_at_pt[CEN]);
           #endif
 
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
           LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index d96c362ddd..404da70d4f 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -352,21 +352,21 @@ static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], float delta_e
   delta_radius -= delta_r;
   LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= delta_t[axis];
   recalc_delta_settings();
 }
 
 static float auto_tune_h() {
   const float r_quot = delta_calibration_radius / delta_radius;
   float h_fac = 0.0;
 
   h_fac = r_quot / (2.0 / 3.0);
-  h_fac = 1.0 / h_fac; // (2/3)/CR
+  h_fac = 1.0f / h_fac; // (2/3)/CR
   return h_fac;
 }
 
 static float auto_tune_r() {
   const float diff = 0.01;
   float r_fac = 0.0,
         z_pt[NPP + 1] = { 0.0 },
         delta_e[ABC] = {0.0},
         delta_r = {0.0},
         delta_t[ABC] = {0.0};

commit d960d448fa6aa463707fd6f88199b807573c1e40
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 4 18:38:05 2018 -0500

    Optimize calculations with LROUND

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 3169fe6c83..d96c362ddd 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -178,21 +178,21 @@ static void print_calibration_results(const float z_pt[NPP + 1], const bool towe
  */
 static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool _1p_cal, const bool _4p_cal, const bool _4p_opp) {
   if (!_0p_cal) {
     float S2 = sq(z_pt[CEN]);
     int16_t N = 1;
     if (!_1p_cal) { // std dev from zero plane
       LOOP_CAL_ACT(rad, _4p_cal, _4p_opp) {
         S2 += sq(z_pt[rad]);
         N++;
       }
-      return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+      return LROUND(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
     }
   }
   return 0.00001;
 }
 
 /**
  *  - Probe a point
  */
 static float calibration_probe(const float &nx, const float &ny, const bool stow, const bool set_up) {
   #if HAS_BED_PROBE
@@ -270,22 +270,22 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
       bool zig_zag = true;
       F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
         const int8_t offset = _7p_9_center ? 2 : 0;
         for (int8_t circle = 0; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                       r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
                       interpol = fmod(rad, 1);
           const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
           if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
-          z_pt[uint8_t(round(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
-          z_pt[uint8_t(round(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
+          z_pt[uint8_t(LROUND(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
+          z_pt[uint8_t(LROUND(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(rad)
           z_pt[rad] /= _7P_STEP / steps;
 
       do_blocking_move_to_xy(0.0, 0.0);
     }
   }
@@ -673,23 +673,23 @@ void GcodeSuite::G33() {
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
-          sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
+          sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev_min * 1000.0));
         else
-          sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
+          sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev_min));
         lcd_setstatus(mess);
         print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
@@ -709,23 +709,23 @@ void GcodeSuite::G33() {
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
-        sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
+        sprintf_P(&mess[15], PSTR("0.%03i"), (int)LROUND(zero_std_dev * 1000.0));
       else
-        sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
+        sprintf_P(&mess[15], PSTR("%03i.x"), (int)LROUND(zero_std_dev));
       lcd_setstatus(mess);
     }
     ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   AC_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 959da32d51..3169fe6c83 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -65,26 +65,24 @@ enum CalEnum : char {                        // the 7 main calibration points -
 
 #if HOTENDS > 1
   const uint8_t old_tool_index = active_extruder;
   #define AC_CLEANUP() ac_cleanup(old_tool_index)
 #else
   #define AC_CLEANUP() ac_cleanup()
 #endif
 
 float lcd_probe_pt(const float &rx, const float &ry);
 
-bool ac_home() {
+void ac_home() {
   endstops.enable(true);
-  if (!home_delta())
-    return false;
+  home_delta();
   endstops.not_homing();
-  return true;
 }
 
 void ac_setup(const bool reset_bed) {
   #if HOTENDS > 1
     tool_change(0, 0, true);
   #endif
 
   planner.synchronize();
   setup_for_endstop_or_probe_move();
 
@@ -523,22 +521,21 @@ void GcodeSuite::G33() {
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
-  if (!_0p_calibration)
-    if (!ac_home()) return;
+  if (!_0p_calibration) ac_home();
 
   do { // start iterations
 
     float z_at_pt[NPP + 1] = { 0.0 };
 
     test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
     iterations++;
 
     // Probe the points
     zero_std_dev_old = zero_std_dev;
@@ -717,18 +714,18 @@ void GcodeSuite::G33() {
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
       lcd_setstatus(mess);
     }
-    if (!ac_home()) return;
+    ac_home();
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   AC_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit a431013eb7560e3d6be4dd02ddc3db172e01f2ff
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 29 23:14:02 2018 -0500

    Fix G33 compile warning

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 78b48790f9..959da32d51 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -240,21 +240,21 @@ static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_poi
   LOOP_CAL_ALL(rad) z_pt[rad] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       z_pt[CEN] += calibration_probe(0, 0, stow_after_each, set_up);
       if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
-      const float start  = _7p_9_center ? _CA + _7P_STEP / 3.0 : _7p_6_center ? _CA : __C,
+      const float start  = _7p_9_center ? float(_CA) + _7P_STEP / 3.0 : _7p_6_center ? float(_CA) : float(__C),
                   steps  = _7p_9_center ? _4P_STEP / 3.0 : _7p_6_center ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(rad, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = delta_calibration_radius * 0.1;
         z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
         if (isnan(z_pt[CEN])) return false;
      }
       z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 

commit 6f330f397e58130dcc9871fba33786575ac37f6f
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Sat May 26 01:32:37 2018 -0300

    [2.0.x] Buffer overflow and scroll fix, UTF8 cleanup (#10844)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 15822262fc..78b48790f9 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -512,29 +512,26 @@ void GcodeSuite::G33() {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   // Report settings
-
-  const char *checkingac = PSTR("Checking... AC");
+  const char* checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
-  char mess[11];
-  strcpy_P(mess, checkingac);
-  lcd_setstatus(mess);
+  lcd_setstatusPGM(checkingac);
 
   print_calibration_settings(_endstop_results, _angle_results);
 
   ac_setup(!_0p_calibration && !_1p_calibration);
 
   if (!_0p_calibration)
     if (!ac_home()) return;
 
   do { // start iterations
 

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 6aac9f0270..15822262fc 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -78,21 +78,21 @@ bool ac_home() {
     return false;
   endstops.not_homing();
   return true;
 }
 
 void ac_setup(const bool reset_bed) {
   #if HOTENDS > 1
     tool_change(0, 0, true);
   #endif
 
-  stepper.synchronize();
+  planner.synchronize();
   setup_for_endstop_or_probe_move();
 
   #if HAS_LEVELING
     if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
   #endif
 }
 
 void ac_cleanup(
   #if HOTENDS > 1
     const uint8_t old_tool_index

commit 33966710119b64f83a19075875a8d27452cca9a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 00:16:30 2018 -0500

    [2.0.x] Reset LCD status to fallbacks (#10470)
    
    * Remove obsolete strings
    * Tweak some static consts
    * Reset LCD status to fallbacks

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 7202d534e7..6aac9f0270 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -476,21 +476,21 @@ void GcodeSuite::G33() {
 
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_9_center         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
              _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
              _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
              _angle_results       = probe_points >= 3  && towers_set;
-  const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
+  static const char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         zero_std_dev_old = zero_std_dev,
         h_factor,
         r_factor,
         a_factor,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],

commit 646aa20b433cbde61a849a2b79ddf1c0a13714ef
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 04:14:48 2018 +0200

    Overhaul of G33 Delta Calibration (#8822)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 036b3425f3..7202d534e7 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -19,686 +19,719 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DELTA_AUTO_CALIBRATION)
 
 #include "../gcode.h"
 #include "../../module/delta.h"
-#include "../../module/probe.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 #include "../../lcd/ultralcd.h"
 
+#if HAS_BED_PROBE
+  #include "../../module/probe.h"
+#endif
+
 #if HOTENDS > 1
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
                   _4P_STEP = _7P_STEP * 2,   // 4-point step
                   NPP      = _7P_STEP * 6;   // number of calibration points on the radius
-enum CalEnum : char {                               // the 7 main calibration points - add definitions if needed
+enum CalEnum : char {                        // the 7 main calibration points - add definitions if needed
   CEN      = 0,
   __A      = 1,
   _AB      = __A + _7P_STEP,
   __B      = _AB + _7P_STEP,
   _BC      = __B + _7P_STEP,
   __C      = _BC + _7P_STEP,
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
 #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
-static void print_signed_float(const char * const prefix, const float &f) {
+#if HOTENDS > 1
+  const uint8_t old_tool_index = active_extruder;
+  #define AC_CLEANUP() ac_cleanup(old_tool_index)
+#else
+  #define AC_CLEANUP() ac_cleanup()
+#endif
+
+float lcd_probe_pt(const float &rx, const float &ry);
+
+bool ac_home() {
+  endstops.enable(true);
+  if (!home_delta())
+    return false;
+  endstops.not_homing();
+  return true;
+}
+
+void ac_setup(const bool reset_bed) {
+  #if HOTENDS > 1
+    tool_change(0, 0, true);
+  #endif
+
+  stepper.synchronize();
+  setup_for_endstop_or_probe_move();
+
+  #if HAS_LEVELING
+    if (reset_bed) reset_bed_level(); // After full calibration bed-level data is no longer valid
+  #endif
+}
+
+void ac_cleanup(
+  #if HOTENDS > 1
+    const uint8_t old_tool_index
+  #endif
+) {
+  #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+  #if HAS_BED_PROBE
+    STOW_PROBE();
+  #endif
+  clean_up_after_endstop_or_probe_move();
+  #if HOTENDS > 1
+    tool_change(old_tool_index, 0, true);
+  #endif
+}
+
+void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
-static void print_G33_settings(const bool end_stops, const bool tower_angles) {
+/**
+ *  - Print the delta settings
+ */
+static void print_calibration_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_PROTOCOLPAIR(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
     print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
     print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   }
   if (end_stops && tower_angles) {
     SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_PROTOCOL_SP(13);
   }
   if (tower_angles) {
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
     SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   }
+  #if HAS_BED_PROBE
+    if (!end_stops && !tower_angles) {
+      SERIAL_PROTOCOL_SP(30);
+      print_signed_float(PSTR("Offset"), zprobe_zoffset);
+    }
+  #endif
   SERIAL_EOL();
 }
 
-static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
+/**
+ *  - Print the probe results
+ */
+static void print_calibration_results(const float z_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_PROTOCOLPGM(".    ");
-  print_signed_float(PSTR("c"), z_at_pt[CEN]);
+  print_signed_float(PSTR("c"), z_pt[CEN]);
   if (tower_points) {
-    print_signed_float(PSTR(" x"), z_at_pt[__A]);
-    print_signed_float(PSTR(" y"), z_at_pt[__B]);
-    print_signed_float(PSTR(" z"), z_at_pt[__C]);
+    print_signed_float(PSTR(" x"), z_pt[__A]);
+    print_signed_float(PSTR(" y"), z_pt[__B]);
+    print_signed_float(PSTR(" z"), z_pt[__C]);
   }
   if (tower_points && opposite_points) {
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_PROTOCOL_SP(13);
   }
   if (opposite_points) {
-    print_signed_float(PSTR("yz"), z_at_pt[_BC]);
-    print_signed_float(PSTR("zx"), z_at_pt[_CA]);
-    print_signed_float(PSTR("xy"), z_at_pt[_AB]);
+    print_signed_float(PSTR("yz"), z_pt[_BC]);
+    print_signed_float(PSTR("zx"), z_pt[_CA]);
+    print_signed_float(PSTR("xy"), z_pt[_AB]);
   }
   SERIAL_EOL();
 }
 
 /**
- * After G33:
- *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
- *  - Stow the probe
- *  - Restore endstops state
- *  - Select the old tool, if needed
+ *  - Calculate the standard deviation from the zero plane
  */
-static void G33_cleanup(
-  #if HOTENDS > 1
-    const uint8_t old_tool_index
-  #endif
-) {
-  #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
-    do_blocking_move_to_z(delta_clip_start_height);
-  #endif
-  STOW_PROBE();
-  clean_up_after_endstop_or_probe_move();
-  #if HOTENDS > 1
-    tool_change(old_tool_index, 0, true);
-  #endif
+static float std_dev_points(float z_pt[NPP + 1], const bool _0p_cal, const bool _1p_cal, const bool _4p_cal, const bool _4p_opp) {
+  if (!_0p_cal) {
+    float S2 = sq(z_pt[CEN]);
+    int16_t N = 1;
+    if (!_1p_cal) { // std dev from zero plane
+      LOOP_CAL_ACT(rad, _4p_cal, _4p_opp) {
+        S2 += sq(z_pt[rad]);
+        N++;
+      }
+      return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+    }
+  }
+  return 0.00001;
 }
 
-inline float calibration_probe(const float nx, const float ny, const bool stow) {
+/**
+ *  - Probe a point
+ */
+static float calibration_probe(const float &nx, const float &ny, const bool stow, const bool set_up) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_pt(nx, ny, set_up ? PROBE_PT_BIG_RAISE : stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
+    UNUSED(set_up);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
-static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
+#if HAS_BED_PROBE
+  static float probe_z_shift(const float center) {
+    STOW_PROBE();
+    endstops.enable_z_probe(false);
+    float z_shift = lcd_probe_pt(0, 0) - center;
+    endstops.enable_z_probe(true);
+    return z_shift;
+  }
+#endif
+
+/**
+ *  - Probe a grid
+ */
+static bool probe_calibration_points(float z_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each, const bool set_up) {
   const bool _0p_calibration      = probe_points == 0,
-             _1p_calibration      = probe_points == 1,
+             _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
-             _7p_calibration      = probe_points >= 3 || probe_points == 0,
+             _7p_calibration      = probe_points >= 3,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
              _7p_8_intermediates  = probe_points == 8,
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
-             _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
-             _7p_9_centre         = probe_points >= 8;
+             _7p_6_center         = probe_points >= 5 && probe_points <= 7,
+             _7p_9_center         = probe_points >= 8;
 
-  LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
+  LOOP_CAL_ALL(rad) z_pt[rad] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
-      z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
-      if (isnan(z_at_pt[CEN])) return NAN;
+      z_pt[CEN] += calibration_probe(0, 0, stow_after_each, set_up);
+      if (isnan(z_pt[CEN])) return false;
     }
 
     if (_7p_calibration) { // probe extra center points
-      const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
-                  steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
-      I_LOOP_CAL_PT(axis, start, steps) {
-        const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
+      const float start  = _7p_9_center ? _CA + _7P_STEP / 3.0 : _7p_6_center ? _CA : __C,
+                  steps  = _7p_9_center ? _4P_STEP / 3.0 : _7p_6_center ? _7P_STEP : _4P_STEP;
+      I_LOOP_CAL_PT(rad, start, steps) {
+        const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
                     r = delta_calibration_radius * 0.1;
-        z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
-        if (isnan(z_at_pt[CEN])) return NAN;
+        z_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
+        if (isnan(z_pt[CEN])) return false;
      }
-      z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
+      z_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
                              _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
                              _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
                              _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
-      F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
-        const int8_t offset = _7p_9_centre ? 1 : 0;
-        for (int8_t circle = -offset; circle <= offset; circle++) {
-          const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
-                      r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
-                      interpol = fmod(axis, 1);
-          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
-          if (isnan(z_temp)) return NAN;
+      F_LOOP_CAL_PT(rad, start, _7p_9_center ? steps * 3 : steps) {
+        const int8_t offset = _7p_9_center ? 2 : 0;
+        for (int8_t circle = 0; circle <= offset; circle++) {
+          const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
+                      r = delta_calibration_radius * (1 - 0.1 * (zig_zag ? offset - circle : circle)),
+                      interpol = fmod(rad, 1);
+          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each, set_up);
+          if (isnan(z_temp)) return false;
           // split probe point to neighbouring calibration points
-          z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
-          z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
+          z_pt[uint8_t(round(rad - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
+          z_pt[uint8_t(round(rad - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
-        LOOP_CAL_RAD(axis)
-          z_at_pt[axis] /= _7P_STEP / steps;
-    }
+        LOOP_CAL_RAD(rad)
+          z_pt[rad] /= _7P_STEP / steps;
 
-    float S1 = z_at_pt[CEN],
-          S2 = sq(z_at_pt[CEN]);
-    int16_t N = 1;
-    if (!_1p_calibration) { // std dev from zero plane
-      LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
-        S1 += z_at_pt[axis];
-        S2 += sq(z_at_pt[axis]);
-        N++;
-      }
-      return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+      do_blocking_move_to_xy(0.0, 0.0);
     }
   }
-
-  return 0.00001;
+  return true;
 }
 
-#if HAS_BED_PROBE
-
-  static bool G33_auto_tune() {
-    float z_at_pt[NPP + 1]      = { 0.0 },
-          z_at_pt_base[NPP + 1] = { 0.0 },
-          z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
-
-    #define ZP(N,I) ((N) * z_at_pt[I])
-    #define Z06(I)  ZP(6, I)
-    #define Z03(I)  ZP(3, I)
-    #define Z02(I)  ZP(2, I)
-    #define Z01(I)  ZP(1, I)
-    #define Z32(I)  ZP(3/2, I)
-
-    SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
-    SERIAL_EOL();
-    if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
-    print_G33_results(z_at_pt_base, true, true);
+/**
+ * kinematics routines and auto tune matrix scaling parameters:
+ * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
+ *  - formulae for approximative forward kinematics in the end-stop displacement matrix
+ *  - definition of the matrix scaling parameters
+ */
+static void reverse_kinematics_probe_points(float z_pt[NPP + 1], float mm_at_pt_axis[NPP + 1][ABC]) {
+  float pos[XYZ] = { 0.0 };
+
+  LOOP_CAL_ALL(rad) {
+    const float a = RADIANS(210 + (360 / NPP) *  (rad - 1)),
+                r = (rad == CEN ? 0.0 : delta_calibration_radius);
+    pos[X_AXIS] = cos(a) * r;
+    pos[Y_AXIS] = sin(a) * r;
+    pos[Z_AXIS] = z_pt[rad];
+    inverse_kinematics(pos);
+    LOOP_XYZ(axis) mm_at_pt_axis[rad][axis] = delta[axis];
+  }
+}
 
-    LOOP_XYZ(axis) {
-      delta_endstop_adj[axis] -= 1.0;
-      recalc_delta_settings();
+static void forward_kinematics_probe_points(float mm_at_pt_axis[NPP + 1][ABC], float z_pt[NPP + 1]) {
+  const float r_quot = delta_calibration_radius / delta_radius;
+
+  #define ZPP(N,I,A) ((1 / 3.0 + r_quot * (N) / 3.0 ) * mm_at_pt_axis[I][A])
+  #define Z00(I, A) ZPP( 0, I, A)
+  #define Zp1(I, A) ZPP(+1, I, A)
+  #define Zm1(I, A) ZPP(-1, I, A)
+  #define Zp2(I, A) ZPP(+2, I, A)
+  #define Zm2(I, A) ZPP(-2, I, A)
+
+  z_pt[CEN] = Z00(CEN, A_AXIS) + Z00(CEN, B_AXIS) + Z00(CEN, C_AXIS);
+  z_pt[__A] = Zp2(__A, A_AXIS) + Zm1(__A, B_AXIS) + Zm1(__A, C_AXIS);
+  z_pt[__B] = Zm1(__B, A_AXIS) + Zp2(__B, B_AXIS) + Zm1(__B, C_AXIS);
+  z_pt[__C] = Zm1(__C, A_AXIS) + Zm1(__C, B_AXIS) + Zp2(__C, C_AXIS);
+  z_pt[_BC] = Zm2(_BC, A_AXIS) + Zp1(_BC, B_AXIS) + Zp1(_BC, C_AXIS);
+  z_pt[_CA] = Zp1(_CA, A_AXIS) + Zm2(_CA, B_AXIS) + Zp1(_CA, C_AXIS);
+  z_pt[_AB] = Zp1(_AB, A_AXIS) + Zp1(_AB, B_AXIS) + Zm2(_AB, C_AXIS);
+}
 
-      endstops.enable(true);
-      if (!home_delta()) return false;
-      endstops.not_homing();
+static void calc_kinematics_diff_probe_points(float z_pt[NPP + 1], float delta_e[ABC], float delta_r, float delta_t[ABC]) {
+  const float z_center = z_pt[CEN];
+  float diff_mm_at_pt_axis[NPP + 1][ABC],
+        new_mm_at_pt_axis[NPP + 1][ABC];
 
-      SERIAL_PROTOCOLPGM("Tuning E");
-      SERIAL_CHAR(tolower(axis_codes[axis]));
-      SERIAL_EOL();
+  reverse_kinematics_probe_points(z_pt, diff_mm_at_pt_axis);
 
-      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
-      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
-      print_G33_results(z_at_pt, true, true);
-      delta_endstop_adj[axis] += 1.0;
-      recalc_delta_settings();
-      switch (axis) {
-        case A_AXIS :
-          h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
-          break;
-        case B_AXIS :
-          h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
-          break;
-        case C_AXIS :
-          h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
-          break;
-      }
-    }
-    h_fac /= 3.0;
-    h_fac *= norm; // Normalize to 1.02 for Kossel mini
+  delta_radius += delta_r;
+  LOOP_XYZ(axis) delta_tower_angle_trim[axis] += delta_t[axis];
+  recalc_delta_settings();
+  reverse_kinematics_probe_points(z_pt, new_mm_at_pt_axis);
 
-    for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
-      delta_radius += 1.0 * zig_zag;
-      recalc_delta_settings();
+  LOOP_XYZ(axis) LOOP_CAL_ALL(rad) diff_mm_at_pt_axis[rad][axis] -= new_mm_at_pt_axis[rad][axis] + delta_e[axis];
+  forward_kinematics_probe_points(diff_mm_at_pt_axis, z_pt);
 
-      endstops.enable(true);
-      if (!home_delta()) return false;
-      endstops.not_homing();
+  LOOP_CAL_RAD(rad) z_pt[rad] -= z_pt[CEN] - z_center;
+  z_pt[CEN] = z_center;
 
-      SERIAL_PROTOCOLPGM("Tuning R");
-      SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
-      SERIAL_EOL();
-      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
-      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
-      print_G33_results(z_at_pt, true, true);
-      delta_radius -= 1.0 * zig_zag;
-      recalc_delta_settings();
-      r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
-    }
-    r_fac /= 2.0;
-    r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
-
-    LOOP_XYZ(axis) {
-      delta_tower_angle_trim[axis] += 1.0;
-      delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
-      delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
-      z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      delta_height -= z_temp;
-      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
-      recalc_delta_settings();
+  delta_radius -= delta_r;
+  LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= delta_t[axis];
+  recalc_delta_settings();
+}
 
-      endstops.enable(true);
-      if (!home_delta()) return false;
-      endstops.not_homing();
+static float auto_tune_h() {
+  const float r_quot = delta_calibration_radius / delta_radius;
+  float h_fac = 0.0;
 
-      SERIAL_PROTOCOLPGM("Tuning T");
-      SERIAL_CHAR(tolower(axis_codes[axis]));
-      SERIAL_EOL();
+  h_fac = r_quot / (2.0 / 3.0);
+  h_fac = 1.0 / h_fac; // (2/3)/CR
+  return h_fac;
+}
 
-      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
-      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
-      print_G33_results(z_at_pt, true, true);
+static float auto_tune_r() {
+  const float diff = 0.01;
+  float r_fac = 0.0,
+        z_pt[NPP + 1] = { 0.0 },
+        delta_e[ABC] = {0.0},
+        delta_r = {0.0},
+        delta_t[ABC] = {0.0};
+
+  delta_r = diff;
+  calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
+  r_fac = -(z_pt[__A] + z_pt[__B] + z_pt[__C] + z_pt[_BC] + z_pt[_CA] + z_pt[_AB]) / 6.0;
+  r_fac = diff / r_fac / 3.0; // 1/(3*delta_Z)
+  return r_fac;
+}
 
-      delta_tower_angle_trim[axis] -= 1.0;
-      delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
-      delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
-      z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      delta_height -= z_temp;
-      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
-      recalc_delta_settings();
-      switch (axis) {
-        case A_AXIS :
-          a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
-          break;
-        case B_AXIS :
-          a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
-          break;
-        case C_AXIS :
-          a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
-          break;
-      }
-    }
-    a_fac /= 3.0;
-    a_fac *= norm; // Normalize to 0.83 for Kossel mini
-
-    endstops.enable(true);
-    if (!home_delta()) return false;
-    endstops.not_homing();
-    print_signed_float(PSTR( "H_FACTOR: "), h_fac);
-    print_signed_float(PSTR(" R_FACTOR: "), r_fac);
-    print_signed_float(PSTR(" A_FACTOR: "), a_fac);
-    SERIAL_EOL();
-    SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
-    SERIAL_EOL();
-    return true;
+static float auto_tune_a() {
+  const float diff = 0.01;
+  float a_fac = 0.0,
+        z_pt[NPP + 1] = { 0.0 },
+        delta_e[ABC] = {0.0},
+        delta_r = {0.0},
+        delta_t[ABC] = {0.0};
+
+  LOOP_XYZ(axis) {
+    LOOP_XYZ(axis_2) delta_t[axis_2] = 0.0;
+    delta_t[axis] = diff;
+    calc_kinematics_diff_probe_points(z_pt, delta_e, delta_r, delta_t);
+    a_fac += z_pt[uint8_t((axis * _4P_STEP) - _7P_STEP + NPP) % NPP + 1] / 6.0;
+    a_fac -= z_pt[uint8_t((axis * _4P_STEP) + 1 + _7P_STEP)] / 6.0;
   }
-
-#endif // HAS_BED_PROBE
+  a_fac = diff / a_fac / 3.0; // 1/(3*delta_Z)
+  return a_fac;
+}
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
- *       Calibrate height, endstops, delta radius, and tower angles.
+ *       Calibrate height, z_offset, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
+ *   S   Setup mode; disables probe protection
+ *
  *   Pn  Number of probe points:
- *      P0     No probe. Normalize only.
- *      P1     Probe center and set height only.
- *      P2     Probe center and towers. Set height, endstops and delta radius.
- *      P3     Probe all positions: center, towers and opposite towers. Set all.
- *      P4-P10 Probe all positions + at different intermediate locations and average them.
+ *      P-1      Checks the z_offset with a center probe and paper test.
+ *      P0       Normalizes calibration.
+ *      P1       Calibrates height only with center probe.
+ *      P2       Probe center and towers. Calibrate height, endstops and delta radius.
+ *      P3       Probe all positions: center, towers and opposite towers. Calibrate all.
+ *      P4-P10   Probe all positions at different intermediate locations and average them.
  *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and take the best result
  *
- *   A   Auto-tune calibration factors (set in Configuration.h)
- *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
-  const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
-  if (!WITHIN(probe_points, 0, 10)) {
-    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
-    return;
-  }
+  const bool set_up =
+    #if HAS_BED_PROBE
+      parser.seen('S');
+    #else
+      false;
+    #endif
 
-  const int8_t verbose_level = parser.byteval('V', 1);
-  if (!WITHIN(verbose_level, 0, 3)) {
-    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
+  const int8_t probe_points = set_up ? 2 : parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
+  if (!WITHIN(probe_points, -1, 10)) {
+    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (-1 - 10).");
     return;
   }
 
-  const float calibration_precision = parser.floatval('C', 0.0);
+  const bool towers_set = !parser.seen('T');
+
+  const float calibration_precision = set_up ? Z_CLEARANCE_BETWEEN_PROBES / 5.0 : parser.floatval('C', 0.0);
   if (calibration_precision < 0) {
     SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
-    SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
+    SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0 - 30).");
+    return;
+  }
+
+  const int8_t verbose_level = parser.byteval('V', 1);
+  if (!WITHIN(verbose_level, 0, 3)) {
+    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0 - 3).");
     return;
   }
 
-  const bool towers_set           = !parser.boolval('T'),
-             auto_tune            = parser.boolval('A'),
-             stow_after_each      = parser.boolval('E'),
-             _0p_calibration      = probe_points == 0,
-             _1p_calibration      = probe_points == 1,
+  const bool stow_after_each = parser.seen('E');
+
+  if (set_up) {
+    delta_height = 999.99;
+    delta_radius = DELTA_PRINTABLE_RADIUS;
+    ZERO(delta_endstop_adj);
+    ZERO(delta_tower_angle_trim);
+    recalc_delta_settings();
+  }
+
+  const bool _0p_calibration      = probe_points == 0,
+             _1p_calibration      = probe_points == 1 || probe_points == -1,
              _4p_calibration      = probe_points == 2,
-             _7p_9_centre         = probe_points >= 8,
-             _tower_results       = (_4p_calibration && towers_set)
-                                    || probe_points >= 3 || probe_points == 0,
-             _opposite_results    = (_4p_calibration && !towers_set)
-                                    || probe_points >= 3 || probe_points == 0,
-             _endstop_results     = probe_points != 1,
-             _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
+             _4p_opposite_points  = _4p_calibration && !towers_set,
+             _7p_9_center         = probe_points >= 8,
+             _tower_results       = (_4p_calibration && towers_set) || probe_points >= 3,
+             _opposite_results    = (_4p_calibration && !towers_set) || probe_points >= 3,
+             _endstop_results     = probe_points != 1 && probe_points != -1 && probe_points != 0,
+             _angle_results       = probe_points >= 3  && towers_set;
   const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
+        zero_std_dev_old = zero_std_dev,
+        h_factor,
+        r_factor,
+        a_factor,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
-        dr_old = delta_radius,
-        zh_old = delta_height,
-        ta_old[ABC] = {
+        r_old = delta_radius,
+        h_old = delta_height,
+        a_old[ABC] = {
           delta_tower_angle_trim[A_AXIS],
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
   SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
-  if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
+  if (!_1p_calibration && !_0p_calibration) { // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
-                  r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
+                  r = delta_calibration_radius;
       if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
-  stepper.synchronize();
-  #if HAS_LEVELING
-    reset_bed_level(); // After calibration bed-level data is no longer valid
-  #endif
-
-  #if HOTENDS > 1
-    const uint8_t old_tool_index = active_extruder;
-    tool_change(0, 0, true);
-    #define G33_CLEANUP() G33_cleanup(old_tool_index)
-  #else
-    #define G33_CLEANUP() G33_cleanup()
-  #endif
-
-  setup_for_endstop_or_probe_move();
-  endstops.enable(true);
-  if (!_0p_calibration) {
-    if (!home_delta())
-      return;
-    endstops.not_homing();
-  }
-
-  if (auto_tune) {
-    #if HAS_BED_PROBE
-      G33_auto_tune();
-    #else
-      SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
-    #endif
-    G33_CLEANUP();
-    return;
-  }
-
   // Report settings
 
-  PGM_P checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
+  const char *checkingac = PSTR("Checking... AC");
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
+  if (set_up) SERIAL_PROTOCOLPGM("  (SET-UP)");
   SERIAL_EOL();
-  lcd_setstatusPGM(checkingac);
+  char mess[11];
+  strcpy_P(mess, checkingac);
+  lcd_setstatus(mess);
 
-  print_G33_settings(_endstop_results, _angle_results);
+  print_calibration_settings(_endstop_results, _angle_results);
 
-  do {
+  ac_setup(!_0p_calibration && !_1p_calibration);
 
-    float z_at_pt[NPP + 1] = { 0.0 };
+  if (!_0p_calibration)
+    if (!ac_home()) return;
+
+  do { // start iterations
 
-    test_precision = zero_std_dev;
+    float z_at_pt[NPP + 1] = { 0.0 };
 
+    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
     iterations++;
 
     // Probe the points
-
-    zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
-    if (isnan(zero_std_dev)) {
-      SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
-      SERIAL_EOL();
-      return G33_CLEANUP();
+    zero_std_dev_old = zero_std_dev;
+    if (!probe_calibration_points(z_at_pt, probe_points, towers_set, stow_after_each, set_up)) {
+      SERIAL_PROTOCOLLNPGM("Correct delta settings with M665 and M666");
+      return AC_CLEANUP();
     }
+    zero_std_dev = std_dev_points(z_at_pt, _0p_calibration, _1p_calibration, _4p_calibration, _4p_opposite_points);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
+
+      #if !HAS_BED_PROBE
+        test_precision = 0.00; // forced end
+      #endif
+
       if (zero_std_dev < zero_std_dev_min) {
+        // set roll-back point
         COPY(e_old, delta_endstop_adj);
-        dr_old = delta_radius;
-        zh_old = delta_height;
-        COPY(ta_old, delta_tower_angle_trim);
+        r_old = delta_radius;
+        h_old = delta_height;
+        COPY(a_old, delta_tower_angle_trim);
       }
 
-      float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
-      const float r_diff = delta_radius - delta_calibration_radius,
-                  h_factor = 1 / 6.0 *
-                    #ifdef H_FACTOR
-                      (H_FACTOR),                                       // Set in Configuration.h
-                    #else
-                      (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
-                    #endif
-                  r_factor = 1 / 6.0 *
-                    #ifdef R_FACTOR
-                      -(R_FACTOR),                                      // Set in Configuration.h
-                    #else
-                      -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
-                    #endif
-                  a_factor = 1 / 6.0 *
-                    #ifdef A_FACTOR
-                      (A_FACTOR);                                       // Set in Configuration.h
-                    #else
-                      (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
-                    #endif
-
-      #define ZP(N,I) ((N) * z_at_pt[I])
-      #define Z6(I) ZP(6, I)
+      float e_delta[ABC] = { 0.0 },
+            r_delta = 0.0,
+            t_delta[ABC] = { 0.0 };
+
+      /**
+       * convergence matrices:
+       * see https://github.com/LVD-AC/Marlin-AC/tree/1.1.x-AC/documentation for
+       *  - definition of the matrix scaling parameters
+       *  - matrices for 4 and 7 point calibration
+       */
+      #define ZP(N,I) ((N) * z_at_pt[I] / 4.0) // 4.0 = divider to normalize to integers
+      #define Z12(I) ZP(12, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
+      #define Z0(I) ZP(0, I)
 
-      #if !HAS_BED_PROBE
-        test_precision = 0.00; // forced end
-      #endif
+      // calculate factors
+      const float cr_old = delta_calibration_radius;
+      if (_7p_9_center) delta_calibration_radius *= 0.9;
+      h_factor = auto_tune_h();
+      r_factor = auto_tune_r();
+      a_factor = auto_tune_a();
+      delta_calibration_radius = cr_old;
 
       switch (probe_points) {
+        case -1:
+          #if HAS_BED_PROBE
+            zprobe_zoffset += probe_z_shift(z_at_pt[CEN]);
+          #endif
+
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
-          LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
+          LOOP_XYZ(axis) e_delta[axis] = +Z4(CEN);
           break;
 
         case 2:
-          if (towers_set) {
-            e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
-            e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
-            e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
-            r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
+          if (towers_set) { // see 4 point calibration (towers) matrix
+            e_delta[A_AXIS] = (+Z4(__A) -Z2(__B) -Z2(__C)) * h_factor  +Z4(CEN);
+            e_delta[B_AXIS] = (-Z2(__A) +Z4(__B) -Z2(__C)) * h_factor  +Z4(CEN);
+            e_delta[C_AXIS] = (-Z2(__A) -Z2(__B) +Z4(__C)) * h_factor  +Z4(CEN);
+            r_delta         = (+Z4(__A) +Z4(__B) +Z4(__C) -Z12(CEN)) * r_factor;
           }
-          else {
-            e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
-            e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
-            e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
-            r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
+          else { // see 4 point calibration (opposites) matrix
+            e_delta[A_AXIS] = (-Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor  +Z4(CEN);
+            e_delta[B_AXIS] = (+Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor  +Z4(CEN);
+            e_delta[C_AXIS] = (+Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor  +Z4(CEN);
+            r_delta         = (+Z4(_BC) +Z4(_CA) +Z4(_AB) -Z12(CEN)) * r_factor;
           }
           break;
 
-        default:
-          e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
-          e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
-          e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
-          r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
-
-          if (towers_set) {
-            t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
-            t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
-            t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
-            e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
-            e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
-            e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
+        default: // see 7 point calibration (towers & opposites) matrix
+          e_delta[A_AXIS] = (+Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor  +Z4(CEN);
+          e_delta[B_AXIS] = (-Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor  +Z4(CEN);
+          e_delta[C_AXIS] = (-Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor  +Z4(CEN);
+          r_delta         = (+Z2(__A) +Z2(__B) +Z2(__C) +Z2(_BC) +Z2(_CA) +Z2(_AB) -Z12(CEN)) * r_factor;
+
+          if (towers_set) { // see 7 point tower angle calibration (towers & opposites) matrix
+            t_delta[A_AXIS] = (+Z0(__A) -Z4(__B) +Z4(__C) +Z0(_BC) -Z4(_CA) +Z4(_AB) +Z0(CEN)) * a_factor;
+            t_delta[B_AXIS] = (+Z4(__A) +Z0(__B) -Z4(__C) +Z4(_BC) +Z0(_CA) -Z4(_AB) +Z0(CEN)) * a_factor;
+            t_delta[C_AXIS] = (-Z4(__A) +Z4(__B) +Z0(__C) -Z4(_BC) +Z4(_CA) +Z0(_AB) +Z0(CEN)) * a_factor;
           }
           break;
       }
-
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
     }
-    else if (zero_std_dev >= test_precision) {   // step one back
+    else if (zero_std_dev >= test_precision) {
+      // roll back
       COPY(delta_endstop_adj, e_old);
-      delta_radius = dr_old;
-      delta_height = zh_old;
-      COPY(delta_tower_angle_trim, ta_old);
+      delta_radius = r_old;
+      delta_height = h_old;
+      COPY(delta_tower_angle_trim, a_old);
     }
 
     if (verbose_level != 0) {                                    // !dry run
+
       // normalise angles to least squares
       if (_angle_results) {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
-    if (verbose_level > 2)
-      print_G33_results(z_at_pt, _tower_results, _opposite_results);
+    if (verbose_level == 3)
+      print_calibration_results(z_at_pt, _tower_results, _opposite_results);
 
-    if (verbose_level != 0) {                                    // !dry run
-      if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
+    if (verbose_level != 0) { // !dry run
+      if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) { // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");
         SERIAL_PROTOCOL_SP(32);
         #if HAS_BED_PROBE
-          if (zero_std_dev >= test_precision && !_1p_calibration)
+          if (zero_std_dev >= test_precision && !_1p_calibration && !_0p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
         lcd_setstatus(mess);
-        print_G33_settings(_endstop_results, _angle_results);
+        print_calibration_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
-      else {                                                     // !end iterations
+      else { // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
         if (verbose_level > 1)
-          print_G33_settings(_endstop_results, _angle_results);
+          print_calibration_settings(_endstop_results, _angle_results);
       }
     }
-    else {                                                       // dry run
-      PGM_P enddryrun = PSTR("End DRY-RUN");
+    else { // dry run
+      const char *enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
       lcd_setstatus(mess);
     }
-
-    endstops.enable(true);
-    if (!home_delta())
-      return;
-    endstops.not_homing();
-
+    if (!ac_home()) return;
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
-  G33_CLEANUP();
+  AC_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit ac2e0afb62bd201608e27e5ef5e0d4ccc5ac9fe5
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Thu Apr 12 01:59:46 2018 +0200

    Low Point for delta calibration (#10363)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 72f4a01067..036b3425f3 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -130,21 +130,21 @@ static void G33_cleanup(
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
 inline float calibration_probe(const float nx, const float ny, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
+    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
 static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,

commit 8b8ad14178374c06858444434988291993903fbb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 9 01:46:23 2018 -0500

    Add Z_PROBE_LOW_POINT to prevent damage

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 036b3425f3..72f4a01067 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -130,21 +130,21 @@ static void G33_cleanup(
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
 inline float calibration_probe(const float nx, const float ny, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
+    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, true);
   #else
     UNUSED(stow);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
 static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,

commit c352954882bc931377ece338b3f5fa459c55ea07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:01:43 2018 -0500

    Allow no raise after run_z_probe in probe_pt

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 626ba24c5a..036b3425f3 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -130,21 +130,21 @@ static void G33_cleanup(
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
 inline float calibration_probe(const float nx, const float ny, const bool stow) {
   #if HAS_BED_PROBE
-    return probe_pt(nx, ny, stow, 0, false);
+    return probe_pt(nx, ny, stow ? PROBE_PT_STOW : PROBE_PT_RAISE, 0, false);
   #else
     UNUSED(stow);
     return lcd_probe_pt(nx, ny);
   #endif
 }
 
 static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,

commit 8922b56b588bc9c54c3526986b8a056564828abd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 16 01:25:32 2018 -0500

    Fix some spelingz

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 63ddbb2018..626ba24c5a 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -363,29 +363,29 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *      P0     No probe. Normalize only.
  *      P1     Probe center and set height only.
  *      P2     Probe center and towers. Set height, endstops and delta radius.
  *      P3     Probe all positions: center, towers and opposite towers. Set all.
- *      P4-P10 Probe all positions + at different itermediate locations and average them.
+ *      P4-P10 Probe all positions + at different intermediate locations and average them.
  *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
- *   Fn  Force to run at least n iterations and takes the best result
+ *   Fn  Force to run at least n iterations and take the best result
  *
- *   A   Auto tune calibartion factors (set in Configuration.h)
+ *   A   Auto-tune calibration factors (set in Configuration.h)
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report start and end settings only
  *      V2  Report settings at each iteration
  *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ddd74a4721..63ddbb2018 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -36,21 +36,21 @@
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
                   _4P_STEP = _7P_STEP * 2,   // 4-point step
                   NPP      = _7P_STEP * 6;   // number of calibration points on the radius
-enum CalEnum {                               // the 7 main calibration points - add definitions if needed
+enum CalEnum : char {                               // the 7 main calibration points - add definitions if needed
   CEN      = 0,
   __A      = 1,
   _AB      = __A + _7P_STEP,
   __B      = _AB + _7P_STEP,
   _BC      = __B + _7P_STEP,
   __C      = _BC + _7P_STEP,
   _CA      = __C + _7P_STEP,
 };
 
 #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)

commit 6d94bbf6186baa87fecc40b6d131c8d489c69e73
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 30 04:03:17 2017 -0600

    Apply some PGM_P pointers

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index b8834efda8..ddd74a4721 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -484,21 +484,21 @@ void GcodeSuite::G33() {
       G33_auto_tune();
     #else
       SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
     #endif
     G33_CLEANUP();
     return;
   }
 
   // Report settings
 
-  const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
+  PGM_P checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_G33_settings(_endstop_results, _angle_results);
 
   do {
 
     float z_at_pt[NPP + 1] = { 0.0 };
@@ -666,21 +666,21 @@ void GcodeSuite::G33() {
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
         if (verbose_level > 1)
           print_G33_settings(_endstop_results, _angle_results);
       }
     }
     else {                                                       // dry run
-      const char *enddryrun = PSTR("End DRY-RUN");
+      PGM_P enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       strcpy_P(mess, enddryrun);
       strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)

commit b35c3b5eb8ac1906e76c02dbf4599463783e2359
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Fri Dec 1 21:29:16 2017 -0600

    Fix missing return values in G33_auto_tune

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ec260ff4a4..b8834efda8 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -247,21 +247,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
     SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
     SERIAL_EOL();
     if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
     print_G33_results(z_at_pt_base, true, true);
 
     LOOP_XYZ(axis) {
       delta_endstop_adj[axis] -= 1.0;
       recalc_delta_settings();
 
       endstops.enable(true);
-      if (!home_delta()) return;
+      if (!home_delta()) return false;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning E");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_endstop_adj[axis] += 1.0;
@@ -279,21 +279,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       }
     }
     h_fac /= 3.0;
     h_fac *= norm; // Normalize to 1.02 for Kossel mini
 
     for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
       delta_radius += 1.0 * zig_zag;
       recalc_delta_settings();
 
       endstops.enable(true);
-      if (!home_delta()) return;
+      if (!home_delta()) return false;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning R");
       SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
       SERIAL_EOL();
       if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_radius -= 1.0 * zig_zag;
       recalc_delta_settings();
@@ -305,21 +305,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
     LOOP_XYZ(axis) {
       delta_tower_angle_trim[axis] += 1.0;
       delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
       delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings();
 
       endstops.enable(true);
-      if (!home_delta()) return;
+      if (!home_delta()) return false;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
 
@@ -339,21 +339,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
           break;
         case C_AXIS :
           a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
           break;
       }
     }
     a_fac /= 3.0;
     a_fac *= norm; // Normalize to 0.83 for Kossel mini
 
     endstops.enable(true);
-    if (!home_delta()) return;
+    if (!home_delta()) return false;
     endstops.not_homing();
     print_signed_float(PSTR( "H_FACTOR: "), h_fac);
     print_signed_float(PSTR(" R_FACTOR: "), r_fac);
     print_signed_float(PSTR(" A_FACTOR: "), a_fac);
     SERIAL_EOL();
     SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
     SERIAL_EOL();
     return true;
   }
 

commit 65f365333ff15b93ddbe16db18b119c717a6f7bc
Author: LVD-AC <lvd@sound-silence.com>
Date:   Sat Nov 25 10:59:46 2017 +0100

    [2.0.x] G33 probe error handling

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 06240eb300..ec260ff4a4 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -128,99 +128,88 @@ static void G33_cleanup(
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
+inline float calibration_probe(const float nx, const float ny, const bool stow) {
+  #if HAS_BED_PROBE
+    return probe_pt(nx, ny, stow, 0, false);
+  #else
+    UNUSED(stow);
+    return lcd_probe_pt(nx, ny);
+  #endif
+}
+
 static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3 || probe_points == 0,
              _7p_no_intermediates = probe_points == 3,
              _7p_1_intermediates  = probe_points == 4,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
              _7p_8_intermediates  = probe_points == 8,
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
              _7p_9_centre         = probe_points >= 8;
 
-  #if HAS_BED_PROBE
-    const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
-                dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
-  #endif
-
   LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
-      z_at_pt[CEN] +=
-        #if HAS_BED_PROBE
-          probe_pt(dx, dy, stow_after_each, 1, false)
-        #else
-          lcd_probe_pt(0, 0)
-        #endif
-      ;
+      z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
+      if (isnan(z_at_pt[CEN])) return NAN;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
                   steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(axis, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                     r = delta_calibration_radius * 0.1;
-        z_at_pt[CEN] +=
-          #if HAS_BED_PROBE
-            probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1, false)
-          #else
-            lcd_probe_pt(cos(a) * r, sin(a) * r)
-          #endif
-        ;
-      }
+        z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
+        if (isnan(z_at_pt[CEN])) return NAN;
+     }
       z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
                              _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
                              _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
                              _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
         const int8_t offset = _7p_9_centre ? 1 : 0;
         for (int8_t circle = -offset; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                       r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
-                      interpol = FMOD(axis, 1);
-          const float z_temp =
-            #if HAS_BED_PROBE
-              probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1, false)
-            #else
-              lcd_probe_pt(cos(a) * r, sin(a) * r)
-            #endif
-          ;
+                      interpol = fmod(axis, 1);
+          const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
+          if (isnan(z_temp)) return NAN;
           // split probe point to neighbouring calibration points
           z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(axis)
           z_at_pt[axis] /= _7P_STEP / steps;
     }
@@ -236,50 +225,50 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       }
       return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
     }
   }
 
   return 0.00001;
 }
 
 #if HAS_BED_PROBE
 
-  static void G33_auto_tune() {
+  static bool G33_auto_tune() {
     float z_at_pt[NPP + 1]      = { 0.0 },
           z_at_pt_base[NPP + 1] = { 0.0 },
           z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
 
     #define ZP(N,I) ((N) * z_at_pt[I])
     #define Z06(I)  ZP(6, I)
     #define Z03(I)  ZP(3, I)
     #define Z02(I)  ZP(2, I)
     #define Z01(I)  ZP(1, I)
     #define Z32(I)  ZP(3/2, I)
 
     SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
     SERIAL_EOL();
-    probe_G33_points(z_at_pt_base, 3, true, false);
+    if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
     print_G33_results(z_at_pt_base, true, true);
 
     LOOP_XYZ(axis) {
       delta_endstop_adj[axis] -= 1.0;
       recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning E");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
-      probe_G33_points(z_at_pt, 3, true, false);
+      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_endstop_adj[axis] += 1.0;
       recalc_delta_settings();
       switch (axis) {
         case A_AXIS :
           h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
           break;
         case B_AXIS :
           h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
@@ -296,21 +285,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       delta_radius += 1.0 * zig_zag;
       recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning R");
       SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
       SERIAL_EOL();
-      probe_G33_points(z_at_pt, 3, true, false);
+      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_radius -= 1.0 * zig_zag;
       recalc_delta_settings();
       r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
     }
     r_fac /= 2.0;
     r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
 
     LOOP_XYZ(axis) {
@@ -323,21 +312,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
-      probe_G33_points(z_at_pt, 3, true, false);
+      if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings();
@@ -358,20 +347,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
 
     endstops.enable(true);
     if (!home_delta()) return;
     endstops.not_homing();
     print_signed_float(PSTR( "H_FACTOR: "), h_fac);
     print_signed_float(PSTR(" R_FACTOR: "), r_fac);
     print_signed_float(PSTR(" A_FACTOR: "), a_fac);
     SERIAL_EOL();
     SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
     SERIAL_EOL();
+    return true;
   }
 
 #endif // HAS_BED_PROBE
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
@@ -385,40 +375,41 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and takes the best result
  *
  *   A   Auto tune calibartion factors (set in Configuration.h)
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
- *      V1  Report settings
- *      V2  Report settings and probe results
+ *      V1  Report start and end settings only
+ *      V2  Report settings at each iteration
+ *      V3  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 10)) {
     SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
-  if (!WITHIN(verbose_level, 0, 2)) {
-    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
+  if (!WITHIN(verbose_level, 0, 3)) {
+    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
     return;
   }
 
-  const float calibration_precision = parser.floatval('C');
+  const float calibration_precision = parser.floatval('C', 0.0);
   if (calibration_precision < 0) {
     SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
@@ -512,20 +503,25 @@ void GcodeSuite::G33() {
 
     float z_at_pt[NPP + 1] = { 0.0 };
 
     test_precision = zero_std_dev;
 
     iterations++;
 
     // Probe the points
 
     zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
+    if (isnan(zero_std_dev)) {
+      SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
+      SERIAL_EOL();
+      return G33_CLEANUP();
+    }
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
       if (zero_std_dev < zero_std_dev_min) {
         COPY(e_old, delta_endstop_adj);
         dr_old = delta_radius;
         zh_old = delta_height;
         COPY(ta_old, delta_tower_angle_trim);
       }
@@ -625,21 +621,21 @@ void GcodeSuite::G33() {
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
-    if (verbose_level != 1)
+    if (verbose_level > 2)
       print_G33_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) {                                    // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");
         SERIAL_PROTOCOL_SP(32);
         #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
@@ -665,21 +661,22 @@ void GcodeSuite::G33() {
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           strcpy_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
-        print_G33_settings(_endstop_results, _angle_results);
+        if (verbose_level > 1)
+          print_G33_settings(_endstop_results, _angle_results);
       }
     }
     else {                                                       // dry run
       const char *enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 

commit e334efb2a7914b6a39fb3c060790319664d98b2d
Author: LVD-AC <lvd@sound-silence.com>
Date:   Wed Nov 8 10:07:17 2017 +0100

    PROBE_MANUALLY etc.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 35f63e6a2b..06240eb300 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -173,21 +173,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
                   steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(axis, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                     r = delta_calibration_radius * 0.1;
         z_at_pt[CEN] +=
           #if HAS_BED_PROBE
-            probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+            probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1, false)
           #else
             lcd_probe_pt(cos(a) * r, sin(a) * r)
           #endif
         ;
       }
       z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
@@ -202,37 +202,36 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
         const int8_t offset = _7p_9_centre ? 1 : 0;
         for (int8_t circle = -offset; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                       r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
                       interpol = FMOD(axis, 1);
           const float z_temp =
             #if HAS_BED_PROBE
-              probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+              probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1, false)
             #else
               lcd_probe_pt(cos(a) * r, sin(a) * r)
             #endif
           ;
           // split probe point to neighbouring calibration points
           z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(axis)
           z_at_pt[axis] /= _7P_STEP / steps;
     }
 
-
     float S1 = z_at_pt[CEN],
           S2 = sq(z_at_pt[CEN]);
     int16_t N = 1;
     if (!_1p_calibration) { // std dev from zero plane
       LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
         N++;
       }
       return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
@@ -256,97 +255,99 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
     #define Z01(I)  ZP(1, I)
     #define Z32(I)  ZP(3/2, I)
 
     SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
     SERIAL_EOL();
     probe_G33_points(z_at_pt_base, 3, true, false);
     print_G33_results(z_at_pt_base, true, true);
 
     LOOP_XYZ(axis) {
       delta_endstop_adj[axis] -= 1.0;
+      recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning E");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_endstop_adj[axis] += 1.0;
+      recalc_delta_settings();
       switch (axis) {
         case A_AXIS :
           h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
           break;
         case B_AXIS :
           h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
           break;
         case C_AXIS :
           h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
           break;
       }
     }
     h_fac /= 3.0;
     h_fac *= norm; // Normalize to 1.02 for Kossel mini
 
     for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
       delta_radius += 1.0 * zig_zag;
-      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning R");
       SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
       SERIAL_EOL();
       probe_G33_points(z_at_pt, 3, true, false);
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_radius -= 1.0 * zig_zag;
-      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      recalc_delta_settings();
       r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
     }
     r_fac /= 2.0;
     r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
 
     LOOP_XYZ(axis) {
       delta_tower_angle_trim[axis] += 1.0;
       delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
       delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
-      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      recalc_delta_settings();
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
-      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      recalc_delta_settings();
       switch (axis) {
         case A_AXIS :
           a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
           break;
         case B_AXIS :
           a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
           break;
         case C_AXIS :
           a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
           break;
@@ -619,21 +620,21 @@ void GcodeSuite::G33() {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
-    recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+    recalc_delta_settings();
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level != 1)
       print_G33_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) {                                    // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");

commit f34c3597dcaef54624c82f732f13151215bbe650
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Wed Nov 8 22:10:08 2017 -0600

    Add delta_height variable in lieu of using home_offset

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 5149a09391..35f63e6a2b 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -62,21 +62,21 @@ enum CalEnum {                               // the 7 main calibration points -
 
 static void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
 static void print_G33_settings(const bool end_stops, const bool tower_angles) {
-  SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+  SERIAL_PROTOCOLPAIR(".Height:", delta_height);
   if (end_stops) {
     print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
     print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
     print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   }
   if (end_stops && tower_angles) {
     SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_PROTOCOL_SP(13);
@@ -310,41 +310,41 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
     }
     r_fac /= 2.0;
     r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
 
     LOOP_XYZ(axis) {
       delta_tower_angle_trim[axis] += 1.0;
       delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
       delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      home_offset[Z_AXIS] -= z_temp;
+      delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
       LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      home_offset[Z_AXIS] -= z_temp;
+      delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
       switch (axis) {
         case A_AXIS :
           a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
           break;
         case B_AXIS :
           a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
           break;
         case C_AXIS :
@@ -439,21 +439,21 @@ void GcodeSuite::G33() {
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
         dr_old = delta_radius,
-        zh_old = home_offset[Z_AXIS],
+        zh_old = delta_height,
         ta_old[ABC] = {
           delta_tower_angle_trim[A_AXIS],
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
   SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
@@ -518,21 +518,21 @@ void GcodeSuite::G33() {
     // Probe the points
 
     zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
       if (zero_std_dev < zero_std_dev_min) {
         COPY(e_old, delta_endstop_adj);
         dr_old = delta_radius;
-        zh_old = home_offset[Z_AXIS];
+        zh_old = delta_height;
         COPY(ta_old, delta_tower_angle_trim);
       }
 
       float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
       const float r_diff = delta_radius - delta_calibration_radius,
                   h_factor = 1 / 6.0 *
                     #ifdef H_FACTOR
                       (H_FACTOR),                                       // Set in Configuration.h
                     #else
                       (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
@@ -602,35 +602,35 @@ void GcodeSuite::G33() {
           break;
       }
 
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
     }
     else if (zero_std_dev >= test_precision) {   // step one back
       COPY(delta_endstop_adj, e_old);
       delta_radius = dr_old;
-      home_offset[Z_AXIS] = zh_old;
+      delta_height = zh_old;
       COPY(delta_tower_angle_trim, ta_old);
     }
 
     if (verbose_level != 0) {                                    // !dry run
       // normalise angles to least squares
       if (_angle_results) {
         float a_sum = 0.0;
         LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
         LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
       }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      home_offset[Z_AXIS] -= z_temp;
+      delta_height -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level != 1)
       print_G33_results(z_at_pt, _tower_results, _opposite_results);
 

commit 82f45c3e6ad00a2f8cc60f0a1f7297958c98637f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 7 19:34:34 2017 -0600

    Patch G33 misuse of PROBE_MANUALLY

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 48511ef188..5149a09391 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -146,50 +146,50 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
              _7p_2_intermediates  = probe_points == 5,
              _7p_4_intermediates  = probe_points == 6,
              _7p_6_intermediates  = probe_points == 7,
              _7p_8_intermediates  = probe_points == 8,
              _7p_11_intermediates = probe_points == 9,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
              _7p_9_centre         = probe_points >= 8;
 
-  #if DISABLED(PROBE_MANUALLY)
+  #if HAS_BED_PROBE
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
   LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       z_at_pt[CEN] +=
-        #if ENABLED(PROBE_MANUALLY)
-          lcd_probe_pt(0, 0)
-        #else
+        #if HAS_BED_PROBE
           probe_pt(dx, dy, stow_after_each, 1, false)
+        #else
+          lcd_probe_pt(0, 0)
         #endif
       ;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
                   steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(axis, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                     r = delta_calibration_radius * 0.1;
         z_at_pt[CEN] +=
-          #if ENABLED(PROBE_MANUALLY)
-            lcd_probe_pt(cos(a) * r, sin(a) * r)
-          #else
+          #if HAS_BED_PROBE
             probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+          #else
+            lcd_probe_pt(cos(a) * r, sin(a) * r)
           #endif
         ;
       }
       z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
@@ -201,24 +201,24 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
         const int8_t offset = _7p_9_centre ? 1 : 0;
         for (int8_t circle = -offset; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                       r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
                       interpol = FMOD(axis, 1);
           const float z_temp =
-            #if ENABLED(PROBE_MANUALLY)
-              lcd_probe_pt(cos(a) * r, sin(a) * r)
-            #else
+            #if HAS_BED_PROBE
               probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+            #else
+              lcd_probe_pt(cos(a) * r, sin(a) * r)
             #endif
           ;
           // split probe point to neighbouring calibration points
           z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
           z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
         LOOP_CAL_RAD(axis)
@@ -235,21 +235,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
         S2 += sq(z_at_pt[axis]);
         N++;
       }
       return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
     }
   }
 
   return 0.00001;
 }
 
-#if DISABLED(PROBE_MANUALLY)
+#if HAS_BED_PROBE
 
   static void G33_auto_tune() {
     float z_at_pt[NPP + 1]      = { 0.0 },
           z_at_pt_base[NPP + 1] = { 0.0 },
           z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
 
     #define ZP(N,I) ((N) * z_at_pt[I])
     #define Z06(I)  ZP(6, I)
     #define Z03(I)  ZP(3, I)
     #define Z02(I)  ZP(2, I)
@@ -359,21 +359,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
     if (!home_delta()) return;
     endstops.not_homing();
     print_signed_float(PSTR( "H_FACTOR: "), h_fac);
     print_signed_float(PSTR(" R_FACTOR: "), r_fac);
     print_signed_float(PSTR(" A_FACTOR: "), a_fac);
     SERIAL_EOL();
     SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
     SERIAL_EOL();
   }
 
-#endif // !PROBE_MANUALLY
+#endif // HAS_BED_PROBE
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *      P0     No probe. Normalize only.
  *      P1     Probe center and set height only.
@@ -481,24 +481,24 @@ void GcodeSuite::G33() {
 
   setup_for_endstop_or_probe_move();
   endstops.enable(true);
   if (!_0p_calibration) {
     if (!home_delta())
       return;
     endstops.not_homing();
   }
 
   if (auto_tune) {
-    #if ENABLED(PROBE_MANUALLY)
-      SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
-    #else
+    #if HAS_BED_PROBE
       G33_auto_tune();
+    #else
+      SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
     #endif
     G33_CLEANUP();
     return;
   }
 
   // Report settings
 
   const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
@@ -549,21 +549,21 @@ void GcodeSuite::G33() {
                     #else
                       (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
                     #endif
 
       #define ZP(N,I) ((N) * z_at_pt[I])
       #define Z6(I) ZP(6, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
 
-      #if ENABLED(PROBE_MANUALLY)
+      #if !HAS_BED_PROBE
         test_precision = 0.00; // forced end
       #endif
 
       switch (probe_points) {
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
@@ -631,21 +631,21 @@ void GcodeSuite::G33() {
 
     // print report
 
     if (verbose_level != 1)
       print_G33_results(z_at_pt, _tower_results, _opposite_results);
 
     if (verbose_level != 0) {                                    // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");
         SERIAL_PROTOCOL_SP(32);
-        #if DISABLED(PROBE_MANUALLY)
+        #if HAS_BED_PROBE
           if (zero_std_dev >= test_precision && !_1p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];

commit 96c9d715f37b72507556032cd1a4dfbc9364d755
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 7 17:33:33 2017 -0600

    Patch abuse of sprintf_P in G33

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 3cf09fea57..48511ef188 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -642,56 +642,56 @@ void GcodeSuite::G33() {
           if (zero_std_dev >= test_precision && !_1p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
-        sprintf_P(mess, PSTR("Calibration sd:"));
+        strcpy_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
         lcd_setstatus(mess);
         print_G33_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else {                                                     // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
-          sprintf_P(mess, PSTR("No convergence"));
+          strcpy_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
         SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
         print_G33_settings(_endstop_results, _angle_results);
       }
     }
     else {                                                       // dry run
       const char *enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
       SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
-      sprintf_P(mess, enddryrun);
-      sprintf_P(&mess[11], PSTR(" sd:"));
+      strcpy_P(mess, enddryrun);
+      strcpy_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
       lcd_setstatus(mess);
     }
 
     endstops.enable(true);
     if (!home_delta())
       return;

commit a22434508f98eead87560536aaec331cd8293a5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 18:19:14 2017 -0500

    Match tweaks to G33 from 1.1

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 037e133d99..3cf09fea57 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -156,38 +156,42 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
   #if DISABLED(PROBE_MANUALLY)
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
   LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
-      #if ENABLED(PROBE_MANUALLY)
-        z_at_pt[CEN] += lcd_probe_pt(0, 0);
-      #else
-        z_at_pt[CEN] += probe_pt(dx, dy, stow_after_each, 1, false);
-      #endif
+      z_at_pt[CEN] +=
+        #if ENABLED(PROBE_MANUALLY)
+          lcd_probe_pt(0, 0)
+        #else
+          probe_pt(dx, dy, stow_after_each, 1, false)
+        #endif
+      ;
     }
 
     if (_7p_calibration) { // probe extra center points
       const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
                   steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
       I_LOOP_CAL_PT(axis, start, steps) {
         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                     r = delta_calibration_radius * 0.1;
-        #if ENABLED(PROBE_MANUALLY)
-          z_at_pt[CEN] += lcd_probe_pt(cos(a) * r, sin(a) * r);
-        #else
-          z_at_pt[CEN] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-        #endif
+        z_at_pt[CEN] +=
+          #if ENABLED(PROBE_MANUALLY)
+            lcd_probe_pt(cos(a) * r, sin(a) * r)
+          #else
+            probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+          #endif
+        ;
       }
       z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49

commit 79772219aeb0531cccfa7eb73cea246ceb6dbb6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 21:01:41 2017 -0500

    Fix Fan Multiplexer init

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 9deab69982..037e133d99 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -23,23 +23,26 @@
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DELTA_AUTO_CALIBRATION)
 
 #include "../gcode.h"
 #include "../../module/delta.h"
 #include "../../module/probe.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
-#include "../../module/tool_change.h"
 #include "../../lcd/ultralcd.h"
 
+#if HOTENDS > 1
+  #include "../../module/tool_change.h"
+#endif
+
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
                   _4P_STEP = _7P_STEP * 2,   // 4-point step
                   NPP      = _7P_STEP * 6;   // number of calibration points on the radius
 enum CalEnum {                               // the 7 main calibration points - add definitions if needed
   CEN      = 0,
   __A      = 1,

commit e0a6ee8da52b6db2b4d87f2f278a456d679df2c6
Author: Colten Edwards <cd.edwards@sasktel.net>
Date:   Sat Nov 4 17:04:18 2017 -0600

    [2.0] Fix up G33, LPC1768 + SDCARD_SORT_ALPHA (#8250)
    
    * Update Conditionals_post.h
    
    * Add a cast to round() to convert to a unsigned int
    
    Add's a cast to round() so that it will compile properly. round() returns a float which must be cast to a integer for the following % operation. Use a unsigned int as a negative index to an array is wrong. Should never be more than 255 points allowing us to use a 8 bit cast.
    
    * Update G33.cpp

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 937c4fb54d..9deab69982 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -148,21 +148,21 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
              _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
              _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
              _7p_9_centre         = probe_points >= 8;
 
   #if DISABLED(PROBE_MANUALLY)
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
-      LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
+  LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       #if ENABLED(PROBE_MANUALLY)
         z_at_pt[CEN] += lcd_probe_pt(0, 0);
       #else
         z_at_pt[CEN] += probe_pt(dx, dy, stow_after_each, 1, false);
       #endif
     }
@@ -192,44 +192,37 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
                              _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
                              _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
         const int8_t offset = _7p_9_centre ? 1 : 0;
         for (int8_t circle = -offset; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                       r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
-                      interpol = fmod(axis, 1);
-          #if ENABLED(PROBE_MANUALLY)
-             float z_temp = lcd_probe_pt(cos(a) * r, sin(a) * r);
-          #else
-            float z_temp = probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-          #endif
+                      interpol = FMOD(axis, 1);
+          const float z_temp =
+            #if ENABLED(PROBE_MANUALLY)
+              lcd_probe_pt(cos(a) * r, sin(a) * r)
+            #else
+              probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1)
+            #endif
+          ;
           // split probe point to neighbouring calibration points
-          z_at_pt[round(axis - interpol + NPP - 1) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
-          z_at_pt[round(axis - interpol) % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
+          z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
+          z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
       }
       if (_7p_intermed_points)
-        LOOP_CAL_RAD(axis) {
-/*
-        // average intermediate points to towers and opposites - only required with _7P_STEP >= 2
-          for (int8_t i = 1; i < _7P_STEP; i++) {
-            const float interpol = i * (1.0 / _7P_STEP);
-            z_at_pt[axis] += (z_at_pt[(axis + NPP - i - 1) % NPP + 1]
-                             + z_at_pt[axis + i]) * sq(cos(RADIANS(interpol * 90)));
-          }
-*/
-          z_at_pt[axis] /= _7P_STEP  / steps;
-        }
+        LOOP_CAL_RAD(axis)
+          z_at_pt[axis] /= _7P_STEP / steps;
     }
 
 
     float S1 = z_at_pt[CEN],
           S2 = sq(z_at_pt[CEN]);
     int16_t N = 1;
     if (!_1p_calibration) { // std dev from zero plane
       LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
@@ -335,28 +328,28 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
       switch (axis) {
         case A_AXIS :
-        a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
-        break;
+          a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
+          break;
         case B_AXIS :
-        a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
-        break;
+          a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
+          break;
         case C_AXIS :
-        a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
-        break;
+          a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
+          break;
       }
     }
     a_fac /= 3.0;
     a_fac *= norm; // Normalize to 0.83 for Kossel mini
 
     endstops.enable(true);
     if (!home_delta()) return;
     endstops.not_homing();
     print_signed_float(PSTR( "H_FACTOR: "), h_fac);
     print_signed_float(PSTR(" R_FACTOR: "), r_fac);

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index c477bcfa99..937c4fb54d 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -452,21 +452,21 @@ void GcodeSuite::G33() {
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
   SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
     LOOP_CAL_RAD(axis) {
       const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                   r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
-      if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
+      if (!position_is_reachable(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   stepper.synchronize();
   #if HAS_LEVELING
     reset_bed_level(); // After calibration bed-level data is no longer valid
   #endif

commit 31f112cf5872d826fd698691679330f83ee21ae3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 3 04:07:45 2017 -0500

    Cleanup trailing whitespace

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 3bf01a78eb..c477bcfa99 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -43,22 +43,22 @@ constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number
 enum CalEnum {                               // the 7 main calibration points - add definitions if needed
   CEN      = 0,
   __A      = 1,
   _AB      = __A + _7P_STEP,
   __B      = _AB + _7P_STEP,
   _BC      = __B + _7P_STEP,
   __C      = _BC + _7P_STEP,
   _CA      = __C + _7P_STEP,
 };
 
-#define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N) 
-#define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N) 
+#define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
+#define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
 #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
 #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
 #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
 #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
 
 static void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
@@ -182,22 +182,22 @@ static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points,
       z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       const CalEnum start  = _4p_opposite_points ? _AB : __A;
       const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
                              _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
                              _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
                              _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
                              _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
-                             _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25 
-                             _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16 
+                             _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
+                             _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
                              _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
                              _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
       F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
         const int8_t offset = _7p_9_centre ? 1 : 0;
         for (int8_t circle = -offset; circle <= offset; circle++) {
           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
                       r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
                       interpol = fmod(axis, 1);
           #if ENABLED(PROBE_MANUALLY)

commit 6827e243a0b4bd58249234eac36a0b7cfe1a7b4c
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Fri Nov 3 09:36:16 2017 +0100

    [2.0.x] G33 magic numbers (#8171)
    
    * [2.0.x] G33 magic numbers
    
    * oops
    
    * Comments
    
    * oops
    
    * warning
    
    * better comment section
    
    * remarks
    
    * extra grids

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index bd7fbe38b7..3bf01a78eb 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -30,20 +30,40 @@
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 #include "../../module/tool_change.h"
 #include "../../lcd/ultralcd.h"
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
+                  _4P_STEP = _7P_STEP * 2,   // 4-point step
+                  NPP      = _7P_STEP * 6;   // number of calibration points on the radius
+enum CalEnum {                               // the 7 main calibration points - add definitions if needed
+  CEN      = 0,
+  __A      = 1,
+  _AB      = __A + _7P_STEP,
+  __B      = _AB + _7P_STEP,
+  _BC      = __B + _7P_STEP,
+  __C      = _BC + _7P_STEP,
+  _CA      = __C + _7P_STEP,
+};
+
+#define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N) 
+#define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N) 
+#define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
+#define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
+#define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
+#define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
+
 static void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
 static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
@@ -62,37 +82,37 @@ static void print_G33_settings(const bool end_stops, const bool tower_angles) {
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   }
   if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
     SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   }
   SERIAL_EOL();
 }
 
-static void print_G33_results(const float z_at_pt[13], const bool tower_points, const bool opposite_points) {
+static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   SERIAL_PROTOCOLPGM(".    ");
-  print_signed_float(PSTR("c"), z_at_pt[0]);
+  print_signed_float(PSTR("c"), z_at_pt[CEN]);
   if (tower_points) {
-    print_signed_float(PSTR(" x"), z_at_pt[1]);
-    print_signed_float(PSTR(" y"), z_at_pt[5]);
-    print_signed_float(PSTR(" z"), z_at_pt[9]);
+    print_signed_float(PSTR(" x"), z_at_pt[__A]);
+    print_signed_float(PSTR(" y"), z_at_pt[__B]);
+    print_signed_float(PSTR(" z"), z_at_pt[__C]);
   }
   if (tower_points && opposite_points) {
     SERIAL_EOL();
     SERIAL_CHAR('.');
     SERIAL_PROTOCOL_SP(13);
   }
   if (opposite_points) {
-    print_signed_float(PSTR("yz"), z_at_pt[7]);
-    print_signed_float(PSTR("zx"), z_at_pt[11]);
-    print_signed_float(PSTR("xy"), z_at_pt[3]);
+    print_signed_float(PSTR("yz"), z_at_pt[_BC]);
+    print_signed_float(PSTR("zx"), z_at_pt[_CA]);
+    print_signed_float(PSTR("xy"), z_at_pt[_AB]);
   }
   SERIAL_EOL();
 }
 
 /**
  * After G33:
  *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
  *  - Stow the probe
  *  - Restore endstops state
  *  - Select the old tool, if needed
@@ -105,109 +125,135 @@ static void G33_cleanup(
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
-static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
+static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   const bool _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3 || probe_points == 0,
-             _7p_half_circle      = probe_points == 3,
-             _7p_double_circle    = probe_points == 5,
-             _7p_triple_circle    = probe_points == 6,
-             _7p_quadruple_circle = probe_points == 7,
+             _7p_no_intermediates = probe_points == 3,
+             _7p_1_intermediates  = probe_points == 4,
+             _7p_2_intermediates  = probe_points == 5,
+             _7p_4_intermediates  = probe_points == 6,
+             _7p_6_intermediates  = probe_points == 7,
+             _7p_8_intermediates  = probe_points == 8,
+             _7p_11_intermediates = probe_points == 9,
+             _7p_14_intermediates = probe_points == 10,
              _7p_intermed_points  = probe_points >= 4,
-             _7p_multi_circle     = probe_points >= 5;
+             _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
+             _7p_9_centre         = probe_points >= 8;
 
   #if DISABLED(PROBE_MANUALLY)
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
-  for (uint8_t i = 0; i <= 12; i++) z_at_pt[i] = 0.0;
+      LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
 
   if (!_0p_calibration) {
 
-    if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
+    if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
       #if ENABLED(PROBE_MANUALLY)
-        z_at_pt[0] += lcd_probe_pt(0, 0);
+        z_at_pt[CEN] += lcd_probe_pt(0, 0);
       #else
-        z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
+        z_at_pt[CEN] += probe_pt(dx, dy, stow_after_each, 1, false);
       #endif
     }
 
     if (_7p_calibration) { // probe extra center points
-      for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
-        const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
+      const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
+                  steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
+      I_LOOP_CAL_PT(axis, start, steps) {
+        const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
+                    r = delta_calibration_radius * 0.1;
         #if ENABLED(PROBE_MANUALLY)
-          z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+          z_at_pt[CEN] += lcd_probe_pt(cos(a) * r, sin(a) * r);
         #else
-          z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+          z_at_pt[CEN] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
         #endif
       }
-      z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
+      z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
+      const CalEnum start  = _4p_opposite_points ? _AB : __A;
+      const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
+                             _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
+                             _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
+                             _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
+                             _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
+                             _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25 
+                             _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16 
+                             _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
+                             _4P_STEP;                                // .5r * 6 +  1c = 4
       bool zig_zag = true;
-      const uint8_t start = _4p_opposite_points ? 3 : 1,
-                    step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
-      for (uint8_t axis = start; axis <= 12; axis += step) {
-        const float zigadd = (zig_zag ? 0.5 : 0.0),
-                    offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
-                                     _7p_triple_circle    ? zigadd + 0.5 :
-                                     _7p_double_circle    ? zigadd : 0;
-        for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
-          const float a = RADIANS(180 + 30 * axis),
-                      r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+      F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
+        const int8_t offset = _7p_9_centre ? 1 : 0;
+        for (int8_t circle = -offset; circle <= offset; circle++) {
+          const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
+                      r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
+                      interpol = fmod(axis, 1);
           #if ENABLED(PROBE_MANUALLY)
-            z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+             float z_temp = lcd_probe_pt(cos(a) * r, sin(a) * r);
           #else
-            z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+            float z_temp = probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
           #endif
+          // split probe point to neighbouring calibration points
+          z_at_pt[round(axis - interpol + NPP - 1) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
+          z_at_pt[round(axis - interpol) % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
         }
         zig_zag = !zig_zag;
-        z_at_pt[axis] /= (2 * offset_circles + 1);
       }
+      if (_7p_intermed_points)
+        LOOP_CAL_RAD(axis) {
+/*
+        // average intermediate points to towers and opposites - only required with _7P_STEP >= 2
+          for (int8_t i = 1; i < _7P_STEP; i++) {
+            const float interpol = i * (1.0 / _7P_STEP);
+            z_at_pt[axis] += (z_at_pt[(axis + NPP - i - 1) % NPP + 1]
+                             + z_at_pt[axis + i]) * sq(cos(RADIANS(interpol * 90)));
+          }
+*/
+          z_at_pt[axis] /= _7P_STEP  / steps;
+        }
     }
 
-    if (_7p_intermed_points) // average intermediates to tower and opposites
-      for (uint8_t axis = 1; axis <= 12; axis += 2)
-        z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
 
-    float S1 = z_at_pt[0],
-          S2 = sq(z_at_pt[0]);
+    float S1 = z_at_pt[CEN],
+          S2 = sq(z_at_pt[CEN]);
     int16_t N = 1;
-    if (!_1p_calibration) // std dev from zero plane
-      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis <= 12; axis += (_4p_calibration ? 4 : 2)) {
+    if (!_1p_calibration) { // std dev from zero plane
+      LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
         N++;
       }
-    return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+      return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+    }
   }
 
   return 0.00001;
 }
 
 #if DISABLED(PROBE_MANUALLY)
 
   static void G33_auto_tune() {
-    float z_at_pt[13]      = { 0.0 },
-          z_at_pt_base[13] = { 0.0 },
+    float z_at_pt[NPP + 1]      = { 0.0 },
+          z_at_pt_base[NPP + 1] = { 0.0 },
           z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
 
     #define ZP(N,I) ((N) * z_at_pt[I])
     #define Z06(I)  ZP(6, I)
     #define Z03(I)  ZP(3, I)
     #define Z02(I)  ZP(2, I)
     #define Z01(I)  ZP(1, I)
     #define Z32(I)  ZP(3/2, I)
 
     SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
@@ -220,55 +266,55 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning E");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
+      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_endstop_adj[axis] += 1.0;
       switch (axis) {
         case A_AXIS :
-          h_fac += 4.0 / (Z03(0) +Z01(1)                         +Z32(11) +Z32(3)); // Offset by X-tower end-stop
+          h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
           break;
         case B_AXIS :
-          h_fac += 4.0 / (Z03(0)         +Z01(5)         +Z32(7)          +Z32(3)); // Offset by Y-tower end-stop
+          h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
           break;
         case C_AXIS :
-          h_fac += 4.0 / (Z03(0)                 +Z01(9) +Z32(7) +Z32(11)        ); // Offset by Z-tower end-stop
+          h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
           break;
       }
     }
     h_fac /= 3.0;
     h_fac *= norm; // Normalize to 1.02 for Kossel mini
 
     for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
       delta_radius += 1.0 * zig_zag;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning R");
       SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
       SERIAL_EOL();
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
+      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
       delta_radius -= 1.0 * zig_zag;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
-      r_fac -= zig_zag * 6.0 / (Z03(1) + Z03(5) + Z03(9) + Z03(7) + Z03(11) + Z03(3)); // Offset by delta radius
+      r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
     }
     r_fac /= 2.0;
     r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
 
     LOOP_XYZ(axis) {
       delta_tower_angle_trim[axis] += 1.0;
       delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
       delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
@@ -277,39 +323,39 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
+      LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
       print_G33_results(z_at_pt, true, true);
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
       switch (axis) {
         case A_AXIS :
-        a_fac += 4.0 / (       Z06(5) -Z06(9)         +Z06(11) -Z06(3)); // Offset by alpha tower angle
+        a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
         break;
         case B_AXIS :
-        a_fac += 4.0 / (-Z06(1)       +Z06(9) -Z06(7)          +Z06(3)); // Offset by beta tower angle
+        a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
         break;
         case C_AXIS :
-        a_fac += 4.0 / (Z06(1) -Z06(5)        +Z06(7) -Z06(11)        ); // Offset by gamma tower angle
+        a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
         break;
       }
     }
     a_fac /= 3.0;
     a_fac *= norm; // Normalize to 0.83 for Kossel mini
 
     endstops.enable(true);
     if (!home_delta()) return;
     endstops.not_homing();
     print_signed_float(PSTR( "H_FACTOR: "), h_fac);
@@ -326,42 +372,42 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *      P0     No probe. Normalize only.
  *      P1     Probe center and set height only.
  *      P2     Probe center and towers. Set height, endstops and delta radius.
  *      P3     Probe all positions: center, towers and opposite towers. Set all.
- *      P4-P7  Probe all positions at different locations and average them.
+ *      P4-P10 Probe all positions + at different itermediate locations and average them.
  *
  *   T   Don't calibrate tower angle corrections
  *
  *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and takes the best result
  *
  *   A   Auto tune calibartion factors (set in Configuration.h)
  *
  *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report settings
  *      V2  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
-  if (!WITHIN(probe_points, 0, 7)) {
-    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-7).");
+  if (!WITHIN(probe_points, 0, 10)) {
+    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 2)) {
     SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
     return;
   }
 
   const float calibration_precision = parser.floatval('C');
@@ -375,29 +421,27 @@ void GcodeSuite::G33() {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
   const bool towers_set           = !parser.boolval('T'),
              auto_tune            = parser.boolval('A'),
              stow_after_each      = parser.boolval('E'),
              _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
+             _7p_9_centre         = probe_points >= 8,
              _tower_results       = (_4p_calibration && towers_set)
                                     || probe_points >= 3 || probe_points == 0,
              _opposite_results    = (_4p_calibration && !towers_set)
                                     || probe_points >= 3 || probe_points == 0,
              _endstop_results     = probe_points != 1,
-             _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set,
-             _7p_double_circle    = probe_points == 5,
-             _7p_triple_circle    = probe_points == 6,
-             _7p_quadruple_circle = probe_points == 7;
+             _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
   const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_min = zero_std_dev,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
@@ -405,26 +449,23 @@ void GcodeSuite::G33() {
         zh_old = home_offset[Z_AXIS],
         ta_old[ABC] = {
           delta_tower_angle_trim[A_AXIS],
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
   SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
   if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
-    const float circles = (_7p_quadruple_circle ? 1.5 :
-                           _7p_triple_circle    ? 1.0 :
-                           _7p_double_circle    ? 0.5 : 0),
-                r = (1 + circles * 0.1) * delta_calibration_radius;
-    for (uint8_t axis = 1; axis <= 12; ++axis) {
-      const float a = RADIANS(180 + 30 * axis);
+    LOOP_CAL_RAD(axis) {
+      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
+                  r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
       if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
 
   stepper.synchronize();
   #if HAS_LEVELING
     reset_bed_level(); // After calibration bed-level data is no longer valid
@@ -461,21 +502,21 @@ void GcodeSuite::G33() {
   const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_G33_settings(_endstop_results, _angle_results);
 
   do {
 
-    float z_at_pt[13] = { 0.0 };
+    float z_at_pt[NPP + 1] = { 0.0 };
 
     test_precision = zero_std_dev;
 
     iterations++;
 
     // Probe the points
 
     zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
 
     // Solve matrices
@@ -519,48 +560,48 @@ void GcodeSuite::G33() {
         test_precision = 0.00; // forced end
       #endif
 
       switch (probe_points) {
         case 0:
           test_precision = 0.00; // forced end
           break;
 
         case 1:
           test_precision = 0.00; // forced end
-          LOOP_XYZ(axis) e_delta[axis] = Z1(0);
+          LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
           break;
 
         case 2:
           if (towers_set) {
-            e_delta[A_AXIS] = (Z6(0) + Z4(1) - Z2(5) - Z2(9)) * h_factor;
-            e_delta[B_AXIS] = (Z6(0) - Z2(1) + Z4(5) - Z2(9)) * h_factor;
-            e_delta[C_AXIS] = (Z6(0) - Z2(1) - Z2(5) + Z4(9)) * h_factor;
-            r_delta         = (Z6(0) - Z2(1) - Z2(5) - Z2(9)) * r_factor;
+            e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
+            e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
+            e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
+            r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
           }
           else {
-            e_delta[A_AXIS] = (Z6(0) - Z4(7) + Z2(11) + Z2(3)) * h_factor;
-            e_delta[B_AXIS] = (Z6(0) + Z2(7) - Z4(11) + Z2(3)) * h_factor;
-            e_delta[C_AXIS] = (Z6(0) + Z2(7) + Z2(11) - Z4(3)) * h_factor;
-            r_delta         = (Z6(0) - Z2(7) - Z2(11) - Z2(3)) * r_factor;
+            e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
+            e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
+            e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
+            r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
           }
           break;
 
         default:
-          e_delta[A_AXIS] = (Z6(0) + Z2(1) - Z1(5) - Z1(9) - Z2(7) + Z1(11) + Z1(3)) * h_factor;
-          e_delta[B_AXIS] = (Z6(0) - Z1(1) + Z2(5) - Z1(9) + Z1(7) - Z2(11) + Z1(3)) * h_factor;
-          e_delta[C_AXIS] = (Z6(0) - Z1(1) - Z1(5) + Z2(9) + Z1(7) + Z1(11) - Z2(3)) * h_factor;
-          r_delta         = (Z6(0) - Z1(1) - Z1(5) - Z1(9) - Z1(7) - Z1(11) - Z1(3)) * r_factor;
+          e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
+          e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
+          e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
+          r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
 
           if (towers_set) {
-            t_delta[A_AXIS] = (       - Z4(5) + Z4(9)         - Z4(11) + Z4(3)) * a_factor;
-            t_delta[B_AXIS] = ( Z4(1)         - Z4(9) + Z4(7)          - Z4(3)) * a_factor;
-            t_delta[C_AXIS] = (-Z4(1) + Z4(5)         - Z4(7) + Z4(11)        ) * a_factor;
+            t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
+            t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
+            t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
             e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
             e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
             e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
           }
           break;
       }
 
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];

commit a1a4fc277e5ec4cc0fab9e7d40931565dc26e118
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Sun Oct 29 10:12:33 2017 +0100

    (2.0.x) serious bug G33 (#8136)
    
    * (2.0.x) serious bug G33
    
    * Revert config changes
    
    This reverts commit 74b5a98223b7b7fb970d05b8541f4a079c3cfe56.

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index abb8eed4b2..bd7fbe38b7 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -123,76 +123,76 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
              _7p_triple_circle    = probe_points == 6,
              _7p_quadruple_circle = probe_points == 7,
              _7p_intermed_points  = probe_points >= 4,
              _7p_multi_circle     = probe_points >= 5;
 
   #if DISABLED(PROBE_MANUALLY)
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
-  for (uint8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] = 0.0;
+  for (uint8_t i = 0; i <= 12; i++) z_at_pt[i] = 0.0;
 
   if (!_0p_calibration) {
 
     if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
       #if ENABLED(PROBE_MANUALLY)
         z_at_pt[0] += lcd_probe_pt(0, 0);
       #else
         z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
       #endif
     }
 
     if (_7p_calibration) { // probe extra center points
-      for (int8_t axis = _7p_multi_circle ? COUNT(z_at_pt) - 2 : COUNT(z_at_pt) - 4; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
+      for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
         const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
         #if ENABLED(PROBE_MANUALLY)
           z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
         #else
           z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
         #endif
       }
       z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
     }
 
     if (!_1p_calibration) {  // probe the radius
       bool zig_zag = true;
       const uint8_t start = _4p_opposite_points ? 3 : 1,
                     step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
-      for (uint8_t axis = start; axis < COUNT(z_at_pt); axis += step) {
+      for (uint8_t axis = start; axis <= 12; axis += step) {
         const float zigadd = (zig_zag ? 0.5 : 0.0),
                     offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
                                      _7p_triple_circle    ? zigadd + 0.5 :
                                      _7p_double_circle    ? zigadd : 0;
         for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
           const float a = RADIANS(180 + 30 * axis),
                       r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
           #if ENABLED(PROBE_MANUALLY)
             z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
           #else
             z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
           #endif
         }
         zig_zag = !zig_zag;
         z_at_pt[axis] /= (2 * offset_circles + 1);
       }
     }
 
     if (_7p_intermed_points) // average intermediates to tower and opposites
-      for (uint8_t axis = 1; axis < COUNT(z_at_pt); axis += 2)
+      for (uint8_t axis = 1; axis <= 12; axis += 2)
         z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
 
     float S1 = z_at_pt[0],
           S2 = sq(z_at_pt[0]);
     int16_t N = 1;
     if (!_1p_calibration) // std dev from zero plane
-      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < COUNT(z_at_pt); axis += (_4p_calibration ? 4 : 2)) {
+      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis <= 12; axis += (_4p_calibration ? 4 : 2)) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
         N++;
       }
     return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
   }
 
   return 0.00001;
 }
 
@@ -220,21 +220,21 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning E");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
       print_G33_results(z_at_pt, true, true);
       delta_endstop_adj[axis] += 1.0;
       switch (axis) {
         case A_AXIS :
           h_fac += 4.0 / (Z03(0) +Z01(1)                         +Z32(11) +Z32(3)); // Offset by X-tower end-stop
           break;
         case B_AXIS :
           h_fac += 4.0 / (Z03(0)         +Z01(5)         +Z32(7)          +Z32(3)); // Offset by Y-tower end-stop
           break;
         case C_AXIS :
@@ -250,21 +250,21 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning R");
       SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
       SERIAL_EOL();
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
       print_G33_results(z_at_pt, true, true);
       delta_radius -= 1.0 * zig_zag;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
       r_fac -= zig_zag * 6.0 / (Z03(1) + Z03(5) + Z03(9) + Z03(7) + Z03(11) + Z03(3)); // Offset by delta radius
     }
     r_fac /= 2.0;
     r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
 
     LOOP_XYZ(axis) {
       delta_tower_angle_trim[axis] += 1.0;
@@ -277,21 +277,21 @@ static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, cons
 
       endstops.enable(true);
       if (!home_delta()) return;
       endstops.not_homing();
 
       SERIAL_PROTOCOLPGM("Tuning T");
       SERIAL_CHAR(tolower(axis_codes[axis]));
       SERIAL_EOL();
 
       probe_G33_points(z_at_pt, 3, true, false);
-      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      for (int8_t i = 0; i <= 12; i++) z_at_pt[i] -= z_at_pt_base[i];
       print_G33_results(z_at_pt, true, true);
 
       delta_tower_angle_trim[axis] -= 1.0;
       delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
       delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
       z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
       recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
       switch (axis) {

commit dcfc2503c26b8c98d62d532433e71daa681c3ca4
Author: LVD-AC <lvd@sound-silence.com>
Date:   Fri Oct 20 08:08:21 2017 +0200

    G33 Autotune calibration update #10

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 5746c3c4de..abb8eed4b2 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -30,112 +30,327 @@
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 #include "../../module/tool_change.h"
 #include "../../lcd/ultralcd.h"
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-/**
- * G33 - Delta '1-4-7-point' Auto-Calibration
- *       Calibrate height, endstops, delta radius, and tower angles.
- *
- * Parameters:
- *
- *   Pn  Number of probe points:
- *
- *      P0     No probe. Normalize only.
- *      P1     Probe center and set height only.
- *      P2     Probe center and towers. Set height, endstops, and delta radius.
- *      P3     Probe all positions: center, towers and opposite towers. Set all.
- *      P4-P7  Probe all positions at different locations and average them.
- *
- *   T0  Don't calibrate tower angle corrections
- *
- *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
- *
- *   Fn  Force to run at least n iterations and takes the best result
- *
- *   Vn  Verbose level:
- *
- *      V0  Dry-run mode. Report settings and probe results. No calibration.
- *      V1  Report settings
- *      V2  Report settings and probe results
- *
- *   E   Engage the probe for each point
- */
-
 static void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
 static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
   if (end_stops) {
-    print_signed_float(PSTR("  Ex"), delta_endstop_adj[A_AXIS]);
+    print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
     print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
     print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
-    SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
   }
-  SERIAL_EOL();
+  if (end_stops && tower_angles) {
+    SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
+    SERIAL_EOL();
+    SERIAL_CHAR('.');
+    SERIAL_PROTOCOL_SP(13);
+  }
   if (tower_angles) {
-    SERIAL_PROTOCOLPGM(".Tower angle :  ");
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
     print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
+  }
+  if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
+    SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
+  }
+  SERIAL_EOL();
+}
+
+static void print_G33_results(const float z_at_pt[13], const bool tower_points, const bool opposite_points) {
+  SERIAL_PROTOCOLPGM(".    ");
+  print_signed_float(PSTR("c"), z_at_pt[0]);
+  if (tower_points) {
+    print_signed_float(PSTR(" x"), z_at_pt[1]);
+    print_signed_float(PSTR(" y"), z_at_pt[5]);
+    print_signed_float(PSTR(" z"), z_at_pt[9]);
+  }
+  if (tower_points && opposite_points) {
     SERIAL_EOL();
+    SERIAL_CHAR('.');
+    SERIAL_PROTOCOL_SP(13);
   }
+  if (opposite_points) {
+    print_signed_float(PSTR("yz"), z_at_pt[7]);
+    print_signed_float(PSTR("zx"), z_at_pt[11]);
+    print_signed_float(PSTR("xy"), z_at_pt[3]);
+  }
+  SERIAL_EOL();
 }
 
+/**
+ * After G33:
+ *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
+ *  - Stow the probe
+ *  - Restore endstops state
+ *  - Select the old tool, if needed
+ */
 static void G33_cleanup(
   #if HOTENDS > 1
     const uint8_t old_tool_index
   #endif
 ) {
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
+static float probe_G33_points(float z_at_pt[13], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
+  const bool _0p_calibration      = probe_points == 0,
+             _1p_calibration      = probe_points == 1,
+             _4p_calibration      = probe_points == 2,
+             _4p_opposite_points  = _4p_calibration && !towers_set,
+             _7p_calibration      = probe_points >= 3 || probe_points == 0,
+             _7p_half_circle      = probe_points == 3,
+             _7p_double_circle    = probe_points == 5,
+             _7p_triple_circle    = probe_points == 6,
+             _7p_quadruple_circle = probe_points == 7,
+             _7p_intermed_points  = probe_points >= 4,
+             _7p_multi_circle     = probe_points >= 5;
+
+  #if DISABLED(PROBE_MANUALLY)
+    const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
+                dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
+  #endif
+
+  for (uint8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] = 0.0;
+
+  if (!_0p_calibration) {
+
+    if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
+      #if ENABLED(PROBE_MANUALLY)
+        z_at_pt[0] += lcd_probe_pt(0, 0);
+      #else
+        z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
+      #endif
+    }
+
+    if (_7p_calibration) { // probe extra center points
+      for (int8_t axis = _7p_multi_circle ? COUNT(z_at_pt) - 2 : COUNT(z_at_pt) - 4; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
+        const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
+        #if ENABLED(PROBE_MANUALLY)
+          z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+        #else
+          z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+        #endif
+      }
+      z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
+    }
+
+    if (!_1p_calibration) {  // probe the radius
+      bool zig_zag = true;
+      const uint8_t start = _4p_opposite_points ? 3 : 1,
+                    step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
+      for (uint8_t axis = start; axis < COUNT(z_at_pt); axis += step) {
+        const float zigadd = (zig_zag ? 0.5 : 0.0),
+                    offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
+                                     _7p_triple_circle    ? zigadd + 0.5 :
+                                     _7p_double_circle    ? zigadd : 0;
+        for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
+          const float a = RADIANS(180 + 30 * axis),
+                      r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+          #if ENABLED(PROBE_MANUALLY)
+            z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+          #else
+            z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+          #endif
+        }
+        zig_zag = !zig_zag;
+        z_at_pt[axis] /= (2 * offset_circles + 1);
+      }
+    }
+
+    if (_7p_intermed_points) // average intermediates to tower and opposites
+      for (uint8_t axis = 1; axis < COUNT(z_at_pt); axis += 2)
+        z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
+
+    float S1 = z_at_pt[0],
+          S2 = sq(z_at_pt[0]);
+    int16_t N = 1;
+    if (!_1p_calibration) // std dev from zero plane
+      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < COUNT(z_at_pt); axis += (_4p_calibration ? 4 : 2)) {
+        S1 += z_at_pt[axis];
+        S2 += sq(z_at_pt[axis]);
+        N++;
+      }
+    return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+  }
+
+  return 0.00001;
+}
+
+#if DISABLED(PROBE_MANUALLY)
+
+  static void G33_auto_tune() {
+    float z_at_pt[13]      = { 0.0 },
+          z_at_pt_base[13] = { 0.0 },
+          z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
+
+    #define ZP(N,I) ((N) * z_at_pt[I])
+    #define Z06(I)  ZP(6, I)
+    #define Z03(I)  ZP(3, I)
+    #define Z02(I)  ZP(2, I)
+    #define Z01(I)  ZP(1, I)
+    #define Z32(I)  ZP(3/2, I)
+
+    SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
+    SERIAL_EOL();
+    probe_G33_points(z_at_pt_base, 3, true, false);
+    print_G33_results(z_at_pt_base, true, true);
+
+    LOOP_XYZ(axis) {
+      delta_endstop_adj[axis] -= 1.0;
+
+      endstops.enable(true);
+      if (!home_delta()) return;
+      endstops.not_homing();
+
+      SERIAL_PROTOCOLPGM("Tuning E");
+      SERIAL_CHAR(tolower(axis_codes[axis]));
+      SERIAL_EOL();
+
+      probe_G33_points(z_at_pt, 3, true, false);
+      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      print_G33_results(z_at_pt, true, true);
+      delta_endstop_adj[axis] += 1.0;
+      switch (axis) {
+        case A_AXIS :
+          h_fac += 4.0 / (Z03(0) +Z01(1)                         +Z32(11) +Z32(3)); // Offset by X-tower end-stop
+          break;
+        case B_AXIS :
+          h_fac += 4.0 / (Z03(0)         +Z01(5)         +Z32(7)          +Z32(3)); // Offset by Y-tower end-stop
+          break;
+        case C_AXIS :
+          h_fac += 4.0 / (Z03(0)                 +Z01(9) +Z32(7) +Z32(11)        ); // Offset by Z-tower end-stop
+          break;
+      }
+    }
+    h_fac /= 3.0;
+    h_fac *= norm; // Normalize to 1.02 for Kossel mini
+
+    for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
+      delta_radius += 1.0 * zig_zag;
+      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+
+      endstops.enable(true);
+      if (!home_delta()) return;
+      endstops.not_homing();
+
+      SERIAL_PROTOCOLPGM("Tuning R");
+      SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
+      SERIAL_EOL();
+      probe_G33_points(z_at_pt, 3, true, false);
+      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      print_G33_results(z_at_pt, true, true);
+      delta_radius -= 1.0 * zig_zag;
+      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      r_fac -= zig_zag * 6.0 / (Z03(1) + Z03(5) + Z03(9) + Z03(7) + Z03(11) + Z03(3)); // Offset by delta radius
+    }
+    r_fac /= 2.0;
+    r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
+
+    LOOP_XYZ(axis) {
+      delta_tower_angle_trim[axis] += 1.0;
+      delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
+      delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
+      z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      home_offset[Z_AXIS] -= z_temp;
+      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
+      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+
+      endstops.enable(true);
+      if (!home_delta()) return;
+      endstops.not_homing();
+
+      SERIAL_PROTOCOLPGM("Tuning T");
+      SERIAL_CHAR(tolower(axis_codes[axis]));
+      SERIAL_EOL();
+
+      probe_G33_points(z_at_pt, 3, true, false);
+      for (int8_t i = 0; i < COUNT(z_at_pt); i++) z_at_pt[i] -= z_at_pt_base[i];
+      print_G33_results(z_at_pt, true, true);
+
+      delta_tower_angle_trim[axis] -= 1.0;
+      delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
+      delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
+      z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      home_offset[Z_AXIS] -= z_temp;
+      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
+      recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
+      switch (axis) {
+        case A_AXIS :
+        a_fac += 4.0 / (       Z06(5) -Z06(9)         +Z06(11) -Z06(3)); // Offset by alpha tower angle
+        break;
+        case B_AXIS :
+        a_fac += 4.0 / (-Z06(1)       +Z06(9) -Z06(7)          +Z06(3)); // Offset by beta tower angle
+        break;
+        case C_AXIS :
+        a_fac += 4.0 / (Z06(1) -Z06(5)        +Z06(7) -Z06(11)        ); // Offset by gamma tower angle
+        break;
+      }
+    }
+    a_fac /= 3.0;
+    a_fac *= norm; // Normalize to 0.83 for Kossel mini
+
+    endstops.enable(true);
+    if (!home_delta()) return;
+    endstops.not_homing();
+    print_signed_float(PSTR( "H_FACTOR: "), h_fac);
+    print_signed_float(PSTR(" R_FACTOR: "), r_fac);
+    print_signed_float(PSTR(" A_FACTOR: "), a_fac);
+    SERIAL_EOL();
+    SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
+    SERIAL_EOL();
+  }
+
+#endif // !PROBE_MANUALLY
+
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
- *
  *      P0     No probe. Normalize only.
  *      P1     Probe center and set height only.
- *      P2     Probe center and towers. Set height, endstops, and delta radius.
+ *      P2     Probe center and towers. Set height, endstops and delta radius.
  *      P3     Probe all positions: center, towers and opposite towers. Set all.
  *      P4-P7  Probe all positions at different locations and average them.
  *
- *   T0  Don't calibrate tower angle corrections
+ *   T   Don't calibrate tower angle corrections
  *
- *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
+ *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and takes the best result
  *
- *   Vn  Verbose level:
+ *   A   Auto tune calibartion factors (set in Configuration.h)
  *
+ *   Vn  Verbose level:
  *      V0  Dry-run mode. Report settings and probe results. No calibration.
  *      V1  Report settings
  *      V2  Report settings and probe results
  *
  *   E   Engage the probe for each point
  */
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 7)) {
@@ -155,68 +370,67 @@ void GcodeSuite::G33() {
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
   const bool towers_set           = !parser.boolval('T'),
+             auto_tune            = parser.boolval('A'),
              stow_after_each      = parser.boolval('E'),
              _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
-             _4p_towers_points    = _4p_calibration && towers_set,
-             _4p_opposite_points  = _4p_calibration && !towers_set,
-             _7p_calibration      = probe_points >= 3 || _0p_calibration,
-             _7p_half_circle      = probe_points == 3,
+             _tower_results       = (_4p_calibration && towers_set)
+                                    || probe_points >= 3 || probe_points == 0,
+             _opposite_results    = (_4p_calibration && !towers_set)
+                                    || probe_points >= 3 || probe_points == 0,
+             _endstop_results     = probe_points != 1,
+             _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set,
              _7p_double_circle    = probe_points == 5,
              _7p_triple_circle    = probe_points == 6,
-             _7p_quadruple_circle = probe_points == 7,
-             _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
-             _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
+             _7p_quadruple_circle = probe_points == 7;
   const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
-  const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
-              dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
-        zero_std_dev_old = zero_std_dev,
         zero_std_dev_min = zero_std_dev,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
         dr_old = delta_radius,
         zh_old = home_offset[Z_AXIS],
         ta_old[ABC] = {
           delta_tower_angle_trim[A_AXIS],
           delta_tower_angle_trim[B_AXIS],
           delta_tower_angle_trim[C_AXIS]
         };
 
+  SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
+
   if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
     const float circles = (_7p_quadruple_circle ? 1.5 :
                            _7p_triple_circle    ? 1.0 :
                            _7p_double_circle    ? 0.5 : 0),
                 r = (1 + circles * 0.1) * delta_calibration_radius;
-    for (uint8_t axis = 1; axis < 13; ++axis) {
+    for (uint8_t axis = 1; axis <= 12; ++axis) {
       const float a = RADIANS(180 + 30 * axis);
       if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
-  SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
   stepper.synchronize();
   #if HAS_LEVELING
     reset_bed_level(); // After calibration bed-level data is no longer valid
   #endif
 
   #if HOTENDS > 1
     const uint8_t old_tool_index = active_extruder;
     tool_change(0, 0, true);
     #define G33_CLEANUP() G33_cleanup(old_tool_index)
@@ -225,138 +439,100 @@ void GcodeSuite::G33() {
   #endif
 
   setup_for_endstop_or_probe_move();
   endstops.enable(true);
   if (!_0p_calibration) {
     if (!home_delta())
       return;
     endstops.not_homing();
   }
 
-  // print settings
+  if (auto_tune) {
+    #if ENABLED(PROBE_MANUALLY)
+      SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
+    #else
+      G33_auto_tune();
+    #endif
+    G33_CLEANUP();
+    return;
+  }
+
+  // Report settings
 
   const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
-  print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+  print_G33_settings(_endstop_results, _angle_results);
 
   do {
 
     float z_at_pt[13] = { 0.0 };
 
-    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+    test_precision = zero_std_dev;
 
     iterations++;
 
     // Probe the points
 
-    if (!_0p_calibration){
-      if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
-        #if ENABLED(PROBE_MANUALLY)
-          z_at_pt[0] += lcd_probe_pt(0, 0);
-        #else
-          z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
-          if (isnan(z_at_pt[0])) return G33_CLEANUP();
-        #endif
-      }
-      if (_7p_calibration) { // probe extra center points
-        for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
-          const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
-          #if ENABLED(PROBE_MANUALLY)
-            z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
-          #else
-            z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-            if (isnan(z_at_pt[0])) return G33_CLEANUP();
-          #endif
-        }
-        z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
-      }
-      if (!_1p_calibration) {  // probe the radius
-        bool zig_zag = true;
-        const uint8_t start = _4p_opposite_points ? 3 : 1,
-                       step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
-        for (uint8_t axis = start; axis < 13; axis += step) {
-          const float zigadd = (zig_zag ? 0.5 : 0.0),
-                      offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
-                                       _7p_triple_circle    ? zigadd + 0.5 :
-                                       _7p_double_circle    ? zigadd : 0;
-          for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
-            const float a = RADIANS(180 + 30 * axis),
-                        r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
-            #if ENABLED(PROBE_MANUALLY)
-              z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
-            #else
-              z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-              if (isnan(z_at_pt[axis])) return G33_CLEANUP();
-            #endif
-          }
-          zig_zag = !zig_zag;
-          z_at_pt[axis] /= (2 * offset_circles + 1);
-        }
-      }
-      if (_7p_intermed_points) // average intermediates to tower and opposites
-        for (uint8_t axis = 1; axis < 13; axis += 2)
-          z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
-    }
-
-    float S1 = z_at_pt[0],
-          S2 = sq(z_at_pt[0]);
-    int16_t N = 1;
-    if (!_1p_calibration) // std dev from zero plane
-      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
-        S1 += z_at_pt[axis];
-        S2 += sq(z_at_pt[axis]);
-        N++;
-      }
-    zero_std_dev_old = zero_std_dev;
-    zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+    zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
       if (zero_std_dev < zero_std_dev_min) {
         COPY(e_old, delta_endstop_adj);
         dr_old = delta_radius;
         zh_old = home_offset[Z_AXIS];
         COPY(ta_old, delta_tower_angle_trim);
       }
 
       float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
       const float r_diff = delta_radius - delta_calibration_radius,
-                  h_factor = (1.00 + r_diff * 0.001) / 6.0,                                       // 1.02 for r_diff = 20mm
-                  r_factor = (-(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff))) / 6.0,               // 2.25 for r_diff = 20mm
-                  a_factor = (66.66 / delta_calibration_radius) / (iterations == 1 ? 16.0 : 2.0); // 0.83 for cal_rd = 80mm
+                  h_factor = 1 / 6.0 *
+                    #ifdef H_FACTOR
+                      (H_FACTOR),                                       // Set in Configuration.h
+                    #else
+                      (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
+                    #endif
+                  r_factor = 1 / 6.0 *
+                    #ifdef R_FACTOR
+                      -(R_FACTOR),                                      // Set in Configuration.h
+                    #else
+                      -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
+                    #endif
+                  a_factor = 1 / 6.0 *
+                    #ifdef A_FACTOR
+                      (A_FACTOR);                                       // Set in Configuration.h
+                    #else
+                      (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
+                    #endif
 
       #define ZP(N,I) ((N) * z_at_pt[I])
       #define Z6(I) ZP(6, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
 
       #if ENABLED(PROBE_MANUALLY)
         test_precision = 0.00; // forced end
       #endif
 
       switch (probe_points) {
         case 0:
-          #if DISABLED(PROBE_MANUALLY)
-            test_precision = 0.00; // forced end
-          #endif
+          test_precision = 0.00; // forced end
           break;
 
         case 1:
-          #if DISABLED(PROBE_MANUALLY)
-            test_precision = 0.00; // forced end
-          #endif
+          test_precision = 0.00; // forced end
           LOOP_XYZ(axis) e_delta[axis] = Z1(0);
           break;
 
         case 2:
           if (towers_set) {
             e_delta[A_AXIS] = (Z6(0) + Z4(1) - Z2(5) - Z2(9)) * h_factor;
             e_delta[B_AXIS] = (Z6(0) - Z2(1) + Z4(5) - Z2(9)) * h_factor;
             e_delta[C_AXIS] = (Z6(0) - Z2(1) - Z2(5) + Z4(9)) * h_factor;
             r_delta         = (Z6(0) - Z2(1) - Z2(5) - Z2(9)) * r_factor;
           }
@@ -368,135 +544,122 @@ void GcodeSuite::G33() {
           }
           break;
 
         default:
           e_delta[A_AXIS] = (Z6(0) + Z2(1) - Z1(5) - Z1(9) - Z2(7) + Z1(11) + Z1(3)) * h_factor;
           e_delta[B_AXIS] = (Z6(0) - Z1(1) + Z2(5) - Z1(9) + Z1(7) - Z2(11) + Z1(3)) * h_factor;
           e_delta[C_AXIS] = (Z6(0) - Z1(1) - Z1(5) + Z2(9) + Z1(7) + Z1(11) - Z2(3)) * h_factor;
           r_delta         = (Z6(0) - Z1(1) - Z1(5) - Z1(9) - Z1(7) - Z1(11) - Z1(3)) * r_factor;
 
           if (towers_set) {
-            t_delta[A_AXIS] = (       - Z2(5) + Z2(9)         - Z2(11) + Z2(3)) * a_factor;
-            t_delta[B_AXIS] = ( Z2(1)         - Z2(9) + Z2(7)          - Z2(3)) * a_factor;
-            t_delta[C_AXIS] = (-Z2(1) + Z2(5)         - Z2(7) + Z2(11)        ) * a_factor;
+            t_delta[A_AXIS] = (       - Z4(5) + Z4(9)         - Z4(11) + Z4(3)) * a_factor;
+            t_delta[B_AXIS] = ( Z4(1)         - Z4(9) + Z4(7)          - Z4(3)) * a_factor;
+            t_delta[C_AXIS] = (-Z4(1) + Z4(5)         - Z4(7) + Z4(11)        ) * a_factor;
             e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
             e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
             e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
           }
           break;
       }
 
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
     }
     else if (zero_std_dev >= test_precision) {   // step one back
       COPY(delta_endstop_adj, e_old);
       delta_radius = dr_old;
       home_offset[Z_AXIS] = zh_old;
       COPY(delta_tower_angle_trim, ta_old);
     }
+
     if (verbose_level != 0) {                                    // !dry run
       // normalise angles to least squares
-      float a_sum = 0.0;
-      LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
-      LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
+      if (_angle_results) {
+        float a_sum = 0.0;
+        LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
+        LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
+      }
 
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
-    if (verbose_level != 1) {
-      SERIAL_PROTOCOLPGM(".    ");
-      print_signed_float(PSTR("c"), z_at_pt[0]);
-      if (_4p_towers_points || _7p_calibration) {
-        print_signed_float(PSTR("   x"), z_at_pt[1]);
-        print_signed_float(PSTR(" y"), z_at_pt[5]);
-        print_signed_float(PSTR(" z"), z_at_pt[9]);
-      }
-      if (!_4p_opposite_points) SERIAL_EOL();
-      if ((_4p_opposite_points) || _7p_calibration) {
-        if (_7p_calibration) {
-          SERIAL_CHAR('.');
-          SERIAL_PROTOCOL_SP(13);
-        }
-        print_signed_float(PSTR("  yz"), z_at_pt[7]);
-        print_signed_float(PSTR("zx"), z_at_pt[11]);
-        print_signed_float(PSTR("xy"), z_at_pt[3]);
-        SERIAL_EOL();
-      }
-    }
+    if (verbose_level != 1)
+      print_G33_results(z_at_pt, _tower_results, _opposite_results);
+
     if (verbose_level != 0) {                                    // !dry run
       if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");
-        SERIAL_PROTOCOL_SP(36);
+        SERIAL_PROTOCOL_SP(32);
         #if DISABLED(PROBE_MANUALLY)
           if (zero_std_dev >= test_precision && !_1p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
           }
         SERIAL_EOL();
         char mess[21];
         sprintf_P(mess, PSTR("Calibration sd:"));
         if (zero_std_dev_min < 1)
           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
         else
           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
         lcd_setstatus(mess);
-        print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+        print_G33_settings(_endstop_results, _angle_results);
         serialprintPGM(save_message);
         SERIAL_EOL();
       }
       else {                                                     // !end iterations
         char mess[15];
         if (iterations < 31)
           sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
         else
           sprintf_P(mess, PSTR("No convergence"));
         SERIAL_PROTOCOL(mess);
-        SERIAL_PROTOCOL_SP(36);
+        SERIAL_PROTOCOL_SP(32);
         SERIAL_PROTOCOLPGM("std dev:");
         SERIAL_PROTOCOL_F(zero_std_dev, 3);
         SERIAL_EOL();
         lcd_setstatus(mess);
-        print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+        print_G33_settings(_endstop_results, _angle_results);
       }
     }
     else {                                                       // dry run
       const char *enddryrun = PSTR("End DRY-RUN");
       serialprintPGM(enddryrun);
-      SERIAL_PROTOCOL_SP(39);
+      SERIAL_PROTOCOL_SP(35);
       SERIAL_PROTOCOLPGM("std dev:");
       SERIAL_PROTOCOL_F(zero_std_dev, 3);
       SERIAL_EOL();
 
       char mess[21];
       sprintf_P(mess, enddryrun);
       sprintf_P(&mess[11], PSTR(" sd:"));
       if (zero_std_dev < 1)
         sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
       lcd_setstatus(mess);
     }
 
     endstops.enable(true);
-    home_delta();
+    if (!home_delta())
+      return;
     endstops.not_homing();
 
   }
   while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   G33_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit 3986a84f77110643b5873a3bd8a748eb246e6f66
Author: Luc Van Daele <lvd@sound-silence.com>
Date:   Wed Oct 18 21:03:17 2017 +0200

    boolval revisited (#8016)

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 0b3d753130..5746c3c4de 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -154,21 +154,21 @@ void GcodeSuite::G33() {
     SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
-  const bool towers_set           = parser.boolval('T', true),
+  const bool towers_set           = !parser.boolval('T'),
              stow_after_each      = parser.boolval('E'),
              _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
              _4p_towers_points    = _4p_calibration && towers_set,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3 || _0p_calibration,
              _7p_half_circle      = probe_points == 3,
              _7p_double_circle    = probe_points == 5,
              _7p_triple_circle    = probe_points == 6,

commit b220bc75216ce437a7cf808e589cb21144ffe3e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 6 15:47:51 2017 -0500

    Apply G33 updates
    
    Adapted from #7865

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index 2fd07806cd..0b3d753130 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -100,20 +100,48 @@ static void G33_cleanup(
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
+/**
+ * G33 - Delta '1-4-7-point' Auto-Calibration
+ *       Calibrate height, endstops, delta radius, and tower angles.
+ *
+ * Parameters:
+ *
+ *   Pn  Number of probe points:
+ *
+ *      P0     No probe. Normalize only.
+ *      P1     Probe center and set height only.
+ *      P2     Probe center and towers. Set height, endstops, and delta radius.
+ *      P3     Probe all positions: center, towers and opposite towers. Set all.
+ *      P4-P7  Probe all positions at different locations and average them.
+ *
+ *   T0  Don't calibrate tower angle corrections
+ *
+ *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
+ *
+ *   Fn  Force to run at least n iterations and takes the best result
+ *
+ *   Vn  Verbose level:
+ *
+ *      V0  Dry-run mode. Report settings and probe results. No calibration.
+ *      V1  Report settings
+ *      V2  Report settings and probe results
+ *
+ *   E   Engage the probe for each point
+ */
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   if (!WITHIN(probe_points, 0, 7)) {
     SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-7).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 2)) {
@@ -127,41 +155,36 @@ void GcodeSuite::G33() {
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
   const bool towers_set           = parser.boolval('T', true),
+             stow_after_each      = parser.boolval('E'),
              _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
              _4p_towers_points    = _4p_calibration && towers_set,
              _4p_opposite_points  = _4p_calibration && !towers_set,
              _7p_calibration      = probe_points >= 3 || _0p_calibration,
              _7p_half_circle      = probe_points == 3,
              _7p_double_circle    = probe_points == 5,
              _7p_triple_circle    = probe_points == 6,
              _7p_quadruple_circle = probe_points == 7,
              _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
              _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
-
-  #if DISABLED(PROBE_MANUALLY)
-    const bool stow_after_each    = parser.boolval('E');
-    const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
-                dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
-  #endif
-
   const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
-
+  const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
+              dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_old = zero_std_dev,
         zero_std_dev_min = zero_std_dev,
         e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
@@ -182,21 +205,20 @@ void GcodeSuite::G33() {
       const float a = RADIANS(180 + 30 * axis);
       if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
     }
   }
   SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
 
   stepper.synchronize();
-
   #if HAS_LEVELING
     reset_bed_level(); // After calibration bed-level data is no longer valid
   #endif
 
   #if HOTENDS > 1
     const uint8_t old_tool_index = active_extruder;
     tool_change(0, 0, true);
     #define G33_CLEANUP() G33_cleanup(old_tool_index)
   #else
     #define G33_CLEANUP() G33_cleanup()
@@ -213,33 +235,25 @@ void GcodeSuite::G33() {
   // print settings
 
   const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
 
-  #if DISABLED(PROBE_MANUALLY)
-    if (!_0p_calibration) {
-      const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
-      if (isnan(measured_z)) return G33_CLEANUP();
-      home_offset[Z_AXIS] -= measured_z;
-    }
-  #endif
-
   do {
 
     float z_at_pt[13] = { 0.0 };
 
-    test_precision = _0p_calibration ? 0.00 : zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
 
     iterations++;
 
     // Probe the points
 
     if (!_0p_calibration){
       if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
         #if ENABLED(PROBE_MANUALLY)
           z_at_pt[0] += lcd_probe_pt(0, 0);
         #else
@@ -294,47 +308,55 @@ void GcodeSuite::G33() {
       for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
         N++;
       }
     zero_std_dev_old = zero_std_dev;
     zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
 
     // Solve matrices
 
-    if ((zero_std_dev < test_precision && zero_std_dev > calibration_precision) || iterations <= force_iterations) {
+    if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
       if (zero_std_dev < zero_std_dev_min) {
         COPY(e_old, delta_endstop_adj);
         dr_old = delta_radius;
         zh_old = home_offset[Z_AXIS];
         COPY(ta_old, delta_tower_angle_trim);
       }
 
       float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
       const float r_diff = delta_radius - delta_calibration_radius,
-                  h_factor = (1.00 + r_diff * 0.001) / 6.0,                        //1.02 / 6 for r_diff = 20mm
-                  r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)) / 6.0,  //2.25 / 6 for r_diff = 20mm
-                  a_factor = 66.66 / delta_calibration_radius;                     //1.25 for cal_rd = 80mm
+                  h_factor = (1.00 + r_diff * 0.001) / 6.0,                                       // 1.02 for r_diff = 20mm
+                  r_factor = (-(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff))) / 6.0,               // 2.25 for r_diff = 20mm
+                  a_factor = (66.66 / delta_calibration_radius) / (iterations == 1 ? 16.0 : 2.0); // 0.83 for cal_rd = 80mm
 
       #define ZP(N,I) ((N) * z_at_pt[I])
       #define Z6(I) ZP(6, I)
       #define Z4(I) ZP(4, I)
       #define Z2(I) ZP(2, I)
       #define Z1(I) ZP(1, I)
 
       #if ENABLED(PROBE_MANUALLY)
         test_precision = 0.00; // forced end
       #endif
 
       switch (probe_points) {
+        case 0:
+          #if DISABLED(PROBE_MANUALLY)
+            test_precision = 0.00; // forced end
+          #endif
+          break;
+
         case 1:
-          test_precision = 0.00; // forced end
+          #if DISABLED(PROBE_MANUALLY)
+            test_precision = 0.00; // forced end
+          #endif
           LOOP_XYZ(axis) e_delta[axis] = Z1(0);
           break;
 
         case 2:
           if (towers_set) {
             e_delta[A_AXIS] = (Z6(0) + Z4(1) - Z2(5) - Z2(9)) * h_factor;
             e_delta[B_AXIS] = (Z6(0) - Z2(1) + Z4(5) - Z2(9)) * h_factor;
             e_delta[C_AXIS] = (Z6(0) - Z2(1) - Z2(5) + Z4(9)) * h_factor;
             r_delta         = (Z6(0) - Z2(1) - Z2(5) - Z2(9)) * r_factor;
           }
@@ -346,23 +368,26 @@ void GcodeSuite::G33() {
           }
           break;
 
         default:
           e_delta[A_AXIS] = (Z6(0) + Z2(1) - Z1(5) - Z1(9) - Z2(7) + Z1(11) + Z1(3)) * h_factor;
           e_delta[B_AXIS] = (Z6(0) - Z1(1) + Z2(5) - Z1(9) + Z1(7) - Z2(11) + Z1(3)) * h_factor;
           e_delta[C_AXIS] = (Z6(0) - Z1(1) - Z1(5) + Z2(9) + Z1(7) + Z1(11) - Z2(3)) * h_factor;
           r_delta         = (Z6(0) - Z1(1) - Z1(5) - Z1(9) - Z1(7) - Z1(11) - Z1(3)) * r_factor;
 
           if (towers_set) {
-            t_delta[A_AXIS] = (            - Z2(5) + Z1(9)         - Z2(11) + Z1(3)) * a_factor;
-            t_delta[B_AXIS] = (      Z2(1)         - Z1(9) + Z2(7)          - Z1(3)) * a_factor;
-            t_delta[C_AXIS] = (     -Z2(1) + Z1(5)         - Z2(7) + Z1(11)        ) * a_factor;
+            t_delta[A_AXIS] = (       - Z2(5) + Z2(9)         - Z2(11) + Z2(3)) * a_factor;
+            t_delta[B_AXIS] = ( Z2(1)         - Z2(9) + Z2(7)          - Z2(3)) * a_factor;
+            t_delta[C_AXIS] = (-Z2(1) + Z2(5)         - Z2(7) + Z2(11)        ) * a_factor;
+            e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
+            e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
+            e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
           }
           break;
       }
 
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
     }
     else if (zero_std_dev >= test_precision) {   // step one back
       COPY(delta_endstop_adj, e_old);
@@ -400,21 +425,21 @@ void GcodeSuite::G33() {
           SERIAL_CHAR('.');
           SERIAL_PROTOCOL_SP(13);
         }
         print_signed_float(PSTR("  yz"), z_at_pt[7]);
         print_signed_float(PSTR("zx"), z_at_pt[11]);
         print_signed_float(PSTR("xy"), z_at_pt[3]);
         SERIAL_EOL();
       }
     }
     if (verbose_level != 0) {                                    // !dry run
-      if ((zero_std_dev >= test_precision || zero_std_dev <= calibration_precision) && iterations > force_iterations) {  // end iterations
+      if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
         SERIAL_PROTOCOLPGM("Calibration OK");
         SERIAL_PROTOCOL_SP(36);
         #if DISABLED(PROBE_MANUALLY)
           if (zero_std_dev >= test_precision && !_1p_calibration)
             SERIAL_PROTOCOLPGM("rolling back.");
           else
         #endif
           {
             SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
@@ -462,16 +487,16 @@ void GcodeSuite::G33() {
       else
         sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
       lcd_setstatus(mess);
     }
 
     endstops.enable(true);
     home_delta();
     endstops.not_homing();
 
   }
-  while ((zero_std_dev < test_precision && zero_std_dev > calibration_precision && iterations < 31) || iterations <= force_iterations);
+  while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
 
   G33_CLEANUP();
 }
 
 #endif // DELTA_AUTO_CALIBRATION

commit dff2904c0f125b806ee63b21a4b27215b389152f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 27 04:57:14 2017 -0500

    Marlin code whitespace cleanup

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index abf86d49d2..2fd07806cd 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -368,21 +368,21 @@ void GcodeSuite::G33() {
       COPY(delta_endstop_adj, e_old);
       delta_radius = dr_old;
       home_offset[Z_AXIS] = zh_old;
       COPY(delta_tower_angle_trim, ta_old);
     }
     if (verbose_level != 0) {                                    // !dry run
       // normalise angles to least squares
       float a_sum = 0.0;
       LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
       LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
-      
+
       // adjust delta_height and endstops by the max amount
       const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
       home_offset[Z_AXIS] -= z_temp;
       LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
     recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 

commit 6d5fcac54ae76374065aed322e9f66f71756af70
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 24 02:18:15 2017 -0500

    G33 changes from 1.1.x

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
index ce9e5431d1..abf86d49d2 100644
--- a/Marlin/src/gcode/calibrate/G33.cpp
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -38,20 +38,21 @@
 #endif
 
 /**
  * G33 - Delta '1-4-7-point' Auto-Calibration
  *       Calibrate height, endstops, delta radius, and tower angles.
  *
  * Parameters:
  *
  *   Pn  Number of probe points:
  *
+ *      P0     No probe. Normalize only.
  *      P1     Probe center and set height only.
  *      P2     Probe center and towers. Set height, endstops, and delta radius.
  *      P3     Probe all positions: center, towers and opposite towers. Set all.
  *      P4-P7  Probe all positions at different locations and average them.
  *
  *   T0  Don't calibrate tower angle corrections
  *
  *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
  *
  *   Fn  Force to run at least n iterations and takes the best result
@@ -66,34 +67,35 @@
  */
 
 static void print_signed_float(const char * const prefix, const float &f) {
   SERIAL_PROTOCOLPGM("  ");
   serialprintPGM(prefix);
   SERIAL_PROTOCOLCHAR(':');
   if (f >= 0) SERIAL_CHAR('+');
   SERIAL_PROTOCOL_F(f, 2);
 }
 
-static void print_G33_settings(const bool end_stops, const bool tower_angles){ // TODO echo these to LCD ???
+static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
   if (end_stops) {
     print_signed_float(PSTR("  Ex"), delta_endstop_adj[A_AXIS]);
     print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
     print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
     SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
   }
   SERIAL_EOL();
   if (tower_angles) {
     SERIAL_PROTOCOLPGM(".Tower angle :  ");
     print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
     print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
-    SERIAL_PROTOCOLLNPGM("  Tz:+0.00");
+    print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
+    SERIAL_EOL();
   }
 }
 
 static void G33_cleanup(
   #if HOTENDS > 1
     const uint8_t old_tool_index
   #endif
 ) {
   #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     do_blocking_move_to_z(delta_clip_start_height);
@@ -101,22 +103,22 @@ static void G33_cleanup(
   STOW_PROBE();
   clean_up_after_endstop_or_probe_move();
   #if HOTENDS > 1
     tool_change(old_tool_index, 0, true);
   #endif
 }
 
 void GcodeSuite::G33() {
 
   const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
-  if (!WITHIN(probe_points, 1, 7)) {
-    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1-7).");
+  if (!WITHIN(probe_points, 0, 7)) {
+    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-7).");
     return;
   }
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 2)) {
     SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
     return;
   }
 
   const float calibration_precision = parser.floatval('C');
@@ -125,56 +127,60 @@ void GcodeSuite::G33() {
     return;
   }
 
   const int8_t force_iterations = parser.intval('F', 0);
   if (!WITHIN(force_iterations, 0, 30)) {
     SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
     return;
   }
 
   const bool towers_set           = parser.boolval('T', true),
+             _0p_calibration      = probe_points == 0,
              _1p_calibration      = probe_points == 1,
              _4p_calibration      = probe_points == 2,
              _4p_towers_points    = _4p_calibration && towers_set,
              _4p_opposite_points  = _4p_calibration && !towers_set,
-             _7p_calibration      = probe_points >= 3,
+             _7p_calibration      = probe_points >= 3 || _0p_calibration,
              _7p_half_circle      = probe_points == 3,
              _7p_double_circle    = probe_points == 5,
              _7p_triple_circle    = probe_points == 6,
              _7p_quadruple_circle = probe_points == 7,
              _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
              _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
 
   #if DISABLED(PROBE_MANUALLY)
     const bool stow_after_each    = parser.boolval('E');
     const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
                 dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
   #endif
 
   const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
 
   int8_t iterations = 0;
   float test_precision,
         zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
         zero_std_dev_old = zero_std_dev,
         zero_std_dev_min = zero_std_dev,
-        e_old[XYZ] = {
+        e_old[ABC] = {
           delta_endstop_adj[A_AXIS],
           delta_endstop_adj[B_AXIS],
           delta_endstop_adj[C_AXIS]
         },
         dr_old = delta_radius,
         zh_old = home_offset[Z_AXIS],
-        alpha_old = delta_tower_angle_trim[A_AXIS],
-        beta_old = delta_tower_angle_trim[B_AXIS];
+        ta_old[ABC] = {
+          delta_tower_angle_trim[A_AXIS],
+          delta_tower_angle_trim[B_AXIS],
+          delta_tower_angle_trim[C_AXIS]
+        };
 
-  if (!_1p_calibration) {  // test if the outer radius is reachable
+  if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
     const float circles = (_7p_quadruple_circle ? 1.5 :
                            _7p_triple_circle    ? 1.0 :
                            _7p_double_circle    ? 0.5 : 0),
                 r = (1 + circles * 0.1) * delta_calibration_radius;
     for (uint8_t axis = 1; axis < 13; ++axis) {
       const float a = RADIANS(180 + 30 * axis);
       if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
         SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
         return;
       }
@@ -191,197 +197,198 @@ void GcodeSuite::G33() {
   #if HOTENDS > 1
     const uint8_t old_tool_index = active_extruder;
     tool_change(0, 0, true);
     #define G33_CLEANUP() G33_cleanup(old_tool_index)
   #else
     #define G33_CLEANUP() G33_cleanup()
   #endif
 
   setup_for_endstop_or_probe_move();
   endstops.enable(true);
-  if (!home_delta())
-    return;
-  endstops.not_homing();
+  if (!_0p_calibration) {
+    if (!home_delta())
+      return;
+    endstops.not_homing();
+  }
 
   // print settings
 
   const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   serialprintPGM(checkingac);
   if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   SERIAL_EOL();
   lcd_setstatusPGM(checkingac);
 
   print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
 
   #if DISABLED(PROBE_MANUALLY)
-    const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
-    if (isnan(measured_z)) return G33_CLEANUP();
-    home_offset[Z_AXIS] -= measured_z;
+    if (!_0p_calibration) {
+      const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
+      if (isnan(measured_z)) return G33_CLEANUP();
+      home_offset[Z_AXIS] -= measured_z;
+    }
   #endif
 
   do {
 
     float z_at_pt[13] = { 0.0 };
 
-    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+    test_precision = _0p_calibration ? 0.00 : zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
 
     iterations++;
 
     // Probe the points
 
-    if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
-      #if ENABLED(PROBE_MANUALLY)
-        z_at_pt[0] += lcd_probe_pt(0, 0);
-      #else
-        z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
-        if (isnan(z_at_pt[0])) return G33_CLEANUP();
-      #endif
-    }
-    if (_7p_calibration) { // probe extra center points
-      for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
-        const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
+    if (!_0p_calibration){
+      if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
         #if ENABLED(PROBE_MANUALLY)
-          z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+          z_at_pt[0] += lcd_probe_pt(0, 0);
         #else
-          z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+          z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
           if (isnan(z_at_pt[0])) return G33_CLEANUP();
         #endif
       }
-      z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
-    }
-    if (!_1p_calibration) {  // probe the radius
-      bool zig_zag = true;
-      const uint8_t start = _4p_opposite_points ? 3 : 1,
-                     step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
-      for (uint8_t axis = start; axis < 13; axis += step) {
-        const float zigadd = (zig_zag ? 0.5 : 0.0),
-                    offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
-                                     _7p_triple_circle    ? zigadd + 0.5 :
-                                     _7p_double_circle    ? zigadd : 0;
-        for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
-          const float a = RADIANS(180 + 30 * axis),
-                      r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+      if (_7p_calibration) { // probe extra center points
+        for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
+          const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
           #if ENABLED(PROBE_MANUALLY)
-            z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+            z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
           #else
-            z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-            if (isnan(z_at_pt[axis])) return G33_CLEANUP();
+            z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+            if (isnan(z_at_pt[0])) return G33_CLEANUP();
           #endif
         }
-        zig_zag = !zig_zag;
-        z_at_pt[axis] /= (2 * offset_circles + 1);
+        z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
+      }
+      if (!_1p_calibration) {  // probe the radius
+        bool zig_zag = true;
+        const uint8_t start = _4p_opposite_points ? 3 : 1,
+                       step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
+        for (uint8_t axis = start; axis < 13; axis += step) {
+          const float zigadd = (zig_zag ? 0.5 : 0.0),
+                      offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
+                                       _7p_triple_circle    ? zigadd + 0.5 :
+                                       _7p_double_circle    ? zigadd : 0;
+          for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
+            const float a = RADIANS(180 + 30 * axis),
+                        r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+            #if ENABLED(PROBE_MANUALLY)
+              z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+            #else
+              z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+              if (isnan(z_at_pt[axis])) return G33_CLEANUP();
+            #endif
+          }
+          zig_zag = !zig_zag;
+          z_at_pt[axis] /= (2 * offset_circles + 1);
+        }
       }
+      if (_7p_intermed_points) // average intermediates to tower and opposites
+        for (uint8_t axis = 1; axis < 13; axis += 2)
+          z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
     }
-    if (_7p_intermed_points) // average intermediates to tower and opposites
-      for (uint8_t axis = 1; axis < 13; axis += 2)
-        z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
 
     float S1 = z_at_pt[0],
           S2 = sq(z_at_pt[0]);
     int16_t N = 1;
     if (!_1p_calibration) // std dev from zero plane
       for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
         S1 += z_at_pt[axis];
         S2 += sq(z_at_pt[axis]);
         N++;
       }
     zero_std_dev_old = zero_std_dev;
     zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
 
     // Solve matrices
 
     if ((zero_std_dev < test_precision && zero_std_dev > calibration_precision) || iterations <= force_iterations) {
       if (zero_std_dev < zero_std_dev_min) {
         COPY(e_old, delta_endstop_adj);
         dr_old = delta_radius;
         zh_old = home_offset[Z_AXIS];
-        alpha_old = delta_tower_angle_trim[A_AXIS];
-        beta_old = delta_tower_angle_trim[B_AXIS];
+        COPY(ta_old, delta_tower_angle_trim);
       }
 
-      float e_delta[XYZ] = { 0.0 }, r_delta = 0.0, t_alpha = 0.0, t_beta = 0.0;
+      float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
       const float r_diff = delta_radius - delta_calibration_radius,
-                  h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
-                  r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
-                  a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
+                  h_factor = (1.00 + r_diff * 0.001) / 6.0,                        //1.02 / 6 for r_diff = 20mm
+                  r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)) / 6.0,  //2.25 / 6 for r_diff = 20mm
+                  a_factor = 66.66 / delta_calibration_radius;                     //1.25 for cal_rd = 80mm
 
       #define ZP(N,I) ((N) * z_at_pt[I])
-      #define Z1000(I) ZP(1.00, I)
-      #define Z1050(I) ZP(h_factor, I)
-      #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
-      #define Z0350(I) ZP(h_factor / 3.00, I)
-      #define Z0175(I) ZP(h_factor / 6.00, I)
-      #define Z2250(I) ZP(r_factor, I)
-      #define Z0750(I) ZP(r_factor / 3.00, I)
-      #define Z0375(I) ZP(r_factor / 6.00, I)
-      #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
-      #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
+      #define Z6(I) ZP(6, I)
+      #define Z4(I) ZP(4, I)
+      #define Z2(I) ZP(2, I)
+      #define Z1(I) ZP(1, I)
 
       #if ENABLED(PROBE_MANUALLY)
         test_precision = 0.00; // forced end
       #endif
 
       switch (probe_points) {
         case 1:
           test_precision = 0.00; // forced end
-          LOOP_XYZ(i) e_delta[i] = Z1000(0);
+          LOOP_XYZ(axis) e_delta[axis] = Z1(0);
           break;
 
         case 2:
           if (towers_set) {
-            e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
-            e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
-            e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
-            r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
+            e_delta[A_AXIS] = (Z6(0) + Z4(1) - Z2(5) - Z2(9)) * h_factor;
+            e_delta[B_AXIS] = (Z6(0) - Z2(1) + Z4(5) - Z2(9)) * h_factor;
+            e_delta[C_AXIS] = (Z6(0) - Z2(1) - Z2(5) + Z4(9)) * h_factor;
+            r_delta         = (Z6(0) - Z2(1) - Z2(5) - Z2(9)) * r_factor;
           }
           else {
-            e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
-            e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
-            e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
-            r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
+            e_delta[A_AXIS] = (Z6(0) - Z4(7) + Z2(11) + Z2(3)) * h_factor;
+            e_delta[B_AXIS] = (Z6(0) + Z2(7) - Z4(11) + Z2(3)) * h_factor;
+            e_delta[C_AXIS] = (Z6(0) + Z2(7) + Z2(11) - Z4(3)) * h_factor;
+            r_delta         = (Z6(0) - Z2(7) - Z2(11) - Z2(3)) * r_factor;
           }
           break;
 
         default:
-          e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
-          e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
-          e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
-          r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
+          e_delta[A_AXIS] = (Z6(0) + Z2(1) - Z1(5) - Z1(9) - Z2(7) + Z1(11) + Z1(3)) * h_factor;
+          e_delta[B_AXIS] = (Z6(0) - Z1(1) + Z2(5) - Z1(9) + Z1(7) - Z2(11) + Z1(3)) * h_factor;
+          e_delta[C_AXIS] = (Z6(0) - Z1(1) - Z1(5) + Z2(9) + Z1(7) + Z1(11) - Z2(3)) * h_factor;
+          r_delta         = (Z6(0) - Z1(1) - Z1(5) - Z1(9) - Z1(7) - Z1(11) - Z1(3)) * r_factor;
 
           if (towers_set) {
-            t_alpha = Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
-            t_beta  = Z0888(1) - Z0444(5) - Z0444(9) + Z0888(7) - Z0444(11) - Z0444(3);
+            t_delta[A_AXIS] = (            - Z2(5) + Z1(9)         - Z2(11) + Z1(3)) * a_factor;
+            t_delta[B_AXIS] = (      Z2(1)         - Z1(9) + Z2(7)          - Z1(3)) * a_factor;
+            t_delta[C_AXIS] = (     -Z2(1) + Z1(5)         - Z2(7) + Z1(11)        ) * a_factor;
           }
           break;
       }
 
       LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
       delta_radius += r_delta;
-      delta_tower_angle_trim[A_AXIS] += t_alpha;
-      delta_tower_angle_trim[B_AXIS] += t_beta;
-
-      // adjust delta_height and endstops by the max amount
-      const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
-      home_offset[Z_AXIS] -= z_temp;
-      LOOP_XYZ(i) delta_endstop_adj[i] -= z_temp;
-
-      recalc_delta_settings(delta_radius, delta_diagonal_rod);
+      LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
     }
     else if (zero_std_dev >= test_precision) {   // step one back
       COPY(delta_endstop_adj, e_old);
       delta_radius = dr_old;
       home_offset[Z_AXIS] = zh_old;
-      delta_tower_angle_trim[A_AXIS] = alpha_old;
-      delta_tower_angle_trim[B_AXIS] = beta_old;
-
-      recalc_delta_settings(delta_radius, delta_diagonal_rod);
+      COPY(delta_tower_angle_trim, ta_old);
+    }
+    if (verbose_level != 0) {                                    // !dry run
+      // normalise angles to least squares
+      float a_sum = 0.0;
+      LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
+      LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
+      
+      // adjust delta_height and endstops by the max amount
+      const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      home_offset[Z_AXIS] -= z_temp;
+      LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
     }
+    recalc_delta_settings(delta_radius, delta_diagonal_rod, delta_tower_angle_trim);
     NOMORE(zero_std_dev_min, zero_std_dev);
 
     // print report
 
     if (verbose_level != 1) {
       SERIAL_PROTOCOLPGM(".    ");
       print_signed_float(PSTR("c"), z_at_pt[0]);
       if (_4p_towers_points || _7p_calibration) {
         print_signed_float(PSTR("   x"), z_at_pt[1]);
         print_signed_float(PSTR(" y"), z_at_pt[5]);

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/gcode/calibrate/G33.cpp b/Marlin/src/gcode/calibrate/G33.cpp
new file mode 100644
index 0000000000..ce9e5431d1
--- /dev/null
+++ b/Marlin/src/gcode/calibrate/G33.cpp
@@ -0,0 +1,470 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(DELTA_AUTO_CALIBRATION)
+
+#include "../gcode.h"
+#include "../../module/delta.h"
+#include "../../module/probe.h"
+#include "../../module/motion.h"
+#include "../../module/stepper.h"
+#include "../../module/endstops.h"
+#include "../../module/tool_change.h"
+#include "../../lcd/ultralcd.h"
+
+#if HAS_LEVELING
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+/**
+ * G33 - Delta '1-4-7-point' Auto-Calibration
+ *       Calibrate height, endstops, delta radius, and tower angles.
+ *
+ * Parameters:
+ *
+ *   Pn  Number of probe points:
+ *
+ *      P1     Probe center and set height only.
+ *      P2     Probe center and towers. Set height, endstops, and delta radius.
+ *      P3     Probe all positions: center, towers and opposite towers. Set all.
+ *      P4-P7  Probe all positions at different locations and average them.
+ *
+ *   T0  Don't calibrate tower angle corrections
+ *
+ *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
+ *
+ *   Fn  Force to run at least n iterations and takes the best result
+ *
+ *   Vn  Verbose level:
+ *
+ *      V0  Dry-run mode. Report settings and probe results. No calibration.
+ *      V1  Report settings
+ *      V2  Report settings and probe results
+ *
+ *   E   Engage the probe for each point
+ */
+
+static void print_signed_float(const char * const prefix, const float &f) {
+  SERIAL_PROTOCOLPGM("  ");
+  serialprintPGM(prefix);
+  SERIAL_PROTOCOLCHAR(':');
+  if (f >= 0) SERIAL_CHAR('+');
+  SERIAL_PROTOCOL_F(f, 2);
+}
+
+static void print_G33_settings(const bool end_stops, const bool tower_angles){ // TODO echo these to LCD ???
+  SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+  if (end_stops) {
+    print_signed_float(PSTR("  Ex"), delta_endstop_adj[A_AXIS]);
+    print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
+    print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
+    SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
+  }
+  SERIAL_EOL();
+  if (tower_angles) {
+    SERIAL_PROTOCOLPGM(".Tower angle :  ");
+    print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
+    print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
+    SERIAL_PROTOCOLLNPGM("  Tz:+0.00");
+  }
+}
+
+static void G33_cleanup(
+  #if HOTENDS > 1
+    const uint8_t old_tool_index
+  #endif
+) {
+  #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+  STOW_PROBE();
+  clean_up_after_endstop_or_probe_move();
+  #if HOTENDS > 1
+    tool_change(old_tool_index, 0, true);
+  #endif
+}
+
+void GcodeSuite::G33() {
+
+  const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
+  if (!WITHIN(probe_points, 1, 7)) {
+    SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1-7).");
+    return;
+  }
+
+  const int8_t verbose_level = parser.byteval('V', 1);
+  if (!WITHIN(verbose_level, 0, 2)) {
+    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
+    return;
+  }
+
+  const float calibration_precision = parser.floatval('C');
+  if (calibration_precision < 0) {
+    SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
+    return;
+  }
+
+  const int8_t force_iterations = parser.intval('F', 0);
+  if (!WITHIN(force_iterations, 0, 30)) {
+    SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
+    return;
+  }
+
+  const bool towers_set           = parser.boolval('T', true),
+             _1p_calibration      = probe_points == 1,
+             _4p_calibration      = probe_points == 2,
+             _4p_towers_points    = _4p_calibration && towers_set,
+             _4p_opposite_points  = _4p_calibration && !towers_set,
+             _7p_calibration      = probe_points >= 3,
+             _7p_half_circle      = probe_points == 3,
+             _7p_double_circle    = probe_points == 5,
+             _7p_triple_circle    = probe_points == 6,
+             _7p_quadruple_circle = probe_points == 7,
+             _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
+             _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
+
+  #if DISABLED(PROBE_MANUALLY)
+    const bool stow_after_each    = parser.boolval('E');
+    const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
+                dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
+  #endif
+
+  const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
+
+  int8_t iterations = 0;
+  float test_precision,
+        zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
+        zero_std_dev_old = zero_std_dev,
+        zero_std_dev_min = zero_std_dev,
+        e_old[XYZ] = {
+          delta_endstop_adj[A_AXIS],
+          delta_endstop_adj[B_AXIS],
+          delta_endstop_adj[C_AXIS]
+        },
+        dr_old = delta_radius,
+        zh_old = home_offset[Z_AXIS],
+        alpha_old = delta_tower_angle_trim[A_AXIS],
+        beta_old = delta_tower_angle_trim[B_AXIS];
+
+  if (!_1p_calibration) {  // test if the outer radius is reachable
+    const float circles = (_7p_quadruple_circle ? 1.5 :
+                           _7p_triple_circle    ? 1.0 :
+                           _7p_double_circle    ? 0.5 : 0),
+                r = (1 + circles * 0.1) * delta_calibration_radius;
+    for (uint8_t axis = 1; axis < 13; ++axis) {
+      const float a = RADIANS(180 + 30 * axis);
+      if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
+        SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
+        return;
+      }
+    }
+  }
+  SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
+
+  stepper.synchronize();
+
+  #if HAS_LEVELING
+    reset_bed_level(); // After calibration bed-level data is no longer valid
+  #endif
+
+  #if HOTENDS > 1
+    const uint8_t old_tool_index = active_extruder;
+    tool_change(0, 0, true);
+    #define G33_CLEANUP() G33_cleanup(old_tool_index)
+  #else
+    #define G33_CLEANUP() G33_cleanup()
+  #endif
+
+  setup_for_endstop_or_probe_move();
+  endstops.enable(true);
+  if (!home_delta())
+    return;
+  endstops.not_homing();
+
+  // print settings
+
+  const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
+  serialprintPGM(checkingac);
+  if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
+  SERIAL_EOL();
+  lcd_setstatusPGM(checkingac);
+
+  print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+
+  #if DISABLED(PROBE_MANUALLY)
+    const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
+    if (isnan(measured_z)) return G33_CLEANUP();
+    home_offset[Z_AXIS] -= measured_z;
+  #endif
+
+  do {
+
+    float z_at_pt[13] = { 0.0 };
+
+    test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+
+    iterations++;
+
+    // Probe the points
+
+    if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
+      #if ENABLED(PROBE_MANUALLY)
+        z_at_pt[0] += lcd_probe_pt(0, 0);
+      #else
+        z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
+        if (isnan(z_at_pt[0])) return G33_CLEANUP();
+      #endif
+    }
+    if (_7p_calibration) { // probe extra center points
+      for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
+        const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
+        #if ENABLED(PROBE_MANUALLY)
+          z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+        #else
+          z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+          if (isnan(z_at_pt[0])) return G33_CLEANUP();
+        #endif
+      }
+      z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
+    }
+    if (!_1p_calibration) {  // probe the radius
+      bool zig_zag = true;
+      const uint8_t start = _4p_opposite_points ? 3 : 1,
+                     step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
+      for (uint8_t axis = start; axis < 13; axis += step) {
+        const float zigadd = (zig_zag ? 0.5 : 0.0),
+                    offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
+                                     _7p_triple_circle    ? zigadd + 0.5 :
+                                     _7p_double_circle    ? zigadd : 0;
+        for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
+          const float a = RADIANS(180 + 30 * axis),
+                      r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+          #if ENABLED(PROBE_MANUALLY)
+            z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+          #else
+            z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+            if (isnan(z_at_pt[axis])) return G33_CLEANUP();
+          #endif
+        }
+        zig_zag = !zig_zag;
+        z_at_pt[axis] /= (2 * offset_circles + 1);
+      }
+    }
+    if (_7p_intermed_points) // average intermediates to tower and opposites
+      for (uint8_t axis = 1; axis < 13; axis += 2)
+        z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
+
+    float S1 = z_at_pt[0],
+          S2 = sq(z_at_pt[0]);
+    int16_t N = 1;
+    if (!_1p_calibration) // std dev from zero plane
+      for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
+        S1 += z_at_pt[axis];
+        S2 += sq(z_at_pt[axis]);
+        N++;
+      }
+    zero_std_dev_old = zero_std_dev;
+    zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+
+    // Solve matrices
+
+    if ((zero_std_dev < test_precision && zero_std_dev > calibration_precision) || iterations <= force_iterations) {
+      if (zero_std_dev < zero_std_dev_min) {
+        COPY(e_old, delta_endstop_adj);
+        dr_old = delta_radius;
+        zh_old = home_offset[Z_AXIS];
+        alpha_old = delta_tower_angle_trim[A_AXIS];
+        beta_old = delta_tower_angle_trim[B_AXIS];
+      }
+
+      float e_delta[XYZ] = { 0.0 }, r_delta = 0.0, t_alpha = 0.0, t_beta = 0.0;
+      const float r_diff = delta_radius - delta_calibration_radius,
+                  h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
+                  r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
+                  a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
+
+      #define ZP(N,I) ((N) * z_at_pt[I])
+      #define Z1000(I) ZP(1.00, I)
+      #define Z1050(I) ZP(h_factor, I)
+      #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
+      #define Z0350(I) ZP(h_factor / 3.00, I)
+      #define Z0175(I) ZP(h_factor / 6.00, I)
+      #define Z2250(I) ZP(r_factor, I)
+      #define Z0750(I) ZP(r_factor / 3.00, I)
+      #define Z0375(I) ZP(r_factor / 6.00, I)
+      #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
+      #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
+
+      #if ENABLED(PROBE_MANUALLY)
+        test_precision = 0.00; // forced end
+      #endif
+
+      switch (probe_points) {
+        case 1:
+          test_precision = 0.00; // forced end
+          LOOP_XYZ(i) e_delta[i] = Z1000(0);
+          break;
+
+        case 2:
+          if (towers_set) {
+            e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
+            e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
+            e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
+            r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
+          }
+          else {
+            e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
+            e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
+            e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
+            r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
+          }
+          break;
+
+        default:
+          e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
+          e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
+          e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
+          r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
+
+          if (towers_set) {
+            t_alpha = Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
+            t_beta  = Z0888(1) - Z0444(5) - Z0444(9) + Z0888(7) - Z0444(11) - Z0444(3);
+          }
+          break;
+      }
+
+      LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
+      delta_radius += r_delta;
+      delta_tower_angle_trim[A_AXIS] += t_alpha;
+      delta_tower_angle_trim[B_AXIS] += t_beta;
+
+      // adjust delta_height and endstops by the max amount
+      const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
+      home_offset[Z_AXIS] -= z_temp;
+      LOOP_XYZ(i) delta_endstop_adj[i] -= z_temp;
+
+      recalc_delta_settings(delta_radius, delta_diagonal_rod);
+    }
+    else if (zero_std_dev >= test_precision) {   // step one back
+      COPY(delta_endstop_adj, e_old);
+      delta_radius = dr_old;
+      home_offset[Z_AXIS] = zh_old;
+      delta_tower_angle_trim[A_AXIS] = alpha_old;
+      delta_tower_angle_trim[B_AXIS] = beta_old;
+
+      recalc_delta_settings(delta_radius, delta_diagonal_rod);
+    }
+    NOMORE(zero_std_dev_min, zero_std_dev);
+
+    // print report
+
+    if (verbose_level != 1) {
+      SERIAL_PROTOCOLPGM(".    ");
+      print_signed_float(PSTR("c"), z_at_pt[0]);
+      if (_4p_towers_points || _7p_calibration) {
+        print_signed_float(PSTR("   x"), z_at_pt[1]);
+        print_signed_float(PSTR(" y"), z_at_pt[5]);
+        print_signed_float(PSTR(" z"), z_at_pt[9]);
+      }
+      if (!_4p_opposite_points) SERIAL_EOL();
+      if ((_4p_opposite_points) || _7p_calibration) {
+        if (_7p_calibration) {
+          SERIAL_CHAR('.');
+          SERIAL_PROTOCOL_SP(13);
+        }
+        print_signed_float(PSTR("  yz"), z_at_pt[7]);
+        print_signed_float(PSTR("zx"), z_at_pt[11]);
+        print_signed_float(PSTR("xy"), z_at_pt[3]);
+        SERIAL_EOL();
+      }
+    }
+    if (verbose_level != 0) {                                    // !dry run
+      if ((zero_std_dev >= test_precision || zero_std_dev <= calibration_precision) && iterations > force_iterations) {  // end iterations
+        SERIAL_PROTOCOLPGM("Calibration OK");
+        SERIAL_PROTOCOL_SP(36);
+        #if DISABLED(PROBE_MANUALLY)
+          if (zero_std_dev >= test_precision && !_1p_calibration)
+            SERIAL_PROTOCOLPGM("rolling back.");
+          else
+        #endif
+          {
+            SERIAL_PROTOCOLPGM("std dev:");
+            SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
+          }
+        SERIAL_EOL();
+        char mess[21];
+        sprintf_P(mess, PSTR("Calibration sd:"));
+        if (zero_std_dev_min < 1)
+          sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
+        else
+          sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
+        lcd_setstatus(mess);
+        print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+        serialprintPGM(save_message);
+        SERIAL_EOL();
+      }
+      else {                                                     // !end iterations
+        char mess[15];
+        if (iterations < 31)
+          sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
+        else
+          sprintf_P(mess, PSTR("No convergence"));
+        SERIAL_PROTOCOL(mess);
+        SERIAL_PROTOCOL_SP(36);
+        SERIAL_PROTOCOLPGM("std dev:");
+        SERIAL_PROTOCOL_F(zero_std_dev, 3);
+        SERIAL_EOL();
+        lcd_setstatus(mess);
+        print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+      }
+    }
+    else {                                                       // dry run
+      const char *enddryrun = PSTR("End DRY-RUN");
+      serialprintPGM(enddryrun);
+      SERIAL_PROTOCOL_SP(39);
+      SERIAL_PROTOCOLPGM("std dev:");
+      SERIAL_PROTOCOL_F(zero_std_dev, 3);
+      SERIAL_EOL();
+
+      char mess[21];
+      sprintf_P(mess, enddryrun);
+      sprintf_P(&mess[11], PSTR(" sd:"));
+      if (zero_std_dev < 1)
+        sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
+      else
+        sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
+      lcd_setstatus(mess);
+    }
+
+    endstops.enable(true);
+    home_delta();
+    endstops.not_homing();
+
+  }
+  while ((zero_std_dev < test_precision && zero_std_dev > calibration_precision && iterations < 31) || iterations <= force_iterations);
+
+  G33_CLEANUP();
+}
+
+#endif // DELTA_AUTO_CALIBRATION
