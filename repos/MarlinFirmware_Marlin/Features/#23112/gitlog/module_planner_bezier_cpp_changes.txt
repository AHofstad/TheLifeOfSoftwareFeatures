commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 93b118f330..a3f98435d0 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -114,20 +114,23 @@ void cubic_b_spline(
 ) {
   // Absolute first and second control points are recovered.
   const xy_pos_t first = position + offsets[0], second = target + offsets[1];
 
   xyze_pos_t bez_target;
   bez_target.set(position.x, position.y);
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
+  // Hints to help optimize the move
+  PlannerHints hints;
+
   for (float t = 0; t < 1;) {
 
     thermalManager.task();
     millis_t now = millis();
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
@@ -170,21 +173,21 @@ void cubic_b_spline(
     // Marlin build, but if you test the same code on a computer you
     // may want to check they are respect.
     /*
       assert(new_t <= 1.0);
       if (new_t < 1.0) {
         assert(new_t - t >= (MIN_STEP) / 2.0);
         assert(new_t - t <= (MAX_STEP) * 2.0);
       }
     */
 
-    step = new_t - t;
+    hints.millimeters = new_t - t;
     t = new_t;
 
     // Compute and send new position
     xyze_pos_t new_bez = LOGICAL_AXIS_ARRAY(
       interp(position.e, target.e, t),  // FIXME. Wrong, since t is not linear in the distance.
       new_pos0,
       new_pos1,
       interp(position.z, target.z, t),  // FIXME. Wrong, since t is not linear in the distance.
       interp(position.i, target.i, t),  // FIXME. Wrong, since t is not linear in the distance.
       interp(position.j, target.j, t),  // FIXME. Wrong, since t is not linear in the distance.
@@ -196,16 +199,16 @@ void cubic_b_spline(
     apply_motion_limits(new_bez);
     bez_target = new_bez;
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       xyze_pos_t pos = bez_target;
       planner.apply_leveling(pos);
     #else
       const xyze_pos_t &pos = bez_target;
     #endif
 
-    if (!planner.buffer_line(pos, scaled_fr_mm_s, active_extruder, step))
+    if (!planner.buffer_line(pos, scaled_fr_mm_s, active_extruder, hints))
       break;
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index fa7e16a387..93b118f330 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -116,21 +116,21 @@ void cubic_b_spline(
   const xy_pos_t first = position + offsets[0], second = target + offsets[1];
 
   xyze_pos_t bez_target;
   bez_target.set(position.x, position.y);
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
   for (float t = 0; t < 1;) {
 
-    thermalManager.manage_heater();
+    thermalManager.task();
     millis_t now = millis();
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
     // close to a linear interpolation.
     bool did_reduce = false;
     float new_t = t + step;

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 848906705f..fa7e16a387 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -181,21 +181,24 @@ void cubic_b_spline(
     t = new_t;
 
     // Compute and send new position
     xyze_pos_t new_bez = LOGICAL_AXIS_ARRAY(
       interp(position.e, target.e, t),  // FIXME. Wrong, since t is not linear in the distance.
       new_pos0,
       new_pos1,
       interp(position.z, target.z, t),  // FIXME. Wrong, since t is not linear in the distance.
       interp(position.i, target.i, t),  // FIXME. Wrong, since t is not linear in the distance.
       interp(position.j, target.j, t),  // FIXME. Wrong, since t is not linear in the distance.
-      interp(position.k, target.k, t)   // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.k, target.k, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.u, target.u, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.v, target.v, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.w, target.w, t)   // FIXME. Wrong, since t is not linear in the distance.
     );
     apply_motion_limits(new_bez);
     bez_target = new_bez;
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       xyze_pos_t pos = bez_target;
       planner.apply_leveling(pos);
     #else
       const xyze_pos_t &pos = bez_target;
     #endif

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index a5e7696e0b..848906705f 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -175,23 +175,27 @@ void cubic_b_spline(
         assert(new_t - t >= (MIN_STEP) / 2.0);
         assert(new_t - t <= (MAX_STEP) * 2.0);
       }
     */
 
     step = new_t - t;
     t = new_t;
 
     // Compute and send new position
     xyze_pos_t new_bez = LOGICAL_AXIS_ARRAY(
-      interp(position.e, target.e, t),  // FIXME. These two are wrong, since the parameter t is not linear in the distance.
-      new_pos0, new_pos1,
-      interp(position.z, target.z, t)
+      interp(position.e, target.e, t),  // FIXME. Wrong, since t is not linear in the distance.
+      new_pos0,
+      new_pos1,
+      interp(position.z, target.z, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.i, target.i, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.j, target.j, t),  // FIXME. Wrong, since t is not linear in the distance.
+      interp(position.k, target.k, t)   // FIXME. Wrong, since t is not linear in the distance.
     );
     apply_motion_limits(new_bez);
     bez_target = new_bez;
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       xyze_pos_t pos = bez_target;
       planner.apply_leveling(pos);
     #else
       const xyze_pos_t &pos = bez_target;
     #endif

commit 82ea06e6a4ffdb0816ab92a5dd721ec5d770015d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 1 20:23:37 2021 -0500

    ‚ôªÔ∏è Patches for Zero Extruders (with TMC)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index be5ce4bbb4..a5e7696e0b 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -174,25 +174,25 @@ void cubic_b_spline(
       if (new_t < 1.0) {
         assert(new_t - t >= (MIN_STEP) / 2.0);
         assert(new_t - t <= (MAX_STEP) * 2.0);
       }
     */
 
     step = new_t - t;
     t = new_t;
 
     // Compute and send new position
-    xyze_pos_t new_bez = {
+    xyze_pos_t new_bez = LOGICAL_AXIS_ARRAY(
+      interp(position.e, target.e, t),  // FIXME. These two are wrong, since the parameter t is not linear in the distance.
       new_pos0, new_pos1,
-      interp(position.z, target.z, t),   // FIXME. These two are wrong, since the parameter t is
-      interp(position.e, target.e, t)    // not linear in the distance.
-    };
+      interp(position.z, target.z, t)
+    );
     apply_motion_limits(new_bez);
     bez_target = new_bez;
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       xyze_pos_t pos = bez_target;
       planner.apply_leveling(pos);
     #else
       const xyze_pos_t &pos = bez_target;
     #endif
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 02d878d5f5..be5ce4bbb4 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -36,42 +36,42 @@
 
 #include "../MarlinCore.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002f
 #define MAX_STEP 0.1f
 #define SIGMA 0.1f
 
 // Compute the linear interpolation between two real numbers.
-static inline float interp(const float &a, const float &b, const float &t) { return (1 - t) * a + t * b; }
+static inline float interp(const_float_t a, const_float_t b, const_float_t t) { return (1 - t) * a + t * b; }
 
 /**
  * Compute a B√©zier curve using the De Casteljau's algorithm (see
  * https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm), which is
  * easy to code and has good numerical stability (very important,
  * since Arudino works with limited precision real numbers).
  */
-static inline float eval_bezier(const float &a, const float &b, const float &c, const float &d, const float &t) {
+static inline float eval_bezier(const_float_t a, const_float_t b, const_float_t c, const_float_t d, const_float_t t) {
   const float iab = interp(a, b, t),
               ibc = interp(b, c, t),
               icd = interp(c, d, t),
               iabc = interp(iab, ibc, t),
               ibcd = interp(ibc, icd, t);
   return interp(iabc, ibcd, t);
 }
 
 /**
  * We approximate Euclidean distance with the sum of the coordinates
  * offset (so-called "norm 1"), which is quicker to compute.
  */
-static inline float dist1(const float &x1, const float &y1, const float &x2, const float &y2) { return ABS(x1 - x2) + ABS(y1 - y2); }
+static inline float dist1(const_float_t x1, const_float_t y1, const_float_t x2, const_float_t y2) { return ABS(x1 - x2) + ABS(y1 - y2); }
 
 /**
  * The algorithm for computing the step is loosely based on the one in Kig
  * (See https://sources.debian.net/src/kig/4:15.08.3-1/misc/kigpainter.cpp/#L759)
  * However, we do not use the stack.
  *
  * The algorithm goes as it follows: the parameters t runs from 0.0 to
  * 1.0 describing the curve, which is evaluated by eval_bezier(). At
  * each iteration we have to choose a step, i.e., the increment of the
  * t variable. By default the step of the previous iteration is taken,
@@ -102,21 +102,21 @@ static inline float dist1(const float &x1, const float &y1, const float &x2, con
  * chance" with the midpoint according to the parametrization). This
  * kind of glitches can be eliminated with proper first derivative
  * estimates; however, given the improbability of such configurations,
  * the mitigation offered by MIN_STEP and the small computational
  * power available on Arduino, I think it is not wise to implement it.
  */
 void cubic_b_spline(
   const xyze_pos_t &position,       // current position
   const xyze_pos_t &target,         // target position
   const xy_pos_t (&offsets)[2],     // a pair of offsets
-  const feedRate_t &scaled_fr_mm_s, // mm/s scaled by feedrate %
+  const_feedRate_t scaled_fr_mm_s,  // mm/s scaled by feedrate %
   const uint8_t extruder
 ) {
   // Absolute first and second control points are recovered.
   const xy_pos_t first = position + offsets[0], second = target + offsets[1];
 
   xyze_pos_t bez_target;
   bez_target.set(position.x, position.y);
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 4025b773ed..02d878d5f5 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -17,21 +17,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * planner_bezier.cpp
  *
  * Compute and buffer movement commands for bezier curves
- *
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
 
 #include "planner.h"
 #include "motion.h"
 #include "temperature.h"
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 1377abc034..4025b773ed 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * planner_bezier.cpp
  *
  * Compute and buffer movement commands for bezier curves
  *
  */
 

commit 000ec9fc139413c7702e8e295a29a21f6a6226e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 20 09:43:15 2020 -0500

    Ensure language.h include order
    
    See #17604

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 7ea3956436..1377abc034 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -29,21 +29,20 @@
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
 
 #include "planner.h"
 #include "motion.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
-#include "../core/language.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002f
 #define MAX_STEP 0.1f
 #define SIGMA 0.1f
 
 // Compute the linear interpolation between two real numbers.
 static inline float interp(const float &a, const float &b, const float &t) { return (1 - t) * a + t * b; }
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index db1f204444..7ea3956436 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 080f4e41a8..db1f204444 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -28,21 +28,21 @@
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
 
 #include "planner.h"
 #include "motion.h"
 #include "temperature.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002f
 #define MAX_STEP 0.1f
 #define SIGMA 0.1f
 
 // Compute the linear interpolation between two real numbers.
 static inline float interp(const float &a, const float &b, const float &t) { return (1 - t) * a + t * b; }

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 6e6746bce8..080f4e41a8 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -101,78 +101,74 @@ static inline float dist1(const float &x1, const float &y1, const float &x2, con
  * Caveat: this algorithm is not perfect, since it can happen that a
  * step is considered acceptable even when the curve is not linear at
  * all in the interval [t, t+step] (but its mid point coincides "by
  * chance" with the midpoint according to the parametrization). This
  * kind of glitches can be eliminated with proper first derivative
  * estimates; however, given the improbability of such configurations,
  * the mitigation offered by MIN_STEP and the small computational
  * power available on Arduino, I think it is not wise to implement it.
  */
 void cubic_b_spline(
-  const float position[NUM_AXIS],   // current position
-  const float target[NUM_AXIS],     // target position
-  const float (&offset)[4],         // a pair of offsets
+  const xyze_pos_t &position,       // current position
+  const xyze_pos_t &target,         // target position
+  const xy_pos_t (&offsets)[2],     // a pair of offsets
   const feedRate_t &scaled_fr_mm_s, // mm/s scaled by feedrate %
   const uint8_t extruder
 ) {
   // Absolute first and second control points are recovered.
-  const float first0 = position[X_AXIS] + offset[0],
-              first1 = position[Y_AXIS] + offset[1],
-              second0 = target[X_AXIS] + offset[2],
-              second1 = target[Y_AXIS] + offset[3];
-
-  float bez_target[4];
-  bez_target[X_AXIS] = position[X_AXIS];
-  bez_target[Y_AXIS] = position[Y_AXIS];
+  const xy_pos_t first = position + offsets[0], second = target + offsets[1];
+
+  xyze_pos_t bez_target;
+  bez_target.set(position.x, position.y);
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
   for (float t = 0; t < 1;) {
 
     thermalManager.manage_heater();
     millis_t now = millis();
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
     // close to a linear interpolation.
     bool did_reduce = false;
     float new_t = t + step;
     NOMORE(new_t, 1);
-    float new_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], new_t),
-          new_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], new_t);
+    float new_pos0 = eval_bezier(position.x, first.x, second.x, target.x, new_t),
+          new_pos1 = eval_bezier(position.y, first.y, second.y, target.y, new_t);
     for (;;) {
       if (new_t - t < (MIN_STEP)) break;
       const float candidate_t = 0.5f * (t + new_t),
-                  candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
-                  candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
-                  interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
-                  interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
+                  candidate_pos0 = eval_bezier(position.x, first.x, second.x, target.x, candidate_t),
+                  candidate_pos1 = eval_bezier(position.y, first.y, second.y, target.y, candidate_t),
+                  interp_pos0 = 0.5f * (bez_target.x + new_pos0),
+                  interp_pos1 = 0.5f * (bez_target.y + new_pos1);
       if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
       did_reduce = true;
     }
 
     // If we did not reduce the step, maybe we should enlarge it.
     if (!did_reduce) for (;;) {
       if (new_t - t > MAX_STEP) break;
       const float candidate_t = t + 2 * (new_t - t);
       if (candidate_t >= 1) break;
-      const float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
-                  candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
-                  interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
-                  interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
+      const float candidate_pos0 = eval_bezier(position.x, first.x, second.x, target.x, candidate_t),
+                  candidate_pos1 = eval_bezier(position.y, first.y, second.y, target.y, candidate_t),
+                  interp_pos0 = 0.5f * (bez_target.x + candidate_pos0),
+                  interp_pos1 = 0.5f * (bez_target.y + candidate_pos1);
       if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
     }
 
     // Check some postcondition; they are disabled in the actual
     // Marlin build, but if you test the same code on a computer you
     // may want to check they are respect.
     /*
@@ -180,31 +176,31 @@ void cubic_b_spline(
       if (new_t < 1.0) {
         assert(new_t - t >= (MIN_STEP) / 2.0);
         assert(new_t - t <= (MAX_STEP) * 2.0);
       }
     */
 
     step = new_t - t;
     t = new_t;
 
     // Compute and send new position
-    bez_target[X_AXIS] = new_pos0;
-    bez_target[Y_AXIS] = new_pos1;
-    // FIXME. The following two are wrong, since the parameter t is
-    // not linear in the distance.
-    bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
-    bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
-    apply_motion_limits(bez_target);
+    xyze_pos_t new_bez = {
+      new_pos0, new_pos1,
+      interp(position.z, target.z, t),   // FIXME. These two are wrong, since the parameter t is
+      interp(position.e, target.e, t)    // not linear in the distance.
+    };
+    apply_motion_limits(new_bez);
+    bez_target = new_bez;
 
     #if HAS_LEVELING && !PLANNER_LEVELING
-      float pos[XYZE] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS], bez_target[E_AXIS] };
+      xyze_pos_t pos = bez_target;
       planner.apply_leveling(pos);
     #else
-      const float (&pos)[XYZE] = bez_target;
+      const xyze_pos_t &pos = bez_target;
     #endif
 
     if (!planner.buffer_line(pos, scaled_fr_mm_s, active_extruder, step))
       break;
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 71a99594f5..6e6746bce8 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -100,36 +100,41 @@ static inline float dist1(const float &x1, const float &y1, const float &x2, con
  *
  * Caveat: this algorithm is not perfect, since it can happen that a
  * step is considered acceptable even when the curve is not linear at
  * all in the interval [t, t+step] (but its mid point coincides "by
  * chance" with the midpoint according to the parametrization). This
  * kind of glitches can be eliminated with proper first derivative
  * estimates; however, given the improbability of such configurations,
  * the mitigation offered by MIN_STEP and the small computational
  * power available on Arduino, I think it is not wise to implement it.
  */
-void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS], const float offset[4], float fr_mm_s, uint8_t extruder) {
+void cubic_b_spline(
+  const float position[NUM_AXIS],   // current position
+  const float target[NUM_AXIS],     // target position
+  const float (&offset)[4],         // a pair of offsets
+  const feedRate_t &scaled_fr_mm_s, // mm/s scaled by feedrate %
+  const uint8_t extruder
+) {
   // Absolute first and second control points are recovered.
   const float first0 = position[X_AXIS] + offset[0],
               first1 = position[Y_AXIS] + offset[1],
               second0 = target[X_AXIS] + offset[2],
               second1 = target[Y_AXIS] + offset[3];
-  float t = 0;
 
   float bez_target[4];
   bez_target[X_AXIS] = position[X_AXIS];
   bez_target[Y_AXIS] = position[Y_AXIS];
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
-  while (t < 1) {
+  for (float t = 0; t < 1;) {
 
     thermalManager.manage_heater();
     millis_t now = millis();
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
     // close to a linear interpolation.
@@ -190,16 +195,16 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
     apply_motion_limits(bez_target);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       float pos[XYZE] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS], bez_target[E_AXIS] };
       planner.apply_leveling(pos);
     #else
       const float (&pos)[XYZE] = bez_target;
     #endif
 
-    if (!planner.buffer_line(pos, fr_mm_s, active_extruder, step))
+    if (!planner.buffer_line(pos, scaled_fr_mm_s, active_extruder, step))
       break;
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index e27c87ee7d..71a99594f5 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 56bcb2d2d4..e27c87ee7d 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -181,21 +181,21 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     step = new_t - t;
     t = new_t;
 
     // Compute and send new position
     bez_target[X_AXIS] = new_pos0;
     bez_target[Y_AXIS] = new_pos1;
     // FIXME. The following two are wrong, since the parameter t is
     // not linear in the distance.
     bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
-    clamp_to_software_endstops(bez_target);
+    apply_motion_limits(bez_target);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       float pos[XYZE] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS], bez_target[E_AXIS] };
       planner.apply_leveling(pos);
     #else
       const float (&pos)[XYZE] = bez_target;
     #endif
 
     if (!planner.buffer_line(pos, fr_mm_s, active_extruder, step))
       break;

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index a547e23086..56bcb2d2d4 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 6ff6808a79..a547e23086 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -183,23 +183,23 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
 
     // Compute and send new position
     bez_target[X_AXIS] = new_pos0;
     bez_target[Y_AXIS] = new_pos1;
     // FIXME. The following two are wrong, since the parameter t is
     // not linear in the distance.
     bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
     clamp_to_software_endstops(bez_target);
 
-    #if HAS_UBL_AND_CURVES
-      float pos[XYZ] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS] };
+    #if HAS_LEVELING && !PLANNER_LEVELING
+      float pos[XYZE] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS], bez_target[E_AXIS] };
       planner.apply_leveling(pos);
-      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], bez_target[E_AXIS], fr_mm_s, active_extruder))
-        break;
     #else
-      if (!planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder))
-        break;
+      const float (&pos)[XYZE] = bez_target;
     #endif
+
+    if (!planner.buffer_line(pos, fr_mm_s, active_extruder, step))
+      break;
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit a4b01483650ce50e3916d4bc16553429825603ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 23:55:12 2018 -0500

    Easier to find 'static inline'

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 407d8a0670..6ff6808a79 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -38,43 +38,42 @@
 #include "../Marlin.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002f
 #define MAX_STEP 0.1f
 #define SIGMA 0.1f
 
 // Compute the linear interpolation between two real numbers.
-inline static float interp(float a, float b, float t) { return (1 - t) * a + t * b; }
+static inline float interp(const float &a, const float &b, const float &t) { return (1 - t) * a + t * b; }
 
 /**
  * Compute a B√©zier curve using the De Casteljau's algorithm (see
  * https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm), which is
  * easy to code and has good numerical stability (very important,
  * since Arudino works with limited precision real numbers).
  */
-inline static float eval_bezier(float a, float b, float c, float d, float t) {
-  float iab = interp(a, b, t);
-  float ibc = interp(b, c, t);
-  float icd = interp(c, d, t);
-  float iabc = interp(iab, ibc, t);
-  float ibcd = interp(ibc, icd, t);
-  float iabcd = interp(iabc, ibcd, t);
-  return iabcd;
+static inline float eval_bezier(const float &a, const float &b, const float &c, const float &d, const float &t) {
+  const float iab = interp(a, b, t),
+              ibc = interp(b, c, t),
+              icd = interp(c, d, t),
+              iabc = interp(iab, ibc, t),
+              ibcd = interp(ibc, icd, t);
+  return interp(iabc, ibcd, t);
 }
 
 /**
  * We approximate Euclidean distance with the sum of the coordinates
  * offset (so-called "norm 1"), which is quicker to compute.
  */
-inline static float dist1(float x1, float y1, float x2, float y2) { return ABS(x1 - x2) + ABS(y1 - y2); }
+static inline float dist1(const float &x1, const float &y1, const float &x2, const float &y2) { return ABS(x1 - x2) + ABS(y1 - y2); }
 
 /**
  * The algorithm for computing the step is loosely based on the one in Kig
  * (See https://sources.debian.net/src/kig/4:15.08.3-1/misc/kigpainter.cpp/#L759)
  * However, we do not use the stack.
  *
  * The algorithm goes as it follows: the parameters t runs from 0.0 to
  * 1.0 describing the curve, which is evaluated by eval_bezier(). At
  * each iteration we have to choose a step, i.e., the increment of the
  * t variable. By default the step of the previous iteration is taken,

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index caf2528895..407d8a0670 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -33,26 +33,26 @@
 
 #include "planner.h"
 #include "motion.h"
 #include "temperature.h"
 
 #include "../Marlin.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
-#define MIN_STEP 0.002
-#define MAX_STEP 0.1
-#define SIGMA 0.1
+#define MIN_STEP 0.002f
+#define MAX_STEP 0.1f
+#define SIGMA 0.1f
 
 // Compute the linear interpolation between two real numbers.
-inline static float interp(float a, float b, float t) { return (1.0 - t) * a + t * b; }
+inline static float interp(float a, float b, float t) { return (1 - t) * a + t * b; }
 
 /**
  * Compute a B√©zier curve using the De Casteljau's algorithm (see
  * https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm), which is
  * easy to code and has good numerical stability (very important,
  * since Arudino works with limited precision real numbers).
  */
 inline static float eval_bezier(float a, float b, float c, float d, float t) {
   float iab = interp(a, b, t);
   float ibc = interp(b, c, t);
@@ -107,68 +107,68 @@ inline static float dist1(float x1, float y1, float x2, float y2) { return ABS(x
  * estimates; however, given the improbability of such configurations,
  * the mitigation offered by MIN_STEP and the small computational
  * power available on Arduino, I think it is not wise to implement it.
  */
 void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS], const float offset[4], float fr_mm_s, uint8_t extruder) {
   // Absolute first and second control points are recovered.
   const float first0 = position[X_AXIS] + offset[0],
               first1 = position[Y_AXIS] + offset[1],
               second0 = target[X_AXIS] + offset[2],
               second1 = target[Y_AXIS] + offset[3];
-  float t = 0.0;
+  float t = 0;
 
   float bez_target[4];
   bez_target[X_AXIS] = position[X_AXIS];
   bez_target[Y_AXIS] = position[Y_AXIS];
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
-  while (t < 1.0) {
+  while (t < 1) {
 
     thermalManager.manage_heater();
     millis_t now = millis();
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
     // close to a linear interpolation.
     bool did_reduce = false;
     float new_t = t + step;
-    NOMORE(new_t, 1.0);
+    NOMORE(new_t, 1);
     float new_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], new_t),
           new_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], new_t);
     for (;;) {
       if (new_t - t < (MIN_STEP)) break;
-      const float candidate_t = 0.5 * (t + new_t),
+      const float candidate_t = 0.5f * (t + new_t),
                   candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
                   candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
-                  interp_pos0 = 0.5 * (bez_target[X_AXIS] + new_pos0),
-                  interp_pos1 = 0.5 * (bez_target[Y_AXIS] + new_pos1);
+                  interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
+                  interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
       if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
       did_reduce = true;
     }
 
     // If we did not reduce the step, maybe we should enlarge it.
     if (!did_reduce) for (;;) {
       if (new_t - t > MAX_STEP) break;
-      const float candidate_t = t + 2.0 * (new_t - t);
-      if (candidate_t >= 1.0) break;
+      const float candidate_t = t + 2 * (new_t - t);
+      if (candidate_t >= 1) break;
       const float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
                   candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
-                  interp_pos0 = 0.5 * (bez_target[X_AXIS] + candidate_pos0),
-                  interp_pos1 = 0.5 * (bez_target[Y_AXIS] + candidate_pos1);
+                  interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
+                  interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
       if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
     }
 
     // Check some postcondition; they are disabled in the actual
     // Marlin build, but if you test the same code on a computer you
     // may want to check they are respect.
     /*

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index bbd1e82625..caf2528895 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -187,18 +187,20 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     bez_target[Y_AXIS] = new_pos1;
     // FIXME. The following two are wrong, since the parameter t is
     // not linear in the distance.
     bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
     clamp_to_software_endstops(bez_target);
 
     #if HAS_UBL_AND_CURVES
       float pos[XYZ] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS] };
       planner.apply_leveling(pos);
-      planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], bez_target[E_AXIS], fr_mm_s, active_extruder);
+      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], bez_target[E_AXIS], fr_mm_s, active_extruder))
+        break;
     #else
-      planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder);
+      if (!planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder))
+        break;
     #endif
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 4bba9850b7..bbd1e82625 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -60,21 +60,21 @@ inline static float eval_bezier(float a, float b, float c, float d, float t) {
   float iabc = interp(iab, ibc, t);
   float ibcd = interp(ibc, icd, t);
   float iabcd = interp(iabc, ibcd, t);
   return iabcd;
 }
 
 /**
  * We approximate Euclidean distance with the sum of the coordinates
  * offset (so-called "norm 1"), which is quicker to compute.
  */
-inline static float dist1(float x1, float y1, float x2, float y2) { return FABS(x1 - x2) + FABS(y1 - y2); }
+inline static float dist1(float x1, float y1, float x2, float y2) { return ABS(x1 - x2) + ABS(y1 - y2); }
 
 /**
  * The algorithm for computing the step is loosely based on the one in Kig
  * (See https://sources.debian.net/src/kig/4:15.08.3-1/misc/kigpainter.cpp/#L759)
  * However, we do not use the stack.
  *
  * The algorithm goes as it follows: the parameters t runs from 0.0 to
  * 1.0 describing the curve, which is evaluated by eval_bezier(). At
  * each iteration we have to choose a step, i.e., the increment of the
  * t variable. By default the step of the previous iteration is taken,

commit 19f189b4e5e10bdbdb3b28d94fa180f74cdbd654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 8 11:10:45 2018 -0500

    Add UBL support for G2/G3 and G5 (#10648)

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 14ac645bc9..4bba9850b7 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -183,15 +183,22 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     t = new_t;
 
     // Compute and send new position
     bez_target[X_AXIS] = new_pos0;
     bez_target[Y_AXIS] = new_pos1;
     // FIXME. The following two are wrong, since the parameter t is
     // not linear in the distance.
     bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
     bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
     clamp_to_software_endstops(bez_target);
-    planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder);
+
+    #if HAS_UBL_AND_CURVES
+      float pos[XYZ] = { bez_target[X_AXIS], bez_target[Y_AXIS], bez_target[Z_AXIS] };
+      planner.apply_leveling(pos);
+      planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], bez_target[E_AXIS], fr_mm_s, active_extruder);
+    #else
+      planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder);
+    #endif
   }
 }
 
 #endif // BEZIER_CURVE_SUPPORT

commit 32512332df436514a5d00fca28b68cb08860fab1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 18 02:08:03 2017 -0600

    Apply some formatting

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 136362d346..14ac645bc9 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -37,22 +37,21 @@
 
 #include "../Marlin.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002
 #define MAX_STEP 0.1
 #define SIGMA 0.1
 
-/* Compute the linear interpolation between to real numbers.
-*/
+// Compute the linear interpolation between two real numbers.
 inline static float interp(float a, float b, float t) { return (1.0 - t) * a + t * b; }
 
 /**
  * Compute a B√©zier curve using the De Casteljau's algorithm (see
  * https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm), which is
  * easy to code and has good numerical stability (very important,
  * since Arudino works with limited precision real numbers).
  */
 inline static float eval_bezier(float a, float b, float c, float d, float t) {
   float iab = interp(a, b, t);

commit dac1f6fe74715bc4fcfc8f7f386b56ad8fee02d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 1 12:04:18 2017 -0500

    Tweaks to cubic_b_spline code style

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index e5becc10c4..136362d346 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -104,24 +104,24 @@ inline static float dist1(float x1, float y1, float x2, float y2) { return FABS(
  * step is considered acceptable even when the curve is not linear at
  * all in the interval [t, t+step] (but its mid point coincides "by
  * chance" with the midpoint according to the parametrization). This
  * kind of glitches can be eliminated with proper first derivative
  * estimates; however, given the improbability of such configurations,
  * the mitigation offered by MIN_STEP and the small computational
  * power available on Arduino, I think it is not wise to implement it.
  */
 void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS], const float offset[4], float fr_mm_s, uint8_t extruder) {
   // Absolute first and second control points are recovered.
-  float first0 = position[X_AXIS] + offset[0];
-  float first1 = position[Y_AXIS] + offset[1];
-  float second0 = target[X_AXIS] + offset[2];
-  float second1 = target[Y_AXIS] + offset[3];
+  const float first0 = position[X_AXIS] + offset[0],
+              first1 = position[Y_AXIS] + offset[1],
+              second0 = target[X_AXIS] + offset[2],
+              second1 = target[Y_AXIS] + offset[3];
   float t = 0.0;
 
   float bez_target[4];
   bez_target[X_AXIS] = position[X_AXIS];
   bez_target[Y_AXIS] = position[Y_AXIS];
   float step = MAX_STEP;
 
   millis_t next_idle_ms = millis() + 200UL;
 
   while (t < 1.0) {
@@ -131,45 +131,45 @@ void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS]
     if (ELAPSED(now, next_idle_ms)) {
       next_idle_ms = now + 200UL;
       idle();
     }
 
     // First try to reduce the step in order to make it sufficiently
     // close to a linear interpolation.
     bool did_reduce = false;
     float new_t = t + step;
     NOMORE(new_t, 1.0);
-    float new_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], new_t);
-    float new_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], new_t);
+    float new_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], new_t),
+          new_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], new_t);
     for (;;) {
       if (new_t - t < (MIN_STEP)) break;
-      float candidate_t = 0.5 * (t + new_t);
-      float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t);
-      float candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t);
-      float interp_pos0 = 0.5 * (bez_target[X_AXIS] + new_pos0);
-      float interp_pos1 = 0.5 * (bez_target[Y_AXIS] + new_pos1);
+      const float candidate_t = 0.5 * (t + new_t),
+                  candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
+                  candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
+                  interp_pos0 = 0.5 * (bez_target[X_AXIS] + new_pos0),
+                  interp_pos1 = 0.5 * (bez_target[Y_AXIS] + new_pos1);
       if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
       did_reduce = true;
     }
 
     // If we did not reduce the step, maybe we should enlarge it.
     if (!did_reduce) for (;;) {
       if (new_t - t > MAX_STEP) break;
-      float candidate_t = t + 2.0 * (new_t - t);
+      const float candidate_t = t + 2.0 * (new_t - t);
       if (candidate_t >= 1.0) break;
-      float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t);
-      float candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t);
-      float interp_pos0 = 0.5 * (bez_target[X_AXIS] + candidate_pos0);
-      float interp_pos1 = 0.5 * (bez_target[Y_AXIS] + candidate_pos1);
+      const float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t),
+                  candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t),
+                  interp_pos0 = 0.5 * (bez_target[X_AXIS] + candidate_pos0),
+                  interp_pos1 = 0.5 * (bez_target[Y_AXIS] + candidate_pos1);
       if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (SIGMA)) break;
       new_t = candidate_t;
       new_pos0 = candidate_pos0;
       new_pos1 = candidate_pos1;
     }
 
     // Check some postcondition; they are disabled in the actual
     // Marlin build, but if you test the same code on a computer you
     // may want to check they are respect.
     /*

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index fe0a652b5e..e5becc10c4 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -24,24 +24,27 @@
  * planner_bezier.cpp
  *
  * Compute and buffer movement commands for bezier curves
  *
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
 
+#include "planner.h"
+#include "motion.h"
+#include "temperature.h"
+
 #include "../Marlin.h"
-#include "../module/planner.h"
 #include "../core/language.h"
-#include "../module/temperature.h"
+#include "../gcode/queue.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002
 #define MAX_STEP 0.1
 #define SIGMA 0.1
 
 /* Compute the linear interpolation between to real numbers.
 */
 inline static float interp(float a, float b, float t) { return (1.0 - t) * a + t * b; }
 

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
index 71697e04ae..fe0a652b5e 100644
--- a/Marlin/src/module/planner_bezier.cpp
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -20,27 +20,28 @@
  *
  */
 
 /**
  * planner_bezier.cpp
  *
  * Compute and buffer movement commands for bezier curves
  *
  */
 
-#include "Marlin.h"
+#include "../inc/MarlinConfig.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
 
-#include "planner.h"
-#include "language.h"
-#include "temperature.h"
+#include "../Marlin.h"
+#include "../module/planner.h"
+#include "../core/language.h"
+#include "../module/temperature.h"
 
 // See the meaning in the documentation of cubic_b_spline().
 #define MIN_STEP 0.002
 #define MAX_STEP 0.1
 #define SIGMA 0.1
 
 /* Compute the linear interpolation between to real numbers.
 */
 inline static float interp(float a, float b, float t) { return (1.0 - t) * a + t * b; }
 

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/planner_bezier.cpp b/Marlin/src/module/planner_bezier.cpp
new file mode 100644
index 0000000000..71697e04ae
--- /dev/null
+++ b/Marlin/src/module/planner_bezier.cpp
@@ -0,0 +1,194 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * planner_bezier.cpp
+ *
+ * Compute and buffer movement commands for bezier curves
+ *
+ */
+
+#include "Marlin.h"
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+
+#include "planner.h"
+#include "language.h"
+#include "temperature.h"
+
+// See the meaning in the documentation of cubic_b_spline().
+#define MIN_STEP 0.002
+#define MAX_STEP 0.1
+#define SIGMA 0.1
+
+/* Compute the linear interpolation between to real numbers.
+*/
+inline static float interp(float a, float b, float t) { return (1.0 - t) * a + t * b; }
+
+/**
+ * Compute a B√©zier curve using the De Casteljau's algorithm (see
+ * https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm), which is
+ * easy to code and has good numerical stability (very important,
+ * since Arudino works with limited precision real numbers).
+ */
+inline static float eval_bezier(float a, float b, float c, float d, float t) {
+  float iab = interp(a, b, t);
+  float ibc = interp(b, c, t);
+  float icd = interp(c, d, t);
+  float iabc = interp(iab, ibc, t);
+  float ibcd = interp(ibc, icd, t);
+  float iabcd = interp(iabc, ibcd, t);
+  return iabcd;
+}
+
+/**
+ * We approximate Euclidean distance with the sum of the coordinates
+ * offset (so-called "norm 1"), which is quicker to compute.
+ */
+inline static float dist1(float x1, float y1, float x2, float y2) { return FABS(x1 - x2) + FABS(y1 - y2); }
+
+/**
+ * The algorithm for computing the step is loosely based on the one in Kig
+ * (See https://sources.debian.net/src/kig/4:15.08.3-1/misc/kigpainter.cpp/#L759)
+ * However, we do not use the stack.
+ *
+ * The algorithm goes as it follows: the parameters t runs from 0.0 to
+ * 1.0 describing the curve, which is evaluated by eval_bezier(). At
+ * each iteration we have to choose a step, i.e., the increment of the
+ * t variable. By default the step of the previous iteration is taken,
+ * and then it is enlarged or reduced depending on how straight the
+ * curve locally is. The step is always clamped between MIN_STEP/2 and
+ * 2*MAX_STEP. MAX_STEP is taken at the first iteration.
+ *
+ * For some t, the step value is considered acceptable if the curve in
+ * the interval [t, t+step] is sufficiently straight, i.e.,
+ * sufficiently close to linear interpolation. In practice the
+ * following test is performed: the distance between eval_bezier(...,
+ * t+step/2) is evaluated and compared with 0.5*(eval_bezier(...,
+ * t)+eval_bezier(..., t+step)). If it is smaller than SIGMA, then the
+ * step value is considered acceptable, otherwise it is not. The code
+ * seeks to find the larger step value which is considered acceptable.
+ *
+ * At every iteration the recorded step value is considered and then
+ * iteratively halved until it becomes acceptable. If it was already
+ * acceptable in the beginning (i.e., no halving were done), then
+ * maybe it was necessary to enlarge it; then it is iteratively
+ * doubled while it remains acceptable. The last acceptable value
+ * found is taken, provided that it is between MIN_STEP and MAX_STEP
+ * and does not bring t over 1.0.
+ *
+ * Caveat: this algorithm is not perfect, since it can happen that a
+ * step is considered acceptable even when the curve is not linear at
+ * all in the interval [t, t+step] (but its mid point coincides "by
+ * chance" with the midpoint according to the parametrization). This
+ * kind of glitches can be eliminated with proper first derivative
+ * estimates; however, given the improbability of such configurations,
+ * the mitigation offered by MIN_STEP and the small computational
+ * power available on Arduino, I think it is not wise to implement it.
+ */
+void cubic_b_spline(const float position[NUM_AXIS], const float target[NUM_AXIS], const float offset[4], float fr_mm_s, uint8_t extruder) {
+  // Absolute first and second control points are recovered.
+  float first0 = position[X_AXIS] + offset[0];
+  float first1 = position[Y_AXIS] + offset[1];
+  float second0 = target[X_AXIS] + offset[2];
+  float second1 = target[Y_AXIS] + offset[3];
+  float t = 0.0;
+
+  float bez_target[4];
+  bez_target[X_AXIS] = position[X_AXIS];
+  bez_target[Y_AXIS] = position[Y_AXIS];
+  float step = MAX_STEP;
+
+  millis_t next_idle_ms = millis() + 200UL;
+
+  while (t < 1.0) {
+
+    thermalManager.manage_heater();
+    millis_t now = millis();
+    if (ELAPSED(now, next_idle_ms)) {
+      next_idle_ms = now + 200UL;
+      idle();
+    }
+
+    // First try to reduce the step in order to make it sufficiently
+    // close to a linear interpolation.
+    bool did_reduce = false;
+    float new_t = t + step;
+    NOMORE(new_t, 1.0);
+    float new_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], new_t);
+    float new_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], new_t);
+    for (;;) {
+      if (new_t - t < (MIN_STEP)) break;
+      float candidate_t = 0.5 * (t + new_t);
+      float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t);
+      float candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t);
+      float interp_pos0 = 0.5 * (bez_target[X_AXIS] + new_pos0);
+      float interp_pos1 = 0.5 * (bez_target[Y_AXIS] + new_pos1);
+      if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (SIGMA)) break;
+      new_t = candidate_t;
+      new_pos0 = candidate_pos0;
+      new_pos1 = candidate_pos1;
+      did_reduce = true;
+    }
+
+    // If we did not reduce the step, maybe we should enlarge it.
+    if (!did_reduce) for (;;) {
+      if (new_t - t > MAX_STEP) break;
+      float candidate_t = t + 2.0 * (new_t - t);
+      if (candidate_t >= 1.0) break;
+      float candidate_pos0 = eval_bezier(position[X_AXIS], first0, second0, target[X_AXIS], candidate_t);
+      float candidate_pos1 = eval_bezier(position[Y_AXIS], first1, second1, target[Y_AXIS], candidate_t);
+      float interp_pos0 = 0.5 * (bez_target[X_AXIS] + candidate_pos0);
+      float interp_pos1 = 0.5 * (bez_target[Y_AXIS] + candidate_pos1);
+      if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (SIGMA)) break;
+      new_t = candidate_t;
+      new_pos0 = candidate_pos0;
+      new_pos1 = candidate_pos1;
+    }
+
+    // Check some postcondition; they are disabled in the actual
+    // Marlin build, but if you test the same code on a computer you
+    // may want to check they are respect.
+    /*
+      assert(new_t <= 1.0);
+      if (new_t < 1.0) {
+        assert(new_t - t >= (MIN_STEP) / 2.0);
+        assert(new_t - t <= (MAX_STEP) * 2.0);
+      }
+    */
+
+    step = new_t - t;
+    t = new_t;
+
+    // Compute and send new position
+    bez_target[X_AXIS] = new_pos0;
+    bez_target[Y_AXIS] = new_pos1;
+    // FIXME. The following two are wrong, since the parameter t is
+    // not linear in the distance.
+    bez_target[Z_AXIS] = interp(position[Z_AXIS], target[Z_AXIS], t);
+    bez_target[E_AXIS] = interp(position[E_AXIS], target[E_AXIS], t);
+    clamp_to_software_endstops(bez_target);
+    planner.buffer_line_kinematic(bez_target, fr_mm_s, extruder);
+  }
+}
+
+#endif // BEZIER_CURVE_SUPPORT
