commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    🚸 Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 55698c942b..0ab1ca6105 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -45,22 +45,20 @@
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_LCD_PROUI)
-  #include "../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if ENABLED(LASER_FEATURE)
   #include "../../feature/spindle_laser.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
@@ -216,21 +214,21 @@ void GcodeSuite::G28() {
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     const M_StateEnum old_grblstate = M_State_grbl;
     set_and_report_grblstate(M_HOMING);
   #endif
 
-  TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingStart());
+  TERN_(DWIN_CREALITY_LCD, dwinHomingStart());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #if NUM_AXES
 
     #if ENABLED(DUAL_X_CARRIAGE)
@@ -645,21 +643,21 @@ void GcodeSuite::G28() {
 
     restore_feedrate_and_scaling();
 
     if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
       SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #endif // NUM_AXES
 
   ui.refresh();
 
-  TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingDone());
+  TERN_(DWIN_CREALITY_LCD, dwinHomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
   #ifdef EVENT_GCODE_AFTER_HOMING
     gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_HOMING));
   #endif
 

commit 38f483c4a6a0b6c814e5ee88747f58eed17fa61e
Author: mikemerryguy <57319047+mikemerryguy@users.noreply.github.com>
Date:   Sun Jan 7 23:14:24 2024 -0500

    🩹 Skip post-G28 XY move for untrusted X or Y (#26644)
    
    Followup to #26469
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 98d0a40148..55698c942b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -632,22 +632,22 @@ void GcodeSuite::G28() {
     #endif
 
     TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
 
     // Restore the active tool after homing
     #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
       tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
     #endif
 
     #ifdef XY_AFTER_HOMING
-      constexpr xy_pos_t xy_after XY_AFTER_HOMING;
-      do_blocking_move_to(xy_after);
+      if (!axes_should_home(_BV(X_AXIS) | _BV(Y_AXIS)))
+        do_blocking_move_to(xy_pos_t(XY_AFTER_HOMING));
     #endif
 
     restore_feedrate_and_scaling();
 
     if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
       SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #endif // NUM_AXES
 
   ui.refresh();

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    🔧 Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index dbdbdc5aff..98d0a40148 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -148,33 +148,33 @@
 
   motion_state_t begin_slow_homing() {
     motion_state_t motion_state{0};
     motion_state.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
                                  planner.settings.max_acceleration_mm_per_s2[Y_AXIS]
                                  OPTARG(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
                                );
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
     TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = 100);
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       motion_state.jerk_state = planner.max_jerk;
       planner.max_jerk.set(0, 0 OPTARG(DELTA, 0));
     #endif
     planner.refresh_acceleration_rates();
     return motion_state;
   }
 
   void end_slow_homing(const motion_state_t &motion_state) {
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = motion_state.acceleration.x;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = motion_state.acceleration.y;
     TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = motion_state.acceleration.z);
-    TERN_(HAS_CLASSIC_JERK, planner.max_jerk = motion_state.jerk_state);
+    TERN_(CLASSIC_JERK, planner.max_jerk = motion_state.jerk_state);
     planner.refresh_acceleration_rates();
   }
 
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *

commit 1a42c38e0eefdf62976bf7a5a35224d3c675f9ff
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Dec 2 22:03:46 2023 -0800

    🩹 Replace more DEBUG_ECHOF (#26495)
    
    Followup to #25928

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ba16c7bbd7..dbdbdc5aff 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -256,21 +256,21 @@ void GcodeSuite::G28() {
 
     #define _OR_HAS_CURR_HOME(N) HAS_CURRENT_HOME(N) ||
     #if MAIN_AXIS_MAP(_OR_HAS_CURR_HOME) MAP(_OR_HAS_CURR_HOME, X2, Y2, Z2, Z3, Z4) 0
       #define HAS_HOMING_CURRENT 1
     #endif
 
     #if HAS_HOMING_CURRENT
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOLN(s, F(" current: "), a, F(" -> "), b); }
         };
       #else
         #define debug_current(...)
       #endif
 
       #define _SAVE_SET_CURRENT(A) \
         const int16_t saved_current_##A = stepper##A.getMilliamps(); \
         stepper##A.rms_current(A##_CURRENT_HOME); \
         debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
 

commit f4228cc4c1e1ed499a07f9357afa6a978c1fd7a5
Author: mikemerryguy <57319047+mikemerryguy@users.noreply.github.com>
Date:   Tue Nov 28 18:55:21 2023 -0500

    ✨ XY_AFTER_HOMING, EVENT_GCODE_AFTER_HOMING (#26469)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 531dc5b558..ba16c7bbd7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -631,27 +631,36 @@ void GcodeSuite::G28() {
       if (finalRaiseZ) do_move_after_z_homing();
     #endif
 
     TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
 
     // Restore the active tool after homing
     #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
       tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
     #endif
 
+    #ifdef XY_AFTER_HOMING
+      constexpr xy_pos_t xy_after XY_AFTER_HOMING;
+      do_blocking_move_to(xy_after);
+    #endif
+
     restore_feedrate_and_scaling();
 
     if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
       SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #endif // NUM_AXES
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
+  #ifdef EVENT_GCODE_AFTER_HOMING
+    gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_HOMING));
+  #endif
+
 }

commit 4744997c164931f8c1f8753ba4112e466b7c83a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 12:14:57 2023 -0500

    📝 GCode => G-Code

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index fd034f0ba6..531dc5b558 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -529,21 +529,21 @@ void GcodeSuite::G28() {
 
       #endif // HAS_Z_AXIS
 
       sync_plan_position();
 
     #endif
 
     /**
      * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
      * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
-     * then print a standard GCode file that contains a single print that does a G28 and has no other
+     * then print a standard G-Code file that contains a single print that does a G28 and has no other
      * IDEX specific commands in it.
      */
     #if ENABLED(DUAL_X_CARRIAGE)
 
       if (idex_is_duplicating()) {
 
         TERN_(IMPROVE_HOMING_RELIABILITY, saved_motion_state = begin_slow_homing());
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    🔧 More endstops refactoring (#25758)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b364c0382c..fd034f0ba6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -247,83 +247,81 @@ void GcodeSuite::G28() {
 
     // Cancel any prior G29 session
     TERN_(PROBE_MANUALLY, g29_in_progress = false);
 
     // Disable leveling before homing
     TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
     // Reset to the XY plane
     TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
-    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
+    #define _OR_HAS_CURR_HOME(N) HAS_CURRENT_HOME(N) ||
+    #if MAIN_AXIS_MAP(_OR_HAS_CURR_HOME) MAP(_OR_HAS_CURR_HOME, X2, Y2, Z2, Z3, Z4) 0
       #define HAS_HOMING_CURRENT 1
     #endif
 
     #if HAS_HOMING_CURRENT
-      auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-        DEBUG_ECHOLN(s, F(" current: "), a, F(" -> "), b);
-      };
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+        };
+      #else
+        #define debug_current(...)
+      #endif
+
+      #define _SAVE_SET_CURRENT(A) \
+        const int16_t saved_current_##A = stepper##A.getMilliamps(); \
+        stepper##A.rms_current(A##_CURRENT_HOME); \
+        debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
+
       #if HAS_CURRENT_HOME(X)
-        const int16_t tmc_save_current_X = stepperX.getMilliamps();
-        stepperX.rms_current(X_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_X), tmc_save_current_X, X_CURRENT_HOME);
+        _SAVE_SET_CURRENT(X);
       #endif
       #if HAS_CURRENT_HOME(X2)
-        const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
-        stepperX2.rms_current(X2_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_X2), tmc_save_current_X2, X2_CURRENT_HOME);
+        _SAVE_SET_CURRENT(X2);
       #endif
       #if HAS_CURRENT_HOME(Y)
-        const int16_t tmc_save_current_Y = stepperY.getMilliamps();
-        stepperY.rms_current(Y_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_Y), tmc_save_current_Y, Y_CURRENT_HOME);
+        _SAVE_SET_CURRENT(Y);
       #endif
       #if HAS_CURRENT_HOME(Y2)
-        const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
-        stepperY2.rms_current(Y2_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_Y2), tmc_save_current_Y2, Y2_CURRENT_HOME);
+        _SAVE_SET_CURRENT(Y2);
+      #endif
+      #if HAS_CURRENT_HOME(Z)
+        _SAVE_SET_CURRENT(Z);
       #endif
-      #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
-        const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
-        stepperZ.rms_current(Z_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_Z), tmc_save_current_Z, Z_CURRENT_HOME);
+      #if HAS_CURRENT_HOME(Z2)
+        _SAVE_SET_CURRENT(Z2);
+      #endif
+      #if HAS_CURRENT_HOME(Z3)
+        _SAVE_SET_CURRENT(Z3);
+      #endif
+      #if HAS_CURRENT_HOME(Z4)
+        _SAVE_SET_CURRENT(Z4);
       #endif
       #if HAS_CURRENT_HOME(I)
-        const int16_t tmc_save_current_I = stepperI.getMilliamps();
-        stepperI.rms_current(I_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
+        _SAVE_SET_CURRENT(I);
       #endif
       #if HAS_CURRENT_HOME(J)
-        const int16_t tmc_save_current_J = stepperJ.getMilliamps();
-        stepperJ.rms_current(J_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
+        _SAVE_SET_CURRENT(J);
       #endif
       #if HAS_CURRENT_HOME(K)
-        const int16_t tmc_save_current_K = stepperK.getMilliamps();
-        stepperK.rms_current(K_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
+        _SAVE_SET_CURRENT(K);
       #endif
       #if HAS_CURRENT_HOME(U)
-        const int16_t tmc_save_current_U = stepperU.getMilliamps();
-        stepperU.rms_current(U_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_U), tmc_save_current_U, U_CURRENT_HOME);
+        _SAVE_SET_CURRENT(U);
       #endif
       #if HAS_CURRENT_HOME(V)
-        const int16_t tmc_save_current_V = stepperV.getMilliamps();
-        stepperV.rms_current(V_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
+        _SAVE_SET_CURRENT(V);
       #endif
       #if HAS_CURRENT_HOME(W)
-        const int16_t tmc_save_current_W = stepperW.getMilliamps();
-        stepperW.rms_current(W_CURRENT_HOME);
-        if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
+        _SAVE_SET_CURRENT(W);
       #endif
       #if SENSORLESS_STALLGUARD_DELAY
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
     #endif // HAS_HOMING_CURRENT
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       motion_state_t saved_motion_state = begin_slow_homing();
     #endif
 
@@ -570,51 +568,60 @@ void GcodeSuite::G28() {
     #endif // DUAL_X_CARRIAGE
 
     endstops.not_homing();
 
     // Clear endstop state for polled stallGuard endstops
     TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
     #if HAS_HOMING_CURRENT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
       #if HAS_CURRENT_HOME(X)
-        stepperX.rms_current(tmc_save_current_X);
+        stepperX.rms_current(saved_current_X);
       #endif
       #if HAS_CURRENT_HOME(X2)
-        stepperX2.rms_current(tmc_save_current_X2);
+        stepperX2.rms_current(saved_current_X2);
       #endif
       #if HAS_CURRENT_HOME(Y)
-        stepperY.rms_current(tmc_save_current_Y);
+        stepperY.rms_current(saved_current_Y);
       #endif
       #if HAS_CURRENT_HOME(Y2)
-        stepperY2.rms_current(tmc_save_current_Y2);
+        stepperY2.rms_current(saved_current_Y2);
+      #endif
+      #if HAS_CURRENT_HOME(Z)
+        stepperZ.rms_current(saved_current_Z);
+      #endif
+      #if HAS_CURRENT_HOME(Z2)
+        stepperZ2.rms_current(saved_current_Z2);
+      #endif
+      #if HAS_CURRENT_HOME(Z3)
+        stepperZ3.rms_current(saved_current_Z3);
       #endif
-      #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
-        stepperZ.rms_current(tmc_save_current_Z);
+      #if HAS_CURRENT_HOME(Z4)
+        stepperZ4.rms_current(saved_current_Z4);
       #endif
       #if HAS_CURRENT_HOME(I)
-        stepperI.rms_current(tmc_save_current_I);
+        stepperI.rms_current(saved_current_I);
       #endif
       #if HAS_CURRENT_HOME(J)
-        stepperJ.rms_current(tmc_save_current_J);
+        stepperJ.rms_current(saved_current_J);
       #endif
       #if HAS_CURRENT_HOME(K)
-        stepperK.rms_current(tmc_save_current_K);
+        stepperK.rms_current(saved_current_K);
       #endif
       #if HAS_CURRENT_HOME(U)
-        stepperU.rms_current(tmc_save_current_U);
+        stepperU.rms_current(saved_current_U);
       #endif
       #if HAS_CURRENT_HOME(V)
-        stepperV.rms_current(tmc_save_current_V);
+        stepperV.rms_current(saved_current_V);
       #endif
       #if HAS_CURRENT_HOME(W)
-        stepperW.rms_current(tmc_save_current_W);
+        stepperW.rms_current(saved_current_W);
       #endif
       #if SENSORLESS_STALLGUARD_DELAY
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
     #endif // HAS_HOMING_CURRENT
 
     // Move to a height where we can use the full xy-area
     TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
 
     #if HAS_Z_AXIS

commit 9135e3f7d3fd0d634656f1c54c70a0ba1f878bfd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 21:10:03 2023 -0500

    🚸 Revert M206 Home Offset behavior (#25996)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 33a8ed76e6..b364c0382c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -113,28 +113,21 @@
     // Disallow Z homing if X or Y homing is needed
     if (homing_needed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     constexpr xy_float_t safe_homing_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
-    #if HAS_HOME_OFFSET && DISABLED(Z_SAFE_HOMING_POINT_ABSOLUTE)
-      xy_float_t okay_homing_xy = safe_homing_xy;
-      okay_homing_xy -= home_offset;
-    #else
-      constexpr xy_float_t okay_homing_xy = safe_homing_xy;
-    #endif
-
-    destination.set(okay_homing_xy, current_position.z);
+    destination.set(safe_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // Free the active extruder for movement
       TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
 

commit 179260878feb6fd575f8d341454e7c4a5add6c2e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 1 20:38:17 2023 -0500

    🎨 Misc. fixes and formatting

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6fb062c170..33a8ed76e6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -345,21 +345,23 @@ void GcodeSuite::G28() {
       #endif
       tool_change(0, true);
     #endif
 
     TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
     remember_feedrate_scaling_off();
 
     endstops.enable(true); // Enable endstops for next homing move
 
-    bool finalRaiseZ = false;
+    #if HAS_Z_AXIS
+      bool finalRaiseZ = false;
+    #endif
 
     #if ENABLED(DELTA)
 
       constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
       home_delta();
 
       TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
     #elif ENABLED(AXEL_TPARA)
@@ -615,24 +617,26 @@ void GcodeSuite::G28() {
         stepperW.rms_current(tmc_save_current_W);
       #endif
       #if SENSORLESS_STALLGUARD_DELAY
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
     #endif // HAS_HOMING_CURRENT
 
     // Move to a height where we can use the full xy-area
     TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
 
-    // Move to the configured Z only if Z was homed to MIN, because machines that
-    // home to MAX historically expect 'G28 Z' to be safe to use at the end of a
-    // print, and do_move_after_z_homing is not very nuanced.
-    if (finalRaiseZ) do_move_after_z_homing();
+    #if HAS_Z_AXIS
+      // Move to the configured Z only if Z was homed to MIN, because machines that
+      // home to MAX historically expect 'G28 Z' to be safe to use at the end of a
+      // print, and do_move_after_z_homing is not very nuanced.
+      if (finalRaiseZ) do_move_after_z_homing();
+    #endif
 
     TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
 
     // Restore the active tool after homing
     #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
       tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
     #endif
 
     restore_feedrate_and_scaling();
 

commit 441416728cd7f0e9b6ebf94f895d1d27fe59d25a
Author: Mark <niujl123@sina.com>
Date:   Sun Jun 18 17:18:08 2023 +0800

    🚸 Bed distance sensor improvements (#25847)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index cb4f80618d..6fb062c170 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -29,24 +29,20 @@
 #include "../../module/stepper.h" // for various
 
 #if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(BD_SENSOR)
-  #include "../../feature/bedlevel/bdl/bdl.h"
-#endif
-
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
@@ -222,22 +218,20 @@ void GcodeSuite::G28() {
   #if ENABLED(LASER_FEATURE)
     planner.laser_inline.status.isPowered = false;
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
-  TERN_(BD_SENSOR, bdl.config_state = 0);
-
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     const M_StateEnum old_grblstate = M_State_grbl;
     set_and_report_grblstate(M_HOMING);
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingStart());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 

commit 41a5fbb16ad985220f1cee1b823950c3bb771186
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:12:01 2023 -0500

    🎨 More lowercase
    
    Followup to #25939

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ab7b03961c..cb4f80618d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -229,21 +229,21 @@ void GcodeSuite::G28() {
     return;
   }
 
   TERN_(BD_SENSOR, bdl.config_state = 0);
 
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     const M_StateEnum old_grblstate = M_State_grbl;
     set_and_report_grblstate(M_HOMING);
   #endif
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingStart());
+  TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingStart());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #if NUM_AXES
 
     #if ENABLED(DUAL_X_CARRIAGE)
@@ -642,18 +642,18 @@ void GcodeSuite::G28() {
 
     restore_feedrate_and_scaling();
 
     if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
       SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #endif // NUM_AXES
 
   ui.refresh();
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
+  TERN_(HAS_DWIN_E3V2_BASIC, dwinHomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
 }

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ♻️ Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index fde640fe98..ab7b03961c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -267,21 +267,21 @@ void GcodeSuite::G28() {
     // Reset to the XY plane
     TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
     #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
     #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
       #define HAS_HOMING_CURRENT 1
     #endif
 
     #if HAS_HOMING_CURRENT
       auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-        DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
+        DEBUG_ECHOLN(s, F(" current: "), a, F(" -> "), b);
       };
       #if HAS_CURRENT_HOME(X)
         const int16_t tmc_save_current_X = stepperX.getMilliamps();
         stepperX.rms_current(X_CURRENT_HOME);
         if (DEBUGGING(LEVELING)) debug_current(F(STR_X), tmc_save_current_X, X_CURRENT_HOME);
       #endif
       #if HAS_CURRENT_HOME(X2)
         const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
         stepperX2.rms_current(X2_CURRENT_HOME);
         if (DEBUGGING(LEVELING)) debug_current(F(STR_X2), tmc_save_current_X2, X2_CURRENT_HOME);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    🧑‍💻 Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index be593d0d5b..fde640fe98 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -479,60 +479,60 @@ void GcodeSuite::G28() {
             idex_set_parked();
 
           #else
 
             homeaxis(X_AXIS);
 
           #endif
         }
       #endif // HAS_X_AXIS
 
-      #if BOTH(FOAMCUTTER_XYUV, HAS_I_AXIS)
+      #if ALL(FOAMCUTTER_XYUV, HAS_I_AXIS)
         // Home I (after X)
         if (doI) homeaxis(I_AXIS);
       #endif
 
       #if HAS_Y_AXIS
         // Home Y (after X)
         if (DISABLED(HOME_Y_BEFORE_X) && doY)
           homeaxis(Y_AXIS);
       #endif
 
-      #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
+      #if ALL(FOAMCUTTER_XYUV, HAS_J_AXIS)
         // Home J (after Y)
         if (doJ) homeaxis(J_AXIS);
       #endif
 
       TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
       #if ENABLED(FOAMCUTTER_XYUV)
 
         // Skip homing of unused Z axis for foamcutters
         if (doZ) set_axis_is_at_home(Z_AXIS);
 
       #elif HAS_Z_AXIS
 
         // Home Z last if homing towards the bed
         #if DISABLED(HOME_Z_FIRST)
           if (doZ) {
-            #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+            #if ANY(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
               stepper.set_all_z_lock(false);
               stepper.set_separate_multi_axis(false);
             #endif
 
             #if ENABLED(Z_SAFE_HOMING)
               if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
             #else
               homeaxis(Z_AXIS);
             #endif
 
-            #if EITHER(Z_HOME_TO_MIN, ALLOW_Z_AFTER_HOMING)
+            #if ANY(Z_HOME_TO_MIN, ALLOW_Z_AFTER_HOMING)
               finalRaiseZ = true;
             #endif
           }
         #endif
 
         SECONDARY_AXIS_CODE(
           if (doI) homeaxis(I_AXIS),
           if (doJ) homeaxis(J_AXIS),
           if (doK) homeaxis(K_AXIS),
           if (doU) homeaxis(U_AXIS),

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    🚸 Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4c654c3509..be593d0d5b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -199,455 +199,461 @@
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
-  TERN_(BD_SENSOR, bdl.config_state = 0);
-
-  /**
-   * Set the laser power to false to stop the planner from processing the current power setting.
-   */
-  #if ENABLED(LASER_FEATURE)
-    planner.laser_inline.status.isPowered = false;
-  #endif
-
-  #if ENABLED(DUAL_X_CARRIAGE)
-    bool IDEX_saved_duplication_state = extruder_duplication_enabled;
-    DualXMode IDEX_saved_mode = dual_x_carriage_mode;
-  #endif
-
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen_test('S')) {
       LOOP_NUM_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
+  /**
+   * Set the laser power to false to stop the planner from processing the current power setting.
+   */
+  #if ENABLED(LASER_FEATURE)
+    planner.laser_inline.status.isPowered = false;
+  #endif
+
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
+  TERN_(BD_SENSOR, bdl.config_state = 0);
+
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     const M_StateEnum old_grblstate = M_State_grbl;
     set_and_report_grblstate(M_HOMING);
   #endif
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingStart());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
-  SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
-
-  // Disable the leveling matrix before homing
-  #if CAN_SET_LEVELING_AFTER_G28
-    const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
-  #endif
-
-  // Cancel any prior G29 session
-  TERN_(PROBE_MANUALLY, g29_in_progress = false);
-
-  // Disable leveling before homing
-  TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
-
-  // Reset to the XY plane
-  TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
-
   // Count this command as movement / activity
   reset_stepper_timeout();
 
-  #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
-    #define HAS_HOMING_CURRENT 1
-  #endif
+  #if NUM_AXES
 
-  #if HAS_HOMING_CURRENT
-    auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-      DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
-    };
-    #if HAS_CURRENT_HOME(X)
-      const int16_t tmc_save_current_X = stepperX.getMilliamps();
-      stepperX.rms_current(X_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_X), tmc_save_current_X, X_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(X2)
-      const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
-      stepperX2.rms_current(X2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_X2), tmc_save_current_X2, X2_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(Y)
-      const int16_t tmc_save_current_Y = stepperY.getMilliamps();
-      stepperY.rms_current(Y_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_Y), tmc_save_current_Y, Y_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(Y2)
-      const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
-      stepperY2.rms_current(Y2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_Y2), tmc_save_current_Y2, Y2_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
-      const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
-      stepperZ.rms_current(Z_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_Z), tmc_save_current_Z, Z_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(I)
-      const int16_t tmc_save_current_I = stepperI.getMilliamps();
-      stepperI.rms_current(I_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(J)
-      const int16_t tmc_save_current_J = stepperJ.getMilliamps();
-      stepperJ.rms_current(J_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(K)
-      const int16_t tmc_save_current_K = stepperK.getMilliamps();
-      stepperK.rms_current(K_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(U)
-      const int16_t tmc_save_current_U = stepperU.getMilliamps();
-      stepperU.rms_current(U_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_U), tmc_save_current_U, U_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(V)
-      const int16_t tmc_save_current_V = stepperV.getMilliamps();
-      stepperV.rms_current(V_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
+    #if ENABLED(DUAL_X_CARRIAGE)
+      bool IDEX_saved_duplication_state = extruder_duplication_enabled;
+      DualXMode IDEX_saved_mode = dual_x_carriage_mode;
     #endif
-    #if HAS_CURRENT_HOME(W)
-      const int16_t tmc_save_current_W = stepperW.getMilliamps();
-      stepperW.rms_current(W_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
-    #endif
-    #if SENSORLESS_STALLGUARD_DELAY
-      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
-    #endif
-  #endif // HAS_HOMING_CURRENT
 
-  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-    motion_state_t saved_motion_state = begin_slow_homing();
-  #endif
+    SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
-  // Always home with tool 0 active
-  #if HAS_MULTI_HOTEND
-    #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
-      const uint8_t old_tool_index = active_extruder;
+    // Disable the leveling matrix before homing
+    #if CAN_SET_LEVELING_AFTER_G28
+      const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
     #endif
-    // PARKING_EXTRUDER homing requires different handling of movement / solenoid activation, depending on the side of homing
-    #if ENABLED(PARKING_EXTRUDER)
-      const bool pe_final_change_must_unpark = parking_extruder_unpark_after_homing(old_tool_index, X_HOME_DIR + 1 == old_tool_index * 2);
-    #endif
-    tool_change(0, true);
-  #endif
 
-  TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
+    // Cancel any prior G29 session
+    TERN_(PROBE_MANUALLY, g29_in_progress = false);
 
-  remember_feedrate_scaling_off();
+    // Disable leveling before homing
+    TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
-  endstops.enable(true); // Enable endstops for next homing move
+    // Reset to the XY plane
+    TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
-  bool finalRaiseZ = false;
+    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
+    #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
+      #define HAS_HOMING_CURRENT 1
+    #endif
+
+    #if HAS_HOMING_CURRENT
+      auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
+        DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
+      };
+      #if HAS_CURRENT_HOME(X)
+        const int16_t tmc_save_current_X = stepperX.getMilliamps();
+        stepperX.rms_current(X_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_X), tmc_save_current_X, X_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(X2)
+        const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
+        stepperX2.rms_current(X2_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_X2), tmc_save_current_X2, X2_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(Y)
+        const int16_t tmc_save_current_Y = stepperY.getMilliamps();
+        stepperY.rms_current(Y_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_Y), tmc_save_current_Y, Y_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(Y2)
+        const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
+        stepperY2.rms_current(Y2_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_Y2), tmc_save_current_Y2, Y2_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
+        const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
+        stepperZ.rms_current(Z_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_Z), tmc_save_current_Z, Z_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(I)
+        const int16_t tmc_save_current_I = stepperI.getMilliamps();
+        stepperI.rms_current(I_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(J)
+        const int16_t tmc_save_current_J = stepperJ.getMilliamps();
+        stepperJ.rms_current(J_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(K)
+        const int16_t tmc_save_current_K = stepperK.getMilliamps();
+        stepperK.rms_current(K_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(U)
+        const int16_t tmc_save_current_U = stepperU.getMilliamps();
+        stepperU.rms_current(U_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_U), tmc_save_current_U, U_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(V)
+        const int16_t tmc_save_current_V = stepperV.getMilliamps();
+        stepperV.rms_current(V_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
+      #endif
+      #if HAS_CURRENT_HOME(W)
+        const int16_t tmc_save_current_W = stepperW.getMilliamps();
+        stepperW.rms_current(W_CURRENT_HOME);
+        if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
+      #endif
+      #if SENSORLESS_STALLGUARD_DELAY
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
+    #endif // HAS_HOMING_CURRENT
 
-  #if ENABLED(DELTA)
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      motion_state_t saved_motion_state = begin_slow_homing();
+    #endif
 
-    constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
+    // Always home with tool 0 active
+    #if HAS_MULTI_HOTEND
+      #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+        const uint8_t old_tool_index = active_extruder;
+      #endif
+      // PARKING_EXTRUDER homing requires different handling of movement / solenoid activation, depending on the side of homing
+      #if ENABLED(PARKING_EXTRUDER)
+        const bool pe_final_change_must_unpark = parking_extruder_unpark_after_homing(old_tool_index, X_HOME_DIR + 1 == old_tool_index * 2);
+      #endif
+      tool_change(0, true);
+    #endif
 
-    home_delta();
+    TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
-    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
+    remember_feedrate_scaling_off();
 
-  #elif ENABLED(AXEL_TPARA)
+    endstops.enable(true); // Enable endstops for next homing move
 
-    constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
+    bool finalRaiseZ = false;
 
-    home_TPARA();
+    #if ENABLED(DELTA)
 
-  #else
+      constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
-    #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
+      home_delta();
 
-    const bool homeZ = TERN0(HAS_Z_AXIS, parser.seen_test('Z')),
-               NUM_AXIS_LIST(              // Other axes should be homed before Z safe-homing
-                 needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
-                 needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K),
-                 needU = _UNSAFE(U), needV = _UNSAFE(V), needW = _UNSAFE(W)
-               ),
-               NUM_AXIS_LIST(              // Home each axis if needed or flagged
-                 homeX = needX || parser.seen_test('X'),
-                 homeY = needY || parser.seen_test('Y'),
-                 homeZZ = homeZ,
-                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME),
-                 homeK = needK || parser.seen_test(AXIS6_NAME), homeU = needU || parser.seen_test(AXIS7_NAME),
-                 homeV = needV || parser.seen_test(AXIS8_NAME), homeW = needW || parser.seen_test(AXIS9_NAME)
-               ),
-               home_all = NUM_AXIS_GANG(   // Home-all if all or none are flagged
-                    homeX == homeX, && homeY == homeX, && homeZ == homeX,
-                 && homeI == homeX, && homeJ == homeX, && homeK == homeX,
-                 && homeU == homeX, && homeV == homeX, && homeW == homeX
-               ),
-               NUM_AXIS_LIST(
-                 doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
-                 doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
-                 doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW
-               );
+      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
-    #if !HAS_Y_AXIS
-      constexpr bool doY = false;
-    #endif
+    #elif ENABLED(AXEL_TPARA)
+
+      constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
+
+      home_TPARA();
+
+    #else // !DELTA && !AXEL_TPARA
+
+      #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
+
+      const bool homeZ = TERN0(HAS_Z_AXIS, parser.seen_test('Z')),
+                 NUM_AXIS_LIST_(             // Other axes should be homed before Z safe-homing
+                   needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
+                   needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K),
+                   needU = _UNSAFE(U), needV = _UNSAFE(V), needW = _UNSAFE(W)
+                 )
+                 NUM_AXIS_LIST_(             // Home each axis if needed or flagged
+                   homeX = needX || parser.seen_test('X'),
+                   homeY = needY || parser.seen_test('Y'),
+                   homeZZ = homeZ,
+                   homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME),
+                   homeK = needK || parser.seen_test(AXIS6_NAME), homeU = needU || parser.seen_test(AXIS7_NAME),
+                   homeV = needV || parser.seen_test(AXIS8_NAME), homeW = needW || parser.seen_test(AXIS9_NAME)
+                 )
+                 home_all = NUM_AXIS_GANG_(  // Home-all if all or none are flagged
+                      homeX == homeX, && homeY == homeX, && homeZ == homeX,
+                   && homeI == homeX, && homeJ == homeX, && homeK == homeX,
+                   && homeU == homeX, && homeV == homeX, && homeW == homeX
+                 )
+                 NUM_AXIS_LIST(
+                   doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
+                   doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
+                   doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW
+                 );
+
+      #if !HAS_Y_AXIS
+        constexpr bool doY = false;
+      #endif
 
-    #if HAS_Z_AXIS
+      #if HAS_Z_AXIS
 
-      UNUSED(needZ); UNUSED(homeZZ);
+        UNUSED(needZ); UNUSED(homeZZ);
 
-      // Z may home first, e.g., when homing away from the bed.
-      // This is also permitted when homing with a Z endstop.
-      if (TERN0(HOME_Z_FIRST, doZ)) homeaxis(Z_AXIS);
+        // Z may home first, e.g., when homing away from the bed.
+        // This is also permitted when homing with a Z endstop.
+        if (TERN0(HOME_Z_FIRST, doZ)) homeaxis(Z_AXIS);
 
-      // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
-      // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
-      const bool seenR = parser.seenval('R');
+        // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
+        // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
+        const bool seenR = parser.seenval('R');
 
-      // Use raise given by 'R' or Z_CLEARANCE_FOR_HOMING (above the probe trigger point)
-      float z_homing_height = seenR ? parser.value_linear_units() : Z_CLEARANCE_FOR_HOMING;
+        // Use raise given by 'R' or Z_CLEARANCE_FOR_HOMING (above the probe trigger point)
+        float z_homing_height = seenR ? parser.value_linear_units() : Z_CLEARANCE_FOR_HOMING;
 
-      // Check for any lateral motion that might require clearance
-      const bool may_skate = seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
+        // Check for any lateral motion that might require clearance
+        const bool may_skate = seenR NUM_AXIS_GANG(|| doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
 
-      if (seenR && z_homing_height == 0) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("R0 = No Z raise");
-      }
-      else {
-        bool with_probe = ENABLED(HOMING_Z_WITH_PROBE);
-        // Raise above the current Z (which should be synced in the planner)
-        // The "height" for Z is a coordinate. But if Z is not trusted/homed make it relative.
-        if (seenR || !TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(Z_AXIS)) {
-          z_homing_height += current_position.z;
-          with_probe = false;
+        if (seenR && z_homing_height == 0) {
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("R0 = No Z raise");
         }
-
-        if (may_skate) {
-          // Apply Z clearance before doing any lateral motion
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z before homing:");
-          do_z_clearance(z_homing_height, with_probe);
+        else {
+          bool with_probe = ENABLED(HOMING_Z_WITH_PROBE);
+          // Raise above the current Z (which should be synced in the planner)
+          // The "height" for Z is a coordinate. But if Z is not trusted/homed make it relative.
+          if (seenR || !TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(Z_AXIS)) {
+            z_homing_height += current_position.z;
+            with_probe = false;
+          }
+
+          if (may_skate) {
+            // Apply Z clearance before doing any lateral motion
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z before homing:");
+            do_z_clearance(z_homing_height, with_probe);
+          }
         }
-      }
 
-      // Init BLTouch ahead of any lateral motion, even if not homing with the probe
-      TERN_(BLTOUCH, if (may_skate) bltouch.init());
+        // Init BLTouch ahead of any lateral motion, even if not homing with the probe
+        TERN_(BLTOUCH, if (may_skate) bltouch.init());
 
-    #endif // HAS_Z_AXIS
+      #endif // HAS_Z_AXIS
 
-    // Diagonal move first if both are homing
-    TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
+      // Diagonal move first if both are homing
+      TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
-    #if HAS_Y_AXIS
-      // Home Y (before X)
-      if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
-        homeaxis(Y_AXIS);
-    #endif
+      #if HAS_Y_AXIS
+        // Home Y (before X)
+        if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
+          homeaxis(Y_AXIS);
+      #endif
 
-    // Home X
-    if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
+      // Home X
+      #if HAS_X_AXIS
+        if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
-      #if ENABLED(DUAL_X_CARRIAGE)
+          #if ENABLED(DUAL_X_CARRIAGE)
 
-        // Always home the 2nd (right) extruder first
-        active_extruder = 1;
-        homeaxis(X_AXIS);
+            // Always home the 2nd (right) extruder first
+            active_extruder = 1;
+            homeaxis(X_AXIS);
 
-        // Remember this extruder's position for later tool change
-        inactive_extruder_x = current_position.x;
+            // Remember this extruder's position for later tool change
+            inactive_extruder_x = current_position.x;
 
-        // Home the 1st (left) extruder
-        active_extruder = 0;
-        homeaxis(X_AXIS);
+            // Home the 1st (left) extruder
+            active_extruder = 0;
+            homeaxis(X_AXIS);
 
-        // Consider the active extruder to be in its "parked" position
-        idex_set_parked();
+            // Consider the active extruder to be in its "parked" position
+            idex_set_parked();
 
-      #else
+          #else
 
-        homeaxis(X_AXIS);
+            homeaxis(X_AXIS);
+
+          #endif
+        }
+      #endif // HAS_X_AXIS
 
+      #if BOTH(FOAMCUTTER_XYUV, HAS_I_AXIS)
+        // Home I (after X)
+        if (doI) homeaxis(I_AXIS);
       #endif
-    }
 
-    #if BOTH(FOAMCUTTER_XYUV, HAS_I_AXIS)
-      // Home I (after X)
-      if (doI) homeaxis(I_AXIS);
-    #endif
+      #if HAS_Y_AXIS
+        // Home Y (after X)
+        if (DISABLED(HOME_Y_BEFORE_X) && doY)
+          homeaxis(Y_AXIS);
+      #endif
 
-    #if HAS_Y_AXIS
-      // Home Y (after X)
-      if (DISABLED(HOME_Y_BEFORE_X) && doY)
-        homeaxis(Y_AXIS);
-    #endif
+      #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
+        // Home J (after Y)
+        if (doJ) homeaxis(J_AXIS);
+      #endif
 
-    #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
-      // Home J (after Y)
-      if (doJ) homeaxis(J_AXIS);
-    #endif
+      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
-    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
+      #if ENABLED(FOAMCUTTER_XYUV)
 
-    #if ENABLED(FOAMCUTTER_XYUV)
+        // Skip homing of unused Z axis for foamcutters
+        if (doZ) set_axis_is_at_home(Z_AXIS);
 
-      // Skip homing of unused Z axis for foamcutters
-      if (doZ) set_axis_is_at_home(Z_AXIS);
+      #elif HAS_Z_AXIS
 
-    #elif HAS_Z_AXIS
+        // Home Z last if homing towards the bed
+        #if DISABLED(HOME_Z_FIRST)
+          if (doZ) {
+            #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+              stepper.set_all_z_lock(false);
+              stepper.set_separate_multi_axis(false);
+            #endif
 
-      // Home Z last if homing towards the bed
-      #if DISABLED(HOME_Z_FIRST)
-        if (doZ) {
-          #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
-            stepper.set_all_z_lock(false);
-            stepper.set_separate_multi_axis(false);
-          #endif
+            #if ENABLED(Z_SAFE_HOMING)
+              if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
+            #else
+              homeaxis(Z_AXIS);
+            #endif
 
-          #if ENABLED(Z_SAFE_HOMING)
-            if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
-          #else
-            homeaxis(Z_AXIS);
-          #endif
+            #if EITHER(Z_HOME_TO_MIN, ALLOW_Z_AFTER_HOMING)
+              finalRaiseZ = true;
+            #endif
+          }
+        #endif
 
-          #if EITHER(Z_HOME_TO_MIN, ALLOW_Z_AFTER_HOMING)
-            finalRaiseZ = true;
-          #endif
-        }
-      #endif
+        SECONDARY_AXIS_CODE(
+          if (doI) homeaxis(I_AXIS),
+          if (doJ) homeaxis(J_AXIS),
+          if (doK) homeaxis(K_AXIS),
+          if (doU) homeaxis(U_AXIS),
+          if (doV) homeaxis(V_AXIS),
+          if (doW) homeaxis(W_AXIS)
+        );
 
-      SECONDARY_AXIS_CODE(
-        if (doI) homeaxis(I_AXIS),
-        if (doJ) homeaxis(J_AXIS),
-        if (doK) homeaxis(K_AXIS),
-        if (doU) homeaxis(U_AXIS),
-        if (doV) homeaxis(V_AXIS),
-        if (doW) homeaxis(W_AXIS)
-      );
+      #endif // HAS_Z_AXIS
 
-    #endif // HAS_Z_AXIS
+      sync_plan_position();
 
-    sync_plan_position();
+    #endif
 
-  #endif
+    /**
+     * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
+     * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
+     * then print a standard GCode file that contains a single print that does a G28 and has no other
+     * IDEX specific commands in it.
+     */
+    #if ENABLED(DUAL_X_CARRIAGE)
 
-  /**
-   * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
-   * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
-   * then print a standard GCode file that contains a single print that does a G28 and has no other
-   * IDEX specific commands in it.
-   */
-  #if ENABLED(DUAL_X_CARRIAGE)
+      if (idex_is_duplicating()) {
 
-    if (idex_is_duplicating()) {
+        TERN_(IMPROVE_HOMING_RELIABILITY, saved_motion_state = begin_slow_homing());
 
-      TERN_(IMPROVE_HOMING_RELIABILITY, saved_motion_state = begin_slow_homing());
+        // Always home the 2nd (right) extruder first
+        active_extruder = 1;
+        homeaxis(X_AXIS);
 
-      // Always home the 2nd (right) extruder first
-      active_extruder = 1;
-      homeaxis(X_AXIS);
+        // Remember this extruder's position for later tool change
+        inactive_extruder_x = current_position.x;
 
-      // Remember this extruder's position for later tool change
-      inactive_extruder_x = current_position.x;
+        // Home the 1st (left) extruder
+        active_extruder = 0;
+        homeaxis(X_AXIS);
 
-      // Home the 1st (left) extruder
-      active_extruder = 0;
-      homeaxis(X_AXIS);
+        // Consider the active extruder to be parked
+        idex_set_parked();
 
-      // Consider the active extruder to be parked
-      idex_set_parked();
+        dual_x_carriage_mode = IDEX_saved_mode;
+        set_duplication_enabled(IDEX_saved_duplication_state);
 
-      dual_x_carriage_mode = IDEX_saved_mode;
-      set_duplication_enabled(IDEX_saved_duplication_state);
+        TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
+      }
 
-      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
-    }
+    #endif // DUAL_X_CARRIAGE
 
-  #endif // DUAL_X_CARRIAGE
+    endstops.not_homing();
 
-  endstops.not_homing();
+    // Clear endstop state for polled stallGuard endstops
+    TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
-  // Clear endstop state for polled stallGuard endstops
-  TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
+    #if HAS_HOMING_CURRENT
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
+      #if HAS_CURRENT_HOME(X)
+        stepperX.rms_current(tmc_save_current_X);
+      #endif
+      #if HAS_CURRENT_HOME(X2)
+        stepperX2.rms_current(tmc_save_current_X2);
+      #endif
+      #if HAS_CURRENT_HOME(Y)
+        stepperY.rms_current(tmc_save_current_Y);
+      #endif
+      #if HAS_CURRENT_HOME(Y2)
+        stepperY2.rms_current(tmc_save_current_Y2);
+      #endif
+      #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
+        stepperZ.rms_current(tmc_save_current_Z);
+      #endif
+      #if HAS_CURRENT_HOME(I)
+        stepperI.rms_current(tmc_save_current_I);
+      #endif
+      #if HAS_CURRENT_HOME(J)
+        stepperJ.rms_current(tmc_save_current_J);
+      #endif
+      #if HAS_CURRENT_HOME(K)
+        stepperK.rms_current(tmc_save_current_K);
+      #endif
+      #if HAS_CURRENT_HOME(U)
+        stepperU.rms_current(tmc_save_current_U);
+      #endif
+      #if HAS_CURRENT_HOME(V)
+        stepperV.rms_current(tmc_save_current_V);
+      #endif
+      #if HAS_CURRENT_HOME(W)
+        stepperW.rms_current(tmc_save_current_W);
+      #endif
+      #if SENSORLESS_STALLGUARD_DELAY
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
+    #endif // HAS_HOMING_CURRENT
 
-  #if HAS_HOMING_CURRENT
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
-    #if HAS_CURRENT_HOME(X)
-      stepperX.rms_current(tmc_save_current_X);
-    #endif
-    #if HAS_CURRENT_HOME(X2)
-      stepperX2.rms_current(tmc_save_current_X2);
-    #endif
-    #if HAS_CURRENT_HOME(Y)
-      stepperY.rms_current(tmc_save_current_Y);
-    #endif
-    #if HAS_CURRENT_HOME(Y2)
-      stepperY2.rms_current(tmc_save_current_Y2);
-    #endif
-    #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
-      stepperZ.rms_current(tmc_save_current_Z);
-    #endif
-    #if HAS_CURRENT_HOME(I)
-      stepperI.rms_current(tmc_save_current_I);
-    #endif
-    #if HAS_CURRENT_HOME(J)
-      stepperJ.rms_current(tmc_save_current_J);
-    #endif
-    #if HAS_CURRENT_HOME(K)
-      stepperK.rms_current(tmc_save_current_K);
-    #endif
-    #if HAS_CURRENT_HOME(U)
-      stepperU.rms_current(tmc_save_current_U);
-    #endif
-    #if HAS_CURRENT_HOME(V)
-      stepperV.rms_current(tmc_save_current_V);
-    #endif
-    #if HAS_CURRENT_HOME(W)
-      stepperW.rms_current(tmc_save_current_W);
-    #endif
-    #if SENSORLESS_STALLGUARD_DELAY
-      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
-    #endif
-  #endif // HAS_HOMING_CURRENT
+    // Move to a height where we can use the full xy-area
+    TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
 
-  // Move to a height where we can use the full xy-area
-  TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
+    // Move to the configured Z only if Z was homed to MIN, because machines that
+    // home to MAX historically expect 'G28 Z' to be safe to use at the end of a
+    // print, and do_move_after_z_homing is not very nuanced.
+    if (finalRaiseZ) do_move_after_z_homing();
 
-  // Move to the configured Z only if Z was homed to MIN, because machines that
-  // home to MAX historically expect 'G28 Z' to be safe to use at the end of a
-  // print, and do_move_after_z_homing is not very nuanced.
-  if (finalRaiseZ) do_move_after_z_homing();
+    TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
 
-  TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
+    // Restore the active tool after homing
+    #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
+      tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
+    #endif
 
-  // Restore the active tool after homing
-  #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
-  #endif
+    restore_feedrate_and_scaling();
 
-  restore_feedrate_and_scaling();
+    if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
+      SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
+
+  #endif // NUM_AXES
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
-  if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
-    SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
-
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
 }

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    🧑‍💻 Endstops preliminary work (#25780)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ed2cda2932..4c654c3509 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -325,21 +325,21 @@ void GcodeSuite::G28() {
       if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(W)
       const int16_t tmc_save_current_W = stepperW.getMilliamps();
       stepperW.rms_current(W_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
     #endif
     #if SENSORLESS_STALLGUARD_DELAY
       safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
     #endif
-  #endif
+  #endif // HAS_HOMING_CURRENT
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    🐛 Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 782761ee14..ed2cda2932 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -349,20 +349,22 @@ void GcodeSuite::G28() {
     #endif
     tool_change(0, true);
   #endif
 
   TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
+  bool finalRaiseZ = false;
+
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
   #elif ENABLED(AXEL_TPARA)
 
@@ -400,22 +402,23 @@ void GcodeSuite::G28() {
                );
 
     #if !HAS_Y_AXIS
       constexpr bool doY = false;
     #endif
 
     #if HAS_Z_AXIS
 
       UNUSED(needZ); UNUSED(homeZZ);
 
-      // Z may home first, e.g., when homing away from the bed
-      TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
+      // Z may home first, e.g., when homing away from the bed.
+      // This is also permitted when homing with a Z endstop.
+      if (TERN0(HOME_Z_FIRST, doZ)) homeaxis(Z_AXIS);
 
       // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
       // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
       const bool seenR = parser.seenval('R');
 
       // Use raise given by 'R' or Z_CLEARANCE_FOR_HOMING (above the probe trigger point)
       float z_homing_height = seenR ? parser.value_linear_units() : Z_CLEARANCE_FOR_HOMING;
 
       // Check for any lateral motion that might require clearance
       const bool may_skate = seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
@@ -510,21 +513,24 @@ void GcodeSuite::G28() {
           #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
             stepper.set_all_z_lock(false);
             stepper.set_separate_multi_axis(false);
           #endif
 
           #if ENABLED(Z_SAFE_HOMING)
             if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
           #else
             homeaxis(Z_AXIS);
           #endif
-          do_move_after_z_homing();
+
+          #if EITHER(Z_HOME_TO_MIN, ALLOW_Z_AFTER_HOMING)
+            finalRaiseZ = true;
+          #endif
         }
       #endif
 
       SECONDARY_AXIS_CODE(
         if (doI) homeaxis(I_AXIS),
         if (doJ) homeaxis(J_AXIS),
         if (doK) homeaxis(K_AXIS),
         if (doU) homeaxis(U_AXIS),
         if (doV) homeaxis(V_AXIS),
         if (doW) homeaxis(W_AXIS)
@@ -568,32 +574,20 @@ void GcodeSuite::G28() {
       TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
-  // Move to a height where we can use the full xy-area
-  TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
-
-  TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
-
-  restore_feedrate_and_scaling();
-
-  // Restore the active tool after homing
-  #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
-  #endif
-
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
       stepperX.rms_current(tmc_save_current_X);
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
@@ -620,20 +614,37 @@ void GcodeSuite::G28() {
       stepperV.rms_current(tmc_save_current_V);
     #endif
     #if HAS_CURRENT_HOME(W)
       stepperW.rms_current(tmc_save_current_W);
     #endif
     #if SENSORLESS_STALLGUARD_DELAY
       safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
     #endif
   #endif // HAS_HOMING_CURRENT
 
+  // Move to a height where we can use the full xy-area
+  TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
+
+  // Move to the configured Z only if Z was homed to MIN, because machines that
+  // home to MAX historically expect 'G28 Z' to be safe to use at the end of a
+  // print, and do_move_after_z_homing is not very nuanced.
+  if (finalRaiseZ) do_move_after_z_homing();
+
+  TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
+
+  // Restore the active tool after homing
+  #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
+    tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
+  #endif
+
+  restore_feedrate_and_scaling();
+
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 

commit 0c2ed8688dd387b56b318f6207ee1cc70811b5a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 21:00:12 2023 -0500

    🩹 Z clearance followup

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 89e0c8d8d4..782761ee14 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -627,16 +627,16 @@ void GcodeSuite::G28() {
     #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
-  if (BOTH(NANODLP_Z_SYNC, NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ))
+  if (ENABLED(NANODLP_Z_SYNC) && (ENABLED(NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
 }

commit c8c5ab22ce242b93632a7e2b9f855bbaf38b557f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 19:29:53 2023 -0500

    🧑‍💻 Gather Z clearances (#25701)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b5e7a13295..89e0c8d8d4 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -392,63 +392,64 @@ void GcodeSuite::G28() {
                     homeX == homeX, && homeY == homeX, && homeZ == homeX,
                  && homeI == homeX, && homeJ == homeX, && homeK == homeX,
                  && homeU == homeX, && homeV == homeX, && homeW == homeX
                ),
                NUM_AXIS_LIST(
                  doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
                  doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
                  doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW
                );
 
+    #if !HAS_Y_AXIS
+      constexpr bool doY = false;
+    #endif
+
     #if HAS_Z_AXIS
+
       UNUSED(needZ); UNUSED(homeZZ);
-    #else
-      constexpr bool doZ = false;
-      #if !HAS_Y_AXIS
-        constexpr bool doY = false;
-      #endif
-    #endif
 
-    // Z may home first, e.g., when homing away from the bed
-    TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
+      // Z may home first, e.g., when homing away from the bed
+      TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
-    // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
-    // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
-    const bool seenR = parser.seenval('R');
+      // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
+      // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
+      const bool seenR = parser.seenval('R');
 
-    // Use raise given by 'R' or Z_HOMING_HEIGHT (above the probe trigger point)
-    float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
+      // Use raise given by 'R' or Z_CLEARANCE_FOR_HOMING (above the probe trigger point)
+      float z_homing_height = seenR ? parser.value_linear_units() : Z_CLEARANCE_FOR_HOMING;
 
-    // Check for any lateral motion that might require clearance
-    const bool may_skate = seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
+      // Check for any lateral motion that might require clearance
+      const bool may_skate = seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
 
-    if (seenR && z_homing_height == 0) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("R0 = No Z raise");
-    }
-    else {
-      bool with_probe = ENABLED(HOMING_Z_WITH_PROBE);
-      // Raise above the current Z (which should be synced in the planner)
-      // The "height" for Z is a coordinate. But if Z is not trusted/homed make it relative.
-      if (seenR || !TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(Z_AXIS)) {
-        z_homing_height += current_position.z;
-        with_probe = false;
+      if (seenR && z_homing_height == 0) {
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("R0 = No Z raise");
       }
+      else {
+        bool with_probe = ENABLED(HOMING_Z_WITH_PROBE);
+        // Raise above the current Z (which should be synced in the planner)
+        // The "height" for Z is a coordinate. But if Z is not trusted/homed make it relative.
+        if (seenR || !TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(Z_AXIS)) {
+          z_homing_height += current_position.z;
+          with_probe = false;
+        }
 
-      if (may_skate) {
-        // Apply Z clearance before doing any lateral motion
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z before homing:");
-        do_z_clearance(z_homing_height, with_probe);
+        if (may_skate) {
+          // Apply Z clearance before doing any lateral motion
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z before homing:");
+          do_z_clearance(z_homing_height, with_probe);
+        }
       }
-    }
 
-    // Init BLTouch ahead of any lateral motion, even if not homing with the probe
-    TERN_(BLTOUCH, if (may_skate) bltouch.init());
+      // Init BLTouch ahead of any lateral motion, even if not homing with the probe
+      TERN_(BLTOUCH, if (may_skate) bltouch.init());
+
+    #endif // HAS_Z_AXIS
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     #if HAS_Y_AXIS
       // Home Y (before X)
       if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
         homeaxis(Y_AXIS);
     #endif
 
@@ -490,49 +491,53 @@ void GcodeSuite::G28() {
     #endif
 
     #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
       // Home J (after Y)
       if (doJ) homeaxis(J_AXIS);
     #endif
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
     #if ENABLED(FOAMCUTTER_XYUV)
-      // skip homing of unused Z axis for foamcutters
+
+      // Skip homing of unused Z axis for foamcutters
       if (doZ) set_axis_is_at_home(Z_AXIS);
-    #else
+
+    #elif HAS_Z_AXIS
+
       // Home Z last if homing towards the bed
-      #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
+      #if DISABLED(HOME_Z_FIRST)
         if (doZ) {
           #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
             stepper.set_all_z_lock(false);
             stepper.set_separate_multi_axis(false);
           #endif
 
           #if ENABLED(Z_SAFE_HOMING)
             if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
           #else
             homeaxis(Z_AXIS);
           #endif
-          probe.move_z_after_homing();
+          do_move_after_z_homing();
         }
       #endif
 
       SECONDARY_AXIS_CODE(
         if (doI) homeaxis(I_AXIS),
         if (doJ) homeaxis(J_AXIS),
         if (doK) homeaxis(K_AXIS),
         if (doU) homeaxis(U_AXIS),
         if (doV) homeaxis(V_AXIS),
         if (doW) homeaxis(W_AXIS)
       );
-    #endif
+
+    #endif // HAS_Z_AXIS
 
     sync_plan_position();
 
   #endif
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
@@ -622,16 +627,16 @@ void GcodeSuite::G28() {
     #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
-  if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
+  if (BOTH(NANODLP_Z_SYNC, NANODLP_ALL_AXIS) || TERN0(HAS_Z_AXIS, doZ))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
 }

commit 8c0ae93d2af2b55197de856529384e8a79967f92
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:18 2023 -0500

    🧑‍💻 Clarify G28 R / R0

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e279b90e33..b5e7a13295 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -401,31 +401,54 @@ void GcodeSuite::G28() {
 
     #if HAS_Z_AXIS
       UNUSED(needZ); UNUSED(homeZZ);
     #else
       constexpr bool doZ = false;
       #if !HAS_Y_AXIS
         constexpr bool doY = false;
       #endif
     #endif
 
+    // Z may home first, e.g., when homing away from the bed
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
+    // 'R' to specify a specific raise. 'R0' indicates no raise, e.g., for recovery.resume
+    // When 'R0' is used, there should already be adequate clearance, e.g., from homing Z to max.
     const bool seenR = parser.seenval('R');
-    const float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW))) {
-      // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z (before homing) by ", z_homing_height);
-      do_z_clearance(z_homing_height);
-      TERN_(BLTOUCH, bltouch.init());
+    // Use raise given by 'R' or Z_HOMING_HEIGHT (above the probe trigger point)
+    float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
+
+    // Check for any lateral motion that might require clearance
+    const bool may_skate = seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW);
+
+    if (seenR && z_homing_height == 0) {
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("R0 = No Z raise");
     }
+    else {
+      bool with_probe = ENABLED(HOMING_Z_WITH_PROBE);
+      // Raise above the current Z (which should be synced in the planner)
+      // The "height" for Z is a coordinate. But if Z is not trusted/homed make it relative.
+      if (seenR || !TERN(HOME_AFTER_DEACTIVATE, axis_is_trusted, axis_was_homed)(Z_AXIS)) {
+        z_homing_height += current_position.z;
+        with_probe = false;
+      }
+
+      if (may_skate) {
+        // Apply Z clearance before doing any lateral motion
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z before homing:");
+        do_z_clearance(z_homing_height, with_probe);
+      }
+    }
+
+    // Init BLTouch ahead of any lateral motion, even if not homing with the probe
+    TERN_(BLTOUCH, if (may_skate) bltouch.init());
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     #if HAS_Y_AXIS
       // Home Y (before X)
       if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
         homeaxis(Y_AXIS);
     #endif
 

commit 904ddf8551149e7de1af25456fc41d069f2f2ac4
Author: Evgeniy Zhabotinskiy <evg-zhabotinsky@users.noreply.github.com>
Date:   Fri Mar 10 03:56:19 2023 +0300

    ✨ Z_SAFE_HOMING_POINT_ABSOLUTE (#23069)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6f0f27cb9d..e279b90e33 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -117,21 +117,21 @@
     // Disallow Z homing if X or Y homing is needed
     if (homing_needed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     constexpr xy_float_t safe_homing_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
-    #if HAS_HOME_OFFSET
+    #if HAS_HOME_OFFSET && DISABLED(Z_SAFE_HOMING_POINT_ABSOLUTE)
       xy_float_t okay_homing_xy = safe_homing_xy;
       okay_homing_xy -= home_offset;
     #else
       constexpr xy_float_t okay_homing_xy = safe_homing_xy;
     #endif
 
     destination.set(okay_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 

commit f9f6662a8c4692cc67006fb302068c96a0e86ac1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 23 21:08:31 2023 -0600

    ♻️ Stepper options refactor (#25422)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 0b6548a3e3..6f0f27cb9d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -79,21 +79,21 @@
 
     // Use a higher diagonal feedrate so axes move at homing speed
     const float minfr = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)),
                 fr_mm_s = HYPOT(minfr, minfr);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
         NUM_AXIS_LIST(
           TERN0(X_SENSORLESS, tmc_enable_stallguard(stepperX)),
           TERN0(Y_SENSORLESS, tmc_enable_stallguard(stepperY)),
-          false, false, false, false
+          false, false, false, false, false, false, false
         )
         , TERN0(X2_SENSORLESS, tmc_enable_stallguard(stepperX2))
         , TERN0(Y2_SENSORLESS, tmc_enable_stallguard(stepperY2))
       };
     #endif
 
     do_blocking_move_to_xy(1.5 * max_length(X_AXIS) * x_axis_home_dir, 1.5 * max_length(Y_AXIS) * Y_HOME_DIR, fr_mm_s);
 
     endstops.validate_homing_move();
 

commit 087e19a0ed4b769224d42cca83c8caccefce63c9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 30 22:11:50 2023 -0600

    🔧 Fix build with no Y axis (#25311)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a6dff2d75a..0b6548a3e3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -396,40 +396,45 @@ void GcodeSuite::G28() {
                NUM_AXIS_LIST(
                  doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
                  doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
                  doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW
                );
 
     #if HAS_Z_AXIS
       UNUSED(needZ); UNUSED(homeZZ);
     #else
       constexpr bool doZ = false;
+      #if !HAS_Y_AXIS
+        constexpr bool doY = false;
+      #endif
     #endif
 
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
     const bool seenR = parser.seenval('R');
     const float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
     if (z_homing_height && (seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
-    // Home Y (before X)
-    if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
-      homeaxis(Y_AXIS);
+    #if HAS_Y_AXIS
+      // Home Y (before X)
+      if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
+        homeaxis(Y_AXIS);
+    #endif
 
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 
@@ -448,23 +453,25 @@ void GcodeSuite::G28() {
         homeaxis(X_AXIS);
 
       #endif
     }
 
     #if BOTH(FOAMCUTTER_XYUV, HAS_I_AXIS)
       // Home I (after X)
       if (doI) homeaxis(I_AXIS);
     #endif
 
-    // Home Y (after X)
-    if (DISABLED(HOME_Y_BEFORE_X) && doY)
-      homeaxis(Y_AXIS);
+    #if HAS_Y_AXIS
+      // Home Y (after X)
+      if (DISABLED(HOME_Y_BEFORE_X) && doY)
+        homeaxis(Y_AXIS);
+    #endif
 
     #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
       // Home J (after Y)
       if (doJ) homeaxis(J_AXIS);
     #endif
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
     #if ENABLED(FOAMCUTTER_XYUV)
       // skip homing of unused Z axis for foamcutters

commit 83320f1052dd09bff7aae789372e7bffccbced97
Author: Mark <niujl123@sina.com>
Date:   Sat Aug 6 14:14:58 2022 +0800

    ✨ Bed Distance Sensor (#24554)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e22e3cb5f8..a6dff2d75a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -29,20 +29,24 @@
 #include "../../module/stepper.h" // for various
 
 #if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(BD_SENSOR)
+  #include "../../feature/bedlevel/bdl/bdl.h"
+#endif
+
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
@@ -195,21 +199,23 @@
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
-  /*
+  TERN_(BD_SENSOR, bdl.config_state = 0);
+
+  /**
    * Set the laser power to false to stop the planner from processing the current power setting.
    */
   #if ENABLED(LASER_FEATURE)
     planner.laser_inline.status.isPowered = false;
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    🧑‍💻  Update planner/stepper includes

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e312bf07b5..e22e3cb5f8 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -17,22 +17,23 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #include "../gcode.h"
 
-#include "../../module/stepper.h"
 #include "../../module/endstops.h"
+#include "../../module/planner.h"
+#include "../../module/stepper.h" // for various
 
 #if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)

commit 3f4e4a4d891e3c4b73ab80aedec46e69c1b59f0d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jul 13 22:16:22 2022 -0500

    🔥 Drop STM L64** drivers, STEVAL_3DP001V1 (#24427)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 384fc7210c..e312bf07b5 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -48,24 +48,20 @@
 #include "../../lcd/marlinui.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../lcd/e3v2/proui/dwin.h"
 #endif
 
-#if HAS_L64XX                         // set L6470 absolute position registers to counts
-  #include "../../libs/L64XX/L64XX_Marlin.h"
-#endif
-
 #if ENABLED(LASER_FEATURE)
   #include "../../feature/spindle_laser.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
@@ -594,27 +590,11 @@ void GcodeSuite::G28() {
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
-  #if HAS_L64XX
-    // Set L6470 absolute position registers to counts
-    // constexpr *might* move this to PROGMEM.
-    // If not, this will need a PROGMEM directive and an accessor.
-    #define _EN_ITEM(N) , E_AXIS
-    static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
-      NUM_AXIS_LIST(X_AXIS, Y_AXIS, Z_AXIS, I_AXIS, J_AXIS, K_AXIS, U_AXIS, V_AXIS, W_AXIS),
-      X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS, Z_AXIS
-      REPEAT(E_STEPPERS, _EN_ITEM)
-    };
-    #undef _EN_ITEM
-    for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
-      const uint8_t cv = L64XX::chain[j];
-      L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L64XX_axis_xref[cv]));
-    }
-  #endif
 }

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ⚡️ Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 01c2b13dda..384fc7210c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -52,21 +52,21 @@
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
-#if ENABLED(LASER_MOVE_G28_OFF)
+#if ENABLED(LASER_FEATURE)
   #include "../../feature/spindle_laser.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
@@ -198,21 +198,26 @@
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
-  TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
+  /*
+   * Set the laser power to false to stop the planner from processing the current power setting.
+   */
+  #if ENABLED(LASER_FEATURE)
+    planner.laser_inline.status.isPowered = false;
+  #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen_test('S')) {
       LOOP_NUM_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();

commit 93ffd57383723c48a092e97364b6659c54b5c419
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:30:05 2022 -0500

    ♻️  reset_acceleration_rates => refresh_…

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 27551fb109..01c2b13dda 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -162,30 +162,30 @@
                                  planner.settings.max_acceleration_mm_per_s2[Y_AXIS]
                                  OPTARG(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
                                );
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
     TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = 100);
     #if HAS_CLASSIC_JERK
       motion_state.jerk_state = planner.max_jerk;
       planner.max_jerk.set(0, 0 OPTARG(DELTA, 0));
     #endif
-    planner.reset_acceleration_rates();
+    planner.refresh_acceleration_rates();
     return motion_state;
   }
 
   void end_slow_homing(const motion_state_t &motion_state) {
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = motion_state.acceleration.x;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = motion_state.acceleration.y;
     TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = motion_state.acceleration.z);
     TERN_(HAS_CLASSIC_JERK, planner.max_jerk = motion_state.jerk_state);
-    planner.reset_acceleration_rates();
+    planner.refresh_acceleration_rates();
   }
 
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.

commit 3522d5376cbf03658b71ddaf8c341e35f59b369b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 20:55:15 2022 -0500

    🩹 Wrap SENSORLESS_STALLGUARD_DELAY

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 175a301568..27551fb109 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -314,21 +314,23 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(V)
       const int16_t tmc_save_current_V = stepperV.getMilliamps();
       stepperV.rms_current(V_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(W)
       const int16_t tmc_save_current_W = stepperW.getMilliamps();
       stepperW.rms_current(W_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
     #endif
-    safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+    #if SENSORLESS_STALLGUARD_DELAY
+      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+    #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
@@ -570,21 +572,23 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(U)
       stepperU.rms_current(tmc_save_current_U);
     #endif
     #if HAS_CURRENT_HOME(V)
       stepperV.rms_current(tmc_save_current_V);
     #endif
     #if HAS_CURRENT_HOME(W)
       stepperW.rms_current(tmc_save_current_W);
     #endif
-    safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+    #if SENSORLESS_STALLGUARD_DELAY
+      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+    #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ⚡️ Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2a1fec84ae..175a301568 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -314,20 +314,21 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(V)
       const int16_t tmc_save_current_V = stepperV.getMilliamps();
       stepperV.rms_current(V_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(W)
       const int16_t tmc_save_current_W = stepperW.getMilliamps();
       stepperW.rms_current(W_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
     #endif
+    safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
@@ -569,20 +570,21 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(U)
       stepperU.rms_current(tmc_save_current_U);
     #endif
     #if HAS_CURRENT_HOME(V)
       stepperV.rms_current(tmc_save_current_V);
     #endif
     #if HAS_CURRENT_HOME(W)
       stepperW.rms_current(tmc_save_current_W);
     #endif
+    safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))

commit 6567e0e0aa0dc429dcfc65870a7471b55c63f506
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 9 19:17:04 2022 -0500

    🎨 Misc. 9-axis cleanup

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 07896856a1..2a1fec84ae 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -368,21 +368,21 @@ void GcodeSuite::G28() {
                  needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
                  needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K),
                  needU = _UNSAFE(U), needV = _UNSAFE(V), needW = _UNSAFE(W)
                ),
                NUM_AXIS_LIST(              // Home each axis if needed or flagged
                  homeX = needX || parser.seen_test('X'),
                  homeY = needY || parser.seen_test('Y'),
                  homeZZ = homeZ,
                  homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME),
                  homeK = needK || parser.seen_test(AXIS6_NAME), homeU = needU || parser.seen_test(AXIS7_NAME),
-                 homeV = needV || parser.seen_test(AXIS8_NAME), homeW = needW || parser.seen_test(AXIS9_NAME),
+                 homeV = needV || parser.seen_test(AXIS8_NAME), homeW = needW || parser.seen_test(AXIS9_NAME)
                ),
                home_all = NUM_AXIS_GANG(   // Home-all if all or none are flagged
                     homeX == homeX, && homeY == homeX, && homeZ == homeX,
                  && homeI == homeX, && homeJ == homeX, && homeK == homeX,
                  && homeU == homeX, && homeV == homeX, && homeW == homeX
                ),
                NUM_AXIS_LIST(
                  doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
                  doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
                  doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ✨ Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 681df55f20..07896856a1 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -75,21 +75,21 @@
     sync_plan_position();
 
     const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
     // Use a higher diagonal feedrate so axes move at homing speed
     const float minfr = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)),
                 fr_mm_s = HYPOT(minfr, minfr);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
-        LINEAR_AXIS_LIST(
+        NUM_AXIS_LIST(
           TERN0(X_SENSORLESS, tmc_enable_stallguard(stepperX)),
           TERN0(Y_SENSORLESS, tmc_enable_stallguard(stepperY)),
           false, false, false, false
         )
         , TERN0(X2_SENSORLESS, tmc_enable_stallguard(stepperX2))
         , TERN0(Y2_SENSORLESS, tmc_enable_stallguard(stepperY2))
       };
     #endif
 
     do_blocking_move_to_xy(1.5 * max_length(X_AXIS) * x_axis_home_dir, 1.5 * max_length(Y_AXIS) * Y_HOME_DIR, fr_mm_s);
@@ -207,21 +207,21 @@ void GcodeSuite::G28() {
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen_test('S')) {
-      LOOP_LINEAR_AXES(a) set_axis_is_at_home((AxisEnum)a);
+      LOOP_NUM_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
@@ -251,21 +251,21 @@ void GcodeSuite::G28() {
   // Disable leveling before homing
   TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K)
+  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || HAS_CURRENT_HOME(U) || HAS_CURRENT_HOME(V) || HAS_CURRENT_HOME(W)
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
       DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
@@ -279,55 +279,55 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_Y), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_Y2), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
-    #if HAS_CURRENT_HOME(I)
-      const int16_t tmc_save_current_I = stepperI.getMilliamps();
-      stepperI.rms_current(I_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(J)
-      const int16_t tmc_save_current_J = stepperJ.getMilliamps();
-      stepperJ.rms_current(J_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
-    #endif
-    #if HAS_CURRENT_HOME(K)
-      const int16_t tmc_save_current_K = stepperK.getMilliamps();
-      stepperK.rms_current(K_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
-    #endif
     #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
       const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
       stepperZ.rms_current(Z_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_Z), tmc_save_current_Z, Z_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(I)
       const int16_t tmc_save_current_I = stepperI.getMilliamps();
       stepperI.rms_current(I_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(J)
       const int16_t tmc_save_current_J = stepperJ.getMilliamps();
       stepperJ.rms_current(J_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(K)
       const int16_t tmc_save_current_K = stepperK.getMilliamps();
       stepperK.rms_current(K_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
     #endif
+    #if HAS_CURRENT_HOME(U)
+      const int16_t tmc_save_current_U = stepperU.getMilliamps();
+      stepperU.rms_current(U_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_U), tmc_save_current_U, U_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(V)
+      const int16_t tmc_save_current_V = stepperV.getMilliamps();
+      stepperV.rms_current(V_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_V), tmc_save_current_V, V_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(W)
+      const int16_t tmc_save_current_W = stepperW.getMilliamps();
+      stepperW.rms_current(W_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_W), tmc_save_current_W, W_CURRENT_HOME);
+    #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
@@ -357,51 +357,56 @@ void GcodeSuite::G28() {
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
 
     home_TPARA();
 
   #else
 
     #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
 
     const bool homeZ = TERN0(HAS_Z_AXIS, parser.seen_test('Z')),
-               LINEAR_AXIS_LIST(              // Other axes should be homed before Z safe-homing
+               NUM_AXIS_LIST(              // Other axes should be homed before Z safe-homing
                  needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
-                 needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K)
+                 needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K),
+                 needU = _UNSAFE(U), needV = _UNSAFE(V), needW = _UNSAFE(W)
                ),
-               LINEAR_AXIS_LIST(              // Home each axis if needed or flagged
+               NUM_AXIS_LIST(              // Home each axis if needed or flagged
                  homeX = needX || parser.seen_test('X'),
                  homeY = needY || parser.seen_test('Y'),
                  homeZZ = homeZ,
-                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME), homeK = needK || parser.seen_test(AXIS6_NAME)
+                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME),
+                 homeK = needK || parser.seen_test(AXIS6_NAME), homeU = needU || parser.seen_test(AXIS7_NAME),
+                 homeV = needV || parser.seen_test(AXIS8_NAME), homeW = needW || parser.seen_test(AXIS9_NAME),
                ),
-               home_all = LINEAR_AXIS_GANG(   // Home-all if all or none are flagged
+               home_all = NUM_AXIS_GANG(   // Home-all if all or none are flagged
                     homeX == homeX, && homeY == homeX, && homeZ == homeX,
-                 && homeI == homeX, && homeJ == homeX, && homeK == homeX
+                 && homeI == homeX, && homeJ == homeX, && homeK == homeX,
+                 && homeU == homeX, && homeV == homeX, && homeW == homeX
                ),
-               LINEAR_AXIS_LIST(
+               NUM_AXIS_LIST(
                  doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
-                 doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK
+                 doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK,
+                 doU = home_all || homeU, doV = home_all || homeV, doW = home_all || homeW
                );
 
     #if HAS_Z_AXIS
       UNUSED(needZ); UNUSED(homeZZ);
     #else
       constexpr bool doZ = false;
     #endif
 
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
     const bool seenR = parser.seenval('R');
     const float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (seenR || LINEAR_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
+    if (z_homing_height && (seenR || NUM_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK, || doU, || doV, || doW))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     // Home Y (before X)
@@ -427,47 +432,67 @@ void GcodeSuite::G28() {
         // Consider the active extruder to be in its "parked" position
         idex_set_parked();
 
       #else
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
+    #if BOTH(FOAMCUTTER_XYUV, HAS_I_AXIS)
+      // Home I (after X)
+      if (doI) homeaxis(I_AXIS);
+    #endif
+
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
+    #if BOTH(FOAMCUTTER_XYUV, HAS_J_AXIS)
+      // Home J (after Y)
+      if (doJ) homeaxis(J_AXIS);
+    #endif
+
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
-    // Home Z last if homing towards the bed
-    #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
-      if (doZ) {
-        #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
-          stepper.set_all_z_lock(false);
-          stepper.set_separate_multi_axis(false);
-        #endif
+    #if ENABLED(FOAMCUTTER_XYUV)
+      // skip homing of unused Z axis for foamcutters
+      if (doZ) set_axis_is_at_home(Z_AXIS);
+    #else
+      // Home Z last if homing towards the bed
+      #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
+        if (doZ) {
+          #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+            stepper.set_all_z_lock(false);
+            stepper.set_separate_multi_axis(false);
+          #endif
+
+          #if ENABLED(Z_SAFE_HOMING)
+            if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
+          #else
+            homeaxis(Z_AXIS);
+          #endif
+          probe.move_z_after_homing();
+        }
+      #endif
 
-        #if ENABLED(Z_SAFE_HOMING)
-          if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
-        #else
-          homeaxis(Z_AXIS);
-        #endif
-        probe.move_z_after_homing();
-      }
+      SECONDARY_AXIS_CODE(
+        if (doI) homeaxis(I_AXIS),
+        if (doJ) homeaxis(J_AXIS),
+        if (doK) homeaxis(K_AXIS),
+        if (doU) homeaxis(U_AXIS),
+        if (doV) homeaxis(V_AXIS),
+        if (doW) homeaxis(W_AXIS)
+      );
     #endif
 
-    TERN_(HAS_I_AXIS, if (doI) homeaxis(I_AXIS));
-    TERN_(HAS_J_AXIS, if (doJ) homeaxis(J_AXIS));
-    TERN_(HAS_K_AXIS, if (doK) homeaxis(K_AXIS));
-
     sync_plan_position();
 
   #endif
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
@@ -535,41 +560,50 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(I)
       stepperI.rms_current(tmc_save_current_I);
     #endif
     #if HAS_CURRENT_HOME(J)
       stepperJ.rms_current(tmc_save_current_J);
     #endif
     #if HAS_CURRENT_HOME(K)
       stepperK.rms_current(tmc_save_current_K);
     #endif
+    #if HAS_CURRENT_HOME(U)
+      stepperU.rms_current(tmc_save_current_U);
+    #endif
+    #if HAS_CURRENT_HOME(V)
+      stepperV.rms_current(tmc_save_current_V);
+    #endif
+    #if HAS_CURRENT_HOME(W)
+      stepperW.rms_current(tmc_save_current_W);
+    #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     #define _EN_ITEM(N) , E_AXIS
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
-      LINEAR_AXIS_LIST(X_AXIS, Y_AXIS, Z_AXIS, I_AXIS, J_AXIS, K_AXIS),
+      NUM_AXIS_LIST(X_AXIS, Y_AXIS, Z_AXIS, I_AXIS, J_AXIS, K_AXIS, U_AXIS, V_AXIS, W_AXIS),
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS, Z_AXIS
       REPEAT(E_STEPPERS, _EN_ITEM)
     };
     #undef _EN_ITEM
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
       const uint8_t cv = L64XX::chain[j];
       L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L64XX_axis_xref[cv]));
     }
   #endif
 }

commit 258a2ed112da097969d36187b53805df7f98a3ec
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 19:17:12 2022 -0500

    🎨 Apply _TERN where possible

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 9361790d74..681df55f20 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -75,47 +75,41 @@
     sync_plan_position();
 
     const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
     // Use a higher diagonal feedrate so axes move at homing speed
     const float minfr = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)),
                 fr_mm_s = HYPOT(minfr, minfr);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
-          LINEAR_AXIS_LIST(tmc_enable_stallguard(stepperX), tmc_enable_stallguard(stepperY), false, false, false, false)
-        , false
-          #if AXIS_HAS_STALLGUARD(X2)
-            || tmc_enable_stallguard(stepperX2)
-          #endif
-        , false
-          #if AXIS_HAS_STALLGUARD(Y2)
-            || tmc_enable_stallguard(stepperY2)
-          #endif
+        LINEAR_AXIS_LIST(
+          TERN0(X_SENSORLESS, tmc_enable_stallguard(stepperX)),
+          TERN0(Y_SENSORLESS, tmc_enable_stallguard(stepperY)),
+          false, false, false, false
+        )
+        , TERN0(X2_SENSORLESS, tmc_enable_stallguard(stepperX2))
+        , TERN0(Y2_SENSORLESS, tmc_enable_stallguard(stepperY2))
       };
     #endif
 
     do_blocking_move_to_xy(1.5 * max_length(X_AXIS) * x_axis_home_dir, 1.5 * max_length(Y_AXIS) * Y_HOME_DIR, fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position.set(0.0, 0.0);
 
     #if ENABLED(SENSORLESS_HOMING) && DISABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
-      tmc_disable_stallguard(stepperX, stealth_states.x);
-      tmc_disable_stallguard(stepperY, stealth_states.y);
-      #if AXIS_HAS_STALLGUARD(X2)
-        tmc_disable_stallguard(stepperX2, stealth_states.x2);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Y2)
-        tmc_disable_stallguard(stepperY2, stealth_states.y2);
-      #endif
+      TERN_(X_SENSORLESS, tmc_disable_stallguard(stepperX, stealth_states.x));
+      TERN_(X2_SENSORLESS, tmc_disable_stallguard(stepperX2, stealth_states.x2));
+      TERN_(Y_SENSORLESS, tmc_disable_stallguard(stepperY, stealth_states.y));
+      TERN_(Y2_SENSORLESS, tmc_disable_stallguard(stepperY2, stealth_states.y2));
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
     DEBUG_SECTION(log_G28, "home_z_safely", DEBUGGING(LEVELING));
 

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    🧑‍💻 Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index dbbea79353..9361790d74 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -232,21 +232,21 @@ void GcodeSuite::G28() {
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     const M_StateEnum old_grblstate = M_State_grbl;
     set_and_report_grblstate(M_HOMING);
   #endif
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_StartHoming());
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingStart());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if CAN_SET_LEVELING_AFTER_G28
     const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
   #endif
@@ -545,22 +545,22 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(J)
       stepperJ.rms_current(tmc_save_current_J);
     #endif
     #if HAS_CURRENT_HOME(K)
       stepperK.rms_current(tmc_save_current_K);
     #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
-  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedHoming());
-  TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_HomingDone());
+  TERN_(EXTENSIBLE_UI, ExtUI::onHomingDone());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    🔧 DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4d8891d55b..dbbea79353 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -44,21 +44,21 @@
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif

commit b07a34eb6bd8928aebef631554626aaa8c88c567
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 16:04:17 2022 -0600

    🐛 Fix M_State_grbl when G29 calls G28

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a38c567939..4d8891d55b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -206,22 +206,20 @@
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
-  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_HOMING));
-
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen_test('S')) {
       LOOP_LINEAR_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
@@ -229,20 +227,25 @@ void GcodeSuite::G28() {
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
+  #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
+    const M_StateEnum old_grblstate = M_State_grbl;
+    set_and_report_grblstate(M_HOMING);
+  #endif
+
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if CAN_SET_LEVELING_AFTER_G28
     const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
@@ -550,21 +553,21 @@ void GcodeSuite::G28() {
   ui.refresh();
 
   TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
-  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(old_grblstate));
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     #define _EN_ITEM(N) , E_AXIS
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       LINEAR_AXIS_LIST(X_AXIS, Y_AXIS, Z_AXIS, I_AXIS, J_AXIS, K_AXIS),
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS, Z_AXIS
       REPEAT(E_STEPPERS, _EN_ITEM)

commit 5520aa3a10453d9245854aeed88583f11c34cab2
Author: espr14 <espr14@gmail.com>
Date:   Thu Feb 10 20:28:38 2022 +0100

    🩹 Simplify quick homing feedrate (#23714)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 606f6ad031..a38c567939 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -69,40 +69,39 @@
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position.set(0.0, 0.0);
     sync_plan_position();
 
     const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
-    const float mlx = max_length(X_AXIS),
-                mly = max_length(Y_AXIS),
-                mlratio = mlx > mly ? mly / mlx : mlx / mly,
-                fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+    // Use a higher diagonal feedrate so axes move at homing speed
+    const float minfr = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)),
+                fr_mm_s = HYPOT(minfr, minfr);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
           LINEAR_AXIS_LIST(tmc_enable_stallguard(stepperX), tmc_enable_stallguard(stepperY), false, false, false, false)
         , false
           #if AXIS_HAS_STALLGUARD(X2)
             || tmc_enable_stallguard(stepperX2)
           #endif
         , false
           #if AXIS_HAS_STALLGUARD(Y2)
             || tmc_enable_stallguard(stepperY2)
           #endif
       };
     #endif
 
-    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * Y_HOME_DIR, fr_mm_s);
+    do_blocking_move_to_xy(1.5 * max_length(X_AXIS) * x_axis_home_dir, 1.5 * max_length(Y_AXIS) * Y_HOME_DIR, fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position.set(0.0, 0.0);
 
     #if ENABLED(SENSORLESS_HOMING) && DISABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);

commit a323d6732bf691d29ce996b6bfd11cbcc3c9f0a7
Author: MOHAMMAD RASIM <mohammad.rasim96@gmail.com>
Date:   Wed Feb 9 21:29:34 2022 +0300

    🚸 Fix, Improve Power-Loss Recovery (#22828)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 48f02d2a33..606f6ad031 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -388,23 +388,24 @@ void GcodeSuite::G28() {
                );
 
     #if HAS_Z_AXIS
       UNUSED(needZ); UNUSED(homeZZ);
     #else
       constexpr bool doZ = false;
     #endif
 
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
-    const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
+    const bool seenR = parser.seenval('R');
+    const float z_homing_height = seenR ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (LINEAR_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
+    if (z_homing_height && (seenR || LINEAR_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     // Home Y (before X)
@@ -444,21 +445,25 @@ void GcodeSuite::G28() {
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
     // Home Z last if homing towards the bed
     #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
       if (doZ) {
         #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
           stepper.set_all_z_lock(false);
           stepper.set_separate_multi_axis(false);
         #endif
 
-        TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
+        #if ENABLED(Z_SAFE_HOMING)
+          if (TERN1(POWER_LOSS_RECOVERY, !parser.seen_test('H'))) home_z_safely(); else homeaxis(Z_AXIS);
+        #else
+          homeaxis(Z_AXIS);
+        #endif
         probe.move_z_after_homing();
       }
     #endif
 
     TERN_(HAS_I_AXIS, if (doI) homeaxis(I_AXIS));
     TERN_(HAS_J_AXIS, if (doJ) homeaxis(J_AXIS));
     TERN_(HAS_K_AXIS, if (doK) homeaxis(K_AXIS));
 
     sync_plan_position();
 

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    🚸 Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index cda71a1c10..48f02d2a33 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -45,21 +45,21 @@
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
-  #include "../../lcd/e3v2/enhanced/dwin.h"
+  #include "../../lcd/e3v2/proui/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif
 

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    🧑‍💻 Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index bd651cd7d8..cda71a1c10 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -255,67 +255,82 @@ void GcodeSuite::G28() {
   // Disable leveling before homing
   TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
+  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z)) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K)
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
       DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F("X"), tmc_save_current_X, X_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_X), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F("X2"), tmc_save_current_X2, X2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_X2), tmc_save_current_X2, X2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_Y), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_Y2), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(I)
       const int16_t tmc_save_current_I = stepperI.getMilliamps();
       stepperI.rms_current(I_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(J)
       const int16_t tmc_save_current_J = stepperJ.getMilliamps();
       stepperJ.rms_current(J_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(K)
       const int16_t tmc_save_current_K = stepperK.getMilliamps();
       stepperK.rms_current(K_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
       const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
       stepperZ.rms_current(Z_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_Z), tmc_save_current_Z, Z_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(I)
+      const int16_t tmc_save_current_I = stepperI.getMilliamps();
+      stepperI.rms_current(I_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(J)
+      const int16_t tmc_save_current_J = stepperJ.getMilliamps();
+      stepperJ.rms_current(J_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(K)
+      const int16_t tmc_save_current_K = stepperK.getMilliamps();
+      stepperK.rms_current(K_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
@@ -354,21 +369,21 @@ void GcodeSuite::G28() {
 
     const bool homeZ = TERN0(HAS_Z_AXIS, parser.seen_test('Z')),
                LINEAR_AXIS_LIST(              // Other axes should be homed before Z safe-homing
                  needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
                  needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K)
                ),
                LINEAR_AXIS_LIST(              // Home each axis if needed or flagged
                  homeX = needX || parser.seen_test('X'),
                  homeY = needY || parser.seen_test('Y'),
                  homeZZ = homeZ,
-                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME), homeK = needK || parser.seen_test(AXIS6_NAME),
+                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME), homeK = needK || parser.seen_test(AXIS6_NAME)
                ),
                home_all = LINEAR_AXIS_GANG(   // Home-all if all or none are flagged
                     homeX == homeX, && homeY == homeX, && homeZ == homeX,
                  && homeI == homeX, && homeJ == homeX, && homeK == homeX
                ),
                LINEAR_AXIS_LIST(
                  doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
                  doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK
                );
 

commit 9665a4434cee0386fa2a63a058b6f2598943ee98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 02:51:34 2022 -0600

    🧑‍💻 Fewer string macros

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 421220e410..bd651cd7d8 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -286,31 +286,31 @@ void GcodeSuite::G28() {
       if (DEBUGGING(LEVELING)) debug_current(F("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(I)
       const int16_t tmc_save_current_I = stepperI.getMilliamps();
       stepperI.rms_current(I_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(AXIS4_STR), tmc_save_current_I, I_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_I), tmc_save_current_I, I_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(J)
       const int16_t tmc_save_current_J = stepperJ.getMilliamps();
       stepperJ.rms_current(J_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(AXIS5_STR), tmc_save_current_J, J_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_J), tmc_save_current_J, J_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(K)
       const int16_t tmc_save_current_K = stepperK.getMilliamps();
       stepperK.rms_current(K_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(F(AXIS6_STR), tmc_save_current_K, K_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(STR_K), tmc_save_current_K, K_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
       const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
       stepperZ.rms_current(Z_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    🧑‍💻 Apply axis conditionals

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8743c0d895..421220e410 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -434,29 +434,23 @@ void GcodeSuite::G28() {
         #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
           stepper.set_all_z_lock(false);
           stepper.set_separate_multi_axis(false);
         #endif
 
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
         probe.move_z_after_homing();
       }
     #endif
 
-    #if LINEAR_AXES >= 4
-      if (doI) homeaxis(I_AXIS);
-    #endif
-    #if LINEAR_AXES >= 5
-      if (doJ) homeaxis(J_AXIS);
-    #endif
-    #if LINEAR_AXES >= 6
-      if (doK) homeaxis(K_AXIS);
-    #endif
+    TERN_(HAS_I_AXIS, if (doI) homeaxis(I_AXIS));
+    TERN_(HAS_J_AXIS, if (doJ) homeaxis(J_AXIS));
+    TERN_(HAS_K_AXIS, if (doK) homeaxis(K_AXIS));
 
     sync_plan_position();
 
   #endif
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.

commit 7bc18a707572d063ac3ba905f1f704dd965f26f3
Author: lukrow80 <64228214+lukrow80@users.noreply.github.com>
Date:   Tue Nov 23 22:30:13 2021 +0100

    🐛 Fix homing current for extra axes (#23152)
    
    Followup to #19112

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 28df536c51..8743c0d895 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -255,21 +255,21 @@ void GcodeSuite::G28() {
   // Disable leveling before homing
   TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
+  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || HAS_CURRENT_HOME(I) || HAS_CURRENT_HOME(J) || HAS_CURRENT_HOME(K) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
       DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
@@ -283,20 +283,35 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
+    #if HAS_CURRENT_HOME(I)
+      const int16_t tmc_save_current_I = stepperI.getMilliamps();
+      stepperI.rms_current(I_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(AXIS4_STR), tmc_save_current_I, I_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(J)
+      const int16_t tmc_save_current_J = stepperJ.getMilliamps();
+      stepperJ.rms_current(J_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(AXIS5_STR), tmc_save_current_J, J_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(K)
+      const int16_t tmc_save_current_K = stepperK.getMilliamps();
+      stepperK.rms_current(K_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F(AXIS6_STR), tmc_save_current_K, K_CURRENT_HOME);
+    #endif
     #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
       const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
       stepperZ.rms_current(Z_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(F("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif

commit 33c89d1f3fa603e49f5a9b346d089331f0f0efbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 14 17:19:57 2021 -0600

    🐛 Fix SENSORLESS_HOMING for 6-axis

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 95f2a9b176..28df536c51 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -76,23 +76,21 @@
 
     const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
-          tmc_enable_stallguard(stepperX)
-        , tmc_enable_stallguard(stepperY)
-        , false
+          LINEAR_AXIS_LIST(tmc_enable_stallguard(stepperX), tmc_enable_stallguard(stepperY), false, false, false, false)
         , false
           #if AXIS_HAS_STALLGUARD(X2)
             || tmc_enable_stallguard(stepperX2)
           #endif
         , false
           #if AXIS_HAS_STALLGUARD(Y2)
             || tmc_enable_stallguard(stepperY2)
           #endif
       };
     #endif

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    🎨 Apply F() to various reports

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index cd6a3a760d..95f2a9b176 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -262,47 +262,47 @@ void GcodeSuite::G28() {
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
-    auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b) {
-      DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
+    auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
+      DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(PSTR("X2"), tmc_save_current_X2, X2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F("X2"), tmc_save_current_X2, X2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(PSTR("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
       const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
       stepperZ.rms_current(Z_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current(PSTR("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(F("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    🎨 Apply F() to status message

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index dc93ba3d2f..cd6a3a760d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -149,21 +149,21 @@
 
       // Free the active extruder for movement
       TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
 
       TERN_(SENSORLESS_HOMING, safe_delay(500)); // Short delay needed to settle
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
-      LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
+      LCD_MESSAGE(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
   }
 
 #endif // Z_SAFE_HOMING
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
 
   motion_state_t begin_slow_homing() {
     motion_state_t motion_state{0};

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index d85c0306d4..dc93ba3d2f 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -263,21 +263,21 @@ void GcodeSuite::G28() {
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b) {
-      DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
+      DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X2"), tmc_save_current_X2, X2_CURRENT_HOME);
@@ -364,21 +364,21 @@ void GcodeSuite::G28() {
     #else
       constexpr bool doZ = false;
     #endif
 
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
     if (z_homing_height && (LINEAR_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
     // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
       homeaxis(Y_AXIS);

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ✨ Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 89ad20d906..d85c0306d4 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -39,26 +39,27 @@
   #include "../../feature/tmc_util.h"
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
-#if ENABLED(DWIN_CREALITY_LCD)
-  #include "../../lcd/e3v2/creality/dwin.h"
-#endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
+#elif ENABLED(DWIN_CREALITY_LCD)
+  #include "../../lcd/e3v2/creality/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "../../lcd/e3v2/enhanced/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif
 
@@ -231,21 +232,21 @@ void GcodeSuite::G28() {
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
-  TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if CAN_SET_LEVELING_AFTER_G28
     const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
   #endif
@@ -515,21 +516,21 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(J)
       stepperJ.rms_current(tmc_save_current_J);
     #endif
     #if HAS_CURRENT_HOME(K)
       stepperK.rms_current(tmc_save_current_K);
     #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
-  TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
+  TERN_(HAS_DWIN_E3V2_BASIC, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   #if HAS_L64XX

commit 9bb5b10c0c9cf5a61d2bfb9dfdb6cfe210b6002b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 31 05:32:13 2021 -0500

    🚚 Relocate and adjust DWIN E3V2 (#22471)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6baef030bf..89ad20d906 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -40,21 +40,21 @@
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../../lcd/dwin/e3v2/dwin.h"
+  #include "../../lcd/e3v2/creality/dwin.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../lcd/extui/ui_api.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 

commit e1907a99e2404ae9a0d1c1115978bc9640aa96f1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 24 21:41:09 2021 -0500

    🎨 Fix some formatting, F() versus PSTR()

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ca9cbb8cc9..6baef030bf 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -261,21 +261,21 @@ void GcodeSuite::G28() {
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
-    auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
+    auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b) {
       DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ⚡️ Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7cd1f65fbf..ca9cbb8cc9 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -160,34 +160,38 @@
     }
   }
 
 #endif // Z_SAFE_HOMING
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
 
   motion_state_t begin_slow_homing() {
     motion_state_t motion_state{0};
     motion_state.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
-                                 planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+                                 planner.settings.max_acceleration_mm_per_s2[Y_AXIS]
+                                 OPTARG(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+                               );
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
+    TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = 100);
     #if HAS_CLASSIC_JERK
       motion_state.jerk_state = planner.max_jerk;
-      planner.max_jerk.set(0, 0);
+      planner.max_jerk.set(0, 0 OPTARG(DELTA, 0));
     #endif
     planner.reset_acceleration_rates();
     return motion_state;
   }
 
   void end_slow_homing(const motion_state_t &motion_state) {
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = motion_state.acceleration.x;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = motion_state.acceleration.y;
+    TERN_(DELTA, planner.settings.max_acceleration_mm_per_s2[Z_AXIS] = motion_state.acceleration.z);
     TERN_(HAS_CLASSIC_JERK, planner.max_jerk = motion_state.jerk_state);
     planner.reset_acceleration_rates();
   }
 
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
@@ -252,21 +256,21 @@ void GcodeSuite::G28() {
   // Disable leveling before homing
   TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
 
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
+  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2) || (ENABLED(DELTA) && HAS_CURRENT_HOME(Z))
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
       DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
@@ -280,20 +284,25 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
+    #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
+      const int16_t tmc_save_current_Z = stepperZ.getMilliamps();
+      stepperZ.rms_current(Z_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(PSTR("Z"), tmc_save_current_Z, Z_CURRENT_HOME);
+    #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     motion_state_t saved_motion_state = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
@@ -490,20 +499,23 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
+    #if HAS_CURRENT_HOME(Z) && ENABLED(DELTA)
+      stepperZ.rms_current(tmc_save_current_Z);
+    #endif
     #if HAS_CURRENT_HOME(I)
       stepperI.rms_current(tmc_save_current_I);
     #endif
     #if HAS_CURRENT_HOME(J)
       stepperJ.rms_current(tmc_save_current_J);
     #endif
     #if HAS_CURRENT_HOME(K)
       stepperK.rms_current(tmc_save_current_K);
     #endif
   #endif // HAS_HOMING_CURRENT

commit 5ce6d8aa1f81178fc25a12abff63ca1a6c88e42c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 19 14:09:09 2021 -0500

    Cosmetic changes for G28

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 69cdd02d16..7cd1f65fbf 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -157,38 +157,38 @@
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
   }
 
 #endif // Z_SAFE_HOMING
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
 
-  slow_homing_t begin_slow_homing() {
-    slow_homing_t slow_homing{0};
-    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
+  motion_state_t begin_slow_homing() {
+    motion_state_t motion_state{0};
+    motion_state.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
                                  planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
     #if HAS_CLASSIC_JERK
-      slow_homing.jerk_xy = planner.max_jerk;
+      motion_state.jerk_state = planner.max_jerk;
       planner.max_jerk.set(0, 0);
     #endif
     planner.reset_acceleration_rates();
-    return slow_homing;
+    return motion_state;
   }
 
-  void end_slow_homing(const slow_homing_t &slow_homing) {
-    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
-    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
-    TERN_(HAS_CLASSIC_JERK, planner.max_jerk = slow_homing.jerk_xy);
+  void end_slow_homing(const motion_state_t &motion_state) {
+    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = motion_state.acceleration.x;
+    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = motion_state.acceleration.y;
+    TERN_(HAS_CLASSIC_JERK, planner.max_jerk = motion_state.jerk_state);
     planner.reset_acceleration_rates();
   }
 
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
@@ -282,21 +282,23 @@ void GcodeSuite::G28() {
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
-  TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing_t slow_homing = begin_slow_homing());
+  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+    motion_state_t saved_motion_state = begin_slow_homing();
+  #endif
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     // PARKING_EXTRUDER homing requires different handling of movement / solenoid activation, depending on the side of homing
     #if ENABLED(PARKING_EXTRUDER)
       const bool pe_final_change_must_unpark = parking_extruder_unpark_after_homing(old_tool_index, X_HOME_DIR + 1 == old_tool_index * 2);
     #endif
@@ -308,21 +310,21 @@ void GcodeSuite::G28() {
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
-    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
+    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
   #elif ENABLED(AXEL_TPARA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
 
     home_TPARA();
 
   #else
 
     #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
@@ -394,21 +396,21 @@ void GcodeSuite::G28() {
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
-    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
+    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
 
     // Home Z last if homing towards the bed
     #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
       if (doZ) {
         #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
           stepper.set_all_z_lock(false);
           stepper.set_separate_multi_axis(false);
         #endif
 
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
@@ -433,40 +435,40 @@ void GcodeSuite::G28() {
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
     if (idex_is_duplicating()) {
 
-      TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing = begin_slow_homing());
+      TERN_(IMPROVE_HOMING_RELIABILITY, saved_motion_state = begin_slow_homing());
 
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
       inactive_extruder_x = current_position.x;
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
       idex_set_parked();
 
       dual_x_carriage_mode = IDEX_saved_mode;
       set_duplication_enabled(IDEX_saved_duplication_state);
 
-      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
+      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(saved_motion_state));
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   // Move to a height where we can use the full xy-area

commit d0df8bc3cbd39d23cb52ffcd3b26629a185c18a6
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Wed Jun 16 23:15:16 2021 -0700

    💡 Add G28 L description (#22144)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 61e7ab4233..69cdd02d16 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -188,23 +188,23 @@
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.
  *        With QUICK_HOME enabled XY will home together, then Z.
  *
- *  O   Home only if position is unknown
- *
- *  Rn  Raise by n mm/inches before homing
+ *  L<bool>   Force leveling state ON (if possible) or OFF after homing (Requires RESTORE_LEVELING_AFTER_G28 or ENABLE_LEVELING_AFTER_G28)
+ *  O         Home only if the position is not known and trusted
+ *  R<linear> Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
@@ -222,21 +222,21 @@ void GcodeSuite::G28() {
     if (parser.seen_test('S')) {
       LOOP_LINEAR_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
-  if (!axes_should_home() && parser.boolval('O')) {
+  if (!axes_should_home() && parser.seen_test('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state

commit 0e1e1591879077cdda868a28b095c427098fda07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 10 02:05:04 2021 -0500

    🎨 Adjust some conditionals

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2eca66c3b0..61e7ab4233 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -235,26 +235,30 @@ void GcodeSuite::G28() {
   }
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
-  #if HAS_LEVELING
-    const bool leveling_restore_state = parser.boolval('L', TERN(RESTORE_LEVELING_AFTER_G28, planner.leveling_active, ENABLED(ENABLE_LEVELING_AFTER_G28)));
-    IF_ENABLED(PROBE_MANUALLY, g29_in_progress = false); // Cancel the active G29 session
-    set_bed_leveling_enabled(false);
+  #if CAN_SET_LEVELING_AFTER_G28
+    const bool leveling_restore_state = parser.boolval('L', TERN1(RESTORE_LEVELING_AFTER_G28, planner.leveling_active));
   #endif
 
+  // Cancel any prior G29 session
+  TERN_(PROBE_MANUALLY, g29_in_progress = false);
+
+  // Disable leveling before homing
+  TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
+
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
     #define HAS_HOMING_CURRENT 1
   #endif
@@ -346,27 +350,28 @@ void GcodeSuite::G28() {
     #if HAS_Z_AXIS
       UNUSED(needZ); UNUSED(homeZZ);
     #else
       constexpr bool doZ = false;
     #endif
 
     TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
 
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (0 LINEAR_AXIS_GANG(|| doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
+    if (z_homing_height && (LINEAR_AXIS_GANG(doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
+    // Diagonal move first if both are homing
     TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
       homeaxis(Y_AXIS);
 
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
@@ -457,26 +462,24 @@ void GcodeSuite::G28() {
       TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
-  #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
-    // move to a height where we can use the full xy-area
-    do_blocking_move_to_z(delta_clip_start_height);
-  #endif
+  // Move to a height where we can use the full xy-area
+  TERN_(DELTA_HOME_TO_SAFE_ZONE, do_blocking_move_to_z(delta_clip_start_height));
 
-  TERN_(HAS_LEVELING, set_bed_leveling_enabled(leveling_restore_state));
+  TERN_(CAN_SET_LEVELING_AFTER_G28, if (leveling_restore_state) set_bed_leveling_enabled());
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    🏗️ Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a71f541593..2eca66c3b0 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -316,56 +316,58 @@ void GcodeSuite::G28() {
   #elif ENABLED(AXEL_TPARA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
 
     home_TPARA();
 
   #else
 
     #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
 
-    const bool homeZ = parser.seen_test('Z'),
-               LINEAR_AXIS_LIST( // Other axes should be homed before Z safe-homing
-                 needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false // UNUSED
+    const bool homeZ = TERN0(HAS_Z_AXIS, parser.seen_test('Z')),
+               LINEAR_AXIS_LIST(              // Other axes should be homed before Z safe-homing
+                 needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false, // UNUSED
+                 needI = _UNSAFE(I), needJ = _UNSAFE(J), needK = _UNSAFE(K)
                ),
-               LINEAR_AXIS_LIST( // Home each axis if needed or flagged
+               LINEAR_AXIS_LIST(              // Home each axis if needed or flagged
                  homeX = needX || parser.seen_test('X'),
                  homeY = needY || parser.seen_test('Y'),
-                 homeZZ = homeZ // UNUSED
+                 homeZZ = homeZ,
+                 homeI = needI || parser.seen_test(AXIS4_NAME), homeJ = needJ || parser.seen_test(AXIS5_NAME), homeK = needK || parser.seen_test(AXIS6_NAME),
                ),
-               // Home-all if all or none are flagged
-               home_all = true LINEAR_AXIS_GANG(&& homeX == homeX, && homeX == homeY, && homeX == homeZ),
-               LINEAR_AXIS_LIST(doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ);
-
-   UNUSED(needZ);
-   UNUSED(homeZZ);
-
-    #if ENABLED(HOME_Z_FIRST)
-
-      if (doZ) homeaxis(Z_AXIS);
+               home_all = LINEAR_AXIS_GANG(   // Home-all if all or none are flagged
+                    homeX == homeX, && homeY == homeX, && homeZ == homeX,
+                 && homeI == homeX, && homeJ == homeX, && homeK == homeX
+               ),
+               LINEAR_AXIS_LIST(
+                 doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ,
+                 doI = home_all || homeI, doJ = home_all || homeJ, doK = home_all || homeK
+               );
 
+    #if HAS_Z_AXIS
+      UNUSED(needZ); UNUSED(homeZZ);
+    #else
+      constexpr bool doZ = false;
     #endif
 
+    TERN_(HOME_Z_FIRST, if (doZ) homeaxis(Z_AXIS));
+
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (0 LINEAR_AXIS_GANG(|| doX, || doY, || TERN0(Z_SAFE_HOMING, doZ)))) {
+    if (z_homing_height && (0 LINEAR_AXIS_GANG(|| doX, || doY, || TERN0(Z_SAFE_HOMING, doZ), || doI, || doJ, || doK))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
-    #if ENABLED(QUICK_HOME)
-
-      if (doX && doY) quick_home_xy();
-
-    #endif
+    TERN_(QUICK_HOME, if (doX && doY) quick_home_xy());
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
       homeaxis(Y_AXIS);
 
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
@@ -390,32 +392,42 @@ void GcodeSuite::G28() {
       #endif
     }
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
-    #if DISABLED(HOME_Z_FIRST)
+    #if HAS_Z_AXIS && DISABLED(HOME_Z_FIRST)
       if (doZ) {
         #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
           stepper.set_all_z_lock(false);
           stepper.set_separate_multi_axis(false);
         #endif
 
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
         probe.move_z_after_homing();
       }
     #endif
 
+    #if LINEAR_AXES >= 4
+      if (doI) homeaxis(I_AXIS);
+    #endif
+    #if LINEAR_AXES >= 5
+      if (doJ) homeaxis(J_AXIS);
+    #endif
+    #if LINEAR_AXES >= 6
+      if (doK) homeaxis(K_AXIS);
+    #endif
+
     sync_plan_position();
 
   #endif
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
@@ -473,39 +485,50 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
+    #if HAS_CURRENT_HOME(I)
+      stepperI.rms_current(tmc_save_current_I);
+    #endif
+    #if HAS_CURRENT_HOME(J)
+      stepperJ.rms_current(tmc_save_current_J);
+    #endif
+    #if HAS_CURRENT_HOME(K)
+      stepperK.rms_current(tmc_save_current_K);
+    #endif
   #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
+    #define _EN_ITEM(N) , E_AXIS
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
-      X_AXIS, Y_AXIS, Z_AXIS,
-      X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
-      E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
+      LINEAR_AXIS_LIST(X_AXIS, Y_AXIS, Z_AXIS, I_AXIS, J_AXIS, K_AXIS),
+      X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS, Z_AXIS
+      REPEAT(E_STEPPERS, _EN_ITEM)
     };
+    #undef _EN_ITEM
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
       const uint8_t cv = L64XX::chain[j];
       L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L64XX_axis_xref[cv]));
     }
   #endif
 }

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ♻️ Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index aacfcfa42f..a71f541593 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -314,36 +314,47 @@ void GcodeSuite::G28() {
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
   #elif ENABLED(AXEL_TPARA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
 
     home_TPARA();
 
   #else
 
+    #define _UNSAFE(A) (homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(A##_AXIS))))
+
     const bool homeZ = parser.seen_test('Z'),
-               needX = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(X_AXIS))),
-               needY = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(Y_AXIS))),
-               homeX = needX || parser.seen_test('X'), homeY = needY || parser.seen_test('Y'),
-               home_all = homeX == homeY && homeX == homeZ, // All or None
-               doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
+               LINEAR_AXIS_LIST( // Other axes should be homed before Z safe-homing
+                 needX = _UNSAFE(X), needY = _UNSAFE(Y), needZ = false // UNUSED
+               ),
+               LINEAR_AXIS_LIST( // Home each axis if needed or flagged
+                 homeX = needX || parser.seen_test('X'),
+                 homeY = needY || parser.seen_test('Y'),
+                 homeZZ = homeZ // UNUSED
+               ),
+               // Home-all if all or none are flagged
+               home_all = true LINEAR_AXIS_GANG(&& homeX == homeX, && homeX == homeY, && homeX == homeZ),
+               LINEAR_AXIS_LIST(doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ);
+
+   UNUSED(needZ);
+   UNUSED(homeZZ);
 
     #if ENABLED(HOME_Z_FIRST)
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
-    if (z_homing_height && (doX || doY || TERN0(Z_SAFE_HOMING, doZ))) {
+    if (z_homing_height && (0 LINEAR_AXIS_GANG(|| doX, || doY, || TERN0(Z_SAFE_HOMING, doZ)))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
       TERN_(BLTOUCH, bltouch.init());
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
@@ -462,39 +473,39 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
-  #endif
+  #endif // HAS_HOMING_CURRENT
 
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
-      E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
+      E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
     };
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
       const uint8_t cv = L64XX::chain[j];
       L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L64XX_axis_xref[cv]));
     }
   #endif
 }

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    🎨 Flags for homing directions

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 23eafe4bb6..aacfcfa42f 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -66,21 +66,21 @@
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position.set(0.0, 0.0);
     sync_plan_position();
 
-    const int x_axis_home_dir = x_home_dir(active_extruder);
+    const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
           tmc_enable_stallguard(stepperX)
         , tmc_enable_stallguard(stepperY)

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ♻️ Refactor axis counts and loops

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 92bbb8e6c5..23eafe4bb6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -213,21 +213,21 @@ void GcodeSuite::G28() {
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_HOMING));
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen_test('S')) {
-      LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
+      LOOP_LINEAR_AXES(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 10e094cba7..92bbb8e6c5 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -212,21 +212,21 @@ void GcodeSuite::G28() {
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
   TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_HOMING));
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
-    if (parser.seen('S')) {
+    if (parser.seen_test('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!axes_should_home() && parser.boolval('O')) {
@@ -314,24 +314,24 @@ void GcodeSuite::G28() {
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
   #elif ENABLED(AXEL_TPARA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
 
     home_TPARA();
 
   #else
 
-    const bool homeZ = parser.seen('Z'),
+    const bool homeZ = parser.seen_test('Z'),
                needX = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(X_AXIS))),
                needY = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(Y_AXIS))),
-               homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
+               homeX = needX || parser.seen_test('X'), homeY = needY || parser.seen_test('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if ENABLED(HOME_Z_FIRST)
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 73bfc3bdc6..10e094cba7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -204,20 +204,22 @@
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_HOMING));
+
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
@@ -472,20 +474,22 @@ void GcodeSuite::G28() {
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
+
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
       E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
     };
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {

commit e989bf3b0ed79156c094f6e298b5ff326a53e3fb
Author: espr14 <espr14@gmail.com>
Date:   Thu Mar 25 04:39:29 2021 +0100

    Endstops always on in G28 (#21441)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 9470678872..73bfc3bdc6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -95,21 +95,21 @@
           #endif
       };
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * Y_HOME_DIR, fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position.set(0.0, 0.0);
 
-    #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(SENSORLESS_HOMING) && DISABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
     #endif
   }

commit a46e0257252bcd50f4c7acb04215f3ad2a92047c
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Mar 3 20:46:32 2021 -0300

    TPARA - 3DOF robot arm IK (#21005)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 430daf6ba2..9470678872 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -304,21 +304,27 @@ void GcodeSuite::G28() {
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
-  #else // NOT DELTA
+  #elif ENABLED(AXEL_TPARA)
+
+    constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a TPARA
+
+    home_TPARA();
+
+  #else
 
     const bool homeZ = parser.seen('Z'),
                needX = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(X_AXIS))),
                needY = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(Y_AXIS))),
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if ENABLED(HOME_Z_FIRST)
 
@@ -385,21 +391,21 @@ void GcodeSuite::G28() {
           stepper.set_separate_multi_axis(false);
         #endif
 
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
         probe.move_z_after_homing();
       }
     #endif
 
     sync_plan_position();
 
-  #endif // !DELTA (G28)
+  #endif
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
     if (idex_is_duplicating()) {

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a2de1dfe38..430daf6ba2 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -252,21 +252,21 @@ void GcodeSuite::G28() {
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
-      serialprintPGM(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
+      DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X2"), tmc_save_current_X2, X2_CURRENT_HOME);

commit 7a1ec7856361790ec5a76d70698ace798dfa43b5
Author: ldursw <37294448+ldursw@users.noreply.github.com>
Date:   Fri Feb 26 20:01:11 2021 -0300

    Init (stow) BLTouch before X/Y homing (#21192)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c26340f1ab..a2de1dfe38 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -325,20 +325,21 @@ void GcodeSuite::G28() {
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
     if (z_homing_height && (doX || doY || TERN0(Z_SAFE_HOMING, doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height);
+      TERN_(BLTOUCH, bltouch.init());
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
@@ -377,21 +378,20 @@ void GcodeSuite::G28() {
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
     #if DISABLED(HOME_Z_FIRST)
       if (doZ) {
         #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
           stepper.set_all_z_lock(false);
           stepper.set_separate_multi_axis(false);
         #endif
 
-        TERN_(BLTOUCH, bltouch.init());
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
         probe.move_z_after_homing();
       }
     #endif
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**

commit bcda46e3f3435a1f87d224be2f81778c1855deb7
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Feb 25 17:09:00 2021 +0100

    Combine Z_AFTER_DEACTIVATE with UNKNOWN_Z_NO_RAISE (#20444)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 12f85f7054..c26340f1ab 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -319,28 +319,26 @@ void GcodeSuite::G28() {
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if ENABLED(HOME_Z_FIRST)
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
-    const float z_homing_height = TERN1(UNKNOWN_Z_NO_RAISE, axis_is_trusted(Z_AXIS))
-                                  ? (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
-                                  : 0;
+    const float z_homing_height = parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT;
 
     if (z_homing_height && (doX || doY || TERN0(Z_SAFE_HOMING, doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
-      do_z_clearance(z_homing_height, axis_is_trusted(Z_AXIS), DISABLED(UNKNOWN_Z_NO_RAISE));
+      do_z_clearance(z_homing_height);
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))

commit 7e172bf456ea52ce1a4206d1184e18745515039d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 16 21:13:53 2021 -0600

    Fix IDEX broken endstop test (#21110)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2de029a08b..12f85f7054 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -89,21 +89,21 @@
           #if AXIS_HAS_STALLGUARD(X2)
             || tmc_enable_stallguard(stepperX2)
           #endif
         , false
           #if AXIS_HAS_STALLGUARD(Y2)
             || tmc_enable_stallguard(stepperY2)
           #endif
       };
     #endif
 
-    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
+    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * Y_HOME_DIR, fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position.set(0.0, 0.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);

commit 1b19eed195cbfe182a7c6c357603eb08c011123d
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Sun Jan 17 07:08:48 2021 +0200

    Fix Tramming Wizard behavior (#20796)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7c13587a67..2de029a08b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -234,21 +234,21 @@ void GcodeSuite::G28() {
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
-    IF_ENABLED(RESTORE_LEVELING_AFTER_G28, const bool leveling_restore_state = planner.leveling_active);
+    const bool leveling_restore_state = parser.boolval('L', TERN(RESTORE_LEVELING_AFTER_G28, planner.leveling_active, ENABLED(ENABLE_LEVELING_AFTER_G28)));
     IF_ENABLED(PROBE_MANUALLY, g29_in_progress = false); // Cancel the active G29 session
     set_bed_leveling_enabled(false);
   #endif
 
   // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
@@ -433,22 +433,21 @@ void GcodeSuite::G28() {
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  IF_ENABLED(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_restore_state));
-  IF_ENABLED(ENABLE_LEVELING_AFTER_G28, set_bed_leveling_enabled(true));
+  TERN_(HAS_LEVELING, set_bed_leveling_enabled(leveling_restore_state));
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");

commit 815c636449e399651ee0751b63ed36f2d28415e0
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Fri Jan 1 22:54:44 2021 +0200

    Fix PARKING_EXTRUDER homing with solenoid (#20473)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e63f60994f..7c13587a67 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -283,20 +283,24 @@ void GcodeSuite::G28() {
     #endif
   #endif
 
   TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing_t slow_homing = begin_slow_homing());
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
+    // PARKING_EXTRUDER homing requires different handling of movement / solenoid activation, depending on the side of homing
+    #if ENABLED(PARKING_EXTRUDER)
+      const bool pe_final_change_must_unpark = parking_extruder_unpark_after_homing(old_tool_index, X_HOME_DIR + 1 == old_tool_index * 2);
+    #endif
     tool_change(0, true);
   #endif
 
   TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
@@ -436,21 +440,21 @@ void GcodeSuite::G28() {
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   IF_ENABLED(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_restore_state));
   IF_ENABLED(ENABLE_LEVELING_AFTER_G28, set_bed_leveling_enabled(true));
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
+    tool_change(old_tool_index, TERN(PARKING_EXTRUDER, !pe_final_change_must_unpark, DISABLED(DUAL_X_CARRIAGE)));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
       stepperX.rms_current(tmc_save_current_X);
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif

commit 198b3ae0f81f9524479741161ba88306766c3e6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:26:18 2020 -0600

    Fix some comments

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3d739c7ce8..e63f60994f 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -239,20 +239,21 @@ void GcodeSuite::G28() {
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     IF_ENABLED(RESTORE_LEVELING_AFTER_G28, const bool leveling_restore_state = planner.leveling_active);
     IF_ENABLED(PROBE_MANUALLY, g29_in_progress = false); // Cancel the active G29 session
     set_bed_leveling_enabled(false);
   #endif
 
+  // Reset to the XY plane
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
     #define HAS_HOMING_CURRENT 1
   #endif
 

commit c559fc82271e1c609b7f0211ce1075c4a1eac815
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Dec 22 14:01:24 2020 +0100

    Fix G28 leveling state, UBL compile (#20499)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 57c21df765..3d739c7ce8 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -234,22 +234,22 @@ void GcodeSuite::G28() {
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
-    const bool leveling_restore_state = ENABLED(ENABLE_LEVELING_AFTER_G28) || TERN0(RESTORE_LEVELING_AFTER_G28, planner.leveling_active);
-    TERN_(PROBE_MANUALLY, g29_in_progress = false);  // Cancel the active G29 session
+    IF_ENABLED(RESTORE_LEVELING_AFTER_G28, const bool leveling_restore_state = planner.leveling_active);
+    IF_ENABLED(PROBE_MANUALLY, g29_in_progress = false); // Cancel the active G29 session
     set_bed_leveling_enabled(false);
   #endif
 
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
@@ -428,21 +428,22 @@ void GcodeSuite::G28() {
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_restore_state));
+  IF_ENABLED(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_restore_state));
+  IF_ENABLED(ENABLE_LEVELING_AFTER_G28, set_bed_leveling_enabled(true));
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");

commit 7afd274d0ce9c7149c3edf3bd23aadd28154ccfb
Author: Dick Streefland <dick@streefland.net>
Date:   Mon Dec 21 08:49:00 2020 +0100

    Apply HOME_AFTER_DEACTIVATE for 'G28 O' (#20525)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 23c4d56d93..57c21df765 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -220,21 +220,21 @@ void GcodeSuite::G28() {
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
-  if (!homing_needed() && parser.boolval('O')) {
+  if (!axes_should_home() && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state

commit 1be16e3d8c44965f2e3f58b2845f9ac8ecdbc74b
Author: JoAnn Manges <joannmanges@gmail.com>
Date:   Tue Dec 15 01:16:50 2020 -0500

    Fix RESTORE_LEVELING_AFTER_G28 (#20471)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 092d8d643a..23c4d56d93 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -428,21 +428,21 @@ void GcodeSuite::G28() {
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_was_active));
+  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_restore_state));
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");

commit 80bde7b6b52a752a3f9b7cd925bbde4a0525c875
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 20:10:13 2020 -0600

    Always enable leveling after G28

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f54b2fb7d4..092d8d643a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -234,21 +234,21 @@ void GcodeSuite::G28() {
 
   TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
 
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
-    TERN_(RESTORE_LEVELING_AFTER_G28, const bool leveling_was_active = planner.leveling_active);
+    const bool leveling_restore_state = ENABLED(ENABLE_LEVELING_AFTER_G28) || TERN0(RESTORE_LEVELING_AFTER_G28, planner.leveling_active);
     TERN_(PROBE_MANUALLY, g29_in_progress = false);  // Cancel the active G29 session
     set_bed_leveling_enabled(false);
   #endif
 
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)

commit 6f4589b375e8adba2c110dbd5d1ec5e80a9204ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 23:05:03 2020 -0600

    G28 followup

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e2b0860eef..f54b2fb7d4 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -428,20 +428,22 @@ void GcodeSuite::G28() {
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
+  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_was_active));
+
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
@@ -451,22 +453,20 @@ void GcodeSuite::G28() {
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
-  TERN_(HAS_LEVELING, set_bed_leveling_enabled(leveling_restore_state));
-
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 

commit 139a33c9fc864b3d2546398e3366a49a0433865b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 19:14:15 2020 -0600

    G28 tweaks

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 31fc1e1cf2..e2b0860eef 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -204,24 +204,20 @@
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
-  TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
-
-  TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
-
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
@@ -229,31 +225,31 @@ void GcodeSuite::G28() {
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!homing_needed() && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
+  TERN_(DWIN_CREALITY_LCD, DWIN_StartHoming());
+  TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
+
   planner.synchronize();          // Wait for planner moves to finish!
 
   SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
-
-    // Cancel the active G29 session
-    TERN_(PROBE_MANUALLY, g29_in_progress = false);
-
     TERN_(RESTORE_LEVELING_AFTER_G28, const bool leveling_was_active = planner.leveling_active);
+    TERN_(PROBE_MANUALLY, g29_in_progress = false);  // Cancel the active G29 session
     set_bed_leveling_enabled(false);
   #endif
 
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   // Count this command as movement / activity
   reset_stepper_timeout();
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
@@ -432,22 +428,20 @@ void GcodeSuite::G28() {
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_was_active));
-
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
@@ -457,24 +451,25 @@ void GcodeSuite::G28() {
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
+  TERN_(HAS_LEVELING, set_bed_leveling_enabled(leveling_restore_state));
+
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
-
   TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.

commit 889695b6ba54ec56ca7ed7fd50d597c29a854687
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 5 16:45:22 2020 -0600

    ExtUI homing / leveling additions

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c17d6dcc8b..31fc1e1cf2 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -43,20 +43,24 @@
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/marlinui.h"
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/dwin/e3v2/dwin.h"
 #endif
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../lcd/extui/ui_api.h"
+#endif
+
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
@@ -202,20 +206,22 @@
  *  Z   Home to the Z endstop
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
   TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
 
+  TERN_(EXTENSIBLE_UI, ExtUI::onHomingStart());
+
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
@@ -455,20 +461,22 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
 
+  TERN_(EXTENSIBLE_UI, ExtUI::onHomingComplete());
+
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c4effe7d58..c17d6dcc8b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -312,29 +312,28 @@ void GcodeSuite::G28() {
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if ENABLED(HOME_Z_FIRST)
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
-    const float z_homing_height =
-      ENABLED(UNKNOWN_Z_NO_RAISE) && !TEST(axis_known_position, Z_AXIS)
-        ? 0
-        : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
+    const float z_homing_height = TERN1(UNKNOWN_Z_NO_RAISE, axis_is_trusted(Z_AXIS))
+                                  ? (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
+                                  : 0;
 
     if (z_homing_height && (doX || doY || TERN0(Z_SAFE_HOMING, doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
-      do_z_clearance(z_homing_height, true, DISABLED(UNKNOWN_Z_NO_RAISE));
+      do_z_clearance(z_homing_height, axis_is_trusted(Z_AXIS), DISABLED(UNKNOWN_Z_NO_RAISE));
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))

commit 649965ae32eca5140ea66d1265a69576e2a2c669
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Nov 26 04:38:00 2020 +0100

    Probe Offset Wizard improvements (#20239)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c0bc179869..c4effe7d58 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -317,34 +317,34 @@ void GcodeSuite::G28() {
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height =
       ENABLED(UNKNOWN_Z_NO_RAISE) && !TEST(axis_known_position, Z_AXIS)
         ? 0
         : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
 
-    if (z_homing_height && (doX || doY || (ENABLED(Z_SAFE_HOMING) && doZ))) {
+    if (z_homing_height && (doX || doY || TERN0(Z_SAFE_HOMING, doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height, true, DISABLED(UNKNOWN_Z_NO_RAISE));
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
-    if (ENABLED(HOME_Y_BEFORE_X) && (doY || (ENABLED(CODEPENDENT_XY_HOMING) && doX)))
+    if (ENABLED(HOME_Y_BEFORE_X) && (doY || TERN0(CODEPENDENT_XY_HOMING, doX)))
       homeaxis(Y_AXIS);
 
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);

commit 1b0a5abd73d162b68b2881486630f60a1e9e7825
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Nov 12 23:54:18 2020 -0500

    G34 Z stepper locking (#20091)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ef39290d2d..c0bc179869 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -368,20 +368,25 @@ void GcodeSuite::G28() {
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
     #if DISABLED(HOME_Z_FIRST)
       if (doZ) {
+        #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+          stepper.set_all_z_lock(false);
+          stepper.set_separate_multi_axis(false);
+        #endif
+
         TERN_(BLTOUCH, bltouch.init());
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
         probe.move_z_after_homing();
       }
     #endif
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 

commit 2282801172abdbce0b26b993d8d3be9ab4ae3649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 11 16:58:34 2020 -0600

    Add HOME_Z_FIRST option (#20113)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a91dd82a2a..ef39290d2d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -306,21 +306,21 @@ void GcodeSuite::G28() {
 
   #else // NOT DELTA
 
     const bool homeZ = parser.seen('Z'),
                needX = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(X_AXIS))),
                needY = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(Y_AXIS))),
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
-    #if Z_HOME_DIR > 0  // If homing away from BED do Z first
+    #if ENABLED(HOME_Z_FIRST)
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height =
       ENABLED(UNKNOWN_Z_NO_RAISE) && !TEST(axis_known_position, Z_AXIS)
         ? 0
         : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
 
@@ -366,32 +366,27 @@ void GcodeSuite::G28() {
       #endif
     }
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
-    #if Z_HOME_DIR < 0
-
+    #if DISABLED(HOME_Z_FIRST)
       if (doZ) {
         TERN_(BLTOUCH, bltouch.init());
-
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
-
         probe.move_z_after_homing();
-
-      } // doZ
-
-    #endif // Z_HOME_DIR < 0
+      }
+    #endif
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.

commit 6375829448eebe01b2835689aac69b73b63ebfd8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 18 16:53:12 2020 -0400

    Apply home offsets to probing, Z Safe Homing (#19423)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 06b9fee257..a91dd82a2a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -119,21 +119,29 @@
 
     // Disallow Z homing if X or Y homing is needed
     if (homing_needed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
-    destination.set(safe_homing_xy, current_position.z);
+    constexpr xy_float_t safe_homing_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
+    #if HAS_HOME_OFFSET
+      xy_float_t okay_homing_xy = safe_homing_xy;
+      okay_homing_xy -= home_offset;
+    #else
+      constexpr xy_float_t okay_homing_xy = safe_homing_xy;
+    #endif
+
+    destination.set(okay_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // Free the active extruder for movement
       TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
 

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index bccbb9bd16..06b9fee257 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -38,21 +38,21 @@
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
-#include "../../lcd/ultralcd.h"
+#include "../../lcd/marlinui.h"
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3420956803..bccbb9bd16 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -127,22 +127,22 @@
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
-      // This causes the carriage on Dual X to unpark
-      TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
+      // Free the active extruder for movement
+      TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
 
       TERN_(SENSORLESS_HOMING, safe_delay(500)); // Short delay needed to settle
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
@@ -275,21 +275,21 @@ void GcodeSuite::G28() {
   TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing_t slow_homing = begin_slow_homing());
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
-  TERN_(HAS_DUPLICATION_MODE, extruder_duplication_enabled = false);
+  TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
@@ -335,30 +335,28 @@ void GcodeSuite::G28() {
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 
         // Remember this extruder's position for later tool change
-        inactive_extruder_x_pos = current_position.x;
+        inactive_extruder_x = current_position.x;
 
         // Home the 1st (left) extruder
         active_extruder = 0;
         homeaxis(X_AXIS);
 
-        // Consider the active extruder to be parked
-        raised_parked_position = current_position;
-        delayed_move_time = 0;
-        active_extruder_parked = true;
+        // Consider the active extruder to be in its "parked" position
+        idex_set_parked();
 
       #else
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
@@ -385,42 +383,40 @@ void GcodeSuite::G28() {
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
-    if (dxc_is_duplicating()) {
+    if (idex_is_duplicating()) {
 
       TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing = begin_slow_homing());
 
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
-      inactive_extruder_x_pos = current_position.x;
+      inactive_extruder_x = current_position.x;
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
-      raised_parked_position = current_position;
-      delayed_move_time = 0;
-      active_extruder_parked = true;
-      extruder_duplication_enabled = IDEX_saved_duplication_state;
-      dual_x_carriage_mode         = IDEX_saved_mode;
-      stepper.set_directions();
+      idex_set_parked();
+
+      dual_x_carriage_mode = IDEX_saved_mode;
+      set_duplication_enabled(IDEX_saved_duplication_state);
 
       TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7bc40b2127..3420956803 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -215,22 +215,23 @@ void GcodeSuite::G28() {
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!homing_needed() && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
-  // Wait for planner moves to finish!
-  planner.synchronize();
+  planner.synchronize();          // Wait for planner moves to finish!
+
+  SET_SOFT_ENDSTOP_LOOSE(false);  // Reset a leftover 'loose' motion state
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
     TERN_(PROBE_MANUALLY, g29_in_progress = false);
 
     TERN_(RESTORE_LEVELING_AFTER_G28, const bool leveling_was_active = planner.leveling_active);
     set_bed_leveling_enabled(false);
   #endif

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index be222a7b17..7bc40b2127 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -185,21 +185,20 @@
  *
  *  O   Home only if position is unknown
  *
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
- *
  */
 void GcodeSuite::G28() {
   DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
   TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
   TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
 
   #if ENABLED(DUAL_X_CARRIAGE)

commit a445746a8b6dd752de725eb67d264153c3b393d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 6 21:40:58 2020 -0500

    Clean up LCD conditionals, DWIN

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 0e1f707898..be222a7b17 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -40,21 +40,21 @@
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../../lcd/dwin/dwin.h"
+  #include "../../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif
 

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 78695bc05b..0e1f707898 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -111,21 +111,21 @@
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
     DEBUG_SECTION(log_G28, "home_z_safely", DEBUGGING(LEVELING));
 
     // Disallow Z homing if X or Y homing is needed
-    if (axis_unhomed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
+    if (homing_needed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
@@ -292,22 +292,22 @@ void GcodeSuite::G28() {
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
   #else // NOT DELTA
 
     const bool homeZ = parser.seen('Z'),
-               needX = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(X_AXIS))),
-               needY = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(Y_AXIS))),
+               needX = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(X_AXIS))),
+               needY = homeZ && TERN0(Z_SAFE_HOMING, axes_should_home(_BV(Y_AXIS))),
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 

commit 73ce80af3a3f8415a7c3f7f5551b429d58019a05
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 29 20:50:10 2020 -0500

    In G28 Z is sort-of known

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 0b2bb9801b..78695bc05b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -312,21 +312,21 @@ void GcodeSuite::G28() {
     #endif
 
     const float z_homing_height =
       ENABLED(UNKNOWN_Z_NO_RAISE) && !TEST(axis_known_position, Z_AXIS)
         ? 0
         : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
 
     if (z_homing_height && (doX || doY || (ENABLED(Z_SAFE_HOMING) && doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
-      do_z_clearance(z_homing_height, TEST(axis_known_position, Z_AXIS), DISABLED(UNKNOWN_Z_NO_RAISE));
+      do_z_clearance(z_homing_height, true, DISABLED(UNKNOWN_Z_NO_RAISE));
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || (ENABLED(CODEPENDENT_XY_HOMING) && doX)))

commit 95f990a656faefe071eabac107c1ffa012598710
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 29 20:43:35 2020 -0500

    Fix UNKNOWN_Z_NO_RAISE in G28
    
    Bug introduced in 73fc0778b86

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 1fbb3dd353..0b2bb9801b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -305,21 +305,21 @@ void GcodeSuite::G28() {
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height =
-      ENABLED(UNKNOWN_Z_NO_RAISE) && TEST(axis_known_position, Z_AXIS)
+      ENABLED(UNKNOWN_Z_NO_RAISE) && !TEST(axis_known_position, Z_AXIS)
         ? 0
         : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
 
     if (z_homing_height && (doX || doY || (ENABLED(Z_SAFE_HOMING) && doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
       do_z_clearance(z_homing_height, TEST(axis_known_position, Z_AXIS), DISABLED(UNKNOWN_Z_NO_RAISE));
     }
 
     #if ENABLED(QUICK_HOME)

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 5ec8fd5af4..1fbb3dd353 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #include "../gcode.h"
 
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b97caa96e3..5ec8fd5af4 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -108,25 +108,25 @@
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
+    DEBUG_SECTION(log_G28, "home_z_safely", DEBUGGING(LEVELING));
+
     // Disallow Z homing if X or Y homing is needed
     if (axis_unhomed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
-
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
     TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 
@@ -139,22 +139,20 @@
 
       TERN_(SENSORLESS_HOMING, safe_delay(500)); // Short delay needed to settle
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
-
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
 #endif // Z_SAFE_HOMING
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
 
   slow_homing_t begin_slow_homing() {
     slow_homing_t slow_homing{0};
     slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
                                  planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
@@ -190,51 +188,45 @@
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28() {
+  DEBUG_SECTION(log_G28, "G28", DEBUGGING(LEVELING));
+  if (DEBUGGING(LEVELING)) log_machine_info();
 
-  if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOLNPGM(">>> G28");
-    log_machine_info();
-  }
-
-  #if ENABLED(LASER_MOVE_G28_OFF)
-    cutter.set_inline_enabled(false);       // turn off laser
-  #endif
+  TERN_(LASER_MOVE_G28_OFF, cutter.set_inline_enabled(false));  // turn off laser
 
   TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
       return;
     }
   #endif
 
   // Home (O)nly if position is unknown
   if (!homing_needed() && parser.boolval('O')) {
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip\n<<< G28");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip");
     return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
@@ -306,40 +298,35 @@ void GcodeSuite::G28() {
 
   #else // NOT DELTA
 
     const bool homeZ = parser.seen('Z'),
                needX = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(X_AXIS))),
                needY = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(Y_AXIS))),
                homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
-    destination = current_position;
-
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height =
-      (DISABLED(UNKNOWN_Z_NO_RAISE) || TEST(axis_known_position, Z_AXIS))
-        ? (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
-        : 0;
+      ENABLED(UNKNOWN_Z_NO_RAISE) && TEST(axis_known_position, Z_AXIS)
+        ? 0
+        : (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT);
 
-    if (z_homing_height && (doX || doY || ENABLED(Z_SAFE_HOMING))) {
+    if (z_homing_height && (doX || doY || (ENABLED(Z_SAFE_HOMING) && doZ))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      destination.z = z_homing_height + (TEST(axis_known_position, Z_AXIS) ? 0.0f : current_position.z);
-      if (destination.z > current_position.z) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination.z);
-        do_blocking_move_to_z(destination.z);
-      }
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) by ", z_homing_height);
+      do_z_clearance(z_homing_height, TEST(axis_known_position, Z_AXIS), DISABLED(UNKNOWN_Z_NO_RAISE));
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     if (ENABLED(HOME_Y_BEFORE_X) && (doY || (ENABLED(CODEPENDENT_XY_HOMING) && doX)))
@@ -380,29 +367,21 @@ void GcodeSuite::G28() {
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
 
       if (doZ) {
         TERN_(BLTOUCH, bltouch.init());
 
         TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
 
-        #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
-          #if Z_AFTER_HOMING > Z_AFTER_PROBING
-            do_blocking_move_to_z(Z_AFTER_HOMING);
-          #else
-            probe.move_z_after_probing();
-          #endif
-        #elif defined(Z_AFTER_HOMING)
-          do_blocking_move_to_z(Z_AFTER_HOMING);
-        #endif
+        probe.move_z_after_homing();
 
       } // doZ
 
     #endif // Z_HOME_DIR < 0
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**
@@ -478,22 +457,20 @@ void GcodeSuite::G28() {
 
   ui.refresh();
 
   TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
 
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
-
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
       E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
     };
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {

commit a6b8b12a6a001a25dc73e8ab08f71e357ea58e48
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 5 18:00:37 2020 -0500

    Simplify home_z_safely, respect HOME_AFTER_DEACTIVATE

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 806a8d50d6..b97caa96e3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -108,27 +108,22 @@
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
-
-    // Disallow Z homing if X or Y are unknown
-    if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
-      LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
-      SERIAL_ECHO_MSG(STR_ERR_Z_HOMING_SER);
-      return;
-    }
+    // Disallow Z homing if X or Y homing is needed
+    if (axis_unhomed_error(_BV(X_AXIS) | _BV(Y_AXIS))) return;
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);

commit c43bbcce152b4d3b4697e1e188d3bcada76a24a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:27:28 2020 -0500

    Enforce sensor range for temperature target (#18465)
    
    * Mitigate stepper timeout
    
    * Add CHAMBER PWM code
    
    * Structured thermistor tables
    
    * Fix reversed sensor ranges
    
    * Prevent temps outside sensor range

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 982c9e9d3c..806a8d50d6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -196,29 +196,29 @@
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28() {
 
-#if ENABLED(LASER_MOVE_G28_OFF)
-  cutter.set_inline_enabled(false);       // turn off laser
-#endif
-
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(">>> G28");
     log_machine_info();
   }
 
+  #if ENABLED(LASER_MOVE_G28_OFF)
+    cutter.set_inline_enabled(false);       // turn off laser
+  #endif
+
   TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
@@ -244,20 +244,23 @@ void GcodeSuite::G28() {
 
     // Cancel the active G29 session
     TERN_(PROBE_MANUALLY, g29_in_progress = false);
 
     TERN_(RESTORE_LEVELING_AFTER_G28, const bool leveling_was_active = planner.leveling_active);
     set_bed_leveling_enabled(false);
   #endif
 
   TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
+  // Count this command as movement / activity
+  reset_stepper_timeout();
+
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
     #define HAS_HOMING_CURRENT 1
   #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
       serialprintPGM(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)

commit f4c258dc2355fee871bec6e11095c7c4777b160d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 16 01:45:27 2020 -0500

    Creality Ender 3 v2 (#17719)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8720b1a929..982c9e9d3c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -39,20 +39,23 @@
   #include "../../feature/tmc_util.h"
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../../lcd/dwin/dwin.h"
+#endif
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   #include "../../feature/spindle_laser.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
@@ -202,20 +205,22 @@ void GcodeSuite::G28() {
 
 #if ENABLED(LASER_MOVE_G28_OFF)
   cutter.set_inline_enabled(false);       // turn off laser
 #endif
 
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(">>> G28");
     log_machine_info();
   }
 
+  TERN_(DWIN_CREALITY_LCD, HMI_flag.home_flag = true);
+
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
@@ -468,20 +473,22 @@ void GcodeSuite::G28() {
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
   ui.refresh();
 
+  TERN_(DWIN_CREALITY_LCD, DWIN_CompletedHoming());
+
   report_current_position();
 
   if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
     SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.

commit eda2fd8dbea69cb8f571f2992cb11334b2cb7a2f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 00:47:31 2020 -0500

    Improvements for Laser / Spindle (#17661)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3f41f076b5..8720b1a929 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -44,20 +44,24 @@
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if HAS_L64XX                         // set L6470 absolute position registers to counts
   #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
+#if ENABLED(LASER_MOVE_G28_OFF)
+  #include "../../feature/spindle_laser.h"
+#endif
+
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position.set(0.0, 0.0);
     sync_plan_position();
@@ -188,20 +192,25 @@
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28() {
+
+#if ENABLED(LASER_MOVE_G28_OFF)
+  cutter.set_inline_enabled(false);       // turn off laser
+#endif
+
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(">>> G28");
     log_machine_info();
   }
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 

commit 5f9624f70b78fecd7f2f27318b01578bcd038a06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 2 19:12:08 2020 -0500

    Ensure XY known for Z safe homing
    
    Addressing #18143

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index bd847658ca..3f41f076b5 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -287,21 +287,24 @@ void GcodeSuite::G28() {
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
   #else // NOT DELTA
 
-    const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
+    const bool homeZ = parser.seen('Z'),
+               needX = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(X_AXIS))),
+               needY = homeZ && TERN0(Z_SAFE_HOMING, axes_need_homing(_BV(Y_AXIS))),
+               homeX = needX || parser.seen('X'), homeY = needY || parser.seen('Y'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif

commit 7628895ac861460bdc6b916e32de8e6a32bb738d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 18 13:58:11 2020 -0500

    Apply misc TERN

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e44d94fc55..bd847658ca 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -362,25 +362,22 @@ void GcodeSuite::G28() {
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
     TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
 
       if (doZ) {
         TERN_(BLTOUCH, bltouch.init());
-        #if ENABLED(Z_SAFE_HOMING)
-          home_z_safely();
-        #else
-          homeaxis(Z_AXIS);
-        #endif
+
+        TERN(Z_SAFE_HOMING, home_z_safely(), homeaxis(Z_AXIS));
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           #if Z_AFTER_HOMING > Z_AFTER_PROBING
             do_blocking_move_to_z(Z_AFTER_HOMING);
           #else
             probe.move_z_after_probing();
           #endif
         #elif defined(Z_AFTER_HOMING)
           do_blocking_move_to_z(Z_AFTER_HOMING);
         #endif

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8c699b5fd3..e44d94fc55 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -119,36 +119,30 @@
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
-    #if HOMING_Z_WITH_PROBE
-      destination -= probe.offset_xy;
-    #endif
+    TERN_(HOMING_Z_WITH_PROBE, destination -= probe.offset_xy);
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
-      #if ENABLED(DUAL_X_CARRIAGE)
-        active_extruder_parked = false;
-      #endif
+      TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
 
-      #if ENABLED(SENSORLESS_HOMING)
-        safe_delay(500); // Short delay needed to settle
-      #endif
+      TERN_(SENSORLESS_HOMING, safe_delay(500)); // Short delay needed to settle
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
@@ -168,23 +162,21 @@
       slow_homing.jerk_xy = planner.max_jerk;
       planner.max_jerk.set(0, 0);
     #endif
     planner.reset_acceleration_rates();
     return slow_homing;
   }
 
   void end_slow_homing(const slow_homing_t &slow_homing) {
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
-    #if HAS_CLASSIC_JERK
-      planner.max_jerk = slow_homing.jerk_xy;
-    #endif
+    TERN_(HAS_CLASSIC_JERK, planner.max_jerk = slow_homing.jerk_xy);
     planner.reset_acceleration_rates();
   }
 
 #endif // IMPROVE_HOMING_RELIABILITY
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
@@ -230,36 +222,32 @@ void GcodeSuite::G28() {
     return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
-    #if ENABLED(PROBE_MANUALLY)
-      g29_in_progress = false;
-    #endif
+    TERN_(PROBE_MANUALLY, g29_in_progress = false);
 
-    #if ENABLED(RESTORE_LEVELING_AFTER_G28)
-      const bool leveling_was_active = planner.leveling_active;
-    #endif
+    TERN_(RESTORE_LEVELING_AFTER_G28, const bool leveling_was_active = planner.leveling_active);
     set_bed_leveling_enabled(false);
   #endif
 
-  #if ENABLED(CNC_WORKSPACE_PLANES)
-    workspace_plane = PLANE_XY;
-  #endif
+  TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-  #define HAS_HOMING_CURRENT (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2))
+  #if HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2)
+    #define HAS_HOMING_CURRENT 1
+  #endif
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
       serialprintPGM(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
@@ -273,49 +261,43 @@ void GcodeSuite::G28() {
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
-  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-    slow_homing_t slow_homing = begin_slow_homing();
-  #endif
+  TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing_t slow_homing = begin_slow_homing());
 
   // Always home with tool 0 active
   #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
-  #if HAS_DUPLICATION_MODE
-    extruder_duplication_enabled = false;
-  #endif
+  TERN_(HAS_DUPLICATION_MODE, extruder_duplication_enabled = false);
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
 
     home_delta();
 
-    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-      end_slow_homing(slow_homing);
-    #endif
+    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
@@ -373,31 +355,27 @@ void GcodeSuite::G28() {
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     if (DISABLED(HOME_Y_BEFORE_X) && doY)
       homeaxis(Y_AXIS);
 
-    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-      end_slow_homing(slow_homing);
-    #endif
+    TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
 
       if (doZ) {
-        #if ENABLED(BLTOUCH)
-          bltouch.init();
-        #endif
+        TERN_(BLTOUCH, bltouch.init());
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           #if Z_AFTER_HOMING > Z_AFTER_PROBING
             do_blocking_move_to_z(Z_AFTER_HOMING);
           #else
@@ -418,65 +396,57 @@ void GcodeSuite::G28() {
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
     if (dxc_is_duplicating()) {
 
-      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-        slow_homing = begin_slow_homing();
-      #endif
+      TERN_(IMPROVE_HOMING_RELIABILITY, slow_homing = begin_slow_homing());
 
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
       inactive_extruder_x_pos = current_position.x;
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
       raised_parked_position = current_position;
       delayed_move_time = 0;
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
 
-      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-        end_slow_homing(slow_homing);
-      #endif
+      TERN_(IMPROVE_HOMING_RELIABILITY, end_slow_homing(slow_homing));
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
-  #if ENABLED(SPI_ENDSTOPS)
-    endstops.clear_endstop_state();
-  #endif
+  TERN_(SPI_ENDSTOPS, endstops.clear_endstop_state());
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  #if ENABLED(RESTORE_LEVELING_AFTER_G28)
-    set_bed_leveling_enabled(leveling_was_active);
-  #endif
+  TERN_(RESTORE_LEVELING_AFTER_G28, set_bed_leveling_enabled(leveling_was_active));
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3437e33942..8c699b5fd3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -20,21 +20,21 @@
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #include "../gcode.h"
 
 #include "../../module/stepper.h"
 #include "../../module/endstops.h"
 
-#if HOTENDS > 1
+#if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
@@ -278,21 +278,21 @@ void GcodeSuite::G28() {
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
-  #if HOTENDS > 1
+  #if HAS_MULTI_HOTEND
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
   #endif
 
@@ -467,21 +467,21 @@ void GcodeSuite::G28() {
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
-  #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
+  #if HAS_MULTI_HOTEND && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
       stepperX.rms_current(tmc_save_current_X);
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);

commit ac7b484703fc04afb3232f997b76e64959d8ba9b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 12 14:58:47 2020 -0500

    Safe homing: Raise Z on G28 Z (#17501)
    
    Co-Authored-By: RFBomb <robbery525@gmail.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index fafce9a896..3437e33942 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -322,21 +322,21 @@ void GcodeSuite::G28() {
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height =
       (DISABLED(UNKNOWN_Z_NO_RAISE) || TEST(axis_known_position, Z_AXIS))
         ? (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
         : 0;
 
-    if (z_homing_height && (doX || doY)) {
+    if (z_homing_height && (doX || doY || ENABLED(Z_SAFE_HOMING))) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination.z = z_homing_height + (TEST(axis_known_position, Z_AXIS) ? 0.0f : current_position.z);
       if (destination.z > current_position.z) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination.z);
         do_blocking_move_to_z(destination.z);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 

commit 53fe572bbdfe4d51e420f6d002197cee533e17fd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 27 22:00:27 2020 -0500

    Limited backlash editing with Core kinematics (#17281)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4603c76967..fafce9a896 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -248,42 +248,42 @@ void GcodeSuite::G28() {
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #define HAS_HOMING_CURRENT (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2))
 
   #if HAS_HOMING_CURRENT
-    auto debug_current = [](const char * const s, const int16_t a, const int16_t b){
-      DEBUG_ECHO(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
+    auto debug_current = [](PGM_P const s, const int16_t a, const int16_t b){
+      serialprintPGM(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current("X", tmc_save_current_X, X_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(PSTR("X"), tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current("X2", tmc_save_current_X2, X2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(PSTR("X2"), tmc_save_current_X2, X2_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y)
       const int16_t tmc_save_current_Y = stepperY.getMilliamps();
       stepperY.rms_current(Y_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current("Y", tmc_save_current_Y, Y_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(PSTR("Y"), tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
-      if (DEBUGGING(LEVELING)) debug_current("Y2", tmc_save_current_Y2, Y2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current(PSTR("Y2"), tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
@@ -338,26 +338,22 @@ void GcodeSuite::G28() {
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
-    #if ENABLED(HOME_Y_BEFORE_X)
-
-      if (doY || (doX && ENABLED(CODEPENDENT_XY_HOMING)))
-        homeaxis(Y_AXIS);
-
-    #endif
+    if (ENABLED(HOME_Y_BEFORE_X) && (doY || (ENABLED(CODEPENDENT_XY_HOMING) && doX)))
+      homeaxis(Y_AXIS);
 
     // Home X
     if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 

commit 2a71e4f336e66d93983ca15714137085090a73b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 7 23:10:47 2020 -0600

    Revert that wack backoff

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 63c7464057..4603c76967 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -93,22 +93,20 @@
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
-      do_blocking_move_to_xy(-0.5 * x_axis_home_dir, -0.5 * home_dir(Y_AXIS), fr_mm_s / 2);
-      safe_delay(100);
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown

commit 64d092935b27ff89955f0430eef5815b15e5a92d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 7 22:20:41 2020 -0600

    More useful ENABLED / DISABLED macros (#17054)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f75462fb97..63c7464057 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -55,27 +55,21 @@
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position.set(0.0, 0.0);
     sync_plan_position();
 
-    const int x_axis_home_dir =
-      #if ENABLED(DUAL_X_CARRIAGE)
-        x_home_dir(active_extruder)
-      #else
-        home_dir(X_AXIS)
-      #endif
-    ;
+    const int x_axis_home_dir = x_home_dir(active_extruder);
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states {
           tmc_enable_stallguard(stepperX)
         , tmc_enable_stallguard(stepperY)
@@ -303,79 +297,72 @@ void GcodeSuite::G28() {
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
   #endif
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
+    constexpr bool doZ = true; // for NANODLP_Z_SYNC if your DLP is on a DELTA
+
     home_delta();
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       end_slow_homing(slow_homing);
     #endif
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
-    const float z_homing_height = (
-      #if ENABLED(UNKNOWN_Z_NO_RAISE)
-        !TEST(axis_known_position, Z_AXIS) ? 0 :
-      #endif
-          (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
-    );
+    const float z_homing_height =
+      (DISABLED(UNKNOWN_Z_NO_RAISE) || TEST(axis_known_position, Z_AXIS))
+        ? (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
+        : 0;
 
     if (z_homing_height && (doX || doY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination.z = z_homing_height + (TEST(axis_known_position, Z_AXIS) ? 0.0f : current_position.z);
       if (destination.z > current_position.z) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination.z);
         do_blocking_move_to_z(destination.z);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     #if ENABLED(HOME_Y_BEFORE_X)
 
-      if (doY
-        #if ENABLED(CODEPENDENT_XY_HOMING)
-          || doX
-        #endif
-      ) homeaxis(Y_AXIS);
+      if (doY || (doX && ENABLED(CODEPENDENT_XY_HOMING)))
+        homeaxis(Y_AXIS);
 
     #endif
 
     // Home X
-    if (doX
-      #if ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X)
-        || doY
-      #endif
-    ) {
+    if (doX || (doY && ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X))) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 
         // Remember this extruder's position for later tool change
         inactive_extruder_x_pos = current_position.x;
 
@@ -389,23 +376,22 @@ void GcodeSuite::G28() {
         active_extruder_parked = true;
 
       #else
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
-    #if DISABLED(HOME_Y_BEFORE_X)
-      if (doY) homeaxis(Y_AXIS);
-    #endif
+    if (DISABLED(HOME_Y_BEFORE_X) && doY)
+      homeaxis(Y_AXIS);
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       end_slow_homing(slow_homing);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
 
       if (doZ) {
         #if ENABLED(BLTOUCH)
@@ -480,34 +466,29 @@ void GcodeSuite::G28() {
   // Clear endstop state for polled stallGuard endstops
   #if ENABLED(SPI_ENDSTOPS)
     endstops.clear_endstop_state();
   #endif
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
+  #if ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
-      #define NO_FETCH false // fetch the previous toolhead
-    #else
-      #define NO_FETCH true
-    #endif
-    tool_change(old_tool_index, NO_FETCH);
+    tool_change(old_tool_index, NONE(PARKING_EXTRUDER, DUAL_X_CARRIAGE));   // Do move if one of these
   #endif
 
   #if HAS_HOMING_CURRENT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
     #if HAS_CURRENT_HOME(X)
       stepperX.rms_current(tmc_save_current_X);
     #endif
     #if HAS_CURRENT_HOME(X2)
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
@@ -516,29 +497,22 @@ void GcodeSuite::G28() {
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
   ui.refresh();
 
   report_current_position();
 
-  #if ENABLED(NANODLP_Z_SYNC)
-    #if ENABLED(NANODLP_ALL_AXIS)
-      #define _HOME_SYNC true       // For any axis, output sync text.
-    #else
-      #define _HOME_SYNC doZ        // Only for Z-axis
-    #endif
-    if (_HOME_SYNC)
-      SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
-  #endif
+  if (ENABLED(NANODLP_Z_SYNC) && (doZ || ENABLED(NANODLP_ALL_AXIS)))
+    SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,

commit 5171e9da93d5913f7e4c75df9fdbe93c7c8fb32e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 20:50:06 2020 -0600

    No more direct G28 calls

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6841636cf0..f75462fb97 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -203,21 +203,21 @@
  *
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
-void GcodeSuite::G28(const bool always_home_all) {
+void GcodeSuite::G28() {
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(">>> G28");
     log_machine_info();
   }
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
@@ -304,30 +304,29 @@ void GcodeSuite::G28(const bool always_home_all) {
     extruder_duplication_enabled = false;
   #endif
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();
-    UNUSED(always_home_all);
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       end_slow_homing(slow_homing);
     #endif
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
-               home_all = always_home_all || (homeX == homeY && homeX == homeZ),
+               home_all = homeX == homeY && homeX == homeZ, // All or None
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 

commit 025c50cc6d360332df1113118af0d61d1eb9191c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 26 06:50:13 2020 -0600

    Quick-homing sensorless back-off (#16872)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index bee8182401..6841636cf0 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -99,20 +99,22 @@
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
+      do_blocking_move_to_xy(-0.5 * x_axis_home_dir, -0.5 * home_dir(Y_AXIS), fr_mm_s / 2);
+      safe_delay(100);
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b76d4da966..bee8182401 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -111,21 +111,21 @@
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
-      SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING_SER);
+      SERIAL_ECHO_MSG(STR_ERR_Z_HOMING_SER);
       return;
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
@@ -147,21 +147,21 @@
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
-      SERIAL_ECHO_MSG(MSG_ZPROBE_OUT_SER);
+      SERIAL_ECHO_MSG(STR_ZPROBE_OUT_SER);
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
 #endif // Z_SAFE_HOMING
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
 
   slow_homing_t begin_slow_homing() {
@@ -522,21 +522,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif
     if (_HOME_SYNC)
-      SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
+      SERIAL_ECHOLNPGM(STR_Z_MOVE_COMP);
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
     static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2b8c150140..b76d4da966 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 72b4d91d2e4d645c7b77eb7eb2aec2f5461f9728
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 2 00:02:30 2020 -0600

    Add Z_AFTER_HOMING to raise Z more in G28 (#16755)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 0b29fbc4d6..2b8c150140 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -398,35 +398,43 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if DISABLED(HOME_Y_BEFORE_X)
       if (doY) homeaxis(Y_AXIS);
     #endif
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       end_slow_homing(slow_homing);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
+
       if (doZ) {
         #if ENABLED(BLTOUCH)
           bltouch.init();
         #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
-          probe.move_z_after_probing();
+          #if Z_AFTER_HOMING > Z_AFTER_PROBING
+            do_blocking_move_to_z(Z_AFTER_HOMING);
+          #else
+            probe.move_z_after_probing();
+          #endif
+        #elif defined(Z_AFTER_HOMING)
+          do_blocking_move_to_z(Z_AFTER_HOMING);
         #endif
 
       } // doZ
+
     #endif // Z_HOME_DIR < 0
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6d87e6f932..0b29fbc4d6 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -126,21 +126,21 @@
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
     #if HOMING_Z_WITH_PROBE
-      destination -= probe_offset_xy;
+      destination -= probe.offset_xy;
     #endif
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
@@ -409,21 +409,21 @@ void GcodeSuite::G28(const bool always_home_all) {
         #if ENABLED(BLTOUCH)
           bltouch.init();
         #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
-          move_z_after_probing();
+          probe.move_z_after_probing();
         #endif
 
       } // doZ
     #endif // Z_HOME_DIR < 0
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**

commit 707349d492c2544d32af7287aca4ddbaf1473542
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 19:52:01 2020 -0600

    Updates for L64XX

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 17d1920450..6d87e6f932 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -523,21 +523,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_L64XX
     // Set L6470 absolute position registers to counts
     // constexpr *might* move this to PROGMEM.
     // If not, this will need a PROGMEM directive and an accessor.
-    static constexpr AxisEnum L6470_axis_xref[MAX_L6470] = {
+    static constexpr AxisEnum L64XX_axis_xref[MAX_L64XX] = {
       X_AXIS, Y_AXIS, Z_AXIS,
       X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
       E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
     };
     for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
       const uint8_t cv = L64XX::chain[j];
-      L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L6470_axis_xref[cv]));
+      L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L64XX_axis_xref[cv]));
     }
   #endif
 }

commit 1ad53cee1f4e2768310fca98de0381df9c39b617
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Mon Jan 13 18:47:30 2020 -0600

    Improved STMicro L64XX stepper driver support (#16452)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index db6ae7a682..17d1920450 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -40,22 +40,22 @@
 #endif
 
 #include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
-#if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
-  #include "../../libs/L6470/L6470_Marlin.h"
+#if HAS_L64XX                         // set L6470 absolute position registers to counts
+  #include "../../libs/L64XX/L64XX_Marlin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
@@ -519,18 +519,25 @@ void GcodeSuite::G28(const bool always_home_all) {
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
-  #if HAS_DRIVER(L6470)
+  #if HAS_L64XX
     // Set L6470 absolute position registers to counts
-    for (uint8_t j = 1; j <= L6470::chain[0]; j++) {
-      const uint8_t cv = L6470::chain[j];
-      L6470.set_param(cv, L6470_ABS_POS, stepper.position((AxisEnum)L6470.axis_xref[cv]));
+    // constexpr *might* move this to PROGMEM.
+    // If not, this will need a PROGMEM directive and an accessor.
+    static constexpr AxisEnum L6470_axis_xref[MAX_L6470] = {
+      X_AXIS, Y_AXIS, Z_AXIS,
+      X_AXIS, Y_AXIS, Z_AXIS, Z_AXIS,
+      E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS, E_AXIS
+    };
+    for (uint8_t j = 1; j <= L64XX::chain[0]; j++) {
+      const uint8_t cv = L64XX::chain[j];
+      L64xxManager.set_param((L64XX_axis_t)cv, L6470_ABS_POS, stepper.position(L6470_axis_xref[cv]));
     }
   #endif
 }

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b6c0389b31..db6ae7a682 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -126,21 +126,21 @@
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
      */
     destination.set(safe_homing_xy, current_position.z);
 
     #if HOMING_Z_WITH_PROBE
-      destination -= probe_offset;
+      destination -= probe_offset_xy;
     #endif
 
     if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif

commit b49a0e39d5617ba3752b4b406cc663a7c6a88908
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 19 16:02:57 2019 -0600

    HOME_USING_SPREADCYCLE is obsolete
    
    Co-Authored-By: teemuatlut <teemu.mantykallio@live.fi>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6826a397b9..b6c0389b31 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -279,25 +279,20 @@ void GcodeSuite::G28(const bool always_home_all) {
       stepperY.rms_current(Y_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current("Y", tmc_save_current_Y, Y_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current("Y2", tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
-  #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to spreadCycle...");
-    process_subcommands_now_P(PSTR("M569 S0 X Y"));
-  #endif
-
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
@@ -508,25 +503,20 @@ void GcodeSuite::G28(const bool always_home_all) {
       stepperX2.rms_current(tmc_save_current_X2);
     #endif
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
-  #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to StealthChop...");
-    process_subcommands_now_P(PSTR("M569 S1 X Y"));
-  #endif
-
   ui.refresh();
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif

commit 6e8dcba698fe79ffe789b866c6b541033b0851fd
Author: danym21 <54744475+danym21@users.noreply.github.com>
Date:   Sun Dec 15 19:00:00 2019 +0100

    Fix G28 debug line, M569 calls (#16213)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b7af871b11..6826a397b9 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -255,21 +255,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
   #define HAS_HOMING_CURRENT (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2))
 
   #if HAS_HOMING_CURRENT
     auto debug_current = [](const char * const s, const int16_t a, const int16_t b){
-      DEBUG_ECHO(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
+      DEBUG_ECHO(s); DEBUG_ECHOLNPAIR(" current: ", a, " -> ", b);
     };
     #if HAS_CURRENT_HOME(X)
       const int16_t tmc_save_current_X = stepperX.getMilliamps();
       stepperX.rms_current(X_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current("X", tmc_save_current_X, X_CURRENT_HOME);
     #endif
     #if HAS_CURRENT_HOME(X2)
       const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
       stepperX2.rms_current(X2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current("X2", tmc_save_current_X2, X2_CURRENT_HOME);
@@ -281,21 +281,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     #endif
     #if HAS_CURRENT_HOME(Y2)
       const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
       stepperY2.rms_current(Y2_CURRENT_HOME);
       if (DEBUGGING(LEVELING)) debug_current("Y2", tmc_save_current_Y2, Y2_CURRENT_HOME);
     #endif
   #endif
 
   #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to spreadCycle...");
-    process_subcommands_now_P(PSTR("M569S0XY"));
+    process_subcommands_now_P(PSTR("M569 S0 X Y"));
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
@@ -510,21 +510,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if HAS_CURRENT_HOME(Y)
       stepperY.rms_current(tmc_save_current_Y);
     #endif
     #if HAS_CURRENT_HOME(Y2)
       stepperY2.rms_current(tmc_save_current_Y2);
     #endif
   #endif
 
   #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to StealthChop...");
-    process_subcommands_now_P(PSTR("M569S1XY"));
+    process_subcommands_now_P(PSTR("M569 S1 X Y"));
   #endif
 
   ui.refresh();
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else

commit f19fa64e98f9ed5b52c0ccccfa13744c4f180c2f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Nov 15 15:42:01 2019 -0600

    Eliminate multiple settings to extruder_duplication_enabled in G28
    
    If the IDEX mode was previously set (via GCode or the LCD Panel) to a duplication mode...   It was lost after a G28 due to this redundant setting of 'extruder_duplication_enabled'.
    
    It is very important to the various use cases of IDEX machines that extruder_duplication_enabled is preserved across a G28.   The reason is this allows a person to use the LCD Panel to put the machine into a duplication mode, and then send a 'normal' part file to the printer and get two parts out of the process.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f65641e661..b7af871b11 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -454,22 +454,20 @@ void GcodeSuite::G28(const bool always_home_all) {
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
       raised_parked_position = current_position;
       delayed_move_time = 0;
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
-      extruder_duplication_enabled = false;
-
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
 
       #if ENABLED(IMPROVE_HOMING_RELIABILITY)
         end_slow_homing(slow_homing);
       #endif
     }
 
   #endif // DUAL_X_CARRIAGE
 

commit 28e1614c2e87ae787a7ca3903ddf4cefd90641da
Author: danym21 <54744475+danym21@users.noreply.github.com>
Date:   Mon Nov 11 01:45:06 2019 +0100

    Add Sensorless Homing current (#15690)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 9ce7938420..f65641e661 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -223,20 +223,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
       return;
     }
   #endif
 
+  // Home (O)nly if position is unknown
   if (!homing_needed() && parser.boolval('O')) {
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip\n<<< G28");
     return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
@@ -249,20 +250,54 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
+  #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
+  #define HAS_HOMING_CURRENT (HAS_CURRENT_HOME(X) || HAS_CURRENT_HOME(X2) || HAS_CURRENT_HOME(Y) || HAS_CURRENT_HOME(Y2))
+
+  #if HAS_HOMING_CURRENT
+    auto debug_current = [](const char * const s, const int16_t a, const int16_t b){
+      DEBUG_ECHO(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b);
+    };
+    #if HAS_CURRENT_HOME(X)
+      const int16_t tmc_save_current_X = stepperX.getMilliamps();
+      stepperX.rms_current(X_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current("X", tmc_save_current_X, X_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(X2)
+      const int16_t tmc_save_current_X2 = stepperX2.getMilliamps();
+      stepperX2.rms_current(X2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current("X2", tmc_save_current_X2, X2_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(Y)
+      const int16_t tmc_save_current_Y = stepperY.getMilliamps();
+      stepperY.rms_current(Y_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current("Y", tmc_save_current_Y, Y_CURRENT_HOME);
+    #endif
+    #if HAS_CURRENT_HOME(Y2)
+      const int16_t tmc_save_current_Y2 = stepperY2.getMilliamps();
+      stepperY2.rms_current(Y2_CURRENT_HOME);
+      if (DEBUGGING(LEVELING)) debug_current("Y2", tmc_save_current_Y2, Y2_CURRENT_HOME);
+    #endif
+  #endif
+
+  #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to spreadCycle...");
+    process_subcommands_now_P(PSTR("M569S0XY"));
+  #endif
+
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
@@ -459,20 +494,41 @@ void GcodeSuite::G28(const bool always_home_all) {
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, NO_FETCH);
   #endif
 
+  #if HAS_HOMING_CURRENT
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Restore driver current...");
+    #if HAS_CURRENT_HOME(X)
+      stepperX.rms_current(tmc_save_current_X);
+    #endif
+    #if HAS_CURRENT_HOME(X2)
+      stepperX2.rms_current(tmc_save_current_X2);
+    #endif
+    #if HAS_CURRENT_HOME(Y)
+      stepperY.rms_current(tmc_save_current_Y);
+    #endif
+    #if HAS_CURRENT_HOME(Y2)
+      stepperY2.rms_current(tmc_save_current_Y2);
+    #endif
+  #endif
+
+  #if BOTH(STEALTHCHOP_XY, HOME_USING_SPREADCYCLE)
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Set XY to StealthChop...");
+    process_subcommands_now_P(PSTR("M569S1XY"));
+  #endif
+
   ui.refresh();
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif

commit 770adcfa1589a15746bc1ae8f26071ce5cd7ebbb
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 10 14:21:20 2019 -0800

    Raise Z before homing X/Y on unknown Z (#15859)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 63408515fb..9ce7938420 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -301,21 +301,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
     if (z_homing_height && (doX || doY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      destination.z = z_homing_height;
+      destination.z = z_homing_height + (TEST(axis_known_position, Z_AXIS) ? 0.0f : current_position.z);
       if (destination.z > current_position.z) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination.z);
         do_blocking_move_to_z(destination.z);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 

commit 9895e6d766bbee5e0f3ed073faef924f932d47fd
Author: Jacob Jordan <doublejinitials@gmail.com>
Date:   Thu Oct 24 13:14:45 2019 -0500

    Only use slow homing speed where applicable (#15640)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8fcb74abc5..63408515fb 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -155,20 +155,47 @@
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(MSG_ZPROBE_OUT_SER);
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
 #endif // Z_SAFE_HOMING
 
+#if ENABLED(IMPROVE_HOMING_RELIABILITY)
+
+  slow_homing_t begin_slow_homing() {
+    slow_homing_t slow_homing{0};
+    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
+                                 planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
+    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
+    #if HAS_CLASSIC_JERK
+      slow_homing.jerk_xy = planner.max_jerk;
+      planner.max_jerk.set(0, 0);
+    #endif
+    planner.reset_acceleration_rates();
+    return slow_homing;
+  }
+
+  void end_slow_homing(const slow_homing_t &slow_homing) {
+    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
+    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
+    #if HAS_CLASSIC_JERK
+      planner.max_jerk = slow_homing.jerk_xy;
+    #endif
+    planner.reset_acceleration_rates();
+  }
+
+#endif // IMPROVE_HOMING_RELIABILITY
+
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.
  *        With QUICK_HOME enabled XY will home together, then Z.
  *
  *  O   Home only if position is unknown
  *
@@ -223,31 +250,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-    slow_homing_t slow_homing{0};
-    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
-                                 planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
-    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
-    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
-    #if HAS_CLASSIC_JERK
-      slow_homing.jerk_xy = planner.max_jerk;
-      planner.max_jerk.set(0, 0);
-    #endif
-
-    planner.reset_acceleration_rates();
+    slow_homing_t slow_homing = begin_slow_homing();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
@@ -257,20 +274,24 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();
     UNUSED(always_home_all);
 
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      end_slow_homing(slow_homing);
+    #endif
+
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = always_home_all || (homeX == homeY && homeX == homeZ),
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
@@ -341,20 +362,24 @@ void GcodeSuite::G28(const bool always_home_all) {
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
       if (doY) homeaxis(Y_AXIS);
     #endif
 
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      end_slow_homing(slow_homing);
+    #endif
+
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (doZ) {
         #if ENABLED(BLTOUCH)
           bltouch.init();
         #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
@@ -374,40 +399,48 @@ void GcodeSuite::G28(const bool always_home_all) {
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
     if (dxc_is_duplicating()) {
 
+      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+        slow_homing = begin_slow_homing();
+      #endif
+
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
       inactive_extruder_x_pos = current_position.x;
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
       raised_parked_position = current_position;
       delayed_move_time = 0;
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
+
+      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+        end_slow_homing(slow_homing);
+      #endif
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   // Clear endstop state for polled stallGuard endstops
   #if ENABLED(SPI_ENDSTOPS)
     endstops.clear_endstop_state();
   #endif
@@ -426,29 +459,20 @@ void GcodeSuite::G28(const bool always_home_all) {
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, NO_FETCH);
   #endif
 
-  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
-    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
-    #if HAS_CLASSIC_JERK
-      planner.max_jerk = slow_homing.jerk_xy;
-    #endif
-    planner.reset_acceleration_rates();
-  #endif
-
   ui.refresh();
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7f1fb7705e..8fcb74abc5 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -111,21 +111,21 @@
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
-      SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING);
+      SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING_SER);
       return;
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      * (Z is already at the right height)
@@ -147,21 +147,21 @@
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
-      SERIAL_ECHO_MSG(MSG_ZPROBE_OUT);
+      SERIAL_ECHO_MSG(MSG_ZPROBE_OUT_SER);
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
 #endif // Z_SAFE_HOMING
 
 /**
  * G28: Home all axes according to settings
  *

commit 10bbed7f69b2d36081e5d09f7c55492e4b0bcde9
Author: Alex Somesan <alex.somesan@gmail.com>
Date:   Sun Sep 29 23:50:53 2019 +0200

    Fix comma/semicolon typo (#15420)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6fda4e84d3..7f1fb7705e 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -224,21 +224,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     slow_homing_t slow_homing{0};
-    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS];
+    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS],
                                  planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
     #if HAS_CLASSIC_JERK
       slow_homing.jerk_xy = planner.max_jerk;
       planner.max_jerk.set(0, 0);
     #endif
 
     planner.reset_acceleration_rates();
   #endif

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 514bb65891..6fda4e84d3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -52,21 +52,21 @@
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
-    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+    current_position.set(0.0, 0.0);
     sync_plan_position();
 
     const int x_axis_home_dir =
       #if ENABLED(DUAL_X_CARRIAGE)
         x_home_dir(active_extruder)
       #else
         home_dir(X_AXIS)
       #endif
     ;
 
@@ -88,21 +88,21 @@
           #if AXIS_HAS_STALLGUARD(Y2)
             || tmc_enable_stallguard(stepperY2)
           #endif
       };
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
 
     endstops.validate_homing_move();
 
-    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+    current_position.set(0.0, 0.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
       #if AXIS_HAS_STALLGUARD(X2)
         tmc_disable_stallguard(stepperX2, stealth_states.x2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         tmc_disable_stallguard(stepperY2, stealth_states.y2);
       #endif
@@ -121,44 +121,42 @@
       SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING);
       return;
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
+     * (Z is already at the right height)
      */
-    destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
-    destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
-    destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
+    destination.set(safe_homing_xy, current_position.z);
 
     #if HOMING_Z_WITH_PROBE
-      destination[X_AXIS] -= probe_offset[X_AXIS];
-      destination[Y_AXIS] -= probe_offset[Y_AXIS];
+      destination -= probe_offset;
     #endif
 
-    if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
+    if (position_is_reachable(destination)) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
-      do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
+      do_blocking_move_to_xy(destination);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(MSG_ZPROBE_OUT);
     }
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
@@ -225,30 +223,28 @@ void GcodeSuite::G28(const bool always_home_all) {
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-    slow_homing_t slow_homing { 0 };
-    slow_homing.acceleration.x = planner.settings.max_acceleration_mm_per_s2[X_AXIS];
-    slow_homing.acceleration.y = planner.settings.max_acceleration_mm_per_s2[Y_AXIS];
+    slow_homing_t slow_homing{0};
+    slow_homing.acceleration.set(planner.settings.max_acceleration_mm_per_s2[X_AXIS];
+                                 planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
     #if HAS_CLASSIC_JERK
-      slow_homing.jerk.x = planner.max_jerk[X_AXIS];
-      slow_homing.jerk.y = planner.max_jerk[Y_AXIS];
-      planner.max_jerk[X_AXIS] = 0;
-      planner.max_jerk[Y_AXIS] = 0;
+      slow_homing.jerk_xy = planner.max_jerk;
+      planner.max_jerk.set(0, 0);
     #endif
 
     planner.reset_acceleration_rates();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
@@ -267,41 +263,41 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = always_home_all || (homeX == homeY && homeX == homeZ),
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
-    set_destination_from_current();
+    destination = current_position;
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
     if (z_homing_height && (doX || doY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      destination[Z_AXIS] = z_homing_height;
-      if (destination[Z_AXIS] > current_position[Z_AXIS]) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
-        do_blocking_move_to_z(destination[Z_AXIS]);
+      destination.z = z_homing_height;
+      if (destination.z > current_position.z) {
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination.z);
+        do_blocking_move_to_z(destination.z);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
@@ -322,28 +318,28 @@ void GcodeSuite::G28(const bool always_home_all) {
       #endif
     ) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 
         // Remember this extruder's position for later tool change
-        inactive_extruder_x_pos = current_position[X_AXIS];
+        inactive_extruder_x_pos = current_position.x;
 
         // Home the 1st (left) extruder
         active_extruder = 0;
         homeaxis(X_AXIS);
 
         // Consider the active extruder to be parked
-        COPY(raised_parked_position, current_position);
+        raised_parked_position = current_position;
         delayed_move_time = 0;
         active_extruder_parked = true;
 
       #else
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
@@ -383,28 +379,28 @@ void GcodeSuite::G28(const bool always_home_all) {
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
     if (dxc_is_duplicating()) {
 
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
-      inactive_extruder_x_pos = current_position[X_AXIS];
+      inactive_extruder_x_pos = current_position.x;
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
-      COPY(raised_parked_position, current_position);
+      raised_parked_position = current_position;
       delayed_move_time = 0;
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
@@ -434,24 +430,22 @@ void GcodeSuite::G28(const bool always_home_all) {
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, NO_FETCH);
   #endif
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
     planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
     #if HAS_CLASSIC_JERK
-      planner.max_jerk[X_AXIS] = slow_homing.jerk.x;
-      planner.max_jerk[Y_AXIS] = slow_homing.jerk.y;
+      planner.max_jerk = slow_homing.jerk_xy;
     #endif
-
     planner.reset_acceleration_rates();
   #endif
 
   ui.refresh();
 
   report_current_position();
 
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.

commit 5288c399ce780cd3e91ee413d1f92ca9e4da53a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:34:07 2019 -0500

    Patch probe offset name, defines

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 1e78a49b45..514bb65891 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -32,23 +32,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
-#if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
-  #include "../../module/probe.h"
-#endif
+#include "../../module/probe.h"
 
 #if ENABLED(BLTOUCH)
   #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a9b1c25201..1e78a49b45 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -129,22 +129,22 @@
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
-      destination[X_AXIS] -= zprobe_offset[X_AXIS];
-      destination[Y_AXIS] -= zprobe_offset[Y_AXIS];
+      destination[X_AXIS] -= probe_offset[X_AXIS];
+      destination[Y_AXIS] -= probe_offset[Y_AXIS];
     #endif
 
     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index aad4c4093c..a9b1c25201 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -129,22 +129,22 @@
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
-      destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
-      destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
+      destination[X_AXIS] -= zprobe_offset[X_AXIS];
+      destination[Y_AXIS] -= zprobe_offset[Y_AXIS];
     #endif
 
     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4d5e203c97..aad4c4093c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -254,21 +254,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
   #endif
 
-  setup_for_endstop_or_probe_move();
+  remember_feedrate_scaling_off();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
@@ -420,21 +420,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
-  clean_up_after_endstop_or_probe_move();
+  restore_feedrate_and_scaling();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, NO_FETCH);
   #endif

commit 13d725d24db1c0acea24d741391556c9c19ee811
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 20 23:15:39 2019 -0500

    Tweak debug messages

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 420eb65c9f..4d5e203c97 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -117,58 +117,58 @@
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
       SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING);
       return;
     }
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z_SAFE_HOMING >>>");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("home_z_safely >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
       destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
     #endif
 
     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
 
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("home_z_safely", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(MSG_ZPROBE_OUT);
     }
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Z_SAFE_HOMING");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< home_z_safely");
   }
 
 #endif // Z_SAFE_HOMING
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.

commit 081e4506ca5356501415bfaf066d982947449623
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Wed Aug 28 04:20:28 2019 -0500

    Fix G53 as prefix, G28 with CNC_COORDINATE_SYSTEMS (#15069)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index d936809051..420eb65c9f 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -446,20 +446,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       planner.max_jerk[X_AXIS] = slow_homing.jerk.x;
       planner.max_jerk[Y_AXIS] = slow_homing.jerk.y;
     #endif
 
     planner.reset_acceleration_rates();
   #endif
 
   ui.refresh();
 
   report_current_position();
+
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 039bd3d1a3..d936809051 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -71,29 +71,33 @@
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_t stealth_states { false };
-      stealth_states.x = tmc_enable_stallguard(stepperX);
-      stealth_states.y = tmc_enable_stallguard(stepperY);
-      #if AXIS_HAS_STALLGUARD(X2)
-        stealth_states.x2 = tmc_enable_stallguard(stepperX2);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Y2)
-        stealth_states.y2 = tmc_enable_stallguard(stepperY2);
-      #endif
+      sensorless_t stealth_states {
+          tmc_enable_stallguard(stepperX)
+        , tmc_enable_stallguard(stepperY)
+        , false
+        , false
+          #if AXIS_HAS_STALLGUARD(X2)
+            || tmc_enable_stallguard(stepperX2)
+          #endif
+        , false
+          #if AXIS_HAS_STALLGUARD(Y2)
+            || tmc_enable_stallguard(stepperY2)
+          #endif
+      };
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
@@ -222,20 +226,36 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
+  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+    slow_homing_t slow_homing { 0 };
+    slow_homing.acceleration.x = planner.settings.max_acceleration_mm_per_s2[X_AXIS];
+    slow_homing.acceleration.y = planner.settings.max_acceleration_mm_per_s2[Y_AXIS];
+    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = 100;
+    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
+    #if HAS_CLASSIC_JERK
+      slow_homing.jerk.x = planner.max_jerk[X_AXIS];
+      slow_homing.jerk.y = planner.max_jerk[Y_AXIS];
+      planner.max_jerk[X_AXIS] = 0;
+      planner.max_jerk[Y_AXIS] = 0;
+    #endif
+
+    planner.reset_acceleration_rates();
+  #endif
+
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, true);
   #endif
 
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
@@ -386,20 +406,25 @@ void GcodeSuite::G28(const bool always_home_all) {
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
+  // Clear endstop state for polled stallGuard endstops
+  #if ENABLED(SPI_ENDSTOPS)
+    endstops.clear_endstop_state();
+  #endif
+
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
@@ -407,20 +432,31 @@ void GcodeSuite::G28(const bool always_home_all) {
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, NO_FETCH);
   #endif
 
+  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+    planner.settings.max_acceleration_mm_per_s2[X_AXIS] = slow_homing.acceleration.x;
+    planner.settings.max_acceleration_mm_per_s2[Y_AXIS] = slow_homing.acceleration.y;
+    #if HAS_CLASSIC_JERK
+      planner.max_jerk[X_AXIS] = slow_homing.jerk.x;
+      planner.max_jerk[Y_AXIS] = slow_homing.jerk.y;
+    #endif
+
+    planner.reset_acceleration_rates();
+  #endif
+
   ui.refresh();
 
   report_current_position();
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis
     #endif
     if (_HOME_SYNC)

commit 6f8b8c394db5f5037e85d3b16dc63bfeb11f6891
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jul 31 21:50:23 2019 -0400

    Homing backoff per-axis / delta Z (#14789)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f39d3bae10..039bd3d1a3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -384,29 +384,20 @@ void GcodeSuite::G28(const bool always_home_all) {
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
-  #ifdef HOMING_BACKOFF_MM
-    endstops.enable(false);
-    constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
-    const float backoff_x = doX ? ABS(endstop_backoff[X_AXIS]) * (X_HOME_DIR) : 0,
-                backoff_y = doY ? ABS(endstop_backoff[Y_AXIS]) * (Y_HOME_DIR) : 0,
-                backoff_z = doZ ? ABS(endstop_backoff[Z_AXIS]) * (Z_HOME_DIR) : 0;
-    if (backoff_z) do_blocking_move_to_z(current_position[Z_AXIS] - backoff_z);
-    if (backoff_x || backoff_y) do_blocking_move_to_xy(current_position[X_AXIS] - backoff_x, current_position[Y_AXIS] - backoff_y);
-  #endif
   endstops.not_homing();
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8e12f4b06a..f39d3bae10 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -71,21 +71,21 @@
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_t stealth_states { false, false, false, false, false, false, false };
+      sensorless_t stealth_states { false };
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
       #if AXIS_HAS_STALLGUARD(X2)
         stealth_states.x2 = tmc_enable_stallguard(stepperX2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         stealth_states.y2 = tmc_enable_stallguard(stepperY2);
       #endif
     #endif
 

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index cd2c1da70f..8e12f4b06a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -68,21 +68,21 @@
       #if ENABLED(DUAL_X_CARRIAGE)
         x_home_dir(active_extruder)
       #else
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
-                fr_mm_s = MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+                fr_mm_s = _MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_t stealth_states { false, false, false, false, false, false, false };
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
       #if AXIS_HAS_STALLGUARD(X2)
         stealth_states.x2 = tmc_enable_stallguard(stepperX2);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
         stealth_states.y2 = tmc_enable_stallguard(stepperY2);

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 5f5f42e9e7..cd2c1da70f 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 2580104c8befb7bb6a363b79776f4a8ba9436686
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 26 05:11:05 2019 -0500

    Revert recent probe changes
    
    - Revert "Fix FIX_MOUNTED_PROBE compile error (#14393)"
    - Revert "Fix G28 with non-BLTouch probes (#14381)"
    - Revert "Fix BLTOUCH deploy/stow in HS mode (#14352)"
    - Revert "Apply needed BLTouch patch (#14233)"
    
    Co-Authored-By: AnHardt <github@kitelab.de>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c30a323637..5f5f42e9e7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -32,23 +32,26 @@
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
-#if HAS_BED_PROBE
+#if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
-  #define STOW_PROBE_BEFORE_HOMING NONE(Z_PROBE_ALLEN_KEY, Z_PROBE_SLED)
+#endif
+
+#if ENABLED(BLTOUCH)
+  #include "../../feature/bltouch.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
@@ -248,24 +251,20 @@ void GcodeSuite::G28(const bool always_home_all) {
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = always_home_all || (homeX == homeY && homeX == homeZ),
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     set_destination_from_current();
 
-    #if STOW_PROBE_BEFORE_HOMING
-      STOW_PROBE();
-    #endif
-
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
@@ -331,20 +330,23 @@ void GcodeSuite::G28(const bool always_home_all) {
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
       if (doY) homeaxis(Y_AXIS);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (doZ) {
+        #if ENABLED(BLTOUCH)
+          bltouch.init();
+        #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 

commit 49627069a50b5e6c2a80f49ccf1497f53e85f8ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 26 03:42:21 2019 -0500

    Shorthand for home-after-deactivate

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 22b6880999..c30a323637 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -193,31 +193,23 @@ void GcodeSuite::G28(const bool always_home_all) {
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
       return;
     }
   #endif
 
-  if (parser.boolval('O')) {
-    if (
-      #if ENABLED(HOME_AFTER_DEACTIVATE)
-        all_axes_known()  // homing needed anytime steppers deactivate
-      #else
-        all_axes_homed()  // homing needed only if never homed
-      #endif
-    ) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip\n<<< G28");
-      return;
-    }
+  if (!homing_needed() && parser.boolval('O')) {
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip\n<<< G28");
+    return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
     #if ENABLED(PROBE_MANUALLY)

commit 8e23e9b16cff95f2ad39dc8d406053413a17d1f4
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jun 25 03:55:29 2019 -0600

    Fix FIX_MOUNTED_PROBE compile error (#14393)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 083730823e..22b6880999 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -32,22 +32,23 @@
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
-#if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
+#if HAS_BED_PROBE
   #include "../../module/probe.h"
+  #define STOW_PROBE_BEFORE_HOMING NONE(Z_PROBE_ALLEN_KEY, Z_PROBE_SLED)
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
@@ -255,21 +256,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = always_home_all || (homeX == homeY && homeX == homeZ),
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     set_destination_from_current();
 
-    #if HAS_BED_PROBE
+    #if STOW_PROBE_BEFORE_HOMING
       STOW_PROBE();
     #endif
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (

commit 5986194c36af76da19cbc1e5321d1243794a6cce
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Mon Jun 24 03:53:05 2019 +0200

    Fix G28 with non-BLTouch probes (#14381)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c451f975cc..083730823e 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -36,24 +36,20 @@
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
 #endif
 
-#if ENABLED(BLTOUCH)
-  #include "../../feature/bltouch.h"
-#endif
-
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
@@ -259,20 +255,24 @@ void GcodeSuite::G28(const bool always_home_all) {
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
                home_all = always_home_all || (homeX == homeY && homeX == homeZ),
                doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     set_destination_from_current();
 
+    #if HAS_BED_PROBE
+      STOW_PROBE();
+    #endif
+
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
@@ -338,23 +338,20 @@ void GcodeSuite::G28(const bool always_home_all) {
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
       if (doY) homeaxis(Y_AXIS);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (doZ) {
-        #if ENABLED(BLTOUCH)
-          bltouch.init();
-        #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 

commit aa0383a83b7bc45b86753ef9f5adb41da09c76df
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 23 21:00:48 2019 -0400

    Enhance IDEX toolchange auto-return w/ no park, full control (#14117)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3656dc0999..c451f975cc 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -235,21 +235,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
-    tool_change(0, 0, true);
+    tool_change(0, true);
   #endif
 
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
 
   endstops.enable(true); // Enable endstops for next homing move
 
@@ -421,21 +421,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
-    tool_change(old_tool_index, 0, NO_FETCH);
+    tool_change(old_tool_index, NO_FETCH);
   #endif
 
   ui.refresh();
 
   report_current_position();
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true       // For any axis, output sync text.
     #else
       #define _HOME_SYNC doZ        // Only for Z-axis

commit 3c179bbd474141d2d03540c9d0887bb3c6080b2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 26 15:30:20 2019 -0500

    Simpler G28 home axis conditions

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c191eeae3b..3656dc0999 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -253,27 +253,23 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
-    const bool homeX = always_home_all || parser.seen('X'),
-               homeY = always_home_all || parser.seen('Y'),
-               homeZ = always_home_all || parser.seen('Z'),
-               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ),
-               doX = home_all || homeX,
-               doY = home_all || homeY,
-               doZ = home_all || homeZ;
+    const bool homeX = parser.seen('X'), homeY = parser.seen('Y'), homeZ = parser.seen('Z'),
+               home_all = always_home_all || (homeX == homeY && homeX == homeZ),
+               doX = home_all || homeX, doY = home_all || homeY, doZ = home_all || homeZ;
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 1a6922cfa4..c191eeae3b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -230,24 +230,20 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
-  #if ENABLED(BLTOUCH)
-    bltouch.init();
-  #endif
-
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
   #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
@@ -346,20 +342,23 @@ void GcodeSuite::G28(const bool always_home_all) {
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
       if (doY) homeaxis(Y_AXIS);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (doZ) {
+        #if ENABLED(BLTOUCH)
+          bltouch.init();
+        #endif
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 684c2e216b..1a6922cfa4 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -421,21 +421,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    #if ENABLED(PARKING_EXTRUDER) || ENABLED(DUAL_X_CARRIAGE)
+    #if EITHER(PARKING_EXTRUDER, DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   ui.refresh();
 
   report_current_position();

commit bf7b28b45661a8f2407da7b5c7f527418f4de716
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Apr 5 18:04:46 2019 -0600

    Fix incorrect variable name (#13585)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 02c6e8a37d..684c2e216b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -399,28 +399,27 @@ void GcodeSuite::G28(const bool always_home_all) {
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
   #ifdef HOMING_BACKOFF_MM
     endstops.enable(false);
-    constexpr float backoff[XYZ] = HOMING_BACKOFF_MM;
+    constexpr float endstop_backoff[XYZ] = HOMING_BACKOFF_MM;
     const float backoff_x = doX ? ABS(endstop_backoff[X_AXIS]) * (X_HOME_DIR) : 0,
                 backoff_y = doY ? ABS(endstop_backoff[Y_AXIS]) * (Y_HOME_DIR) : 0,
                 backoff_z = doZ ? ABS(endstop_backoff[Z_AXIS]) * (Z_HOME_DIR) : 0;
     if (backoff_z) do_blocking_move_to_z(current_position[Z_AXIS] - backoff_z);
     if (backoff_x || backoff_y) do_blocking_move_to_xy(current_position[X_AXIS] - backoff_x, current_position[Y_AXIS] - backoff_y);
   #endif
-
   endstops.not_homing();
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif

commit 27a4927ed108c027df5210308f5ad3974059faee
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Apr 4 01:47:19 2019 -0600

    Add option to move away from endstop after homing. (#13557)
    
    Add option to move away from endstop after homing.
    - Add `ENDSTOP_BACKOFF` for printers with a recessed Z home button (Lulzbot TAZ 6).
    - Also prevents chattering when sensorless homing with axes against bumpers.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f0d05d832e..02c6e8a37d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -175,21 +175,20 @@
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28(const bool always_home_all) {
-
   if (DEBUGGING(LEVELING)) {
     DEBUG_ECHOLNPGM(">>> G28");
     log_machine_info();
   }
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
@@ -261,67 +260,70 @@ void GcodeSuite::G28(const bool always_home_all) {
   #if ENABLED(DELTA)
 
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = always_home_all || parser.seen('X'),
                homeY = always_home_all || parser.seen('Y'),
                homeZ = always_home_all || parser.seen('Z'),
-               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
+               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ),
+               doX = home_all || homeX,
+               doY = home_all || homeY,
+               doZ = home_all || homeZ;
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
-      if (home_all || homeZ) homeaxis(Z_AXIS);
+      if (doZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
-    if (z_homing_height && (home_all || homeX || homeY)) {
+    if (z_homing_height && (doX || doY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
         do_blocking_move_to_z(destination[Z_AXIS]);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
-      if (home_all || (homeX && homeY)) quick_home_xy();
+      if (doX && doY) quick_home_xy();
 
     #endif
 
     // Home Y (before X)
     #if ENABLED(HOME_Y_BEFORE_X)
 
-      if (home_all || homeY
+      if (doY
         #if ENABLED(CODEPENDENT_XY_HOMING)
-          || homeX
+          || doX
         #endif
       ) homeaxis(Y_AXIS);
 
     #endif
 
     // Home X
-    if (home_all || homeX
+    if (doX
       #if ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X)
-        || homeY
+        || doY
       #endif
     ) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         homeaxis(X_AXIS);
 
         // Remember this extruder's position for later tool change
@@ -338,37 +340,37 @@ void GcodeSuite::G28(const bool always_home_all) {
 
       #else
 
         homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
-      if (home_all || homeY) homeaxis(Y_AXIS);
+      if (doY) homeaxis(Y_AXIS);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
-      if (home_all || homeZ) {
+      if (doZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 
-      } // home_all || homeZ
+      } // doZ
     #endif // Z_HOME_DIR < 0
 
     sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
@@ -395,20 +397,30 @@ void GcodeSuite::G28(const bool always_home_all) {
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
+  #ifdef HOMING_BACKOFF_MM
+    endstops.enable(false);
+    constexpr float backoff[XYZ] = HOMING_BACKOFF_MM;
+    const float backoff_x = doX ? ABS(endstop_backoff[X_AXIS]) * (X_HOME_DIR) : 0,
+                backoff_y = doY ? ABS(endstop_backoff[Y_AXIS]) * (Y_HOME_DIR) : 0,
+                backoff_z = doZ ? ABS(endstop_backoff[Z_AXIS]) * (Z_HOME_DIR) : 0;
+    if (backoff_z) do_blocking_move_to_z(current_position[Z_AXIS] - backoff_z);
+    if (backoff_x || backoff_y) do_blocking_move_to_xy(current_position[X_AXIS] - backoff_x, current_position[Y_AXIS] - backoff_y);
+  #endif
+
   endstops.not_homing();
 
   #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
@@ -423,23 +435,23 @@ void GcodeSuite::G28(const bool always_home_all) {
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   ui.refresh();
 
   report_current_position();
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
-      #define _HOME_SYNC true                 // For any axis, output sync text.
+      #define _HOME_SYNC true       // For any axis, output sync text.
     #else
-      #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
+      #define _HOME_SYNC doZ        // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_DRIVER(L6470)
     // Set L6470 absolute position registers to counts
     for (uint8_t j = 1; j <= L6470::chain[0]; j++) {

commit fbc7b51a24c9b8832815522c4a7cba3828207319
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 31 20:50:40 2019 -0400

    Use NO_FETCH for Dual X G28 (#13539)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 89884f87f1..f0d05d832e 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -410,21 +410,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
-    #if ENABLED(PARKING_EXTRUDER)
+    #if ENABLED(PARKING_EXTRUDER) || ENABLED(DUAL_X_CARRIAGE)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   ui.refresh();
 
   report_current_position();

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3cb4b9f9d1..89884f87f1 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -36,20 +36,24 @@
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../../feature/bltouch.h"
+#endif
+
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(QUICK_HOME)
@@ -228,21 +232,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(BLTOUCH)
-    bltouch_init();
+    bltouch.init();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6b2c0f9511..3cb4b9f9d1 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -393,21 +393,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       extruder_duplication_enabled = false;
 
       dual_x_carriage_mode         = IDEX_saved_mode;
       stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
-  #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+  #if BOTH(DELTA, DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 9b8aa2b51c..6b2c0f9511 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -42,20 +42,23 @@
 #if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
   #include "../../libs/L6470/L6470_Marlin.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../core/debug_out.h"
+
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
     sync_plan_position();
 
     const int x_axis_home_dir =
       #if ENABLED(DUAL_X_CARRIAGE)
@@ -106,64 +109,58 @@
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
       SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING);
       return;
     }
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z_SAFE_HOMING >>>");
 
     sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
       destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
     #endif
 
     if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_MSG(MSG_ZPROBE_OUT);
     }
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< Z_SAFE_HOMING");
   }
 
 #endif // Z_SAFE_HOMING
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.
@@ -175,59 +172,50 @@
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM(">>> G28");
-      log_machine_info();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_ECHOLNPGM(">>> G28");
+    log_machine_info();
+  }
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
       return;
     }
   #endif
 
   if (parser.boolval('O')) {
     if (
       #if ENABLED(HOME_AFTER_DEACTIVATE)
         all_axes_known()  // homing needed anytime steppers deactivate
       #else
         all_axes_homed()  // homing needed only if never homed
       #endif
     ) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("> homing not needed, skip");
-          SERIAL_ECHOLNPGM("<<< G28");
-        }
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> homing not needed, skip\n<<< G28");
       return;
     }
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
@@ -290,26 +278,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
     if (z_homing_height && (home_all || homeX || homeY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING))
-            SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
-        #endif
-
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
         do_blocking_move_to_z(destination[Z_AXIS]);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (home_all || (homeX && homeY)) quick_home_xy();
 
     #endif
 
@@ -444,22 +427,20 @@ void GcodeSuite::G28(const bool always_home_all) {
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true                 // For any axis, output sync text.
     #else
       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G28");
 
   #if HAS_DRIVER(L6470)
     // Set L6470 absolute position registers to counts
     for (uint8_t j = 1; j <= L6470::chain[0]; j++) {
       const uint8_t cv = L6470::chain[j];
       L6470.set_param(cv, L6470_ABS_POS, stepper.position((AxisEnum)L6470.axis_xref[cv]));
     }
   #endif
 }

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index fc5b5fedb7..9b8aa2b51c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -251,21 +251,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
-  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  #if HAS_DUPLICATION_MODE
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
 
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();

commit 5d28575d4d113aadf2f2c5a341b898e6a5b62d2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 25 14:28:01 2019 -0600

    Clean up some motion code

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 205ff7b091..fc5b5fedb7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -256,23 +256,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
-  #endif
+
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
 
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = always_home_all || parser.seen('X'),

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 149da19a8a..205ff7b091 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit c3cb449990e037ca02826596d4b54aafa51db55c
Author: mattfredwill <mattfredwill@gmail.com>
Date:   Sat Feb 2 08:09:01 2019 +0800

    TMC2130 dual-stepper Sensorless Homing (#13061)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index defb0f62e7..149da19a8a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -64,34 +64,46 @@
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_t stealth_states { false, false, false };
+      sensorless_t stealth_states { false, false, false, false, false, false, false };
       stealth_states.x = tmc_enable_stallguard(stepperX);
       stealth_states.y = tmc_enable_stallguard(stepperY);
+      #if AXIS_HAS_STALLGUARD(X2)
+        stealth_states.x2 = tmc_enable_stallguard(stepperX2);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Y2)
+        stealth_states.y2 = tmc_enable_stallguard(stepperY2);
+      #endif
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
       tmc_disable_stallguard(stepperX, stealth_states.x);
       tmc_disable_stallguard(stepperY, stealth_states.y);
+      #if AXIS_HAS_STALLGUARD(X2)
+        tmc_disable_stallguard(stepperX2, stealth_states.x2);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Y2)
+        tmc_disable_stallguard(stepperY2, stealth_states.y2);
+      #endif
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown

commit 2f35747f294c4b3dc3e6920b34e208f89bd4841d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jan 23 19:06:54 2019 -0600

    L6470 SPI daisy chain support (#12895)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 479af95835..defb0f62e7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -38,20 +38,24 @@
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
 #if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
+#if HAS_DRIVER(L6470)                         // set L6470 absolute position registers to counts
+  #include "../../libs/L6470/L6470_Marlin.h"
+#endif
+
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
     sync_plan_position();
 
     const int x_axis_home_dir =
       #if ENABLED(DUAL_X_CARRIAGE)
@@ -433,11 +437,19 @@ void GcodeSuite::G28(const bool always_home_all) {
     #else
       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
   #endif
+
+  #if HAS_DRIVER(L6470)
+    // Set L6470 absolute position registers to counts
+    for (uint8_t j = 1; j <= L6470::chain[0]; j++) {
+      const uint8_t cv = L6470::chain[j];
+      L6470.set_param(cv, L6470_ABS_POS, stepper.position((AxisEnum)L6470.axis_xref[cv]));
+    }
+  #endif
 }

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index eb4f4ef75b..479af95835 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -60,33 +60,34 @@
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_homing_per_axis(X_AXIS);
-      sensorless_homing_per_axis(Y_AXIS);
+      sensorless_t stealth_states { false, false, false };
+      stealth_states.x = tmc_enable_stallguard(stepperX);
+      stealth_states.y = tmc_enable_stallguard(stepperY);
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
 
     endstops.validate_homing_move();
 
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
-      sensorless_homing_per_axis(X_AXIS, false);
-      sensorless_homing_per_axis(Y_AXIS, false);
+      tmc_disable_stallguard(stepperX, stealth_states.x);
+      tmc_disable_stallguard(stepperY, stealth_states.y);
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 29a0e6552c..eb4f4ef75b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -85,22 +85,21 @@
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
+      SERIAL_ECHO_MSG(MSG_ERR_Z_HOMING);
       return;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
     #endif
 
     sync_plan_position();
 
     /**
@@ -128,22 +127,21 @@
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
       homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
+      SERIAL_ECHO_MSG(MSG_ZPROBE_OUT);
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
     #endif
   }
 
 #endif // Z_SAFE_HOMING
 
 /**

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 8a40e2bd61..29a0e6552c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -418,21 +418,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if ENABLED(PARKING_EXTRUDER)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
-  lcd_refresh();
+  ui.refresh();
 
   report_current_position();
   #if ENABLED(NANODLP_Z_SYNC)
     #if ENABLED(NANODLP_ALL_AXIS)
       #define _HOME_SYNC true                 // For any axis, output sync text.
     #else
       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
     #endif
     if (_HOME_SYNC)
       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);

commit 427bc64ba137907fbdbc103622ae88106a31a250
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 02:19:55 2018 -0600

    G28 O respects HOME_AFTER_DEACTIVATE
    
    Addressing #11271

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6f6ea3393a..8a40e2bd61 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -185,28 +185,36 @@ void GcodeSuite::G28(const bool always_home_all) {
       sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
       #endif
       return;
     }
   #endif
 
-  if (all_axes_known() && parser.boolval('O')) { // home only if needed
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("> homing not needed, skip");
-        SERIAL_ECHOLNPGM("<<< G28");
-      }
-    #endif
-    return;
+  if (parser.boolval('O')) {
+    if (
+      #if ENABLED(HOME_AFTER_DEACTIVATE)
+        all_axes_known()  // homing needed anytime steppers deactivate
+      #else
+        all_axes_homed()  // homing needed only if never homed
+      #endif
+    ) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOLNPGM("> homing not needed, skip");
+          SERIAL_ECHOLNPGM("<<< G28");
+        }
+      #endif
+      return;
+    }
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
     #if ENABLED(PROBE_MANUALLY)

commit 2bf18950ab2070e842c91057d5812dcaa1bff9a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 16:00:34 2018 -0500

    Refactor LCD menus

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6553fc5cfc..6f6ea3393a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -203,21 +203,20 @@ void GcodeSuite::G28(const bool always_home_all) {
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
 
     // Cancel the active G29 session
     #if ENABLED(PROBE_MANUALLY)
-      extern bool g29_in_progress;
       g29_in_progress = false;
     #endif
 
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 66054d00e5..6553fc5cfc 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -362,39 +362,42 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)
 
-    if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
+    if (dxc_is_duplicating()) {
 
       // Always home the 2nd (right) extruder first
       active_extruder = 1;
       homeaxis(X_AXIS);
 
       // Remember this extruder's position for later tool change
       inactive_extruder_x_pos = current_position[X_AXIS];
 
       // Home the 1st (left) extruder
       active_extruder = 0;
       homeaxis(X_AXIS);
 
       // Consider the active extruder to be parked
       COPY(raised_parked_position, current_position);
       delayed_move_time = 0;
       active_extruder_parked = true;
       extruder_duplication_enabled = IDEX_saved_duplication_state;
+      extruder_duplication_enabled = false;
+
       dual_x_carriage_mode         = IDEX_saved_mode;
+      stepper.set_directions();
     }
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b8cfe9b78d..66054d00e5 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -94,21 +94,21 @@
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
       return;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
     #endif
 
-    SYNC_PLAN_POSITION_KINEMATIC();
+    sync_plan_position();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
@@ -175,21 +175,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)
     bool IDEX_saved_duplication_state = extruder_duplication_enabled;
     DualXMode IDEX_saved_mode = dual_x_carriage_mode;
   #endif
 
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
-      SYNC_PLAN_POSITION_KINEMATIC();
+      sync_plan_position();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
       #endif
       return;
     }
   #endif
 
   if (all_axes_known() && parser.boolval('O')) { // home only if needed
@@ -350,21 +350,21 @@ void GcodeSuite::G28(const bool always_home_all) {
           homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
-    SYNC_PLAN_POSITION_KINEMATIC();
+    sync_plan_position();
 
   #endif // !DELTA (G28)
 
   /**
    * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
    * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
    * then print a standard GCode file that contains a single print that does a G28 and has no other
    * IDEX specific commands in it.
    */
   #if ENABLED(DUAL_X_CARRIAGE)

commit bc1ba998b20e68e9f913ddc5d9e89bd8cf11efc9
Author: Alexander Amelkin <mocbuhtig@amelkin.msk.ru>
Date:   Mon Sep 10 06:06:03 2018 +0300

    [2.0.x] Fix undefined symbol 'g29_in_progress' (#11781)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 02fe1bbedb..b8cfe9b78d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -198,28 +198,29 @@ void GcodeSuite::G28(const bool always_home_all) {
         SERIAL_ECHOLNPGM("> homing not needed, skip");
         SERIAL_ECHOLNPGM("<<< G28");
       }
     #endif
     return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
-  // Cancel the active G29 session
-  #if ENABLED(PROBE_MANUALLY)
-    extern bool g29_in_progress;
-    g29_in_progress = false;
-  #endif
-
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
+
+    // Cancel the active G29 session
+    #if ENABLED(PROBE_MANUALLY)
+      extern bool g29_in_progress;
+      g29_in_progress = false;
+    #endif
+
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 

commit bad225dc04b8484a87726383edbbcc98e07f9195
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Sep 9 05:19:48 2018 -0400

    Fix mesh leveling compile errors (#11768)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b1845ee79b..02fe1bbedb 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -200,20 +200,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       }
     #endif
     return;
   }
 
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
+    extern bool g29_in_progress;
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
@@ -390,21 +391,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  #if ENABLED(RESTORE_LEVELING_AFTER_G28)
+  #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if ENABLED(PARKING_EXTRUDER)
       #define NO_FETCH false // fetch the previous toolhead
     #else

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2a303e5e65..b1845ee79b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -352,52 +352,50 @@ void GcodeSuite::G28(const bool always_home_all) {
           move_z_after_probing();
         #endif
 
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
-/**
- * 
- * This code block allows the DXC mode to survive (and function) across a G28 if it is an IDEX
- * machine and the printer is currently in DXC_DUPLICATION_MODE.
- * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and 
- * then print a standard GCode file that contains a single print that does a G28 and has no other
- * IDEX specific commands in it.
- * 
- **/
-
+  /**
+   * Preserve DXC mode across a G28 for IDEX printers in DXC_DUPLICATION_MODE.
+   * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and
+   * then print a standard GCode file that contains a single print that does a G28 and has no other
+   * IDEX specific commands in it.
+   */
   #if ENABLED(DUAL_X_CARRIAGE)
+
     if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
 
-        // Always home the 2nd (right) extruder first
-        active_extruder = 1;
-        homeaxis(X_AXIS);
+      // Always home the 2nd (right) extruder first
+      active_extruder = 1;
+      homeaxis(X_AXIS);
 
-        // Remember this extruder's position for later tool change
-        inactive_extruder_x_pos = current_position[X_AXIS];
+      // Remember this extruder's position for later tool change
+      inactive_extruder_x_pos = current_position[X_AXIS];
 
-        // Home the 1st (left) extruder
-        active_extruder = 0;
-        homeaxis(X_AXIS);
+      // Home the 1st (left) extruder
+      active_extruder = 0;
+      homeaxis(X_AXIS);
 
-        // Consider the active extruder to be parked
-        COPY(raised_parked_position, current_position);
-        delayed_move_time = 0;
-        active_extruder_parked = true;
-        extruder_duplication_enabled = IDEX_saved_duplication_state;
-        dual_x_carriage_mode         = IDEX_saved_mode;
+      // Consider the active extruder to be parked
+      COPY(raised_parked_position, current_position);
+      delayed_move_time = 0;
+      active_extruder_parked = true;
+      extruder_duplication_enabled = IDEX_saved_duplication_state;
+      dual_x_carriage_mode         = IDEX_saved_mode;
     }
-  #endif
+
+  #endif // DUAL_X_CARRIAGE
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index ffd81c1ead..2a303e5e65 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -167,20 +167,25 @@
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPGM(">>> G28");
       log_machine_info();
     }
   #endif
 
+  #if ENABLED(DUAL_X_CARRIAGE)
+    bool IDEX_saved_duplication_state = extruder_duplication_enabled;
+    DualXMode IDEX_saved_mode = dual_x_carriage_mode;
+  #endif
+
   #if ENABLED(MARLIN_DEV_MODE)
     if (parser.seen('S')) {
       LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
       SYNC_PLAN_POSITION_KINEMATIC();
       SERIAL_ECHOLNPGM("Simulated Homing");
       report_current_position();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
       #endif
       return;
@@ -222,21 +227,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
-  #if ENABLED(DUAL_X_CARRIAGE)
+  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   #endif
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)
@@ -347,20 +352,53 @@ void GcodeSuite::G28(const bool always_home_all) {
           move_z_after_probing();
         #endif
 
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
+/**
+ * 
+ * This code block allows the DXC mode to survive (and function) across a G28 if it is an IDEX
+ * machine and the printer is currently in DXC_DUPLICATION_MODE.
+ * This is important because it lets a user use the LCD Panel to set an IDEX Duplication mode, and 
+ * then print a standard GCode file that contains a single print that does a G28 and has no other
+ * IDEX specific commands in it.
+ * 
+ **/
+
+  #if ENABLED(DUAL_X_CARRIAGE)
+    if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
+
+        // Always home the 2nd (right) extruder first
+        active_extruder = 1;
+        homeaxis(X_AXIS);
+
+        // Remember this extruder's position for later tool change
+        inactive_extruder_x_pos = current_position[X_AXIS];
+
+        // Home the 1st (left) extruder
+        active_extruder = 0;
+        homeaxis(X_AXIS);
+
+        // Consider the active extruder to be parked
+        COPY(raised_parked_position, current_position);
+        delayed_move_time = 0;
+        active_extruder_parked = true;
+        extruder_duplication_enabled = IDEX_saved_duplication_state;
+        dual_x_carriage_mode         = IDEX_saved_mode;
+    }
+  #endif
+
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_was_active);
   #endif

commit 593d5375eaf51f6c313c7d6b7a5edfa3a9e46a97
Author: Colin Gilgenbach <colin@gilgenbach.net>
Date:   Tue Aug 21 22:42:55 2018 -0600

    Fix G28 resetting DUAL_NOZZLE_DUPLICATION_MODE (#11605)
    
    There's no reason for G28 to reset DUAL_NOZZLE_DUPLICATION_MODE, because it only affects the E stepper, unlike DUAL_X_CARRIAGE which affects the X steppers as well.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c512edde0c..ffd81c1ead 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -222,21 +222,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
-  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  #if ENABLED(DUAL_X_CARRIAGE)
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   #endif
   endstops.enable(true); // Enable endstops for next homing move
 
   #if ENABLED(DELTA)

commit 4237c3d9f88b3b2b9d6c43e3e51964f404f154f0
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 26 12:04:09 2018 +0200

    [2.0.x] different bltouch init (#11135)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index d88fd91bf7..c512edde0c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -211,22 +211,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(BLTOUCH)
-    bltouch_command(BLTOUCH_RESET);
-    set_bltouch_deployed(false);
+    bltouch_init();
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 

commit e0ab8acf198648f731074f9b14f3562b55c5dd5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 2 22:27:05 2018 -0500

    Add "Marlin Dev Mode" option

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 26cf2b0974..d88fd91bf7 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -167,20 +167,33 @@
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPGM(">>> G28");
       log_machine_info();
     }
   #endif
 
+  #if ENABLED(MARLIN_DEV_MODE)
+    if (parser.seen('S')) {
+      LOOP_XYZ(a) set_axis_is_at_home((AxisEnum)a);
+      SYNC_PLAN_POSITION_KINEMATIC();
+      SERIAL_ECHOLNPGM("Simulated Homing");
+      report_current_position();
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
+      #endif
+      return;
+    }
+  #endif
+
   if (all_axes_known() && parser.boolval('O')) { // home only if needed
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("> homing not needed, skip");
         SERIAL_ECHOLNPGM("<<< G28");
       }
     #endif
     return;
   }
 

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 166f4651e3..26cf2b0974 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -65,21 +65,23 @@
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(X_AXIS);
       sensorless_homing_per_axis(Y_AXIS);
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
-    endstops.hit_on_purpose(); // clear endstop hit flags
+
+    endstops.validate_homing_move();
+
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(X_AXIS, false);
       sensorless_homing_per_axis(Y_AXIS, false);
     #endif
   }
 
 #endif // QUICK_HOME
 

commit 90ba77ea0fcaabe604aff9190d42595dd3bb9f2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 30 18:13:13 2018 -0500

    Lose the old HOMEAXIS macro

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 191c2d20ec..166f4651e3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -122,21 +122,21 @@
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
       #if ENABLED(SENSORLESS_HOMING)
         safe_delay(500); // Short delay needed to settle
       #endif
 
       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
-      HOMEAXIS(Z);
+      homeaxis(Z_AXIS);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
     #endif
@@ -234,21 +234,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     const bool homeX = always_home_all || parser.seen('X'),
                homeY = always_home_all || parser.seen('Y'),
                homeZ = always_home_all || parser.seen('Z'),
                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
-      if (home_all || homeZ) HOMEAXIS(Z);
+      if (home_all || homeZ) homeaxis(Z_AXIS);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
@@ -272,68 +272,68 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     #endif
 
     // Home Y (before X)
     #if ENABLED(HOME_Y_BEFORE_X)
 
       if (home_all || homeY
         #if ENABLED(CODEPENDENT_XY_HOMING)
           || homeX
         #endif
-      ) HOMEAXIS(Y);
+      ) homeaxis(Y_AXIS);
 
     #endif
 
     // Home X
     if (home_all || homeX
       #if ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X)
         || homeY
       #endif
     ) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
-        HOMEAXIS(X);
+        homeaxis(X_AXIS);
 
         // Remember this extruder's position for later tool change
         inactive_extruder_x_pos = current_position[X_AXIS];
 
         // Home the 1st (left) extruder
         active_extruder = 0;
-        HOMEAXIS(X);
+        homeaxis(X_AXIS);
 
         // Consider the active extruder to be parked
         COPY(raised_parked_position, current_position);
         delayed_move_time = 0;
         active_extruder_parked = true;
 
       #else
 
-        HOMEAXIS(X);
+        homeaxis(X_AXIS);
 
       #endif
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
-      if (home_all || homeY) HOMEAXIS(Y);
+      if (home_all || homeY) homeaxis(Y_AXIS);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
-          HOMEAXIS(Z);
+          homeaxis(Z_AXIS);
         #endif
 
         #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();

commit cce0523a953f41873195946fbaa4099b85110d97
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Wed Jun 13 21:09:13 2018 +0200

    [2.0.x] reset bltouch on home (#11018)
    
    Added reset bltouch instead. This ensure properly stow even when in error.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7a0f835939..191c2d20ec 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -196,20 +196,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   #if ENABLED(BLTOUCH)
+    bltouch_command(BLTOUCH_RESET);
     set_bltouch_deployed(false);
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif

commit e0276d2f329e15f8f77b1684fcb1724d29db8609
Author: Karl Andersson <karl@iaccess.se>
Date:   Wed Jun 13 01:38:00 2018 +0200

    Official STMicroelectronics Arduino Core STM32F4 HAL compatibility (#11006)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 2a57b52f34..7a0f835939 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -174,21 +174,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   if (all_axes_known() && parser.boolval('O')) { // home only if needed
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("> homing not needed, skip");
         SERIAL_ECHOLNPGM("<<< G28");
       }
     #endif
     return;
   }
-  
+
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4535621688..2a57b52f34 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -81,21 +81,21 @@
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
-    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
+    if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
       return;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
     #endif
 
@@ -165,21 +165,21 @@
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPGM(">>> G28");
       log_machine_info();
     }
   #endif
 
-  if ((axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) && parser.boolval('O')) { // home only if needed
+  if (all_axes_known() && parser.boolval('O')) { // home only if needed
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPGM("> homing not needed, skip");
         SERIAL_ECHOLNPGM("<<< G28");
       }
     #endif
     return;
   }
   
   // Wait for planner moves to finish!
@@ -239,21 +239,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (home_all || homeZ) HOMEAXIS(Z);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
-        !axis_known_position[Z_AXIS] ? 0 :
+        !TEST(axis_known_position, Z_AXIS) ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
 
     if (z_homing_height && (home_all || homeX || homeY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 86170e6a66b115ab6fa4def988e8154f729c0900
Author: Robert Mendon <gibben@gmail.com>
Date:   Mon Jun 11 20:51:48 2018 -0600

    [2.0.x] Add O (optional) flag to G28/G29 (#10913)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c80d106d76..4535621688 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -145,38 +145,50 @@
 #endif // Z_SAFE_HOMING
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.
  *        With QUICK_HOME enabled XY will home together, then Z.
  *
+ *  O   Home only if position is unknown
+ *
  *  Rn  Raise by n mm/inches before homing
  *
  * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPGM(">>> G28");
       log_machine_info();
     }
   #endif
 
+  if ((axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) && parser.boolval('O')) { // home only if needed
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("> homing not needed, skip");
+        SERIAL_ECHOLNPGM("<<< G28");
+      }
+    #endif
+    return;
+  }
+  
   // Wait for planner moves to finish!
   planner.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING

commit f1cdfe3dfd06a130387cd62e887094573802832f
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Sun Jun 10 23:27:14 2018 +0200

    [2.0.x] stow bltouch before start homing (#10987)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c299a119ad..c80d106d76 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -32,21 +32,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
-#if HOMING_Z_WITH_PROBE
+#if HOMING_Z_WITH_PROBE || ENABLED(BLTOUCH)
   #include "../../module/probe.h"
 #endif
 
 #include "../../lcd/ultralcd.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
@@ -183,20 +183,24 @@ void GcodeSuite::G28(const bool always_home_all) {
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
+  #if ENABLED(BLTOUCH)
+    set_bltouch_deployed(false);
+  #endif
+
   // Always home with tool 0 active
   #if HOTENDS > 1
     #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
       const uint8_t old_tool_index = active_extruder;
     #endif
     tool_change(0, 0, true);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
     extruder_duplication_enabled = false;

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index a0bce4731c..c299a119ad 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -57,21 +57,21 @@
       #if ENABLED(DUAL_X_CARRIAGE)
         x_home_dir(active_extruder)
       #else
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
-                fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+                fr_mm_s = MIN(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(X_AXIS);
       sensorless_homing_per_axis(Y_AXIS);
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 043179c931..a0bce4731c 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -164,21 +164,21 @@
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPGM(">>> G28");
       log_machine_info();
     }
   #endif
 
   // Wait for planner moves to finish!
-  stepper.synchronize();
+  planner.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
       const bool leveling_was_active = planner.leveling_active;

commit 59fda986ea429c83b0e20cd8b1a172fd2a550852
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:25:47 2018 -0500

    Allow Z_AFTER_PROBING to be 0

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 510262bd03..043179c931 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -305,21 +305,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           HOMEAXIS(Z);
         #endif
 
-        #if HOMING_Z_WITH_PROBE && Z_AFTER_PROBING
+        #if HOMING_Z_WITH_PROBE && defined(Z_AFTER_PROBING)
           move_z_after_probing();
         #endif
 
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 

commit f423e54f77d82bc2d70e035ec4a6f8d50ce6f6f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 23 18:00:06 2018 -0500

    Strip trailing spaces

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 17f3ea7474..510262bd03 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -227,21 +227,21 @@ void GcodeSuite::G28(const bool always_home_all) {
       if (home_all || homeZ) HOMEAXIS(Z);
 
     #endif
 
     const float z_homing_height = (
       #if ENABLED(UNKNOWN_Z_NO_RAISE)
         !axis_known_position[Z_AXIS] ? 0 :
       #endif
           (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
     );
- 
+
     if (z_homing_height && (home_all || homeX || homeY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING))
             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
         #endif
 

commit 1c3d49afe0228668edb174acd1be5ff48cbf6c5f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 22 01:23:26 2018 -0500

    Fix G28 with Z_AFTER_PROBING
    
    Fix #10476

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 5fc0aaf15a..17f3ea7474 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -304,24 +304,26 @@ void GcodeSuite::G28(const bool always_home_all) {
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           HOMEAXIS(Z);
         #endif
+
+        #if HOMING_Z_WITH_PROBE && Z_AFTER_PROBING
+          move_z_after_probing();
+        #endif
+
       } // home_all || homeZ
-      #if HOMING_Z_WITH_PROBE && Z_AFTER_PROBING
-        move_z_after_probing();
-      #endif
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area

commit 7dcd0a1cffd1d3d1652a4a1aa70068162a2b566a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 21 19:07:48 2018 -0500

    Add R parameter to G28 to specify pre-raise

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 0416ad6d41..5fc0aaf15a 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -145,21 +145,23 @@
 #endif // Z_SAFE_HOMING
 
 /**
  * G28: Home all axes according to settings
  *
  * Parameters
  *
  *  None  Home to all axes with no parameters.
  *        With QUICK_HOME enabled XY will home together, then Z.
  *
- * Cartesian parameters
+ *  Rn  Raise by n mm/inches before homing
+ *
+ * Cartesian/SCARA parameters
  *
  *  X   Home to the X endstop
  *  Y   Home to the Y endstop
  *  Z   Home to the Z endstop
  *
  */
 void GcodeSuite::G28(const bool always_home_all) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
@@ -219,26 +221,27 @@ void GcodeSuite::G28(const bool always_home_all) {
                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (home_all || homeZ) HOMEAXIS(Z);
 
     #endif
 
-    #if ENABLED(UNKNOWN_Z_NO_RAISE)
-      const float z_homing_height = axis_known_position[Z_AXIS] ? Z_HOMING_HEIGHT : 0;
-    #else
-      constexpr float z_homing_height = Z_HOMING_HEIGHT;
-    #endif
-
+    const float z_homing_height = (
+      #if ENABLED(UNKNOWN_Z_NO_RAISE)
+        !axis_known_position[Z_AXIS] ? 0 :
+      #endif
+          (parser.seenval('R') ? parser.value_linear_units() : Z_HOMING_HEIGHT)
+    );
+ 
     if (z_homing_height && (home_all || homeX || homeY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING))
             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
         #endif
 

commit 1a75165f35f6466738590643bc2c9df8a68c8c52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 18:16:20 2018 -0500

    For set_z_fade_height use set_bed_leveling_enabled

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 221195c8f0..0416ad6d41 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -172,21 +172,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   stepper.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     #if ENABLED(RESTORE_LEVELING_AFTER_G28)
-      const bool leveling_state_at_entry = planner.leveling_active;
+      const bool leveling_was_active = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
@@ -319,21 +319,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if ENABLED(RESTORE_LEVELING_AFTER_G28)
-    set_bed_leveling_enabled(leveling_state_at_entry);
+    set_bed_leveling_enabled(leveling_was_active);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if ENABLED(PARKING_EXTRUDER)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true

commit c1f58a238d93e40c155275285c00b3d46b03bebe
Author: AnHardt <github@kitelab.de>
Date:   Thu Mar 29 23:10:20 2018 +0200

    No delay in sensorless quick homing (#10254)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c6231c5985..221195c8f0 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -71,21 +71,20 @@
       sensorless_homing_per_axis(Y_AXIS);
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
       sensorless_homing_per_axis(X_AXIS, false);
       sensorless_homing_per_axis(Y_AXIS, false);
-      safe_delay(500); // Short delay needed to settle
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown

commit bc45fb6b131598403c8fdc5089697d98dc878299
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:08:44 2018 -0500

    Tweak use of move_z_after_probing

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index e15ddb5e58..c6231c5985 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -303,21 +303,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           HOMEAXIS(Z);
         #endif
       } // home_all || homeZ
-      #if HOMING_Z_WITH_PROBE
+      #if HOMING_Z_WITH_PROBE && Z_AFTER_PROBING
         move_z_after_probing();
       #endif
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 

commit a6feb58837fa97167f5340abaa7b1175ca858450
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 16 00:46:42 2018 -0500

    Delta support for multiple hotends with offsets (#10118)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 44950b7868..e15ddb5e58 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -184,21 +184,23 @@ void GcodeSuite::G28(const bool always_home_all) {
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
-    const uint8_t old_tool_index = active_extruder;
+    #if DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+      const uint8_t old_tool_index = active_extruder;
+    #endif
     tool_change(0, 0, true);
   #endif
 
   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
     extruder_duplication_enabled = false;
   #endif
 
   setup_for_endstop_or_probe_move();
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
@@ -324,21 +326,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
   #if ENABLED(RESTORE_LEVELING_AFTER_G28)
     set_bed_leveling_enabled(leveling_state_at_entry);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
-  #if HOTENDS > 1
+  #if HOTENDS > 1 && (DISABLED(DELTA) || ENABLED(DELTA_HOME_TO_SAFE_ZONE))
     #if ENABLED(PARKING_EXTRUDER)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   lcd_refresh();
 

commit 28f1276286da94f4a1b3a7bffa103a35a3ee8352
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 11 13:07:55 2018 -0500

    [2.0.x] Add Z_AFTER_PROBING option (#10058)
    
    Some "fix-mounted" probes need manual stowing. And after probing some may prefer to raise or lower the nozzle. This restores an old option but tailors it to allow raise or lower as preferred.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index f76a45f6ed..44950b7868 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -32,20 +32,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "../../feature/tmc_util.h"
 #endif
 
+#if HOMING_Z_WITH_PROBE
+  #include "../../module/probe.h"
+#endif
+
 #include "../../lcd/ultralcd.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
     sync_plan_position();
 
@@ -297,20 +301,23 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           HOMEAXIS(Z);
         #endif
       } // home_all || homeZ
+      #if HOMING_Z_WITH_PROBE
+        move_z_after_probing();
+      #endif
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area

commit 419d12ca1be19d1792db05062b4fa2808b05d165
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 23:18:47 2018 -0600

    Add UNKNOWN_Z_NO_RAISE option
    
    With this option enabled, Z won't ever be raised until after `G28` has been completed, and it won't raise if Z becomes unknown. This is good for machines whose beds fall when Z is powered off.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 92526e1020..f76a45f6ed 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -214,23 +214,29 @@ void GcodeSuite::G28(const bool always_home_all) {
                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (home_all || homeZ) HOMEAXIS(Z);
 
     #endif
 
-    if (home_all || homeX || homeY) {
+    #if ENABLED(UNKNOWN_Z_NO_RAISE)
+      const float z_homing_height = axis_known_position[Z_AXIS] ? Z_HOMING_HEIGHT : 0;
+    #else
+      constexpr float z_homing_height = Z_HOMING_HEIGHT;
+    #endif
+
+    if (z_homing_height && (home_all || homeX || homeY)) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
-      destination[Z_AXIS] = Z_HOMING_HEIGHT;
+      destination[Z_AXIS] = z_homing_height;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING))
             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
         #endif
 
         do_blocking_move_to_z(destination[Z_AXIS]);
       }
     }

commit a446433c87dc8b715ed5b9d98a34104f90b676b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 1 01:37:31 2018 -0600

    Fix SENSORLESS_HOMING for Core Kinematics (#9868)

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 3ab978dc84..92526e1020 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -56,39 +56,31 @@
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     #if ENABLED(SENSORLESS_HOMING)
-      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
-        tmc_sensorless_homing(stepperX);
-      #endif
-      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
-        tmc_sensorless_homing(stepperY);
-      #endif
+      sensorless_homing_per_axis(X_AXIS);
+      sensorless_homing_per_axis(Y_AXIS);
     #endif
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
 
     #if ENABLED(SENSORLESS_HOMING)
-      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
-        tmc_sensorless_homing(stepperX, false);
-      #endif
-      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
-        tmc_sensorless_homing(stepperY, false);
-      #endif
+      sensorless_homing_per_axis(X_AXIS, false);
+      sensorless_homing_per_axis(Y_AXIS, false);
       safe_delay(500); // Short delay needed to settle
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 

commit b2cf253a13ba36baa681032e4e02639d23ff3774
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 23 12:41:00 2018 -0600

    Add RESTORE_LEVELING_AFTER_G28 option

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 5bc414b4ec..3ab978dc84 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -176,22 +176,22 @@ void GcodeSuite::G28(const bool always_home_all) {
   // Wait for planner moves to finish!
   stepper.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const bool ubl_state_at_entry = planner.leveling_active;
+    #if ENABLED(RESTORE_LEVELING_AFTER_G28)
+      const bool leveling_state_at_entry = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1
@@ -312,22 +312,22 @@ void GcodeSuite::G28(const bool always_home_all) {
 
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
     // move to a height where we can use the full xy-area
     do_blocking_move_to_z(delta_clip_start_height);
   #endif
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    set_bed_leveling_enabled(ubl_state_at_entry);
+  #if ENABLED(RESTORE_LEVELING_AFTER_G28)
+    set_bed_leveling_enabled(leveling_state_at_entry);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1
     #if ENABLED(PARKING_EXTRUDER)
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true

commit 1d7f5be0ff3728637f2fc5fae2d3af719ae6901d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 20 19:44:02 2018 -0600

    quick_home_xy sensorless homing

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 853d28c79d..5bc414b4ec 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -28,20 +28,24 @@
 #include "../../module/endstops.h"
 
 #if HOTENDS > 1
   #include "../../module/tool_change.h"
 #endif
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(SENSORLESS_HOMING)
+  #include "../../feature/tmc_util.h"
+#endif
+
 #include "../../lcd/ultralcd.h"
 
 #if ENABLED(QUICK_HOME)
 
   static void quick_home_xy() {
 
     // Pretend the current position is 0,0
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
     sync_plan_position();
 
@@ -51,24 +55,40 @@
       #else
         home_dir(X_AXIS)
       #endif
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
+    #if ENABLED(SENSORLESS_HOMING)
+      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+        tmc_sensorless_homing(stepperX);
+      #endif
+      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+        tmc_sensorless_homing(stepperY);
+      #endif
+    #endif
+
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+
     #if ENABLED(SENSORLESS_HOMING)
+      #if ENABLED(X_IS_TMC2130) && defined(X_HOMING_SENSITIVITY)
+        tmc_sensorless_homing(stepperX, false);
+      #endif
+      #if ENABLED(Y_IS_TMC2130) && defined(Y_HOMING_SENSITIVITY)
+        tmc_sensorless_homing(stepperY, false);
+      #endif
       safe_delay(500); // Short delay needed to settle
     #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 

commit d4e4fe40e0ec9013c0a1fbe8781a0802b6b3f9d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 10:11:11 2018 -0600

    Add SENSORLESS_HOMING delay to quick_home_xy
    
    Fix #9471

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 88f021b265..853d28c79d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -54,20 +54,23 @@
     ;
 
     const float mlx = max_length(X_AXIS),
                 mly = max_length(Y_AXIS),
                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
                 fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+    #if ENABLED(SENSORLESS_HOMING)
+      safe_delay(500); // Short delay needed to settle
+    #endif
   }
 
 #endif // QUICK_HOME
 
 #if ENABLED(Z_SAFE_HOMING)
 
   inline void home_z_safely() {
 
     // Disallow Z homing if X or Y are unknown
     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {

commit 3af988a7f3646309927066d5a8c48551a8720b0a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 18 19:28:40 2018 -0600

    Add sensorless homing delay to home_z_safely
    
    Based on #9705

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index de6bcd321d..88f021b265 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -99,20 +99,24 @@
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
       #endif
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
+      #if ENABLED(SENSORLESS_HOMING)
+        safe_delay(500); // Short delay needed to settle
+      #endif
+
       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
       HOMEAXIS(Z);
     }
     else {
       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
       SERIAL_ECHO_START();
       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 8ffa0b24a47ab888beed06ab0b4bf0ced63116e5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 18 00:51:37 2018 -0600

    Strip excess G28 debug logging

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 5f3e7bfd8b..de6bcd321d 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -191,26 +191,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     const bool homeX = always_home_all || parser.seen('X'),
                homeY = always_home_all || parser.seen('Y'),
                homeZ = always_home_all || parser.seen('Z'),
                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
     set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
-      if (home_all || homeZ) {
-        HOMEAXIS(Z);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
-        #endif
-      }
+      if (home_all || homeZ) HOMEAXIS(Z);
 
     #endif
 
     if (home_all || homeX || homeY) {
       // Raise Z before homing any other axes and z is not already high enough (never lower z)
       destination[Z_AXIS] = Z_HOMING_HEIGHT;
       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING))
@@ -227,26 +222,21 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     #endif
 
     // Home Y (before X)
     #if ENABLED(HOME_Y_BEFORE_X)
 
       if (home_all || homeY
         #if ENABLED(CODEPENDENT_XY_HOMING)
           || homeX
         #endif
-      ) {
-        HOMEAXIS(Y);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
-        #endif
-      }
+      ) HOMEAXIS(Y);
 
     #endif
 
     // Home X
     if (home_all || homeX
       #if ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X)
         || homeY
       #endif
     ) {
 
@@ -266,47 +256,35 @@ void GcodeSuite::G28(const bool always_home_all) {
         // Consider the active extruder to be parked
         COPY(raised_parked_position, current_position);
         delayed_move_time = 0;
         active_extruder_parked = true;
 
       #else
 
         HOMEAXIS(X);
 
       #endif
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
-      #endif
     }
 
     // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
-      if (home_all || homeY) {
-        HOMEAXIS(Y);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
-        #endif
-      }
+      if (home_all || homeY) HOMEAXIS(Y);
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0
       if (home_all || homeZ) {
         #if ENABLED(Z_SAFE_HOMING)
           home_z_safely();
         #else
           HOMEAXIS(Z);
         #endif
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
-        #endif
       } // home_all || homeZ
     #endif // Z_HOME_DIR < 0
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
   #endif // !DELTA (G28)
 
   endstops.not_homing();
 
   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)

commit 9019ea0fce853e02c6ef860e18ca944b8b1084ae
Author: Kevin <kevinbayer8@gmail.com>
Date:   Fri Feb 16 16:59:44 2018 +0100

    Option to force X or Y to home first when homing the other axis

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 7368314942..5f3e7bfd8b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -220,34 +220,42 @@ void GcodeSuite::G28(const bool always_home_all) {
         do_blocking_move_to_z(destination[Z_AXIS]);
       }
     }
 
     #if ENABLED(QUICK_HOME)
 
       if (home_all || (homeX && homeY)) quick_home_xy();
 
     #endif
 
+    // Home Y (before X)
     #if ENABLED(HOME_Y_BEFORE_X)
 
-      // Home Y
-      if (home_all || homeY) {
+      if (home_all || homeY
+        #if ENABLED(CODEPENDENT_XY_HOMING)
+          || homeX
+        #endif
+      ) {
         HOMEAXIS(Y);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
         #endif
       }
 
     #endif
 
     // Home X
-    if (home_all || homeX) {
+    if (home_all || homeX
+      #if ENABLED(CODEPENDENT_XY_HOMING) && DISABLED(HOME_Y_BEFORE_X)
+        || homeY
+      #endif
+    ) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         HOMEAXIS(X);
 
         // Remember this extruder's position for later tool change
         inactive_extruder_x_pos = current_position[X_AXIS];
 
@@ -264,22 +272,22 @@ void GcodeSuite::G28(const bool always_home_all) {
 
         HOMEAXIS(X);
 
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
       #endif
     }
 
+    // Home Y (after X)
     #if DISABLED(HOME_Y_BEFORE_X)
-      // Home Y
       if (home_all || homeY) {
         HOMEAXIS(Y);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
         #endif
       }
     #endif
 
     // Home Z last if homing towards the bed
     #if Z_HOME_DIR < 0

commit 5595098063175645ca36141d5c050b0ff5c0fe7d
Author: robpower <dev@robpower.info>
Date:   Fri Dec 15 20:34:41 2017 +0100

    V2 Extended NanoDLP_Z_Move_Sync to G4 & G28,Added all axis option.

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index d641a08d22..7368314942 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -318,15 +318,24 @@ void GcodeSuite::G28(const bool always_home_all) {
       #define NO_FETCH false // fetch the previous toolhead
     #else
       #define NO_FETCH true
     #endif
     tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   lcd_refresh();
 
   report_current_position();
+  #if ENABLED(NANODLP_Z_SYNC)
+    #if ENABLED(NANODLP_ALL_AXIS)
+      #define _HOME_SYNC true                 // For any axis, output sync text.
+    #else
+      #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
+    #endif
+    if (_HOME_SYNC)
+      SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
+  #endif
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
   #endif
 }

commit 9e3fbcf35cd347c3dcbdc0a0b7755f52bb401917
Author: revilor <oliver.rossmueller@web.de>
Date:   Wed Dec 6 02:40:36 2017 +0100

    fix for #8669 (#8679)
    
    * fix for #8669
    
    * Update G28.cpp

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index c33d08b14b..d641a08d22 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -198,37 +198,35 @@ void GcodeSuite::G28(const bool always_home_all) {
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (home_all || homeZ) {
         HOMEAXIS(Z);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
         #endif
       }
 
-    #else
+    #endif
 
-      if (home_all || homeX || homeY) {
-        // Raise Z before homing any other axes and z is not already high enough (never lower z)
-        destination[Z_AXIS] = Z_HOMING_HEIGHT;
-        if (destination[Z_AXIS] > current_position[Z_AXIS]) {
+    if (home_all || homeX || homeY) {
+      // Raise Z before homing any other axes and z is not already high enough (never lower z)
+      destination[Z_AXIS] = Z_HOMING_HEIGHT;
+      if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING))
-              SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
-          #endif
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING))
+            SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
+        #endif
 
-          do_blocking_move_to_z(destination[Z_AXIS]);
-        }
+        do_blocking_move_to_z(destination[Z_AXIS]);
       }
-
-    #endif
+    }
 
     #if ENABLED(QUICK_HOME)
 
       if (home_all || (homeX && homeY)) quick_home_xy();
 
     #endif
 
     #if ENABLED(HOME_Y_BEFORE_X)
 
       // Home Y

commit 22b897e77d926ca4767f9c78ef82a52e8b7088b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 25 20:45:43 2017 -0600

    Show M211 output with workspace offset

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 4866794a2e..c33d08b14b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -309,27 +309,26 @@ void GcodeSuite::G28(const bool always_home_all) {
   #endif
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     set_bed_leveling_enabled(ubl_state_at_entry);
   #endif
 
   clean_up_after_endstop_or_probe_move();
 
   // Restore the active tool after homing
   #if HOTENDS > 1
-    tool_change(old_tool_index, 0,
-      #if ENABLED(PARKING_EXTRUDER)
-        false // fetch the previous toolhead
-      #else
-        true
-      #endif
-    );
+    #if ENABLED(PARKING_EXTRUDER)
+      #define NO_FETCH false // fetch the previous toolhead
+    #else
+      #define NO_FETCH true
+    #endif
+    tool_change(old_tool_index, 0, NO_FETCH);
   #endif
 
   lcd_refresh();
 
   report_current_position();
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
   #endif
 }

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index b3fefd4c4e..4866794a2e 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -79,30 +79,30 @@
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
     #endif
 
     SYNC_PLAN_POSITION_KINEMATIC();
 
     /**
      * Move the Z probe (or just the nozzle) to the safe homing point
      */
-    destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
-    destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
+    destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
+    destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
 
     #if HOMING_Z_WITH_PROBE
       destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
       destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
     #endif
 
-    if (position_is_reachable_xy(destination[X_AXIS], destination[Y_AXIS])) {
+    if (position_is_reachable(destination[X_AXIS], destination[Y_AXIS])) {
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
       #endif
 
       // This causes the carriage on Dual X to unpark
       #if ENABLED(DUAL_X_CARRIAGE)
         active_extruder_parked = false;
       #endif
 
@@ -202,21 +202,21 @@ void GcodeSuite::G28(const bool always_home_all) {
         HOMEAXIS(Z);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
         #endif
       }
 
     #else
 
       if (home_all || homeX || homeY) {
         // Raise Z before homing any other axes and z is not already high enough (never lower z)
-        destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
+        destination[Z_AXIS] = Z_HOMING_HEIGHT;
         if (destination[Z_AXIS] > current_position[Z_AXIS]) {
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING))
               SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
           #endif
 
           do_blocking_move_to_z(destination[Z_AXIS]);
         }
       }
@@ -244,21 +244,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     // Home X
     if (home_all || homeX) {
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         // Always home the 2nd (right) extruder first
         active_extruder = 1;
         HOMEAXIS(X);
 
         // Remember this extruder's position for later tool change
-        inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
+        inactive_extruder_x_pos = current_position[X_AXIS];
 
         // Home the 1st (left) extruder
         active_extruder = 0;
         HOMEAXIS(X);
 
         // Consider the active extruder to be parked
         COPY(raised_parked_position, current_position);
         delayed_move_time = 0;
         active_extruder_parked = true;
 

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index effa484d2b..b3fefd4c4e 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -187,21 +187,21 @@ void GcodeSuite::G28(const bool always_home_all) {
     home_delta();
     UNUSED(always_home_all);
 
   #else // NOT DELTA
 
     const bool homeX = always_home_all || parser.seen('X'),
                homeY = always_home_all || parser.seen('Y'),
                homeZ = always_home_all || parser.seen('Z'),
                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
-    set_destination_to_current();
+    set_destination_from_current();
 
     #if Z_HOME_DIR > 0  // If homing away from BED do Z first
 
       if (home_all || homeZ) {
         HOMEAXIS(Z);
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
         #endif
       }
 

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index d960088bbb..effa484d2b 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -150,21 +150,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   stepper.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const bool ubl_state_at_entry = LEVELING_IS_ACTIVE();
+      const bool ubl_state_at_entry = planner.leveling_active;
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index df4109a03b..d960088bbb 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -150,21 +150,21 @@ void GcodeSuite::G28(const bool always_home_all) {
   stepper.synchronize();
 
   // Cancel the active G29 session
   #if ENABLED(PROBE_MANUALLY)
     g29_in_progress = false;
   #endif
 
   // Disable the leveling matrix before homing
   #if HAS_LEVELING
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const bool ubl_state_at_entry = leveling_is_active();
+      const bool ubl_state_at_entry = LEVELING_IS_ACTIVE();
     #endif
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(CNC_WORKSPACE_PLANES)
     workspace_plane = PLANE_XY;
   #endif
 
   // Always home with tool 0 active
   #if HOTENDS > 1

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
new file mode 100644
index 0000000000..df4109a03b
--- /dev/null
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -0,0 +1,335 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#include "../gcode.h"
+
+#include "../../module/stepper.h"
+#include "../../module/endstops.h"
+
+#if HOTENDS > 1
+  #include "../../module/tool_change.h"
+#endif
+
+#if HAS_LEVELING
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+#include "../../lcd/ultralcd.h"
+
+#if ENABLED(QUICK_HOME)
+
+  static void quick_home_xy() {
+
+    // Pretend the current position is 0,0
+    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+    sync_plan_position();
+
+    const int x_axis_home_dir =
+      #if ENABLED(DUAL_X_CARRIAGE)
+        x_home_dir(active_extruder)
+      #else
+        home_dir(X_AXIS)
+      #endif
+    ;
+
+    const float mlx = max_length(X_AXIS),
+                mly = max_length(Y_AXIS),
+                mlratio = mlx > mly ? mly / mlx : mlx / mly,
+                fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+
+    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
+    endstops.hit_on_purpose(); // clear endstop hit flags
+    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+  }
+
+#endif // QUICK_HOME
+
+#if ENABLED(Z_SAFE_HOMING)
+
+  inline void home_z_safely() {
+
+    // Disallow Z homing if X or Y are unknown
+    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
+      LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
+      return;
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
+    #endif
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    /**
+     * Move the Z probe (or just the nozzle) to the safe homing point
+     */
+    destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
+    destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
+    destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
+
+    #if HOMING_Z_WITH_PROBE
+      destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
+      destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
+    #endif
+
+    if (position_is_reachable_xy(destination[X_AXIS], destination[Y_AXIS])) {
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
+      #endif
+
+      // This causes the carriage on Dual X to unpark
+      #if ENABLED(DUAL_X_CARRIAGE)
+        active_extruder_parked = false;
+      #endif
+
+      do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
+      HOMEAXIS(Z);
+    }
+    else {
+      LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
+    #endif
+  }
+
+#endif // Z_SAFE_HOMING
+
+/**
+ * G28: Home all axes according to settings
+ *
+ * Parameters
+ *
+ *  None  Home to all axes with no parameters.
+ *        With QUICK_HOME enabled XY will home together, then Z.
+ *
+ * Cartesian parameters
+ *
+ *  X   Home to the X endstop
+ *  Y   Home to the Y endstop
+ *  Z   Home to the Z endstop
+ *
+ */
+void GcodeSuite::G28(const bool always_home_all) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOLNPGM(">>> G28");
+      log_machine_info();
+    }
+  #endif
+
+  // Wait for planner moves to finish!
+  stepper.synchronize();
+
+  // Cancel the active G29 session
+  #if ENABLED(PROBE_MANUALLY)
+    g29_in_progress = false;
+  #endif
+
+  // Disable the leveling matrix before homing
+  #if HAS_LEVELING
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      const bool ubl_state_at_entry = leveling_is_active();
+    #endif
+    set_bed_leveling_enabled(false);
+  #endif
+
+  #if ENABLED(CNC_WORKSPACE_PLANES)
+    workspace_plane = PLANE_XY;
+  #endif
+
+  // Always home with tool 0 active
+  #if HOTENDS > 1
+    const uint8_t old_tool_index = active_extruder;
+    tool_change(0, 0, true);
+  #endif
+
+  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+    extruder_duplication_enabled = false;
+  #endif
+
+  setup_for_endstop_or_probe_move();
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
+  #endif
+  endstops.enable(true); // Enable endstops for next homing move
+
+  #if ENABLED(DELTA)
+
+    home_delta();
+    UNUSED(always_home_all);
+
+  #else // NOT DELTA
+
+    const bool homeX = always_home_all || parser.seen('X'),
+               homeY = always_home_all || parser.seen('Y'),
+               homeZ = always_home_all || parser.seen('Z'),
+               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
+
+    set_destination_to_current();
+
+    #if Z_HOME_DIR > 0  // If homing away from BED do Z first
+
+      if (home_all || homeZ) {
+        HOMEAXIS(Z);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
+        #endif
+      }
+
+    #else
+
+      if (home_all || homeX || homeY) {
+        // Raise Z before homing any other axes and z is not already high enough (never lower z)
+        destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
+        if (destination[Z_AXIS] > current_position[Z_AXIS]) {
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING))
+              SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
+          #endif
+
+          do_blocking_move_to_z(destination[Z_AXIS]);
+        }
+      }
+
+    #endif
+
+    #if ENABLED(QUICK_HOME)
+
+      if (home_all || (homeX && homeY)) quick_home_xy();
+
+    #endif
+
+    #if ENABLED(HOME_Y_BEFORE_X)
+
+      // Home Y
+      if (home_all || homeY) {
+        HOMEAXIS(Y);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
+        #endif
+      }
+
+    #endif
+
+    // Home X
+    if (home_all || homeX) {
+
+      #if ENABLED(DUAL_X_CARRIAGE)
+
+        // Always home the 2nd (right) extruder first
+        active_extruder = 1;
+        HOMEAXIS(X);
+
+        // Remember this extruder's position for later tool change
+        inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
+
+        // Home the 1st (left) extruder
+        active_extruder = 0;
+        HOMEAXIS(X);
+
+        // Consider the active extruder to be parked
+        COPY(raised_parked_position, current_position);
+        delayed_move_time = 0;
+        active_extruder_parked = true;
+
+      #else
+
+        HOMEAXIS(X);
+
+      #endif
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
+      #endif
+    }
+
+    #if DISABLED(HOME_Y_BEFORE_X)
+      // Home Y
+      if (home_all || homeY) {
+        HOMEAXIS(Y);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
+        #endif
+      }
+    #endif
+
+    // Home Z last if homing towards the bed
+    #if Z_HOME_DIR < 0
+      if (home_all || homeZ) {
+        #if ENABLED(Z_SAFE_HOMING)
+          home_z_safely();
+        #else
+          HOMEAXIS(Z);
+        #endif
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
+        #endif
+      } // home_all || homeZ
+    #endif // Z_HOME_DIR < 0
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+  #endif // !DELTA (G28)
+
+  endstops.not_homing();
+
+  #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+    // move to a height where we can use the full xy-area
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    set_bed_leveling_enabled(ubl_state_at_entry);
+  #endif
+
+  clean_up_after_endstop_or_probe_move();
+
+  // Restore the active tool after homing
+  #if HOTENDS > 1
+    tool_change(old_tool_index, 0,
+      #if ENABLED(PARKING_EXTRUDER)
+        false // fetch the previous toolhead
+      #else
+        true
+      #endif
+    );
+  #endif
+
+  lcd_refresh();
+
+  report_current_position();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G28");
+  #endif
+}
