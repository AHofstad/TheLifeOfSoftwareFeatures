commit 17a1363f4def87469a7f1b5a853b1d744fd9adf8
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Jul 10 14:15:34 2024 +1200

    üêõ Fix ERR_EEPROM_NOPROM result (#27255)
    
    Followup to #27199

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d4467b7687..a553d56745 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1816,21 +1816,21 @@ void MarlinSettings::postprocess() {
     return ERR_EEPROM_NOERR;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
   EEPROM_Error MarlinSettings::_load() {
     EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
     const EEPROM_Error check = check_version();
-    if (check == ERR_EEPROM_VERSION) return eeprom_error;
+    if (check == ERR_EEPROM_NOPROM) return eeprom_error;
 
     uint16_t stored_crc;
 
     do { // A block to break out of on error
 
       // Version has to match or defaults are used
       if (check == ERR_EEPROM_VERSION) {
         eeprom_error = check;
         break;
       }

commit cb6fd130ba21fa4fbca4172b3082a37550e8b9d9
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Fri Jun 28 01:37:35 2024 +0200

    ‚ö°Ô∏è Load/init (most) settings after showing boot-screen (#27199)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Peter Ellens <ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a9f2f888bf..d4467b7687 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -771,40 +771,42 @@ void MarlinSettings::postprocess() {
 #if ALL(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
   #define HOST_EEPROM_CHITCHAT 1
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_WARN_MSG(ERR); eeprom_error = ERR_EEPROM_SIZE; } }while(0)
 
   #define TWO_BYTE_HASH(A,B) uint16_t((uint16_t(A ^ 0xC3) << 4) ^ (uint16_t(B ^ 0xC3) << 12))
 
+  #define EEPROM_OFFSETOF(FIELD) (EEPROM_OFFSET + offsetof(SettingsData, FIELD))
+
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
       SERIAL_ECHOLNPGM("Field: " STRINGIFY(FIELD)); \
       EEPROM_ASSERT( \
-        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
+        eeprom_error || eeprom_index == EEPROM_OFFSETOF(FIELD), \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else
     #define _FIELD_TEST(FIELD) NOOP
   #endif
 
   #if ENABLED(DEBUG_EEPROM_OBSERVE)
     #define EEPROM_READ(V...)        do{ SERIAL_ECHOLNPGM("READ: ", F(STRINGIFY(FIRST(V)))); EEPROM_READ_(V); }while(0)
     #define EEPROM_READ_ALWAYS(V...) do{ SERIAL_ECHOLNPGM("READ: ", F(STRINGIFY(FIRST(V)))); EEPROM_READ_ALWAYS_(V); }while(0)
   #else
     #define EEPROM_READ(V...)        EEPROM_READ_(V)
     #define EEPROM_READ_ALWAYS(V...) EEPROM_READ_ALWAYS_(V)
   #endif
 
-  const char version[4] = EEPROM_VERSION;
+  constexpr char version_str[4] = EEPROM_VERSION;
 
   #if ENABLED(EEPROM_INIT_NOW)
     constexpr uint32_t strhash32(const char *s, const uint32_t h=0) {
       return *s ? strhash32(s + 1, ((h + *s) << (*s & 3)) ^ *s) : h;
     }
     constexpr uint32_t build_hash = strhash32(__DATE__ __TIME__);
   #endif
 
   bool MarlinSettings::validating;
   int MarlinSettings::eeprom_index;
@@ -820,28 +822,28 @@ void MarlinSettings::postprocess() {
       return ERR_EEPROM_SIZE;
     }
     return ERR_EEPROM_NOERR;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
-    MString<3> ver(F("ERR"));
 
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
-    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
+    constexpr char dummy_version[] = "ERR";
+    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(dummy_version);
 
     #if ENABLED(EEPROM_INIT_NOW)
       EEPROM_SKIP(build_hash);  // Skip the hash slot which will be written later
     #endif
 
     EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
     //
     // Clear after skipping CRC and before writing the CRC'ed data
     //
@@ -1758,21 +1760,21 @@ void MarlinSettings::postprocess() {
     //
     // Report final CRC and Data Size
     //
     if (eeprom_error == ERR_EEPROM_NOERR) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
-      EEPROM_WRITE(version);
+      EEPROM_WRITE(version_str);
       #if ENABLED(EEPROM_INIT_NOW)
         EEPROM_WRITE(build_hash);
       #endif
       EEPROM_WRITE(final_crc);
 
       // Report storage size
       DEBUG_ECHO_MSG("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error = size_error(eeprom_size);
     }
@@ -1790,43 +1792,53 @@ void MarlinSettings::postprocess() {
     if (success) {
       LCD_MESSAGE(MSG_SETTINGS_STORED);
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_SETTINGS_STORED)));
     }
 
     TERN_(EXTENSIBLE_UI, ExtUI::onSettingsStored(success));
 
     return success;
   }
 
+  EEPROM_Error MarlinSettings::check_version() {
+    if (!EEPROM_START(EEPROM_OFFSET)) return ERR_EEPROM_NOPROM;
+    char stored_ver[4];
+    EEPROM_READ_ALWAYS(stored_ver);
+
+    // Version has to match or defaults are used
+    if (strncmp(stored_ver, version_str, 3) != 0) {
+      if (stored_ver[3] != '\0') {
+        stored_ver[0] = '?';
+        stored_ver[1] = '\0';
+      }
+      DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      return ERR_EEPROM_VERSION;
+    }
+    return ERR_EEPROM_NOERR;
+  }
+
   /**
    * M501 - Retrieve Configuration
    */
   EEPROM_Error MarlinSettings::_load() {
     EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
-    if (!EEPROM_START(EEPROM_OFFSET)) return eeprom_error;
-
-    char stored_ver[4];
-    EEPROM_READ_ALWAYS(stored_ver);
+    const EEPROM_Error check = check_version();
+    if (check == ERR_EEPROM_VERSION) return eeprom_error;
 
     uint16_t stored_crc;
 
     do { // A block to break out of on error
 
       // Version has to match or defaults are used
-      if (strncmp(version, stored_ver, 3) != 0) {
-        if (stored_ver[3] != '\0') {
-          stored_ver[0] = '?';
-          stored_ver[1] = '\0';
-        }
-        DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-        eeprom_error = ERR_EEPROM_VERSION;
+      if (check == ERR_EEPROM_VERSION) {
+        eeprom_error = check;
         break;
       }
 
       //
       // Optionally reset on first boot after flashing
       //
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
         EEPROM_READ_ALWAYS(stored_hash);
         if (stored_hash != build_hash) {
@@ -2873,22 +2885,21 @@ void MarlinSettings::postprocess() {
       if ((eeprom_error = size_error(eeprom_total))) {
         // Handle below and on return
         break;
       }
       else if (working_crc != stored_crc) {
         eeprom_error = ERR_EEPROM_CRC;
         break;
       }
       else if (!validating) {
         DEBUG_ECHO_START();
-        DEBUG_ECHO(version);
-        DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_total, " bytes; crc ", working_crc, ")");
+        DEBUG_ECHOLN(version_str, F(" stored settings retrieved ("), eeprom_total, F(" bytes; crc "), working_crc, ')');
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           bedlevel.report_state();
 
           if (!bedlevel.sanity_check()) {
             #if ALL(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               bedlevel.echo_name();
@@ -2960,20 +2971,40 @@ void MarlinSettings::postprocess() {
     #else
       const EEPROM_Error err = _load();
     #endif
     validating = false;
 
     if (err) ui.eeprom_alert(err);
 
     return (err == ERR_EEPROM_NOERR);
   }
 
+  #if HAS_EARLY_LCD_SETTINGS
+
+    #if HAS_LCD_CONTRAST
+      void MarlinSettings::load_contrast() {
+        uint8_t lcd_contrast; EEPROM_START(EEPROM_OFFSETOF(lcd_contrast)); EEPROM_READ(lcd_contrast);
+        DEBUG_ECHOLNPGM("LCD Contrast: ", lcd_contrast);
+        ui.contrast = lcd_contrast;
+      }
+    #endif
+
+    #if HAS_LCD_BRIGHTNESS
+      void MarlinSettings::load_brightness() {
+        uint8_t lcd_brightness; EEPROM_START(EEPROM_OFFSETOF(lcd_brightness)); EEPROM_READ(lcd_brightness);
+        DEBUG_ECHOLNPGM("LCD Brightness: ", lcd_brightness);
+        ui.brightness = lcd_brightness;
+      }
+    #endif
+
+  #endif // HAS_EARLY_LCD_SETTINGS
+
   bool MarlinSettings::load() {
     if (validate()) {
       const EEPROM_Error err = _load();
       const bool success = (err == ERR_EEPROM_NOERR);
       TERN_(EXTENSIBLE_UI, ExtUI::onSettingsLoaded(success));
       return success;
     }
     reset();
     #if ANY(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
       (void)save();
@@ -3110,20 +3141,39 @@ void MarlinSettings::postprocess() {
 
 #else // !EEPROM_SETTINGS
 
   bool MarlinSettings::save() {
     DEBUG_WARN_MSG("EEPROM disabled");
     return false;
   }
 
 #endif // !EEPROM_SETTINGS
 
+#if HAS_EARLY_LCD_SETTINGS
+
+  void MarlinSettings::load_lcd_state() {
+    if (TERN0(EEPROM_SETTINGS, check_version() == ERR_EEPROM_NOERR)) {
+      #if ENABLED(EEPROM_SETTINGS)
+        TERN_(HAS_LCD_CONTRAST, load_contrast());
+        TERN_(HAS_LCD_BRIGHTNESS, load_brightness());
+      #endif
+    }
+    else {
+      TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
+      TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
+    }
+    TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
+    TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
+  }
+
+#endif // HAS_EARLY_LCD_SETTINGS
+
 /**
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
   LOOP_DISTINCT_AXES(i) {
     planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
     #if ENABLED(EDITABLE_STEPS_PER_UNIT)
       planner.settings.axis_steps_per_mm[i] = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
     #endif
     planner.settings.max_feedrate_mm_s[i] = pgm_read_float(&_DMF[ALIM(i, _DMF)]);

commit 6b6865d068c2ebbcb6b56c965807571257d50828
Author: Jonathan Brazier <66009857+JonBr306@users.noreply.github.com>
Date:   Mon May 20 06:03:03 2024 +0100

    ‚ú® INPUT_SHAPING_Z (#27073)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 17b8ae4d72..a9f2f888bf 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -627,20 +627,24 @@ typedef struct SettingsDataStruct {
   // Input Shaping
   //
   #if ENABLED(INPUT_SHAPING_X)
     float shaping_x_frequency,                          // M593 X F
           shaping_x_zeta;                               // M593 X D
   #endif
   #if ENABLED(INPUT_SHAPING_Y)
     float shaping_y_frequency,                          // M593 Y F
           shaping_y_zeta;                               // M593 Y D
   #endif
+  #if ENABLED(INPUT_SHAPING_Z)
+    float shaping_z_frequency,                          // M593 Z F
+          shaping_z_zeta;                               // M593 Z D
+  #endif
 
   //
   // HOTEND_IDLE_TIMEOUT
   //
   #if ENABLED(HOTEND_IDLE_TIMEOUT)
     hotend_idle_settings_t hotend_idle_config;          // M86 S T E B
   #endif
 
   //
   // Nonlinear Extrusion
@@ -1724,20 +1728,24 @@ void MarlinSettings::postprocess() {
     //
     #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
       #endif
+      #if ENABLED(INPUT_SHAPING_Z)
+        EEPROM_WRITE(stepper.get_shaping_frequency(Z_AXIS));
+        EEPROM_WRITE(stepper.get_shaping_damping_ratio(Z_AXIS));
+      #endif
     #endif
 
     //
     // HOTEND_IDLE_TIMEOUT
     //
     #if ENABLED(HOTEND_IDLE_TIMEOUT)
       EEPROM_WRITE(hotend_idle.cfg);
     #endif
 
     //
@@ -2806,36 +2814,47 @@ void MarlinSettings::postprocess() {
       #if ENABLED(FT_MOTION)
         _FIELD_TEST(ftMotion_cfg);
         EEPROM_READ(ftMotion.cfg);
       #endif
 
       //
       // Input Shaping
       //
       #if ENABLED(INPUT_SHAPING_X)
       {
-        float _data[2];
+        struct { float freq, damp; } _data;
         EEPROM_READ(_data);
         if (!validating) {
-          stepper.set_shaping_frequency(X_AXIS, _data[0]);
-          stepper.set_shaping_damping_ratio(X_AXIS, _data[1]);
+          stepper.set_shaping_frequency(X_AXIS, _data.freq);
+          stepper.set_shaping_damping_ratio(X_AXIS, _data.damp);
         }
       }
       #endif
 
       #if ENABLED(INPUT_SHAPING_Y)
       {
-        float _data[2];
+        struct { float freq, damp; } _data;
+        EEPROM_READ(_data);
+        if (!validating) {
+          stepper.set_shaping_frequency(Y_AXIS, _data.freq);
+          stepper.set_shaping_damping_ratio(Y_AXIS, _data.damp);
+        }
+      }
+      #endif
+
+      #if ENABLED(INPUT_SHAPING_Z)
+      {
+        struct { float freq, damp; } _data;
         EEPROM_READ(_data);
         if (!validating) {
-          stepper.set_shaping_frequency(Y_AXIS, _data[0]);
-          stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
+          stepper.set_shaping_frequency(Z_AXIS, _data.freq);
+          stepper.set_shaping_damping_ratio(Z_AXIS, _data.damp);
         }
       }
       #endif
 
       //
       // HOTEND_IDLE_TIMEOUT
       //
       #if ENABLED(HOTEND_IDLE_TIMEOUT)
         EEPROM_READ(hotend_idle.cfg);
       #endif
@@ -3658,20 +3677,24 @@ void MarlinSettings::reset() {
   //
   #if HAS_ZV_SHAPING
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
+    #if ENABLED(INPUT_SHAPING_Z)
+      stepper.set_shaping_frequency(Z_AXIS, SHAPING_FREQ_Z);
+      stepper.set_shaping_damping_ratio(Z_AXIS, SHAPING_ZETA_Z);
+    #endif
   #endif
 
   //
   // Hotend Idle Timeout
   //
   TERN_(HOTEND_IDLE_TIMEOUT, hotend_idle.cfg.set_defaults());
 
   postprocess();
 
   #if ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)

commit 390f1f7c69f6bcb41b7e179dcdd45187da3bfec3
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Apr 5 17:27:30 2024 -0700

    üêõ Don't apply settings during validation (#26935)
    
    Check the `validating` variable before applying settings for several features.
    This specifically avoids settings corruption for BACKLASH_PREVENTION, which has side-effects when first applied using incorrect values.

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4880013862..17b8ae4d72 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1933,21 +1933,21 @@ void MarlinSettings::postprocess() {
       }
 
       //
       // Filament Runout Sensor
       //
       {
         int8_t runout_sensor_enabled;
         _FIELD_TEST(runout_sensor_enabled);
         EEPROM_READ(runout_sensor_enabled);
         #if HAS_FILAMENT_SENSOR
-          runout.enabled = runout_sensor_enabled < 0 ? FIL_RUNOUT_ENABLED_DEFAULT : runout_sensor_enabled;
+        if (!validating) runout.enabled = runout_sensor_enabled < 0 ? FIL_RUNOUT_ENABLED_DEFAULT : runout_sensor_enabled;
         #endif
 
         TERN_(HAS_FILAMENT_SENSOR, if (runout.enabled) runout.reset());
 
         float runout_distance_mm;
         EEPROM_READ(runout_distance_mm);
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
@@ -2114,21 +2114,21 @@ void MarlinSettings::postprocess() {
       #if HAS_PTC
         #if ENABLED(PTC_PROBE)
           EEPROM_READ(ptc.z_offsets_probe);
         #endif
         # if ENABLED(PTC_BED)
           EEPROM_READ(ptc.z_offsets_bed);
         #endif
         #if ENABLED(PTC_HOTEND)
           EEPROM_READ(ptc.z_offsets_hotend);
         #endif
-        ptc.reset_index();
+        if (!validating) ptc.reset_index();
       #else
         // No placeholder data for this feature
       #endif
 
       //
       // BLTOUCH
       //
       {
         _FIELD_TEST(bltouch_od_5v_mode);
         #if ENABLED(BLTOUCH)
@@ -2674,25 +2674,27 @@ void MarlinSettings::postprocess() {
         xyz_float_t backlash_distance_mm;
         uint8_t backlash_correction;
         float backlash_smoothing_mm;
 
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
 
         #if ENABLED(BACKLASH_GCODE)
+        if (!validating) {
           LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, backlash_distance_mm[axis]);
           backlash.set_correction_uint8(backlash_correction);
           #ifdef BACKLASH_SMOOTHING_MM
             backlash.set_smoothing_mm(backlash_smoothing_mm);
           #endif
+        }
         #endif
       }
       #endif // NUM_AXES
 
       //
       // Extensible UI User Data
       //
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
@@ -2780,21 +2782,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Selected LCD language
       //
       #if HAS_MULTI_LANGUAGE
       {
         uint8_t ui_language;
         EEPROM_READ(ui_language);
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
-        ui.set_language(ui_language);
+        if (!validating) ui.set_language(ui_language);
       }
       #endif
 
       //
       // Model predictive control
       //
       #if ENABLED(MPCTEMP)
         HOTEND_LOOP() EEPROM_READ(thermalManager.temp_hotend[e].mpc);
       #endif
 
@@ -2806,31 +2808,35 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(ftMotion.cfg);
       #endif
 
       //
       // Input Shaping
       //
       #if ENABLED(INPUT_SHAPING_X)
       {
         float _data[2];
         EEPROM_READ(_data);
-        stepper.set_shaping_frequency(X_AXIS, _data[0]);
-        stepper.set_shaping_damping_ratio(X_AXIS, _data[1]);
+        if (!validating) {
+          stepper.set_shaping_frequency(X_AXIS, _data[0]);
+          stepper.set_shaping_damping_ratio(X_AXIS, _data[1]);
+        }
       }
       #endif
 
       #if ENABLED(INPUT_SHAPING_Y)
       {
         float _data[2];
         EEPROM_READ(_data);
-        stepper.set_shaping_frequency(Y_AXIS, _data[0]);
-        stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
+        if (!validating) {
+          stepper.set_shaping_frequency(Y_AXIS, _data[0]);
+          stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
+        }
       }
       #endif
 
       //
       // HOTEND_IDLE_TIMEOUT
       //
       #if ENABLED(HOTEND_IDLE_TIMEOUT)
         EEPROM_READ(hotend_idle.cfg);
       #endif
 

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b382f80d51..4880013862 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -68,25 +68,27 @@
   #include "../feature/bedlevel/bedlevel.h"
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
     #include "../feature/x_twist.h"
   #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
-#if ENABLED(EXTENSIBLE_UI)
-  #include "../lcd/extui/ui_api.h"
-#elif ENABLED(DWIN_LCD_PROUI)
+#if ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
   #include "../lcd/e3v2/proui/bedlevel_tools.h"
+#endif
+
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
@@ -483,20 +485,27 @@ typedef struct SettingsDataStruct {
     #elif HAS_MOTOR_CURRENT_DAC
       #define MOTOR_CURRENT_COUNT LOGICAL_AXES
     #elif HAS_MOTOR_CURRENT_I2C
       #define MOTOR_CURRENT_COUNT DIGIPOT_I2C_NUM_CHANNELS
     #else // HAS_MOTOR_CURRENT_SPI
       #define MOTOR_CURRENT_COUNT DISTINCT_AXES
     #endif
   #endif
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
+  //
+  // Adaptive Step Smoothing state
+  //
+  #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+    bool adaptive_step_smoothing_enabled;               // G-code pending
+  #endif
+
   //
   // CNC_COORDINATE_SYSTEMS
   //
   #if NUM_AXES
     xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS]; // G54-G59.3
   #endif
 
   //
   // SKEW_CORRECTION
   //
@@ -530,23 +539,21 @@ typedef struct SettingsDataStruct {
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
-  #if ENABLED(DWIN_LCD_PROUI)
-    uint8_t dwin_data[eeprom_data_size];
-  #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     uint8_t dwin_settings[jyersDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
@@ -1523,20 +1530,28 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(motor_current_setting);
 
       #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
         EEPROM_WRITE(stepper.motor_current_setting);
       #else
         const uint32_t no_current[MOTOR_CURRENT_COUNT] = { 0 };
         EEPROM_WRITE(no_current);
       #endif
     }
 
+    //
+    // Adaptive Step Smoothing state
+    //
+    #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+      _FIELD_TEST(adaptive_step_smoothing_enabled);
+      EEPROM_WRITE(stepper.adaptive_step_smoothing_enabled);
+    #endif
+
     //
     // CNC Coordinate Systems
     //
     #if NUM_AXES
       _FIELD_TEST(coordinate_system);
       #if DISABLED(CNC_COORDINATE_SYSTEMS)
         const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
       #endif
       EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
     #endif
@@ -1599,31 +1614,22 @@ void MarlinSettings::postprocess() {
     #if ENABLED(EXTENSIBLE_UI)
     {
       char extui_data[ExtUI::eeprom_data_size] = { 0 };
       ExtUI::onStoreSettings(extui_data);
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
     }
     #endif
 
     //
-    // Creality DWIN User Data
+    // JyersUI DWIN User Data
     //
-    #if ENABLED(DWIN_LCD_PROUI)
-    {
-      _FIELD_TEST(dwin_data);
-      char dwin_data[eeprom_data_size] = { 0 };
-      dwinCopySettingsTo(dwin_data);
-      EEPROM_WRITE(dwin_data);
-    }
-    #endif
-
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
       char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
       jyersDWIN.saveSettings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
@@ -2592,20 +2598,27 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(motor_current_setting);
         #if HAS_MOTOR_CURRENT_SPI
           DEBUG_ECHO_MSG("DIGIPOTS Loaded");
         #endif
         #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
           if (!validating)
             COPY(stepper.motor_current_setting, motor_current_setting);
         #endif
       }
 
+      //
+      // Adaptive Step Smoothing state
+      //
+      #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+        EEPROM_READ(stepper.adaptive_step_smoothing_enabled);
+      #endif
+
       //
       // CNC Coordinate System
       //
       #if NUM_AXES
       {
         _FIELD_TEST(coordinate_system);
         #if ENABLED(CNC_COORDINATE_SYSTEMS)
           if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
           EEPROM_READ(gcode.coordinate_system);
         #else
@@ -2683,30 +2696,23 @@ void MarlinSettings::postprocess() {
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
       }
       #endif
 
       //
-      // DWIN User Data
+      // JyersUI User Data
       //
-      #if ENABLED(DWIN_LCD_PROUI)
-      {
-        const char dwin_data[eeprom_data_size] = { 0 };
-        _FIELD_TEST(dwin_data);
-        EEPROM_READ(dwin_data);
-        if (!validating) dwinCopySettingsFrom(dwin_data);
-      }
-      #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+      #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
         const char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
         if (!validating) jyersDWIN.loadSettings(dwin_settings);
       }
       #endif
 
       //
       // Case Light Brightness
@@ -3537,20 +3543,27 @@ void MarlinSettings::reset() {
   // DIGIPOTS
   //
   #if HAS_MOTOR_CURRENT_SPI
     static constexpr uint32_t tmp_motor_current_setting[] = DIGIPOT_MOTOR_CURRENT;
     DEBUG_ECHOLNPGM("Writing Digipot");
     for (uint8_t q = 0; q < COUNT(tmp_motor_current_setting); ++q)
       stepper.set_digipot_current(q, tmp_motor_current_setting[q]);
     DEBUG_ECHOLNPGM("Digipot Written");
   #endif
 
+  //
+  // Adaptive Step Smoothing state
+  //
+  #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+    stepper.adaptive_step_smoothing_enabled = true;
+  #endif
+
   //
   // CNC Coordinate System
   //
   TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
 
   //
   // Skew Correction
   //
   #if ENABLED(SKEW_CORRECTION_GCODE)
     planner.skew_factor.xy = XY_SKEW_FACTOR;
@@ -3582,25 +3595,20 @@ void MarlinSettings::reset() {
   //
   // Fan tachometer check
   //
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
-  //
-  // Ender-3 V2 with ProUI
-  //
-  TERN_(DWIN_LCD_PROUI, dwinSetDataDefaults());
-
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
     constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
     constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
     constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
     #if ENABLED(MPC_INCLUDE_FAN)
       constexpr float _mpc_ambient_xfer_coeff_fan255[] = MPC_AMBIENT_XFER_COEFF_FAN255;

commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    üîß TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2dc48ebbf0..b382f80d51 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3461,21 +3461,21 @@ void MarlinSettings::reset() {
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // LCD Backlight / Sleep Timeout
   //
   #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
     #if HAS_BACKLIGHT_TIMEOUT
       ui.backlight_timeout_minutes = LCD_BACKLIGHT_TIMEOUT_MINS;
     #elif HAS_DISPLAY_SLEEP
-      ui.sleep_timeout_minutes = TERN(TOUCH_SCREEN, TOUCH_IDLE_SLEEP_MINS, DISPLAY_SLEEP_MINUTES);
+      ui.sleep_timeout_minutes = DISPLAY_SLEEP_MINUTES;
     #endif
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery

commit 01094ea6aa7b843f830ec350e5886fcab6b652ff
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jan 25 19:18:49 2024 -0500

    ‚ú®üî® EEPROM exclusion zone (#26729)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3a66c12ccc..2dc48ebbf0 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -722,21 +722,22 @@ void MarlinSettings::postprocess() {
 
   #if ENABLED(EEPROM_SETTINGS)
     static_assert(
       !WITHIN(SD_FIRMWARE_UPDATE_EEPROM_ADDR, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
       "SD_FIRMWARE_UPDATE_EEPROM_ADDR collides with EEPROM settings storage."
     );
   #endif
 
   bool MarlinSettings::sd_update_status() {
     uint8_t val;
-    persistentStore.read_data(SD_FIRMWARE_UPDATE_EEPROM_ADDR, &val);
+    int pos = SD_FIRMWARE_UPDATE_EEPROM_ADDR;
+    persistentStore.read_data(pos, &val);
     return (val == SD_FIRMWARE_UPDATE_ACTIVE_VALUE);
   }
 
   bool MarlinSettings::set_sd_update_status(const bool enable) {
     if (enable != sd_update_status())
       persistentStore.write_data(
         SD_FIRMWARE_UPDATE_EEPROM_ADDR,
         enable ? SD_FIRMWARE_UPDATE_ACTIVE_VALUE : SD_FIRMWARE_UPDATE_INACTIVE_VALUE
       );
     return true;

commit 9b3119393f0c7fe3eb08734e097df09c7466acc3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Jan 26 12:39:09 2024 +1300

    ü©π Followup to EDITABLE_STEPS_PER_UNIT (#26677)
    
    Followup to #26618

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 34f840e8e3..3a66c12ccc 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1854,22 +1854,24 @@ void MarlinSettings::postprocess() {
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
         uint32_t tmp1[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
 
         EEPROM_READ(planner.settings.min_segment_time_us);
 
-        float tmp2[NUM_AXES + e_factors];
-        EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
+        #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+          float tmp2[NUM_AXES + e_factors];
+          EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
+        #endif
 
         feedRate_t tmp3[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
         if (!validating) LOOP_DISTINCT_AXES(i) {
           const bool in = (i < e_factors + NUM_AXES);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
           #if ENABLED(EDITABLE_STEPS_PER_UNIT)
             planner.settings.axis_steps_per_mm[i]        = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           #endif

commit aa7d5714867df05348ca63ad113ea9cf7ccc3271
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 22 17:32:01 2024 -0600

    ‚ôªÔ∏è LCD pins migration precursor (#26719)
    
    Preliminary changes for #25650

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6a20488f6d..34f840e8e3 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -695,21 +695,21 @@ void MarlinSettings::postprocess() {
   TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
 
   // Refresh mm_per_step with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
-  // Moved as last update due to interference with Neopixel init
+  // Moved as last update due to interference with NeoPixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
   TERN_(HAS_BACKLIGHT_TIMEOUT, ui.refresh_backlight_timeout());
   TERN_(HAS_DISPLAY_SLEEP, ui.refresh_screen_timeout());
 }
 
 #if ALL(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&

commit da96607b65ecc910178413d6979c128add9d098e
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sat Jan 20 00:38:25 2024 +0200

    üîß Adjust DEFAULT_EJERK settings (#26665)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index da62a42781..6a20488f6d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -849,21 +849,21 @@ void MarlinSettings::postprocess() {
     {
       EEPROM_WRITE(planner.settings);
 
       #if ENABLED(CLASSIC_JERK)
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
           dummyf = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummyf);
         #endif
       #else
-        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4);
+        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(5, 10, 10, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4);
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
       TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
     // Home Offset
     //

commit f44f9eb9f831e007156e310de09ab3ba03100cf0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 10 14:49:28 2024 -0600

    üé® Misc. style adjustments

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index adbd3dcf47..da62a42781 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3706,23 +3706,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // M200 Volumetric Extrusion
     //
     IF_DISABLED(NO_VOLUMETRICS, gcode.M200_report(forReplay));
 
     //
     // M92 Steps per Unit
     //
-    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
-      gcode.M92_report(forReplay);
-    #endif
+    TERN_(EDITABLE_STEPS_PER_UNIT, gcode.M92_report(forReplay));
 
     //
     // M203 Maximum feedrates (units/s)
     //
     gcode.M203_report(forReplay);
 
     //
     // M201 Maximum Acceleration (units/s2)
     //
     gcode.M201_report(forReplay);

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ‚ú® EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a12728a003..adbd3dcf47 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -191,22 +191,24 @@ typedef struct { uint32_t MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS,
 typedef struct {  int16_t MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
 typedef struct {     bool NUM_AXIS_LIST_(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1) X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
-static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
+#if ENABLED(EDITABLE_STEPS_PER_UNIT)
+  static const float   _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
+#endif
 
 /**
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   #if ENABLED(EEPROM_INIT_NOW)
@@ -1848,31 +1850,36 @@ void MarlinSettings::postprocess() {
       uint8_t e_factors;
       EEPROM_READ_ALWAYS(e_factors);
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
         uint32_t tmp1[NUM_AXES + e_factors];
-        float tmp2[NUM_AXES + e_factors];
-        feedRate_t tmp3[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
+
         EEPROM_READ(planner.settings.min_segment_time_us);
+
+        float tmp2[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
+
+        feedRate_t tmp3[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
         if (!validating) LOOP_DISTINCT_AXES(i) {
           const bool in = (i < e_factors + NUM_AXES);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
-          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+          #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+            planner.settings.axis_steps_per_mm[i]        = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+          #endif
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
         #if ENABLED(CLASSIC_JERK)
@@ -3075,21 +3082,23 @@ void MarlinSettings::postprocess() {
   }
 
 #endif // !EEPROM_SETTINGS
 
 /**
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
   LOOP_DISTINCT_AXES(i) {
     planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
-    planner.settings.axis_steps_per_mm[i] = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      planner.settings.axis_steps_per_mm[i] = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+    #endif
     planner.settings.max_feedrate_mm_s[i] = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
   planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
@@ -3657,21 +3666,23 @@ void MarlinSettings::reset() {
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
-  void M92_report(const bool echo=true, const int8_t e=-1);
+  #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+    void M92_report(const bool echo=true, const int8_t e=-1);
+  #endif
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
     //
     // Announce current units, in case inches are being displayed
     //
@@ -3695,21 +3706,23 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // M200 Volumetric Extrusion
     //
     IF_DISABLED(NO_VOLUMETRICS, gcode.M200_report(forReplay));
 
     //
     // M92 Steps per Unit
     //
-    gcode.M92_report(forReplay);
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      gcode.M92_report(forReplay);
+    #endif
 
     //
     // M203 Maximum feedrates (units/s)
     //
     gcode.M203_report(forReplay);
 
     //
     // M201 Maximum Acceleration (units/s2)
     //
     gcode.M201_report(forReplay);

commit 1d46e67de202ae436958c344506f14d2da975076
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Wed Jan 10 07:13:10 2024 +0200

    ‚ú® PLR_BED_THRESHOLD (#26649)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d3b1c58063..a12728a003 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -437,20 +437,21 @@ typedef struct SettingsDataStruct {
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
   // POWER_LOSS_RECOVERY
   //
   bool recovery_enabled;                                // M413 S
+  celsius_t bed_temp_threshold;                         // M413 B
 
   //
   // FWRETRACT
   //
   fwretract_settings_t fwretract_settings;              // M207 S F Z W, M208 S F W R
   bool autoretract_enabled;                             // M209 S
 
   //
   // !NO_VOLUMETRIC
   //
@@ -1261,22 +1262,24 @@ void MarlinSettings::postprocess() {
         constexpr controllerFan_settings_t cfs = controllerFan_defaults;
       #endif
       EEPROM_WRITE(cfs);
     }
 
     //
     // Power-Loss Recovery
     //
     {
       _FIELD_TEST(recovery_enabled);
-      const bool recovery_enabled = TERN(POWER_LOSS_RECOVERY, recovery.enabled, ENABLED(PLR_ENABLED_DEFAULT));
+      const bool recovery_enabled = TERN0(POWER_LOSS_RECOVERY, recovery.enabled);
+      const celsius_t bed_temp_threshold = TERN0(HAS_PLR_BED_THRESHOLD, recovery.bed_temp_threshold);
       EEPROM_WRITE(recovery_enabled);
+      EEPROM_WRITE(bed_temp_threshold);
     }
 
     //
     // Firmware Retraction
     //
     {
       _FIELD_TEST(fwretract_settings);
       #if DISABLED(FWRETRACT)
         const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
       #endif
@@ -2303,24 +2306,29 @@ void MarlinSettings::postprocess() {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
         EEPROM_READ(cfs);
         TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
       }
 
       //
       // Power-Loss Recovery
       //
       {
-        bool recovery_enabled;
         _FIELD_TEST(recovery_enabled);
+        bool recovery_enabled;
+        celsius_t bed_temp_threshold;
         EEPROM_READ(recovery_enabled);
-        TERN_(POWER_LOSS_RECOVERY, if (!validating) recovery.enabled = recovery_enabled);
+        EEPROM_READ(bed_temp_threshold);
+        if (!validating) {
+          TERN_(POWER_LOSS_RECOVERY, recovery.enabled = recovery_enabled);
+          TERN_(HAS_PLR_BED_THRESHOLD, recovery.bed_temp_threshold = bed_temp_threshold);
+        }
       }
 
       //
       // Firmware Retraction
       //
       {
         fwretract_settings_t fwretract_settings;
         bool autoretract_enabled;
         _FIELD_TEST(fwretract_settings);
         EEPROM_READ(fwretract_settings);
@@ -3453,21 +3461,24 @@ void MarlinSettings::reset() {
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
-  TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    recovery.enable(ENABLED(PLR_ENABLED_DEFAULT));
+    TERN_(HAS_PLR_BED_THRESHOLD, recovery.bed_temp_threshold = PLR_BED_THRESHOLD);
+  #endif
 
   //
   // Firmware Retraction
   //
   TERN_(FWRETRACT, fwretract.reset());
 
   //
   // Volumetric & Filament Size
   //
   #if DISABLED(NO_VOLUMETRICS)

commit f6ecdae972c1e54f52daec5c63252281962da5b9
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Jan 10 10:19:47 2024 +1300

    üîß Base NUM_SERVO_PLUGS on SERVO PINS (#26640)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 387d86ba29..d3b1c58063 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -85,26 +85,20 @@
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
-#if HAS_SERVOS && HAS_SERVO_ANGLES
-  #define EEPROM_NUM_SERVOS NUM_SERVOS
-#else
-  #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
-#endif
-
 #include "../feature/fwretract.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
 #endif
 
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
@@ -311,21 +305,23 @@ typedef struct SettingsDataStruct {
 
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // bedlevel.storage_slot
 
   //
   // SERVO_ANGLES
   //
-  uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
+  #if HAS_SERVO_ANGLES
+    uint16_t servo_angles[NUM_SERVOS][2];               // M281 P L U
+  #endif
 
   //
   // Temperature first layer compensation values
   //
   #if HAS_PTC
     #if ENABLED(PTC_PROBE)
       int16_t z_offsets_probe[COUNT(ptc.z_offsets_probe)]; // M871 P I V
     #endif
     #if ENABLED(PTC_BED)
       int16_t z_offsets_bed[COUNT(ptc.z_offsets_bed)];     // M871 B I V
@@ -1044,27 +1040,26 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(planner_leveling_active);
       const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
       const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, bedlevel.storage_slot, -1);
       EEPROM_WRITE(ubl_active);
       EEPROM_WRITE(storage_slot);
     }
 
     //
     // Servo Angles
     //
+    #if HAS_SERVO_ANGLES
     {
       _FIELD_TEST(servo_angles);
-      #if !HAS_SERVO_ANGLES
-        uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
-      #endif
       EEPROM_WRITE(servo_angles);
     }
+    #endif
 
     //
     // Thermal first layer compensation values
     //
     #if HAS_PTC
       #if ENABLED(PTC_PROBE)
         EEPROM_WRITE(ptc.z_offsets_probe);
       #endif
       #if ENABLED(PTC_BED)
         EEPROM_WRITE(ptc.z_offsets_bed);
@@ -2075,29 +2070,31 @@ void MarlinSettings::postprocess() {
           bool planner_leveling_active;
           int8_t ubl_storage_slot;
         #endif
         EEPROM_READ(planner_leveling_active);
         EEPROM_READ(ubl_storage_slot);
       }
 
       //
       // SERVO_ANGLES
       //
+      #if HAS_SERVO_ANGLES
       {
         _FIELD_TEST(servo_angles);
         #if ENABLED(EDITABLE_SERVO_ANGLES)
-          uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
+          uint16_t (&servo_angles_arr)[NUM_SERVOS][2] = servo_angles;
         #else
-          uint16_t servo_angles_arr[EEPROM_NUM_SERVOS][2];
+          uint16_t servo_angles_arr[NUM_SERVOS][2];
         #endif
         EEPROM_READ(servo_angles_arr);
       }
+      #endif
 
       //
       // Thermal first layer compensation values
       //
       #if HAS_PTC
         #if ENABLED(PTC_PROBE)
           EEPROM_READ(ptc.z_offsets_probe);
         #endif
         # if ENABLED(PTC_BED)
           EEPROM_READ(ptc.z_offsets_bed);

commit 6d407767e7692d66bc93a0012d71268770e4835c
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 3 16:43:18 2024 +0100

    üîß CONFIGURE_FILAMENT_CHANGE - Optional M603 (#26613)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fa7beee94b..387d86ba29 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V89"
+#define EEPROM_VERSION "V90"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 //#define DEBUG_EEPROM_OBSERVE
 
 #include "settings.h"
 
 #include "endstops.h"
@@ -501,21 +501,21 @@ typedef struct SettingsDataStruct {
   //
   // SKEW_CORRECTION
   //
   #if ENABLED(SKEW_CORRECTION)
     skew_factor_t planner_skew_factor;                  // M852 I J K
   #endif
 
   //
   // ADVANCED_PAUSE_FEATURE
   //
-  #if HAS_EXTRUDERS
+  #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
     fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
   #endif
 
   //
   // Tool-change settings
   //
   #if HAS_MULTI_EXTRUDER
     toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
@@ -1544,25 +1544,22 @@ void MarlinSettings::postprocess() {
     // Skew correction factors
     //
     #if ENABLED(SKEW_CORRECTION)
       _FIELD_TEST(planner_skew_factor);
       EEPROM_WRITE(planner.skew_factor);
     #endif
 
     //
     // Advanced Pause filament load & unload lengths
     //
-    #if HAS_EXTRUDERS
+    #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
     {
-      #if DISABLED(ADVANCED_PAUSE_FEATURE)
-        const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
-      #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
     }
     #endif
 
     //
     // Multiple Extruders
     //
 
     #if HAS_MULTI_EXTRUDER
@@ -2619,25 +2616,22 @@ void MarlinSettings::postprocess() {
               planner.skew_factor.yz = skew_factor.yz;
             #endif
           }
         #endif
       }
       #endif
 
       //
       // Advanced Pause filament load & unload lengths
       //
-      #if HAS_EXTRUDERS
+      #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
       {
-        #if DISABLED(ADVANCED_PAUSE_FEATURE)
-          fil_change_settings_t fc_settings[EXTRUDERS];
-        #endif
         _FIELD_TEST(fc_settings);
         EEPROM_READ(fc_settings);
       }
       #endif
 
       //
       // Tool-change settings
       //
       #if HAS_MULTI_EXTRUDER
         _FIELD_TEST(toolchange_settings);
@@ -3542,21 +3536,21 @@ void MarlinSettings::reset() {
     planner.skew_factor.xy = XY_SKEW_FACTOR;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
       planner.skew_factor.xz = XZ_SKEW_FACTOR;
       planner.skew_factor.yz = YZ_SKEW_FACTOR;
     #endif
   #endif
 
   //
   // Advanced Pause filament load & unload lengths
   //
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
     EXTRUDER_LOOP() {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
       fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
   #endif
 
   #if ENABLED(PASSWORD_FEATURE)
     #ifdef PASSWORD_DEFAULT_VALUE
       password.is_set = true;
       password.value = PASSWORD_DEFAULT_VALUE;
@@ -3917,21 +3911,21 @@ void MarlinSettings::reset() {
     //
     // Motor Current (SPI or PWM)
     //
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       gcode.M907_report(forReplay);
     #endif
 
     //
     // Advanced Pause filament load & unload lengths
     //
-    TERN_(ADVANCED_PAUSE_FEATURE, gcode.M603_report(forReplay));
+    TERN_(CONFIGURE_FILAMENT_CHANGE, gcode.M603_report(forReplay));
 
     //
     // Tool-changing Parameters
     //
     E_TERN_(gcode.M217_report(forReplay));
 
     //
     // Backlash Compensation
     //
     TERN_(BACKLASH_GCODE, gcode.M425_report(forReplay));

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    üîß Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b99ae8ddcd..fa7beee94b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -843,21 +843,21 @@ void MarlinSettings::postprocess() {
     const uint8_t e_factors = DISTINCT_AXES - (NUM_AXES);
     _FIELD_TEST(e_factors);
     EEPROM_WRITE(e_factors);
 
     //
     // Planner Motion
     //
     {
       EEPROM_WRITE(planner.settings);
 
-      #if HAS_CLASSIC_JERK
+      #if ENABLED(CLASSIC_JERK)
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
           dummyf = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummyf);
         #endif
       #else
         const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4);
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
@@ -1873,21 +1873,21 @@ void MarlinSettings::postprocess() {
           planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
-        #if HAS_CLASSIC_JERK
+        #if ENABLED(CLASSIC_JERK)
           EEPROM_READ(planner.max_jerk);
           #if HAS_LINEAR_E_JERK
             EEPROM_READ(dummyf);
           #endif
         #else
           for (uint8_t q = LOGICAL_AXES; q--;) EEPROM_READ(dummyf);
         #endif
 
         EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
       }
@@ -3087,21 +3087,21 @@ void MarlinSettings::reset() {
     planner.settings.max_feedrate_mm_s[i] = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
   planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
-  #if HAS_CLASSIC_JERK
+  #if ENABLED(CLASSIC_JERK)
     #if HAS_X_AXIS && !defined(DEFAULT_XJERK)
       #define DEFAULT_XJERK 0
     #endif
     #if HAS_Y_AXIS && !defined(DEFAULT_YJERK)
       #define DEFAULT_YJERK 0
     #endif
     #if HAS_Z_AXIS && !defined(DEFAULT_ZJERK)
       #define DEFAULT_ZJERK 0
     #endif
     #if HAS_I_AXIS && !defined(DEFAULT_IJERK)

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ‚ú® EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f636b985e1..b99ae8ddcd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -424,24 +424,26 @@ typedef struct SettingsDataStruct {
   uint8_t lcd_contrast;                                 // M250 C
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
   //
   // Display Sleep
   //
-  #if LCD_BACKLIGHT_TIMEOUT_MINS
-    uint8_t backlight_timeout_minutes;                  // M255 S
-  #elif HAS_DISPLAY_SLEEP
-    uint8_t sleep_timeout_minutes;                      // M255 S
+  #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+    #if HAS_BACKLIGHT_TIMEOUT
+      uint8_t backlight_timeout_minutes;                // M255 S
+    #elif HAS_DISPLAY_SLEEP
+      uint8_t sleep_timeout_minutes;                    // M255 S
+    #endif
   #endif
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
   // POWER_LOSS_RECOVERY
   //
@@ -697,26 +699,22 @@ void MarlinSettings::postprocess() {
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
-
-  #if LCD_BACKLIGHT_TIMEOUT_MINS
-    ui.refresh_backlight_timeout();
-  #elif HAS_DISPLAY_SLEEP
-    ui.refresh_screen_timeout();
-  #endif
+  TERN_(HAS_BACKLIGHT_TIMEOUT, ui.refresh_backlight_timeout());
+  TERN_(HAS_DISPLAY_SLEEP, ui.refresh_screen_timeout());
 }
 
 #if ALL(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
   );
 #endif
@@ -1242,24 +1240,26 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
     }
 
     //
     // LCD Backlight / Sleep Timeout
     //
-    #if LCD_BACKLIGHT_TIMEOUT_MINS
-      EEPROM_WRITE(ui.backlight_timeout_minutes);
-    #elif HAS_DISPLAY_SLEEP
-      EEPROM_WRITE(ui.sleep_timeout_minutes);
+    #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+      #if HAS_BACKLIGHT_TIMEOUT
+        EEPROM_WRITE(ui.backlight_timeout_minutes);
+      #elif HAS_DISPLAY_SLEEP
+        EEPROM_WRITE(ui.sleep_timeout_minutes);
+      #endif
     #endif
 
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
         const controllerFan_settings_t &cfs = controllerFan.settings;
       #else
@@ -2287,24 +2287,26 @@ void MarlinSettings::postprocess() {
       {
         uint8_t lcd_brightness;
         _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
       //
       // LCD Backlight / Sleep Timeout
       //
-      #if LCD_BACKLIGHT_TIMEOUT_MINS
-        EEPROM_READ(ui.backlight_timeout_minutes);
-      #elif HAS_DISPLAY_SLEEP
-        EEPROM_READ(ui.sleep_timeout_minutes);
+      #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+        #if HAS_BACKLIGHT_TIMEOUT
+          EEPROM_READ(ui.backlight_timeout_minutes);
+        #elif HAS_DISPLAY_SLEEP
+          EEPROM_READ(ui.sleep_timeout_minutes);
+        #endif
       #endif
 
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
         EEPROM_READ(cfs);
         TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
@@ -3444,24 +3446,26 @@ void MarlinSettings::reset() {
   TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // LCD Backlight / Sleep Timeout
   //
-  #if LCD_BACKLIGHT_TIMEOUT_MINS
-    ui.backlight_timeout_minutes = LCD_BACKLIGHT_TIMEOUT_MINS;
-  #elif HAS_DISPLAY_SLEEP
-    ui.sleep_timeout_minutes = TERN(TOUCH_SCREEN, TOUCH_IDLE_SLEEP_MINS, DISPLAY_SLEEP_MINUTES);
+  #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+    #if HAS_BACKLIGHT_TIMEOUT
+      ui.backlight_timeout_minutes = LCD_BACKLIGHT_TIMEOUT_MINS;
+    #elif HAS_DISPLAY_SLEEP
+      ui.sleep_timeout_minutes = TERN(TOUCH_SCREEN, TOUCH_IDLE_SLEEP_MINS, DISPLAY_SLEEP_MINUTES);
+    #endif
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
@@ -3820,21 +3824,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // LCD Contrast
     //
     TERN_(HAS_LCD_CONTRAST, gcode.M250_report(forReplay));
 
     //
     // Display Sleep
     //
-    TERN_(HAS_GCODE_M255, gcode.M255_report(forReplay));
+    TERN_(EDITABLE_DISPLAY_TIMEOUT, gcode.M255_report(forReplay));
 
     //
     // LCD Brightness
     //
     TERN_(HAS_LCD_BRIGHTNESS, gcode.M256_report(forReplay));
 
     //
     // Controller Fan
     //
     TERN_(CONTROLLER_FAN_EDITABLE, gcode.M710_report(forReplay));

commit dfec58e5dced9fd794cc4a8e7a88a4d34f0cacda
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 8 00:47:18 2023 -0600

    ‚ö°Ô∏è Use strlcpy with buffer size (#26513)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6f7c4b1ebc..f636b985e1 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2035,21 +2035,21 @@ void MarlinSettings::postprocess() {
           break;
         }
 
         xy_pos_t spacing, start;
         EEPROM_READ(spacing);                          // 2 ints
         EEPROM_READ(start);                            // 2 ints
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
             bedlevel.set_grid(spacing, start);
-            EEPROM_READ(bedlevel.z_values);                 // 9 to 256 floats
+            EEPROM_READ(bedlevel.z_values);            // 9 to 256 floats
           }
           else if (grid_max_x > (GRID_MAX_POINTS_X) || grid_max_y > (GRID_MAX_POINTS_Y)) {
             eeprom_error = ERR_EEPROM_CORRUPT;
             break;
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7abe276561..6f7c4b1ebc 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -605,21 +605,21 @@ typedef struct SettingsDataStruct {
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     MPC_t mpc_constants[HOTENDS];                       // M306
   #endif
 
   //
   // Fixed-Time Motion
   //
   #if ENABLED(FT_MOTION)
-    ft_config_t fxdTiCtrl_cfg;                          // M493
+    ft_config_t ftMotion_cfg;                          // M493
   #endif
 
   //
   // Input Shaping
   //
   #if ENABLED(INPUT_SHAPING_X)
     float shaping_x_frequency,                          // M593 X F
           shaping_x_zeta;                               // M593 X D
   #endif
   #if ENABLED(INPUT_SHAPING_Y)
@@ -1704,22 +1704,22 @@ void MarlinSettings::postprocess() {
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
       HOTEND_LOOP() EEPROM_WRITE(thermalManager.temp_hotend[e].mpc);
     #endif
 
     //
     // Fixed-Time Motion
     //
     #if ENABLED(FT_MOTION)
-      _FIELD_TEST(fxdTiCtrl_cfg);
-      EEPROM_WRITE(fxdTiCtrl.cfg);
+      _FIELD_TEST(ftMotion_cfg);
+      EEPROM_WRITE(ftMotion.cfg);
     #endif
 
     //
     // Input Shaping
     //
     #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
@@ -2778,22 +2778,22 @@ void MarlinSettings::postprocess() {
       // Model predictive control
       //
       #if ENABLED(MPCTEMP)
         HOTEND_LOOP() EEPROM_READ(thermalManager.temp_hotend[e].mpc);
       #endif
 
       //
       // Fixed-Time Motion
       //
       #if ENABLED(FT_MOTION)
-        _FIELD_TEST(fxdTiCtrl_cfg);
-        EEPROM_READ(fxdTiCtrl.cfg);
+        _FIELD_TEST(ftMotion_cfg);
+        EEPROM_READ(ftMotion.cfg);
       #endif
 
       //
       // Input Shaping
       //
       #if ENABLED(INPUT_SHAPING_X)
       {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(X_AXIS, _data[0]);
@@ -3607,21 +3607,21 @@ void MarlinSettings::reset() {
       #if ENABLED(MPC_INCLUDE_FAN)
         mpc.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
       mpc.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   //
   // Fixed-Time Motion
   //
-  TERN_(FT_MOTION, fxdTiCtrl.set_defaults());
+  TERN_(FT_MOTION, ftMotion.set_defaults());
 
   //
   // Nonlinear Extrusion
   //
   TERN_(NONLINEAR_EXTRUSION, stepper.ne.reset());
 
   //
   // Input Shaping
   //
   #if HAS_ZV_SHAPING

commit e9b9d634c4ef5d48791de84545ef86d46909fec0
Author: Andrew Bortz <andrew@abortz.net>
Date:   Tue Oct 10 20:24:48 2023 -0700

    ‚ú® Nonlinear Extrusion Control (M592) (#26127)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a4820ae900..7abe276561 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V88"
+#define EEPROM_VERSION "V89"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 //#define DEBUG_EEPROM_OBSERVE
 
 #include "settings.h"
 
 #include "endstops.h"
@@ -627,20 +627,27 @@ typedef struct SettingsDataStruct {
           shaping_y_zeta;                               // M593 Y D
   #endif
 
   //
   // HOTEND_IDLE_TIMEOUT
   //
   #if ENABLED(HOTEND_IDLE_TIMEOUT)
     hotend_idle_settings_t hotend_idle_config;          // M86 S T E B
   #endif
 
+  //
+  // Nonlinear Extrusion
+  //
+  #if ENABLED(NONLINEAR_EXTRUSION)
+    ne_coeff_t stepper_ne;                              // M592 A B C
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1722,20 +1729,27 @@ void MarlinSettings::postprocess() {
       #endif
     #endif
 
     //
     // HOTEND_IDLE_TIMEOUT
     //
     #if ENABLED(HOTEND_IDLE_TIMEOUT)
       EEPROM_WRITE(hotend_idle.cfg);
     #endif
 
+    //
+    // Nonlinear Extrusion
+    //
+    #if ENABLED(NONLINEAR_EXTRUSION)
+      EEPROM_WRITE(stepper.ne);
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (eeprom_error == ERR_EEPROM_NOERR) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2796,20 +2810,27 @@ void MarlinSettings::postprocess() {
       }
       #endif
 
       //
       // HOTEND_IDLE_TIMEOUT
       //
       #if ENABLED(HOTEND_IDLE_TIMEOUT)
         EEPROM_READ(hotend_idle.cfg);
       #endif
 
+      //
+      // Nonlinear Extrusion
+      //
+      #if ENABLED(NONLINEAR_EXTRUSION)
+        EEPROM_READ(stepper.ne);
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       const uint16_t eeprom_total = eeprom_index - (EEPROM_OFFSET);
       if ((eeprom_error = size_error(eeprom_total))) {
         // Handle below and on return
         break;
       }
       else if (working_crc != stored_crc) {
         eeprom_error = ERR_EEPROM_CRC;
@@ -3389,29 +3410,27 @@ void MarlinSettings::reset() {
   #endif
 
   //
   // PID Extrusion Scaling
   //
   TERN_(PID_EXTRUSION_SCALING, thermalManager.lpq_len = 20); // Default last-position-queue size
 
   //
   // Heated Bed PID
   //
-
   #if ENABLED(PIDTEMPBED)
     thermalManager.temp_bed.pid.set(DEFAULT_bedKp, DEFAULT_bedKi, DEFAULT_bedKd);
   #endif
 
   //
   // Heated Chamber PID
   //
-
   #if ENABLED(PIDTEMPCHAMBER)
     thermalManager.temp_chamber.pid.set(DEFAULT_chamberKp, DEFAULT_chamberKi, DEFAULT_chamberKd);
   #endif
 
   //
   // User-Defined Thermistors
   //
   TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
   //
@@ -3449,21 +3468,20 @@ void MarlinSettings::reset() {
   TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
 
   //
   // Firmware Retraction
   //
   TERN_(FWRETRACT, fwretract.reset());
 
   //
   // Volumetric & Filament Size
   //
-
   #if DISABLED(NO_VOLUMETRICS)
     parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
     for (uint8_t q = 0; q < COUNT(planner.filament_size); ++q)
       planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
       for (uint8_t q = 0; q < COUNT(planner.volumetric_extruder_limit); ++q)
         planner.volumetric_extruder_limit[q] = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
     #endif
   #endif
 
@@ -3591,20 +3609,25 @@ void MarlinSettings::reset() {
       #endif
       mpc.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   //
   // Fixed-Time Motion
   //
   TERN_(FT_MOTION, fxdTiCtrl.set_defaults());
 
+  //
+  // Nonlinear Extrusion
+  //
+  TERN_(NONLINEAR_EXTRUSION, stepper.ne.reset());
+
   //
   // Input Shaping
   //
   #if HAS_ZV_SHAPING
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
@@ -3860,20 +3883,25 @@ void MarlinSettings::reset() {
     //
     // TMC stepping mode
     //
     TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
     //
     // Fixed-Time Motion
     //
     TERN_(FT_MOTION, gcode.M493_report(forReplay));
 
+    //
+    // Nonlinear Extrusion
+    //
+    TERN_(NONLINEAR_EXTRUSION, gcode.M592_report(forReplay));
+
     //
     // Input Shaping
     //
     TERN_(HAS_ZV_SHAPING, gcode.M593_report(forReplay));
 
     //
     // Hotend Idle Timeout
     //
     TERN_(HOTEND_IDLE_TIMEOUT, gcode.M86_report(forReplay));
 

commit db98f0611004efd6e042c4cf53c881d7b1f3c10c
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Fri Oct 6 15:09:58 2023 -0700

    üö∏ Warning alerts for non-fatal errors (#26306)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c125577f5c..a4820ae900 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -751,21 +751,21 @@ void MarlinSettings::postprocess() {
 //
 #define DEBUG_OUT ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ALL(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
   #define HOST_EEPROM_CHITCHAT 1
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = ERR_EEPROM_SIZE; } }while(0)
+  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_WARN_MSG(ERR); eeprom_error = ERR_EEPROM_SIZE; } }while(0)
 
   #define TWO_BYTE_HASH(A,B) uint16_t((uint16_t(A ^ 0xC3) << 4) ^ (uint16_t(B ^ 0xC3) << 12))
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
       SERIAL_ECHOLNPGM("Field: " STRINGIFY(FIELD)); \
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
@@ -789,21 +789,21 @@ void MarlinSettings::postprocess() {
     }
     constexpr uint32_t build_hash = strhash32(__DATE__ __TIME__);
   #endif
 
   bool MarlinSettings::validating;
   int MarlinSettings::eeprom_index;
   uint16_t MarlinSettings::working_crc;
 
   EEPROM_Error MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
-      DEBUG_ERROR_MSG("EEPROM datasize error."
+      DEBUG_WARN_MSG("EEPROM datasize error."
         #if ENABLED(MARLIN_DEV_MODE)
           " (Actual:", size, " Expected:", datasize(), ")"
         #endif
       );
       return ERR_EEPROM_SIZE;
     }
     return ERR_EEPROM_NOERR;
   }
 
   /**
@@ -2858,24 +2858,24 @@ void MarlinSettings::postprocess() {
     EEPROM_FINISH();
 
     switch (eeprom_error) {
       case ERR_EEPROM_NOERR:
         if (!validating) postprocess();
         break;
       case ERR_EEPROM_SIZE:
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         break;
       case ERR_EEPROM_CORRUPT:
-        DEBUG_ERROR_MSG(STR_ERR_EEPROM_CORRUPT);
+        DEBUG_WARN_MSG(STR_ERR_EEPROM_CORRUPT);
         break;
       case ERR_EEPROM_CRC:
-        DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        DEBUG_WARN_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
         break;
       default: break;
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
       // Report the EEPROM settings
       if (!validating && TERN1(EEPROM_BOOT_SILENT, IsRunning())) report();
     #endif
 
@@ -3041,21 +3041,21 @@ void MarlinSettings::postprocess() {
     }
 
     //void MarlinSettings::delete_mesh() { return; }
     //void MarlinSettings::defrag_meshes() { return; }
 
   #endif // AUTO_BED_LEVELING_UBL
 
 #else // !EEPROM_SETTINGS
 
   bool MarlinSettings::save() {
-    DEBUG_ERROR_MSG("EEPROM disabled");
+    DEBUG_WARN_MSG("EEPROM disabled");
     return false;
   }
 
 #endif // !EEPROM_SETTINGS
 
 /**
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
   LOOP_DISTINCT_AXES(i) {

commit 9135e3f7d3fd0d634656f1c54c70a0ba1f878bfd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 21:10:03 2023 -0500

    üö∏ Revert M206 Home Offset behavior (#25996)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c8ce84cd83..c125577f5c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -663,24 +663,21 @@ void MarlinSettings::postprocess() {
   TERN_(PIDTEMP, thermalManager.updatePID());
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
   #elif EXTRUDERS
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
 
   // Software endstops depend on home_offset
-  LOOP_NUM_AXES(i) {
-    update_workspace_offset((AxisEnum)i);
-    update_software_endstops((AxisEnum)i);
-  }
+  LOOP_NUM_AXES(i) update_software_endstops((AxisEnum)i);
 
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
@@ -3694,21 +3691,21 @@ void MarlinSettings::reset() {
     gcode.M204_report(forReplay);
 
     //
     // M205 "Advanced" Settings
     //
     gcode.M205_report(forReplay);
 
     //
     // M206 Home Offset
     //
-    TERN_(HAS_M206_COMMAND, gcode.M206_report(forReplay));
+    TERN_(HAS_HOME_OFFSET, gcode.M206_report(forReplay));
 
     //
     // M218 Hotend offsets
     //
     TERN_(HAS_HOTEND_OFFSET, gcode.M218_report(forReplay));
 
     //
     // Bed Leveling
     //
     #if HAS_LEVELING

commit 1a241e6e86512b570267d672e2f00a80df41b2e9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 1 16:50:42 2023 -0500

    üêõ Fix M105 (MString append TS) and EEPROM ver
    
    Followup to #24390

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 479b43c4bd..c8ce84cd83 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -807,28 +807,28 @@ void MarlinSettings::postprocess() {
       return ERR_EEPROM_SIZE;
     }
     return ERR_EEPROM_NOERR;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
-    MString<4> ver(F("ERR"));
+    MString<3> ver(F("ERR"));
 
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
-    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(&ver);
+    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
     #if ENABLED(EEPROM_INIT_NOW)
       EEPROM_SKIP(build_hash);  // Skip the hash slot which will be written later
     #endif
 
     EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
     //
     // Clear after skipping CRC and before writing the CRC'ed data
     //

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7ef6970141..479b43c4bd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1603,21 +1603,21 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
     //
     // Creality DWIN User Data
     //
     #if ENABLED(DWIN_LCD_PROUI)
     {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
-      DWIN_CopySettingsTo(dwin_data);
+      dwinCopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
       char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
       jyersDWIN.saveSettings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
@@ -2668,21 +2668,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // DWIN User Data
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
-        if (!validating) DWIN_CopySettingsFrom(dwin_data);
+        if (!validating) dwinCopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
         const char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
         if (!validating) jyersDWIN.loadSettings(dwin_settings);
       }
       #endif
 
@@ -3015,21 +3015,21 @@ void MarlinSettings::postprocess() {
           if (into) {
             float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
             bedlevel.set_mesh_from_store(z_mesh_store, z_values);
             memcpy(into, z_values, sizeof(z_values));
           }
           else
             bedlevel.set_mesh_from_store(z_mesh_store, bedlevel.z_values);
         #endif
 
         #if ENABLED(DWIN_LCD_PROUI)
-          status = !bedLevelTools.meshvalidate();
+          status = !bedLevelTools.meshValidate();
           if (status) {
             bedlevel.invalidate();
             LCD_MESSAGE(MSG_UBL_MESH_INVALID);
           }
           else
             ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), bedlevel.storage_slot);
         #endif
 
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        DEBUG_ECHOLNPGM("Mesh loaded from slot ", slot);
@@ -3552,21 +3552,21 @@ void MarlinSettings::reset() {
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   //
   // Ender-3 V2 with ProUI
   //
-  TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
+  TERN_(DWIN_LCD_PROUI, dwinSetDataDefaults());
 
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
     constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
     constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
     constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
     #if ENABLED(MPC_INCLUDE_FAN)

commit bbfaf7474c50f81d606c2dde91035bc40835e830
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 21:44:42 2023 -0500

    üé® CrealityDWIN => JyersDWIN (#26026)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3e2b2386bd..7ef6970141 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -532,21 +532,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
   #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
   #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-    uint8_t dwin_settings[crealityDWIN.eeprom_data_size];
+    uint8_t dwin_settings[jyersDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
@@ -1611,22 +1611,22 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
-      char dwin_settings[crealityDWIN.eeprom_data_size] = { 0 };
-      crealityDWIN.saveSettings(dwin_settings);
+      char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
+      jyersDWIN.saveSettings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
@@ -2672,24 +2672,24 @@ void MarlinSettings::postprocess() {
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
-        const char dwin_settings[crealityDWIN.eeprom_data_size] = { 0 };
+        const char dwin_settings[jyersDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
-        if (!validating) crealityDWIN.loadSettings(dwin_settings);
+        if (!validating) jyersDWIN.loadSettings(dwin_settings);
       }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
@@ -3165,21 +3165,21 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
-  TERN_(DWIN_CREALITY_LCD_JYERSUI, crealityDWIN.resetSettings());
+  TERN_(DWIN_CREALITY_LCD_JYERSUI, jyersDWIN.resetSettings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fa434c1499..3e2b2386bd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -807,28 +807,28 @@ void MarlinSettings::postprocess() {
       return ERR_EEPROM_SIZE;
     }
     return ERR_EEPROM_NOERR;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
-    char ver[4] = "ERR";
+    MString<4> ver(F("ERR"));
 
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
-    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
+    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(&ver);
 
     #if ENABLED(EEPROM_INIT_NOW)
       EEPROM_SKIP(build_hash);  // Skip the hash slot which will be written later
     #endif
 
     EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
     //
     // Clear after skipping CRC and before writing the CRC'ed data
     //

commit 402c4ef5d3de2b22efd73111222ee7d1f1f6b25f
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jun 25 15:32:56 2023 -0700

    üö∏ M86-M87 Hotend Idle Timeout (#25015)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 16e0d10a09..fa434c1499 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -171,20 +171,24 @@
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
 #if DGUS_LCD_UI_MKS
   #include "../lcd/extui/dgus/DGUSScreenHandler.h"
   #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
+#if ENABLED(HOTEND_IDLE_TIMEOUT)
+  #include "../feature/hotend_idle.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
 
 #define _EN_ITEM(N) , E##N
 #define _EN1_ITEM(N) , E##N:1
 
@@ -616,20 +620,27 @@ typedef struct SettingsDataStruct {
   //
   #if ENABLED(INPUT_SHAPING_X)
     float shaping_x_frequency,                          // M593 X F
           shaping_x_zeta;                               // M593 X D
   #endif
   #if ENABLED(INPUT_SHAPING_Y)
     float shaping_y_frequency,                          // M593 Y F
           shaping_y_zeta;                               // M593 Y D
   #endif
 
+  //
+  // HOTEND_IDLE_TIMEOUT
+  //
+  #if ENABLED(HOTEND_IDLE_TIMEOUT)
+    hotend_idle_settings_t hotend_idle_config;          // M86 S T E B
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1695,32 +1706,39 @@ void MarlinSettings::postprocess() {
     //
     // Fixed-Time Motion
     //
     #if ENABLED(FT_MOTION)
       _FIELD_TEST(fxdTiCtrl_cfg);
       EEPROM_WRITE(fxdTiCtrl.cfg);
     #endif
 
     //
     // Input Shaping
-    ///
+    //
     #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
       #endif
     #endif
 
+    //
+    // HOTEND_IDLE_TIMEOUT
+    //
+    #if ENABLED(HOTEND_IDLE_TIMEOUT)
+      EEPROM_WRITE(hotend_idle.cfg);
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (eeprom_error == ERR_EEPROM_NOERR) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2774,20 +2792,27 @@ void MarlinSettings::postprocess() {
 
       #if ENABLED(INPUT_SHAPING_Y)
       {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(Y_AXIS, _data[0]);
         stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
       }
       #endif
 
+      //
+      // HOTEND_IDLE_TIMEOUT
+      //
+      #if ENABLED(HOTEND_IDLE_TIMEOUT)
+        EEPROM_READ(hotend_idle.cfg);
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       const uint16_t eeprom_total = eeprom_index - (EEPROM_OFFSET);
       if ((eeprom_error = size_error(eeprom_total))) {
         // Handle below and on return
         break;
       }
       else if (working_crc != stored_crc) {
         eeprom_error = ERR_EEPROM_CRC;
@@ -3583,20 +3608,25 @@ void MarlinSettings::reset() {
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
   #endif
 
+  //
+  // Hotend Idle Timeout
+  //
+  TERN_(HOTEND_IDLE_TIMEOUT, hotend_idle.cfg.set_defaults());
+
   postprocess();
 
   #if ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLN(hdsl);
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
@@ -3838,20 +3868,25 @@ void MarlinSettings::reset() {
     //
     // Fixed-Time Motion
     //
     TERN_(FT_MOTION, gcode.M493_report(forReplay));
 
     //
     // Input Shaping
     //
     TERN_(HAS_ZV_SHAPING, gcode.M593_report(forReplay));
 
+    //
+    // Hotend Idle Timeout
+    //
+    TERN_(HOTEND_IDLE_TIMEOUT, gcode.M86_report(forReplay));
+
     //
     // Linear Advance
     //
     TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 
     //
     // Motor Current (SPI or PWM)
     //
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       gcode.M907_report(forReplay);

commit 41a5fbb16ad985220f1cee1b823950c3bb771186
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:12:01 2023 -0500

    üé® More lowercase
    
    Followup to #25939

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 1ee3932c2d..16e0d10a09 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -528,21 +528,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
   #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
   #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-    uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
+    uint8_t dwin_settings[crealityDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 321691ba87..1ee3932c2d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1600,22 +1600,22 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
-      char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
-      CrealityDWIN.Save_Settings(dwin_settings);
+      char dwin_settings[crealityDWIN.eeprom_data_size] = { 0 };
+      crealityDWIN.saveSettings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
@@ -2654,24 +2654,24 @@ void MarlinSettings::postprocess() {
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
-        const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+        const char dwin_settings[crealityDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
-        if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
+        if (!validating) crealityDWIN.loadSettings(dwin_settings);
       }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
@@ -3140,21 +3140,21 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
-  TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
+  TERN_(DWIN_CREALITY_LCD_JYERSUI, crealityDWIN.resetSettings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 1defac2977..321691ba87 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3588,21 +3588,21 @@ void MarlinSettings::reset() {
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
   #endif
 
   postprocess();
 
   #if ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
-    DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
+    DEBUG_ECHO_START(); DEBUG_ECHOLN(hdsl);
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
@@ -3684,48 +3684,46 @@ void MarlinSettings::reset() {
     #if HAS_LEVELING
 
       gcode.M420_report(forReplay);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; ++py) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; ++px) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPGM("  G29 S3 I", px, " J", py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
+              SERIAL_ECHOLN(F("  G29 S3 I"), px, F(" J"), py, FPSTR(SP_Z_STR), p_float_t(LINEAR_UNIT(bedlevel.z_values[px][py]), 5));
             }
           }
           CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(bedlevel.z_offset), 5);
+          SERIAL_ECHOLNPGM("  G29 S4 Z", p_float_t(LINEAR_UNIT(bedlevel.z_offset), 5));
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
           SERIAL_EOL();
           bedlevel.report_state();
           SERIAL_ECHO_MSG("Active Mesh Slot ", bedlevel.storage_slot);
           SERIAL_ECHO_MSG("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
         }
 
        //bedlevel.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                            // solution needs to be found.
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; ++py) {
             for (uint8_t px = 0; px < GRID_MAX_POINTS_X; ++px) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPGM("  G29 W I", px, " J", py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
+              SERIAL_ECHOLN(F("  G29 W I"), px, F(" J"), py, FPSTR(SP_Z_STR), p_float_t(LINEAR_UNIT(bedlevel.z_values[px][py]), 5));
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
     //
     // X Axis Twist Compensation

commit 35016633d843ba393eb17cf5fd1dba03764821dd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 6 02:58:28 2023 -0500

    ü©π Conditional include probe.h

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 62b03a1b9c..1defac2977 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -53,21 +53,23 @@
 
 #include "../lcd/marlinui.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"
 
 #if ANY(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
-#include "probe.h"
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
     #include "../feature/x_twist.h"
   #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f9dff24656..62b03a1b9c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -867,21 +867,21 @@ void MarlinSettings::postprocess() {
       #endif
     }
     #endif // NUM_AXES
 
     //
     // Hotend Offsets, if any
     //
     {
       #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
-        LOOP_S_L_N(e, 1, HOTENDS)
+        for (uint8_t e = 1; e < HOTENDS; ++e)
           EEPROM_WRITE(hotend_offset[e]);
       #endif
     }
 
     //
     // Filament Runout Sensor
     //
     {
       #if HAS_FILAMENT_SENSOR
         const bool &runout_sensor_enabled = runout.enabled;
@@ -1878,21 +1878,21 @@ void MarlinSettings::postprocess() {
         #endif
       }
       #endif // NUM_AXES
 
       //
       // Hotend Offsets, if any
       //
       {
         #if HAS_HOTEND_OFFSET
           // Skip hotend 0 which must be 0
-          LOOP_S_L_N(e, 1, HOTENDS)
+          for (uint8_t e = 1; e < HOTENDS; ++e)
             EEPROM_READ(hotend_offset[e]);
         #endif
       }
 
       //
       // Filament Runout Sensor
       //
       {
         int8_t runout_sensor_enabled;
         _FIELD_TEST(runout_sensor_enabled);
@@ -3287,21 +3287,21 @@ void MarlinSettings::reset() {
     #define _PITEM(N,T) PREHEAT_##N##_##T,
     #if HAS_HOTEND
       constexpr uint16_t hpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_HOTEND) };
     #endif
     #if HAS_HEATED_BED
       constexpr uint16_t bpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_BED) };
     #endif
     #if HAS_FAN
       constexpr uint8_t fpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, FAN_SPEED) };
     #endif
-    LOOP_L_N(i, PREHEAT_COUNT) {
+    for (uint8_t i = 0; i < PREHEAT_COUNT; ++i) {
       TERN_(HAS_HOTEND,     ui.material_preset[i].hotend_temp = hpre[i]);
       TERN_(HAS_HEATED_BED, ui.material_preset[i].bed_temp = bpre[i]);
       TERN_(HAS_FAN,        ui.material_preset[i].fan_speed = fpre[i]);
     }
   #endif
 
   //
   // Hotend PID
   //
 
@@ -3428,24 +3428,24 @@ void MarlinSettings::reset() {
   // Firmware Retraction
   //
   TERN_(FWRETRACT, fwretract.reset());
 
   //
   // Volumetric & Filament Size
   //
 
   #if DISABLED(NO_VOLUMETRICS)
     parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
-    LOOP_L_N(q, COUNT(planner.filament_size))
+    for (uint8_t q = 0; q < COUNT(planner.filament_size); ++q)
       planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-      LOOP_L_N(q, COUNT(planner.volumetric_extruder_limit))
+      for (uint8_t q = 0; q < COUNT(planner.volumetric_extruder_limit); ++q)
         planner.volumetric_extruder_limit[q] = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
     #endif
   #endif
 
   endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
   reset_stepper_drivers();
 
   //
   // Linear Advance
@@ -3462,31 +3462,31 @@ void MarlinSettings::reset() {
       planner.extruder_advance_K[0] = ADVANCE_K;
     #endif
   #endif
 
   //
   // Motor Current PWM
   //
 
   #if HAS_MOTOR_CURRENT_PWM
     constexpr uint32_t tmp_motor_current_setting[MOTOR_CURRENT_COUNT] = PWM_MOTOR_CURRENT;
-    LOOP_L_N(q, MOTOR_CURRENT_COUNT)
+    for (uint8_t q = 0; q < MOTOR_CURRENT_COUNT; ++q)
       stepper.set_digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
   #endif
 
   //
   // DIGIPOTS
   //
   #if HAS_MOTOR_CURRENT_SPI
     static constexpr uint32_t tmp_motor_current_setting[] = DIGIPOT_MOTOR_CURRENT;
     DEBUG_ECHOLNPGM("Writing Digipot");
-    LOOP_L_N(q, COUNT(tmp_motor_current_setting))
+    for (uint8_t q = 0; q < COUNT(tmp_motor_current_setting); ++q)
       stepper.set_digipot_current(q, tmp_motor_current_setting[q]);
     DEBUG_ECHOLNPGM("Digipot Written");
   #endif
 
   //
   // CNC Coordinate System
   //
   TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
 
   //
@@ -3679,22 +3679,22 @@ void MarlinSettings::reset() {
     //
     // Bed Leveling
     //
     #if HAS_LEVELING
 
       gcode.M420_report(forReplay);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
-          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
-            LOOP_L_N(px, GRID_MAX_POINTS_X) {
+          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; ++py) {
+            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; ++px) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 S3 I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(bedlevel.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
@@ -3705,22 +3705,22 @@ void MarlinSettings::reset() {
           SERIAL_ECHO_MSG("Active Mesh Slot ", bedlevel.storage_slot);
           SERIAL_ECHO_MSG("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
         }
 
        //bedlevel.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                            // solution needs to be found.
 
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
-          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
-            LOOP_L_N(px, GRID_MAX_POINTS_X) {
+          for (uint8_t py = 0; py < GRID_MAX_POINTS_Y; ++py) {
+            for (uint8_t px = 0; px < GRID_MAX_POINTS_X; ++px) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
@@ -3758,21 +3758,21 @@ void MarlinSettings::reset() {
     TERN_(HAS_PREHEAT, gcode.M145_report(forReplay));
 
     //
     // PID
     //
     TERN_(PIDTEMP,        gcode.M301_report(forReplay));
     TERN_(PIDTEMPBED,     gcode.M304_report(forReplay));
     TERN_(PIDTEMPCHAMBER, gcode.M309_report(forReplay));
 
     #if HAS_USER_THERMISTORS
-      LOOP_L_N(i, USER_THERMISTORS)
+      for (uint8_t i = 0; i < USER_THERMISTORS; ++i)
         thermalManager.M305_report(i, forReplay);
     #endif
 
     //
     // LCD Contrast
     //
     TERN_(HAS_LCD_CONTRAST, gcode.M250_report(forReplay));
 
     //
     // Display Sleep

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 28eee57c08..f9dff24656 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -49,21 +49,21 @@
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 
 #include "../lcd/marlinui.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"
 
-#if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
+#if ANY(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
     #include "../feature/x_twist.h"
   #endif
@@ -688,21 +688,21 @@ void MarlinSettings::postprocess() {
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 
   #if LCD_BACKLIGHT_TIMEOUT_MINS
     ui.refresh_backlight_timeout();
   #elif HAS_DISPLAY_SLEEP
     ui.refresh_screen_timeout();
   #endif
 }
 
-#if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
+#if ALL(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
   );
 #endif
 
 #if ENABLED(SD_FIRMWARE_UPDATE)
 
@@ -732,24 +732,24 @@ void MarlinSettings::postprocess() {
 
 #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
   static_assert(EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
                 "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
 //
 // This file simply uses the DEBUG_ECHO macros to implement EEPROM_CHITCHAT.
 // For deeper debugging of EEPROM issues enable DEBUG_EEPROM_READWRITE.
 //
-#define DEBUG_OUT EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+#define DEBUG_OUT ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
-#if BOTH(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
+#if ALL(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
   #define HOST_EEPROM_CHITCHAT 1
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = ERR_EEPROM_SIZE; } }while(0)
 
   #define TWO_BYTE_HASH(A,B) uint16_t((uint16_t(A ^ 0xC3) << 4) ^ (uint16_t(B ^ 0xC3) << 12))
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
@@ -2796,28 +2796,28 @@ void MarlinSettings::postprocess() {
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_total, " bytes; crc ", working_crc, ")");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           bedlevel.report_state();
 
           if (!bedlevel.sanity_check()) {
-            #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+            #if ALL(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               bedlevel.echo_name();
               DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = ERR_EEPROM_CORRUPT;
-            #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+            #if ALL(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
               bedlevel.echo_name();
               DEBUG_ECHOLNPGM(".");
             #endif
             bedlevel.reset();
           }
 
           if (bedlevel.storage_slot >= 0) {
             load_mesh(bedlevel.storage_slot);
             DEBUG_ECHOLNPGM("Mesh ", bedlevel.storage_slot, " loaded from storage.");
@@ -2881,21 +2881,21 @@ void MarlinSettings::postprocess() {
   }
 
   bool MarlinSettings::load() {
     if (validate()) {
       const EEPROM_Error err = _load();
       const bool success = (err == ERR_EEPROM_NOERR);
       TERN_(EXTENSIBLE_UI, ExtUI::onSettingsLoaded(success));
       return success;
     }
     reset();
-    #if EITHER(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
+    #if ANY(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
       DEBUG_ECHOLNPGM("?Invalid slot.\n", s, " mesh slots available.");
@@ -3583,21 +3583,21 @@ void MarlinSettings::reset() {
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
   #endif
 
   postprocess();
 
-  #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+  #if ANY(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
@@ -3736,21 +3736,21 @@ void MarlinSettings::reset() {
     TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
     //
     // Kinematic Settings
     //
     TERN_(IS_KINEMATIC, gcode.M665_report(forReplay));
 
     //
     // M666 Endstops Adjustment
     //
-    #if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
+    #if ANY(DELTA, HAS_EXTRA_ENDSTOPS)
       gcode.M666_report(forReplay);
     #endif
 
     //
     // Z Auto-Align
     //
     TERN_(Z_STEPPER_AUTO_ALIGN, gcode.M422_report(forReplay));
 
     //
     // LCD Preheat Settings

commit 5bc84bf08cb47741537fe705dbfe19eee5396d4e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 19 23:30:48 2023 -0500

    üö∏ Improve EEPROM validation (#25860)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 58e00b7fb0..28eee57c08 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,26 +29,27 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V87"
+#define EEPROM_VERSION "V88"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
+//#define DEBUG_EEPROM_OBSERVE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 
 #include "../lcd/marlinui.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
@@ -204,21 +205,22 @@ static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   #if ENABLED(EEPROM_INIT_NOW)
     uint32_t build_hash;                                // Unique build hash
   #endif
-  uint16_t  crc;                                        // Data Checksum
+  uint16_t  crc;                                        // Data Checksum for validation
+  uint16_t  data_size;                                  // Data Size for validation
 
   //
   // DISTINCT_E_FACTORS
   //
   uint8_t e_factors;                                    // DISTINCT_AXES - NUM_AXES
 
   //
   // Planner settings
   //
   planner_settings_t planner_settings;
@@ -257,39 +259,41 @@ typedef struct SettingsDataStruct {
   #if ENABLED(AUTOTEMP)
     celsius_t planner_autotemp_max, planner_autotemp_min;
     float planner_autotemp_factor;
   #endif
 
   //
   // MESH_BED_LEVELING
   //
   float mbl_z_offset;                                   // bedlevel.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  uint16_t mesh_check;                                  // Hash to check against X/Y
   float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // bedlevel.z_values
                     [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
   //
   #if NUM_AXES
     xyz_pos_t probe_offset;                             // M851 X Y Z
   #endif
 
   //
   // ABL_PLANAR
   //
   matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
 
   //
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  uint16_t grid_check;                                  // Hash to check against X/Y
   xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
   #else
     float z_values[3][3];
   #endif
 
   //
   // X_AXIS_TWIST_COMPENSATION
   //
@@ -737,78 +741,96 @@ void MarlinSettings::postprocess() {
 //
 #define DEBUG_OUT EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if BOTH(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
   #define HOST_EEPROM_CHITCHAT 1
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
+  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = ERR_EEPROM_SIZE; } }while(0)
+
+  #define TWO_BYTE_HASH(A,B) uint16_t((uint16_t(A ^ 0xC3) << 4) ^ (uint16_t(B ^ 0xC3) << 12))
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
+      SERIAL_ECHOLNPGM("Field: " STRINGIFY(FIELD)); \
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else
     #define _FIELD_TEST(FIELD) NOOP
   #endif
 
+  #if ENABLED(DEBUG_EEPROM_OBSERVE)
+    #define EEPROM_READ(V...)        do{ SERIAL_ECHOLNPGM("READ: ", F(STRINGIFY(FIRST(V)))); EEPROM_READ_(V); }while(0)
+    #define EEPROM_READ_ALWAYS(V...) do{ SERIAL_ECHOLNPGM("READ: ", F(STRINGIFY(FIRST(V)))); EEPROM_READ_ALWAYS_(V); }while(0)
+  #else
+    #define EEPROM_READ(V...)        EEPROM_READ_(V)
+    #define EEPROM_READ_ALWAYS(V...) EEPROM_READ_ALWAYS_(V)
+  #endif
+
   const char version[4] = EEPROM_VERSION;
 
   #if ENABLED(EEPROM_INIT_NOW)
     constexpr uint32_t strhash32(const char *s, const uint32_t h=0) {
       return *s ? strhash32(s + 1, ((h + *s) << (*s & 3)) ^ *s) : h;
     }
     constexpr uint32_t build_hash = strhash32(__DATE__ __TIME__);
   #endif
 
-  bool MarlinSettings::eeprom_error, MarlinSettings::validating;
+  bool MarlinSettings::validating;
   int MarlinSettings::eeprom_index;
   uint16_t MarlinSettings::working_crc;
 
-  bool MarlinSettings::size_error(const uint16_t size) {
+  EEPROM_Error MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
       DEBUG_ERROR_MSG("EEPROM datasize error."
         #if ENABLED(MARLIN_DEV_MODE)
           " (Actual:", size, " Expected:", datasize(), ")"
         #endif
       );
-      return true;
+      return ERR_EEPROM_SIZE;
     }
-    return false;
+    return ERR_EEPROM_NOERR;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
     char ver[4] = "ERR";
 
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
-    eeprom_error = false;
+    EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
     TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
     #if ENABLED(EEPROM_INIT_NOW)
-      EEPROM_SKIP(build_hash);  // Skip the hash slot
+      EEPROM_SKIP(build_hash);  // Skip the hash slot which will be written later
     #endif
 
     EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
-    working_crc = 0; // clear before first "real data"
+    //
+    // Clear after skipping CRC and before writing the CRC'ed data
+    //
+    working_crc = 0;
+
+    // Write the size of the data structure for use in validation
+    const uint16_t data_size = datasize();
+    EEPROM_WRITE(data_size);
 
     const uint8_t e_factors = DISTINCT_AXES - (NUM_AXES);
     _FIELD_TEST(e_factors);
     EEPROM_WRITE(e_factors);
 
     //
     // Planner Motion
     //
     {
       EEPROM_WRITE(planner.settings);
@@ -908,20 +930,24 @@ void MarlinSettings::postprocess() {
         dummyf = 0;
       #endif
 
       const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
                     mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
 
       EEPROM_WRITE(TERN(MESH_BED_LEVELING, bedlevel.z_offset, dummyf));
       EEPROM_WRITE(mesh_num_x);
       EEPROM_WRITE(mesh_num_y);
 
+      // Check value for the X/Y values
+      const uint16_t mesh_check = TWO_BYTE_HASH(mesh_num_x, mesh_num_y);
+      EEPROM_WRITE(mesh_check);
+
       #if ENABLED(MESH_BED_LEVELING)
         EEPROM_WRITE(bedlevel.z_values);
       #else
         for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Probe XYZ Offsets
     //
@@ -957,20 +983,25 @@ void MarlinSettings::postprocess() {
         static_assert(
           sizeof(bedlevel.z_values) == GRID_MAX_POINTS * sizeof(bedlevel.z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
+
+      // Check value for the X/Y values
+      const uint16_t grid_check = TWO_BYTE_HASH(grid_max_x, grid_max_y);
+      EEPROM_WRITE(grid_check);
+
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         EEPROM_WRITE(bedlevel.grid_spacing);
         EEPROM_WRITE(bedlevel.grid_start);
       #else
         const xy_pos_t bilinear_grid_spacing{0}, bilinear_start{0};
         EEPROM_WRITE(bilinear_grid_spacing);
         EEPROM_WRITE(bilinear_start);
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -1677,98 +1708,124 @@ void MarlinSettings::postprocess() {
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
       #endif
     #endif
 
     //
     // Report final CRC and Data Size
     //
-    if (!eeprom_error) {
+    if (eeprom_error == ERR_EEPROM_NOERR) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
       EEPROM_WRITE(version);
       #if ENABLED(EEPROM_INIT_NOW)
         EEPROM_WRITE(build_hash);
       #endif
       EEPROM_WRITE(final_crc);
 
       // Report storage size
       DEBUG_ECHO_MSG("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
-      eeprom_error |= size_error(eeprom_size);
+      eeprom_error = size_error(eeprom_size);
     }
     EEPROM_FINISH();
 
     //
     // UBL Mesh
     //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (bedlevel.storage_slot >= 0)
         store_mesh(bedlevel.storage_slot);
     #endif
 
-    if (!eeprom_error) {
+    const bool success = (eeprom_error == ERR_EEPROM_NOERR);
+    if (success) {
       LCD_MESSAGE(MSG_SETTINGS_STORED);
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_SETTINGS_STORED)));
     }
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onSettingsStored(!eeprom_error));
+    TERN_(EXTENSIBLE_UI, ExtUI::onSettingsStored(success));
 
-    return !eeprom_error;
+    return success;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
-  bool MarlinSettings::_load() {
-    if (!EEPROM_START(EEPROM_OFFSET)) return false;
+  EEPROM_Error MarlinSettings::_load() {
+    EEPROM_Error eeprom_error = ERR_EEPROM_NOERR;
+
+    if (!EEPROM_START(EEPROM_OFFSET)) return eeprom_error;
 
     char stored_ver[4];
     EEPROM_READ_ALWAYS(stored_ver);
 
-    // Version has to match or defaults are used
-    if (strncmp(version, stored_ver, 3) != 0) {
-      if (stored_ver[3] != '\0') {
-        stored_ver[0] = '?';
-        stored_ver[1] = '\0';
-      }
-      DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      LCD_MESSAGE(MSG_ERR_EEPROM_VERSION);
-      TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_VERSION)));
+    uint16_t stored_crc;
 
-      IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
-      eeprom_error = true;
-    }
-    else {
+    do { // A block to break out of on error
+
+      // Version has to match or defaults are used
+      if (strncmp(version, stored_ver, 3) != 0) {
+        if (stored_ver[3] != '\0') {
+          stored_ver[0] = '?';
+          stored_ver[1] = '\0';
+        }
+        DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+        eeprom_error = ERR_EEPROM_VERSION;
+        break;
+      }
 
-      // Optionally reset on the first boot after flashing
+      //
+      // Optionally reset on first boot after flashing
+      //
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
         EEPROM_READ_ALWAYS(stored_hash);
-        if (stored_hash != build_hash) { EEPROM_FINISH(); return false; }
+        if (stored_hash != build_hash) {
+          eeprom_error = ERR_EEPROM_CORRUPT;
+          break;
+        }
       #endif
 
-      uint16_t stored_crc;
+      //
+      // Get the stored CRC to compare at the end
+      //
       EEPROM_READ_ALWAYS(stored_crc);
 
+      //
+      // A temporary float for safe storage
+      //
       float dummyf = 0;
-      working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
-      _FIELD_TEST(e_factors);
+      //
+      // Init to 0. Accumulated by EEPROM_READ
+      //
+      working_crc = 0;
 
+      //
+      // Validate the stored size against the current data structure size
+      //
+      uint16_t stored_size;
+      EEPROM_READ_ALWAYS(stored_size);
+      if ((eeprom_error = size_error(stored_size))) break;
+
+      //
+      // Extruder Parameter Count
       // Number of e_factors may change
+      //
+      _FIELD_TEST(e_factors);
       uint8_t e_factors;
       EEPROM_READ_ALWAYS(e_factors);
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
         uint32_t tmp1[NUM_AXES + e_factors];
@@ -1865,30 +1922,42 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(planner.autotemp.max);
         EEPROM_READ(planner.autotemp.min);
         EEPROM_READ(planner.autotemp.factor);
       #endif
 
       //
       // Mesh (Manual) Bed Leveling
       //
       {
         uint8_t mesh_num_x, mesh_num_y;
+        uint16_t mesh_check;
         EEPROM_READ(dummyf);
         EEPROM_READ_ALWAYS(mesh_num_x);
         EEPROM_READ_ALWAYS(mesh_num_y);
 
+        // Check value must correspond to the X/Y values
+        EEPROM_READ_ALWAYS(mesh_check);
+        if (mesh_check != TWO_BYTE_HASH(mesh_num_x, mesh_num_y)) {
+          eeprom_error = ERR_EEPROM_CORRUPT;
+          break;
+        }
+
         #if ENABLED(MESH_BED_LEVELING)
           if (!validating) bedlevel.z_offset = dummyf;
           if (mesh_num_x == (GRID_MAX_POINTS_X) && mesh_num_y == (GRID_MAX_POINTS_Y)) {
             // EEPROM data fits the current mesh
             EEPROM_READ(bedlevel.z_values);
           }
+          else if (mesh_num_x > (GRID_MAX_POINTS_X) || mesh_num_y > (GRID_MAX_POINTS_Y)) {
+            eeprom_error = ERR_EEPROM_CORRUPT;
+            break;
+          }
           else {
             // EEPROM data is stale
             if (!validating) bedlevel.reset();
             for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
           }
         #else
           // MBL is disabled - skip the stored data
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
         #endif
       }
@@ -1919,29 +1988,42 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
       //
       // Bilinear Auto Bed Leveling
       //
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
+
+        // Check value must correspond to the X/Y values
+        uint16_t grid_check;
+        EEPROM_READ_ALWAYS(grid_check);
+        if (grid_check != TWO_BYTE_HASH(grid_max_x, grid_max_y)) {
+          eeprom_error = ERR_EEPROM_CORRUPT;
+          break;
+        }
+
         xy_pos_t spacing, start;
         EEPROM_READ(spacing);                          // 2 ints
         EEPROM_READ(start);                            // 2 ints
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
             bedlevel.set_grid(spacing, start);
             EEPROM_READ(bedlevel.z_values);                 // 9 to 256 floats
           }
+          else if (grid_max_x > (GRID_MAX_POINTS_X) || grid_max_y > (GRID_MAX_POINTS_Y)) {
+            eeprom_error = ERR_EEPROM_CORRUPT;
+            break;
+          }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
       //
       // X Axis Twist Compensation
@@ -2693,105 +2775,122 @@ void MarlinSettings::postprocess() {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(Y_AXIS, _data[0]);
         stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
       }
       #endif
 
       //
       // Validate Final Size and CRC
       //
-      eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
-      if (eeprom_error) {
-        DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
-        IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
+      const uint16_t eeprom_total = eeprom_index - (EEPROM_OFFSET);
+      if ((eeprom_error = size_error(eeprom_total))) {
+        // Handle below and on return
+        break;
       }
       else if (working_crc != stored_crc) {
-        eeprom_error = true;
-        DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        LCD_MESSAGE(MSG_ERR_EEPROM_CRC);
-        TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
-        IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
+        eeprom_error = ERR_EEPROM_CRC;
+        break;
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
-        DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
+        DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_total, " bytes; crc ", working_crc, ")");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
-      if (!validating && !eeprom_error) postprocess();
-
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           bedlevel.report_state();
 
           if (!bedlevel.sanity_check()) {
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               bedlevel.echo_name();
               DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
-            eeprom_error = true;
+            eeprom_error = ERR_EEPROM_CORRUPT;
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
               bedlevel.echo_name();
               DEBUG_ECHOLNPGM(".");
             #endif
             bedlevel.reset();
           }
 
           if (bedlevel.storage_slot >= 0) {
             load_mesh(bedlevel.storage_slot);
             DEBUG_ECHOLNPGM("Mesh ", bedlevel.storage_slot, " loaded from storage.");
           }
           else {
             bedlevel.reset();
             DEBUG_ECHOLNPGM("UBL reset");
           }
         }
       #endif
+
+    } while(0);
+
+    EEPROM_FINISH();
+
+    switch (eeprom_error) {
+      case ERR_EEPROM_NOERR:
+        if (!validating) postprocess();
+        break;
+      case ERR_EEPROM_SIZE:
+        DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
+        break;
+      case ERR_EEPROM_CORRUPT:
+        DEBUG_ERROR_MSG(STR_ERR_EEPROM_CORRUPT);
+        break;
+      case ERR_EEPROM_CRC:
+        DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
+        break;
+      default: break;
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
       // Report the EEPROM settings
       if (!validating && TERN1(EEPROM_BOOT_SILENT, IsRunning())) report();
     #endif
 
-    EEPROM_FINISH();
-
-    return !eeprom_error;
+    return eeprom_error;
   }
 
   #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
     extern bool restoreEEPROM();
   #endif
 
   bool MarlinSettings::validate() {
     validating = true;
     #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
-      bool success = _load();
-      if (!success && restoreEEPROM()) {
+      EEPROM_Error err = _load();
+      if (err != ERR_EEPROM_NOERR && restoreEEPROM()) {
         SERIAL_ECHOLNPGM("Recovered backup EEPROM settings from SPI Flash");
-        success = _load();
+        err = _load();
       }
     #else
-      const bool success = _load();
+      const EEPROM_Error err = _load();
     #endif
     validating = false;
-    return success;
+
+    if (err) ui.eeprom_alert(err);
+
+    return (err == ERR_EEPROM_NOERR);
   }
 
   bool MarlinSettings::load() {
     if (validate()) {
-      const bool success = _load();
+      const EEPROM_Error err = _load();
+      const bool success = (err == ERR_EEPROM_NOERR);
       TERN_(EXTENSIBLE_UI, ExtUI::onSettingsLoaded(success));
       return success;
     }
     reset();
     #if EITHER(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    üö∏ Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b6e605e853..58e00b7fb0 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -894,21 +894,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(planner.autotemp.min);
       EEPROM_WRITE(planner.autotemp.factor);
     #endif
 
     //
     // Mesh Bed Leveling
     //
     {
       #if ENABLED(MESH_BED_LEVELING)
         static_assert(
-          sizeof(bedlevel.z_values) == (GRID_MAX_POINTS) * sizeof(bedlevel.z_values[0][0]),
+          sizeof(bedlevel.z_values) == GRID_MAX_POINTS * sizeof(bedlevel.z_values[0][0]),
           "MBL Z array is the wrong size."
         );
       #else
         dummyf = 0;
       #endif
 
       const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
                     mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
 
       EEPROM_WRITE(TERN(MESH_BED_LEVELING, bedlevel.z_offset, dummyf));
@@ -948,21 +948,21 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
-          sizeof(bedlevel.z_values) == (GRID_MAX_POINTS) * sizeof(bedlevel.z_values[0][0]),
+          sizeof(bedlevel.z_values) == GRID_MAX_POINTS * sizeof(bedlevel.z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         EEPROM_WRITE(bedlevel.grid_spacing);

commit ed66f498eb713f59f14d000f8bfa550b34ce8528
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:38:24 2023 -0500

    üö∏ Fixed-Time Motion EEPROM and Menu (#25835)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 53e98a4626..b6e605e853 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -104,20 +104,24 @@
 #if HAS_POWER_MONITOR
   #include "../feature/power_monitor.h"
 #endif
 
 #include "../feature/pause.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
+#if ENABLED(FT_MOTION)
+  #include "../module/ft_motion.h"
+#endif
+
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
   #ifndef FIL_RUNOUT_ENABLED_DEFAULT
     #define FIL_RUNOUT_ENABLED_DEFAULT true
   #endif
 #endif
 
 #if ENABLED(ADVANCE_K_EXTRA)
   extern float other_extruder_advance_K[DISTINCT_E];
 #endif
@@ -587,30 +591,37 @@ typedef struct SettingsDataStruct {
     uint8_t ui_language;                                // M414 S
   #endif
 
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     MPC_t mpc_constants[HOTENDS];                       // M306
   #endif
 
+  //
+  // Fixed-Time Motion
+  //
+  #if ENABLED(FT_MOTION)
+    ft_config_t fxdTiCtrl_cfg;                          // M493
+  #endif
+
   //
   // Input Shaping
   //
   #if ENABLED(INPUT_SHAPING_X)
-    float shaping_x_frequency, // M593 X F
-          shaping_x_zeta;      // M593 X D
+    float shaping_x_frequency,                          // M593 X F
+          shaping_x_zeta;                               // M593 X D
   #endif
   #if ENABLED(INPUT_SHAPING_Y)
-    float shaping_y_frequency, // M593 Y F
-          shaping_y_zeta;      // M593 Y D
+    float shaping_y_frequency,                          // M593 Y F
+          shaping_y_zeta;                               // M593 Y D
   #endif
 
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
@@ -1641,20 +1652,28 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(ui.language);
     #endif
 
     //
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
       HOTEND_LOOP() EEPROM_WRITE(thermalManager.temp_hotend[e].mpc);
     #endif
 
+    //
+    // Fixed-Time Motion
+    //
+    #if ENABLED(FT_MOTION)
+      _FIELD_TEST(fxdTiCtrl_cfg);
+      EEPROM_WRITE(fxdTiCtrl.cfg);
+    #endif
+
     //
     // Input Shaping
     ///
     #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
@@ -2639,23 +2658,29 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(ui_language);
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
         ui.set_language(ui_language);
       }
       #endif
 
       //
       // Model predictive control
       //
       #if ENABLED(MPCTEMP)
-      {
         HOTEND_LOOP() EEPROM_READ(thermalManager.temp_hotend[e].mpc);
-      }
+      #endif
+
+      //
+      // Fixed-Time Motion
+      //
+      #if ENABLED(FT_MOTION)
+        _FIELD_TEST(fxdTiCtrl_cfg);
+        EEPROM_READ(fxdTiCtrl.cfg);
       #endif
 
       //
       // Input Shaping
       //
       #if ENABLED(INPUT_SHAPING_X)
       {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(X_AXIS, _data[0]);
@@ -3438,20 +3463,25 @@ void MarlinSettings::reset() {
       mpc.block_heat_capacity = _mpc_block_heat_capacity[e];
       mpc.sensor_responsiveness = _mpc_sensor_responsiveness[e];
       mpc.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
         mpc.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
       mpc.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
+  //
+  // Fixed-Time Motion
+  //
+  TERN_(FT_MOTION, fxdTiCtrl.set_defaults());
+
   //
   // Input Shaping
   //
   #if HAS_ZV_SHAPING
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
@@ -3699,20 +3729,25 @@ void MarlinSettings::reset() {
       // TMC Sensorless homing thresholds
       //
       TERN_(USE_SENSORLESS, gcode.M914_report(forReplay));
     #endif
 
     //
     // TMC stepping mode
     //
     TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
+    //
+    // Fixed-Time Motion
+    //
+    TERN_(FT_MOTION, gcode.M493_report(forReplay));
+
     //
     // Input Shaping
     //
     TERN_(HAS_ZV_SHAPING, gcode.M593_report(forReplay));
 
     //
     // Linear Advance
     //
     TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8ebc8c61f5..53e98a4626 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -174,24 +174,24 @@
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
 
 #define _EN_ITEM(N) , E##N
 #define _EN1_ITEM(N) , E##N:1
 
-typedef struct { uint16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint16_t;
-typedef struct { uint32_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint32_t;
-typedef struct {  int16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
-typedef struct {     bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1), X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
+typedef struct { uint16_t MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint16_t;
+typedef struct { uint32_t MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint32_t;
+typedef struct {  int16_t MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
+typedef struct {     bool NUM_AXIS_LIST_(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1) X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
@@ -218,21 +218,23 @@ typedef struct SettingsDataStruct {
   // Planner settings
   //
   planner_settings_t planner_settings;
 
   xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
   float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
   //
   // Home Offset
   //
-  xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
+  #if NUM_AXES
+    xyz_pos_t home_offset;                              // M206 XYZ / M665 TPZ
+  #endif
 
   //
   // Hotend Offset
   //
   #if HAS_HOTEND_OFFSET
     xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
   #endif
 
   //
   // FILAMENT_RUNOUT_SENSOR
@@ -257,22 +259,23 @@ typedef struct SettingsDataStruct {
   // MESH_BED_LEVELING
   //
   float mbl_z_offset;                                   // bedlevel.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // bedlevel.z_values
                     [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
   //
-
-  xyz_pos_t probe_offset;                               // M851 X Y Z
+  #if NUM_AXES
+    xyz_pos_t probe_offset;                             // M851 X Y Z
+  #endif
 
   //
   // ABL_PLANAR
   //
   matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
 
   //
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
@@ -468,21 +471,23 @@ typedef struct SettingsDataStruct {
       #define MOTOR_CURRENT_COUNT DIGIPOT_I2C_NUM_CHANNELS
     #else // HAS_MOTOR_CURRENT_SPI
       #define MOTOR_CURRENT_COUNT DISTINCT_AXES
     #endif
   #endif
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
-  xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
+  #if NUM_AXES
+    xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS]; // G54-G59.3
+  #endif
 
   //
   // SKEW_CORRECTION
   //
   #if ENABLED(SKEW_CORRECTION)
     skew_factor_t planner_skew_factor;                  // M852 I J K
   #endif
 
   //
   // ADVANCED_PAUSE_FEATURE
@@ -494,23 +499,25 @@ typedef struct SettingsDataStruct {
   //
   // Tool-change settings
   //
   #if HAS_MULTI_EXTRUDER
     toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
   //
   // BACKLASH_COMPENSATION
   //
-  xyz_float_t backlash_distance_mm;                     // M425 X Y Z
-  uint8_t backlash_correction;                          // M425 F
-  float backlash_smoothing_mm;                          // M425 S
+  #if NUM_AXES
+    xyz_float_t backlash_distance_mm;                   // M425 X Y Z
+    uint8_t backlash_correction;                        // M425 F
+    float backlash_smoothing_mm;                        // M425 S
+  #endif
 
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
@@ -806,32 +813,34 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
       TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
     // Home Offset
     //
+    #if NUM_AXES
     {
       _FIELD_TEST(home_offset);
 
       #if HAS_SCARA_OFFSET
         EEPROM_WRITE(scara_home_offset);
       #else
         #if !HAS_HOME_OFFSET
           const xyz_pos_t home_offset{0};
         #endif
         EEPROM_WRITE(home_offset);
       #endif
     }
+    #endif // NUM_AXES
 
     //
     // Hotend Offsets, if any
     //
     {
       #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
         LOOP_S_L_N(e, 1, HOTENDS)
           EEPROM_WRITE(hotend_offset[e]);
       #endif
@@ -898,29 +907,31 @@ void MarlinSettings::postprocess() {
       #if ENABLED(MESH_BED_LEVELING)
         EEPROM_WRITE(bedlevel.z_values);
       #else
         for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Probe XYZ Offsets
     //
+    #if NUM_AXES
     {
       _FIELD_TEST(probe_offset);
       #if HAS_BED_PROBE
         const xyz_pos_t &zpo = probe.offset;
       #else
         constexpr xyz_pos_t zpo{0};
       #endif
       EEPROM_WRITE(zpo);
     }
+    #endif
 
     //
     // Planar Bed Leveling matrix
     //
     {
       #if ABL_PLANAR
         EEPROM_WRITE(planner.bed_level_matrix);
       #else
         dummyf = 0;
         for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
@@ -1357,21 +1368,21 @@ void MarlinSettings::postprocess() {
         TERN_(E1_HAS_STEALTHCHOP, tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs());
         TERN_(E2_HAS_STEALTHCHOP, tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs());
         TERN_(E3_HAS_STEALTHCHOP, tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs());
         TERN_(E4_HAS_STEALTHCHOP, tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs());
         TERN_(E5_HAS_STEALTHCHOP, tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs());
         TERN_(E6_HAS_STEALTHCHOP, tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs());
         TERN_(E7_HAS_STEALTHCHOP, tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs());
       #else
         #define _EN_ITEM(N) , .E##N =  30
         const per_stepper_uint32_t tmc_hybrid_threshold = {
-          NUM_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3, .U = 3, .V = 3, .W = 3),
+          NUM_AXIS_LIST_(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3, .U = 3, .V = 3, .W = 3)
           .X2 = 100, .Y2 = 100, .Z2 = 3, .Z3 = 3, .Z4 = 3
           REPEAT(E_STEPPERS, _EN_ITEM)
         };
         #undef _EN_ITEM
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
@@ -1455,27 +1466,27 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(stepper.motor_current_setting);
       #else
         const uint32_t no_current[MOTOR_CURRENT_COUNT] = { 0 };
         EEPROM_WRITE(no_current);
       #endif
     }
 
     //
     // CNC Coordinate Systems
     //
-
-    _FIELD_TEST(coordinate_system);
-
-    #if DISABLED(CNC_COORDINATE_SYSTEMS)
-      const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
+    #if NUM_AXES
+      _FIELD_TEST(coordinate_system);
+      #if DISABLED(CNC_COORDINATE_SYSTEMS)
+        const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
+      #endif
+      EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
     #endif
-    EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
 
     //
     // Skew correction factors
     //
     #if ENABLED(SKEW_CORRECTION)
       _FIELD_TEST(planner_skew_factor);
       EEPROM_WRITE(planner.skew_factor);
     #endif
 
     //
@@ -1496,39 +1507,41 @@ void MarlinSettings::postprocess() {
     //
 
     #if HAS_MULTI_EXTRUDER
       _FIELD_TEST(toolchange_settings);
       EEPROM_WRITE(toolchange_settings);
     #endif
 
     //
     // Backlash Compensation
     //
+    #if NUM_AXES
     {
       #if ENABLED(BACKLASH_GCODE)
         xyz_float_t backlash_distance_mm;
         LOOP_NUM_AXES(axis) backlash_distance_mm[axis] = backlash.get_distance_mm((AxisEnum)axis);
         const uint8_t backlash_correction = backlash.get_correction_uint8();
       #else
         const xyz_float_t backlash_distance_mm{0};
         const uint8_t backlash_correction = 0;
       #endif
       #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
         const float backlash_smoothing_mm = backlash.get_smoothing_mm();
       #else
         const float backlash_smoothing_mm = 3;
       #endif
       _FIELD_TEST(backlash_distance_mm);
       EEPROM_WRITE(backlash_distance_mm);
       EEPROM_WRITE(backlash_correction);
       EEPROM_WRITE(backlash_smoothing_mm);
     }
+    #endif // NUM_AXES
 
     //
     // Extensible UI User Data
     //
     #if ENABLED(EXTENSIBLE_UI)
     {
       char extui_data[ExtUI::eeprom_data_size] = { 0 };
       ExtUI::onStoreSettings(extui_data);
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
@@ -1768,32 +1781,34 @@ void MarlinSettings::postprocess() {
         #else
           for (uint8_t q = LOGICAL_AXES; q--;) EEPROM_READ(dummyf);
         #endif
 
         EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
       }
 
       //
       // Home Offset (M206 / M665)
       //
+      #if NUM_AXES
       {
         _FIELD_TEST(home_offset);
 
         #if HAS_SCARA_OFFSET
           EEPROM_READ(scara_home_offset);
         #else
           #if !HAS_HOME_OFFSET
             xyz_pos_t home_offset;
           #endif
           EEPROM_READ(home_offset);
         #endif
       }
+      #endif // NUM_AXES
 
       //
       // Hotend Offsets, if any
       //
       {
         #if HAS_HOTEND_OFFSET
           // Skip hotend 0 which must be 0
           LOOP_S_L_N(e, 1, HOTENDS)
             EEPROM_READ(hotend_offset[e]);
         #endif
@@ -1855,29 +1870,31 @@ void MarlinSettings::postprocess() {
           }
         #else
           // MBL is disabled - skip the stored data
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
         #endif
       }
 
       //
       // Probe Z Offset
       //
+      #if NUM_AXES
       {
         _FIELD_TEST(probe_offset);
         #if HAS_BED_PROBE
           const xyz_pos_t &zpo = probe.offset;
         #else
           xyz_pos_t zpo;
         #endif
         EEPROM_READ(zpo);
       }
+      #endif
 
       //
       // Planar Bed Leveling matrix
       //
       {
         #if ABL_PLANAR
           EEPROM_READ(planner.bed_level_matrix);
         #else
           for (uint8_t q = 9; q--;) EEPROM_READ(dummyf);
         #endif
@@ -2432,30 +2449,32 @@ void MarlinSettings::postprocess() {
         #endif
         #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
           if (!validating)
             COPY(stepper.motor_current_setting, motor_current_setting);
         #endif
       }
 
       //
       // CNC Coordinate System
       //
+      #if NUM_AXES
       {
         _FIELD_TEST(coordinate_system);
         #if ENABLED(CNC_COORDINATE_SYSTEMS)
           if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
           EEPROM_READ(gcode.coordinate_system);
         #else
           xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
           EEPROM_READ(coordinate_system);
         #endif
       }
+      #endif
 
       //
       // Skew correction factors
       //
       #if ENABLED(SKEW_CORRECTION)
       {
         skew_factor_t skew_factor;
         _FIELD_TEST(planner_skew_factor);
         EEPROM_READ(skew_factor);
         #if ENABLED(SKEW_CORRECTION_GCODE)
@@ -2487,38 +2506,40 @@ void MarlinSettings::postprocess() {
       // Tool-change settings
       //
       #if HAS_MULTI_EXTRUDER
         _FIELD_TEST(toolchange_settings);
         EEPROM_READ(toolchange_settings);
       #endif
 
       //
       // Backlash Compensation
       //
+      #if NUM_AXES
       {
         xyz_float_t backlash_distance_mm;
         uint8_t backlash_correction;
         float backlash_smoothing_mm;
 
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
 
         #if ENABLED(BACKLASH_GCODE)
           LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, backlash_distance_mm[axis]);
           backlash.set_correction_uint8(backlash_correction);
           #ifdef BACKLASH_SMOOTHING_MM
             backlash.set_smoothing_mm(backlash_smoothing_mm);
           #endif
         #endif
       }
+      #endif // NUM_AXES
 
       //
       // Extensible UI User Data
       //
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
@@ -2896,21 +2917,21 @@ void MarlinSettings::reset() {
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
   planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
   #if HAS_CLASSIC_JERK
-    #ifndef DEFAULT_XJERK
+    #if HAS_X_AXIS && !defined(DEFAULT_XJERK)
       #define DEFAULT_XJERK 0
     #endif
     #if HAS_Y_AXIS && !defined(DEFAULT_YJERK)
       #define DEFAULT_YJERK 0
     #endif
     #if HAS_Z_AXIS && !defined(DEFAULT_ZJERK)
       #define DEFAULT_ZJERK 0
     #endif
     #if HAS_I_AXIS && !defined(DEFAULT_IJERK)
       #define DEFAULT_IJERK 0

commit 9a1c02591ba4c3d5b41f4c64edd819ea1860b75b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 17:51:45 2023 -0500

    üßë‚Äçüíª Status Message cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ca5b940c5d..8ebc8c61f5 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1699,21 +1699,21 @@ void MarlinSettings::postprocess() {
     char stored_ver[4];
     EEPROM_READ_ALWAYS(stored_ver);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      TERN_(DWIN_LCD_PROUI, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
+      LCD_MESSAGE(MSG_ERR_EEPROM_VERSION);
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_VERSION)));
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
 
       // Optionally reset on the first boot after flashing
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
@@ -2655,21 +2655,21 @@ void MarlinSettings::postprocess() {
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        TERN_(DWIN_LCD_PROUI, LCD_MESSAGE(MSG_ERR_EEPROM_CRC));
+        LCD_MESSAGE(MSG_ERR_EEPROM_CRC);
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 

commit f5c7b190f6169f0a213ef4b088e9c4b5ef33b2b8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 23:22:36 2023 -0500

    üêõ Fix BLTOUCH_HS_MODE config

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0be7f965a4..ca5b940c5d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -315,21 +315,21 @@ typedef struct SettingsDataStruct {
     #endif
     #if ENABLED(PTC_HOTEND)
       int16_t z_offsets_hotend[COUNT(ptc.z_offsets_hotend)]; // M871 E I V
     #endif
   #endif
 
   //
   // BLTOUCH
   //
   bool bltouch_od_5v_mode;
-  #ifdef BLTOUCH_HS_MODE
+  #if HAS_BLTOUCH_HS_MODE
     bool bltouch_high_speed_mode;                       // M401 S
   #endif
 
   //
   // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
   //
   #if IS_KINEMATIC
     float segments_per_second;                          // M665 S
     #if ENABLED(DELTA)
       float delta_height;                               // M666 H
@@ -1009,21 +1009,21 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
     // BLTOUCH
     //
     {
       _FIELD_TEST(bltouch_od_5v_mode);
       const bool bltouch_od_5v_mode = TERN0(BLTOUCH, bltouch.od_5v_mode);
       EEPROM_WRITE(bltouch_od_5v_mode);
 
-      #ifdef BLTOUCH_HS_MODE
+      #if HAS_BLTOUCH_HS_MODE
         _FIELD_TEST(bltouch_high_speed_mode);
         const bool bltouch_high_speed_mode = TERN0(BLTOUCH, bltouch.high_speed_mode);
         EEPROM_WRITE(bltouch_high_speed_mode);
       #endif
     }
 
     //
     // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
     //
     #if IS_KINEMATIC
@@ -1969,21 +1969,21 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(bltouch_od_5v_mode);
         #if ENABLED(BLTOUCH)
           const bool &bltouch_od_5v_mode = bltouch.od_5v_mode;
         #else
           bool bltouch_od_5v_mode;
         #endif
         EEPROM_READ(bltouch_od_5v_mode);
 
-        #ifdef BLTOUCH_HS_MODE
+        #if HAS_BLTOUCH_HS_MODE
           _FIELD_TEST(bltouch_high_speed_mode);
           #if ENABLED(BLTOUCH)
             const bool &bltouch_high_speed_mode = bltouch.high_speed_mode;
           #else
             bool bltouch_high_speed_mode;
           #endif
           EEPROM_READ(bltouch_high_speed_mode);
         #endif
       }
 
@@ -3068,23 +3068,21 @@ void MarlinSettings::reset() {
   TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
 
   //
   // Probe Temperature Compensation
   //
   TERN_(HAS_PTC, ptc.reset());
 
   //
   // BLTouch
   //
-  #ifdef BLTOUCH_HS_MODE
-    bltouch.high_speed_mode = ENABLED(BLTOUCH_HS_MODE);
-  #endif
+  TERN_(HAS_BLTOUCH_HS_MODE, bltouch.high_speed_mode = BLTOUCH_HS_MODE);
 
   //
   // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
   //
 
   #if IS_KINEMATIC
     segments_per_second = DEFAULT_SEGMENTS_PER_SECOND;
     #if ENABLED(DELTA)
       const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
       delta_height = DELTA_HEIGHT;

commit 8cdf43f8fdf8900ad903d094d1aeb5dc651b324b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 20:26:49 2023 -0500

    üé®  HAS_SHAPING => HAS_ZV_SHAPING

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8b615f2faf..0be7f965a4 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1631,21 +1631,21 @@ void MarlinSettings::postprocess() {
     //
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
       HOTEND_LOOP() EEPROM_WRITE(thermalManager.temp_hotend[e].mpc);
     #endif
 
     //
     // Input Shaping
     ///
-    #if HAS_SHAPING
+    #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
       #endif
     #endif
 
@@ -3422,21 +3422,21 @@ void MarlinSettings::reset() {
       #if ENABLED(MPC_INCLUDE_FAN)
         mpc.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
       mpc.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   //
   // Input Shaping
   //
-  #if HAS_SHAPING
+  #if HAS_ZV_SHAPING
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
     #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
   #endif
 
@@ -3683,21 +3683,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // TMC stepping mode
     //
     TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
     //
     // Input Shaping
     //
-    TERN_(HAS_SHAPING, gcode.M593_report(forReplay));
+    TERN_(HAS_ZV_SHAPING, gcode.M593_report(forReplay));
 
     //
     // Linear Advance
     //
     TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 
     //
     // Motor Current (SPI or PWM)
     //
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM

commit 6fe387b6f0722033e6cca96fd5e8215ea7b162eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 15 06:48:17 2023 -0600

    üßë‚Äçüíª Adjust PID / MPC / ProUI
    
    Changes to simplify #25232 WIP

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index afdbf3d103..8b615f2faf 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1625,22 +1625,21 @@ void MarlinSettings::postprocess() {
     // Selected LCD language
     //
     #if HAS_MULTI_LANGUAGE
       EEPROM_WRITE(ui.language);
     #endif
 
     //
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
-      HOTEND_LOOP()
-        EEPROM_WRITE(thermalManager.temp_hotend[e].constants);
+      HOTEND_LOOP() EEPROM_WRITE(thermalManager.temp_hotend[e].mpc);
     #endif
 
     //
     // Input Shaping
     ///
     #if HAS_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
@@ -2620,22 +2619,21 @@ void MarlinSettings::postprocess() {
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
         ui.set_language(ui_language);
       }
       #endif
 
       //
       // Model predictive control
       //
       #if ENABLED(MPCTEMP)
       {
-        HOTEND_LOOP()
-          EEPROM_READ(thermalManager.temp_hotend[e].constants);
+        HOTEND_LOOP() EEPROM_READ(thermalManager.temp_hotend[e].mpc);
       }
       #endif
 
       //
       // Input Shaping
       //
       #if ENABLED(INPUT_SHAPING_X)
       {
         float _data[2];
         EEPROM_READ(_data);
@@ -3409,29 +3407,29 @@ void MarlinSettings::reset() {
     static_assert(COUNT(_mpc_heater_power) == HOTENDS, "MPC_HEATER_POWER must have HOTENDS items.");
     static_assert(COUNT(_mpc_block_heat_capacity) == HOTENDS, "MPC_BLOCK_HEAT_CAPACITY must have HOTENDS items.");
     static_assert(COUNT(_mpc_sensor_responsiveness) == HOTENDS, "MPC_SENSOR_RESPONSIVENESS must have HOTENDS items.");
     static_assert(COUNT(_mpc_ambient_xfer_coeff) == HOTENDS, "MPC_AMBIENT_XFER_COEFF must have HOTENDS items.");
     #if ENABLED(MPC_INCLUDE_FAN)
       static_assert(COUNT(_mpc_ambient_xfer_coeff_fan255) == HOTENDS, "MPC_AMBIENT_XFER_COEFF_FAN255 must have HOTENDS items.");
     #endif
     static_assert(COUNT(_filament_heat_capacity_permm) == HOTENDS, "FILAMENT_HEAT_CAPACITY_PERMM must have HOTENDS items.");
 
     HOTEND_LOOP() {
-      MPC_t &constants = thermalManager.temp_hotend[e].constants;
-      constants.heater_power = _mpc_heater_power[e];
-      constants.block_heat_capacity = _mpc_block_heat_capacity[e];
-      constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
-      constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
+      MPC_t &mpc = thermalManager.temp_hotend[e].mpc;
+      mpc.heater_power = _mpc_heater_power[e];
+      mpc.block_heat_capacity = _mpc_block_heat_capacity[e];
+      mpc.sensor_responsiveness = _mpc_sensor_responsiveness[e];
+      mpc.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
-        constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
+        mpc.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
-      constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
+      mpc.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   //
   // Input Shaping
   //
   #if HAS_SHAPING
     #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);

commit c3fe4abd446336c50bdb892f08fa24a08f1bdda5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 7 22:59:25 2023 -0600

    üî® DGUS_LCD_UI version check

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 1b6f157479..afdbf3d103 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -159,21 +159,21 @@
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   #include "../libs/buzzer.h"
 #endif
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
-#if ENABLED(DGUS_LCD_UI_MKS)
+#if DGUS_LCD_UI_MKS
   #include "../lcd/extui/dgus/DGUSScreenHandler.h"
   #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
@@ -562,21 +562,21 @@ typedef struct SettingsDataStruct {
   //
   // Fan tachometer check
   //
   #if HAS_FANCHECK
     bool fan_check_enabled;
   #endif
 
   //
   // MKS UI controller
   //
-  #if ENABLED(DGUS_LCD_UI_MKS)
+  #if DGUS_LCD_UI_MKS
     MKS_Language mks_language_index;                    // Display Language
     xy_int_t mks_corner_offsets[5];                     // Bed Tramming
     xyz_int_t mks_park_pos;                             // Custom Parking (without NOZZLE_PARK)
     celsius_t mks_min_extrusion_temp;                   // Min E Temp (shadow M302 value)
   #endif
 
   #if HAS_MULTI_LANGUAGE
     uint8_t ui_language;                                // M414 S
   #endif
 
@@ -1607,21 +1607,21 @@ void MarlinSettings::postprocess() {
     //
     // Fan tachometer check
     //
     #if HAS_FANCHECK
       EEPROM_WRITE(fan_check.enabled);
     #endif
 
     //
     // MKS UI controller
     //
-    #if ENABLED(DGUS_LCD_UI_MKS)
+    #if DGUS_LCD_UI_MKS
       EEPROM_WRITE(mks_language_index);
       EEPROM_WRITE(mks_corner_offsets);
       EEPROM_WRITE(mks_park_pos);
       EEPROM_WRITE(mks_min_extrusion_temp);
     #endif
 
     //
     // Selected LCD language
     //
     #if HAS_MULTI_LANGUAGE
@@ -2595,21 +2595,21 @@ void MarlinSettings::postprocess() {
       // Fan tachometer check
       //
       #if HAS_FANCHECK
         _FIELD_TEST(fan_check_enabled);
         EEPROM_READ(fan_check.enabled);
       #endif
 
       //
       // MKS UI controller
       //
-      #if ENABLED(DGUS_LCD_UI_MKS)
+      #if DGUS_LCD_UI_MKS
         _FIELD_TEST(mks_language_index);
         EEPROM_READ(mks_language_index);
         EEPROM_READ(mks_corner_offsets);
         EEPROM_READ(mks_park_pos);
         EEPROM_READ(mks_min_extrusion_temp);
       #endif
 
       //
       // Selected LCD language
       //

commit c66b3cf8a429c427c014f33171407c634da735f1
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 8 04:22:21 2023 -0500

    üö∏ ProUI updates (#25176)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 9a7635fc51..1b6f157479 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2520,21 +2520,21 @@ void MarlinSettings::postprocess() {
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
       }
       #endif
 
       //
-      // Creality DWIN User Data
+      // DWIN User Data
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
@@ -2845,21 +2845,21 @@ void MarlinSettings::postprocess() {
           if (into) {
             float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
             bedlevel.set_mesh_from_store(z_mesh_store, z_values);
             memcpy(into, z_values, sizeof(z_values));
           }
           else
             bedlevel.set_mesh_from_store(z_mesh_store, bedlevel.z_values);
         #endif
 
         #if ENABLED(DWIN_LCD_PROUI)
-          status = !BedLevelTools.meshvalidate();
+          status = !bedLevelTools.meshvalidate();
           if (status) {
             bedlevel.invalidate();
             LCD_MESSAGE(MSG_UBL_MESH_INVALID);
           }
           else
             ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), bedlevel.storage_slot);
         #endif
 
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        DEBUG_ECHOLNPGM("Mesh loaded from slot ", slot);

commit 88242e0b5ce32111df3b28132ff8d2ca5c37264c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Dec 31 16:55:15 2022 +1300

    üßë‚Äçüíª Fix type warning (#25149)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 354fb4b172..9a7635fc51 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3306,21 +3306,21 @@ void MarlinSettings::reset() {
 
   reset_stepper_drivers();
 
   //
   // Linear Advance
   //
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       constexpr float linAdvanceK[] = ADVANCE_K;
       EXTRUDER_LOOP() {
-        const float a = linAdvanceK[_MAX(e, COUNT(linAdvanceK) - 1)];
+        const float a = linAdvanceK[_MAX(uint8_t(e), COUNT(linAdvanceK) - 1)];
         planner.extruder_advance_K[e] = a;
         TERN_(ADVANCE_K_EXTRA, other_extruder_advance_K[e] = a);
       }
     #else
       planner.extruder_advance_K[0] = ADVANCE_K;
     #endif
   #endif
 
   //
   // Motor Current PWM

commit c7e84e8ef145a35b2c90e1a6f1d908929cc46d83
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Dec 31 15:59:13 2022 +1300

    ‚ú® Persistent AUTOTEMP settings (#25093)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index aa0cfe52f7..354fb4b172 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -238,20 +238,28 @@ typedef struct SettingsDataStruct {
   // FILAMENT_RUNOUT_SENSOR
   //
   bool runout_sensor_enabled;                           // M412 S
   float runout_distance_mm;                             // M412 D
 
   //
   // ENABLE_LEVELING_FADE_HEIGHT
   //
   float planner_z_fade_height;                          // M420 Zn  planner.z_fade_height
 
+  //
+  // AUTOTEMP
+  //
+  #if ENABLED(AUTOTEMP)
+    celsius_t planner_autotemp_max, planner_autotemp_min;
+    float planner_autotemp_factor;
+  #endif
+
   //
   // MESH_BED_LEVELING
   //
   float mbl_z_offset;                                   // bedlevel.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // bedlevel.z_values
                     [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
@@ -465,21 +473,23 @@ typedef struct SettingsDataStruct {
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
   //
-  skew_factor_t planner_skew_factor;                    // M852 I J K
+  #if ENABLED(SKEW_CORRECTION)
+    skew_factor_t planner_skew_factor;                  // M852 I J K
+  #endif
 
   //
   // ADVANCED_PAUSE_FEATURE
   //
   #if HAS_EXTRUDERS
     fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
   #endif
 
   //
   // Tool-change settings
@@ -848,20 +858,30 @@ void MarlinSettings::postprocess() {
     }
 
     //
     // Global Leveling
     //
     {
       const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, (DEFAULT_LEVELING_FADE_HEIGHT));
       EEPROM_WRITE(zfh);
     }
 
+    //
+    // AUTOTEMP
+    //
+    #if ENABLED(AUTOTEMP)
+      _FIELD_TEST(planner_autotemp_max);
+      EEPROM_WRITE(planner.autotemp.max);
+      EEPROM_WRITE(planner.autotemp.min);
+      EEPROM_WRITE(planner.autotemp.factor);
+    #endif
+
     //
     // Mesh Bed Leveling
     //
     {
       #if ENABLED(MESH_BED_LEVELING)
         static_assert(
           sizeof(bedlevel.z_values) == (GRID_MAX_POINTS) * sizeof(bedlevel.z_values[0][0]),
           "MBL Z array is the wrong size."
         );
       #else
@@ -1446,22 +1466,24 @@ void MarlinSettings::postprocess() {
     _FIELD_TEST(coordinate_system);
 
     #if DISABLED(CNC_COORDINATE_SYSTEMS)
       const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
     #endif
     EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
 
     //
     // Skew correction factors
     //
-    _FIELD_TEST(planner_skew_factor);
-    EEPROM_WRITE(planner.skew_factor);
+    #if ENABLED(SKEW_CORRECTION)
+      _FIELD_TEST(planner_skew_factor);
+      EEPROM_WRITE(planner.skew_factor);
+    #endif
 
     //
     // Advanced Pause filament load & unload lengths
     //
     #if HAS_EXTRUDERS
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
         const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
       #endif
       _FIELD_TEST(fc_settings);
@@ -1796,20 +1818,29 @@ void MarlinSettings::postprocess() {
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
 
       //
       // Global Leveling
       //
       EEPROM_READ(TERN(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height, dummyf));
 
+      //
+      // AUTOTEMP
+      //
+      #if ENABLED(AUTOTEMP)
+        EEPROM_READ(planner.autotemp.max);
+        EEPROM_READ(planner.autotemp.min);
+        EEPROM_READ(planner.autotemp.factor);
+      #endif
+
       //
       // Mesh (Manual) Bed Leveling
       //
       {
         uint8_t mesh_num_x, mesh_num_y;
         EEPROM_READ(dummyf);
         EEPROM_READ_ALWAYS(mesh_num_x);
         EEPROM_READ_ALWAYS(mesh_num_y);
 
         #if ENABLED(MESH_BED_LEVELING)
@@ -2416,34 +2447,36 @@ void MarlinSettings::postprocess() {
           EEPROM_READ(gcode.coordinate_system);
         #else
           xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
           EEPROM_READ(coordinate_system);
         #endif
       }
 
       //
       // Skew correction factors
       //
+      #if ENABLED(SKEW_CORRECTION)
       {
         skew_factor_t skew_factor;
         _FIELD_TEST(planner_skew_factor);
         EEPROM_READ(skew_factor);
         #if ENABLED(SKEW_CORRECTION_GCODE)
           if (!validating) {
             planner.skew_factor.xy = skew_factor.xy;
             #if ENABLED(SKEW_CORRECTION_FOR_Z)
               planner.skew_factor.xz = skew_factor.xz;
               planner.skew_factor.yz = skew_factor.yz;
             #endif
           }
         #endif
       }
+      #endif
 
       //
       // Advanced Pause filament load & unload lengths
       //
       #if HAS_EXTRUDERS
       {
         #if DISABLED(ADVANCED_PAUSE_FEATURE)
           fil_change_settings_t fc_settings[EXTRUDERS];
         #endif
         _FIELD_TEST(fc_settings);
@@ -2992,20 +3025,29 @@ void MarlinSettings::reset() {
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));
   TERN_(HAS_LEVELING, reset_bed_level());
 
+  //
+  // AUTOTEMP
+  //
+  #if ENABLED(AUTOTEMP)
+    planner.autotemp.max = AUTOTEMP_MAX;
+    planner.autotemp.min = AUTOTEMP_MIN;
+    planner.autotemp.factor = AUTOTEMP_FACTOR;
+  #endif
+
   //
   // X Axis Twist Compensation
   //
   TERN_(X_AXIS_TWIST_COMPENSATION, xatc.reset());
 
   //
   // Nozzle-to-probe Offset
   //
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;

commit 5200b36ae44a814963bba0d68c4b76364dc98847
Author: MarkMan0 <38912829+MarkMan0@users.noreply.github.com>
Date:   Sun Dec 18 06:48:33 2022 +0100

    üêõ Fix, Refactor PID scaling (#25096)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4ae4c19922..aa0cfe52f7 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1088,35 +1088,35 @@ void MarlinSettings::postprocess() {
       const int16_t lpq_len = TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, 20);
       EEPROM_WRITE(lpq_len);
     }
 
     //
     // PIDTEMPBED
     //
     {
       _FIELD_TEST(bedPID);
       #if ENABLED(PIDTEMPBED)
-        const PID_t &pid = thermalManager.temp_bed.pid;
+        const auto &pid = thermalManager.temp_bed.pid;
         const raw_pid_t bed_pid = { pid.p(), pid.i(), pid.d() };
       #else
         const raw_pid_t bed_pid = { NAN, NAN, NAN };
       #endif
       EEPROM_WRITE(bed_pid);
     }
 
     //
     // PIDTEMPCHAMBER
     //
     {
       _FIELD_TEST(chamberPID);
       #if ENABLED(PIDTEMPCHAMBER)
-        const PID_t &pid = thermalManager.temp_chamber.pid;
+        const auto &pid = thermalManager.temp_chamber.pid;
         const raw_pid_t chamber_pid = { pid.p(), pid.i(), pid.d() };
       #else
         const raw_pid_t chamber_pid = { NAN, NAN, NAN };
       #endif
       EEPROM_WRITE(chamber_pid);
     }
 
     //
     // User-defined Thermistors
     //

commit 6d87dafc6e883ca5150210e27ce965394d3fc69f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Dec 12 16:46:50 2022 -0600

    ü©π Fix M502 init of default motion
    
    Fix regression from #25035

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index de38cf2377..4ae4c19922 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -186,20 +186,22 @@ typedef struct { uint32_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS,
 typedef struct {  int16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
 typedef struct {     bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1), X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
+static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
+static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 /**
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   #if ENABLED(EEPROM_INIT_NOW)

commit b4fbe4ff5023c3dace1aead7aac84feb0b793131
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Dec 10 17:28:48 2022 +0000

    ‚ö°Ô∏è Better IS buffer size calc (#25035)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4ae4c19922..de38cf2377 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -186,22 +186,20 @@ typedef struct { uint32_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS,
 typedef struct {  int16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
 typedef struct {     bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1), X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
-static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
-static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 /**
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   #if ENABLED(EEPROM_INIT_NOW)

commit 89334caa526f2d300eee834d34d06d8f837a57d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 28 03:38:15 2022 +0000

    ‚ö°Ô∏è Input Shaping improvements (#24951)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 921b0d91cb..4ae4c19922 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -573,25 +573,25 @@ typedef struct SettingsDataStruct {
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     MPC_t mpc_constants[HOTENDS];                       // M306
   #endif
 
   //
   // Input Shaping
   //
-  #if HAS_SHAPING_X
+  #if ENABLED(INPUT_SHAPING_X)
     float shaping_x_frequency, // M593 X F
           shaping_x_zeta;      // M593 X D
   #endif
-  #if HAS_SHAPING_Y
+  #if ENABLED(INPUT_SHAPING_Y)
     float shaping_y_frequency, // M593 Y F
           shaping_y_zeta;      // M593 Y D
   #endif
 
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
@@ -1610,26 +1610,26 @@ void MarlinSettings::postprocess() {
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
       HOTEND_LOOP()
         EEPROM_WRITE(thermalManager.temp_hotend[e].constants);
     #endif
 
     //
     // Input Shaping
     ///
-    #if ENABLED(INPUT_SHAPING)
-      #if HAS_SHAPING_X
+    #if HAS_SHAPING
+      #if ENABLED(INPUT_SHAPING_X)
         EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
       #endif
-      #if HAS_SHAPING_Y
+      #if ENABLED(INPUT_SHAPING_Y)
         EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
         EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
       #endif
     #endif
 
     //
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
@@ -2595,30 +2595,30 @@ void MarlinSettings::postprocess() {
       #if ENABLED(MPCTEMP)
       {
         HOTEND_LOOP()
           EEPROM_READ(thermalManager.temp_hotend[e].constants);
       }
       #endif
 
       //
       // Input Shaping
       //
-      #if HAS_SHAPING_X
+      #if ENABLED(INPUT_SHAPING_X)
       {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(X_AXIS, _data[0]);
         stepper.set_shaping_damping_ratio(X_AXIS, _data[1]);
       }
       #endif
 
-      #if HAS_SHAPING_Y
+      #if ENABLED(INPUT_SHAPING_Y)
       {
         float _data[2];
         EEPROM_READ(_data);
         stepper.set_shaping_frequency(Y_AXIS, _data[0]);
         stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
       }
       #endif
 
       //
       // Validate Final Size and CRC
@@ -3382,26 +3382,26 @@ void MarlinSettings::reset() {
       #if ENABLED(MPC_INCLUDE_FAN)
         constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
       constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   //
   // Input Shaping
   //
-  #if ENABLED(INPUT_SHAPING)
-    #if HAS_SHAPING_X
+  #if HAS_SHAPING
+    #if ENABLED(INPUT_SHAPING_X)
       stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
       stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
     #endif
-    #if HAS_SHAPING_Y
+    #if ENABLED(INPUT_SHAPING_Y)
       stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
       stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
     #endif
   #endif
 
   postprocess();
 
   #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
@@ -3643,21 +3643,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // TMC stepping mode
     //
     TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
     //
     // Input Shaping
     //
-    TERN_(INPUT_SHAPING, gcode.M593_report(forReplay));
+    TERN_(HAS_SHAPING, gcode.M593_report(forReplay));
 
     //
     // Linear Advance
     //
     TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 
     //
     // Motor Current (SPI or PWM)
     //
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM

commit 86276a6dd2c5e7f8f7a3c6e02c6d08af11f64998
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Nov 26 08:23:24 2022 +0100

    üö∏ COLOR_UI sleep timeout / setting (#24994)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 5d1ef71d66..921b0d91cb 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -651,21 +651,21 @@ void MarlinSettings::postprocess() {
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 
   #if LCD_BACKLIGHT_TIMEOUT_MINS
     ui.refresh_backlight_timeout();
-  #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
+  #elif HAS_DISPLAY_SLEEP
     ui.refresh_screen_timeout();
   #endif
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."

commit 74474c8a818745f1324aa5e22e59c361b4dff609
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 26 19:21:47 2022 +1300

    üîß Fix TPARA (‚Ä¶SCARA, DELTA) settings (#25016)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a090b140ad..5d1ef71d66 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3037,25 +3037,21 @@ void MarlinSettings::reset() {
   //
   #ifdef BLTOUCH_HS_MODE
     bltouch.high_speed_mode = ENABLED(BLTOUCH_HS_MODE);
   #endif
 
   //
   // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
   //
 
   #if IS_KINEMATIC
-    segments_per_second = (
-      TERN_(DELTA, DELTA_SEGMENTS_PER_SECOND)
-      TERN_(IS_SCARA, SCARA_SEGMENTS_PER_SECOND)
-      TERN_(POLARGRAPH, POLAR_SEGMENTS_PER_SECOND)
-    );
+    segments_per_second = DEFAULT_SEGMENTS_PER_SECOND;
     #if ENABLED(DELTA)
       const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
       delta_height = DELTA_HEIGHT;
       delta_endstop_adj = adj;
       delta_radius = DELTA_RADIUS;
       delta_diagonal_rod = DELTA_DIAGONAL_ROD;
       delta_tower_angle_trim = dta;
       delta_diagonal_rod_trim = ddr;
     #elif ENABLED(POLARGRAPH)
       draw_area_min.set(X_MIN_POS, Y_MIN_POS);

commit 885e923bffc29caaf002ac4cf35e780d3a923634
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 6 23:49:38 2022 -0600

    ü©π Fix EEPROM write for !LIN_ADVANCE
    
    Fixes #24963
    Followup to #24821

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f76b5afe74..a090b140ad 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1414,21 +1414,21 @@ void MarlinSettings::postprocess() {
     //
     // Linear Advance
     //
     {
       _FIELD_TEST(planner_extruder_advance_K);
 
       #if ENABLED(LIN_ADVANCE)
         EEPROM_WRITE(planner.extruder_advance_K);
       #else
         dummyf = 0;
-        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummyf);
+        for (uint8_t q = DISTINCT_E; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Motor Current PWM
     //
     {
       _FIELD_TEST(motor_current_setting);
 
       #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM

commit a460b01c876ff39901fe55a4b66b2c62737ef46c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 21 22:34:22 2022 +0100

    üöÄ ZV Input Shaping (#24797)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index cb8fe217e9..f76b5afe74 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -570,20 +570,32 @@ typedef struct SettingsDataStruct {
     uint8_t ui_language;                                // M414 S
   #endif
 
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     MPC_t mpc_constants[HOTENDS];                       // M306
   #endif
 
+  //
+  // Input Shaping
+  //
+  #if HAS_SHAPING_X
+    float shaping_x_frequency, // M593 X F
+          shaping_x_zeta;      // M593 X D
+  #endif
+  #if HAS_SHAPING_Y
+    float shaping_y_frequency, // M593 Y F
+          shaping_y_zeta;      // M593 Y D
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1595,20 +1607,34 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
     // Model predictive control
     //
     #if ENABLED(MPCTEMP)
       HOTEND_LOOP()
         EEPROM_WRITE(thermalManager.temp_hotend[e].constants);
     #endif
 
+    //
+    // Input Shaping
+    ///
+    #if ENABLED(INPUT_SHAPING)
+      #if HAS_SHAPING_X
+        EEPROM_WRITE(stepper.get_shaping_frequency(X_AXIS));
+        EEPROM_WRITE(stepper.get_shaping_damping_ratio(X_AXIS));
+      #endif
+      #if HAS_SHAPING_Y
+        EEPROM_WRITE(stepper.get_shaping_frequency(Y_AXIS));
+        EEPROM_WRITE(stepper.get_shaping_damping_ratio(Y_AXIS));
+      #endif
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2566,20 +2592,41 @@ void MarlinSettings::postprocess() {
       //
       // Model predictive control
       //
       #if ENABLED(MPCTEMP)
       {
         HOTEND_LOOP()
           EEPROM_READ(thermalManager.temp_hotend[e].constants);
       }
       #endif
 
+      //
+      // Input Shaping
+      //
+      #if HAS_SHAPING_X
+      {
+        float _data[2];
+        EEPROM_READ(_data);
+        stepper.set_shaping_frequency(X_AXIS, _data[0]);
+        stepper.set_shaping_damping_ratio(X_AXIS, _data[1]);
+      }
+      #endif
+
+      #if HAS_SHAPING_Y
+      {
+        float _data[2];
+        EEPROM_READ(_data);
+        stepper.set_shaping_frequency(Y_AXIS, _data[0]);
+        stepper.set_shaping_damping_ratio(Y_AXIS, _data[1]);
+      }
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
@@ -3336,20 +3383,34 @@ void MarlinSettings::reset() {
       constants.block_heat_capacity = _mpc_block_heat_capacity[e];
       constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
       constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
         constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
       constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
+  //
+  // Input Shaping
+  //
+  #if ENABLED(INPUT_SHAPING)
+    #if HAS_SHAPING_X
+      stepper.set_shaping_frequency(X_AXIS, SHAPING_FREQ_X);
+      stepper.set_shaping_damping_ratio(X_AXIS, SHAPING_ZETA_X);
+    #endif
+    #if HAS_SHAPING_Y
+      stepper.set_shaping_frequency(Y_AXIS, SHAPING_FREQ_Y);
+      stepper.set_shaping_damping_ratio(Y_AXIS, SHAPING_ZETA_Y);
+    #endif
+  #endif
+
   postprocess();
 
   #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
@@ -3583,20 +3644,25 @@ void MarlinSettings::reset() {
       // TMC Sensorless homing thresholds
       //
       TERN_(USE_SENSORLESS, gcode.M914_report(forReplay));
     #endif
 
     //
     // TMC stepping mode
     //
     TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
+    //
+    // Input Shaping
+    //
+    TERN_(INPUT_SHAPING, gcode.M593_report(forReplay));
+
     //
     // Linear Advance
     //
     TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 
     //
     // Motor Current (SPI or PWM)
     //
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       gcode.M907_report(forReplay);

commit e49c3dc0889f1a6b597701ceb69624bdf4365445
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 19 00:45:35 2022 -0500

    ü©π Polargraph followup
    
    Fix issue from #24847

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 95836a5f3a..cb8fe217e9 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -312,21 +312,21 @@ typedef struct SettingsDataStruct {
 
   //
   // BLTOUCH
   //
   bool bltouch_od_5v_mode;
   #ifdef BLTOUCH_HS_MODE
     bool bltouch_high_speed_mode;                       // M401 S
   #endif
 
   //
-  // Kinematic Settings
+  // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
   //
   #if IS_KINEMATIC
     float segments_per_second;                          // M665 S
     #if ENABLED(DELTA)
       float delta_height;                               // M666 H
       abc_float_t delta_endstop_adj;                    // M666 X Y Z
       float delta_radius,                               // M665 R
             delta_diagonal_rod;                         // M665 L
       abc_float_t delta_tower_angle_trim,               // M665 X Y Z
                   delta_diagonal_rod_trim;              // M665 A B C
@@ -985,21 +985,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(bltouch_od_5v_mode);
 
       #ifdef BLTOUCH_HS_MODE
         _FIELD_TEST(bltouch_high_speed_mode);
         const bool bltouch_high_speed_mode = TERN0(BLTOUCH, bltouch.high_speed_mode);
         EEPROM_WRITE(bltouch_high_speed_mode);
       #endif
     }
 
     //
-    // Kinematic Settings
+    // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
     //
     #if IS_KINEMATIC
     {
       EEPROM_WRITE(segments_per_second);
       #if ENABLED(DELTA)
         _FIELD_TEST(delta_height);
         EEPROM_WRITE(delta_height);              // 1 float
         EEPROM_WRITE(delta_endstop_adj);         // 3 floats
         EEPROM_WRITE(delta_radius);              // 1 float
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
@@ -1437,28 +1437,20 @@ void MarlinSettings::postprocess() {
       const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
     #endif
     EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
 
     //
     // Skew correction factors
     //
     _FIELD_TEST(planner_skew_factor);
     EEPROM_WRITE(planner.skew_factor);
 
-    //
-    // POLARGRAPH
-    //
-    #if ENABLED(POLARGRAPH)
-      _FIELD_TEST(polargraph_max_belt_len);
-      EEPROM_WRITE(polargraph_max_belt_len);
-    #endif
-
     //
     // Advanced Pause filament load & unload lengths
     //
     #if HAS_EXTRUDERS
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
         const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
       #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
@@ -1933,21 +1925,21 @@ void MarlinSettings::postprocess() {
           #if ENABLED(BLTOUCH)
             const bool &bltouch_high_speed_mode = bltouch.high_speed_mode;
           #else
             bool bltouch_high_speed_mode;
           #endif
           EEPROM_READ(bltouch_high_speed_mode);
         #endif
       }
 
       //
-      // Kinematic Segments-per-second
+      // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
       //
       #if IS_KINEMATIC
       {
         EEPROM_READ(segments_per_second);
         #if ENABLED(DELTA)
           _FIELD_TEST(delta_height);
           EEPROM_READ(delta_height);              // 1 float
           EEPROM_READ(delta_endstop_adj);         // 3 floats
           EEPROM_READ(delta_radius);              // 1 float
           EEPROM_READ(delta_diagonal_rod);        // 1 float
@@ -2994,21 +2986,21 @@ void MarlinSettings::reset() {
   TERN_(HAS_PTC, ptc.reset());
 
   //
   // BLTouch
   //
   #ifdef BLTOUCH_HS_MODE
     bltouch.high_speed_mode = ENABLED(BLTOUCH_HS_MODE);
   #endif
 
   //
-  // Kinematic settings
+  // Kinematic Settings (Delta, SCARA, TPARA, Polargraph...)
   //
 
   #if IS_KINEMATIC
     segments_per_second = (
       TERN_(DELTA, DELTA_SEGMENTS_PER_SECOND)
       TERN_(IS_SCARA, SCARA_SEGMENTS_PER_SECOND)
       TERN_(POLARGRAPH, POLAR_SEGMENTS_PER_SECOND)
     );
     #if ENABLED(DELTA)
       const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;

commit 5a80fc261736f6e88ec87b5544228383e2937894
Author: Dan Royer <dan@marginallyclever.com>
Date:   Sat Oct 15 22:03:42 2022 -0700

    üêõ Fix and improve Polargraph (#24847)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ec1a03eb05..95836a5f3a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -250,21 +250,21 @@ typedef struct SettingsDataStruct {
   //
   float mbl_z_offset;                                   // bedlevel.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // bedlevel.z_values
                     [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
   //
 
-  xyz_pos_t probe_offset;
+  xyz_pos_t probe_offset;                               // M851 X Y Z
 
   //
   // ABL_PLANAR
   //
   matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
 
   //
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
@@ -323,21 +323,25 @@ typedef struct SettingsDataStruct {
   //
   #if IS_KINEMATIC
     float segments_per_second;                          // M665 S
     #if ENABLED(DELTA)
       float delta_height;                               // M666 H
       abc_float_t delta_endstop_adj;                    // M666 X Y Z
       float delta_radius,                               // M665 R
             delta_diagonal_rod;                         // M665 L
       abc_float_t delta_tower_angle_trim,               // M665 X Y Z
                   delta_diagonal_rod_trim;              // M665 A B C
+    #elif ENABLED(POLARGRAPH)
+      xy_pos_t draw_area_min, draw_area_max;            // M665 L R T B
+      float polargraph_max_belt_len;                    // M665 H
     #endif
+
   #endif
 
   //
   // Extra Endstops offsets
   //
   #if HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 (S2) Z
           z3_endstop_adj,                               // M666 (S3) Z
@@ -461,21 +465,21 @@ typedef struct SettingsDataStruct {
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
   //
-  skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
+  skew_factor_t planner_skew_factor;                    // M852 I J K
 
   //
   // ADVANCED_PAUSE_FEATURE
   //
   #if HAS_EXTRUDERS
     fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
   #endif
 
   //
   // Tool-change settings
@@ -994,20 +998,25 @@ void MarlinSettings::postprocess() {
     {
       EEPROM_WRITE(segments_per_second);
       #if ENABLED(DELTA)
         _FIELD_TEST(delta_height);
         EEPROM_WRITE(delta_height);              // 1 float
         EEPROM_WRITE(delta_endstop_adj);         // 3 floats
         EEPROM_WRITE(delta_radius);              // 1 float
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
         EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
+      #elif ENABLED(POLARGRAPH)
+        _FIELD_TEST(draw_area_min);
+        EEPROM_WRITE(draw_area_min);             // 2 floats
+        EEPROM_WRITE(draw_area_max);             // 2 floats
+        EEPROM_WRITE(polargraph_max_belt_len);   // 1 float
       #endif
     }
     #endif
 
     //
     // Extra Endstops offsets
     //
     #if HAS_EXTRA_ENDSTOPS
     {
       _FIELD_TEST(x2_endstop_adj);
@@ -1428,20 +1437,28 @@ void MarlinSettings::postprocess() {
       const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
     #endif
     EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
 
     //
     // Skew correction factors
     //
     _FIELD_TEST(planner_skew_factor);
     EEPROM_WRITE(planner.skew_factor);
 
+    //
+    // POLARGRAPH
+    //
+    #if ENABLED(POLARGRAPH)
+      _FIELD_TEST(polargraph_max_belt_len);
+      EEPROM_WRITE(polargraph_max_belt_len);
+    #endif
+
     //
     // Advanced Pause filament load & unload lengths
     //
     #if HAS_EXTRUDERS
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
         const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
       #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
@@ -1929,20 +1946,25 @@ void MarlinSettings::postprocess() {
       {
         EEPROM_READ(segments_per_second);
         #if ENABLED(DELTA)
           _FIELD_TEST(delta_height);
           EEPROM_READ(delta_height);              // 1 float
           EEPROM_READ(delta_endstop_adj);         // 3 floats
           EEPROM_READ(delta_radius);              // 1 float
           EEPROM_READ(delta_diagonal_rod);        // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
           EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
+        #elif ENABLED(POLARGRAPH)
+          _FIELD_TEST(draw_area_min);
+          EEPROM_READ(draw_area_min);             // 2 floats
+          EEPROM_READ(draw_area_max);             // 2 floats
+          EEPROM_READ(polargraph_max_belt_len);   // 1 float
         #endif
       }
       #endif
 
       //
       // Extra Endstops offsets
       //
       #if HAS_EXTRA_ENDSTOPS
       {
         _FIELD_TEST(x2_endstop_adj);
@@ -2989,20 +3011,24 @@ void MarlinSettings::reset() {
       TERN_(POLARGRAPH, POLAR_SEGMENTS_PER_SECOND)
     );
     #if ENABLED(DELTA)
       const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
       delta_height = DELTA_HEIGHT;
       delta_endstop_adj = adj;
       delta_radius = DELTA_RADIUS;
       delta_diagonal_rod = DELTA_DIAGONAL_ROD;
       delta_tower_angle_trim = dta;
       delta_diagonal_rod_trim = ddr;
+    #elif ENABLED(POLARGRAPH)
+      draw_area_min.set(X_MIN_POS, Y_MIN_POS);
+      draw_area_max.set(X_MAX_POS, Y_MAX_POS);
+      polargraph_max_belt_len = POLARGRAPH_MAX_BELT_LEN;
     #endif
   #endif
 
   //
   // Endstop Adjustments
   //
 
   #if ENABLED(X_DUAL_ENDSTOPS)
     #ifndef X2_ENDSTOP_ADJUSTMENT
       #define X2_ENDSTOP_ADJUSTMENT 0
@@ -3485,23 +3511,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // Z Auto-Align
     //
     TERN_(Z_STEPPER_AUTO_ALIGN, gcode.M422_report(forReplay));
 
     //
     // LCD Preheat Settings
     //
-    #if HAS_PREHEAT
-      gcode.M145_report(forReplay);
-    #endif
+    TERN_(HAS_PREHEAT, gcode.M145_report(forReplay));
 
     //
     // PID
     //
     TERN_(PIDTEMP,        gcode.M301_report(forReplay));
     TERN_(PIDTEMPBED,     gcode.M304_report(forReplay));
     TERN_(PIDTEMPCHAMBER, gcode.M309_report(forReplay));
 
     #if HAS_USER_THERMISTORS
       LOOP_L_N(i, USER_THERMISTORS)

commit efde96131d9e9288dc2ea28b548f691a184fb33e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Oct 10 20:49:37 2022 +0200

    ‚ú® ADVANCE_K per-extruder (#24821)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4ccaa805c5..ec1a03eb05 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -111,22 +111,22 @@
   #include "../feature/backlash.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
   #ifndef FIL_RUNOUT_ENABLED_DEFAULT
     #define FIL_RUNOUT_ENABLED_DEFAULT true
   #endif
 #endif
 
-#if ENABLED(EXTRA_LIN_ADVANCE_K)
-  extern float other_extruder_advance_K[EXTRUDERS];
+#if ENABLED(ADVANCE_K_EXTRA)
+  extern float other_extruder_advance_K[DISTINCT_E];
 #endif
 
 #if HAS_MULTI_EXTRUDER
   #include "tool_change.h"
   void M217_report(const bool eeprom);
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
@@ -435,21 +435,21 @@ typedef struct SettingsDataStruct {
   // HAS_TRINAMIC_CONFIG
   //
   per_stepper_uint16_t tmc_stepper_current;             // M906 X Y Z...
   per_stepper_uint32_t tmc_hybrid_threshold;            // M913 X Y Z...
   mot_stepper_int16_t tmc_sgt;                          // M914 X Y Z...
   per_stepper_bool_t tmc_stealth_enabled;               // M569 X Y Z...
 
   //
   // LIN_ADVANCE
   //
-  float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
+  float planner_extruder_advance_K[DISTINCT_E]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
     #if HAS_MOTOR_CURRENT_PWM
       #define MOTOR_CURRENT_COUNT 3
     #elif HAS_MOTOR_CURRENT_DAC
       #define MOTOR_CURRENT_COUNT LOGICAL_AXES
     #elif HAS_MOTOR_CURRENT_I2C
@@ -2327,21 +2327,21 @@ void MarlinSettings::postprocess() {
             TERN_(E6_HAS_STEALTHCHOP, SET_STEPPING_MODE(E6));
             TERN_(E7_HAS_STEALTHCHOP, SET_STEPPING_MODE(E7));
           }
         #endif
       }
 
       //
       // Linear Advance
       //
       {
-        float extruder_advance_K[_MAX(EXTRUDERS, 1)];
+        float extruder_advance_K[DISTINCT_E];
         _FIELD_TEST(planner_extruder_advance_K);
         EEPROM_READ(extruder_advance_K);
         #if ENABLED(LIN_ADVANCE)
           if (!validating)
             COPY(planner.extruder_advance_K, extruder_advance_K);
         #endif
       }
 
       //
       // Motor Current PWM
@@ -3199,26 +3199,31 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
   endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
   reset_stepper_drivers();
 
   //
   // Linear Advance
   //
-
   #if ENABLED(LIN_ADVANCE)
-    EXTRUDER_LOOP() {
-      planner.extruder_advance_K[e] = LIN_ADVANCE_K;
-      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[e] = LIN_ADVANCE_K);
-    }
+    #if ENABLED(DISTINCT_E_FACTORS)
+      constexpr float linAdvanceK[] = ADVANCE_K;
+      EXTRUDER_LOOP() {
+        const float a = linAdvanceK[_MAX(e, COUNT(linAdvanceK) - 1)];
+        planner.extruder_advance_K[e] = a;
+        TERN_(ADVANCE_K_EXTRA, other_extruder_advance_K[e] = a);
+      }
+    #else
+      planner.extruder_advance_K[0] = ADVANCE_K;
+    #endif
   #endif
 
   //
   // Motor Current PWM
   //
 
   #if HAS_MOTOR_CURRENT_PWM
     constexpr uint32_t tmp_motor_current_setting[MOTOR_CURRENT_COUNT] = PWM_MOTOR_CURRENT;
     LOOP_L_N(q, MOTOR_CURRENT_COUNT)
       stepper.set_digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));

commit fcf9f22390ca47f68b85d02c93e9ceeabd599f79
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sat Oct 1 23:04:50 2022 +0300

    ü©π Fix Color UI touchscreen sleep (#24826)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2b6a98b045..4ccaa805c5 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -635,21 +635,21 @@ void MarlinSettings::postprocess() {
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 
   #if LCD_BACKLIGHT_TIMEOUT_MINS
     ui.refresh_backlight_timeout();
-  #elif HAS_DISPLAY_SLEEP
+  #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
     ui.refresh_screen_timeout();
   #endif
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
@@ -3160,21 +3160,21 @@ void MarlinSettings::reset() {
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // LCD Backlight / Sleep Timeout
   //
   #if LCD_BACKLIGHT_TIMEOUT_MINS
     ui.backlight_timeout_minutes = LCD_BACKLIGHT_TIMEOUT_MINS;
   #elif HAS_DISPLAY_SLEEP
-    ui.sleep_timeout_minutes = DISPLAY_SLEEP_MINUTES;
+    ui.sleep_timeout_minutes = TERN(TOUCH_SCREEN, TOUCH_IDLE_SLEEP_MINS, DISPLAY_SLEEP_MINUTES);
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //

commit 9e5c143b87e4fc97a875e56aa9ec7d411c36d923
Author: studiodyne <diabolomix@hotmail.fr>
Date:   Sun Aug 28 00:43:32 2022 +0200

    ‚ú® M217 G wipe retract length

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 179fea057d..2b6a98b045 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V86"
+#define EEPROM_VERSION "V87"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -2869,20 +2869,21 @@ void MarlinSettings::reset() {
   //
 
   #if HAS_MULTI_EXTRUDER
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       toolchange_settings.swap_length     = TOOLCHANGE_FS_LENGTH;
       toolchange_settings.extra_resume    = TOOLCHANGE_FS_EXTRA_RESUME_LENGTH;
       toolchange_settings.retract_speed   = TOOLCHANGE_FS_RETRACT_SPEED;
       toolchange_settings.unretract_speed = TOOLCHANGE_FS_UNRETRACT_SPEED;
       toolchange_settings.extra_prime     = TOOLCHANGE_FS_EXTRA_PRIME;
       toolchange_settings.prime_speed     = TOOLCHANGE_FS_PRIME_SPEED;
+      toolchange_settings.wipe_retract    = TOOLCHANGE_FS_WIPE_RETRACT;
       toolchange_settings.fan_speed       = TOOLCHANGE_FS_FAN_SPEED;
       toolchange_settings.fan_time        = TOOLCHANGE_FS_FAN_TIME;
     #endif
 
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       enable_first_prime = false;
     #endif
 
     #if ENABLED(TOOLCHANGE_PARK)
       constexpr xyz_pos_t tpxy = TOOLCHANGE_PARK_XY;

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index aa6f48d763..179fea057d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -357,32 +357,32 @@ typedef struct SettingsDataStruct {
   //
   // Material Presets
   //
   #if HAS_PREHEAT
     preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
   #endif
 
   //
   // PIDTEMP
   //
-  PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
+  raw_pidcf_t hotendPID[HOTENDS];                       // M301 En PIDCF / M303 En U
   int16_t lpq_len;                                      // M301 L
 
   //
   // PIDTEMPBED
   //
-  PID_t bedPID;                                         // M304 PID / M303 E-1 U
+  raw_pid_t bedPID;                                     // M304 PID / M303 E-1 U
 
   //
   // PIDTEMPCHAMBER
   //
-  PID_t chamberPID;                                     // M309 PID / M303 E-2 U
+  raw_pid_t chamberPID;                                 // M309 PID / M303 E-2 U
 
   //
   // User-defined Thermistors
   //
   #if HAS_USER_THERMISTORS
     user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
   #endif
 
   //
   // Power monitor
@@ -1045,89 +1045,70 @@ void MarlinSettings::postprocess() {
     #if HAS_PREHEAT
       _FIELD_TEST(ui_material_preset);
       EEPROM_WRITE(ui.material_preset);
     #endif
 
     //
     // PIDTEMP
     //
     {
       _FIELD_TEST(hotendPID);
+      #if DISABLED(PIDTEMP)
+        raw_pidcf_t pidcf = { NAN, NAN, NAN, NAN, NAN };
+      #endif
       HOTEND_LOOP() {
-        PIDCF_t pidcf = {
-          #if DISABLED(PIDTEMP)
-            NAN, NAN, NAN,
-            NAN, NAN
-          #else
-                         PID_PARAM(Kp, e),
-            unscalePID_i(PID_PARAM(Ki, e)),
-            unscalePID_d(PID_PARAM(Kd, e)),
-                         PID_PARAM(Kc, e),
-                         PID_PARAM(Kf, e)
-          #endif
-        };
+        #if ENABLED(PIDTEMP)
+          const hotend_pid_t &pid = thermalManager.temp_hotend[e].pid;
+          raw_pidcf_t pidcf = { pid.p(), pid.i(), pid.d(), pid.c(), pid.f() };
+        #endif
         EEPROM_WRITE(pidcf);
       }
 
       _FIELD_TEST(lpq_len);
-      #if DISABLED(PID_EXTRUSION_SCALING)
-        const int16_t lpq_len = 20;
-      #endif
-      EEPROM_WRITE(TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, lpq_len));
+      const int16_t lpq_len = TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, 20);
+      EEPROM_WRITE(lpq_len);
     }
 
     //
     // PIDTEMPBED
     //
     {
       _FIELD_TEST(bedPID);
-
-      const PID_t bed_pid = {
-        #if DISABLED(PIDTEMPBED)
-          NAN, NAN, NAN
-        #else
-          // Store the unscaled PID values
-          thermalManager.temp_bed.pid.Kp,
-          unscalePID_i(thermalManager.temp_bed.pid.Ki),
-          unscalePID_d(thermalManager.temp_bed.pid.Kd)
-        #endif
-      };
+      #if ENABLED(PIDTEMPBED)
+        const PID_t &pid = thermalManager.temp_bed.pid;
+        const raw_pid_t bed_pid = { pid.p(), pid.i(), pid.d() };
+      #else
+        const raw_pid_t bed_pid = { NAN, NAN, NAN };
+      #endif
       EEPROM_WRITE(bed_pid);
     }
 
     //
     // PIDTEMPCHAMBER
     //
     {
       _FIELD_TEST(chamberPID);
-
-      const PID_t chamber_pid = {
-        #if DISABLED(PIDTEMPCHAMBER)
-          NAN, NAN, NAN
-        #else
-          // Store the unscaled PID values
-          thermalManager.temp_chamber.pid.Kp,
-          unscalePID_i(thermalManager.temp_chamber.pid.Ki),
-          unscalePID_d(thermalManager.temp_chamber.pid.Kd)
-        #endif
-      };
+      #if ENABLED(PIDTEMPCHAMBER)
+        const PID_t &pid = thermalManager.temp_chamber.pid;
+        const raw_pid_t chamber_pid = { pid.p(), pid.i(), pid.d() };
+      #else
+        const raw_pid_t chamber_pid = { NAN, NAN, NAN };
+      #endif
       EEPROM_WRITE(chamber_pid);
     }
 
     //
     // User-defined Thermistors
     //
     #if HAS_USER_THERMISTORS
-    {
       _FIELD_TEST(user_thermistor);
       EEPROM_WRITE(thermalManager.user_thermistor);
-    }
     #endif
 
     //
     // Power monitor
     //
     {
       #if HAS_POWER_MONITOR
         const uint8_t &power_monitor_flags = power_monitor.flags;
       #else
         constexpr uint8_t power_monitor_flags = 0x00;
@@ -1996,31 +1977,25 @@ void MarlinSettings::postprocess() {
       #if HAS_PREHEAT
         _FIELD_TEST(ui_material_preset);
         EEPROM_READ(ui.material_preset);
       #endif
 
       //
       // Hotend PID
       //
       {
         HOTEND_LOOP() {
-          PIDCF_t pidcf;
+          raw_pidcf_t pidcf;
           EEPROM_READ(pidcf);
           #if ENABLED(PIDTEMP)
-            if (!validating && !isnan(pidcf.Kp)) {
-              // Scale PID values since EEPROM values are unscaled
-              PID_PARAM(Kp, e) = pidcf.Kp;
-              PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
-              PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
-              TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
-              TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
-            }
+            if (!validating && !isnan(pidcf.p))
+              thermalManager.temp_hotend[e].pid.set(pidcf);
           #endif
         }
       }
 
       //
       // PID Extrusion Scaling
       //
       {
         _FIELD_TEST(lpq_len);
         #if ENABLED(PID_EXTRUSION_SCALING)
@@ -2028,45 +2003,37 @@ void MarlinSettings::postprocess() {
         #else
           int16_t lpq_len;
         #endif
         EEPROM_READ(lpq_len);
       }
 
       //
       // Heated Bed PID
       //
       {
-        PID_t pid;
+        raw_pid_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
-          if (!validating && !isnan(pid.Kp)) {
-            // Scale PID values since EEPROM values are unscaled
-            thermalManager.temp_bed.pid.Kp = pid.Kp;
-            thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
-            thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
-          }
+          if (!validating && !isnan(pid.p))
+            thermalManager.temp_bed.pid.set(pid);
         #endif
       }
 
       //
       // Heated Chamber PID
       //
       {
-        PID_t pid;
+        raw_pid_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPCHAMBER)
-          if (!validating && !isnan(pid.Kp)) {
-            // Scale PID values since EEPROM values are unscaled
-            thermalManager.temp_chamber.pid.Kp = pid.Kp;
-            thermalManager.temp_chamber.pid.Ki = scalePID_i(pid.Ki);
-            thermalManager.temp_chamber.pid.Kd = scalePID_d(pid.Kd);
-          }
+          if (!validating && !isnan(pid.p))
+            thermalManager.temp_chamber.pid.set(pid);
         #endif
       }
 
       //
       // User-defined Thermistors
       //
       #if HAS_USER_THERMISTORS
       {
         user_thermistor_t user_thermistor[USER_THERMISTORS];
         _FIELD_TEST(user_thermistor);
@@ -3135,51 +3102,49 @@ void MarlinSettings::reset() {
             ARRAY_BY_HOTENDS1(DEFAULT_Kf)
           #endif
         ;
         static_assert(WITHIN(COUNT(defKf), 1, HOTENDS), "DEFAULT_Kf_LIST must have between 1 and HOTENDS items.");
       #endif
       #define PID_DEFAULT(N,E) def##N[E]
     #else
       #define PID_DEFAULT(N,E) DEFAULT_##N
     #endif
     HOTEND_LOOP() {
-      PID_PARAM(Kp, e) =      float(PID_DEFAULT(Kp, ALIM(e, defKp)));
-      PID_PARAM(Ki, e) = scalePID_i(PID_DEFAULT(Ki, ALIM(e, defKi)));
-      PID_PARAM(Kd, e) = scalePID_d(PID_DEFAULT(Kd, ALIM(e, defKd)));
-      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = float(PID_DEFAULT(Kc, ALIM(e, defKc))));
-      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = float(PID_DEFAULT(Kf, ALIM(e, defKf))));
+      thermalManager.temp_hotend[e].pid.set(
+        PID_DEFAULT(Kp, ALIM(e, defKp)),
+        PID_DEFAULT(Ki, ALIM(e, defKi)),
+        PID_DEFAULT(Kd, ALIM(e, defKd))
+        OPTARG(PID_EXTRUSION_SCALING, PID_DEFAULT(Kc, ALIM(e, defKc)))
+        OPTARG(PID_FAN_SCALING, PID_DEFAULT(Kf, ALIM(e, defKf)))
+      );
     }
   #endif
 
   //
   // PID Extrusion Scaling
   //
   TERN_(PID_EXTRUSION_SCALING, thermalManager.lpq_len = 20); // Default last-position-queue size
 
   //
   // Heated Bed PID
   //
 
   #if ENABLED(PIDTEMPBED)
-    thermalManager.temp_bed.pid.Kp = DEFAULT_bedKp;
-    thermalManager.temp_bed.pid.Ki = scalePID_i(DEFAULT_bedKi);
-    thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
+    thermalManager.temp_bed.pid.set(DEFAULT_bedKp, DEFAULT_bedKi, DEFAULT_bedKd);
   #endif
 
   //
   // Heated Chamber PID
   //
 
   #if ENABLED(PIDTEMPCHAMBER)
-    thermalManager.temp_chamber.pid.Kp = DEFAULT_chamberKp;
-    thermalManager.temp_chamber.pid.Ki = scalePID_i(DEFAULT_chamberKi);
-    thermalManager.temp_chamber.pid.Kd = scalePID_d(DEFAULT_chamberKd);
+    thermalManager.temp_chamber.pid.set(DEFAULT_chamberKp, DEFAULT_chamberKi, DEFAULT_chamberKd);
   #endif
 
   //
   // User-Defined Thermistors
   //
   TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
   //
   // Power Monitor
   //
@@ -3335,28 +3300,29 @@ void MarlinSettings::reset() {
     static_assert(COUNT(_mpc_heater_power) == HOTENDS, "MPC_HEATER_POWER must have HOTENDS items.");
     static_assert(COUNT(_mpc_block_heat_capacity) == HOTENDS, "MPC_BLOCK_HEAT_CAPACITY must have HOTENDS items.");
     static_assert(COUNT(_mpc_sensor_responsiveness) == HOTENDS, "MPC_SENSOR_RESPONSIVENESS must have HOTENDS items.");
     static_assert(COUNT(_mpc_ambient_xfer_coeff) == HOTENDS, "MPC_AMBIENT_XFER_COEFF must have HOTENDS items.");
     #if ENABLED(MPC_INCLUDE_FAN)
       static_assert(COUNT(_mpc_ambient_xfer_coeff_fan255) == HOTENDS, "MPC_AMBIENT_XFER_COEFF_FAN255 must have HOTENDS items.");
     #endif
     static_assert(COUNT(_filament_heat_capacity_permm) == HOTENDS, "FILAMENT_HEAT_CAPACITY_PERMM must have HOTENDS items.");
 
     HOTEND_LOOP() {
-      thermalManager.temp_hotend[e].constants.heater_power = _mpc_heater_power[e];
-      thermalManager.temp_hotend[e].constants.block_heat_capacity = _mpc_block_heat_capacity[e];
-      thermalManager.temp_hotend[e].constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
-      thermalManager.temp_hotend[e].constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
+      MPC_t &constants = thermalManager.temp_hotend[e].constants;
+      constants.heater_power = _mpc_heater_power[e];
+      constants.block_heat_capacity = _mpc_block_heat_capacity[e];
+      constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
+      constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
-        thermalManager.temp_hotend[e].constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
+        constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
-      thermalManager.temp_hotend[e].constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
+      constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   postprocess();
 
   #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
   #endif

commit 2f91154cbdcec3b81da9913bdd16556e8c775d06
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Thu Aug 25 20:16:55 2022 +0300

    ‚ôªÔ∏è Display sleep minutes, encoder disable option (#24618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b40690e22c..aa6f48d763 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -395,22 +395,22 @@ typedef struct SettingsDataStruct {
   uint8_t lcd_contrast;                                 // M250 C
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
   //
   // Display Sleep
   //
-  #if LCD_BACKLIGHT_TIMEOUT
-    uint16_t lcd_backlight_timeout;                     // M255 S
+  #if LCD_BACKLIGHT_TIMEOUT_MINS
+    uint8_t backlight_timeout_minutes;                  // M255 S
   #elif HAS_DISPLAY_SLEEP
     uint8_t sleep_timeout_minutes;                      // M255 S
   #endif
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
@@ -633,21 +633,21 @@ void MarlinSettings::postprocess() {
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 
-  #if LCD_BACKLIGHT_TIMEOUT
+  #if LCD_BACKLIGHT_TIMEOUT_MINS
     ui.refresh_backlight_timeout();
   #elif HAS_DISPLAY_SLEEP
     ui.refresh_screen_timeout();
   #endif
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
@@ -1150,22 +1150,22 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
     }
 
     //
     // LCD Backlight / Sleep Timeout
     //
-    #if LCD_BACKLIGHT_TIMEOUT
-      EEPROM_WRITE(ui.lcd_backlight_timeout);
+    #if LCD_BACKLIGHT_TIMEOUT_MINS
+      EEPROM_WRITE(ui.backlight_timeout_minutes);
     #elif HAS_DISPLAY_SLEEP
       EEPROM_WRITE(ui.sleep_timeout_minutes);
     #endif
 
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
@@ -2101,22 +2101,22 @@ void MarlinSettings::postprocess() {
       {
         uint8_t lcd_brightness;
         _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
       //
       // LCD Backlight / Sleep Timeout
       //
-      #if LCD_BACKLIGHT_TIMEOUT
-        EEPROM_READ(ui.lcd_backlight_timeout);
+      #if LCD_BACKLIGHT_TIMEOUT_MINS
+        EEPROM_READ(ui.backlight_timeout_minutes);
       #elif HAS_DISPLAY_SLEEP
         EEPROM_READ(ui.sleep_timeout_minutes);
       #endif
 
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
@@ -3191,22 +3191,22 @@ void MarlinSettings::reset() {
   TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // LCD Backlight / Sleep Timeout
   //
-  #if LCD_BACKLIGHT_TIMEOUT
-    ui.lcd_backlight_timeout = LCD_BACKLIGHT_TIMEOUT;
+  #if LCD_BACKLIGHT_TIMEOUT_MINS
+    ui.backlight_timeout_minutes = LCD_BACKLIGHT_TIMEOUT_MINS;
   #elif HAS_DISPLAY_SLEEP
     ui.sleep_timeout_minutes = DISPLAY_SLEEP_MINUTES;
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //

commit 007af4776880fda761e925bce383ac41a7769833
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 22 21:59:00 2022 -0500

    ‚ú® Reinstate JyersUI

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a37dfc0257..b40690e22c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -70,20 +70,22 @@
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
   #include "../lcd/e3v2/proui/bedlevel_tools.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
@@ -494,20 +496,22 @@ typedef struct SettingsDataStruct {
   //
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
   #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
+  #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
@@ -1512,20 +1516,29 @@ void MarlinSettings::postprocess() {
     //
     #if ENABLED(DWIN_LCD_PROUI)
     {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
+    #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    {
+      _FIELD_TEST(dwin_settings);
+      char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+      CrealityDWIN.Save_Settings(dwin_settings);
+      EEPROM_WRITE(dwin_settings);
+    }
+    #endif
+
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
     // Password feature
     //
@@ -2476,20 +2489,27 @@ void MarlinSettings::postprocess() {
       //
       // Creality DWIN User Data
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
+      #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+      {
+        const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+        _FIELD_TEST(dwin_settings);
+        EEPROM_READ(dwin_settings);
+        if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
+      }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 
@@ -2913,20 +2933,22 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
+  TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
+
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());
 

commit 8fb54d4621c5f571d613fca2943393d4a95cb8e4
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jul 14 00:00:33 2022 -0500

    üö∏ Fix and update ProUI (#24477)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d21dc92c67..a37dfc0257 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -69,20 +69,21 @@
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
+  #include "../lcd/e3v2/proui/bedlevel_tools.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
@@ -2749,33 +2750,43 @@ void MarlinSettings::postprocess() {
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
           uint8_t * const dest = (uint8_t*)&z_mesh_store;
         #else
           uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&bedlevel.z_values;
         #endif
 
         persistentStore.access_start();
-        const uint16_t status = persistentStore.read_data(pos, dest, MESH_STORE_SIZE, &crc);
+        uint16_t status = persistentStore.read_data(pos, dest, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           if (into) {
             float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
             bedlevel.set_mesh_from_store(z_mesh_store, z_values);
             memcpy(into, z_values, sizeof(z_values));
           }
           else
             bedlevel.set_mesh_from_store(z_mesh_store, bedlevel.z_values);
         #endif
 
+        #if ENABLED(DWIN_LCD_PROUI)
+          status = !BedLevelTools.meshvalidate();
+          if (status) {
+            bedlevel.invalidate();
+            LCD_MESSAGE(MSG_UBL_MESH_INVALID);
+          }
+          else
+            ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), bedlevel.storage_slot);
+        #endif
+
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        DEBUG_ECHOLNPGM("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();
 
       #else
 
         // Other mesh types
 
       #endif

commit f73fad1b2fa6e70b3d632969ecf2773bee826643
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 6 19:34:45 2022 -0500

    üî• Remove JyersUI (#24459)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3d6e14b5f7..d21dc92c67 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -69,22 +69,20 @@
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-  #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
@@ -495,22 +493,20 @@ typedef struct SettingsDataStruct {
   //
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
   #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
-  #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-    uint8_t dwin_settings[eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
@@ -1515,29 +1511,20 @@ void MarlinSettings::postprocess() {
     //
     #if ENABLED(DWIN_LCD_PROUI)
     {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
-    #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-    {
-      _FIELD_TEST(dwin_settings);
-      char dwin_settings[eeprom_data_size] = { 0 };
-      CrealityDWIN.Save_Settings(dwin_settings);
-      EEPROM_WRITE(dwin_settings);
-    }
-    #endif
-
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
     // Password feature
     //
@@ -2488,27 +2475,20 @@ void MarlinSettings::postprocess() {
       //
       // Creality DWIN User Data
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
-      #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-      {
-        const char dwin_settings[eeprom_data_size] = { 0 };
-        _FIELD_TEST(dwin_settings);
-        EEPROM_READ(dwin_settings);
-        if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
-      }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 
@@ -2922,22 +2902,20 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
-  TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
-
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());
 

commit 509dfe92d0c2227ddece025fb97875582ca47aed
Author: Meilleur Gars <98503100+LCh-77@users.noreply.github.com>
Date:   Wed Jul 6 13:46:11 2022 -0700

    üö∏ JyersUI updates (#24451)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7ee3a87fce..3d6e14b5f7 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -496,21 +496,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
   #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
   #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-    uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
+    uint8_t dwin_settings[eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
@@ -1518,21 +1518,21 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
-      char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+      char dwin_settings[eeprom_data_size] = { 0 };
       CrealityDWIN.Save_Settings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
@@ -2490,21 +2490,21 @@ void MarlinSettings::postprocess() {
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
-        const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+        const char dwin_settings[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
         if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
       }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS

commit 93ffd57383723c48a092e97364b6659c54b5c419
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:30:05 2022 -0500

    ‚ôªÔ∏è  reset_acceleration_rates => refresh_‚Ä¶

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 149b1b6dc1..7ee3a87fce 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -585,21 +585,21 @@ uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
  */
 
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float new_z_fade_height;
 #endif
 
 void MarlinSettings::postprocess() {
   xyze_pos_t oldpos = current_position;
 
   // steps per s2 needs to be updated to agree with units per s2
-  planner.reset_acceleration_rates();
+  planner.refresh_acceleration_rates();
 
   // Make sure delta kinematics are updated before refreshing the
   // planner position so the stepper counts will be set correctly.
   TERN_(DELTA, recalc_delta_settings());
 
   TERN_(PIDTEMP, thermalManager.updatePID());
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
   #elif EXTRUDERS

commit 6ecf52f196d08d399c24b1516fc0b33b227ed66c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat May 28 23:40:08 2022 +0100

    üö© MPC update (#24253)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ac9970bf5a..149b1b6dc1 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3312,37 +3312,40 @@ void MarlinSettings::reset() {
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
     constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
     constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
     constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
     #if ENABLED(MPC_INCLUDE_FAN)
       constexpr float _mpc_ambient_xfer_coeff_fan255[] = MPC_AMBIENT_XFER_COEFF_FAN255;
     #endif
+    constexpr float _filament_heat_capacity_permm[] = FILAMENT_HEAT_CAPACITY_PERMM;
 
     static_assert(COUNT(_mpc_heater_power) == HOTENDS, "MPC_HEATER_POWER must have HOTENDS items.");
     static_assert(COUNT(_mpc_block_heat_capacity) == HOTENDS, "MPC_BLOCK_HEAT_CAPACITY must have HOTENDS items.");
     static_assert(COUNT(_mpc_sensor_responsiveness) == HOTENDS, "MPC_SENSOR_RESPONSIVENESS must have HOTENDS items.");
     static_assert(COUNT(_mpc_ambient_xfer_coeff) == HOTENDS, "MPC_AMBIENT_XFER_COEFF must have HOTENDS items.");
     #if ENABLED(MPC_INCLUDE_FAN)
       static_assert(COUNT(_mpc_ambient_xfer_coeff_fan255) == HOTENDS, "MPC_AMBIENT_XFER_COEFF_FAN255 must have HOTENDS items.");
     #endif
+    static_assert(COUNT(_filament_heat_capacity_permm) == HOTENDS, "FILAMENT_HEAT_CAPACITY_PERMM must have HOTENDS items.");
 
     HOTEND_LOOP() {
       thermalManager.temp_hotend[e].constants.heater_power = _mpc_heater_power[e];
       thermalManager.temp_hotend[e].constants.block_heat_capacity = _mpc_block_heat_capacity[e];
       thermalManager.temp_hotend[e].constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
       thermalManager.temp_hotend[e].constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
         thermalManager.temp_hotend[e].constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
+      thermalManager.temp_hotend[e].constants.filament_heat_capacity_permm = _filament_heat_capacity_permm[e];
     }
   #endif
 
   postprocess();
 
   #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
   #endif

commit c5126de559719ebdaf4475b0db4ab21c26b90a1a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 16:08:29 2022 -0500

    üßë‚Äçüíª MAP macro for axis lists, etc. (#24191)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 99994b9f8f..ac9970bf5a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -173,23 +173,23 @@
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
 
 #define _EN_ITEM(N) , E##N
 #define _EN1_ITEM(N) , E##N:1
 
-typedef struct { uint16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint16_t;
-typedef struct { uint32_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint32_t;
-typedef struct {  int16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
+typedef struct { uint16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint16_t;
+typedef struct { uint32_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint32_t;
+typedef struct {  int16_t MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
 typedef struct {     bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1), X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2d74751a82..99994b9f8f 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -240,23 +240,23 @@ typedef struct SettingsDataStruct {
   float runout_distance_mm;                             // M412 D
 
   //
   // ENABLE_LEVELING_FADE_HEIGHT
   //
   float planner_z_fade_height;                          // M420 Zn  planner.z_fade_height
 
   //
   // MESH_BED_LEVELING
   //
-  float mbl_z_offset;                                   // mbl.z_offset
+  float mbl_z_offset;                                   // bedlevel.z_offset
   uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
-  float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // mbl.z_values
+  float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // bedlevel.z_values
                     [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
 
   //
   // HAS_BED_PROBE
   //
 
   xyz_pos_t probe_offset;
 
   //
   // ABL_PLANAR
@@ -280,21 +280,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
     float xatc_spacing;                                 // M423 X Z
     float xatc_start;
     xatc_array_t xatc_z_offset;
   #endif
 
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
-  int8_t ubl_storage_slot;                              // ubl.storage_slot
+  int8_t ubl_storage_slot;                              // bedlevel.storage_slot
 
   //
   // SERVO_ANGLES
   //
   uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
 
   //
   // Temperature first layer compensation values
   //
   #if HAS_PTC
@@ -608,21 +608,21 @@ void MarlinSettings::postprocess() {
   #endif
 
   // Software endstops depend on home_offset
   LOOP_NUM_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
-  TERN_(AUTO_BED_LEVELING_BILINEAR, bbl.refresh_bed_level());
+  TERN_(AUTO_BED_LEVELING_BILINEAR, bedlevel.refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.update_brightness());
 
   TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
@@ -837,36 +837,36 @@ void MarlinSettings::postprocess() {
       const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, (DEFAULT_LEVELING_FADE_HEIGHT));
       EEPROM_WRITE(zfh);
     }
 
     //
     // Mesh Bed Leveling
     //
     {
       #if ENABLED(MESH_BED_LEVELING)
         static_assert(
-          sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
+          sizeof(bedlevel.z_values) == (GRID_MAX_POINTS) * sizeof(bedlevel.z_values[0][0]),
           "MBL Z array is the wrong size."
         );
       #else
         dummyf = 0;
       #endif
 
       const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
                     mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
 
-      EEPROM_WRITE(TERN(MESH_BED_LEVELING, mbl.z_offset, dummyf));
+      EEPROM_WRITE(TERN(MESH_BED_LEVELING, bedlevel.z_offset, dummyf));
       EEPROM_WRITE(mesh_num_x);
       EEPROM_WRITE(mesh_num_y);
 
       #if ENABLED(MESH_BED_LEVELING)
-        EEPROM_WRITE(mbl.z_values);
+        EEPROM_WRITE(bedlevel.z_values);
       #else
         for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Probe XYZ Offsets
     //
     {
       _FIELD_TEST(probe_offset);
@@ -889,40 +889,40 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
-          sizeof(Z_VALUES_ARR) == (GRID_MAX_POINTS) * sizeof(Z_VALUES_ARR[0][0]),
+          sizeof(bedlevel.z_values) == (GRID_MAX_POINTS) * sizeof(bedlevel.z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        EEPROM_WRITE(bbl.get_grid_spacing());
-        EEPROM_WRITE(bbl.get_grid_start());
+        EEPROM_WRITE(bedlevel.grid_spacing);
+        EEPROM_WRITE(bedlevel.grid_start);
       #else
-        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
+        const xy_pos_t bilinear_grid_spacing{0}, bilinear_start{0};
         EEPROM_WRITE(bilinear_grid_spacing);
         EEPROM_WRITE(bilinear_start);
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        EEPROM_WRITE(Z_VALUES_ARR);              // 9-256 floats
+        EEPROM_WRITE(bedlevel.z_values);              // 9-256 floats
       #else
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // X Axis Twist Compensation
     //
     #if ENABLED(X_AXIS_TWIST_COMPENSATION)
@@ -931,21 +931,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(xatc.start);
       EEPROM_WRITE(xatc.z_offset);
     #endif
 
     //
     // Unified Bed Leveling
     //
     {
       _FIELD_TEST(planner_leveling_active);
       const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
-      const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
+      const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, bedlevel.storage_slot, -1);
       EEPROM_WRITE(ubl_active);
       EEPROM_WRITE(storage_slot);
     }
 
     //
     // Servo Angles
     //
     {
       _FIELD_TEST(servo_angles);
       #if !HAS_SERVO_ANGLES
@@ -1631,22 +1631,22 @@ void MarlinSettings::postprocess() {
       DEBUG_ECHO_MSG("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
     EEPROM_FINISH();
 
     //
     // UBL Mesh
     //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
-      if (ubl.storage_slot >= 0)
-        store_mesh(ubl.storage_slot);
+      if (bedlevel.storage_slot >= 0)
+        store_mesh(bedlevel.storage_slot);
     #endif
 
     if (!eeprom_error) {
       LCD_MESSAGE(MSG_SETTINGS_STORED);
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_SETTINGS_STORED)));
     }
 
     TERN_(EXTENSIBLE_UI, ExtUI::onSettingsStored(!eeprom_error));
 
     return !eeprom_error;
@@ -1789,34 +1789,34 @@ void MarlinSettings::postprocess() {
       //
       // Mesh (Manual) Bed Leveling
       //
       {
         uint8_t mesh_num_x, mesh_num_y;
         EEPROM_READ(dummyf);
         EEPROM_READ_ALWAYS(mesh_num_x);
         EEPROM_READ_ALWAYS(mesh_num_y);
 
         #if ENABLED(MESH_BED_LEVELING)
-          if (!validating) mbl.z_offset = dummyf;
+          if (!validating) bedlevel.z_offset = dummyf;
           if (mesh_num_x == (GRID_MAX_POINTS_X) && mesh_num_y == (GRID_MAX_POINTS_Y)) {
             // EEPROM data fits the current mesh
-            EEPROM_READ(mbl.z_values);
+            EEPROM_READ(bedlevel.z_values);
           }
           else {
             // EEPROM data is stale
-            if (!validating) mbl.reset();
+            if (!validating) bedlevel.reset();
             for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
           }
         #else
           // MBL is disabled - skip the stored data
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
-        #endif // MESH_BED_LEVELING
+        #endif
       }
 
       //
       // Probe Z Offset
       //
       {
         _FIELD_TEST(probe_offset);
         #if HAS_BED_PROBE
           const xyz_pos_t &zpo = probe.offset;
         #else
@@ -1842,22 +1842,22 @@ void MarlinSettings::postprocess() {
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
         xy_pos_t spacing, start;
         EEPROM_READ(spacing);                          // 2 ints
         EEPROM_READ(start);                            // 2 ints
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
-            bbl.set_grid(spacing, start);
-            EEPROM_READ(Z_VALUES_ARR);                 // 9 to 256 floats
+            bedlevel.set_grid(spacing, start);
+            EEPROM_READ(bedlevel.z_values);                 // 9 to 256 floats
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
       //
@@ -1870,21 +1870,21 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(xatc.z_offset);
       #endif
 
       //
       // Unified Bed Leveling active state
       //
       {
         _FIELD_TEST(planner_leveling_active);
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           const bool &planner_leveling_active = planner.leveling_active;
-          const int8_t &ubl_storage_slot = ubl.storage_slot;
+          const int8_t &ubl_storage_slot = bedlevel.storage_slot;
         #else
           bool planner_leveling_active;
           int8_t ubl_storage_slot;
         #endif
         EEPROM_READ(planner_leveling_active);
         EEPROM_READ(ubl_storage_slot);
       }
 
       //
       // SERVO_ANGLES
@@ -2610,44 +2610,44 @@ void MarlinSettings::postprocess() {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
-          ubl.report_state();
+          bedlevel.report_state();
 
-          if (!ubl.sanity_check()) {
+          if (!bedlevel.sanity_check()) {
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
-              ubl.echo_name();
+              bedlevel.echo_name();
               DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
-              ubl.echo_name();
+              bedlevel.echo_name();
               DEBUG_ECHOLNPGM(".");
             #endif
-            ubl.reset();
+            bedlevel.reset();
           }
 
-          if (ubl.storage_slot >= 0) {
-            load_mesh(ubl.storage_slot);
-            DEBUG_ECHOLNPGM("Mesh ", ubl.storage_slot, " loaded from storage.");
+          if (bedlevel.storage_slot >= 0) {
+            load_mesh(bedlevel.storage_slot);
+            DEBUG_ECHOLNPGM("Mesh ", bedlevel.storage_slot, " loaded from storage.");
           }
           else {
-            ubl.reset();
+            bedlevel.reset();
             DEBUG_ECHOLNPGM("UBL reset");
           }
         }
       #endif
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
       // Report the EEPROM settings
       if (!validating && TERN1(EEPROM_BOOT_SILENT, IsRunning())) report();
     #endif
@@ -2701,21 +2701,21 @@ void MarlinSettings::postprocess() {
     // is a placeholder for the size of the MAT; the MAT will always
     // live at the very end of the eeprom
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129;
 
     uint16_t MarlinSettings::meshes_start_index() {
       // Pad the end of configuration data so it can float up
       // or down a little bit without disrupting the mesh data
       return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;
     }
 
-    #define MESH_STORE_SIZE sizeof(TERN(OPTIMIZED_MESH_STORAGE, mesh_store_t, ubl.z_values))
+    #define MESH_STORE_SIZE sizeof(TERN(OPTIMIZED_MESH_STORAGE, mesh_store_t, bedlevel.z_values))
 
     uint16_t MarlinSettings::calc_num_meshes() {
       return (meshes_end - meshes_start_index()) / MESH_STORE_SIZE;
     }
 
     int MarlinSettings::mesh_slot_offset(const int8_t slot) {
       return meshes_end - (slot + 1) * MESH_STORE_SIZE;
     }
 
     void MarlinSettings::store_mesh(const int8_t slot) {
@@ -2727,24 +2727,24 @@ void MarlinSettings::postprocess() {
           DEBUG_ECHOLNPGM("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
           DEBUG_EOL();
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
 
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-          ubl.set_store_from_mesh(ubl.z_values, z_mesh_store);
+          bedlevel.set_store_from_mesh(bedlevel.z_values, z_mesh_store);
           uint8_t * const src = (uint8_t*)&z_mesh_store;
         #else
-          uint8_t * const src = (uint8_t*)&ubl.z_values;
+          uint8_t * const src = (uint8_t*)&bedlevel.z_values;
         #endif
 
         // Write crc to MAT along with other data, or just tack on to the beginning or end
         persistentStore.access_start();
         const bool status = persistentStore.write_data(pos, src, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
         if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
         else        DEBUG_ECHOLNPGM("Mesh saved in slot ", slot);
 
@@ -2765,35 +2765,35 @@ void MarlinSettings::postprocess() {
           ubl_invalid_slot(a);
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
           uint8_t * const dest = (uint8_t*)&z_mesh_store;
         #else
-          uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
+          uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&bedlevel.z_values;
         #endif
 
         persistentStore.access_start();
         const uint16_t status = persistentStore.read_data(pos, dest, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           if (into) {
             float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-            ubl.set_mesh_from_store(z_mesh_store, z_values);
+            bedlevel.set_mesh_from_store(z_mesh_store, z_values);
             memcpy(into, z_values, sizeof(z_values));
           }
           else
-            ubl.set_mesh_from_store(z_mesh_store, ubl.z_values);
+            bedlevel.set_mesh_from_store(z_mesh_store, bedlevel.z_values);
         #endif
 
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        DEBUG_ECHOLNPGM("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();
 
       #else
 
         // Other mesh types
@@ -3434,46 +3434,47 @@ void MarlinSettings::reset() {
 
       gcode.M420_report(forReplay);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 S3 I", px, " J", py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(mbl.z_offset), 5);
+          SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(bedlevel.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
           SERIAL_EOL();
-          ubl.report_state();
-          SERIAL_ECHO_MSG("Active Mesh Slot ", ubl.storage_slot);
+          bedlevel.report_state();
+          SERIAL_ECHO_MSG("Active Mesh Slot ", bedlevel.storage_slot);
           SERIAL_ECHO_MSG("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
         }
 
-       //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
-                                                  // solution needs to be found.
+       //bedlevel.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
+                                           // solution needs to be found.
+
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(Z_VALUES_ARR[px][py]), 5);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(bedlevel.z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
     //
     // X Axis Twist Compensation

commit 1e749e4f48f528179213e736c99371843a90b4fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:13:59 2022 -0500

    üßë‚Äçüíª Misc. LCD cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index cf91dc25b4..2d74751a82 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1510,21 +1510,21 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
     //
     // Creality DWIN User Data
     //
     #if ENABLED(DWIN_LCD_PROUI)
     {
       _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
-      DWIN_StoreSettings(dwin_data);
+      DWIN_CopySettingsTo(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #endif
 
     #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       _FIELD_TEST(dwin_settings);
       char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
       CrealityDWIN.Save_Settings(dwin_settings);
       EEPROM_WRITE(dwin_settings);
@@ -2486,21 +2486,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Creality DWIN User Data
       //
       #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
-        if (!validating) DWIN_LoadSettings(dwin_data);
+        if (!validating) DWIN_CopySettingsFrom(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
         const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
         if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
       }
       #endif
 
@@ -2922,21 +2922,20 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
-  TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
@@ -3297,20 +3296,25 @@ void MarlinSettings::reset() {
   //
   // Fan tachometer check
   //
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
+  //
+  // Ender-3 V2 with ProUI
+  //
+  TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
+
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
     constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
     constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
     constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
     #if ENABLED(MPC_INCLUDE_FAN)
       constexpr float _mpc_ambient_xfer_coeff_fan255[] = MPC_AMBIENT_XFER_COEFF_FAN255;

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index bae5d36aaa..cf91dc25b4 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -534,21 +534,21 @@ typedef struct SettingsDataStruct {
     uint32_t ethernet_ip,                               // M552 P
              ethernet_dns,
              ethernet_gateway,                          // M553 P
              ethernet_subnet;                           // M554 P
   #endif
 
   //
   // Buzzer enable/disable
   //
   #if ENABLED(SOUND_MENU_ITEM)
-    bool buzzer_enabled;
+    bool sound_on;
   #endif
 
   //
   // Fan tachometer check
   //
   #if HAS_FANCHECK
     bool fan_check_enabled;
   #endif
 
   //
@@ -1569,21 +1569,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(ethernet_dns);
       EEPROM_WRITE(ethernet_gateway);
       EEPROM_WRITE(ethernet_subnet);
     }
     #endif
 
     //
     // Buzzer enable/disable
     //
     #if ENABLED(SOUND_MENU_ITEM)
-      EEPROM_WRITE(ui.buzzer_enabled);
+      EEPROM_WRITE(ui.sound_on);
     #endif
 
     //
     // Fan tachometer check
     //
     #if HAS_FANCHECK
       EEPROM_WRITE(fan_check.enabled);
     #endif
 
     //
@@ -2539,22 +2539,22 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(ethernet_ip);      ethernet.ip      = ethernet_ip;
         EEPROM_READ(ethernet_dns);     ethernet.myDns   = ethernet_dns;
         EEPROM_READ(ethernet_gateway); ethernet.gateway = ethernet_gateway;
         EEPROM_READ(ethernet_subnet);  ethernet.subnet  = ethernet_subnet;
       #endif
 
       //
       // Buzzer enable/disable
       //
       #if ENABLED(SOUND_MENU_ITEM)
-        _FIELD_TEST(buzzer_enabled);
-        EEPROM_READ(ui.buzzer_enabled);
+        _FIELD_TEST(sound_on);
+        EEPROM_READ(ui.sound_on);
       #endif
 
       //
       // Fan tachometer check
       //
       #if HAS_FANCHECK
         _FIELD_TEST(fan_check_enabled);
         EEPROM_READ(fan_check.enabled);
       #endif
 
@@ -2938,21 +2938,23 @@ void MarlinSettings::reset() {
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());
 
   //
   // Buzzer enable/disable
   //
-  TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
+  #if ENABLED(SOUND_MENU_ITEM)
+    ui.sound_on = ENABLED(SOUND_ON_DEFAULT);
+  #endif
 
   //
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a9737e5ed3..bae5d36aaa 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -340,23 +340,23 @@ typedef struct SettingsDataStruct {
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 (S2) Z
           z3_endstop_adj,                               // M666 (S3) Z
           z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
   //
   // Z_STEPPER_AUTO_ALIGN, HAS_Z_STEPPER_ALIGN_STEPPER_XY
   //
   #if ENABLED(Z_STEPPER_AUTO_ALIGN)
-    xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
+    xy_pos_t z_stepper_align_xy[NUM_Z_STEPPERS];             // M422 S X Y
     #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
-      xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
+      xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPERS];   // M422 W X Y
     #endif
   #endif
 
   //
   // Material Presets
   //
   #if HAS_PREHEAT
     preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
   #endif
 
@@ -1010,27 +1010,27 @@ void MarlinSettings::postprocess() {
     #if HAS_EXTRA_ENDSTOPS
     {
       _FIELD_TEST(x2_endstop_adj);
 
       // Write dual endstops in X, Y, Z order. Unused = 0.0
       dummyf = 0;
       EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
       EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
       EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
 
-      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPERS >= 3
         EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummyf);
       #endif
 
-      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPERS >= 4
         EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummyf);
       #endif
     }
     #endif
 
     #if ENABLED(Z_STEPPER_AUTO_ALIGN)
       EEPROM_WRITE(z_stepper_align.xy);
       #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
@@ -1962,26 +1962,26 @@ void MarlinSettings::postprocess() {
       // Extra Endstops offsets
       //
       #if HAS_EXTRA_ENDSTOPS
       {
         _FIELD_TEST(x2_endstop_adj);
 
         EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
         EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
         EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
 
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPERS >= 3
           EEPROM_READ(endstops.z3_endstop_adj); // 1 float
         #else
           EEPROM_READ(dummyf);
         #endif
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPERS >= 4
           EEPROM_READ(endstops.z4_endstop_adj); // 1 float
         #else
           EEPROM_READ(dummyf);
         #endif
       }
       #endif
 
       #if ENABLED(Z_STEPPER_AUTO_ALIGN)
         EEPROM_READ(z_stepper_align.xy);
         #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
@@ -3035,27 +3035,27 @@ void MarlinSettings::reset() {
       #define Y2_ENDSTOP_ADJUSTMENT 0
     #endif
     endstops.y2_endstop_adj = Y2_ENDSTOP_ADJUSTMENT;
   #endif
 
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #ifndef Z2_ENDSTOP_ADJUSTMENT
       #define Z2_ENDSTOP_ADJUSTMENT 0
     #endif
     endstops.z2_endstop_adj = Z2_ENDSTOP_ADJUSTMENT;
-    #if NUM_Z_STEPPER_DRIVERS >= 3
+    #if NUM_Z_STEPPERS >= 3
       #ifndef Z3_ENDSTOP_ADJUSTMENT
         #define Z3_ENDSTOP_ADJUSTMENT 0
       #endif
       endstops.z3_endstop_adj = Z3_ENDSTOP_ADJUSTMENT;
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 4
+    #if NUM_Z_STEPPERS >= 4
       #ifndef Z4_ENDSTOP_ADJUSTMENT
         #define Z4_ENDSTOP_ADJUSTMENT 0
       #endif
       endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
     #endif
   #endif
 
   //
   // Preheat parameters
   //

commit ac4fefa49a34ca299816419cc76715dd7fc9af62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 23 05:00:46 2022 -0500

    ‚ôªÔ∏è Consolidate DGUSScreenHandler class (#24067)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 82725a7e63..a9737e5ed3 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -548,21 +548,21 @@ typedef struct SettingsDataStruct {
   // Fan tachometer check
   //
   #if HAS_FANCHECK
     bool fan_check_enabled;
   #endif
 
   //
   // MKS UI controller
   //
   #if ENABLED(DGUS_LCD_UI_MKS)
-    uint8_t mks_language_index;                         // Display Language
+    MKS_Language mks_language_index;                    // Display Language
     xy_int_t mks_corner_offsets[5];                     // Bed Tramming
     xyz_int_t mks_park_pos;                             // Custom Parking (without NOZZLE_PARK)
     celsius_t mks_min_extrusion_temp;                   // Min E Temp (shadow M302 value)
   #endif
 
   #if HAS_MULTI_LANGUAGE
     uint8_t ui_language;                                // M414 S
   #endif
 
   //
@@ -3295,30 +3295,20 @@ void MarlinSettings::reset() {
   //
   // Fan tachometer check
   //
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
-  postprocess();
-
-  #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
-    FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
-    TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
-    DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
-  #endif
-
-  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
-
   //
   // Model predictive control
   //
   #if ENABLED(MPCTEMP)
     constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
     constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
     constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
     constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
     #if ENABLED(MPC_INCLUDE_FAN)
       constexpr float _mpc_ambient_xfer_coeff_fan255[] = MPC_AMBIENT_XFER_COEFF_FAN255;
@@ -3335,20 +3325,30 @@ void MarlinSettings::reset() {
     HOTEND_LOOP() {
       thermalManager.temp_hotend[e].constants.heater_power = _mpc_heater_power[e];
       thermalManager.temp_hotend[e].constants.block_heat_capacity = _mpc_block_heat_capacity[e];
       thermalManager.temp_hotend[e].constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
       thermalManager.temp_hotend[e].constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
       #if ENABLED(MPC_INCLUDE_FAN)
         thermalManager.temp_hotend[e].constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
       #endif
     }
   #endif
+
+  postprocess();
+
+  #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+    FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
+    TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
+    DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
+  #endif
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);

commit d4fd39f05fe9ac17f987eda2f6f5996fbfb8947e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 20 00:52:05 2022 -0500

    üêõ  Update M913, M914 report
    
    Followup to #11248, #11249, #23400

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0b06865ddb..82725a7e63 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -426,24 +426,24 @@ typedef struct SettingsDataStruct {
   //
   // !NO_VOLUMETRIC
   //
   bool parser_volumetric_enabled;                       // M200 S  parser.volumetric_enabled
   float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
   float planner_volumetric_extruder_limit[EXTRUDERS];   // M200 T L  planner.volumetric_extruder_limit[]
 
   //
   // HAS_TRINAMIC_CONFIG
   //
-  per_stepper_uint16_t tmc_stepper_current;             // M906 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  per_stepper_uint32_t tmc_hybrid_threshold;            // M913 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  mot_stepper_int16_t tmc_sgt;                          // M914 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4
-  per_stepper_bool_t tmc_stealth_enabled;               // M569 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  per_stepper_uint16_t tmc_stepper_current;             // M906 X Y Z...
+  per_stepper_uint32_t tmc_hybrid_threshold;            // M913 X Y Z...
+  mot_stepper_int16_t tmc_sgt;                          // M914 X Y Z...
+  per_stepper_bool_t tmc_stealth_enabled;               // M569 X Y Z...
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT

commit 8aaf64d9172bacff2231823ccedbe27a1a968d45
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Apr 19 05:15:15 2022 +0200

    üí• Update Motor Current G-codes for extra axes (#23975)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6526a3c192..0b06865ddb 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -440,21 +440,29 @@ typedef struct SettingsDataStruct {
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
-    #define MOTOR_CURRENT_COUNT NUM_AXES
+    #if HAS_MOTOR_CURRENT_PWM
+      #define MOTOR_CURRENT_COUNT 3
+    #elif HAS_MOTOR_CURRENT_DAC
+      #define MOTOR_CURRENT_COUNT LOGICAL_AXES
+    #elif HAS_MOTOR_CURRENT_I2C
+      #define MOTOR_CURRENT_COUNT DIGIPOT_I2C_NUM_CHANNELS
+    #else // HAS_MOTOR_CURRENT_SPI
+      #define MOTOR_CURRENT_COUNT DISTINCT_AXES
+    #endif
   #endif
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION

commit 32e6767b5acfc57ced0a58c269ff5ae1d6f5cfd2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 4 15:57:03 2022 -0500

    ‚ú® DOGM Display Sleep (#23992)
    
    Co-authored-by: borland1 <barryorlando@hotmail.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 55dc0b4071..6526a3c192 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -395,21 +395,23 @@ typedef struct SettingsDataStruct {
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
   //
   // Display Sleep
   //
   #if LCD_BACKLIGHT_TIMEOUT
-    uint16_t lcd_backlight_timeout;                     // (G-code needed)
+    uint16_t lcd_backlight_timeout;                     // M255 S
+  #elif HAS_DISPLAY_SLEEP
+    uint8_t sleep_timeout_minutes;                      // M255 S
   #endif
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
   // POWER_LOSS_RECOVERY
   //
@@ -624,20 +626,22 @@ void MarlinSettings::postprocess() {
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 
   #if LCD_BACKLIGHT_TIMEOUT
     ui.refresh_backlight_timeout();
+  #elif HAS_DISPLAY_SLEEP
+    ui.refresh_screen_timeout();
   #endif
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
   );
@@ -1139,20 +1143,22 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
     }
 
     //
     // LCD Backlight / Sleep Timeout
     //
     #if LCD_BACKLIGHT_TIMEOUT
       EEPROM_WRITE(ui.lcd_backlight_timeout);
+    #elif HAS_DISPLAY_SLEEP
+      EEPROM_WRITE(ui.sleep_timeout_minutes);
     #endif
 
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
         const controllerFan_settings_t &cfs = controllerFan.settings;
       #else
@@ -2088,20 +2094,22 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
       //
       // LCD Backlight / Sleep Timeout
       //
       #if LCD_BACKLIGHT_TIMEOUT
         EEPROM_READ(ui.lcd_backlight_timeout);
+      #elif HAS_DISPLAY_SLEEP
+        EEPROM_READ(ui.sleep_timeout_minutes);
       #endif
 
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
         EEPROM_READ(cfs);
         TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
@@ -3165,20 +3173,22 @@ void MarlinSettings::reset() {
   //
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // LCD Backlight / Sleep Timeout
   //
   #if LCD_BACKLIGHT_TIMEOUT
     ui.lcd_backlight_timeout = LCD_BACKLIGHT_TIMEOUT;
+  #elif HAS_DISPLAY_SLEEP
+    ui.sleep_timeout_minutes = DISPLAY_SLEEP_MINUTES;
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
@@ -3495,20 +3505,25 @@ void MarlinSettings::reset() {
     #if HAS_USER_THERMISTORS
       LOOP_L_N(i, USER_THERMISTORS)
         thermalManager.M305_report(i, forReplay);
     #endif
 
     //
     // LCD Contrast
     //
     TERN_(HAS_LCD_CONTRAST, gcode.M250_report(forReplay));
 
+    //
+    // Display Sleep
+    //
+    TERN_(HAS_GCODE_M255, gcode.M255_report(forReplay));
+
     //
     // LCD Brightness
     //
     TERN_(HAS_LCD_BRIGHTNESS, gcode.M256_report(forReplay));
 
     //
     // Controller Fan
     //
     TERN_(CONTROLLER_FAN_EDITABLE, gcode.M710_report(forReplay));
 

commit 19838d97be0d9ae22efa9d51a412bb1ac0bf056b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:50:39 2022 -0500

    üé®  Misc. adjustments, spacing

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 5dc8e2e664..55dc0b4071 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -392,21 +392,21 @@ typedef struct SettingsDataStruct {
   // HAS_LCD_CONTRAST
   //
   uint8_t lcd_contrast;                                 // M250 C
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
   //
-  // LCD_BACKLIGHT_TIMEOUT
+  // Display Sleep
   //
   #if LCD_BACKLIGHT_TIMEOUT
     uint16_t lcd_backlight_timeout;                     // (G-code needed)
   #endif
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
@@ -1135,35 +1135,35 @@ void MarlinSettings::postprocess() {
     //
     // LCD Brightness
     //
     {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
     }
 
     //
-    // LCD Backlight Timeout
+    // LCD Backlight / Sleep Timeout
     //
     #if LCD_BACKLIGHT_TIMEOUT
       EEPROM_WRITE(ui.lcd_backlight_timeout);
     #endif
 
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
         const controllerFan_settings_t &cfs = controllerFan.settings;
       #else
-        controllerFan_settings_t cfs = controllerFan_defaults;
+        constexpr controllerFan_settings_t cfs = controllerFan_defaults;
       #endif
       EEPROM_WRITE(cfs);
     }
 
     //
     // Power-Loss Recovery
     //
     {
       _FIELD_TEST(recovery_enabled);
       const bool recovery_enabled = TERN(POWER_LOSS_RECOVERY, recovery.enabled, ENABLED(PLR_ENABLED_DEFAULT));
@@ -2084,21 +2084,21 @@ void MarlinSettings::postprocess() {
       // LCD Brightness
       //
       {
         uint8_t lcd_brightness;
         _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
       //
-      // LCD Backlight Timeout
+      // LCD Backlight / Sleep Timeout
       //
       #if LCD_BACKLIGHT_TIMEOUT
         EEPROM_READ(ui.lcd_backlight_timeout);
       #endif
 
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
@@ -3161,21 +3161,21 @@ void MarlinSettings::reset() {
   // LCD Contrast
   //
   TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
-  // LCD Backlight Timeout
+  // LCD Backlight / Sleep Timeout
   //
   #if LCD_BACKLIGHT_TIMEOUT
     ui.lcd_backlight_timeout = LCD_BACKLIGHT_TIMEOUT;
   #endif
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 

commit c4873a64ecd54dc0bbccb1eaeecd1b5ae2f6aef5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:14:02 2022 -0500

    üßë‚Äçüíª General and Axis-based bitfield flags (#23989)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fa0222119d..5dc8e2e664 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -171,25 +171,26 @@
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
 
 #define _EN_ITEM(N) , E##N
+#define _EN1_ITEM(N) , E##N:1
 
-typedef struct { uint16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
-typedef struct { uint32_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
-typedef struct {  int16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
-typedef struct {     bool NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
+typedef struct { uint16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint16_t;
+typedef struct { uint32_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } per_stepper_uint32_t;
+typedef struct {  int16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4;                              } mot_stepper_int16_t;
+typedef struct {     bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1), X2:1, Y2:1, Z2:1, Z3:1, Z4:1 REPEAT(E_STEPPERS, _EN1_ITEM); } per_stepper_bool_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
@@ -423,24 +424,24 @@ typedef struct SettingsDataStruct {
   //
   // !NO_VOLUMETRIC
   //
   bool parser_volumetric_enabled;                       // M200 S  parser.volumetric_enabled
   float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
   float planner_volumetric_extruder_limit[EXTRUDERS];   // M200 T L  planner.volumetric_extruder_limit[]
 
   //
   // HAS_TRINAMIC_CONFIG
   //
-  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
-  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2 Y2 Z2 Z3 Z4
-  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  per_stepper_uint16_t tmc_stepper_current;             // M906 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  per_stepper_uint32_t tmc_hybrid_threshold;            // M913 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  mot_stepper_int16_t tmc_sgt;                          // M914 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4
+  per_stepper_bool_t tmc_stealth_enabled;               // M569 X Y Z I J K U V W X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
@@ -1213,21 +1214,21 @@ void MarlinSettings::postprocess() {
 
       #endif
     }
 
     //
     // TMC Configuration
     //
     {
       _FIELD_TEST(tmc_stepper_current);
 
-      tmc_stepper_current_t tmc_stepper_current{0};
+      per_stepper_uint16_t tmc_stepper_current{0};
 
       #if HAS_TRINAMIC_CONFIG
         #if AXIS_IS_TMC(X)
           tmc_stepper_current.X = stepperX.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y)
           tmc_stepper_current.Y = stepperY.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
           tmc_stepper_current.Z = stepperZ.getMilliamps();
@@ -1293,21 +1294,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(tmc_stepper_current);
     }
 
     //
     // TMC Hybrid Threshold, and placeholder values
     //
     {
       _FIELD_TEST(tmc_hybrid_threshold);
 
       #if ENABLED(HYBRID_THRESHOLD)
-        tmc_hybrid_threshold_t tmc_hybrid_threshold{0};
+        per_stepper_uint32_t tmc_hybrid_threshold{0};
         TERN_(X_HAS_STEALTHCHOP,  tmc_hybrid_threshold.X =  stepperX.get_pwm_thrs());
         TERN_(Y_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Y =  stepperY.get_pwm_thrs());
         TERN_(Z_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Z =  stepperZ.get_pwm_thrs());
         TERN_(I_HAS_STEALTHCHOP,  tmc_hybrid_threshold.I =  stepperI.get_pwm_thrs());
         TERN_(J_HAS_STEALTHCHOP,  tmc_hybrid_threshold.J =  stepperJ.get_pwm_thrs());
         TERN_(K_HAS_STEALTHCHOP,  tmc_hybrid_threshold.K =  stepperK.get_pwm_thrs());
         TERN_(U_HAS_STEALTHCHOP,  tmc_hybrid_threshold.U =  stepperU.get_pwm_thrs());
         TERN_(V_HAS_STEALTHCHOP,  tmc_hybrid_threshold.V =  stepperV.get_pwm_thrs());
         TERN_(W_HAS_STEALTHCHOP,  tmc_hybrid_threshold.W =  stepperW.get_pwm_thrs());
         TERN_(X2_HAS_STEALTHCHOP, tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs());
@@ -1318,35 +1319,35 @@ void MarlinSettings::postprocess() {
         TERN_(E0_HAS_STEALTHCHOP, tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs());
         TERN_(E1_HAS_STEALTHCHOP, tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs());
         TERN_(E2_HAS_STEALTHCHOP, tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs());
         TERN_(E3_HAS_STEALTHCHOP, tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs());
         TERN_(E4_HAS_STEALTHCHOP, tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs());
         TERN_(E5_HAS_STEALTHCHOP, tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs());
         TERN_(E6_HAS_STEALTHCHOP, tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs());
         TERN_(E7_HAS_STEALTHCHOP, tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs());
       #else
         #define _EN_ITEM(N) , .E##N =  30
-        const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
+        const per_stepper_uint32_t tmc_hybrid_threshold = {
           NUM_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3, .U = 3, .V = 3, .W = 3),
           .X2 = 100, .Y2 = 100, .Z2 = 3, .Z3 = 3, .Z4 = 3
           REPEAT(E_STEPPERS, _EN_ITEM)
         };
         #undef _EN_ITEM
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
     //
     {
-      tmc_sgt_t tmc_sgt{0};
+      mot_stepper_int16_t tmc_sgt{0};
       #if USE_SENSORLESS
         NUM_AXIS_CODE(
           TERN_(X_SENSORLESS, tmc_sgt.X = stepperX.homing_threshold()),
           TERN_(Y_SENSORLESS, tmc_sgt.Y = stepperY.homing_threshold()),
           TERN_(Z_SENSORLESS, tmc_sgt.Z = stepperZ.homing_threshold()),
           TERN_(I_SENSORLESS, tmc_sgt.I = stepperI.homing_threshold()),
           TERN_(J_SENSORLESS, tmc_sgt.J = stepperJ.homing_threshold()),
           TERN_(K_SENSORLESS, tmc_sgt.K = stepperK.homing_threshold()),
           TERN_(U_SENSORLESS, tmc_sgt.U = stepperU.homing_threshold()),
           TERN_(V_SENSORLESS, tmc_sgt.V = stepperV.homing_threshold()),
@@ -1360,21 +1361,21 @@ void MarlinSettings::postprocess() {
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
 
     //
     // TMC stepping mode
     //
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
-      tmc_stealth_enabled_t tmc_stealth_enabled = { false };
+      per_stepper_bool_t tmc_stealth_enabled = { false };
       TERN_(X_HAS_STEALTHCHOP,  tmc_stealth_enabled.X  = stepperX.get_stored_stealthChop());
       TERN_(Y_HAS_STEALTHCHOP,  tmc_stealth_enabled.Y  = stepperY.get_stored_stealthChop());
       TERN_(Z_HAS_STEALTHCHOP,  tmc_stealth_enabled.Z  = stepperZ.get_stored_stealthChop());
       TERN_(I_HAS_STEALTHCHOP,  tmc_stealth_enabled.I  = stepperI.get_stored_stealthChop());
       TERN_(J_HAS_STEALTHCHOP,  tmc_stealth_enabled.J  = stepperJ.get_stored_stealthChop());
       TERN_(K_HAS_STEALTHCHOP,  tmc_stealth_enabled.K  = stepperK.get_stored_stealthChop());
       TERN_(U_HAS_STEALTHCHOP,  tmc_stealth_enabled.U  = stepperU.get_stored_stealthChop());
       TERN_(V_HAS_STEALTHCHOP,  tmc_stealth_enabled.V  = stepperV.get_stored_stealthChop());
       TERN_(W_HAS_STEALTHCHOP,  tmc_stealth_enabled.W  = stepperW.get_stored_stealthChop());
       TERN_(X2_HAS_STEALTHCHOP, tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop());
@@ -2161,21 +2162,21 @@ void MarlinSettings::postprocess() {
       //
       // TMC Stepper Settings
       //
 
       if (!validating) reset_stepper_drivers();
 
       // TMC Stepper Current
       {
         _FIELD_TEST(tmc_stepper_current);
 
-        tmc_stepper_current_t currents;
+        per_stepper_uint16_t currents;
         EEPROM_READ(currents);
 
         #if HAS_TRINAMIC_CONFIG
 
           #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
           if (!validating) {
             #if AXIS_IS_TMC(X)
               SET_CURR(X);
             #endif
             #if AXIS_IS_TMC(Y)
@@ -2240,21 +2241,21 @@ void MarlinSettings::postprocess() {
             #endif
             #if AXIS_IS_TMC(E7)
               SET_CURR(E7);
             #endif
           }
         #endif
       }
 
       // TMC Hybrid Threshold
       {
-        tmc_hybrid_threshold_t tmc_hybrid_threshold;
+        per_stepper_uint32_t tmc_hybrid_threshold;
         _FIELD_TEST(tmc_hybrid_threshold);
         EEPROM_READ(tmc_hybrid_threshold);
 
         #if ENABLED(HYBRID_THRESHOLD)
           if (!validating) {
             TERN_(X_HAS_STEALTHCHOP,  stepperX.set_pwm_thrs(tmc_hybrid_threshold.X));
             TERN_(Y_HAS_STEALTHCHOP,  stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y));
             TERN_(Z_HAS_STEALTHCHOP,  stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z));
             TERN_(X2_HAS_STEALTHCHOP, stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2));
             TERN_(Y2_HAS_STEALTHCHOP, stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2));
@@ -2276,21 +2277,21 @@ void MarlinSettings::postprocess() {
             TERN_(E6_HAS_STEALTHCHOP, stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6));
             TERN_(E7_HAS_STEALTHCHOP, stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7));
           }
         #endif
       }
 
       //
       // TMC StallGuard threshold.
       //
       {
-        tmc_sgt_t tmc_sgt;
+        mot_stepper_int16_t tmc_sgt;
         _FIELD_TEST(tmc_sgt);
         EEPROM_READ(tmc_sgt);
         #if USE_SENSORLESS
           if (!validating) {
             NUM_AXIS_CODE(
               TERN_(X_SENSORLESS, stepperX.homing_threshold(tmc_sgt.X)),
               TERN_(Y_SENSORLESS, stepperY.homing_threshold(tmc_sgt.Y)),
               TERN_(Z_SENSORLESS, stepperZ.homing_threshold(tmc_sgt.Z)),
               TERN_(I_SENSORLESS, stepperI.homing_threshold(tmc_sgt.I)),
               TERN_(J_SENSORLESS, stepperJ.homing_threshold(tmc_sgt.J)),
@@ -2305,21 +2306,21 @@ void MarlinSettings::postprocess() {
             TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
             TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
           }
         #endif
       }
 
       // TMC stepping mode
       {
         _FIELD_TEST(tmc_stealth_enabled);
 
-        tmc_stealth_enabled_t tmc_stealth_enabled;
+        per_stepper_bool_t tmc_stealth_enabled;
         EEPROM_READ(tmc_stealth_enabled);
 
         #if HAS_TRINAMIC_CONFIG
 
           #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
           if (!validating) {
             TERN_(X_HAS_STEALTHCHOP,  SET_STEPPING_MODE(X));
             TERN_(Y_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Y));
             TERN_(Z_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Z));
             TERN_(I_HAS_STEALTHCHOP,  SET_STEPPING_MODE(I));

commit 72b2e2b2c7230245dea9fcb46b9b8a92bcb11bcc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 08:14:14 2022 +0100

    ‚öóÔ∏è Temperature Model Predictive Control (#23751)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2b2aae2633..fa0222119d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -547,20 +547,27 @@ typedef struct SettingsDataStruct {
     uint8_t mks_language_index;                         // Display Language
     xy_int_t mks_corner_offsets[5];                     // Bed Tramming
     xyz_int_t mks_park_pos;                             // Custom Parking (without NOZZLE_PARK)
     celsius_t mks_min_extrusion_temp;                   // Min E Temp (shadow M302 value)
   #endif
 
   #if HAS_MULTI_LANGUAGE
     uint8_t ui_language;                                // M414 S
   #endif
 
+  //
+  // Model predictive control
+  //
+  #if ENABLED(MPCTEMP)
+    MPC_t mpc_constants[HOTENDS];                       // M306
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1574,20 +1581,28 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(mks_min_extrusion_temp);
     #endif
 
     //
     // Selected LCD language
     //
     #if HAS_MULTI_LANGUAGE
       EEPROM_WRITE(ui.language);
     #endif
 
+    //
+    // Model predictive control
+    //
+    #if ENABLED(MPCTEMP)
+      HOTEND_LOOP()
+        EEPROM_WRITE(thermalManager.temp_hotend[e].constants);
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2542,20 +2557,30 @@ void MarlinSettings::postprocess() {
       //
       #if HAS_MULTI_LANGUAGE
       {
         uint8_t ui_language;
         EEPROM_READ(ui_language);
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
         ui.set_language(ui_language);
       }
       #endif
 
+      //
+      // Model predictive control
+      //
+      #if ENABLED(MPCTEMP)
+      {
+        HOTEND_LOOP()
+          EEPROM_READ(thermalManager.temp_hotend[e].constants);
+      }
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
@@ -3260,20 +3285,51 @@ void MarlinSettings::reset() {
 
   postprocess();
 
   #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
     FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
     TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
     DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
+
+  //
+  // Model predictive control
+  //
+  #if ENABLED(MPCTEMP)
+    constexpr float _mpc_heater_power[] = MPC_HEATER_POWER;
+    constexpr float _mpc_block_heat_capacity[] = MPC_BLOCK_HEAT_CAPACITY;
+    constexpr float _mpc_sensor_responsiveness[] = MPC_SENSOR_RESPONSIVENESS;
+    constexpr float _mpc_ambient_xfer_coeff[] = MPC_AMBIENT_XFER_COEFF;
+    #if ENABLED(MPC_INCLUDE_FAN)
+      constexpr float _mpc_ambient_xfer_coeff_fan255[] = MPC_AMBIENT_XFER_COEFF_FAN255;
+    #endif
+
+    static_assert(COUNT(_mpc_heater_power) == HOTENDS, "MPC_HEATER_POWER must have HOTENDS items.");
+    static_assert(COUNT(_mpc_block_heat_capacity) == HOTENDS, "MPC_BLOCK_HEAT_CAPACITY must have HOTENDS items.");
+    static_assert(COUNT(_mpc_sensor_responsiveness) == HOTENDS, "MPC_SENSOR_RESPONSIVENESS must have HOTENDS items.");
+    static_assert(COUNT(_mpc_ambient_xfer_coeff) == HOTENDS, "MPC_AMBIENT_XFER_COEFF must have HOTENDS items.");
+    #if ENABLED(MPC_INCLUDE_FAN)
+      static_assert(COUNT(_mpc_ambient_xfer_coeff_fan255) == HOTENDS, "MPC_AMBIENT_XFER_COEFF_FAN255 must have HOTENDS items.");
+    #endif
+
+    HOTEND_LOOP() {
+      thermalManager.temp_hotend[e].constants.heater_power = _mpc_heater_power[e];
+      thermalManager.temp_hotend[e].constants.block_heat_capacity = _mpc_block_heat_capacity[e];
+      thermalManager.temp_hotend[e].constants.sensor_responsiveness = _mpc_sensor_responsiveness[e];
+      thermalManager.temp_hotend[e].constants.ambient_xfer_coeff_fan0 = _mpc_ambient_xfer_coeff[e];
+      #if ENABLED(MPC_INCLUDE_FAN)
+        thermalManager.temp_hotend[e].constants.fan255_adjustment = _mpc_ambient_xfer_coeff_fan255[e] - _mpc_ambient_xfer_coeff[e];
+      #endif
+    }
+  #endif
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);
@@ -3536,15 +3592,20 @@ void MarlinSettings::reset() {
     #if HAS_ETHERNET
       CONFIG_ECHO_HEADING("Ethernet");
       if (!forReplay) ETH0_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M552_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M553_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M554_report();
     #endif
 
     TERN_(HAS_MULTI_LANGUAGE, gcode.M414_report(forReplay));
+
+    //
+    // Model predictive control
+    //
+    TERN_(MPCTEMP, gcode.M306_report(forReplay));
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 5d91a90c65..2b2aae2633 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -172,24 +172,24 @@
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
 #endif
 
 #define _EN_ITEM(N) , E##N
 
-typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
-typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
-typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
-typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
+typedef struct { uint16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
+typedef struct { uint32_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
+typedef struct {  int16_t NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
+typedef struct {     bool NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
@@ -203,21 +203,21 @@ static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   #if ENABLED(EEPROM_INIT_NOW)
     uint32_t build_hash;                                // Unique build hash
   #endif
   uint16_t  crc;                                        // Data Checksum
 
   //
   // DISTINCT_E_FACTORS
   //
-  uint8_t e_factors;                                    // DISTINCT_AXES - LINEAR_AXES
+  uint8_t e_factors;                                    // DISTINCT_AXES - NUM_AXES
 
   //
   // Planner settings
   //
   planner_settings_t planner_settings;
 
   xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
   float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
   //
@@ -437,21 +437,21 @@ typedef struct SettingsDataStruct {
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
-    #define MOTOR_CURRENT_COUNT LINEAR_AXES
+    #define MOTOR_CURRENT_COUNT NUM_AXES
   #endif
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
@@ -583,21 +583,21 @@ void MarlinSettings::postprocess() {
   TERN_(PIDTEMP, thermalManager.updatePID());
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
   #elif EXTRUDERS
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
 
   // Software endstops depend on home_offset
-  LOOP_LINEAR_AXES(i) {
+  LOOP_NUM_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, bbl.refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
@@ -731,38 +731,38 @@ void MarlinSettings::postprocess() {
     TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
     #if ENABLED(EEPROM_INIT_NOW)
       EEPROM_SKIP(build_hash);  // Skip the hash slot
     #endif
 
     EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"
 
-    const uint8_t e_factors = DISTINCT_AXES - (LINEAR_AXES);
+    const uint8_t e_factors = DISTINCT_AXES - (NUM_AXES);
     _FIELD_TEST(e_factors);
     EEPROM_WRITE(e_factors);
 
     //
     // Planner Motion
     //
     {
       EEPROM_WRITE(planner.settings);
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
           dummyf = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummyf);
         #endif
       #else
-        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4, 0.4, 0.4, 0.4);
+        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4);
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
       TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
     // Home Offset
     //
@@ -1227,20 +1227,29 @@ void MarlinSettings::postprocess() {
         #endif
         #if AXIS_IS_TMC(I)
           tmc_stepper_current.I = stepperI.getMilliamps();
         #endif
         #if AXIS_IS_TMC(J)
           tmc_stepper_current.J = stepperJ.getMilliamps();
         #endif
         #if AXIS_IS_TMC(K)
           tmc_stepper_current.K = stepperK.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(U)
+          tmc_stepper_current.U = stepperU.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(V)
+          tmc_stepper_current.V = stepperV.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(W)
+          tmc_stepper_current.W = stepperW.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(X2)
           tmc_stepper_current.X2 = stepperX2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y2)
           tmc_stepper_current.Y2 = stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z3)
@@ -1284,58 +1293,64 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(tmc_hybrid_threshold);
 
       #if ENABLED(HYBRID_THRESHOLD)
         tmc_hybrid_threshold_t tmc_hybrid_threshold{0};
         TERN_(X_HAS_STEALTHCHOP,  tmc_hybrid_threshold.X =  stepperX.get_pwm_thrs());
         TERN_(Y_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Y =  stepperY.get_pwm_thrs());
         TERN_(Z_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Z =  stepperZ.get_pwm_thrs());
         TERN_(I_HAS_STEALTHCHOP,  tmc_hybrid_threshold.I =  stepperI.get_pwm_thrs());
         TERN_(J_HAS_STEALTHCHOP,  tmc_hybrid_threshold.J =  stepperJ.get_pwm_thrs());
         TERN_(K_HAS_STEALTHCHOP,  tmc_hybrid_threshold.K =  stepperK.get_pwm_thrs());
+        TERN_(U_HAS_STEALTHCHOP,  tmc_hybrid_threshold.U =  stepperU.get_pwm_thrs());
+        TERN_(V_HAS_STEALTHCHOP,  tmc_hybrid_threshold.V =  stepperV.get_pwm_thrs());
+        TERN_(W_HAS_STEALTHCHOP,  tmc_hybrid_threshold.W =  stepperW.get_pwm_thrs());
         TERN_(X2_HAS_STEALTHCHOP, tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs());
         TERN_(Y2_HAS_STEALTHCHOP, tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs());
         TERN_(Z2_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs());
         TERN_(Z3_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs());
         TERN_(Z4_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs());
         TERN_(E0_HAS_STEALTHCHOP, tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs());
         TERN_(E1_HAS_STEALTHCHOP, tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs());
         TERN_(E2_HAS_STEALTHCHOP, tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs());
         TERN_(E3_HAS_STEALTHCHOP, tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs());
         TERN_(E4_HAS_STEALTHCHOP, tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs());
         TERN_(E5_HAS_STEALTHCHOP, tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs());
         TERN_(E6_HAS_STEALTHCHOP, tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs());
         TERN_(E7_HAS_STEALTHCHOP, tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs());
       #else
         #define _EN_ITEM(N) , .E##N =  30
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
-          LINEAR_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3),
+          NUM_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3, .U = 3, .V = 3, .W = 3),
           .X2 = 100, .Y2 = 100, .Z2 = 3, .Z3 = 3, .Z4 = 3
           REPEAT(E_STEPPERS, _EN_ITEM)
         };
         #undef _EN_ITEM
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
     //
     {
       tmc_sgt_t tmc_sgt{0};
       #if USE_SENSORLESS
-        LINEAR_AXIS_CODE(
+        NUM_AXIS_CODE(
           TERN_(X_SENSORLESS, tmc_sgt.X = stepperX.homing_threshold()),
           TERN_(Y_SENSORLESS, tmc_sgt.Y = stepperY.homing_threshold()),
           TERN_(Z_SENSORLESS, tmc_sgt.Z = stepperZ.homing_threshold()),
           TERN_(I_SENSORLESS, tmc_sgt.I = stepperI.homing_threshold()),
           TERN_(J_SENSORLESS, tmc_sgt.J = stepperJ.homing_threshold()),
-          TERN_(K_SENSORLESS, tmc_sgt.K = stepperK.homing_threshold())
+          TERN_(K_SENSORLESS, tmc_sgt.K = stepperK.homing_threshold()),
+          TERN_(U_SENSORLESS, tmc_sgt.U = stepperU.homing_threshold()),
+          TERN_(V_SENSORLESS, tmc_sgt.V = stepperV.homing_threshold()),
+          TERN_(W_SENSORLESS, tmc_sgt.W = stepperW.homing_threshold())
         );
         TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
         TERN_(Y2_SENSORLESS, tmc_sgt.Y2 = stepperY2.homing_threshold());
         TERN_(Z2_SENSORLESS, tmc_sgt.Z2 = stepperZ2.homing_threshold());
         TERN_(Z3_SENSORLESS, tmc_sgt.Z3 = stepperZ3.homing_threshold());
         TERN_(Z4_SENSORLESS, tmc_sgt.Z4 = stepperZ4.homing_threshold());
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
 
@@ -1345,20 +1360,23 @@ void MarlinSettings::postprocess() {
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
       tmc_stealth_enabled_t tmc_stealth_enabled = { false };
       TERN_(X_HAS_STEALTHCHOP,  tmc_stealth_enabled.X  = stepperX.get_stored_stealthChop());
       TERN_(Y_HAS_STEALTHCHOP,  tmc_stealth_enabled.Y  = stepperY.get_stored_stealthChop());
       TERN_(Z_HAS_STEALTHCHOP,  tmc_stealth_enabled.Z  = stepperZ.get_stored_stealthChop());
       TERN_(I_HAS_STEALTHCHOP,  tmc_stealth_enabled.I  = stepperI.get_stored_stealthChop());
       TERN_(J_HAS_STEALTHCHOP,  tmc_stealth_enabled.J  = stepperJ.get_stored_stealthChop());
       TERN_(K_HAS_STEALTHCHOP,  tmc_stealth_enabled.K  = stepperK.get_stored_stealthChop());
+      TERN_(U_HAS_STEALTHCHOP,  tmc_stealth_enabled.U  = stepperU.get_stored_stealthChop());
+      TERN_(V_HAS_STEALTHCHOP,  tmc_stealth_enabled.V  = stepperV.get_stored_stealthChop());
+      TERN_(W_HAS_STEALTHCHOP,  tmc_stealth_enabled.W  = stepperW.get_stored_stealthChop());
       TERN_(X2_HAS_STEALTHCHOP, tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop());
       TERN_(Y2_HAS_STEALTHCHOP, tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop());
       TERN_(Z2_HAS_STEALTHCHOP, tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop());
       TERN_(Z3_HAS_STEALTHCHOP, tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop());
       TERN_(Z4_HAS_STEALTHCHOP, tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop());
       TERN_(E0_HAS_STEALTHCHOP, tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop());
       TERN_(E1_HAS_STEALTHCHOP, tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop());
       TERN_(E2_HAS_STEALTHCHOP, tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop());
       TERN_(E3_HAS_STEALTHCHOP, tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop());
       TERN_(E4_HAS_STEALTHCHOP, tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop());
@@ -1434,21 +1452,21 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(toolchange_settings);
       EEPROM_WRITE(toolchange_settings);
     #endif
 
     //
     // Backlash Compensation
     //
     {
       #if ENABLED(BACKLASH_GCODE)
         xyz_float_t backlash_distance_mm;
-        LOOP_LINEAR_AXES(axis) backlash_distance_mm[axis] = backlash.get_distance_mm((AxisEnum)axis);
+        LOOP_NUM_AXES(axis) backlash_distance_mm[axis] = backlash.get_distance_mm((AxisEnum)axis);
         const uint8_t backlash_correction = backlash.get_correction_uint8();
       #else
         const xyz_float_t backlash_distance_mm{0};
         const uint8_t backlash_correction = 0;
       #endif
       #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
         const float backlash_smoothing_mm = backlash.get_smoothing_mm();
       #else
         const float backlash_smoothing_mm = 3;
       #endif
@@ -1646,30 +1664,30 @@ void MarlinSettings::postprocess() {
       // Number of e_factors may change
       uint8_t e_factors;
       EEPROM_READ_ALWAYS(e_factors);
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
-        uint32_t tmp1[LINEAR_AXES + e_factors];
-        float tmp2[LINEAR_AXES + e_factors];
-        feedRate_t tmp3[LINEAR_AXES + e_factors];
+        uint32_t tmp1[NUM_AXES + e_factors];
+        float tmp2[NUM_AXES + e_factors];
+        feedRate_t tmp3[NUM_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
         EEPROM_READ(planner.settings.min_segment_time_us);
         EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
         EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
         if (!validating) LOOP_DISTINCT_AXES(i) {
-          const bool in = (i < e_factors + LINEAR_AXES);
+          const bool in = (i < e_factors + NUM_AXES);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
           planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
@@ -2168,20 +2186,29 @@ void MarlinSettings::postprocess() {
             #endif
             #if AXIS_IS_TMC(I)
               SET_CURR(I);
             #endif
             #if AXIS_IS_TMC(J)
               SET_CURR(J);
             #endif
             #if AXIS_IS_TMC(K)
               SET_CURR(K);
             #endif
+            #if AXIS_IS_TMC(U)
+              SET_CURR(U);
+            #endif
+            #if AXIS_IS_TMC(V)
+              SET_CURR(V);
+            #endif
+            #if AXIS_IS_TMC(W)
+              SET_CURR(W);
+            #endif
             #if AXIS_IS_TMC(E0)
               SET_CURR(E0);
             #endif
             #if AXIS_IS_TMC(E1)
               SET_CURR(E1);
             #endif
             #if AXIS_IS_TMC(E2)
               SET_CURR(E2);
             #endif
             #if AXIS_IS_TMC(E3)
@@ -2215,20 +2242,23 @@ void MarlinSettings::postprocess() {
             TERN_(Y_HAS_STEALTHCHOP,  stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y));
             TERN_(Z_HAS_STEALTHCHOP,  stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z));
             TERN_(X2_HAS_STEALTHCHOP, stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2));
             TERN_(Y2_HAS_STEALTHCHOP, stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2));
             TERN_(Z2_HAS_STEALTHCHOP, stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2));
             TERN_(Z3_HAS_STEALTHCHOP, stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3));
             TERN_(Z4_HAS_STEALTHCHOP, stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4));
             TERN_(I_HAS_STEALTHCHOP,  stepperI.set_pwm_thrs(tmc_hybrid_threshold.I));
             TERN_(J_HAS_STEALTHCHOP,  stepperJ.set_pwm_thrs(tmc_hybrid_threshold.J));
             TERN_(K_HAS_STEALTHCHOP,  stepperK.set_pwm_thrs(tmc_hybrid_threshold.K));
+            TERN_(U_HAS_STEALTHCHOP,  stepperU.set_pwm_thrs(tmc_hybrid_threshold.U));
+            TERN_(V_HAS_STEALTHCHOP,  stepperV.set_pwm_thrs(tmc_hybrid_threshold.V));
+            TERN_(W_HAS_STEALTHCHOP,  stepperW.set_pwm_thrs(tmc_hybrid_threshold.W));
             TERN_(E0_HAS_STEALTHCHOP, stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0));
             TERN_(E1_HAS_STEALTHCHOP, stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1));
             TERN_(E2_HAS_STEALTHCHOP, stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2));
             TERN_(E3_HAS_STEALTHCHOP, stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3));
             TERN_(E4_HAS_STEALTHCHOP, stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4));
             TERN_(E5_HAS_STEALTHCHOP, stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5));
             TERN_(E6_HAS_STEALTHCHOP, stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6));
             TERN_(E7_HAS_STEALTHCHOP, stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7));
           }
         #endif
@@ -2236,27 +2266,30 @@ void MarlinSettings::postprocess() {
 
       //
       // TMC StallGuard threshold.
       //
       {
         tmc_sgt_t tmc_sgt;
         _FIELD_TEST(tmc_sgt);
         EEPROM_READ(tmc_sgt);
         #if USE_SENSORLESS
           if (!validating) {
-            LINEAR_AXIS_CODE(
+            NUM_AXIS_CODE(
               TERN_(X_SENSORLESS, stepperX.homing_threshold(tmc_sgt.X)),
               TERN_(Y_SENSORLESS, stepperY.homing_threshold(tmc_sgt.Y)),
               TERN_(Z_SENSORLESS, stepperZ.homing_threshold(tmc_sgt.Z)),
               TERN_(I_SENSORLESS, stepperI.homing_threshold(tmc_sgt.I)),
               TERN_(J_SENSORLESS, stepperJ.homing_threshold(tmc_sgt.J)),
-              TERN_(K_SENSORLESS, stepperK.homing_threshold(tmc_sgt.K))
+              TERN_(K_SENSORLESS, stepperK.homing_threshold(tmc_sgt.K)),
+              TERN_(U_SENSORLESS, stepperU.homing_threshold(tmc_sgt.U)),
+              TERN_(V_SENSORLESS, stepperV.homing_threshold(tmc_sgt.V)),
+              TERN_(W_SENSORLESS, stepperW.homing_threshold(tmc_sgt.W))
             );
             TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
             TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(tmc_sgt.Y2));
             TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(tmc_sgt.Z2));
             TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
             TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
           }
         #endif
       }
 
@@ -2270,20 +2303,23 @@ void MarlinSettings::postprocess() {
         #if HAS_TRINAMIC_CONFIG
 
           #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
           if (!validating) {
             TERN_(X_HAS_STEALTHCHOP,  SET_STEPPING_MODE(X));
             TERN_(Y_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Y));
             TERN_(Z_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Z));
             TERN_(I_HAS_STEALTHCHOP,  SET_STEPPING_MODE(I));
             TERN_(J_HAS_STEALTHCHOP,  SET_STEPPING_MODE(J));
             TERN_(K_HAS_STEALTHCHOP,  SET_STEPPING_MODE(K));
+            TERN_(U_HAS_STEALTHCHOP,  SET_STEPPING_MODE(U));
+            TERN_(V_HAS_STEALTHCHOP,  SET_STEPPING_MODE(V));
+            TERN_(W_HAS_STEALTHCHOP,  SET_STEPPING_MODE(W));
             TERN_(X2_HAS_STEALTHCHOP, SET_STEPPING_MODE(X2));
             TERN_(Y2_HAS_STEALTHCHOP, SET_STEPPING_MODE(Y2));
             TERN_(Z2_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z2));
             TERN_(Z3_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z3));
             TERN_(Z4_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z4));
             TERN_(E0_HAS_STEALTHCHOP, SET_STEPPING_MODE(E0));
             TERN_(E1_HAS_STEALTHCHOP, SET_STEPPING_MODE(E1));
             TERN_(E2_HAS_STEALTHCHOP, SET_STEPPING_MODE(E2));
             TERN_(E3_HAS_STEALTHCHOP, SET_STEPPING_MODE(E3));
             TERN_(E4_HAS_STEALTHCHOP, SET_STEPPING_MODE(E4));
@@ -2390,21 +2426,21 @@ void MarlinSettings::postprocess() {
         xyz_float_t backlash_distance_mm;
         uint8_t backlash_correction;
         float backlash_smoothing_mm;
 
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
 
         #if ENABLED(BACKLASH_GCODE)
-          LOOP_LINEAR_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, backlash_distance_mm[axis]);
+          LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, backlash_distance_mm[axis]);
           backlash.set_correction_uint8(backlash_correction);
           #ifdef BACKLASH_SMOOTHING_MM
             backlash.set_smoothing_mm(backlash_smoothing_mm);
           #endif
         #endif
       }
 
       //
       // Extensible UI User Data
       //
@@ -2766,22 +2802,31 @@ void MarlinSettings::reset() {
     #endif
     #if HAS_I_AXIS && !defined(DEFAULT_IJERK)
       #define DEFAULT_IJERK 0
     #endif
     #if HAS_J_AXIS && !defined(DEFAULT_JJERK)
       #define DEFAULT_JJERK 0
     #endif
     #if HAS_K_AXIS && !defined(DEFAULT_KJERK)
       #define DEFAULT_KJERK 0
     #endif
+    #if HAS_U_AXIS && !defined(DEFAULT_UJERK)
+      #define DEFAULT_UJERK 0
+    #endif
+    #if HAS_V_AXIS && !defined(DEFAULT_VJERK)
+      #define DEFAULT_VJERK 0
+    #endif
+    #if HAS_W_AXIS && !defined(DEFAULT_WJERK)
+      #define DEFAULT_WJERK 0
+    #endif
     planner.max_jerk.set(
-      LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_IJERK, DEFAULT_JJERK, DEFAULT_KJERK)
+      NUM_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_IJERK, DEFAULT_JJERK, DEFAULT_KJERK, DEFAULT_UJERK, DEFAULT_VJERK, DEFAULT_WJERK)
     );
     TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK);
   #endif
 
   TERN_(HAS_JUNCTION_DEVIATION, planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM));
 
   #if HAS_SCARA_OFFSET
     scara_home_offset.reset();
   #elif HAS_HOME_OFFSET
     home_offset.reset();
@@ -2829,21 +2874,21 @@ void MarlinSettings::reset() {
 
     #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
       migration = migration_defaults;
     #endif
 
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
-    LOOP_LINEAR_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
+    LOOP_NUM_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
   TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
@@ -2874,25 +2919,25 @@ void MarlinSettings::reset() {
   //
   // X Axis Twist Compensation
   //
   TERN_(X_AXIS_TWIST_COMPENSATION, xatc.reset());
 
   //
   // Nozzle-to-probe Offset
   //
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
-    static_assert(COUNT(dpo) == LINEAR_AXES, "NOZZLE_TO_PROBE_OFFSET must contain offsets for each linear axis X, Y, Z....");
+    static_assert(COUNT(dpo) == NUM_AXES, "NOZZLE_TO_PROBE_OFFSET must contain offsets for each linear axis X, Y, Z....");
     #if HAS_PROBE_XY_OFFSET
-      LOOP_LINEAR_AXES(a) probe.offset[a] = dpo[a];
+      LOOP_NUM_AXES(a) probe.offset[a] = dpo[a];
     #else
-      probe.offset.set(LINEAR_AXIS_LIST(0, 0, dpo[Z_AXIS], 0, 0, 0));
+      probe.offset.set(NUM_AXIS_LIST(0, 0, dpo[Z_AXIS], 0, 0, 0, 0, 0, 0));
     #endif
   #endif
 
   //
   // Z Stepper Auto-alignment points
   //
   TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
   //
   // Servo Angles

commit ae53033cea506209310fb014b304f3a07c59e9d7
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 03:13:16 2022 +0100

    ‚ôªÔ∏è Refactor and fix ABL Bilinear (#23868)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 02d1b26437..5d91a90c65 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -590,21 +590,21 @@ void MarlinSettings::postprocess() {
   #endif
 
   // Software endstops depend on home_offset
   LOOP_LINEAR_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
-  TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
+  TERN_(AUTO_BED_LEVELING_BILINEAR, bbl.refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.update_brightness());
 
   TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
@@ -869,36 +869,40 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
-          sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
+          sizeof(Z_VALUES_ARR) == (GRID_MAX_POINTS) * sizeof(Z_VALUES_ARR[0][0]),
           "Bilinear Z array is the wrong size."
         );
-      #else
-        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
-      EEPROM_WRITE(bilinear_grid_spacing);
-      EEPROM_WRITE(bilinear_start);
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        EEPROM_WRITE(bbl.get_grid_spacing());
+        EEPROM_WRITE(bbl.get_grid_start());
+      #else
+        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
+        EEPROM_WRITE(bilinear_grid_spacing);
+        EEPROM_WRITE(bilinear_start);
+      #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        EEPROM_WRITE(z_values);              // 9-256 floats
+        EEPROM_WRITE(Z_VALUES_ARR);              // 9-256 floats
       #else
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // X Axis Twist Compensation
     //
     #if ENABLED(X_AXIS_TWIST_COMPENSATION)
@@ -1784,34 +1788,33 @@ void MarlinSettings::postprocess() {
         #endif
       }
 
       //
       // Bilinear Auto Bed Leveling
       //
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
+        xy_pos_t spacing, start;
+        EEPROM_READ(spacing);                          // 2 ints
+        EEPROM_READ(start);                            // 2 ints
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
-            EEPROM_READ(bilinear_grid_spacing);        // 2 ints
-            EEPROM_READ(bilinear_start);               // 2 ints
-            EEPROM_READ(z_values);                     // 9 to 256 floats
+            bbl.set_grid(spacing, start);
+            EEPROM_READ(Z_VALUES_ARR);                 // 9 to 256 floats
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
-            xy_pos_t bgs, bs;
-            EEPROM_READ(bgs);
-            EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
       //
       // X Axis Twist Compensation
       //
       #if ENABLED(X_AXIS_TWIST_COMPENSATION)
         _FIELD_TEST(xatc_spacing);
         EEPROM_READ(xatc.spacing);
@@ -3330,21 +3333,21 @@ void MarlinSettings::reset() {
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
-              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(Z_VALUES_ARR[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
     //
     // X Axis Twist Compensation

commit d6fcae40c4ded0901aae33f7a1a9d5049ab12b89
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 29 03:38:25 2022 -0500

    üí• Rename ExtUI settings methods

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 1f482afeb4..02d1b26437 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1588,21 +1588,21 @@ void MarlinSettings::postprocess() {
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
     #endif
 
     if (!eeprom_error) {
       LCD_MESSAGE(MSG_SETTINGS_STORED);
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_SETTINGS_STORED)));
     }
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
+    TERN_(EXTENSIBLE_UI, ExtUI::onSettingsStored(!eeprom_error));
 
     return !eeprom_error;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
   bool MarlinSettings::_load() {
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
@@ -2591,21 +2591,21 @@ void MarlinSettings::postprocess() {
     #else
       const bool success = _load();
     #endif
     validating = false;
     return success;
   }
 
   bool MarlinSettings::load() {
     if (validate()) {
       const bool success = _load();
-      TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreRead(success));
+      TERN_(EXTENSIBLE_UI, ExtUI::onSettingsLoaded(success));
       return success;
     }
     reset();
     #if EITHER(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 

commit a80a303cbe057b02e8d9cd29bc94c161e48784f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 22:22:08 2022 -0500

    üßë‚Äçüíª EXTRUDER_LOOP macro

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 63bb93765b..1f482afeb4 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3131,23 +3131,23 @@ void MarlinSettings::reset() {
 
   endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
   reset_stepper_drivers();
 
   //
   // Linear Advance
   //
 
   #if ENABLED(LIN_ADVANCE)
-    LOOP_L_N(i, EXTRUDERS) {
-      planner.extruder_advance_K[i] = LIN_ADVANCE_K;
-      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[i] = LIN_ADVANCE_K);
+    EXTRUDER_LOOP() {
+      planner.extruder_advance_K[e] = LIN_ADVANCE_K;
+      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[e] = LIN_ADVANCE_K);
     }
   #endif
 
   //
   // Motor Current PWM
   //
 
   #if HAS_MOTOR_CURRENT_PWM
     constexpr uint32_t tmp_motor_current_setting[MOTOR_CURRENT_COUNT] = PWM_MOTOR_CURRENT;
     LOOP_L_N(q, MOTOR_CURRENT_COUNT)
@@ -3178,21 +3178,21 @@ void MarlinSettings::reset() {
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
       planner.skew_factor.xz = XZ_SKEW_FACTOR;
       planner.skew_factor.yz = YZ_SKEW_FACTOR;
     #endif
   #endif
 
   //
   // Advanced Pause filament load & unload lengths
   //
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    LOOP_L_N(e, EXTRUDERS) {
+    EXTRUDER_LOOP() {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
       fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
   #endif
 
   #if ENABLED(PASSWORD_FEATURE)
     #ifdef PASSWORD_DEFAULT_VALUE
       password.is_set = true;
       password.value = PASSWORD_DEFAULT_VALUE;
     #else

commit 9b2c06045d6c9a561c45e1e5c1f386268dfdca49
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Mar 18 16:17:41 2022 +1300

    ü©π Fix xatc EEPROM debug (#23911)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6eb17d5d2e..63bb93765b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -270,21 +270,23 @@ typedef struct SettingsDataStruct {
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
   #else
     float z_values[3][3];
   #endif
 
   //
   // X_AXIS_TWIST_COMPENSATION
   //
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-    XATC xatc;                                          // M423 X Z
+    float xatc_spacing;                                 // M423 X Z
+    float xatc_start;
+    xatc_array_t xatc_z_offset;
   #endif
 
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
   //
   // SERVO_ANGLES
@@ -893,21 +895,21 @@ void MarlinSettings::postprocess() {
       #else
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // X Axis Twist Compensation
     //
     #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-      _FIELD_TEST(xatc);
+      _FIELD_TEST(xatc_spacing);
       EEPROM_WRITE(xatc.spacing);
       EEPROM_WRITE(xatc.start);
       EEPROM_WRITE(xatc.z_offset);
     #endif
 
     //
     // Unified Bed Leveling
     //
     {
       _FIELD_TEST(planner_leveling_active);
@@ -1804,21 +1806,21 @@ void MarlinSettings::postprocess() {
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
       //
       // X Axis Twist Compensation
       //
       #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-        _FIELD_TEST(xatc);
+        _FIELD_TEST(xatc_spacing);
         EEPROM_READ(xatc.spacing);
         EEPROM_READ(xatc.start);
         EEPROM_READ(xatc.z_offset);
       #endif
 
       //
       // Unified Bed Leveling active state
       //
       {
         _FIELD_TEST(planner_leveling_active);

commit df4e022a48667369fcc94dfda56505eb3ba2019f
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Sat Mar 12 00:12:03 2022 +0100

    üö∏ Fix, extend X Axis Twist Compensation (#23745)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2b2e335565..6eb17d5d2e 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -270,21 +270,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
   #else
     float z_values[3][3];
   #endif
 
   //
   // X_AXIS_TWIST_COMPENSATION
   //
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-    XATC xatc;                                          // TBD
+    XATC xatc;                                          // M423 X Z
   #endif
 
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
   //
   // SERVO_ANGLES
@@ -894,21 +894,23 @@ void MarlinSettings::postprocess() {
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // X Axis Twist Compensation
     //
     #if ENABLED(X_AXIS_TWIST_COMPENSATION)
       _FIELD_TEST(xatc);
-      EEPROM_WRITE(xatc);
+      EEPROM_WRITE(xatc.spacing);
+      EEPROM_WRITE(xatc.start);
+      EEPROM_WRITE(xatc.z_offset);
     #endif
 
     //
     // Unified Bed Leveling
     //
     {
       _FIELD_TEST(planner_leveling_active);
       const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
       const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
       EEPROM_WRITE(ubl_active);
@@ -1802,21 +1804,24 @@ void MarlinSettings::postprocess() {
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
       //
       // X Axis Twist Compensation
       //
       #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-        EEPROM_READ(xatc);
+        _FIELD_TEST(xatc);
+        EEPROM_READ(xatc.spacing);
+        EEPROM_READ(xatc.start);
+        EEPROM_READ(xatc.z_offset);
       #endif
 
       //
       // Unified Bed Leveling active state
       //
       {
         _FIELD_TEST(planner_leveling_active);
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           const bool &planner_leveling_active = planner.leveling_active;
           const int8_t &ubl_storage_slot = ubl.storage_slot;
@@ -3330,28 +3335,27 @@ void MarlinSettings::reset() {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
-      // TODO: Create G-code for settings
-      //#if ENABLED(X_AXIS_TWIST_COMPENSATION)
-      //  CONFIG_ECHO_START();
-      //  xatc.print_points();
-      //#endif
-
     #endif // HAS_LEVELING
 
+    //
+    // X Axis Twist Compensation
+    //
+    TERN_(X_AXIS_TWIST_COMPENSATION, gcode.M423_report(forReplay));
+
     //
     // Editable Servo Angles
     //
     TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
     //
     // Kinematic Settings
     //
     TERN_(IS_KINEMATIC, gcode.M665_report(forReplay));
 

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    üö∏ Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index e0b2eccbbd..2b2e335565 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1460,30 +1460,32 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
     }
     #endif
 
     //
     // Creality DWIN User Data
     //
     #if ENABLED(DWIN_LCD_PROUI)
     {
+      _FIELD_TEST(dwin_data);
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_StoreSettings(dwin_data);
-      _FIELD_TEST(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
-    #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    #endif
+
+    #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
+      _FIELD_TEST(dwin_settings);
       char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
       CrealityDWIN.Save_Settings(dwin_settings);
-      _FIELD_TEST(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    üîß DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index cd71344389..e0b2eccbbd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -67,21 +67,21 @@
     #include "../feature/x_twist.h"
   #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "../lcd/e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
   #include "../feature/host_actions.h"
 #endif
 
 #if HAS_SERVOS
@@ -480,21 +480,21 @@ typedef struct SettingsDataStruct {
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // Ender-3 V2 DWIN
   //
-  #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #if ENABLED(DWIN_LCD_PROUI)
     uint8_t dwin_data[eeprom_data_size];
   #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
@@ -1458,21 +1458,21 @@ void MarlinSettings::postprocess() {
       char extui_data[ExtUI::eeprom_data_size] = { 0 };
       ExtUI::onStoreSettings(extui_data);
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
     }
     #endif
 
     //
     // Creality DWIN User Data
     //
-    #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+    #if ENABLED(DWIN_LCD_PROUI)
     {
       char dwin_data[eeprom_data_size] = { 0 };
       DWIN_StoreSettings(dwin_data);
       _FIELD_TEST(dwin_data);
       EEPROM_WRITE(dwin_data);
     }
     #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
       CrealityDWIN.Save_Settings(dwin_settings);
@@ -1603,21 +1603,21 @@ void MarlinSettings::postprocess() {
     char stored_ver[4];
     EEPROM_READ_ALWAYS(stored_ver);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
+      TERN_(DWIN_LCD_PROUI, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
       TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_VERSION)));
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
 
       // Optionally reset on the first boot after flashing
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
@@ -2401,21 +2401,21 @@ void MarlinSettings::postprocess() {
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
       }
       #endif
 
       //
       // Creality DWIN User Data
       //
-      #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+      #if ENABLED(DWIN_LCD_PROUI)
       {
         const char dwin_data[eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_data);
         EEPROM_READ(dwin_data);
         if (!validating) DWIN_LoadSettings(dwin_data);
       }
       #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
         const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
@@ -2505,21 +2505,21 @@ void MarlinSettings::postprocess() {
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_CRC));
+        TERN_(DWIN_LCD_PROUI, LCD_MESSAGE(MSG_ERR_EEPROM_CRC));
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
         TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
@@ -2823,21 +2823,21 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     LOOP_LINEAR_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
-  TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_SetDataDefaults());
+  TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //

commit 813b6af7247113d0cd96f4bf71c0c1a980590219
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 17:35:03 2022 -0600

    ü©π Fix 'hdsl' warning

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fed1f67755..cd71344389 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3196,23 +3196,25 @@ void MarlinSettings::reset() {
   //
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   postprocess();
 
-  FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
-  TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
-  DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
+  #if EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
+    FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
+    TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
+    DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
+  #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))

commit bb2f100fcdaef30958601ec90ebcaad0fcae8815
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 17:50:55 2022 -0600

    üö∏ Use Z_STEPPER_ALIGN_STEPPER_XY to enable

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2c103b89b4..fed1f67755 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -334,25 +334,25 @@ typedef struct SettingsDataStruct {
   //
   #if HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 (S2) Z
           z3_endstop_adj,                               // M666 (S3) Z
           z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
   //
-  // Z_STEPPER_AUTO_ALIGN, Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
+  // Z_STEPPER_AUTO_ALIGN, HAS_Z_STEPPER_ALIGN_STEPPER_XY
   //
   #if ENABLED(Z_STEPPER_AUTO_ALIGN)
     xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+    #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
       xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
     #endif
   #endif
 
   //
   // Material Presets
   //
   #if HAS_PREHEAT
     preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
   #endif
@@ -998,21 +998,21 @@ void MarlinSettings::postprocess() {
       #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
         EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
       #else
         EEPROM_WRITE(dummyf);
       #endif
     }
     #endif
 
     #if ENABLED(Z_STEPPER_AUTO_ALIGN)
       EEPROM_WRITE(z_stepper_align.xy);
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
         EEPROM_WRITE(z_stepper_align.stepper_xy);
       #endif
     #endif
 
     //
     // LCD Preheat settings
     //
     #if HAS_PREHEAT
       _FIELD_TEST(ui_material_preset);
       EEPROM_WRITE(ui.material_preset);
@@ -1917,21 +1917,21 @@ void MarlinSettings::postprocess() {
         #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
           EEPROM_READ(endstops.z4_endstop_adj); // 1 float
         #else
           EEPROM_READ(dummyf);
         #endif
       }
       #endif
 
       #if ENABLED(Z_STEPPER_AUTO_ALIGN)
         EEPROM_READ(z_stepper_align.xy);
-        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           EEPROM_READ(z_stepper_align.stepper_xy);
         #endif
       #endif
 
       //
       // LCD Preheat settings
       //
       #if HAS_PREHEAT
         _FIELD_TEST(ui_material_preset);
         EEPROM_READ(ui.material_preset);

commit 2e39bc30fd748b0ade7aafdab4827f942536cdcd
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Mar 2 22:13:46 2022 +0000

    üö∏ Universal X_AXIS_TWIST_COMPENSATION (#23828)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f512d87b99..2c103b89b4 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -57,21 +57,21 @@
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
   #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-    #include "../feature/bedlevel/abl/x_twist.h"
+    #include "../feature/x_twist.h"
   #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
@@ -262,27 +262,31 @@ typedef struct SettingsDataStruct {
   //
   matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
 
   //
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
-    #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-      XATC xatc;                                        // TBD
-    #endif
   #else
     float z_values[3][3];
   #endif
 
+  //
+  // X_AXIS_TWIST_COMPENSATION
+  //
+  #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+    XATC xatc;                                          // TBD
+  #endif
+
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
   //
   // SERVO_ANGLES
   //
   uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
@@ -291,21 +295,21 @@ typedef struct SettingsDataStruct {
   // Temperature first layer compensation values
   //
   #if HAS_PTC
     #if ENABLED(PTC_PROBE)
       int16_t z_offsets_probe[COUNT(ptc.z_offsets_probe)]; // M871 P I V
     #endif
     #if ENABLED(PTC_BED)
       int16_t z_offsets_bed[COUNT(ptc.z_offsets_bed)];     // M871 B I V
     #endif
     #if ENABLED(PTC_HOTEND)
-      int16_t z_offsets_hotend[COUNT(ptc.z_offsets_hotend)];     // M871 E I V
+      int16_t z_offsets_hotend[COUNT(ptc.z_offsets_hotend)]; // M871 E I V
     #endif
   #endif
 
   //
   // BLTOUCH
   //
   bool bltouch_od_5v_mode;
   #ifdef BLTOUCH_HS_MODE
     bool bltouch_high_speed_mode;                       // M401 S
   #endif
@@ -866,45 +870,47 @@ void MarlinSettings::postprocess() {
 
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
           sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
-        #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-          static_assert(COUNT(xatc.z_offset) == XATC_MAX_POINTS, "XATC Z-offset mesh is the wrong size.");
-        #endif
       #else
         const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       EEPROM_WRITE(bilinear_grid_spacing);
       EEPROM_WRITE(bilinear_start);
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         EEPROM_WRITE(z_values);              // 9-256 floats
-        #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-          EEPROM_WRITE(xatc);
-        #endif
       #else
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
+    //
+    // X Axis Twist Compensation
+    //
+    #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+      _FIELD_TEST(xatc);
+      EEPROM_WRITE(xatc);
+    #endif
+
     //
     // Unified Bed Leveling
     //
     {
       _FIELD_TEST(planner_leveling_active);
       const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
       const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
       EEPROM_WRITE(ubl_active);
       EEPROM_WRITE(storage_slot);
     }
@@ -1778,35 +1784,39 @@ void MarlinSettings::postprocess() {
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
             EEPROM_READ(bilinear_grid_spacing);        // 2 ints
             EEPROM_READ(bilinear_start);               // 2 ints
             EEPROM_READ(z_values);                     // 9 to 256 floats
-            #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-              EEPROM_READ(xatc);
-            #endif
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             xy_pos_t bgs, bs;
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
       }
 
+      //
+      // X Axis Twist Compensation
+      //
+      #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+        EEPROM_READ(xatc);
+      #endif
+
       //
       // Unified Bed Leveling active state
       //
       {
         _FIELD_TEST(planner_leveling_active);
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           const bool &planner_leveling_active = planner.leveling_active;
           const int8_t &ubl_storage_slot = ubl.storage_slot;
         #else
           bool planner_leveling_active;
@@ -2842,20 +2852,28 @@ void MarlinSettings::reset() {
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));
   TERN_(HAS_LEVELING, reset_bed_level());
 
+  //
+  // X Axis Twist Compensation
+  //
+  TERN_(X_AXIS_TWIST_COMPENSATION, xatc.reset());
+
+  //
+  // Nozzle-to-probe Offset
+  //
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == LINEAR_AXES, "NOZZLE_TO_PROBE_OFFSET must contain offsets for each linear axis X, Y, Z....");
     #if HAS_PROBE_XY_OFFSET
       LOOP_LINEAR_AXES(a) probe.offset[a] = dpo[a];
     #else
       probe.offset.set(LINEAR_AXIS_LIST(0, 0, dpo[Z_AXIS], 0, 0, 0));
     #endif
   #endif
 
@@ -3306,28 +3324,28 @@ void MarlinSettings::reset() {
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
-        // TODO: Create G-code for settings
-        //#if ENABLED(X_AXIS_TWIST_COMPENSATION)
-        //  CONFIG_ECHO_START();
-        //  xatc.print_points();
-        //#endif
-
       #endif
 
+      // TODO: Create G-code for settings
+      //#if ENABLED(X_AXIS_TWIST_COMPENSATION)
+      //  CONFIG_ECHO_START();
+      //  xatc.print_points();
+      //#endif
+
     #endif // HAS_LEVELING
 
     //
     // Editable Servo Angles
     //
     TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
     //
     // Kinematic Settings
     //

commit 6b7868d943cd08b83af085ea0d507cc8433799c6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Mar 1 22:14:52 2022 +0000

    üêõ Fix backlash applied steps when config changes (#23826)
    
    Followup to #23814

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 66316edbbb..f512d87b99 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1419,28 +1419,29 @@ void MarlinSettings::postprocess() {
     #if HAS_MULTI_EXTRUDER
       _FIELD_TEST(toolchange_settings);
       EEPROM_WRITE(toolchange_settings);
     #endif
 
     //
     // Backlash Compensation
     //
     {
       #if ENABLED(BACKLASH_GCODE)
-        const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
-        const uint8_t &backlash_correction = backlash.correction;
+        xyz_float_t backlash_distance_mm;
+        LOOP_LINEAR_AXES(axis) backlash_distance_mm[axis] = backlash.get_distance_mm((AxisEnum)axis);
+        const uint8_t backlash_correction = backlash.get_correction_uint8();
       #else
         const xyz_float_t backlash_distance_mm{0};
         const uint8_t backlash_correction = 0;
       #endif
       #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
-        const float &backlash_smoothing_mm = backlash.smoothing_mm;
+        const float backlash_smoothing_mm = backlash.get_smoothing_mm();
       #else
         const float backlash_smoothing_mm = 3;
       #endif
       _FIELD_TEST(backlash_distance_mm);
       EEPROM_WRITE(backlash_distance_mm);
       EEPROM_WRITE(backlash_correction);
       EEPROM_WRITE(backlash_smoothing_mm);
     }
 
     //
@@ -2357,36 +2358,36 @@ void MarlinSettings::postprocess() {
       //
       #if HAS_MULTI_EXTRUDER
         _FIELD_TEST(toolchange_settings);
         EEPROM_READ(toolchange_settings);
       #endif
 
       //
       // Backlash Compensation
       //
       {
-        #if ENABLED(BACKLASH_GCODE)
-          const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
-          const uint8_t &backlash_correction = backlash.correction;
-        #else
-          xyz_float_t backlash_distance_mm;
-          uint8_t backlash_correction;
-        #endif
-        #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
-          const float &backlash_smoothing_mm = backlash.smoothing_mm;
-        #else
-          float backlash_smoothing_mm;
-        #endif
+        xyz_float_t backlash_distance_mm;
+        uint8_t backlash_correction;
+        float backlash_smoothing_mm;
+
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
+
+        #if ENABLED(BACKLASH_GCODE)
+          LOOP_LINEAR_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, backlash_distance_mm[axis]);
+          backlash.set_correction_uint8(backlash_correction);
+          #ifdef BACKLASH_SMOOTHING_MM
+            backlash.set_smoothing_mm(backlash_smoothing_mm);
+          #endif
+        #endif
       }
 
       //
       // Extensible UI User Data
       //
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
@@ -2804,25 +2805,25 @@ void MarlinSettings::reset() {
 
     toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
 
     #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
       migration = migration_defaults;
     #endif
 
   #endif
 
   #if ENABLED(BACKLASH_GCODE)
-    backlash.correction = (BACKLASH_CORRECTION) * 255;
+    backlash.set_correction(BACKLASH_CORRECTION);
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
-    backlash.distance_mm = tmp;
+    LOOP_LINEAR_AXES(axis) backlash.set_distance_mm((AxisEnum)axis, tmp[axis]);
     #ifdef BACKLASH_SMOOTHING_MM
-      backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
+      backlash.set_smoothing_mm(BACKLASH_SMOOTHING_MM);
     #endif
   #endif
 
   TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);

commit 0e7be8e8c4b1a7ca351ce19b462cac2d27fab82d
Author: M. FURIC Franck <francknos@gmail.com>
Date:   Sat Feb 26 23:54:04 2022 +0100

    ‚ú® LCD Backlight Timer (#23768)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index bcbe8fa985..66316edbbb 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -384,20 +384,27 @@ typedef struct SettingsDataStruct {
   //
   // HAS_LCD_CONTRAST
   //
   uint8_t lcd_contrast;                                 // M250 C
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
+  //
+  // LCD_BACKLIGHT_TIMEOUT
+  //
+  #if LCD_BACKLIGHT_TIMEOUT
+    uint16_t lcd_backlight_timeout;                     // (G-code needed)
+  #endif
+
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
   // POWER_LOSS_RECOVERY
   //
   bool recovery_enabled;                                // M413 S
 
@@ -600,20 +607,24 @@ void MarlinSettings::postprocess() {
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 
   // Moved as last update due to interference with Neopixel init
   TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
   TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
+
+  #if LCD_BACKLIGHT_TIMEOUT
+    ui.refresh_backlight_timeout();
+  #endif
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
   );
 #endif
@@ -1101,20 +1112,27 @@ void MarlinSettings::postprocess() {
 
     //
     // LCD Brightness
     //
     {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
     }
 
+    //
+    // LCD Backlight Timeout
+    //
+    #if LCD_BACKLIGHT_TIMEOUT
+      EEPROM_WRITE(ui.lcd_backlight_timeout);
+    #endif
+
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
         const controllerFan_settings_t &cfs = controllerFan.settings;
       #else
         controllerFan_settings_t cfs = controllerFan_defaults;
       #endif
@@ -2008,20 +2026,27 @@ void MarlinSettings::postprocess() {
       //
       // LCD Brightness
       //
       {
         uint8_t lcd_brightness;
         _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
+      //
+      // LCD Backlight Timeout
+      //
+      #if LCD_BACKLIGHT_TIMEOUT
+        EEPROM_READ(ui.lcd_backlight_timeout);
+      #endif
+
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
         EEPROM_READ(cfs);
         TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
       }
 
@@ -3033,20 +3058,27 @@ void MarlinSettings::reset() {
   //
   // LCD Contrast
   //
   TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
   TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
+  //
+  // LCD Backlight Timeout
+  //
+  #if LCD_BACKLIGHT_TIMEOUT
+    ui.lcd_backlight_timeout = LCD_BACKLIGHT_TIMEOUT;
+  #endif
+
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
   TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
 

commit 98a17cd60dc51f1b22b88101b526fd7f1b3f8787
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 15 15:09:09 2022 -0600

    ‚ôªÔ∏è Rename XATC z_values => z_offset

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8c2cd8813d..bcbe8fa985 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -856,24 +856,21 @@ void MarlinSettings::postprocess() {
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
           sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
         #if ENABLED(X_AXIS_TWIST_COMPENSATION)
-          static_assert(
-            sizeof(xatc.z_values) == (XATC_MAX_POINTS) * sizeof(xatc.z_values[0]),
-            "Z-offset mesh is the wrong size."
-          );
+          static_assert(COUNT(xatc.z_offset) == XATC_MAX_POINTS, "XATC Z-offset mesh is the wrong size.");
         #endif
       #else
         const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       EEPROM_WRITE(bilinear_grid_spacing);

commit 7763f9385d506ef79ef81ccb48a972ab56050fb1
Author: Taylor Talkington <taylor.talkington@gmail.com>
Date:   Tue Feb 8 18:36:06 2022 -0500

    ‚ú® Optional HOST_STATUS_NOTIFICATIONS (#22833)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7af91568bf..8c2cd8813d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -73,20 +73,24 @@
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../feature/host_actions.h"
+#endif
+
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if HAS_SERVOS && HAS_SERVO_ANGLES
   #define EEPROM_NUM_SERVOS NUM_SERVOS
 #else
   #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
 #endif
 
@@ -645,20 +649,24 @@ void MarlinSettings::postprocess() {
                 "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
 //
 // This file simply uses the DEBUG_ECHO macros to implement EEPROM_CHITCHAT.
 // For deeper debugging of EEPROM issues enable DEBUG_EEPROM_READWRITE.
 //
 #define DEBUG_OUT EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
+#if BOTH(EEPROM_CHITCHAT, HOST_PROMPT_SUPPORT)
+  #define HOST_EEPROM_CHITCHAT 1
+#endif
+
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
@@ -1547,21 +1555,24 @@ void MarlinSettings::postprocess() {
     EEPROM_FINISH();
 
     //
     // UBL Mesh
     //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
     #endif
 
-    if (!eeprom_error) LCD_MESSAGE(MSG_SETTINGS_STORED);
+    if (!eeprom_error) {
+      LCD_MESSAGE(MSG_SETTINGS_STORED);
+      TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_SETTINGS_STORED)));
+    }
 
     TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
 
     return !eeprom_error;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
   bool MarlinSettings::_load() {
@@ -1571,20 +1582,21 @@ void MarlinSettings::postprocess() {
     EEPROM_READ_ALWAYS(stored_ver);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
+      TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_VERSION)));
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
 
       // Optionally reset on the first boot after flashing
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
         EEPROM_READ_ALWAYS(stored_hash);
@@ -2461,26 +2473,28 @@ void MarlinSettings::postprocess() {
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_CRC));
+        TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(GET_TEXT_F(MSG_ERR_EEPROM_CRC)));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
+        TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(F("Stored settings retrieved")));
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           ubl.report_state();
 
           if (!ubl.sanity_check()) {
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
@@ -2776,21 +2790,20 @@ void MarlinSettings::reset() {
 
   #if ENABLED(BACKLASH_GCODE)
     backlash.correction = (BACKLASH_CORRECTION) * 255;
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     backlash.distance_mm = tmp;
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
-  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
   TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
@@ -3135,21 +3148,25 @@ void MarlinSettings::reset() {
   //
   TERN_(HAS_FANCHECK, fan_check.enabled = true);
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   postprocess();
 
-  DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
+  FSTR_P const hdsl = F("Hardcoded Default Settings Loaded");
+  TERN_(HOST_EEPROM_CHITCHAT, hostui.notify(hdsl));
+  DEBUG_ECHO_START(); DEBUG_ECHOLNF(hdsl);
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    üö∏ Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ab498b7df3..7af91568bf 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -68,21 +68,21 @@
   #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
-  #include "../lcd/e3v2/enhanced/dwin.h"
+  #include "../lcd/e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if HAS_SERVOS && HAS_SERVO_ANGLES
   #define EEPROM_NUM_SERVOS NUM_SERVOS
@@ -3021,21 +3021,21 @@ void MarlinSettings::reset() {
   TERN_(POWER_MONITOR, power_monitor.reset());
 
   //
   // LCD Contrast
   //
   TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
-  TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = DEFAULT_LCD_BRIGHTNESS);
+  TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = LCD_BRIGHTNESS_DEFAULT);
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
   TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));

commit 5439a34c4b5e5f87bdd4aebeebee3d80a776cb56
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Sat Feb 5 01:44:21 2022 +0100

    ü©π Init brightness/contrast later (#23645)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b737d41c2d..ab498b7df3 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -571,23 +571,20 @@ void MarlinSettings::postprocess() {
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
 
   // Software endstops depend on home_offset
   LOOP_LINEAR_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
-  TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
-  TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
-
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
@@ -595,20 +592,24 @@ void MarlinSettings::postprocess() {
 
   TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
 
   // Refresh mm_per_step with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
+
+  // Moved as last update due to interference with Neopixel init
+  TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
+  TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"
   static_assert(
     !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
     !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
     "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
   );
 #endif

commit f6e8622360609d95464d256be5717db090191583
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Jan 22 10:16:41 2022 -0600

    üêõ Fix LCD contrast/brightness init (#23567)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 90bb9f6d6e..b737d41c2d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -571,20 +571,23 @@ void MarlinSettings::postprocess() {
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
 
   // Software endstops depend on home_offset
   LOOP_LINEAR_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
+  TERN_(HAS_LCD_CONTRAST, ui.refresh_contrast());
+  TERN_(HAS_LCD_BRIGHTNESS, ui.refresh_brightness());
+
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
@@ -1979,33 +1982,34 @@ void MarlinSettings::postprocess() {
         uint8_t power_monitor_flags;
         _FIELD_TEST(power_monitor_flags);
         EEPROM_READ(power_monitor_flags);
         TERN_(HAS_POWER_MONITOR, if (!validating) power_monitor.flags = power_monitor_flags);
       }
 
       //
       // LCD Contrast
       //
       {
-        _FIELD_TEST(lcd_contrast);
         uint8_t lcd_contrast;
+        _FIELD_TEST(lcd_contrast);
         EEPROM_READ(lcd_contrast);
-        TERN_(HAS_LCD_CONTRAST, if (!validating) ui.set_contrast(lcd_contrast));
+        TERN_(HAS_LCD_CONTRAST, if (!validating) ui.contrast = lcd_contrast);
       }
 
       //
       // LCD Brightness
       //
       {
         uint8_t lcd_brightness;
+        _FIELD_TEST(lcd_brightness);
         EEPROM_READ(lcd_brightness);
-        TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.set_brightness(lcd_brightness));
+        TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.brightness = lcd_brightness);
       }
 
       //
       // Controller Fan
       //
       {
         controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
         EEPROM_READ(cfs);
         TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
@@ -3011,26 +3015,26 @@ void MarlinSettings::reset() {
   TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
   //
   // Power Monitor
   //
   TERN_(POWER_MONITOR, power_monitor.reset());
 
   //
   // LCD Contrast
   //
-  TERN_(HAS_LCD_CONTRAST, ui.set_contrast(DEFAULT_LCD_CONTRAST));
+  TERN_(HAS_LCD_CONTRAST, ui.contrast = LCD_CONTRAST_DEFAULT);
 
   //
   // LCD Brightness
   //
-  TERN_(HAS_LCD_BRIGHTNESS, ui.set_brightness(DEFAULT_LCD_BRIGHTNESS));
+  TERN_(HAS_LCD_BRIGHTNESS, ui.brightness = DEFAULT_LCD_BRIGHTNESS);
 
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
   TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));

commit d5f2334140e6f8ead29d3648b371547ebe72c7aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 22 10:14:47 2022 -0600

    ‚ôªÔ∏è Adjust LCD init, contrast default, settings load

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index baab8b6dec..90bb9f6d6e 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1958,101 +1958,91 @@ void MarlinSettings::postprocess() {
             thermalManager.temp_chamber.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
       //
       // User-defined Thermistors
       //
       #if HAS_USER_THERMISTORS
       {
+        user_thermistor_t user_thermistor[USER_THERMISTORS];
         _FIELD_TEST(user_thermistor);
-        EEPROM_READ(thermalManager.user_thermistor);
+        EEPROM_READ(user_thermistor);
+        if (!validating) COPY(thermalManager.user_thermistor, user_thermistor);
       }
       #endif
 
       //
       // Power monitor
       //
       {
-        #if HAS_POWER_MONITOR
-          uint8_t &power_monitor_flags = power_monitor.flags;
-        #else
-          uint8_t power_monitor_flags;
-        #endif
+        uint8_t power_monitor_flags;
         _FIELD_TEST(power_monitor_flags);
         EEPROM_READ(power_monitor_flags);
+        TERN_(HAS_POWER_MONITOR, if (!validating) power_monitor.flags = power_monitor_flags);
       }
 
       //
       // LCD Contrast
       //
       {
         _FIELD_TEST(lcd_contrast);
         uint8_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
         TERN_(HAS_LCD_CONTRAST, if (!validating) ui.set_contrast(lcd_contrast));
       }
 
       //
       // LCD Brightness
       //
       {
-        _FIELD_TEST(lcd_brightness);
         uint8_t lcd_brightness;
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.set_brightness(lcd_brightness));
       }
 
       //
       // Controller Fan
       //
       {
+        controllerFan_settings_t cfs = { 0 };
         _FIELD_TEST(controllerFan_settings);
-        #if ENABLED(CONTROLLER_FAN_EDITABLE)
-          const controllerFan_settings_t &cfs = controllerFan.settings;
-        #else
-          controllerFan_settings_t cfs = { 0 };
-        #endif
         EEPROM_READ(cfs);
+        TERN_(CONTROLLER_FAN_EDITABLE, if (!validating) controllerFan.settings = cfs);
       }
 
       //
       // Power-Loss Recovery
       //
       {
+        bool recovery_enabled;
         _FIELD_TEST(recovery_enabled);
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          const bool &recovery_enabled = recovery.enabled;
-        #else
-          bool recovery_enabled;
-        #endif
         EEPROM_READ(recovery_enabled);
+        TERN_(POWER_LOSS_RECOVERY, if (!validating) recovery.enabled = recovery_enabled);
       }
 
       //
       // Firmware Retraction
       //
       {
+        fwretract_settings_t fwretract_settings;
+        bool autoretract_enabled;
         _FIELD_TEST(fwretract_settings);
+        EEPROM_READ(fwretract_settings);
+        EEPROM_READ(autoretract_enabled);
 
         #if ENABLED(FWRETRACT)
-          EEPROM_READ(fwretract.settings);
-        #else
-          fwretract_settings_t fwretract_settings;
-          EEPROM_READ(fwretract_settings);
-        #endif
-        #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
-          EEPROM_READ(fwretract.autoretract_enabled);
-        #else
-          bool autoretract_enabled;
-          EEPROM_READ(autoretract_enabled);
+          if (!validating) {
+            fwretract.settings = fwretract_settings;
+            TERN_(FWRETRACT_AUTORETRACT, fwretract.autoretract_enabled = autoretract_enabled);
+          }
         #endif
       }
 
       //
       // Volumetric & Filament Size
       //
       {
         struct {
           bool volumetric_enabled;
           float filament_size[EXTRUDERS];

commit fd595aa01bcd139352055f4dca771c193aa35d14
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 19 02:20:32 2022 -0600

    üé® Misc. style and cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 750aab74fd..baab8b6dec 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1983,23 +1983,21 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(power_monitor_flags);
       }
 
       //
       // LCD Contrast
       //
       {
         _FIELD_TEST(lcd_contrast);
         uint8_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
-        if (!validating) {
-          TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
-        }
+        TERN_(HAS_LCD_CONTRAST, if (!validating) ui.set_contrast(lcd_contrast));
       }
 
       //
       // LCD Brightness
       //
       {
         _FIELD_TEST(lcd_brightness);
         uint8_t lcd_brightness;
         EEPROM_READ(lcd_brightness);
         TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.set_brightness(lcd_brightness));

commit e0d19f9f419bd6150324672872a2314e98ee5e6b
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 9 02:29:36 2022 -0500

    üêõ Fix EEPROM_INIT_NOW build hash test (#23479)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a152575454..750aab74fd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1577,21 +1577,21 @@ void MarlinSettings::postprocess() {
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
 
       // Optionally reset on the first boot after flashing
       #if ENABLED(EEPROM_INIT_NOW)
         uint32_t stored_hash;
         EEPROM_READ_ALWAYS(stored_hash);
-        if (stored_hash != build_hash) { EEPROM_FINISH(); return true; }
+        if (stored_hash != build_hash) { EEPROM_FINISH(); return false; }
       #endif
 
       uint16_t stored_crc;
       EEPROM_READ_ALWAYS(stored_crc);
 
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(e_factors);
 

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 5fda608e38..a152575454 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2705,27 +2705,27 @@ void MarlinSettings::reset() {
   #if HAS_CLASSIC_JERK
     #ifndef DEFAULT_XJERK
       #define DEFAULT_XJERK 0
     #endif
     #if HAS_Y_AXIS && !defined(DEFAULT_YJERK)
       #define DEFAULT_YJERK 0
     #endif
     #if HAS_Z_AXIS && !defined(DEFAULT_ZJERK)
       #define DEFAULT_ZJERK 0
     #endif
-    #if LINEAR_AXES >= 4 && !defined(DEFAULT_IJERK)
+    #if HAS_I_AXIS && !defined(DEFAULT_IJERK)
       #define DEFAULT_IJERK 0
     #endif
-    #if LINEAR_AXES >= 5 && !defined(DEFAULT_JJERK)
+    #if HAS_J_AXIS && !defined(DEFAULT_JJERK)
       #define DEFAULT_JJERK 0
     #endif
-    #if LINEAR_AXES >= 6 && !defined(DEFAULT_KJERK)
+    #if HAS_K_AXIS && !defined(DEFAULT_KJERK)
       #define DEFAULT_KJERK 0
     #endif
     planner.max_jerk.set(
       LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_IJERK, DEFAULT_JJERK, DEFAULT_KJERK)
     );
     TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK);
   #endif
 
   TERN_(HAS_JUNCTION_DEVIATION, planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM));
 

commit 1b876c170fc62abbb7381cfa79f2456ab4ec48ac
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu Dec 23 07:49:15 2021 +0100

    ü©π Fix settings G21 report (#23338)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8a32d4c57e..5fda608e38 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3164,26 +3164,27 @@ void MarlinSettings::reset() {
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
     //
     // Announce current units, in case inches are being displayed
     //
     CONFIG_ECHO_HEADING("Linear Units");
+    CONFIG_ECHO_START();
     #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHO_MSG("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
+      SERIAL_ECHOPGM("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
     #else
-      SERIAL_ECHO_MSG("  G21 ;");
+      SERIAL_ECHOPGM("  G21 ;");
     #endif
-    gcode.say_units();
+    gcode.say_units(); // " (in/mm)"
 
     //
     // M149 Temperature units
     //
     #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
       gcode.M149_report(forReplay);
     #else
       CONFIG_ECHO_HEADING(STR_TEMPERATURE_UNITS);
       CONFIG_ECHO_MSG("  M149 C ; Units in Celsius");
     #endif

commit 2893048e2955963bb307a4ca67ec26bb336de2f5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 21 23:09:55 2021 -0500

    ‚ú® BLTouch High Speed mode runtime configuration (#22916)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a9c771240c..8a32d4c57e 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -294,21 +294,24 @@ typedef struct SettingsDataStruct {
       int16_t z_offsets_bed[COUNT(ptc.z_offsets_bed)];     // M871 B I V
     #endif
     #if ENABLED(PTC_HOTEND)
       int16_t z_offsets_hotend[COUNT(ptc.z_offsets_hotend)];     // M871 E I V
     #endif
   #endif
 
   //
   // BLTOUCH
   //
-  bool bltouch_last_written_mode;
+  bool bltouch_od_5v_mode;
+  #ifdef BLTOUCH_HS_MODE
+    bool bltouch_high_speed_mode;                       // M401 S
+  #endif
 
   //
   // Kinematic Settings
   //
   #if IS_KINEMATIC
     float segments_per_second;                          // M665 S
     #if ENABLED(DELTA)
       float delta_height;                               // M666 H
       abc_float_t delta_endstop_adj;                    // M666 X Y Z
       float delta_radius,                               // M665 R
@@ -911,23 +914,29 @@ void MarlinSettings::postprocess() {
         EEPROM_WRITE(ptc.z_offsets_hotend);
       #endif
     #else
       // No placeholder data for this feature
     #endif
 
     //
     // BLTOUCH
     //
     {
-      _FIELD_TEST(bltouch_last_written_mode);
-      const bool bltouch_last_written_mode = TERN(BLTOUCH, bltouch.last_written_mode, false);
-      EEPROM_WRITE(bltouch_last_written_mode);
+      _FIELD_TEST(bltouch_od_5v_mode);
+      const bool bltouch_od_5v_mode = TERN0(BLTOUCH, bltouch.od_5v_mode);
+      EEPROM_WRITE(bltouch_od_5v_mode);
+
+      #ifdef BLTOUCH_HS_MODE
+        _FIELD_TEST(bltouch_high_speed_mode);
+        const bool bltouch_high_speed_mode = TERN0(BLTOUCH, bltouch.high_speed_mode);
+        EEPROM_WRITE(bltouch_high_speed_mode);
+      #endif
     }
 
     //
     // Kinematic Settings
     //
     #if IS_KINEMATIC
     {
       EEPROM_WRITE(segments_per_second);
       #if ENABLED(DELTA)
         _FIELD_TEST(delta_height);
@@ -1803,27 +1812,37 @@ void MarlinSettings::postprocess() {
         #endif
         ptc.reset_index();
       #else
         // No placeholder data for this feature
       #endif
 
       //
       // BLTOUCH
       //
       {
-        _FIELD_TEST(bltouch_last_written_mode);
+        _FIELD_TEST(bltouch_od_5v_mode);
         #if ENABLED(BLTOUCH)
-          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
+          const bool &bltouch_od_5v_mode = bltouch.od_5v_mode;
         #else
-          bool bltouch_last_written_mode;
+          bool bltouch_od_5v_mode;
+        #endif
+        EEPROM_READ(bltouch_od_5v_mode);
+
+        #ifdef BLTOUCH_HS_MODE
+          _FIELD_TEST(bltouch_high_speed_mode);
+          #if ENABLED(BLTOUCH)
+            const bool &bltouch_high_speed_mode = bltouch.high_speed_mode;
+          #else
+            bool bltouch_high_speed_mode;
+          #endif
+          EEPROM_READ(bltouch_high_speed_mode);
         #endif
-        EEPROM_READ(bltouch_last_written_mode);
       }
 
       //
       // Kinematic Segments-per-second
       //
       #if IS_KINEMATIC
       {
         EEPROM_READ(segments_per_second);
         #if ENABLED(DELTA)
           _FIELD_TEST(delta_height);
@@ -2820,25 +2839,25 @@ void MarlinSettings::reset() {
   // Servo Angles
   //
   TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
 
   //
   // Probe Temperature Compensation
   //
   TERN_(HAS_PTC, ptc.reset());
 
   //
-  // BLTOUCH
+  // BLTouch
   //
-  //#if ENABLED(BLTOUCH)
-  //  bltouch.last_written_mode;
-  //#endif
+  #ifdef BLTOUCH_HS_MODE
+    bltouch.high_speed_mode = ENABLED(BLTOUCH_HS_MODE);
+  #endif
 
   //
   // Kinematic settings
   //
 
   #if IS_KINEMATIC
     segments_per_second = (
       TERN_(DELTA, DELTA_SEGMENTS_PER_SECOND)
       TERN_(IS_SCARA, SCARA_SEGMENTS_PER_SECOND)
       TERN_(POLARGRAPH, POLAR_SEGMENTS_PER_SECOND)

commit c1dba3d02888824400413fdf366c1fa574cbb587
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Dec 22 15:44:04 2021 +1300

    ‚ú® Option to reset EEPROM on first run (#23276)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8ccf773adc..a9c771240c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V85"
+#define EEPROM_VERSION "V86"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -191,34 +191,46 @@ static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 /**
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
+  #if ENABLED(EEPROM_INIT_NOW)
+    uint32_t build_hash;                                // Unique build hash
+  #endif
   uint16_t  crc;                                        // Data Checksum
 
   //
   // DISTINCT_E_FACTORS
   //
-  uint8_t   esteppers;                                  // DISTINCT_AXES - LINEAR_AXES
+  uint8_t e_factors;                                    // DISTINCT_AXES - LINEAR_AXES
 
+  //
+  // Planner settings
+  //
   planner_settings_t planner_settings;
 
   xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
   float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
+  //
+  // Home Offset
+  //
   xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
 
+  //
+  // Hotend Offset
+  //
   #if HAS_HOTEND_OFFSET
     xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
   #endif
 
   //
   // FILAMENT_RUNOUT_SENSOR
   //
   bool runout_sensor_enabled;                           // M412 S
   float runout_distance_mm;                             // M412 D
 
@@ -642,53 +654,68 @@ void MarlinSettings::postprocess() {
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else
     #define _FIELD_TEST(FIELD) NOOP
   #endif
 
   const char version[4] = EEPROM_VERSION;
 
+  #if ENABLED(EEPROM_INIT_NOW)
+    constexpr uint32_t strhash32(const char *s, const uint32_t h=0) {
+      return *s ? strhash32(s + 1, ((h + *s) << (*s & 3)) ^ *s) : h;
+    }
+    constexpr uint32_t build_hash = strhash32(__DATE__ __TIME__);
+  #endif
+
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
   int MarlinSettings::eeprom_index;
   uint16_t MarlinSettings::working_crc;
 
   bool MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
-      DEBUG_ERROR_MSG("EEPROM datasize error.");
+      DEBUG_ERROR_MSG("EEPROM datasize error."
+        #if ENABLED(MARLIN_DEV_MODE)
+          " (Actual:", size, " Expected:", datasize(), ")"
+        #endif
+      );
       return true;
     }
     return false;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
     char ver[4] = "ERR";
 
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     eeprom_error = false;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
     TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
-    EEPROM_SKIP(working_crc); // Skip the checksum slot
+    #if ENABLED(EEPROM_INIT_NOW)
+      EEPROM_SKIP(build_hash);  // Skip the hash slot
+    #endif
+
+    EEPROM_SKIP(working_crc);   // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"
 
-    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - LINEAR_AXES;
-    _FIELD_TEST(esteppers);
-    EEPROM_WRITE(esteppers);
+    const uint8_t e_factors = DISTINCT_AXES - (LINEAR_AXES);
+    _FIELD_TEST(e_factors);
+    EEPROM_WRITE(e_factors);
 
     //
     // Planner Motion
     //
     {
       EEPROM_WRITE(planner.settings);
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
@@ -1487,20 +1514,23 @@ void MarlinSettings::postprocess() {
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
       EEPROM_WRITE(version);
+      #if ENABLED(EEPROM_INIT_NOW)
+        EEPROM_WRITE(build_hash);
+      #endif
       EEPROM_WRITE(final_crc);
 
       // Report storage size
       DEBUG_ECHO_MSG("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
     EEPROM_FINISH();
 
     //
@@ -1520,61 +1550,69 @@ void MarlinSettings::postprocess() {
 
   /**
    * M501 - Retrieve Configuration
    */
   bool MarlinSettings::_load() {
     if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     char stored_ver[4];
     EEPROM_READ_ALWAYS(stored_ver);
 
-    uint16_t stored_crc;
-    EEPROM_READ_ALWAYS(stored_crc);
-
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
+
+      // Optionally reset on the first boot after flashing
+      #if ENABLED(EEPROM_INIT_NOW)
+        uint32_t stored_hash;
+        EEPROM_READ_ALWAYS(stored_hash);
+        if (stored_hash != build_hash) { EEPROM_FINISH(); return true; }
+      #endif
+
+      uint16_t stored_crc;
+      EEPROM_READ_ALWAYS(stored_crc);
+
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
-      _FIELD_TEST(esteppers);
+      _FIELD_TEST(e_factors);
 
-      // Number of esteppers may change
-      uint8_t esteppers;
-      EEPROM_READ_ALWAYS(esteppers);
+      // Number of e_factors may change
+      uint8_t e_factors;
+      EEPROM_READ_ALWAYS(e_factors);
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
-        uint32_t tmp1[LINEAR_AXES + esteppers];
-        float tmp2[LINEAR_AXES + esteppers];
-        feedRate_t tmp3[LINEAR_AXES + esteppers];
+        uint32_t tmp1[LINEAR_AXES + e_factors];
+        float tmp2[LINEAR_AXES + e_factors];
+        feedRate_t tmp3[LINEAR_AXES + e_factors];
         EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
         EEPROM_READ(planner.settings.min_segment_time_us);
         EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
         EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
         if (!validating) LOOP_DISTINCT_AXES(i) {
-          const bool in = (i < esteppers + LINEAR_AXES);
+          const bool in = (i < e_factors + LINEAR_AXES);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
           planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
@@ -2489,21 +2527,21 @@ void MarlinSettings::postprocess() {
     return success;
   }
 
   bool MarlinSettings::load() {
     if (validate()) {
       const bool success = _load();
       TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreRead(success));
       return success;
     }
     reset();
-    #if ENABLED(EEPROM_AUTO_INIT)
+    #if EITHER(EEPROM_AUTO_INIT, EEPROM_INIT_NOW)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
       DEBUG_ECHOLNPGM("?Invalid slot.\n", s, " mesh slots available.");

commit a16a059312b0ddb822da2769b5ba5372f9857c48
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Tue Dec 7 02:53:51 2021 +0100

    ‚ú® X Twist Compensation & Calibration (#23238)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4057d339dc..8ccf773adc 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -56,20 +56,23 @@
 #include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
+  #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+    #include "../feature/bedlevel/abl/x_twist.h"
+  #endif
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "../lcd/e3v2/enhanced/dwin.h"
@@ -243,20 +246,23 @@ typedef struct SettingsDataStruct {
   //
   matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
 
   //
   // AUTO_BED_LEVELING_BILINEAR
   //
   uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
   xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
     bed_mesh_t z_values;                                // G29
+    #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+      XATC xatc;                                        // TBD
+    #endif
   #else
     float z_values[3][3];
   #endif
 
   //
   // AUTO_BED_LEVELING_UBL
   //
   bool planner_leveling_active;                         // M420 S  planner.leveling_active
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
@@ -807,33 +813,42 @@ void MarlinSettings::postprocess() {
 
     //
     // Bilinear Auto Bed Leveling
     //
     {
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         static_assert(
           sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
           "Bilinear Z array is the wrong size."
         );
+        #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+          static_assert(
+            sizeof(xatc.z_values) == (XATC_MAX_POINTS) * sizeof(xatc.z_values[0]),
+            "Z-offset mesh is the wrong size."
+          );
+        #endif
       #else
         const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
       #endif
 
       const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
                     grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
       EEPROM_WRITE(grid_max_x);
       EEPROM_WRITE(grid_max_y);
       EEPROM_WRITE(bilinear_grid_spacing);
       EEPROM_WRITE(bilinear_start);
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         EEPROM_WRITE(z_values);              // 9-256 floats
+        #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+          EEPROM_WRITE(xatc);
+        #endif
       #else
         dummyf = 0;
         for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Unified Bed Leveling
     //
     {
@@ -1684,20 +1699,23 @@ void MarlinSettings::postprocess() {
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
             EEPROM_READ(bilinear_grid_spacing);        // 2 ints
             EEPROM_READ(bilinear_start);               // 2 ints
             EEPROM_READ(z_values);                     // 9 to 256 floats
+            #if ENABLED(X_AXIS_TWIST_COMPENSATION)
+              EEPROM_READ(xatc);
+            #endif
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             xy_pos_t bgs, bs;
             EEPROM_READ(bgs);
             EEPROM_READ(bs);
             for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
           }
@@ -3190,20 +3208,26 @@ void MarlinSettings::reset() {
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPGM("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
+        // TODO: Create G-code for settings
+        //#if ENABLED(X_AXIS_TWIST_COMPENSATION)
+        //  CONFIG_ECHO_START();
+        //  xatc.print_points();
+        //#endif
+
       #endif
 
     #endif // HAS_LEVELING
 
     //
     // Editable Servo Angles
     //
     TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
     //

commit 7110d11c9d8933c8c412c2fabd3b065a5ab97b6e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 23 21:01:53 2021 +0100

    ‚ú® Fan tachometer support (#23086)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0cb29f29e0..4057d339dc 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -147,20 +147,24 @@
 #endif
 
 #if HAS_ETHERNET
   #include "../feature/ethernet.h"
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   #include "../libs/buzzer.h"
 #endif
 
+#if HAS_FANCHECK
+  #include "../feature/fancheck.h"
+#endif
+
 #if ENABLED(DGUS_LCD_UI_MKS)
   #include "../lcd/extui/dgus/DGUSScreenHandler.h"
   #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
@@ -484,20 +488,27 @@ typedef struct SettingsDataStruct {
              ethernet_subnet;                           // M554 P
   #endif
 
   //
   // Buzzer enable/disable
   //
   #if ENABLED(SOUND_MENU_ITEM)
     bool buzzer_enabled;
   #endif
 
+  //
+  // Fan tachometer check
+  //
+  #if HAS_FANCHECK
+    bool fan_check_enabled;
+  #endif
+
   //
   // MKS UI controller
   //
   #if ENABLED(DGUS_LCD_UI_MKS)
     uint8_t mks_language_index;                         // Display Language
     xy_int_t mks_corner_offsets[5];                     // Bed Tramming
     xyz_int_t mks_park_pos;                             // Custom Parking (without NOZZLE_PARK)
     celsius_t mks_min_extrusion_temp;                   // Min E Temp (shadow M302 value)
   #endif
 
@@ -1426,20 +1437,27 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
     //
     // Buzzer enable/disable
     //
     #if ENABLED(SOUND_MENU_ITEM)
       EEPROM_WRITE(ui.buzzer_enabled);
     #endif
 
+    //
+    // Fan tachometer check
+    //
+    #if HAS_FANCHECK
+      EEPROM_WRITE(fan_check.enabled);
+    #endif
+
     //
     // MKS UI controller
     //
     #if ENABLED(DGUS_LCD_UI_MKS)
       EEPROM_WRITE(mks_language_index);
       EEPROM_WRITE(mks_corner_offsets);
       EEPROM_WRITE(mks_park_pos);
       EEPROM_WRITE(mks_min_extrusion_temp);
     #endif
 
@@ -2332,20 +2350,28 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Buzzer enable/disable
       //
       #if ENABLED(SOUND_MENU_ITEM)
         _FIELD_TEST(buzzer_enabled);
         EEPROM_READ(ui.buzzer_enabled);
       #endif
 
+      //
+      // Fan tachometer check
+      //
+      #if HAS_FANCHECK
+        _FIELD_TEST(fan_check_enabled);
+        EEPROM_READ(fan_check.enabled);
+      #endif
+
       //
       // MKS UI controller
       //
       #if ENABLED(DGUS_LCD_UI_MKS)
         _FIELD_TEST(mks_language_index);
         EEPROM_READ(mks_language_index);
         EEPROM_READ(mks_corner_offsets);
         EEPROM_READ(mks_park_pos);
         EEPROM_READ(mks_min_extrusion_temp);
       #endif
@@ -3029,20 +3055,25 @@ void MarlinSettings::reset() {
 
   #if ENABLED(PASSWORD_FEATURE)
     #ifdef PASSWORD_DEFAULT_VALUE
       password.is_set = true;
       password.value = PASSWORD_DEFAULT_VALUE;
     #else
       password.is_set = false;
     #endif
   #endif
 
+  //
+  // Fan tachometer check
+  //
+  TERN_(HAS_FANCHECK, fan_check.enabled = true);
+
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   postprocess();
 
   DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
 }
 

commit 589a6d7f6bbf2254958aa92d8707c51fcbcd8dd3
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Nov 10 11:55:20 2021 -0500

    üö∏ Fix up E3V2 Enhanced (#23100)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f4eba776b6..0cb29f29e0 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3037,22 +3037,20 @@ void MarlinSettings::reset() {
   #endif
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   postprocess();
 
   DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
-
-  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);

commit dc972990f35ed0f6c1ddc7d2d6c15df9e8a4cb3c
Author: Evgeniy Zhabotinskiy <evg-zhabotinsky@users.noreply.github.com>
Date:   Sun Nov 7 07:16:18 2021 +0300

    ü©π Fix M503 report (#23084)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 01a5c47fd5..f4eba776b6 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3061,23 +3061,23 @@ void MarlinSettings::reset() {
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
     //
     // Announce current units, in case inches are being displayed
     //
     CONFIG_ECHO_HEADING("Linear Units");
     #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHOPGM("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
+      SERIAL_ECHO_MSG("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
     #else
-      SERIAL_ECHOPGM("  G21 ;");
+      SERIAL_ECHO_MSG("  G21 ;");
     #endif
     gcode.say_units();
 
     //
     // M149 Temperature units
     //
     #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
       gcode.M149_report(forReplay);
     #else
       CONFIG_ECHO_HEADING(STR_TEMPERATURE_UNITS);

commit 296a6137cd06ce06f062767ab1b59f99ee95a094
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 1 23:03:50 2021 +0000

    üö∏ More flexible Probe Temperature Compensation (#23033)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c82f5aad0d..01a5c47fd5 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -121,21 +121,21 @@
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "stepper/indirection.h"
   #include "../feature/tmc_util.h"
 #endif
 
-#if ENABLED(PROBE_TEMP_COMPENSATION)
+#if HAS_PTC
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #include "../feature/controllerfan.h"
 
 #if ENABLED(CASE_LIGHT_ENABLE)
   #include "../feature/caselight.h"
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
@@ -257,27 +257,30 @@ typedef struct SettingsDataStruct {
   int8_t ubl_storage_slot;                              // ubl.storage_slot
 
   //
   // SERVO_ANGLES
   //
   uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
 
   //
   // Temperature first layer compensation values
   //
-  #if ENABLED(PROBE_TEMP_COMPENSATION)
-    int16_t z_offsets_probe[COUNT(temp_comp.z_offsets_probe)], // M871 P I V
-            z_offsets_bed[COUNT(temp_comp.z_offsets_bed)]      // M871 B I V
-            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-              , z_offsets_ext[COUNT(temp_comp.z_offsets_ext)]  // M871 E I V
-            #endif
-            ;
+  #if HAS_PTC
+    #if ENABLED(PTC_PROBE)
+      int16_t z_offsets_probe[COUNT(ptc.z_offsets_probe)]; // M871 P I V
+    #endif
+    #if ENABLED(PTC_BED)
+      int16_t z_offsets_bed[COUNT(ptc.z_offsets_bed)];     // M871 B I V
+    #endif
+    #if ENABLED(PTC_HOTEND)
+      int16_t z_offsets_hotend[COUNT(ptc.z_offsets_hotend)];     // M871 E I V
+    #endif
   #endif
 
   //
   // BLTOUCH
   //
   bool bltouch_last_written_mode;
 
   //
   // Kinematic Settings
   //
@@ -837,25 +840,29 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(servo_angles);
       #if !HAS_SERVO_ANGLES
         uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
       #endif
       EEPROM_WRITE(servo_angles);
     }
 
     //
     // Thermal first layer compensation values
     //
-    #if ENABLED(PROBE_TEMP_COMPENSATION)
-      EEPROM_WRITE(temp_comp.z_offsets_probe);
-      EEPROM_WRITE(temp_comp.z_offsets_bed);
-      #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-        EEPROM_WRITE(temp_comp.z_offsets_ext);
+    #if HAS_PTC
+      #if ENABLED(PTC_PROBE)
+        EEPROM_WRITE(ptc.z_offsets_probe);
+      #endif
+      #if ENABLED(PTC_BED)
+        EEPROM_WRITE(ptc.z_offsets_bed);
+      #endif
+      #if ENABLED(PTC_HOTEND)
+        EEPROM_WRITE(ptc.z_offsets_hotend);
       #endif
     #else
       // No placeholder data for this feature
     #endif
 
     //
     // BLTOUCH
     //
     {
       _FIELD_TEST(bltouch_last_written_mode);
@@ -1703,27 +1710,31 @@ void MarlinSettings::postprocess() {
           uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
         #else
           uint16_t servo_angles_arr[EEPROM_NUM_SERVOS][2];
         #endif
         EEPROM_READ(servo_angles_arr);
       }
 
       //
       // Thermal first layer compensation values
       //
-      #if ENABLED(PROBE_TEMP_COMPENSATION)
-        EEPROM_READ(temp_comp.z_offsets_probe);
-        EEPROM_READ(temp_comp.z_offsets_bed);
-        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-          EEPROM_READ(temp_comp.z_offsets_ext);
+      #if HAS_PTC
+        #if ENABLED(PTC_PROBE)
+          EEPROM_READ(ptc.z_offsets_probe);
         #endif
-        temp_comp.reset_index();
+        # if ENABLED(PTC_BED)
+          EEPROM_READ(ptc.z_offsets_bed);
+        #endif
+        #if ENABLED(PTC_HOTEND)
+          EEPROM_READ(ptc.z_offsets_hotend);
+        #endif
+        ptc.reset_index();
       #else
         // No placeholder data for this feature
       #endif
 
       //
       // BLTOUCH
       //
       {
         _FIELD_TEST(bltouch_last_written_mode);
         #if ENABLED(BLTOUCH)
@@ -2721,20 +2732,25 @@ void MarlinSettings::reset() {
   //
   // Z Stepper Auto-alignment points
   //
   TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
   //
   // Servo Angles
   //
   TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
 
+  //
+  // Probe Temperature Compensation
+  //
+  TERN_(HAS_PTC, ptc.reset());
+
   //
   // BLTOUCH
   //
   //#if ENABLED(BLTOUCH)
   //  bltouch.last_written_mode;
   //#endif
 
   //
   // Kinematic settings
   //

commit 1d80464ba77bc576426f15af28a633bf48d769ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:15:58 2021 -0500

    üé® Define HAS_PREHEAT conditional

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6b7143e82a..c82f5aad0d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -310,21 +310,21 @@ typedef struct SettingsDataStruct {
   #if ENABLED(Z_STEPPER_AUTO_ALIGN)
     xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
     #endif
   #endif
 
   //
   // Material Presets
   //
-  #if PREHEAT_COUNT
+  #if HAS_PREHEAT
     preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
   #endif
 
   //
   // PIDTEMP
   //
   PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
   int16_t lpq_len;                                      // M301 L
 
   //
@@ -911,21 +911,21 @@ void MarlinSettings::postprocess() {
     #if ENABLED(Z_STEPPER_AUTO_ALIGN)
       EEPROM_WRITE(z_stepper_align.xy);
       #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
         EEPROM_WRITE(z_stepper_align.stepper_xy);
       #endif
     #endif
 
     //
     // LCD Preheat settings
     //
-    #if PREHEAT_COUNT
+    #if HAS_PREHEAT
       _FIELD_TEST(ui_material_preset);
       EEPROM_WRITE(ui.material_preset);
     #endif
 
     //
     // PIDTEMP
     //
     {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
@@ -1779,21 +1779,21 @@ void MarlinSettings::postprocess() {
       #if ENABLED(Z_STEPPER_AUTO_ALIGN)
         EEPROM_READ(z_stepper_align.xy);
         #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           EEPROM_READ(z_stepper_align.stepper_xy);
         #endif
       #endif
 
       //
       // LCD Preheat settings
       //
-      #if PREHEAT_COUNT
+      #if HAS_PREHEAT
         _FIELD_TEST(ui_material_preset);
         EEPROM_READ(ui.material_preset);
       #endif
 
       //
       // Hotend PID
       //
       {
         HOTEND_LOOP() {
           PIDCF_t pidcf;
@@ -2789,21 +2789,21 @@ void MarlinSettings::reset() {
       #ifndef Z4_ENDSTOP_ADJUSTMENT
         #define Z4_ENDSTOP_ADJUSTMENT 0
       #endif
       endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
     #endif
   #endif
 
   //
   // Preheat parameters
   //
-  #if PREHEAT_COUNT
+  #if HAS_PREHEAT
     #define _PITEM(N,T) PREHEAT_##N##_##T,
     #if HAS_HOTEND
       constexpr uint16_t hpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_HOTEND) };
     #endif
     #if HAS_HEATED_BED
       constexpr uint16_t bpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_BED) };
     #endif
     #if HAS_FAN
       constexpr uint8_t fpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, FAN_SPEED) };
     #endif
@@ -3174,21 +3174,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // Z Auto-Align
     //
     TERN_(Z_STEPPER_AUTO_ALIGN, gcode.M422_report(forReplay));
 
     //
     // LCD Preheat Settings
     //
-    #if PREHEAT_COUNT
+    #if HAS_PREHEAT
       gcode.M145_report(forReplay);
     #endif
 
     //
     // PID
     //
     TERN_(PIDTEMP,        gcode.M301_report(forReplay));
     TERN_(PIDTEMPBED,     gcode.M304_report(forReplay));
     TERN_(PIDTEMPCHAMBER, gcode.M309_report(forReplay));
 

commit d7fede3a6324cd6b1ec91a9c8e248fce8f0d7cf2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:40:01 2021 -0500

    üé® Apply F() to G-code report header

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4f15dceba8..6b7143e82a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3030,21 +3030,21 @@ void MarlinSettings::reset() {
   DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
   #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
-  #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, PSTR(STR))
+  #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, F(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
     //

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index a4b8bb19e6..4f15dceba8 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1464,21 +1464,21 @@ void MarlinSettings::postprocess() {
     EEPROM_FINISH();
 
     //
     // UBL Mesh
     //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
         store_mesh(ubl.storage_slot);
     #endif
 
-    if (!eeprom_error) LCD_MESSAGEPGM(MSG_SETTINGS_STORED);
+    if (!eeprom_error) LCD_MESSAGE(MSG_SETTINGS_STORED);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
 
     return !eeprom_error;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
   bool MarlinSettings::_load() {
@@ -1490,21 +1490,21 @@ void MarlinSettings::postprocess() {
     uint16_t stored_crc;
     EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      TERN_(DWIN_CREALITY_LCD_ENHANCED, ui.set_status(GET_TEXT(MSG_ERR_EEPROM_VERSION)));
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_VERSION));
 
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
 
@@ -2355,21 +2355,21 @@ void MarlinSettings::postprocess() {
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        TERN_(DWIN_CREALITY_LCD_ENHANCED, ui.set_status(GET_TEXT(MSG_ERR_EEPROM_CRC)));
+        TERN_(DWIN_CREALITY_LCD_ENHANCED, LCD_MESSAGE(MSG_ERR_EEPROM_CRC));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 921b25dad7..a4b8bb19e6 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3271,21 +3271,21 @@ void MarlinSettings::reset() {
     #endif
 
     //
     // Advanced Pause filament load & unload lengths
     //
     TERN_(ADVANCED_PAUSE_FEATURE, gcode.M603_report(forReplay));
 
     //
     // Tool-changing Parameters
     //
-    TERN_(HAS_MULTI_EXTRUDER, gcode.M217_report(forReplay));
+    E_TERN_(gcode.M217_report(forReplay));
 
     //
     // Backlash Compensation
     //
     TERN_(BACKLASH_GCODE, gcode.M425_report(forReplay));
 
     //
     // Filament Runout Sensor
     //
     TERN_(HAS_FILAMENT_SENSOR, gcode.M412_report(forReplay));

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7d73f2ec4b..921b25dad7 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -550,21 +550,21 @@ void MarlinSettings::postprocess() {
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.update_brightness());
 
   TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
 
-  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
+  // Refresh mm_per_step with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
   #include "printcounter.h"

commit 1ac7a56a823b5012250dd7259a9a7a46d3bfcde5
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sat Sep 25 05:59:43 2021 -0500

    üêõ E3V2 Brightness followup (#22821)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d8d9f20276..7d73f2ec4b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -345,21 +345,21 @@ typedef struct SettingsDataStruct {
   #endif
 
   //
   // Power monitor
   //
   uint8_t power_monitor_flags;                          // M430 I V W
 
   //
   // HAS_LCD_CONTRAST
   //
-  int16_t lcd_contrast;                                 // M250 C
+  uint8_t lcd_contrast;                                 // M250 C
 
   //
   // HAS_LCD_BRIGHTNESS
   //
   uint8_t lcd_brightness;                               // M256 B
 
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
@@ -1010,21 +1010,21 @@ void MarlinSettings::postprocess() {
       #endif
       _FIELD_TEST(power_monitor_flags);
       EEPROM_WRITE(power_monitor_flags);
     }
 
     //
     // LCD Contrast
     //
     {
       _FIELD_TEST(lcd_contrast);
-      const int16_t lcd_contrast = TERN(HAS_LCD_CONTRAST, ui.contrast, 127);
+      const uint8_t lcd_contrast = TERN(HAS_LCD_CONTRAST, ui.contrast, 127);
       EEPROM_WRITE(lcd_contrast);
     }
 
     //
     // LCD Brightness
     //
     {
       _FIELD_TEST(lcd_brightness);
       const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
       EEPROM_WRITE(lcd_brightness);
@@ -1877,21 +1877,21 @@ void MarlinSettings::postprocess() {
         #endif
         _FIELD_TEST(power_monitor_flags);
         EEPROM_READ(power_monitor_flags);
       }
 
       //
       // LCD Contrast
       //
       {
         _FIELD_TEST(lcd_contrast);
-        int16_t lcd_contrast;
+        uint8_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
         if (!validating) {
           TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
         }
       }
 
       //
       // LCD Brightness
       //
       {

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8e4c758854..d8d9f20276 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V84"
+#define EEPROM_VERSION "V85"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -272,31 +272,38 @@ typedef struct SettingsDataStruct {
             #endif
             ;
   #endif
 
   //
   // BLTOUCH
   //
   bool bltouch_last_written_mode;
 
   //
-  // DELTA / [XYZ]_DUAL_ENDSTOPS
+  // Kinematic Settings
   //
-  #if ENABLED(DELTA)
-    float delta_height;                                 // M666 H
-    abc_float_t delta_endstop_adj;                      // M666 X Y Z
-    float delta_radius,                                 // M665 R
-          delta_diagonal_rod,                           // M665 L
-          segments_per_second;                          // M665 S
-    abc_float_t delta_tower_angle_trim,                 // M665 X Y Z
-                delta_diagonal_rod_trim;                // M665 A B C
-  #elif HAS_EXTRA_ENDSTOPS
+  #if IS_KINEMATIC
+    float segments_per_second;                          // M665 S
+    #if ENABLED(DELTA)
+      float delta_height;                               // M666 H
+      abc_float_t delta_endstop_adj;                    // M666 X Y Z
+      float delta_radius,                               // M665 R
+            delta_diagonal_rod;                         // M665 L
+      abc_float_t delta_tower_angle_trim,               // M665 X Y Z
+                  delta_diagonal_rod_trim;              // M665 A B C
+    #endif
+  #endif
+
+  //
+  // Extra Endstops offsets
+  //
+  #if HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 (S2) Z
           z3_endstop_adj,                               // M666 (S3) Z
           z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
   //
   // Z_STEPPER_AUTO_ALIGN, Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
   //
@@ -850,59 +857,63 @@ void MarlinSettings::postprocess() {
     //
     // BLTOUCH
     //
     {
       _FIELD_TEST(bltouch_last_written_mode);
       const bool bltouch_last_written_mode = TERN(BLTOUCH, bltouch.last_written_mode, false);
       EEPROM_WRITE(bltouch_last_written_mode);
     }
 
     //
-    // DELTA Geometry or Dual Endstops offsets
+    // Kinematic Settings
     //
+    #if IS_KINEMATIC
     {
+      EEPROM_WRITE(segments_per_second);
       #if ENABLED(DELTA)
-
         _FIELD_TEST(delta_height);
-
         EEPROM_WRITE(delta_height);              // 1 float
         EEPROM_WRITE(delta_endstop_adj);         // 3 floats
         EEPROM_WRITE(delta_radius);              // 1 float
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
-        EEPROM_WRITE(segments_per_second);       // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
         EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
+      #endif
+    }
+    #endif
 
-      #elif HAS_EXTRA_ENDSTOPS
-
-        _FIELD_TEST(x2_endstop_adj);
-
-        // Write dual endstops in X, Y, Z order. Unused = 0.0
-        dummyf = 0;
-        EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
-        EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
-        EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
+    //
+    // Extra Endstops offsets
+    //
+    #if HAS_EXTRA_ENDSTOPS
+    {
+      _FIELD_TEST(x2_endstop_adj);
 
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
-          EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
+      // Write dual endstops in X, Y, Z order. Unused = 0.0
+      dummyf = 0;
+      EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
+      EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
+      EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
 
-        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
-          EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
-        #else
-          EEPROM_WRITE(dummyf);
-        #endif
+      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+        EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummyf);
+      #endif
 
+      #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+        EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
+      #else
+        EEPROM_WRITE(dummyf);
       #endif
     }
+    #endif
 
     #if ENABLED(Z_STEPPER_AUTO_ALIGN)
       EEPROM_WRITE(z_stepper_align.xy);
       #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
         EEPROM_WRITE(z_stepper_align.stepper_xy);
       #endif
     #endif
 
     //
     // LCD Preheat settings
@@ -1717,56 +1728,60 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(bltouch_last_written_mode);
         #if ENABLED(BLTOUCH)
           const bool &bltouch_last_written_mode = bltouch.last_written_mode;
         #else
           bool bltouch_last_written_mode;
         #endif
         EEPROM_READ(bltouch_last_written_mode);
       }
 
       //
-      // DELTA Geometry or Dual Endstops offsets
+      // Kinematic Segments-per-second
       //
+      #if IS_KINEMATIC
       {
+        EEPROM_READ(segments_per_second);
         #if ENABLED(DELTA)
-
           _FIELD_TEST(delta_height);
-
           EEPROM_READ(delta_height);              // 1 float
           EEPROM_READ(delta_endstop_adj);         // 3 floats
           EEPROM_READ(delta_radius);              // 1 float
           EEPROM_READ(delta_diagonal_rod);        // 1 float
-          EEPROM_READ(segments_per_second);       // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
           EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
+        #endif
+      }
+      #endif
 
-        #elif HAS_EXTRA_ENDSTOPS
-
-          _FIELD_TEST(x2_endstop_adj);
+      //
+      // Extra Endstops offsets
+      //
+      #if HAS_EXTRA_ENDSTOPS
+      {
+        _FIELD_TEST(x2_endstop_adj);
 
-          EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
-          EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
-          EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
-
-          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
-            EEPROM_READ(endstops.z3_endstop_adj); // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
-          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
-            EEPROM_READ(endstops.z4_endstop_adj); // 1 float
-          #else
-            EEPROM_READ(dummyf);
-          #endif
+        EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
+        EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
+        EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
 
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+          EEPROM_READ(endstops.z3_endstop_adj); // 1 float
+        #else
+          EEPROM_READ(dummyf);
+        #endif
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+          EEPROM_READ(endstops.z4_endstop_adj); // 1 float
+        #else
+          EEPROM_READ(dummyf);
         #endif
       }
+      #endif
 
       #if ENABLED(Z_STEPPER_AUTO_ALIGN)
         EEPROM_READ(z_stepper_align.xy);
         #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           EEPROM_READ(z_stepper_align.stepper_xy);
         #endif
       #endif
 
       //
       // LCD Preheat settings
@@ -2714,34 +2729,44 @@ void MarlinSettings::reset() {
   TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
 
   //
   // BLTOUCH
   //
   //#if ENABLED(BLTOUCH)
   //  bltouch.last_written_mode;
   //#endif
 
   //
-  // Endstop Adjustments
+  // Kinematic settings
   //
 
-  #if ENABLED(DELTA)
-    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
-    delta_height = DELTA_HEIGHT;
-    delta_endstop_adj = adj;
-    delta_radius = DELTA_RADIUS;
-    delta_diagonal_rod = DELTA_DIAGONAL_ROD;
-    segments_per_second = DELTA_SEGMENTS_PER_SECOND;
-    delta_tower_angle_trim = dta;
-    delta_diagonal_rod_trim = ddr;
+  #if IS_KINEMATIC
+    segments_per_second = (
+      TERN_(DELTA, DELTA_SEGMENTS_PER_SECOND)
+      TERN_(IS_SCARA, SCARA_SEGMENTS_PER_SECOND)
+      TERN_(POLARGRAPH, POLAR_SEGMENTS_PER_SECOND)
+    );
+    #if ENABLED(DELTA)
+      const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
+      delta_height = DELTA_HEIGHT;
+      delta_endstop_adj = adj;
+      delta_radius = DELTA_RADIUS;
+      delta_diagonal_rod = DELTA_DIAGONAL_ROD;
+      delta_tower_angle_trim = dta;
+      delta_diagonal_rod_trim = ddr;
+    #endif
   #endif
 
+  //
+  // Endstop Adjustments
+  //
+
   #if ENABLED(X_DUAL_ENDSTOPS)
     #ifndef X2_ENDSTOP_ADJUSTMENT
       #define X2_ENDSTOP_ADJUSTMENT 0
     #endif
     endstops.x2_endstop_adj = X2_ENDSTOP_ADJUSTMENT;
   #endif
 
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #ifndef Y2_ENDSTOP_ADJUSTMENT
       #define Y2_ENDSTOP_ADJUSTMENT 0
@@ -3130,21 +3155,21 @@ void MarlinSettings::reset() {
       #endif
 
     #endif // HAS_LEVELING
 
     //
     // Editable Servo Angles
     //
     TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
     //
-    // Delta / SCARA Kinematics
+    // Kinematic Settings
     //
     TERN_(IS_KINEMATIC, gcode.M665_report(forReplay));
 
     //
     // M666 Endstops Adjustment
     //
     #if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
       gcode.M666_report(forReplay);
     #endif
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 017b96cc20..8e4c758854 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2346,21 +2346,21 @@ void MarlinSettings::postprocess() {
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         TERN_(DWIN_CREALITY_LCD_ENHANCED, ui.set_status(GET_TEXT(MSG_ERR_EEPROM_CRC)));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
-        DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
+        DEBUG_ECHOLNPGM(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           ubl.report_state();
 
           if (!ubl.sanity_check()) {
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
@@ -2373,21 +2373,21 @@ void MarlinSettings::postprocess() {
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
               ubl.echo_name();
               DEBUG_ECHOLNPGM(".");
             #endif
             ubl.reset();
           }
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
-            DEBUG_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
+            DEBUG_ECHOLNPGM("Mesh ", ubl.storage_slot, " loaded from storage.");
           }
           else {
             ubl.reset();
             DEBUG_ECHOLNPGM("UBL reset");
           }
         }
       #endif
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
@@ -2429,21 +2429,21 @@ void MarlinSettings::postprocess() {
     #if ENABLED(EEPROM_AUTO_INIT)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
-      DEBUG_ECHOLNPAIR("?Invalid slot.\n", s, " mesh slots available.");
+      DEBUG_ECHOLNPGM("?Invalid slot.\n", s, " mesh slots available.");
       UNUSED(s);
     }
 
     // 128 (+1 because of the change to capacity rather than last valid address)
     // is a placeholder for the size of the MAT; the MAT will always
     // live at the very end of the eeprom
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129;
 
     uint16_t MarlinSettings::meshes_start_index() {
       // Pad the end of configuration data so it can float up
@@ -2460,21 +2460,21 @@ void MarlinSettings::postprocess() {
     int MarlinSettings::mesh_slot_offset(const int8_t slot) {
       return meshes_end - (slot + 1) * MESH_STORE_SIZE;
     }
 
     void MarlinSettings::store_mesh(const int8_t slot) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
           ubl_invalid_slot(a);
-          DEBUG_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
+          DEBUG_ECHOLNPGM("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
           DEBUG_EOL();
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
 
         #if ENABLED(OPTIMIZED_MESH_STORAGE)
           int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
           ubl.set_store_from_mesh(ubl.z_values, z_mesh_store);
@@ -2482,21 +2482,21 @@ void MarlinSettings::postprocess() {
         #else
           uint8_t * const src = (uint8_t*)&ubl.z_values;
         #endif
 
         // Write crc to MAT along with other data, or just tack on to the beginning or end
         persistentStore.access_start();
         const bool status = persistentStore.write_data(pos, src, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
         if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
-        else        DEBUG_ECHOLNPAIR("Mesh saved in slot ", slot);
+        else        DEBUG_ECHOLNPGM("Mesh saved in slot ", slot);
 
       #else
 
         // Other mesh types
 
       #endif
     }
 
     void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=nullptr*/) {
 
@@ -2526,21 +2526,21 @@ void MarlinSettings::postprocess() {
           if (into) {
             float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
             ubl.set_mesh_from_store(z_mesh_store, z_values);
             memcpy(into, z_values, sizeof(z_values));
           }
           else
             ubl.set_mesh_from_store(z_mesh_store, ubl.z_values);
         #endif
 
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
-        else        DEBUG_ECHOLNPAIR("Mesh loaded from slot ", slot);
+        else        DEBUG_ECHOLNPGM("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();
 
       #else
 
         // Other mesh types
 
       #endif
     }
 
@@ -3003,38 +3003,38 @@ void MarlinSettings::reset() {
   postprocess();
 
   DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
-  #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR(V); }while(0)
-  #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR_P(V); }while(0)
+  #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(V); }while(0)
+  #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM_P(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, PSTR(STR))
 
   void M92_report(const bool echo=true, const int8_t e=-1);
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
     //
     // Announce current units, in case inches are being displayed
     //
     CONFIG_ECHO_HEADING("Linear Units");
     #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHOPAIR("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
+      SERIAL_ECHOPGM("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
     #else
       SERIAL_ECHOPGM("  G21 ;");
     #endif
     gcode.say_units();
 
     //
     // M149 Temperature units
     //
     #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
       gcode.M149_report(forReplay);
@@ -3089,21 +3089,21 @@ void MarlinSettings::reset() {
     #if HAS_LEVELING
 
       gcode.M420_report(forReplay);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 S3 I", px, " J", py);
+              SERIAL_ECHOPGM("  G29 S3 I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
@@ -3114,21 +3114,21 @@ void MarlinSettings::reset() {
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 W I", px, " J", py);
+              SERIAL_ECHOPGM("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
     //

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c24a63ee51..017b96cc20 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -126,23 +126,20 @@
 #if HAS_TRINAMIC_CONFIG
   #include "stepper/indirection.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #include "../feature/controllerfan.h"
-#if ENABLED(CONTROLLER_FAN_EDITABLE)
-  void M710_report(const bool forReplay=true);
-#endif
 
 #if ENABLED(CASE_LIGHT_ENABLE)
   #include "../feature/caselight.h"
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
@@ -160,27 +157,20 @@
 #if ENABLED(DGUS_LCD_UI_MKS)
   #include "../lcd/extui/dgus/DGUSScreenHandler.h"
   #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
-  void M552_report();
-  void M553_report();
-  void M554_report();
-#endif
-
-#if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
-  void M666_report(const bool forReplay=true);
 #endif
 
 #define _EN_ITEM(N) , E##N
 
 typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
 typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
 typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
 typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
 
 #undef _EN_ITEM
@@ -3005,942 +2995,288 @@ void MarlinSettings::reset() {
     #endif
   #endif
 
   //
   // MKS UI controller
   //
   TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
 
   postprocess();
 
-  DEBUG_ECHO_START();
-  DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
+  DEBUG_ECHO_MSG("Hardcoded Default Settings Loaded");
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
-  static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
-    if (!repl) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("; ");
-      SERIAL_ECHOPGM_P(pstr);
-      if (eol) SERIAL_EOL();
-    }
-  }
-
-  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+  #define CONFIG_ECHO_START()       gcode.report_echo_start(forReplay)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR(V); }while(0)
-  #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
-
-  #if HAS_TRINAMIC_CONFIG
-    inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
-    #if HAS_STEALTHCHOP
-      void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOPGM("  M569 S1");
-        if (etc) {
-          SERIAL_CHAR(' ');
-          SERIAL_ECHOPGM_P(etc);
-        }
-        if (newLine) SERIAL_EOL();
-      }
-    #endif
-    #if ENABLED(HYBRID_THRESHOLD)
-      inline void say_M913(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M913"); }
-    #endif
-    #if USE_SENSORLESS
-      inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
-    #endif
-  #endif
-
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    inline void say_M603(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M603 "); }
-  #endif
+  #define CONFIG_ECHO_MSG_P(V...)   do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR_P(V); }while(0)
+  #define CONFIG_ECHO_HEADING(STR)  gcode.report_heading(forReplay, PSTR(STR))
 
-  inline void say_units(const bool colon) {
-    SERIAL_ECHOPGM_P(
-      #if ENABLED(INCH_MODE_SUPPORT)
-        parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
-      #endif
-      PSTR(" (mm)")
-    );
-    if (colon) SERIAL_ECHOLNPGM(":");
-  }
-
-  void report_M92(const bool echo=true, const int8_t e=-1);
+  void M92_report(const bool echo=true, const int8_t e=-1);
 
   /**
    * M503 - Report current settings in RAM
    *
    * Unless specifically disabled, M503 is available even without EEPROM
    */
   void MarlinSettings::report(const bool forReplay) {
-    /**
-     * Announce current units, in case inches are being displayed
-     */
-    CONFIG_ECHO_START();
+    //
+    // Announce current units, in case inches are being displayed
+    //
+    CONFIG_ECHO_HEADING("Linear Units");
     #if ENABLED(INCH_MODE_SUPPORT)
-      SERIAL_ECHOPGM("  G2");
-      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
-      SERIAL_ECHOPGM(" ;");
-      say_units(false);
+      SERIAL_ECHOPAIR("  G2", AS_DIGIT(parser.linear_unit_factor == 1.0), " ;");
     #else
-      SERIAL_ECHOPGM("  G21    ; Units in mm");
-      say_units(false);
+      SERIAL_ECHOPGM("  G21 ;");
     #endif
-    SERIAL_EOL();
-
-    #if HAS_LCD_MENU
-
-      // Temperature units - for Ultipanel temperature options
-
-      CONFIG_ECHO_START();
-      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        SERIAL_ECHOPGM("  M149 ");
-        SERIAL_CHAR(parser.temp_units_code());
-        SERIAL_ECHOPGM(" ; Units in ");
-        SERIAL_ECHOPGM_P(parser.temp_units_name());
-      #else
-        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
-      #endif
+    gcode.say_units();
 
+    //
+    // M149 Temperature units
+    //
+    #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+      gcode.M149_report(forReplay);
+    #else
+      CONFIG_ECHO_HEADING(STR_TEMPERATURE_UNITS);
+      CONFIG_ECHO_MSG("  M149 C ; Units in Celsius");
     #endif
 
-    SERIAL_EOL();
-
-    #if EXTRUDERS && DISABLED(NO_VOLUMETRICS)
-
-      /**
-       * Volumetric extrusion M200
-       */
-      if (!forReplay) {
-        config_heading(forReplay, PSTR("Filament settings:"), false);
-        if (parser.volumetric_enabled)
-          SERIAL_EOL();
-        else
-          SERIAL_ECHOLNPGM(" Disabled");
-      }
+    //
+    // M200 Volumetric Extrusion
+    //
+    IF_DISABLED(NO_VOLUMETRICS, gcode.M200_report(forReplay));
 
-      #if EXTRUDERS == 1
-        CONFIG_ECHO_MSG("  M200 S", parser.volumetric_enabled
-                            , " D", LINEAR_UNIT(planner.filament_size[0])
-                            #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                              , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
-                            #endif
-                       );
-      #else
-        LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_MSG("  M200 T", i
-                              , " D", LINEAR_UNIT(planner.filament_size[i])
-                              #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
-                              #endif
-                         );
-        }
-        CONFIG_ECHO_MSG("  M200 S", parser.volumetric_enabled);
-      #endif
+    //
+    // M92 Steps per Unit
+    //
+    gcode.M92_report(forReplay);
 
-    #endif // EXTRUDERS && !NO_VOLUMETRICS
-
-    CONFIG_ECHO_HEADING("Steps per unit:");
-    report_M92(!forReplay);
-
-    CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-      LIST_N(DOUBLE(LINEAR_AXES),
-        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]),
-        SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]),
-        SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]),
-        SP_I_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[I_AXIS]),
-        SP_J_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[J_AXIS]),
-        SP_K_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[K_AXIS])
-      )
-      #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
-        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
-      #endif
-    );
-    #if ENABLED(DISTINCT_E_FACTORS)
-      LOOP_L_N(i, E_STEPPERS) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-            PSTR("  M203 T"), i
-          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
-        );
-      }
-    #endif
+    //
+    // M203 Maximum feedrates (units/s)
+    //
+    gcode.M203_report(forReplay);
 
-    CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-      LIST_N(DOUBLE(LINEAR_AXES),
-        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]),
-        SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]),
-        SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]),
-        SP_I_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[I_AXIS]),
-        SP_J_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[J_AXIS]),
-        SP_K_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[K_AXIS])
-      )
-      #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
-        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
-      #endif
-    );
-    #if ENABLED(DISTINCT_E_FACTORS)
-      LOOP_L_N(i, E_STEPPERS) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-            PSTR("  M201 T"), i
-          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
-        );
-      }
-    #endif
+    //
+    // M201 Maximum Acceleration (units/s2)
+    //
+    gcode.M201_report(forReplay);
 
-    CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
-      , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
-      , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
-    );
+    //
+    // M204 Acceleration (units/s2)
+    //
+    gcode.M204_report(forReplay);
 
-    CONFIG_ECHO_HEADING(
-      "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
-      TERN_(HAS_JUNCTION_DEVIATION, " J<junc_dev>")
-      #if HAS_CLASSIC_JERK
-        " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
-        TERN_(HAS_CLASSIC_E_JERK, " E<max_e_jerk>")
-      #endif
-    );
-    CONFIG_ECHO_START();
-    SERIAL_ECHOLNPAIR_P(
-        PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
-      , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
-      , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
-      #if HAS_JUNCTION_DEVIATION
-        , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
-      #endif
-      #if HAS_CLASSIC_JERK
-        , LIST_N(DOUBLE(LINEAR_AXES),
-          SP_X_STR, LINEAR_UNIT(planner.max_jerk.x),
-          SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y),
-          SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z),
-          SP_I_STR, LINEAR_UNIT(planner.max_jerk.i),
-          SP_J_STR, LINEAR_UNIT(planner.max_jerk.j),
-          SP_K_STR, LINEAR_UNIT(planner.max_jerk.k)
-        )
-        #if HAS_CLASSIC_E_JERK
-          , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
-        #endif
-      #endif
-    );
+    //
+    // M205 "Advanced" Settings
+    //
+    gcode.M205_report(forReplay);
 
-    #if HAS_M206_COMMAND
-      CONFIG_ECHO_HEADING("Home offset:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        #if IS_CARTESIAN
-          LIST_N(DOUBLE(LINEAR_AXES),
-            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x),
-            SP_Y_STR, LINEAR_UNIT(home_offset.y),
-            SP_Z_STR, LINEAR_UNIT(home_offset.z),
-            SP_I_STR, LINEAR_UNIT(home_offset.i),
-            SP_J_STR, LINEAR_UNIT(home_offset.j),
-            SP_K_STR, LINEAR_UNIT(home_offset.k)
-          )
-        #else
-          PSTR("  M206 Z"), LINEAR_UNIT(home_offset.z)
-        #endif
-      );
-    #endif
+    //
+    // M206 Home Offset
+    //
+    TERN_(HAS_M206_COMMAND, gcode.M206_report(forReplay));
 
-    #if HAS_HOTEND_OFFSET
-      CONFIG_ECHO_HEADING("Hotend offsets:");
-      CONFIG_ECHO_START();
-      LOOP_S_L_N(e, 1, HOTENDS) {
-        SERIAL_ECHOPAIR_P(
-          PSTR("  M218 T"), e,
-          SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
-          SP_Y_STR, LINEAR_UNIT(hotend_offset[e].y)
-        );
-        SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(hotend_offset[e].z), 3);
-      }
-    #endif
+    //
+    // M218 Hotend offsets
+    //
+    TERN_(HAS_HOTEND_OFFSET, gcode.M218_report(forReplay));
 
-    /**
-     * Bed Leveling
-     */
+    //
+    // Bed Leveling
+    //
     #if HAS_LEVELING
 
-      #if ENABLED(MESH_BED_LEVELING)
-
-        CONFIG_ECHO_HEADING("Mesh Bed Leveling:");
-
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-        config_heading(forReplay, NUL_STR, false);
-        if (!forReplay) {
-          ubl.echo_name();
-          SERIAL_CHAR(':');
-          SERIAL_EOL();
-        }
-
-      #elif HAS_ABL_OR_UBL
-
-        CONFIG_ECHO_HEADING("Auto Bed Leveling:");
-
-      #endif
-
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        PSTR("  M420 S"), planner.leveling_active
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
-        #endif
-      );
+      gcode.M420_report(forReplay);
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPAIR("  G29 S3 I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
           SERIAL_EOL();
           ubl.report_state();
-          config_heading(false, PSTR("Active Mesh Slot: "), false);
-          SERIAL_ECHOLN(ubl.storage_slot);
-          config_heading(false, PSTR("EEPROM can hold "), false);
-          SERIAL_ECHO(calc_num_meshes());
-          SERIAL_ECHOLNPGM(" meshes.\n");
+          SERIAL_ECHO_MSG("Active Mesh Slot ", ubl.storage_slot);
+          SERIAL_ECHO_MSG("EEPROM can hold ", calc_num_meshes(), " meshes.\n");
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
               SERIAL_ECHOPAIR("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
-    #if ENABLED(EDITABLE_SERVO_ANGLES)
-
-      CONFIG_ECHO_HEADING("Servo Angles:");
-      LOOP_L_N(i, NUM_SERVOS) {
-        switch (i) {
-          #if ENABLED(SWITCHING_EXTRUDER)
-            case SWITCHING_EXTRUDER_SERVO_NR:
-            #if EXTRUDERS > 3
-              case SWITCHING_EXTRUDER_E23_SERVO_NR:
-            #endif
-          #elif ENABLED(SWITCHING_NOZZLE)
-            case SWITCHING_NOZZLE_SERVO_NR:
-          #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
-            case Z_PROBE_SERVO_NR:
-          #endif
-            CONFIG_ECHO_MSG("  M281 P", i, " L", servo_angles[i][0], " U", servo_angles[i][1]);
-          default: break;
-        }
-      }
-
-    #endif // EDITABLE_SERVO_ANGLES
-
-    #if HAS_SCARA_OFFSET
-
-      CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M665 S"), segments_per_second
-        , SP_P_STR, scara_home_offset.a
-        , SP_T_STR, scara_home_offset.b
-        , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
-      );
-
-    #elif ENABLED(DELTA)
-
-      CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
-        , PSTR(" R"), LINEAR_UNIT(delta_radius)
-        , PSTR(" H"), LINEAR_UNIT(delta_height)
-        , PSTR(" S"), segments_per_second
-        , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
-        , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
-        , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
-        , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
-        , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
-        , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
-      );
+    //
+    // Editable Servo Angles
+    //
+    TERN_(EDITABLE_SERVO_ANGLES, gcode.M281_report(forReplay));
 
-    #endif
+    //
+    // Delta / SCARA Kinematics
+    //
+    TERN_(IS_KINEMATIC, gcode.M665_report(forReplay));
 
+    //
+    // M666 Endstops Adjustment
+    //
     #if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
-      M666_report(forReplay);
+      gcode.M666_report(forReplay);
     #endif
 
-    #if PREHEAT_COUNT
-
-      CONFIG_ECHO_HEADING("Material heatup parameters:");
-      LOOP_L_N(i, PREHEAT_COUNT) {
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR_P(
-          PSTR("  M145 S"), i
-          #if HAS_HOTEND
-            , PSTR(" H"), parser.to_temp_units(ui.material_preset[i].hotend_temp)
-          #endif
-          #if HAS_HEATED_BED
-            , SP_B_STR, parser.to_temp_units(ui.material_preset[i].bed_temp)
-          #endif
-          #if HAS_FAN
-            , PSTR(" F"), ui.material_preset[i].fan_speed
-          #endif
-        );
-      }
+    //
+    // Z Auto-Align
+    //
+    TERN_(Z_STEPPER_AUTO_ALIGN, gcode.M422_report(forReplay));
 
+    //
+    // LCD Preheat Settings
+    //
+    #if PREHEAT_COUNT
+      gcode.M145_report(forReplay);
     #endif
 
-    #if HAS_PID_HEATING
-
-      CONFIG_ECHO_HEADING("PID settings:");
-
-      #if ENABLED(PIDTEMP)
-        HOTEND_LOOP() {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR_P(
-            #if ENABLED(PID_PARAMS_PER_HOTEND)
-              PSTR("  M301 E"), e,
-              SP_P_STR
-            #else
-              PSTR("  M301 P")
-            #endif
-                        , PID_PARAM(Kp, e)
-            , PSTR(" I"), unscalePID_i(PID_PARAM(Ki, e))
-            , PSTR(" D"), unscalePID_d(PID_PARAM(Kd, e))
-          );
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            SERIAL_ECHOPAIR_P(SP_C_STR, PID_PARAM(Kc, e));
-            if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
-          #endif
-          #if ENABLED(PID_FAN_SCALING)
-            SERIAL_ECHOPAIR(" F", PID_PARAM(Kf, e));
-          #endif
-          SERIAL_EOL();
-        }
-      #endif // PIDTEMP
-
-      #if ENABLED(PIDTEMPBED)
-        CONFIG_ECHO_MSG(
-            "  M304 P", thermalManager.temp_bed.pid.Kp
-          , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
-          , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
-        );
-      #endif
-
-      #if ENABLED(PIDTEMPCHAMBER)
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR(
-            "  M309 P", thermalManager.temp_chamber.pid.Kp
-          , " I", unscalePID_i(thermalManager.temp_chamber.pid.Ki)
-          , " D", unscalePID_d(thermalManager.temp_chamber.pid.Kd)
-        );
-      #endif
-
-    #endif // PIDTEMP || PIDTEMPBED || PIDTEMPCHAMBER
+    //
+    // PID
+    //
+    TERN_(PIDTEMP,        gcode.M301_report(forReplay));
+    TERN_(PIDTEMPBED,     gcode.M304_report(forReplay));
+    TERN_(PIDTEMPCHAMBER, gcode.M309_report(forReplay));
 
     #if HAS_USER_THERMISTORS
-      CONFIG_ECHO_HEADING("User thermistors:");
       LOOP_L_N(i, USER_THERMISTORS)
-        thermalManager.log_user_thermistor(i, true);
+        thermalManager.M305_report(i, forReplay);
     #endif
 
-    #if HAS_LCD_CONTRAST
-      CONFIG_ECHO_HEADING("LCD Contrast:");
-      CONFIG_ECHO_MSG("  M250 C", ui.contrast);
-    #endif
+    //
+    // LCD Contrast
+    //
+    TERN_(HAS_LCD_CONTRAST, gcode.M250_report(forReplay));
 
-    #if HAS_LCD_BRIGHTNESS
-      CONFIG_ECHO_HEADING("LCD Brightness:");
-      CONFIG_ECHO_MSG("  M256 B", ui.brightness);
-    #endif
+    //
+    // LCD Brightness
+    //
+    TERN_(HAS_LCD_BRIGHTNESS, gcode.M256_report(forReplay));
 
-    TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
+    //
+    // Controller Fan
+    //
+    TERN_(CONTROLLER_FAN_EDITABLE, gcode.M710_report(forReplay));
 
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      CONFIG_ECHO_HEADING("Power-Loss Recovery:");
-      CONFIG_ECHO_MSG("  M413 S", recovery.enabled);
-    #endif
+    //
+    // Power-Loss Recovery
+    //
+    TERN_(POWER_LOSS_RECOVERY, gcode.M413_report(forReplay));
 
+    //
+    // Firmware Retraction
+    //
     #if ENABLED(FWRETRACT)
-      fwretract.M207_report(forReplay);
-      fwretract.M208_report(forReplay);
-      TERN_(FWRETRACT_AUTORETRACT, fwretract.M209_report(forReplay));
+      gcode.M207_report(forReplay);
+      gcode.M208_report(forReplay);
+      TERN_(FWRETRACT_AUTORETRACT, gcode.M209_report(forReplay));
     #endif
 
-    /**
-     * Probe Offset
-     */
-    #if HAS_BED_PROBE
-      config_heading(forReplay, PSTR("Z-Probe Offset"), false);
-      if (!forReplay) say_units(true);
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-        #if HAS_PROBE_XY_OFFSET
-          PSTR("  M851 X"), LINEAR_UNIT(probe.offset_xy.x),
-                  SP_Y_STR, LINEAR_UNIT(probe.offset_xy.y),
-                  SP_Z_STR
-        #else
-          PSTR("  M851 X0 Y0 Z")
-        #endif
-        , LINEAR_UNIT(probe.offset.z)
-      );
-    #endif
+    //
+    // Probe Offset
+    //
+    TERN_(HAS_BED_PROBE, gcode.M851_report(forReplay));
 
-    /**
-     * Bed Skew Correction
-     */
-    #if ENABLED(SKEW_CORRECTION_GCODE)
-      CONFIG_ECHO_HEADING("Skew Factor: ");
-      CONFIG_ECHO_START();
-      #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        SERIAL_ECHOPAIR_F("  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
-        SERIAL_ECHOPAIR_F(" J", LINEAR_UNIT(planner.skew_factor.xz), 6);
-        SERIAL_ECHOLNPAIR_F(" K", LINEAR_UNIT(planner.skew_factor.yz), 6);
-      #else
-        SERIAL_ECHOLNPAIR_F("  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
-      #endif
-    #endif
+    //
+    // Bed Skew Correction
+    //
+    TERN_(SKEW_CORRECTION_GCODE, gcode.M852_report(forReplay));
 
     #if HAS_TRINAMIC_CONFIG
+      //
+      // TMC Stepper driver current
+      //
+      gcode.M906_report(forReplay);
 
-      /**
-       * TMC stepper driver current
-       */
-      CONFIG_ECHO_HEADING("Stepper driver current:");
-
-      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
-        say_M906(forReplay);
-        #if AXIS_IS_TMC(X)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
-        #endif
-        SERIAL_EOL();
-      #endif
-
-      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
-        say_M906(forReplay);
-        SERIAL_ECHOPGM(" I1");
-        #if AXIS_IS_TMC(X2)
-          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
-        #endif
-        #if AXIS_IS_TMC(Z2)
-          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
-        #endif
-        SERIAL_EOL();
-      #endif
-
-      #if AXIS_IS_TMC(Z3)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
-      #endif
-
-      #if AXIS_IS_TMC(Z4)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.getMilliamps());
-      #endif
-
-      #if AXIS_IS_TMC(I)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(J)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(K)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.getMilliamps());
-      #endif
-
-      #if AXIS_IS_TMC(E0)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E1)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E2)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T2 E", stepperE2.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E3)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T3 E", stepperE3.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E4)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T4 E", stepperE4.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E5)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E6)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T6 E", stepperE6.getMilliamps());
-      #endif
-      #if AXIS_IS_TMC(E7)
-        say_M906(forReplay);
-        SERIAL_ECHOLNPAIR(" T7 E", stepperE7.getMilliamps());
-      #endif
-      SERIAL_EOL();
-
-      /**
-       * TMC Hybrid Threshold
-       */
-      #if ENABLED(HYBRID_THRESHOLD)
-        CONFIG_ECHO_HEADING("Hybrid Threshold:");
-        #if X_HAS_STEALTHCHOP || Y_HAS_STEALTHCHOP || Z_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          #if X_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
-          #endif
-          #if Y_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
-          #endif
-          #if Z_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if X2_HAS_STEALTHCHOP || Y2_HAS_STEALTHCHOP || Z2_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOPGM(" I1");
-          #if X2_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
-          #endif
-          #if Y2_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
-          #endif
-          #if Z2_HAS_STEALTHCHOP
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if Z3_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
-        #endif
-
-        #if Z4_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.get_pwm_thrs());
-        #endif
-
-        #if I_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.get_pwm_thrs());
-        #endif
-        #if J_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.get_pwm_thrs());
-        #endif
-        #if K_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.get_pwm_thrs());
-        #endif
-
-        #if E0_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
-        #endif
-        #if E1_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
-        #endif
-        #if E2_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
-        #endif
-        #if E3_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
-        #endif
-        #if E4_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
-        #endif
-        #if E5_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
-        #endif
-        #if E6_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T6 E", stepperE6.get_pwm_thrs());
-        #endif
-        #if E7_HAS_STEALTHCHOP
-          say_M913(forReplay);
-          SERIAL_ECHOLNPAIR(" T7 E", stepperE7.get_pwm_thrs());
-        #endif
-        SERIAL_EOL();
-      #endif // HYBRID_THRESHOLD
-
-      /**
-       * TMC Sensorless homing thresholds
-       */
-      #if USE_SENSORLESS
-        CONFIG_ECHO_HEADING("StallGuard threshold:");
-        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          #if X_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.homing_threshold());
-          #endif
-          #if Y_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.homing_threshold());
-          #endif
-          #if Z_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.homing_threshold());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if X2_SENSORLESS || Y2_SENSORLESS || Z2_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOPGM(" I1");
-          #if X2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.homing_threshold());
-          #endif
-          #if Y2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.homing_threshold());
-          #endif
-          #if Z2_SENSORLESS
-            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.homing_threshold());
-          #endif
-          SERIAL_EOL();
-        #endif
-
-        #if Z3_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
-        #endif
-
-        #if Z4_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.homing_threshold());
-        #endif
-
-        #if I_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.homing_threshold());
-        #endif
-        #if J_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.homing_threshold());
-        #endif
-        #if K_SENSORLESS
-          CONFIG_ECHO_START();
-          say_M914();
-          SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.homing_threshold());
-        #endif
-
-      #endif // USE_SENSORLESS
-
-      /**
-       * TMC stepping mode
-       */
-      #if HAS_STEALTHCHOP
-        CONFIG_ECHO_HEADING("Driver stepping mode:");
-        const bool chop_x = TERN0(X_HAS_STEALTHCHOP, stepperX.get_stored_stealthChop()),
-                   chop_y = TERN0(Y_HAS_STEALTHCHOP, stepperY.get_stored_stealthChop()),
-                   chop_z = TERN0(Z_HAS_STEALTHCHOP, stepperZ.get_stored_stealthChop()),
-                   chop_i = TERN0(I_HAS_STEALTHCHOP, stepperI.get_stored_stealthChop()),
-                   chop_j = TERN0(J_HAS_STEALTHCHOP, stepperJ.get_stored_stealthChop()),
-                   chop_k = TERN0(K_HAS_STEALTHCHOP, stepperK.get_stored_stealthChop());
-
-        if (chop_x || chop_y || chop_z || chop_i || chop_j || chop_k) {
-          say_M569(forReplay);
-          LINEAR_AXIS_CODE(
-            if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR),
-            if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR),
-            if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR),
-            if (chop_i) SERIAL_ECHOPGM_P(SP_I_STR),
-            if (chop_j) SERIAL_ECHOPGM_P(SP_J_STR),
-            if (chop_k) SERIAL_ECHOPGM_P(SP_K_STR)
-          );
-          SERIAL_EOL();
-        }
+      //
+      // TMC Hybrid Threshold
+      //
+      TERN_(HYBRID_THRESHOLD, gcode.M913_report(forReplay));
 
-        const bool chop_x2 = TERN0(X2_HAS_STEALTHCHOP, stepperX2.get_stored_stealthChop()),
-                   chop_y2 = TERN0(Y2_HAS_STEALTHCHOP, stepperY2.get_stored_stealthChop()),
-                   chop_z2 = TERN0(Z2_HAS_STEALTHCHOP, stepperZ2.get_stored_stealthChop());
+      //
+      // TMC Sensorless homing thresholds
+      //
+      TERN_(USE_SENSORLESS, gcode.M914_report(forReplay));
+    #endif
 
-        if (chop_x2 || chop_y2 || chop_z2) {
-          say_M569(forReplay, PSTR("I1"));
-          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
-          SERIAL_EOL();
-        }
+    //
+    // TMC stepping mode
+    //
+    TERN_(HAS_STEALTHCHOP, gcode.M569_report(forReplay));
 
-        if (TERN0(Z3_HAS_STEALTHCHOP, stepperZ3.get_stored_stealthChop())) { say_M569(forReplay, PSTR("I2 Z"), true); }
-        if (TERN0(Z4_HAS_STEALTHCHOP, stepperZ4.get_stored_stealthChop())) { say_M569(forReplay, PSTR("I3 Z"), true); }
-
-        if (TERN0( I_HAS_STEALTHCHOP, stepperI.get_stored_stealthChop()))  { say_M569(forReplay, SP_I_STR, true); }
-        if (TERN0( J_HAS_STEALTHCHOP, stepperJ.get_stored_stealthChop()))  { say_M569(forReplay, SP_J_STR, true); }
-        if (TERN0( K_HAS_STEALTHCHOP, stepperK.get_stored_stealthChop()))  { say_M569(forReplay, SP_K_STR, true); }
-
-        if (TERN0(E0_HAS_STEALTHCHOP, stepperE0.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T0 E"), true); }
-        if (TERN0(E1_HAS_STEALTHCHOP, stepperE1.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T1 E"), true); }
-        if (TERN0(E2_HAS_STEALTHCHOP, stepperE2.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T2 E"), true); }
-        if (TERN0(E3_HAS_STEALTHCHOP, stepperE3.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T3 E"), true); }
-        if (TERN0(E4_HAS_STEALTHCHOP, stepperE4.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T4 E"), true); }
-        if (TERN0(E5_HAS_STEALTHCHOP, stepperE5.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T5 E"), true); }
-        if (TERN0(E6_HAS_STEALTHCHOP, stepperE6.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T6 E"), true); }
-        if (TERN0(E7_HAS_STEALTHCHOP, stepperE7.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T7 E"), true); }
-
-      #endif // HAS_STEALTHCHOP
-
-    #endif // HAS_TRINAMIC_CONFIG
-
-    /**
-     * Linear Advance
-     */
-    #if ENABLED(LIN_ADVANCE)
-      CONFIG_ECHO_HEADING("Linear Advance:");
-      #if EXTRUDERS < 2
-        CONFIG_ECHO_MSG("  M900 K", planner.extruder_advance_K[0]);
-      #else
-        LOOP_L_N(i, EXTRUDERS)
-          CONFIG_ECHO_MSG("  M900 T", i, " K", planner.extruder_advance_K[i]);
-      #endif
-    #endif
+    //
+    // Linear Advance
+    //
+    TERN_(LIN_ADVANCE, gcode.M900_report(forReplay));
 
-    #if EITHER(HAS_MOTOR_CURRENT_SPI, HAS_MOTOR_CURRENT_PWM)
-      CONFIG_ECHO_HEADING("Stepper motor currents:");
-      CONFIG_ECHO_START();
-      #if HAS_MOTOR_CURRENT_PWM
-        SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
-            PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
-                  , SP_Z_STR, stepper.motor_current_setting[1] // Z
-                  , SP_E_STR, stepper.motor_current_setting[2] // E
-        );
-      #elif HAS_MOTOR_CURRENT_SPI
-        SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
-        LOOP_LOGICAL_AXES(q) {                                 // X Y Z (I J K) E (map to X Y Z (I J K) E0 by default)
-          SERIAL_CHAR(' ', axis_codes[q]);
-          SERIAL_ECHO(stepper.motor_current_setting[q]);
-        }
-        SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
-        SERIAL_ECHOLN(stepper.motor_current_setting[4]);
-      #endif
-    #elif HAS_MOTOR_CURRENT_I2C                                // i2c-based has any number of values
-      // Values sent over i2c are not stored.
-      // Indexes map directly to drivers, not axes.
-    #elif HAS_MOTOR_CURRENT_DAC                                // DAC-based has 4 values, for X Y Z (I J K) E
-      // Values sent over i2c are not stored. Uses indirect mapping.
+    //
+    // Motor Current (SPI or PWM)
+    //
+    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+      gcode.M907_report(forReplay);
     #endif
 
-    /**
-     * Advanced Pause filament load & unload lengths
-     */
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      CONFIG_ECHO_HEADING("Filament load/unload lengths:");
-      #if EXTRUDERS == 1
-        say_M603(forReplay);
-        SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
-      #else
-        auto echo_603 = [](const bool f, const uint8_t n) { say_M603(f); SERIAL_ECHOLNPAIR("T", n, " L", LINEAR_UNIT(fc_settings[n].load_length), " U", LINEAR_UNIT(fc_settings[n].unload_length)); };
-        LOOP_L_N(i, EXTRUDERS) echo_603(forReplay, i);
-      #endif
-    #endif
+    //
+    // Advanced Pause filament load & unload lengths
+    //
+    TERN_(ADVANCED_PAUSE_FEATURE, gcode.M603_report(forReplay));
 
-    #if HAS_MULTI_EXTRUDER
-      CONFIG_ECHO_HEADING("Tool-changing:");
-      CONFIG_ECHO_START();
-      M217_report(true);
-    #endif
+    //
+    // Tool-changing Parameters
+    //
+    TERN_(HAS_MULTI_EXTRUDER, gcode.M217_report(forReplay));
 
-    #if ENABLED(BACKLASH_GCODE)
-      CONFIG_ECHO_HEADING("Backlash compensation:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M425 F"), backlash.get_correction()
-        , LIST_N(DOUBLE(LINEAR_AXES),
-            SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x),
-            SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y),
-            SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z),
-            SP_I_STR, LINEAR_UNIT(backlash.distance_mm.i),
-            SP_J_STR, LINEAR_UNIT(backlash.distance_mm.j),
-            SP_K_STR, LINEAR_UNIT(backlash.distance_mm.k)
-          )
-        #ifdef BACKLASH_SMOOTHING_MM
-          , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
-        #endif
-      );
-    #endif
+    //
+    // Backlash Compensation
+    //
+    TERN_(BACKLASH_GCODE, gcode.M425_report(forReplay));
 
-    #if HAS_FILAMENT_SENSOR
-      CONFIG_ECHO_HEADING("Filament runout sensor:");
-      CONFIG_ECHO_MSG(
-        "  M412 S", runout.enabled
-        #if HAS_FILAMENT_RUNOUT_DISTANCE
-          , " D", LINEAR_UNIT(runout.runout_distance())
-        #endif
-      );
-    #endif
+    //
+    // Filament Runout Sensor
+    //
+    TERN_(HAS_FILAMENT_SENSOR, gcode.M412_report(forReplay));
 
     #if HAS_ETHERNET
-      CONFIG_ECHO_HEADING("Ethernet:");
-      if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }
+      CONFIG_ECHO_HEADING("Ethernet");
+      if (!forReplay) ETH0_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
-      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M552_report();
-      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M553_report();
-      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M554_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M552_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M553_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); gcode.M554_report();
     #endif
 
-    #if HAS_MULTI_LANGUAGE
-      CONFIG_ECHO_HEADING("UI Language:");
-      CONFIG_ECHO_MSG("  M414 S", ui.language);
-    #endif
+    TERN_(HAS_MULTI_LANGUAGE, gcode.M414_report(forReplay));
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ‚ú® Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f2d2aeee92..c24a63ee51 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -64,23 +64,23 @@
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
-#endif
-
-#if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "../lcd/e3v2/enhanced/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "../lcd/e3v2/jyersui/dwin.h"
 #endif
 
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if HAS_SERVOS && HAS_SERVO_ANGLES
   #define EEPROM_NUM_SERVOS NUM_SERVOS
 #else
@@ -434,28 +434,29 @@ typedef struct SettingsDataStruct {
   // BACKLASH_COMPENSATION
   //
   xyz_float_t backlash_distance_mm;                     // M425 X Y Z
   uint8_t backlash_correction;                          // M425 F
   float backlash_smoothing_mm;                          // M425 S
 
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
-    // This is a significant hardware change; don't reserve space when not present
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
-  // DWIN_CREALITY_LCD_JYERSUI
+  // Ender-3 V2 DWIN
   //
-  #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+    uint8_t dwin_data[eeprom_data_size];
+  #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
   #endif
 
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
@@ -1351,23 +1352,30 @@ void MarlinSettings::postprocess() {
     #if ENABLED(EXTENSIBLE_UI)
     {
       char extui_data[ExtUI::eeprom_data_size] = { 0 };
       ExtUI::onStoreSettings(extui_data);
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
     }
     #endif
 
     //
-    // Creality UI Settings
+    // Creality DWIN User Data
     //
-    #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+    {
+      char dwin_data[eeprom_data_size] = { 0 };
+      DWIN_StoreSettings(dwin_data);
+      _FIELD_TEST(dwin_data);
+      EEPROM_WRITE(dwin_data);
+    }
+    #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
     {
       char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
       CrealityDWIN.Save_Settings(dwin_settings);
       _FIELD_TEST(dwin_settings);
       EEPROM_WRITE(dwin_settings);
     }
     #endif
 
     //
     // Case Light Brightness
@@ -1481,20 +1489,22 @@ void MarlinSettings::postprocess() {
     uint16_t stored_crc;
     EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      TERN_(DWIN_CREALITY_LCD_ENHANCED, ui.set_status(GET_TEXT(MSG_ERR_EEPROM_VERSION)));
+
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
 
       // Number of esteppers may change
@@ -2242,23 +2252,30 @@ void MarlinSettings::postprocess() {
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
       }
       #endif
 
       //
-      // Creality UI Settings
+      // Creality DWIN User Data
       //
-      #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+      #if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+      {
+        const char dwin_data[eeprom_data_size] = { 0 };
+        _FIELD_TEST(dwin_data);
+        EEPROM_READ(dwin_data);
+        if (!validating) DWIN_LoadSettings(dwin_data);
+      }
+      #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
       {
         const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
         _FIELD_TEST(dwin_settings);
         EEPROM_READ(dwin_settings);
         if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
       }
       #endif
 
       //
       // Case Light Brightness
@@ -2333,20 +2350,21 @@ void MarlinSettings::postprocess() {
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        TERN_(DWIN_CREALITY_LCD_ENHANCED, ui.set_status(GET_TEXT(MSG_ERR_EEPROM_CRC)));
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 
@@ -2649,21 +2667,21 @@ void MarlinSettings::reset() {
   #if ENABLED(BACKLASH_GCODE)
     backlash.correction = (BACKLASH_CORRECTION) * 255;
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     backlash.distance_mm = tmp;
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
-
+  TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_SetDataDefaults());
   TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //

commit 43a9c71ef7a1c9e9e294707017d372d344c774ce
Author: Jyers <76993396+Jyers@users.noreply.github.com>
Date:   Mon Sep 6 21:06:27 2021 -0700

    ‚ú® Ender-3 V2 with Jyers UI (#22422)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 632f95558d..f2d2aeee92 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -66,20 +66,24 @@
 #endif
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
   #include "../feature/z_stepper_align.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../lcd/extui/ui_api.h"
 #endif
 
+#if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "../lcd/e3v2/jyersui/dwin.h"
+#endif
+
 #if HAS_SERVOS
   #include "servo.h"
 #endif
 
 #if HAS_SERVOS && HAS_SERVO_ANGLES
   #define EEPROM_NUM_SERVOS NUM_SERVOS
 #else
   #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
 #endif
 
@@ -434,20 +438,27 @@ typedef struct SettingsDataStruct {
   float backlash_smoothing_mm;                          // M425 S
 
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
     // This is a significant hardware change; don't reserve space when not present
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
+  //
+  // DWIN_CREALITY_LCD_JYERSUI
+  //
+  #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    uint8_t dwin_settings[CrealityDWIN.eeprom_data_size];
+  #endif
+
   //
   // CASELIGHT_USES_BRIGHTNESS
   //
   #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
   // PASSWORD_FEATURE
   //
@@ -1339,20 +1350,32 @@ void MarlinSettings::postprocess() {
     //
     #if ENABLED(EXTENSIBLE_UI)
     {
       char extui_data[ExtUI::eeprom_data_size] = { 0 };
       ExtUI::onStoreSettings(extui_data);
       _FIELD_TEST(extui_data);
       EEPROM_WRITE(extui_data);
     }
     #endif
 
+    //
+    // Creality UI Settings
+    //
+    #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+    {
+      char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+      CrealityDWIN.Save_Settings(dwin_settings);
+      _FIELD_TEST(dwin_settings);
+      EEPROM_WRITE(dwin_settings);
+    }
+    #endif
+
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
     // Password feature
     //
@@ -2218,20 +2241,32 @@ void MarlinSettings::postprocess() {
       //
       #if ENABLED(EXTENSIBLE_UI)
       { // This is a significant hardware change; don't reserve EEPROM space when not present
         const char extui_data[ExtUI::eeprom_data_size] = { 0 };
         _FIELD_TEST(extui_data);
         EEPROM_READ(extui_data);
         if (!validating) ExtUI::onLoadSettings(extui_data);
       }
       #endif
 
+      //
+      // Creality UI Settings
+      //
+      #if ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+      {
+        const char dwin_settings[CrealityDWIN.eeprom_data_size] = { 0 };
+        _FIELD_TEST(dwin_settings);
+        EEPROM_READ(dwin_settings);
+        if (!validating) CrealityDWIN.Load_Settings(dwin_settings);
+      }
+      #endif
+
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 
       //
       // Password feature
@@ -2615,20 +2650,22 @@ void MarlinSettings::reset() {
     backlash.correction = (BACKLASH_CORRECTION) * 255;
     constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
     backlash.distance_mm = tmp;
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 
+  TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Reset_Settings());
+
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());
 

commit e33e101850797f4d3edecd4eb18e9ae63c89ef13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 29 20:54:51 2021 -0500

    üé® Tweak pins, comment formatting

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fca33c98c2..632f95558d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2390,27 +2390,29 @@ void MarlinSettings::postprocess() {
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
       DEBUG_ECHOLNPAIR("?Invalid slot.\n", s, " mesh slots available.");
       UNUSED(s);
     }
 
-    const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
-                                                                                  // is a placeholder for the size of the MAT; the MAT will always
-                                                                                  // live at the very end of the eeprom
+    // 128 (+1 because of the change to capacity rather than last valid address)
+    // is a placeholder for the size of the MAT; the MAT will always
+    // live at the very end of the eeprom
+    const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129;
 
     uint16_t MarlinSettings::meshes_start_index() {
-      return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
-                                                          // or down a little bit without disrupting the mesh data
+      // Pad the end of configuration data so it can float up
+      // or down a little bit without disrupting the mesh data
+      return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;
     }
 
     #define MESH_STORE_SIZE sizeof(TERN(OPTIMIZED_MESH_STORAGE, mesh_store_t, ubl.z_values))
 
     uint16_t MarlinSettings::calc_num_meshes() {
       return (meshes_end - meshes_start_index()) / MESH_STORE_SIZE;
     }
 
     int MarlinSettings::mesh_slot_offset(const int8_t slot) {
       return meshes_end - (slot + 1) * MESH_STORE_SIZE;

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 47c1314e28..fca33c98c2 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2548,23 +2548,21 @@ void MarlinSettings::reset() {
     #endif
     #if LINEAR_AXES >= 6 && !defined(DEFAULT_KJERK)
       #define DEFAULT_KJERK 0
     #endif
     planner.max_jerk.set(
       LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_IJERK, DEFAULT_JJERK, DEFAULT_KJERK)
     );
     TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK);
   #endif
 
-  #if HAS_JUNCTION_DEVIATION
-    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
-  #endif
+  TERN_(HAS_JUNCTION_DEVIATION, planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM));
 
   #if HAS_SCARA_OFFSET
     scara_home_offset.reset();
   #elif HAS_HOME_OFFSET
     home_offset.reset();
   #endif
 
   TERN_(HAS_HOTEND_OFFSET, reset_hotend_offsets());
 
   //
@@ -3144,23 +3142,21 @@ void MarlinSettings::reset() {
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
       , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
       , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
     );
 
     CONFIG_ECHO_HEADING(
       "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
-      #if HAS_JUNCTION_DEVIATION
-        " J<junc_dev>"
-      #endif
+      TERN_(HAS_JUNCTION_DEVIATION, " J<junc_dev>")
       #if HAS_CLASSIC_JERK
         " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
         TERN_(HAS_CLASSIC_E_JERK, " E<max_e_jerk>")
       #endif
     );
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
       , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
       , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)

commit 1555db237e841c754931cbe43e48ebae14c6fdc5
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Aug 13 05:40:52 2021 +0200

    üö∏ Fewer CRs in settings report (#22560)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b30c82260f..47c1314e28 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2313,21 +2313,20 @@ void MarlinSettings::postprocess() {
         DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           ubl.report_state();
 
           if (!ubl.sanity_check()) {
-            SERIAL_EOL();
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               ubl.echo_name();
               DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
             #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
               ubl.echo_name();
@@ -3259,21 +3258,20 @@ void MarlinSettings::reset() {
           }
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
           SERIAL_EOL();
           ubl.report_state();
-          SERIAL_EOL();
           config_heading(false, PSTR("Active Mesh Slot: "), false);
           SERIAL_ECHOLN(ubl.storage_slot);
           config_heading(false, PSTR("EEPROM can hold "), false);
           SERIAL_ECHO(calc_num_meshes());
           SERIAL_ECHOLNPGM(" meshes.\n");
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -3879,17 +3877,17 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Ethernet:");
       if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M552_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M553_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M554_report();
     #endif
 
     #if HAS_MULTI_LANGUAGE
       CONFIG_ECHO_HEADING("UI Language:");
-      SERIAL_ECHO_MSG("  M414 S", ui.language);
+      CONFIG_ECHO_MSG("  M414 S", ui.language);
     #endif
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit 1e33c1a2a78392e9182442db043384b0f96cca20
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 1 14:28:53 2021 -0500

    M256 LCD brightness (#22478)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 33e6b15f9a..b30c82260f 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V83"
+#define EEPROM_VERSION "V84"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -346,20 +346,25 @@ typedef struct SettingsDataStruct {
   //
   // Power monitor
   //
   uint8_t power_monitor_flags;                          // M430 I V W
 
   //
   // HAS_LCD_CONTRAST
   //
   int16_t lcd_contrast;                                 // M250 C
 
+  //
+  // HAS_LCD_BRIGHTNESS
+  //
+  uint8_t lcd_brightness;                               // M256 B
+
   //
   // Controller fan settings
   //
   controllerFan_settings_t controllerFan_settings;      // M710
 
   //
   // POWER_LOSS_RECOVERY
   //
   bool recovery_enabled;                                // M413 S
 
@@ -992,31 +997,33 @@ void MarlinSettings::postprocess() {
       #endif
       _FIELD_TEST(power_monitor_flags);
       EEPROM_WRITE(power_monitor_flags);
     }
 
     //
     // LCD Contrast
     //
     {
       _FIELD_TEST(lcd_contrast);
-
-      const int16_t lcd_contrast =
-        #if HAS_LCD_CONTRAST
-          ui.contrast
-        #else
-          127
-        #endif
-      ;
+      const int16_t lcd_contrast = TERN(HAS_LCD_CONTRAST, ui.contrast, 127);
       EEPROM_WRITE(lcd_contrast);
     }
 
+    //
+    // LCD Brightness
+    //
+    {
+      _FIELD_TEST(lcd_brightness);
+      const uint8_t lcd_brightness = TERN(HAS_LCD_BRIGHTNESS, ui.brightness, 255);
+      EEPROM_WRITE(lcd_brightness);
+    }
+
     //
     // Controller Fan
     //
     {
       _FIELD_TEST(controllerFan_settings);
       #if ENABLED(USE_CONTROLLER_FAN)
         const controllerFan_settings_t &cfs = controllerFan.settings;
       #else
         controllerFan_settings_t cfs = controllerFan_defaults;
       #endif
@@ -1839,20 +1846,30 @@ void MarlinSettings::postprocess() {
       //
       {
         _FIELD_TEST(lcd_contrast);
         int16_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
         if (!validating) {
           TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
         }
       }
 
+      //
+      // LCD Brightness
+      //
+      {
+        _FIELD_TEST(lcd_brightness);
+        uint8_t lcd_brightness;
+        EEPROM_READ(lcd_brightness);
+        TERN_(HAS_LCD_BRIGHTNESS, if (!validating) ui.set_brightness(lcd_brightness));
+      }
+
       //
       // Controller Fan
       //
       {
         _FIELD_TEST(controllerFan_settings);
         #if ENABLED(CONTROLLER_FAN_EDITABLE)
           const controllerFan_settings_t &cfs = controllerFan.settings;
         #else
           controllerFan_settings_t cfs = { 0 };
         #endif
@@ -2822,20 +2839,25 @@ void MarlinSettings::reset() {
   //
   // Power Monitor
   //
   TERN_(POWER_MONITOR, power_monitor.reset());
 
   //
   // LCD Contrast
   //
   TERN_(HAS_LCD_CONTRAST, ui.set_contrast(DEFAULT_LCD_CONTRAST));
 
+  //
+  // LCD Brightness
+  //
+  TERN_(HAS_LCD_BRIGHTNESS, ui.set_brightness(DEFAULT_LCD_BRIGHTNESS));
+
   //
   // Controller Fan
   //
   TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
 
   //
   // Power-Loss Recovery
   //
   TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
 
@@ -3399,20 +3421,25 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("User thermistors:");
       LOOP_L_N(i, USER_THERMISTORS)
         thermalManager.log_user_thermistor(i, true);
     #endif
 
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
       CONFIG_ECHO_MSG("  M250 C", ui.contrast);
     #endif
 
+    #if HAS_LCD_BRIGHTNESS
+      CONFIG_ECHO_HEADING("LCD Brightness:");
+      CONFIG_ECHO_MSG("  M256 B", ui.brightness);
+    #endif
+
     TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
       CONFIG_ECHO_MSG("  M413 S", recovery.enabled);
     #endif
 
     #if ENABLED(FWRETRACT)
       fwretract.M207_report(forReplay);
       fwretract.M208_report(forReplay);

commit ab96ada2e240e7861c6dc5a1cbff4bdab66f2b26
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 31 23:27:10 2021 -0500

    üé® Adjust settings.cpp indent

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index cc4d69f581..33e6b15f9a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1324,26 +1324,26 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(backlash_distance_mm);
       EEPROM_WRITE(backlash_distance_mm);
       EEPROM_WRITE(backlash_correction);
       EEPROM_WRITE(backlash_smoothing_mm);
     }
 
     //
     // Extensible UI User Data
     //
     #if ENABLED(EXTENSIBLE_UI)
-      {
-        char extui_data[ExtUI::eeprom_data_size] = { 0 };
-        ExtUI::onStoreSettings(extui_data);
-        _FIELD_TEST(extui_data);
-        EEPROM_WRITE(extui_data);
-      }
+    {
+      char extui_data[ExtUI::eeprom_data_size] = { 0 };
+      ExtUI::onStoreSettings(extui_data);
+      _FIELD_TEST(extui_data);
+      EEPROM_WRITE(extui_data);
+    }
     #endif
 
     //
     // Case Light Brightness
     //
     #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
@@ -2193,27 +2193,26 @@ void MarlinSettings::postprocess() {
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);
         EEPROM_READ(backlash_smoothing_mm);
       }
 
       //
       // Extensible UI User Data
       //
       #if ENABLED(EXTENSIBLE_UI)
-        // This is a significant hardware change; don't reserve EEPROM space when not present
-        {
-          const char extui_data[ExtUI::eeprom_data_size] = { 0 };
-          _FIELD_TEST(extui_data);
-          EEPROM_READ(extui_data);
-          if (!validating) ExtUI::onLoadSettings(extui_data);
-        }
+      { // This is a significant hardware change; don't reserve EEPROM space when not present
+        const char extui_data[ExtUI::eeprom_data_size] = { 0 };
+        _FIELD_TEST(extui_data);
+        EEPROM_READ(extui_data);
+        if (!validating) ExtUI::onLoadSettings(extui_data);
+      }
       #endif
 
       //
       // Case Light Brightness
       //
       #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 

commit 01ae1ced386c71bde6ae75137200ff23bd187cbb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 11 18:25:51 2021 -0500

    üö∏ M666: Fix value filter, add report (#22337)
    
    In reference to #22325

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8c3e9fb75c..cc4d69f581 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -123,21 +123,21 @@
   #include "stepper/indirection.h"
   #include "../feature/tmc_util.h"
 #endif
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #include "../feature/controllerfan.h"
 #if ENABLED(CONTROLLER_FAN_EDITABLE)
-  void M710_report(const bool forReplay);
+  void M710_report(const bool forReplay=true);
 #endif
 
 #if ENABLED(CASE_LIGHT_ENABLE)
   #include "../feature/caselight.h"
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
@@ -161,20 +161,24 @@
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();
 #endif
 
+#if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
+  void M666_report(const bool forReplay=true);
+#endif
+
 #define _EN_ITEM(N) , E##N
 
 typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
 typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
 typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
 typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
 
 #undef _EN_ITEM
 
 // Limit an index to an array size
@@ -3295,69 +3299,40 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M665 S"), segments_per_second
         , SP_P_STR, scara_home_offset.a
         , SP_T_STR, scara_home_offset.b
         , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
       );
 
     #elif ENABLED(DELTA)
 
-      CONFIG_ECHO_HEADING("Endstop adjustment:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M666 X"), LINEAR_UNIT(delta_endstop_adj.a)
-        , SP_Y_STR, LINEAR_UNIT(delta_endstop_adj.b)
-        , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
-      );
-
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
         , PSTR(" R"), LINEAR_UNIT(delta_radius)
         , PSTR(" H"), LINEAR_UNIT(delta_height)
         , PSTR(" S"), segments_per_second
         , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
         , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
         , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
         , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
         , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
         , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
       );
 
-    #elif HAS_EXTRA_ENDSTOPS
-
-      CONFIG_ECHO_HEADING("Endstop adjustment:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOPGM("  M666");
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        SERIAL_ECHOLNPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
-      #endif
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        SERIAL_ECHOLNPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
-      #endif
-      #if ENABLED(Z_MULTI_ENDSTOPS)
-        #if NUM_Z_STEPPER_DRIVERS >= 3
-          SERIAL_ECHOPAIR(" S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
-          CONFIG_ECHO_START();
-          SERIAL_ECHOPAIR("  M666 S3 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
-          #if NUM_Z_STEPPER_DRIVERS >= 4
-            CONFIG_ECHO_START();
-            SERIAL_ECHOPAIR("  M666 S4 Z", LINEAR_UNIT(endstops.z4_endstop_adj));
-          #endif
-        #else
-          SERIAL_ECHOLNPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
-        #endif
-      #endif
+    #endif
 
-    #endif // [XYZ]_DUAL_ENDSTOPS
+    #if EITHER(DELTA, HAS_EXTRA_ENDSTOPS)
+      M666_report(forReplay);
+    #endif
 
     #if PREHEAT_COUNT
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       LOOP_L_N(i, PREHEAT_COUNT) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
           PSTR("  M145 S"), i
           #if HAS_HOTEND
             , PSTR(" H"), parser.to_temp_units(ui.material_preset[i].hotend_temp)

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    üé® Check flags without ENABLED

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 27ba7cbc75..8c3e9fb75c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3811,24 +3811,24 @@ void MarlinSettings::reset() {
         );
       #elif HAS_MOTOR_CURRENT_SPI
         SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
         LOOP_LOGICAL_AXES(q) {                                 // X Y Z (I J K) E (map to X Y Z (I J K) E0 by default)
           SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
         SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
         SERIAL_ECHOLN(stepper.motor_current_setting[4]);
       #endif
-    #elif ENABLED(HAS_MOTOR_CURRENT_I2C)                       // i2c-based has any number of values
+    #elif HAS_MOTOR_CURRENT_I2C                                // i2c-based has any number of values
       // Values sent over i2c are not stored.
       // Indexes map directly to drivers, not axes.
-    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                       // DAC-based has 4 values, for X Y Z (I J K) E
+    #elif HAS_MOTOR_CURRENT_DAC                                // DAC-based has 4 values, for X Y Z (I J K) E
       // Values sent over i2c are not stored. Uses indirect mapping.
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);

commit c2f67cf8ee5625b869d5cded06c6df333aa1af73
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Jun 11 22:53:23 2021 +0200

    ‚úèÔ∏è Six Linear Axes followup (Fix M503) (#22112)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0a88d63e8c..27ba7cbc75 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3156,21 +3156,21 @@ void MarlinSettings::reset() {
           , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
         #endif
       #endif
     );
 
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
         #if IS_CARTESIAN
-          LIST_N(LINEAR_AXES,
+          LIST_N(DOUBLE(LINEAR_AXES),
             PSTR("  M206 X"), LINEAR_UNIT(home_offset.x),
             SP_Y_STR, LINEAR_UNIT(home_offset.y),
             SP_Z_STR, LINEAR_UNIT(home_offset.z),
             SP_I_STR, LINEAR_UNIT(home_offset.i),
             SP_J_STR, LINEAR_UNIT(home_offset.j),
             SP_K_STR, LINEAR_UNIT(home_offset.k)
           )
         #else
           PSTR("  M206 Z"), LINEAR_UNIT(home_offset.z)
         #endif

commit e31c26748197bdeb8ad7aa01ae34299d9d7136f3
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Jun 7 06:23:23 2021 +0200

    ‚úèÔ∏è Six Linear Axes followup (Hybrid Threshold init) (#22068)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index aae0f97361..0a88d63e8c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1168,21 +1168,21 @@ void MarlinSettings::postprocess() {
         TERN_(E3_HAS_STEALTHCHOP, tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs());
         TERN_(E4_HAS_STEALTHCHOP, tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs());
         TERN_(E5_HAS_STEALTHCHOP, tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs());
         TERN_(E6_HAS_STEALTHCHOP, tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs());
         TERN_(E7_HAS_STEALTHCHOP, tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs());
       #else
         #define _EN_ITEM(N) , .E##N =  30
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
           LINEAR_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3),
           .X2 = 100, .Y2 = 100, .Z2 = 3, .Z3 = 3, .Z4 = 3
-          REPEAT(EXTRUDERS, _EN_ITEM)
+          REPEAT(E_STEPPERS, _EN_ITEM)
         };
         #undef _EN_ITEM
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
     //
     {

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fc4fdc1f92..aae0f97361 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -161,24 +161,28 @@
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();
 #endif
 
-typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
-typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
-typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
+#define _EN_ITEM(N) , E##N
+
+typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stepper_current_t;
+typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_hybrid_threshold_t;
+typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4;                              } tmc_sgt_t;
+typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(E_STEPPERS, _EN_ITEM); } tmc_stealth_enabled_t;
+
+#undef _EN_ITEM
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 /**
@@ -380,21 +384,21 @@ typedef struct SettingsDataStruct {
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
     #define MOTOR_CURRENT_COUNT LINEAR_AXES
   #endif
-  uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E
+  uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E ...
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
   //
   skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
@@ -647,21 +651,21 @@ void MarlinSettings::postprocess() {
     {
       EEPROM_WRITE(planner.settings);
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
           dummyf = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummyf);
         #endif
       #else
-        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4);
+        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4, 0.4, 0.4, 0.4);
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
       TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
     // Home Offset
     //
@@ -1080,20 +1084,29 @@ void MarlinSettings::postprocess() {
       #if HAS_TRINAMIC_CONFIG
         #if AXIS_IS_TMC(X)
           tmc_stepper_current.X = stepperX.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y)
           tmc_stepper_current.Y = stepperY.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
           tmc_stepper_current.Z = stepperZ.getMilliamps();
         #endif
+        #if AXIS_IS_TMC(I)
+          tmc_stepper_current.I = stepperI.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(J)
+          tmc_stepper_current.J = stepperJ.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(K)
+          tmc_stepper_current.K = stepperK.getMilliamps();
+        #endif
         #if AXIS_IS_TMC(X2)
           tmc_stepper_current.X2 = stepperX2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y2)
           tmc_stepper_current.Y2 = stepperY2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z2)
           tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z3)
@@ -1131,152 +1144,100 @@ void MarlinSettings::postprocess() {
     }
 
     //
     // TMC Hybrid Threshold, and placeholder values
     //
     {
       _FIELD_TEST(tmc_hybrid_threshold);
 
       #if ENABLED(HYBRID_THRESHOLD)
         tmc_hybrid_threshold_t tmc_hybrid_threshold{0};
-        #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_hybrid_threshold.X = stepperX.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_hybrid_threshold.Y = stepperY.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_hybrid_threshold.Z = stepperZ.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
-          tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
-          tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
-          tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
-          tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E5)
-          tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E6)
-          tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E7)
-          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
-        #endif
+        TERN_(X_HAS_STEALTHCHOP,  tmc_hybrid_threshold.X =  stepperX.get_pwm_thrs());
+        TERN_(Y_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Y =  stepperY.get_pwm_thrs());
+        TERN_(Z_HAS_STEALTHCHOP,  tmc_hybrid_threshold.Z =  stepperZ.get_pwm_thrs());
+        TERN_(I_HAS_STEALTHCHOP,  tmc_hybrid_threshold.I =  stepperI.get_pwm_thrs());
+        TERN_(J_HAS_STEALTHCHOP,  tmc_hybrid_threshold.J =  stepperJ.get_pwm_thrs());
+        TERN_(K_HAS_STEALTHCHOP,  tmc_hybrid_threshold.K =  stepperK.get_pwm_thrs());
+        TERN_(X2_HAS_STEALTHCHOP, tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs());
+        TERN_(Y2_HAS_STEALTHCHOP, tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs());
+        TERN_(Z2_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs());
+        TERN_(Z3_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs());
+        TERN_(Z4_HAS_STEALTHCHOP, tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs());
+        TERN_(E0_HAS_STEALTHCHOP, tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs());
+        TERN_(E1_HAS_STEALTHCHOP, tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs());
+        TERN_(E2_HAS_STEALTHCHOP, tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs());
+        TERN_(E3_HAS_STEALTHCHOP, tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs());
+        TERN_(E4_HAS_STEALTHCHOP, tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs());
+        TERN_(E5_HAS_STEALTHCHOP, tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs());
+        TERN_(E6_HAS_STEALTHCHOP, tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs());
+        TERN_(E7_HAS_STEALTHCHOP, tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs());
       #else
+        #define _EN_ITEM(N) , .E##N =  30
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
-          LINEAR_AXIS_LIST(.X = 100, .Y = 100, .Z = 3),
-          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
-          .E0 =  30, .E1 =  30, .E2 =  30, .E3 =  30,
-          .E4 =  30, .E5 =  30, .E6 =  30, .E7 =  30
+          LINEAR_AXIS_LIST(.X = 100, .Y = 100, .Z = 3, .I = 3, .J = 3, .K = 3),
+          .X2 = 100, .Y2 = 100, .Z2 = 3, .Z3 = 3, .Z4 = 3
+          REPEAT(EXTRUDERS, _EN_ITEM)
         };
+        #undef _EN_ITEM
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
     //
     {
       tmc_sgt_t tmc_sgt{0};
       #if USE_SENSORLESS
-        TERN_(X_SENSORLESS,  tmc_sgt.X  = stepperX.homing_threshold());
+        LINEAR_AXIS_CODE(
+          TERN_(X_SENSORLESS, tmc_sgt.X = stepperX.homing_threshold()),
+          TERN_(Y_SENSORLESS, tmc_sgt.Y = stepperY.homing_threshold()),
+          TERN_(Z_SENSORLESS, tmc_sgt.Z = stepperZ.homing_threshold()),
+          TERN_(I_SENSORLESS, tmc_sgt.I = stepperI.homing_threshold()),
+          TERN_(J_SENSORLESS, tmc_sgt.J = stepperJ.homing_threshold()),
+          TERN_(K_SENSORLESS, tmc_sgt.K = stepperK.homing_threshold())
+        );
         TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
-        TERN_(Y_SENSORLESS,  tmc_sgt.Y  = stepperY.homing_threshold());
         TERN_(Y2_SENSORLESS, tmc_sgt.Y2 = stepperY2.homing_threshold());
-        TERN_(Z_SENSORLESS,  tmc_sgt.Z  = stepperZ.homing_threshold());
         TERN_(Z2_SENSORLESS, tmc_sgt.Z2 = stepperZ2.homing_threshold());
         TERN_(Z3_SENSORLESS, tmc_sgt.Z3 = stepperZ3.homing_threshold());
         TERN_(Z4_SENSORLESS, tmc_sgt.Z4 = stepperZ4.homing_threshold());
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
 
     //
     // TMC stepping mode
     //
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
       tmc_stealth_enabled_t tmc_stealth_enabled = { false };
-      #if AXIS_HAS_STEALTHCHOP(X)
-        tmc_stealth_enabled.X = stepperX.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Y)
-        tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z)
-        tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(X2)
-        tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Y2)
-        tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z2)
-        tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z3)
-        tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(Z4)
-        tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E0)
-        tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E1)
-        tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E2)
-        tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E3)
-        tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E4)
-        tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E5)
-        tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E6)
-        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop();
-      #endif
-      #if AXIS_HAS_STEALTHCHOP(E7)
-        tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop();
-      #endif
+      TERN_(X_HAS_STEALTHCHOP,  tmc_stealth_enabled.X  = stepperX.get_stored_stealthChop());
+      TERN_(Y_HAS_STEALTHCHOP,  tmc_stealth_enabled.Y  = stepperY.get_stored_stealthChop());
+      TERN_(Z_HAS_STEALTHCHOP,  tmc_stealth_enabled.Z  = stepperZ.get_stored_stealthChop());
+      TERN_(I_HAS_STEALTHCHOP,  tmc_stealth_enabled.I  = stepperI.get_stored_stealthChop());
+      TERN_(J_HAS_STEALTHCHOP,  tmc_stealth_enabled.J  = stepperJ.get_stored_stealthChop());
+      TERN_(K_HAS_STEALTHCHOP,  tmc_stealth_enabled.K  = stepperK.get_stored_stealthChop());
+      TERN_(X2_HAS_STEALTHCHOP, tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop());
+      TERN_(Y2_HAS_STEALTHCHOP, tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop());
+      TERN_(Z2_HAS_STEALTHCHOP, tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop());
+      TERN_(Z3_HAS_STEALTHCHOP, tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop());
+      TERN_(Z4_HAS_STEALTHCHOP, tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop());
+      TERN_(E0_HAS_STEALTHCHOP, tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop());
+      TERN_(E1_HAS_STEALTHCHOP, tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop());
+      TERN_(E2_HAS_STEALTHCHOP, tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop());
+      TERN_(E3_HAS_STEALTHCHOP, tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop());
+      TERN_(E4_HAS_STEALTHCHOP, tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop());
+      TERN_(E5_HAS_STEALTHCHOP, tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop());
+      TERN_(E6_HAS_STEALTHCHOP, tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop());
+      TERN_(E7_HAS_STEALTHCHOP, tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop());
       EEPROM_WRITE(tmc_stealth_enabled);
     }
 
     //
     // Linear Advance
     //
     {
       _FIELD_TEST(planner_extruder_advance_K);
 
       #if ENABLED(LIN_ADVANCE)
@@ -1985,20 +1946,29 @@ void MarlinSettings::postprocess() {
             #endif
             #if AXIS_IS_TMC(Z2)
               SET_CURR(Z2);
             #endif
             #if AXIS_IS_TMC(Z3)
               SET_CURR(Z3);
             #endif
             #if AXIS_IS_TMC(Z4)
               SET_CURR(Z4);
             #endif
+            #if AXIS_IS_TMC(I)
+              SET_CURR(I);
+            #endif
+            #if AXIS_IS_TMC(J)
+              SET_CURR(J);
+            #endif
+            #if AXIS_IS_TMC(K)
+              SET_CURR(K);
+            #endif
             #if AXIS_IS_TMC(E0)
               SET_CURR(E0);
             #endif
             #if AXIS_IS_TMC(E1)
               SET_CURR(E1);
             #endif
             #if AXIS_IS_TMC(E2)
               SET_CURR(E2);
             #endif
             #if AXIS_IS_TMC(E3)
@@ -2021,152 +1991,99 @@ void MarlinSettings::postprocess() {
       }
 
       // TMC Hybrid Threshold
       {
         tmc_hybrid_threshold_t tmc_hybrid_threshold;
         _FIELD_TEST(tmc_hybrid_threshold);
         EEPROM_READ(tmc_hybrid_threshold);
 
         #if ENABLED(HYBRID_THRESHOLD)
           if (!validating) {
-            #if AXIS_HAS_STEALTHCHOP(X)
-              stepperX.set_pwm_thrs(tmc_hybrid_threshold.X);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y)
-              stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z)
-              stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(X2)
-              stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y2)
-              stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z2)
-              stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z3)
-              stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z4)
-              stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E0)
-              stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E2)
-              stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E3)
-              stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E4)
-              stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E5)
-              stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E6)
-              stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E7)
-              stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7);
-            #endif
+            TERN_(X_HAS_STEALTHCHOP,  stepperX.set_pwm_thrs(tmc_hybrid_threshold.X));
+            TERN_(Y_HAS_STEALTHCHOP,  stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y));
+            TERN_(Z_HAS_STEALTHCHOP,  stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z));
+            TERN_(X2_HAS_STEALTHCHOP, stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2));
+            TERN_(Y2_HAS_STEALTHCHOP, stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2));
+            TERN_(Z2_HAS_STEALTHCHOP, stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2));
+            TERN_(Z3_HAS_STEALTHCHOP, stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3));
+            TERN_(Z4_HAS_STEALTHCHOP, stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4));
+            TERN_(I_HAS_STEALTHCHOP,  stepperI.set_pwm_thrs(tmc_hybrid_threshold.I));
+            TERN_(J_HAS_STEALTHCHOP,  stepperJ.set_pwm_thrs(tmc_hybrid_threshold.J));
+            TERN_(K_HAS_STEALTHCHOP,  stepperK.set_pwm_thrs(tmc_hybrid_threshold.K));
+            TERN_(E0_HAS_STEALTHCHOP, stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0));
+            TERN_(E1_HAS_STEALTHCHOP, stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1));
+            TERN_(E2_HAS_STEALTHCHOP, stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2));
+            TERN_(E3_HAS_STEALTHCHOP, stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3));
+            TERN_(E4_HAS_STEALTHCHOP, stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4));
+            TERN_(E5_HAS_STEALTHCHOP, stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5));
+            TERN_(E6_HAS_STEALTHCHOP, stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6));
+            TERN_(E7_HAS_STEALTHCHOP, stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7));
           }
         #endif
       }
 
       //
       // TMC StallGuard threshold.
       //
       {
         tmc_sgt_t tmc_sgt;
         _FIELD_TEST(tmc_sgt);
         EEPROM_READ(tmc_sgt);
         #if USE_SENSORLESS
           if (!validating) {
-            TERN_(X_SENSORLESS,  stepperX.homing_threshold(tmc_sgt.X));
+            LINEAR_AXIS_CODE(
+              TERN_(X_SENSORLESS, stepperX.homing_threshold(tmc_sgt.X)),
+              TERN_(Y_SENSORLESS, stepperY.homing_threshold(tmc_sgt.Y)),
+              TERN_(Z_SENSORLESS, stepperZ.homing_threshold(tmc_sgt.Z)),
+              TERN_(I_SENSORLESS, stepperI.homing_threshold(tmc_sgt.I)),
+              TERN_(J_SENSORLESS, stepperJ.homing_threshold(tmc_sgt.J)),
+              TERN_(K_SENSORLESS, stepperK.homing_threshold(tmc_sgt.K))
+            );
             TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
-            TERN_(Y_SENSORLESS,  stepperY.homing_threshold(tmc_sgt.Y));
             TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(tmc_sgt.Y2));
-            TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(tmc_sgt.Z));
             TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(tmc_sgt.Z2));
             TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
             TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
           }
         #endif
       }
 
       // TMC stepping mode
       {
         _FIELD_TEST(tmc_stealth_enabled);
 
         tmc_stealth_enabled_t tmc_stealth_enabled;
         EEPROM_READ(tmc_stealth_enabled);
 
         #if HAS_TRINAMIC_CONFIG
 
           #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
           if (!validating) {
-            #if AXIS_HAS_STEALTHCHOP(X)
-              SET_STEPPING_MODE(X);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y)
-              SET_STEPPING_MODE(Y);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z)
-              SET_STEPPING_MODE(Z);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(X2)
-              SET_STEPPING_MODE(X2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Y2)
-              SET_STEPPING_MODE(Y2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z2)
-              SET_STEPPING_MODE(Z2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z3)
-              SET_STEPPING_MODE(Z3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(Z4)
-              SET_STEPPING_MODE(Z4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E0)
-              SET_STEPPING_MODE(E0);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              SET_STEPPING_MODE(E1);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E2)
-              SET_STEPPING_MODE(E2);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E3)
-              SET_STEPPING_MODE(E3);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E4)
-              SET_STEPPING_MODE(E4);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E5)
-              SET_STEPPING_MODE(E5);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E6)
-              SET_STEPPING_MODE(E6);
-            #endif
-            #if AXIS_HAS_STEALTHCHOP(E7)
-              SET_STEPPING_MODE(E7);
-            #endif
+            TERN_(X_HAS_STEALTHCHOP,  SET_STEPPING_MODE(X));
+            TERN_(Y_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Y));
+            TERN_(Z_HAS_STEALTHCHOP,  SET_STEPPING_MODE(Z));
+            TERN_(I_HAS_STEALTHCHOP,  SET_STEPPING_MODE(I));
+            TERN_(J_HAS_STEALTHCHOP,  SET_STEPPING_MODE(J));
+            TERN_(K_HAS_STEALTHCHOP,  SET_STEPPING_MODE(K));
+            TERN_(X2_HAS_STEALTHCHOP, SET_STEPPING_MODE(X2));
+            TERN_(Y2_HAS_STEALTHCHOP, SET_STEPPING_MODE(Y2));
+            TERN_(Z2_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z2));
+            TERN_(Z3_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z3));
+            TERN_(Z4_HAS_STEALTHCHOP, SET_STEPPING_MODE(Z4));
+            TERN_(E0_HAS_STEALTHCHOP, SET_STEPPING_MODE(E0));
+            TERN_(E1_HAS_STEALTHCHOP, SET_STEPPING_MODE(E1));
+            TERN_(E2_HAS_STEALTHCHOP, SET_STEPPING_MODE(E2));
+            TERN_(E3_HAS_STEALTHCHOP, SET_STEPPING_MODE(E3));
+            TERN_(E4_HAS_STEALTHCHOP, SET_STEPPING_MODE(E4));
+            TERN_(E5_HAS_STEALTHCHOP, SET_STEPPING_MODE(E5));
+            TERN_(E6_HAS_STEALTHCHOP, SET_STEPPING_MODE(E6));
+            TERN_(E7_HAS_STEALTHCHOP, SET_STEPPING_MODE(E7));
           }
         #endif
       }
 
       //
       // Linear Advance
       //
       {
         float extruder_advance_K[_MAX(EXTRUDERS, 1)];
         _FIELD_TEST(planner_extruder_advance_K);
@@ -2591,28 +2508,39 @@ void MarlinSettings::reset() {
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
   planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
   #if HAS_CLASSIC_JERK
     #ifndef DEFAULT_XJERK
       #define DEFAULT_XJERK 0
     #endif
-    #ifndef DEFAULT_YJERK
+    #if HAS_Y_AXIS && !defined(DEFAULT_YJERK)
       #define DEFAULT_YJERK 0
     #endif
-    #ifndef DEFAULT_ZJERK
+    #if HAS_Z_AXIS && !defined(DEFAULT_ZJERK)
       #define DEFAULT_ZJERK 0
     #endif
-    planner.max_jerk.set(LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK));
-    TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
+    #if LINEAR_AXES >= 4 && !defined(DEFAULT_IJERK)
+      #define DEFAULT_IJERK 0
+    #endif
+    #if LINEAR_AXES >= 5 && !defined(DEFAULT_JJERK)
+      #define DEFAULT_JJERK 0
+    #endif
+    #if LINEAR_AXES >= 6 && !defined(DEFAULT_KJERK)
+      #define DEFAULT_KJERK 0
+    #endif
+    planner.max_jerk.set(
+      LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_IJERK, DEFAULT_JJERK, DEFAULT_KJERK)
+    );
+    TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK);
   #endif
 
   #if HAS_JUNCTION_DEVIATION
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #endif
 
   #if HAS_SCARA_OFFSET
     scara_home_offset.reset();
   #elif HAS_HOME_OFFSET
     home_offset.reset();
@@ -2696,25 +2624,25 @@ void MarlinSettings::reset() {
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));
   TERN_(HAS_LEVELING, reset_bed_level());
 
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
-    static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
+    static_assert(COUNT(dpo) == LINEAR_AXES, "NOZZLE_TO_PROBE_OFFSET must contain offsets for each linear axis X, Y, Z....");
     #if HAS_PROBE_XY_OFFSET
       LOOP_LINEAR_AXES(a) probe.offset[a] = dpo[a];
     #else
-      probe.offset.set(0, 0, dpo[Z_AXIS]);
+      probe.offset.set(LINEAR_AXIS_LIST(0, 0, dpo[Z_AXIS], 0, 0, 0));
     #endif
   #endif
 
   //
   // Z Stepper Auto-alignment points
   //
   TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
   //
   // Servo Angles
@@ -3138,21 +3066,24 @@ void MarlinSettings::reset() {
 
     CONFIG_ECHO_HEADING("Steps per unit:");
     report_M92(!forReplay);
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
       LIST_N(DOUBLE(LINEAR_AXES),
         PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]),
         SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]),
-        SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
+        SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS]),
+        SP_I_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[I_AXIS]),
+        SP_J_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[J_AXIS]),
+        SP_K_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[K_AXIS])
       )
       #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M203 T"), i
@@ -3160,21 +3091,24 @@ void MarlinSettings::reset() {
         );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
       LIST_N(DOUBLE(LINEAR_AXES),
         PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]),
         SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]),
-        SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+        SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS]),
+        SP_I_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[I_AXIS]),
+        SP_J_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[J_AXIS]),
+        SP_K_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[K_AXIS])
       )
       #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M201 T"), i
@@ -3203,41 +3137,50 @@ void MarlinSettings::reset() {
     );
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
       , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
       , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
       #if HAS_JUNCTION_DEVIATION
         , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
       #endif
       #if HAS_CLASSIC_JERK
-        , SP_X_STR, LINEAR_UNIT(planner.max_jerk.x)
-        , SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y)
-        , SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z)
+        , LIST_N(DOUBLE(LINEAR_AXES),
+          SP_X_STR, LINEAR_UNIT(planner.max_jerk.x),
+          SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y),
+          SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z),
+          SP_I_STR, LINEAR_UNIT(planner.max_jerk.i),
+          SP_J_STR, LINEAR_UNIT(planner.max_jerk.j),
+          SP_K_STR, LINEAR_UNIT(planner.max_jerk.k)
+        )
         #if HAS_CLASSIC_E_JERK
           , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
         #endif
       #endif
     );
 
     #if HAS_M206_COMMAND
       CONFIG_ECHO_HEADING("Home offset:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
         #if IS_CARTESIAN
-            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x)
-          , SP_Y_STR, LINEAR_UNIT(home_offset.y)
-          , SP_Z_STR
+          LIST_N(LINEAR_AXES,
+            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x),
+            SP_Y_STR, LINEAR_UNIT(home_offset.y),
+            SP_Z_STR, LINEAR_UNIT(home_offset.z),
+            SP_I_STR, LINEAR_UNIT(home_offset.i),
+            SP_J_STR, LINEAR_UNIT(home_offset.j),
+            SP_K_STR, LINEAR_UNIT(home_offset.k)
+          )
         #else
-          PSTR("  M206 Z")
+          PSTR("  M206 Z"), LINEAR_UNIT(home_offset.z)
         #endif
-        , LINEAR_UNIT(home_offset.z)
       );
     #endif
 
     #if HAS_HOTEND_OFFSET
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
       LOOP_S_L_N(e, 1, HOTENDS) {
         SERIAL_ECHOPAIR_P(
           PSTR("  M218 T"), e,
           SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
@@ -3575,20 +3518,33 @@ void MarlinSettings::reset() {
       #if AXIS_IS_TMC(Z3)
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
       #endif
 
       #if AXIS_IS_TMC(Z4)
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.getMilliamps());
       #endif
 
+      #if AXIS_IS_TMC(I)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(J)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(K)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.getMilliamps());
+      #endif
+
       #if AXIS_IS_TMC(E0)
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E1)
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
       #endif
       #if AXIS_IS_TMC(E2)
         say_M906(forReplay);
@@ -3614,88 +3570,101 @@ void MarlinSettings::reset() {
         say_M906(forReplay);
         SERIAL_ECHOLNPAIR(" T7 E", stepperE7.getMilliamps());
       #endif
       SERIAL_EOL();
 
       /**
        * TMC Hybrid Threshold
        */
       #if ENABLED(HYBRID_THRESHOLD)
         CONFIG_ECHO_HEADING("Hybrid Threshold:");
-        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
+        #if X_HAS_STEALTHCHOP || Y_HAS_STEALTHCHOP || Z_HAS_STEALTHCHOP
           say_M913(forReplay);
-          #if AXIS_HAS_STEALTHCHOP(X)
+          #if X_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
           #endif
-          #if AXIS_HAS_STEALTHCHOP(Y)
+          #if Y_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
           #endif
-          #if AXIS_HAS_STEALTHCHOP(Z)
+          #if Z_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
           #endif
           SERIAL_EOL();
         #endif
 
-        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
+        #if X2_HAS_STEALTHCHOP || Y2_HAS_STEALTHCHOP || Z2_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOPGM(" I1");
-          #if AXIS_HAS_STEALTHCHOP(X2)
+          #if X2_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
           #endif
-          #if AXIS_HAS_STEALTHCHOP(Y2)
+          #if Y2_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
           #endif
-          #if AXIS_HAS_STEALTHCHOP(Z2)
+          #if Z2_HAS_STEALTHCHOP
             SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
           #endif
           SERIAL_EOL();
         #endif
 
-        #if AXIS_HAS_STEALTHCHOP(Z3)
+        #if Z3_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
         #endif
 
-        #if AXIS_HAS_STEALTHCHOP(Z4)
+        #if Z4_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.get_pwm_thrs());
         #endif
 
-        #if AXIS_HAS_STEALTHCHOP(E0)
+        #if I_HAS_STEALTHCHOP
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.get_pwm_thrs());
+        #endif
+        #if J_HAS_STEALTHCHOP
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.get_pwm_thrs());
+        #endif
+        #if K_HAS_STEALTHCHOP
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.get_pwm_thrs());
+        #endif
+
+        #if E0_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
+        #if E1_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
+        #if E2_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
+        #if E3_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
+        #if E4_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E5)
+        #if E5_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E6)
+        #if E6_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T6 E", stepperE6.get_pwm_thrs());
         #endif
-        #if AXIS_HAS_STEALTHCHOP(E7)
+        #if E7_HAS_STEALTHCHOP
           say_M913(forReplay);
           SERIAL_ECHOLNPAIR(" T7 E", stepperE7.get_pwm_thrs());
         #endif
         SERIAL_EOL();
       #endif // HYBRID_THRESHOLD
 
       /**
        * TMC Sensorless homing thresholds
        */
       #if USE_SENSORLESS
@@ -3736,107 +3705,90 @@ void MarlinSettings::reset() {
           say_M914();
           SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
         #endif
 
         #if Z4_SENSORLESS
           CONFIG_ECHO_START();
           say_M914();
           SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.homing_threshold());
         #endif
 
+        #if I_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR_P(SP_I_STR, stepperI.homing_threshold());
+        #endif
+        #if J_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR_P(SP_J_STR, stepperJ.homing_threshold());
+        #endif
+        #if K_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR_P(SP_K_STR, stepperK.homing_threshold());
+        #endif
+
       #endif // USE_SENSORLESS
 
       /**
        * TMC stepping mode
        */
       #if HAS_STEALTHCHOP
         CONFIG_ECHO_HEADING("Driver stepping mode:");
-        #if AXIS_HAS_STEALTHCHOP(X)
-          const bool chop_x = stepperX.get_stored_stealthChop();
-        #else
-          constexpr bool chop_x = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          const bool chop_y = stepperY.get_stored_stealthChop();
-        #else
-          constexpr bool chop_y = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          const bool chop_z = stepperZ.get_stored_stealthChop();
-        #else
-          constexpr bool chop_z = false;
-        #endif
-
-        if (chop_x || chop_y || chop_z) {
+        const bool chop_x = TERN0(X_HAS_STEALTHCHOP, stepperX.get_stored_stealthChop()),
+                   chop_y = TERN0(Y_HAS_STEALTHCHOP, stepperY.get_stored_stealthChop()),
+                   chop_z = TERN0(Z_HAS_STEALTHCHOP, stepperZ.get_stored_stealthChop()),
+                   chop_i = TERN0(I_HAS_STEALTHCHOP, stepperI.get_stored_stealthChop()),
+                   chop_j = TERN0(J_HAS_STEALTHCHOP, stepperJ.get_stored_stealthChop()),
+                   chop_k = TERN0(K_HAS_STEALTHCHOP, stepperK.get_stored_stealthChop());
+
+        if (chop_x || chop_y || chop_z || chop_i || chop_j || chop_k) {
           say_M569(forReplay);
-          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
-          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
-          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
+          LINEAR_AXIS_CODE(
+            if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR),
+            if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR),
+            if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR),
+            if (chop_i) SERIAL_ECHOPGM_P(SP_I_STR),
+            if (chop_j) SERIAL_ECHOPGM_P(SP_J_STR),
+            if (chop_k) SERIAL_ECHOPGM_P(SP_K_STR)
+          );
           SERIAL_EOL();
         }
 
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          const bool chop_x2 = stepperX2.get_stored_stealthChop();
-        #else
-          constexpr bool chop_x2 = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          const bool chop_y2 = stepperY2.get_stored_stealthChop();
-        #else
-          constexpr bool chop_y2 = false;
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          const bool chop_z2 = stepperZ2.get_stored_stealthChop();
-        #else
-          constexpr bool chop_z2 = false;
-        #endif
+        const bool chop_x2 = TERN0(X2_HAS_STEALTHCHOP, stepperX2.get_stored_stealthChop()),
+                   chop_y2 = TERN0(Y2_HAS_STEALTHCHOP, stepperY2.get_stored_stealthChop()),
+                   chop_z2 = TERN0(Z2_HAS_STEALTHCHOP, stepperZ2.get_stored_stealthChop());
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
           if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
           if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
           if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stored_stealthChop()) { say_M569(forReplay, PSTR("I2 Z"), true); }
-        #endif
+        if (TERN0(Z3_HAS_STEALTHCHOP, stepperZ3.get_stored_stealthChop())) { say_M569(forReplay, PSTR("I2 Z"), true); }
+        if (TERN0(Z4_HAS_STEALTHCHOP, stepperZ4.get_stored_stealthChop())) { say_M569(forReplay, PSTR("I3 Z"), true); }
 
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          if (stepperZ4.get_stored_stealthChop()) { say_M569(forReplay, PSTR("I3 Z"), true); }
-        #endif
+        if (TERN0( I_HAS_STEALTHCHOP, stepperI.get_stored_stealthChop()))  { say_M569(forReplay, SP_I_STR, true); }
+        if (TERN0( J_HAS_STEALTHCHOP, stepperJ.get_stored_stealthChop()))  { say_M569(forReplay, SP_J_STR, true); }
+        if (TERN0( K_HAS_STEALTHCHOP, stepperK.get_stored_stealthChop()))  { say_M569(forReplay, SP_K_STR, true); }
 
-        #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T0 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T1 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T2 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T3 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T4 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T5 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E6)
-          if (stepperE6.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T6 E"), true); }
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(E7)
-          if (stepperE7.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T7 E"), true); }
-        #endif
+        if (TERN0(E0_HAS_STEALTHCHOP, stepperE0.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T0 E"), true); }
+        if (TERN0(E1_HAS_STEALTHCHOP, stepperE1.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T1 E"), true); }
+        if (TERN0(E2_HAS_STEALTHCHOP, stepperE2.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T2 E"), true); }
+        if (TERN0(E3_HAS_STEALTHCHOP, stepperE3.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T3 E"), true); }
+        if (TERN0(E4_HAS_STEALTHCHOP, stepperE4.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T4 E"), true); }
+        if (TERN0(E5_HAS_STEALTHCHOP, stepperE5.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T5 E"), true); }
+        if (TERN0(E6_HAS_STEALTHCHOP, stepperE6.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T6 E"), true); }
+        if (TERN0(E7_HAS_STEALTHCHOP, stepperE7.get_stored_stealthChop())) { say_M569(forReplay, PSTR("T7 E"), true); }
 
       #endif // HAS_STEALTHCHOP
 
     #endif // HAS_TRINAMIC_CONFIG
 
     /**
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)
       CONFIG_ECHO_HEADING("Linear Advance:");
@@ -3852,31 +3804,31 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
         SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
             PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
                   , SP_Z_STR, stepper.motor_current_setting[1] // Z
                   , SP_E_STR, stepper.motor_current_setting[2] // E
         );
       #elif HAS_MOTOR_CURRENT_SPI
         SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
-        LOOP_LOGICAL_AXES(q) {                                 // X Y Z E (map to X Y Z E0 by default)
+        LOOP_LOGICAL_AXES(q) {                                 // X Y Z (I J K) E (map to X Y Z (I J K) E0 by default)
           SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
         SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
         SERIAL_ECHOLN(stepper.motor_current_setting[4]);
       #endif
     #elif ENABLED(HAS_MOTOR_CURRENT_I2C)                       // i2c-based has any number of values
       // Values sent over i2c are not stored.
       // Indexes map directly to drivers, not axes.
-    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                       // DAC-based has 4 values, for X Y Z E
+    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                       // DAC-based has 4 values, for X Y Z (I J K) E
       // Values sent over i2c are not stored. Uses indirect mapping.
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);
@@ -3894,21 +3846,24 @@ void MarlinSettings::reset() {
     #endif
 
     #if ENABLED(BACKLASH_GCODE)
       CONFIG_ECHO_HEADING("Backlash compensation:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M425 F"), backlash.get_correction()
         , LIST_N(DOUBLE(LINEAR_AXES),
             SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x),
             SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y),
-            SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
+            SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z),
+            SP_I_STR, LINEAR_UNIT(backlash.distance_mm.i),
+            SP_J_STR, LINEAR_UNIT(backlash.distance_mm.j),
+            SP_K_STR, LINEAR_UNIT(backlash.distance_mm.k)
           )
         #ifdef BACKLASH_SMOOTHING_MM
           , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
         #endif
       );
     #endif
 
     #if HAS_FILAMENT_SENSOR
       CONFIG_ECHO_HEADING("Filament runout sensor:");
       CONFIG_ECHO_MSG(

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index eae4728793..fc4fdc1f92 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -161,24 +161,24 @@
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();
 #endif
 
-typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
-typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
-typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
-typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
+typedef struct { uint16_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
+typedef struct { uint32_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
+typedef struct {  int16_t LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
+typedef struct {     bool LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 /**
@@ -647,21 +647,21 @@ void MarlinSettings::postprocess() {
     {
       EEPROM_WRITE(planner.settings);
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
         #if HAS_LINEAR_E_JERK
           dummyf = float(DEFAULT_EJERK);
           EEPROM_WRITE(dummyf);
         #endif
       #else
-        const xyze_pos_t planner_max_jerk = { 10, 10, 0.4, float(DEFAULT_EJERK) };
+        const xyze_pos_t planner_max_jerk = LOGICAL_AXIS_ARRAY(float(DEFAULT_EJERK), 10, 10, 0.4);
         EEPROM_WRITE(planner_max_jerk);
       #endif
 
       TERN_(CLASSIC_JERK, dummyf = 0.02f);
       EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
     }
 
     //
     // Home Offset
     //
@@ -1181,24 +1181,24 @@ void MarlinSettings::postprocess() {
           tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(E6)
           tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(E7)
           tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
         #endif
       #else
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
-          .X  = 100, .Y  = 100, .Z  =   3,
+          LINEAR_AXIS_LIST(.X = 100, .Y = 100, .Z = 3),
           .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
-          .E0 =  30, .E1 =  30, .E2 =  30,
-          .E3 =  30, .E4 =  30, .E5 =  30
+          .E0 =  30, .E1 =  30, .E2 =  30, .E3 =  30,
+          .E4 =  30, .E5 =  30, .E6 =  30, .E7 =  30
         };
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
 
     //
     // TMC StallGuard threshold
     //
     {
       tmc_sgt_t tmc_sgt{0};
@@ -2597,21 +2597,21 @@ void MarlinSettings::reset() {
   #if HAS_CLASSIC_JERK
     #ifndef DEFAULT_XJERK
       #define DEFAULT_XJERK 0
     #endif
     #ifndef DEFAULT_YJERK
       #define DEFAULT_YJERK 0
     #endif
     #ifndef DEFAULT_ZJERK
       #define DEFAULT_ZJERK 0
     #endif
-    planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
+    planner.max_jerk.set(LINEAR_AXIS_LIST(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK));
     TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
   #endif
 
   #if HAS_JUNCTION_DEVIATION
     planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
   #endif
 
   #if HAS_SCARA_OFFSET
     scara_home_offset.reset();
   #elif HAS_HOME_OFFSET
@@ -3135,44 +3135,48 @@ void MarlinSettings::reset() {
       #endif
 
     #endif // EXTRUDERS && !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
     report_M92(!forReplay);
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
-        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
-      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
-      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
-      #if DISABLED(DISTINCT_E_FACTORS)
+      LIST_N(DOUBLE(LINEAR_AXES),
+        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS]),
+        SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS]),
+        SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
+      )
+      #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M203 T"), i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
         );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
-        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
-      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
-      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
-      #if DISABLED(DISTINCT_E_FACTORS)
+      LIST_N(DOUBLE(LINEAR_AXES),
+        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS]),
+        SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS]),
+        SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+      )
+      #if HAS_EXTRUDERS && DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
             PSTR("  M201 T"), i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
         );
@@ -3887,23 +3891,25 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Tool-changing:");
       CONFIG_ECHO_START();
       M217_report(true);
     #endif
 
     #if ENABLED(BACKLASH_GCODE)
       CONFIG_ECHO_HEADING("Backlash compensation:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M425 F"), backlash.get_correction()
-        , SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x)
-        , SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y)
-        , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
+        , LIST_N(DOUBLE(LINEAR_AXES),
+            SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x),
+            SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y),
+            SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
+          )
         #ifdef BACKLASH_SMOOTHING_MM
           , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
         #endif
       );
     #endif
 
     #if HAS_FILAMENT_SENSOR
       CONFIG_ECHO_HEADING("Filament runout sensor:");
       CONFIG_ECHO_MSG(
         "  M412 S", runout.enabled

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 56e3c86fd4..eae4728793 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -395,21 +395,21 @@ typedef struct SettingsDataStruct {
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
   //
   skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
 
   //
   // ADVANCED_PAUSE_FEATURE
   //
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
   #endif
 
   //
   // Tool-change settings
   //
   #if HAS_MULTI_EXTRUDER
     toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
@@ -1314,21 +1314,21 @@ void MarlinSettings::postprocess() {
 
     //
     // Skew correction factors
     //
     _FIELD_TEST(planner_skew_factor);
     EEPROM_WRITE(planner.skew_factor);
 
     //
     // Advanced Pause filament load & unload lengths
     //
-    #if EXTRUDERS
+    #if HAS_EXTRUDERS
     {
       #if DISABLED(ADVANCED_PAUSE_FEATURE)
         const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
       #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
     }
     #endif
 
     //
@@ -2228,21 +2228,21 @@ void MarlinSettings::postprocess() {
               planner.skew_factor.xz = skew_factor.xz;
               planner.skew_factor.yz = skew_factor.yz;
             #endif
           }
         #endif
       }
 
       //
       // Advanced Pause filament load & unload lengths
       //
-      #if EXTRUDERS
+      #if HAS_EXTRUDERS
       {
         #if DISABLED(ADVANCED_PAUSE_FEATURE)
           fil_change_settings_t fc_settings[EXTRUDERS];
         #endif
         _FIELD_TEST(fc_settings);
         EEPROM_READ(fc_settings);
       }
       #endif
 
       //

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0ef382a71c..56e3c86fd4 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -187,21 +187,21 @@ static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   uint16_t  crc;                                        // Data Checksum
 
   //
   // DISTINCT_E_FACTORS
   //
-  uint8_t   esteppers;                                  // XYZE_N - XYZ
+  uint8_t   esteppers;                                  // DISTINCT_AXES - LINEAR_AXES
 
   planner_settings_t planner_settings;
 
   xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
   float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
 
   xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
 
   #if HAS_HOTEND_OFFSET
     xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
@@ -378,21 +378,21 @@ typedef struct SettingsDataStruct {
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
   #ifndef MOTOR_CURRENT_COUNT
-    #define MOTOR_CURRENT_COUNT 3
+    #define MOTOR_CURRENT_COUNT LINEAR_AXES
   #endif
   uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
@@ -509,21 +509,21 @@ void MarlinSettings::postprocess() {
   TERN_(PIDTEMP, thermalManager.updatePID());
 
   #if DISABLED(NO_VOLUMETRICS)
     planner.calculate_volumetric_multipliers();
   #elif EXTRUDERS
     for (uint8_t i = COUNT(planner.e_factor); i--;)
       planner.refresh_e_factor(i);
   #endif
 
   // Software endstops depend on home_offset
-  LOOP_XYZ(i) {
+  LOOP_LINEAR_AXES(i) {
     update_workspace_offset((AxisEnum)i);
     update_software_endstops((AxisEnum)i);
   }
 
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
@@ -630,23 +630,22 @@ void MarlinSettings::postprocess() {
 
     eeprom_error = false;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
     TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"
 
+    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - LINEAR_AXES;
     _FIELD_TEST(esteppers);
-
-    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - XYZ;
     EEPROM_WRITE(esteppers);
 
     //
     // Planner Motion
     //
     {
       EEPROM_WRITE(planner.settings);
 
       #if HAS_CLASSIC_JERK
         EEPROM_WRITE(planner.max_jerk);
@@ -1506,48 +1505,48 @@ void MarlinSettings::postprocess() {
       // Number of esteppers may change
       uint8_t esteppers;
       EEPROM_READ_ALWAYS(esteppers);
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
-        uint32_t tmp1[XYZ + esteppers];
-        float tmp2[XYZ + esteppers];
-        feedRate_t tmp3[XYZ + esteppers];
+        uint32_t tmp1[LINEAR_AXES + esteppers];
+        float tmp2[LINEAR_AXES + esteppers];
+        feedRate_t tmp3[LINEAR_AXES + esteppers];
         EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
         EEPROM_READ(planner.settings.min_segment_time_us);
         EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
         EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
-        if (!validating) LOOP_XYZE_N(i) {
-          const bool in = (i < esteppers + XYZ);
+        if (!validating) LOOP_DISTINCT_AXES(i) {
+          const bool in = (i < esteppers + LINEAR_AXES);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
           planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
         #if HAS_CLASSIC_JERK
           EEPROM_READ(planner.max_jerk);
           #if HAS_LINEAR_E_JERK
             EEPROM_READ(dummyf);
           #endif
         #else
-          for (uint8_t q = XYZE; q--;) EEPROM_READ(dummyf);
+          for (uint8_t q = LOGICAL_AXES; q--;) EEPROM_READ(dummyf);
         #endif
 
         EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
       }
 
       //
       // Home Offset (M206 / M665)
       //
       {
         _FIELD_TEST(home_offset);
@@ -2575,21 +2574,21 @@ void MarlinSettings::postprocess() {
     DEBUG_ERROR_MSG("EEPROM disabled");
     return false;
   }
 
 #endif // !EEPROM_SETTINGS
 
 /**
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
-  LOOP_XYZE_N(i) {
+  LOOP_DISTINCT_AXES(i) {
     planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
     planner.settings.axis_steps_per_mm[i] = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
     planner.settings.max_feedrate_mm_s[i] = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
@@ -2699,21 +2698,21 @@ void MarlinSettings::reset() {
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));
   TERN_(HAS_LEVELING, reset_bed_level());
 
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     #if HAS_PROBE_XY_OFFSET
-      LOOP_XYZ(a) probe.offset[a] = dpo[a];
+      LOOP_LINEAR_AXES(a) probe.offset[a] = dpo[a];
     #else
       probe.offset.set(0, 0, dpo[Z_AXIS]);
     #endif
   #endif
 
   //
   // Z Stepper Auto-alignment points
   //
   TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
@@ -3849,21 +3848,21 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
         SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
             PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
                   , SP_Z_STR, stepper.motor_current_setting[1] // Z
                   , SP_E_STR, stepper.motor_current_setting[2] // E
         );
       #elif HAS_MOTOR_CURRENT_SPI
         SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
-        LOOP_XYZE(q) {                                         // X Y Z E (map to X Y Z E0 by default)
+        LOOP_LOGICAL_AXES(q) {                                 // X Y Z E (map to X Y Z E0 by default)
           SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
         SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
         SERIAL_ECHOLN(stepper.motor_current_setting[4]);
       #endif
     #elif ENABLED(HAS_MOTOR_CURRENT_I2C)                       // i2c-based has any number of values
       // Values sent over i2c are not stored.
       // Indexes map directly to drivers, not axes.
     #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                       // DAC-based has 4 values, for X Y Z E

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2b20bba4fb..0ef382a71c 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2577,22 +2577,22 @@ void MarlinSettings::postprocess() {
   }
 
 #endif // !EEPROM_SETTINGS
 
 /**
  * M502 - Reset Configuration
  */
 void MarlinSettings::reset() {
   LOOP_XYZE_N(i) {
     planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
-    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
-    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
+    planner.settings.axis_steps_per_mm[i] = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+    planner.settings.max_feedrate_mm_s[i] = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
   }
 
   planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
   planner.settings.acceleration = DEFAULT_ACCELERATION;
   planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
   planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
   planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
   planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
 
   #if HAS_CLASSIC_JERK

commit 1e189506effcf6be1e681cedb396b0574a9f109e
Author: ellensp <ellensp@hotmail.com>
Date:   Tue May 18 14:16:47 2021 +1200

    Fix EEPROM_CHITCHAT (#21934)
    
    Fix #21929

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 9d65bbb744..2b20bba4fb 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -577,21 +577,25 @@ void MarlinSettings::postprocess() {
     return true;
   }
 
 #endif // SD_FIRMWARE_UPDATE
 
 #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
   static_assert(EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
                 "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
-#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+//
+// This file simply uses the DEBUG_ECHO macros to implement EEPROM_CHITCHAT.
+// For deeper debugging of EEPROM issues enable DEBUG_EEPROM_READWRITE.
+//
+#define DEBUG_OUT EITHER(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
@@ -1443,22 +1447,21 @@ void MarlinSettings::postprocess() {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
       EEPROM_WRITE(version);
       EEPROM_WRITE(final_crc);
 
       // Report storage size
-      DEBUG_ECHO_START();
-      DEBUG_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
+      DEBUG_ECHO_MSG("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
 
       eeprom_error |= size_error(eeprom_size);
     }
     EEPROM_FINISH();
 
     //
     // UBL Mesh
     //
     #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
       if (ubl.storage_slot >= 0)
@@ -1483,22 +1486,21 @@ void MarlinSettings::postprocess() {
 
     uint16_t stored_crc;
     EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
-      DEBUG_ECHO_START();
-      DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      DEBUG_ECHO_MSG("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
       IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
 
       // Number of esteppers may change
@@ -2179,23 +2181,27 @@ void MarlinSettings::postprocess() {
       //
       // Motor Current PWM
       //
       {
         _FIELD_TEST(motor_current_setting);
         uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]
           #if HAS_MOTOR_CURRENT_SPI
              = DIGIPOT_MOTOR_CURRENT
           #endif
         ;
-        DEBUG_ECHOLNPGM("DIGIPOTS Loading");
+        #if HAS_MOTOR_CURRENT_SPI
+          DEBUG_ECHO_MSG("DIGIPOTS Loading");
+        #endif
         EEPROM_READ(motor_current_setting);
-        DEBUG_ECHOLNPGM("DIGIPOTS Loaded");
+        #if HAS_MOTOR_CURRENT_SPI
+          DEBUG_ECHO_MSG("DIGIPOTS Loaded");
+        #endif
         #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
           if (!validating)
             COPY(stepper.motor_current_setting, motor_current_setting);
         #endif
       }
 
       //
       // CNC Coordinate System
       //
       {
@@ -2350,28 +2356,26 @@ void MarlinSettings::postprocess() {
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
         ui.set_language(ui_language);
       }
       #endif
 
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
-        DEBUG_ECHO_START();
-        DEBUG_ECHOLNPAIR("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
+        DEBUG_ECHO_MSG("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
-        DEBUG_ERROR_START();
-        DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        DEBUG_ERROR_MSG("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 
@@ -2447,27 +2451,22 @@ void MarlinSettings::postprocess() {
     #if ENABLED(EEPROM_AUTO_INIT)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
-      #if BOTH(EEPROM_CHITCHAT, DEBUG_OUT)
-        DEBUG_ECHOLNPGM("?Invalid slot.");
-        DEBUG_ECHO(s);
-        DEBUG_ECHOLNPGM(" mesh slots available.");
-      #else
-        UNUSED(s);
-      #endif
+      DEBUG_ECHOLNPAIR("?Invalid slot.\n", s, " mesh slots available.");
+      UNUSED(s);
     }
 
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
                                                                                   // is a placeholder for the size of the MAT; the MAT will always
                                                                                   // live at the very end of the eeprom
 
     uint16_t MarlinSettings::meshes_start_index() {
       return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
                                                           // or down a little bit without disrupting the mesh data
     }

commit 0c8a53e507fa792b114a89fe6902f4efe4ed2fe8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 11 10:47:32 2021 -0500

    :art: Misc. code cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 35b55c82f9..9d65bbb744 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1065,21 +1065,21 @@ void MarlinSettings::postprocess() {
 
       #endif
     }
 
     //
     // TMC Configuration
     //
     {
       _FIELD_TEST(tmc_stepper_current);
 
-      tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+      tmc_stepper_current_t tmc_stepper_current{0};
 
       #if HAS_TRINAMIC_CONFIG
         #if AXIS_IS_TMC(X)
           tmc_stepper_current.X = stepperX.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Y)
           tmc_stepper_current.Y = stepperY.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z)
           tmc_stepper_current.Z = stepperZ.getMilliamps();
@@ -1127,21 +1127,21 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(tmc_stepper_current);
     }
 
     //
     // TMC Hybrid Threshold, and placeholder values
     //
     {
       _FIELD_TEST(tmc_hybrid_threshold);
 
       #if ENABLED(HYBRID_THRESHOLD)
-       tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+        tmc_hybrid_threshold_t tmc_hybrid_threshold{0};
         #if AXIS_HAS_STEALTHCHOP(X)
           tmc_hybrid_threshold.X = stepperX.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
           tmc_hybrid_threshold.Y = stepperY.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
           tmc_hybrid_threshold.Z = stepperZ.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
@@ -1531,21 +1531,21 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(planner.settings.travel_acceleration);
         EEPROM_READ(planner.settings.min_feedrate_mm_s);
         EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
 
         #if HAS_CLASSIC_JERK
           EEPROM_READ(planner.max_jerk);
           #if HAS_LINEAR_E_JERK
             EEPROM_READ(dummyf);
           #endif
         #else
-          for (uint8_t q = 4; q--;) EEPROM_READ(dummyf);
+          for (uint8_t q = XYZE; q--;) EEPROM_READ(dummyf);
         #endif
 
         EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
       }
 
       //
       // Home Offset (M206 / M665)
       //
       {
         _FIELD_TEST(home_offset);
@@ -2249,21 +2249,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Backlash Compensation
       //
       {
         #if ENABLED(BACKLASH_GCODE)
           const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
           const uint8_t &backlash_correction = backlash.correction;
         #else
-          float backlash_distance_mm[XYZ];
+          xyz_float_t backlash_distance_mm;
           uint8_t backlash_correction;
         #endif
         #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
           const float &backlash_smoothing_mm = backlash.smoothing_mm;
         #else
           float backlash_smoothing_mm;
         #endif
         _FIELD_TEST(backlash_distance_mm);
         EEPROM_READ(backlash_distance_mm);
         EEPROM_READ(backlash_correction);

commit e5dc2c53215020cd2c2caeb519a51d4bd430ecc0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 11 08:30:16 2021 -0500

    Simplify macro expansion with recursion (#21859)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 07253c117a..35b55c82f9 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3873,22 +3873,22 @@ void MarlinSettings::reset() {
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);
         SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
-        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0);
-        REPEAT(EXTRUDERS, _ECHO_603)
+        auto echo_603 = [](const bool f, const uint8_t n) { say_M603(f); SERIAL_ECHOLNPAIR("T", n, " L", LINEAR_UNIT(fc_settings[n].load_length), " U", LINEAR_UNIT(fc_settings[n].unload_length)); };
+        LOOP_L_N(i, EXTRUDERS) echo_603(forReplay, i);
       #endif
     #endif
 
     #if HAS_MULTI_EXTRUDER
       CONFIG_ECHO_HEADING("Tool-changing:");
       CONFIG_ECHO_START();
       M217_report(true);
     #endif
 
     #if ENABLED(BACKLASH_GCODE)

commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 13c01954a0..07253c117a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -147,22 +147,22 @@
 
 #if HAS_ETHERNET
   #include "../feature/ethernet.h"
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   #include "../libs/buzzer.h"
 #endif
 
 #if ENABLED(DGUS_LCD_UI_MKS)
-  #include "../lcd/extui/lib/dgus/DGUSScreenHandler.h"
-  #include "../lcd/extui/lib/dgus/DGUSDisplayDef.h"
+  #include "../lcd/extui/dgus/DGUSScreenHandler.h"
+  #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();

commit f424da498a8fabf19a7bdabe23c6d843cd4a5191
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Sat Apr 24 09:16:14 2021 +0300

    ExtUI::onPostprocessSettings (#21683)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 4273c4b062..13c01954a0 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -526,20 +526,22 @@ void MarlinSettings::postprocess() {
   TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.update_brightness());
 
+  TERN_(EXTENSIBLE_UI, ExtUI::onPostprocessSettings());
+
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 }
 
 #if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)

commit 6bb10b189897dcaef5a6da496dfd4f1631689f1b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 20 00:44:19 2021 -0500

    Changes supporting "Prussia3D" MK3 (#21617)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 915886fe4a..4273c4b062 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2773,39 +2773,34 @@ void MarlinSettings::reset() {
         #define Z4_ENDSTOP_ADJUSTMENT 0
       #endif
       endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
     #endif
   #endif
 
   //
   // Preheat parameters
   //
   #if PREHEAT_COUNT
+    #define _PITEM(N,T) PREHEAT_##N##_##T,
     #if HAS_HOTEND
-      constexpr uint16_t hpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND, PREHEAT_3_TEMP_HOTEND, PREHEAT_4_TEMP_HOTEND, PREHEAT_5_TEMP_HOTEND);
+      constexpr uint16_t hpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_HOTEND) };
     #endif
     #if HAS_HEATED_BED
-      constexpr uint16_t bpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED, PREHEAT_3_TEMP_BED, PREHEAT_4_TEMP_BED, PREHEAT_5_TEMP_BED);
+      constexpr uint16_t bpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, TEMP_BED) };
     #endif
     #if HAS_FAN
-      constexpr uint8_t fpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED, PREHEAT_3_FAN_SPEED, PREHEAT_4_FAN_SPEED, PREHEAT_5_FAN_SPEED);
+      constexpr uint8_t fpre[] = { REPEAT2_S(1, INCREMENT(PREHEAT_COUNT), _PITEM, FAN_SPEED) };
     #endif
     LOOP_L_N(i, PREHEAT_COUNT) {
-      #if HAS_HOTEND
-        ui.material_preset[i].hotend_temp = hpre[i];
-      #endif
-      #if HAS_HEATED_BED
-        ui.material_preset[i].bed_temp = bpre[i];
-      #endif
-      #if HAS_FAN
-        ui.material_preset[i].fan_speed = fpre[i];
-      #endif
+      TERN_(HAS_HOTEND,     ui.material_preset[i].hotend_temp = hpre[i]);
+      TERN_(HAS_HEATED_BED, ui.material_preset[i].bed_temp = bpre[i]);
+      TERN_(HAS_FAN,        ui.material_preset[i].fan_speed = fpre[i]);
     }
   #endif
 
   //
   // Hotend PID
   //
 
   #if ENABLED(PIDTEMP)
     #if ENABLED(PID_PARAMS_PER_HOTEND)
       constexpr float defKp[] =

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d1fd719cfb..915886fe4a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -893,22 +893,22 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
     // PIDTEMP
     //
     {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
         PIDCF_t pidcf = {
           #if DISABLED(PIDTEMP)
-            MFNAN, MFNAN, MFNAN,
-            MFNAN, MFNAN
+            NAN, NAN, NAN,
+            NAN, NAN
           #else
                          PID_PARAM(Kp, e),
             unscalePID_i(PID_PARAM(Ki, e)),
             unscalePID_d(PID_PARAM(Kd, e)),
                          PID_PARAM(Kc, e),
                          PID_PARAM(Kf, e)
           #endif
         };
         EEPROM_WRITE(pidcf);
       }
@@ -921,40 +921,40 @@ void MarlinSettings::postprocess() {
     }
 
     //
     // PIDTEMPBED
     //
     {
       _FIELD_TEST(bedPID);
 
       const PID_t bed_pid = {
         #if DISABLED(PIDTEMPBED)
-          MFNAN, MFNAN, MFNAN
+          NAN, NAN, NAN
         #else
           // Store the unscaled PID values
           thermalManager.temp_bed.pid.Kp,
           unscalePID_i(thermalManager.temp_bed.pid.Ki),
           unscalePID_d(thermalManager.temp_bed.pid.Kd)
         #endif
       };
       EEPROM_WRITE(bed_pid);
     }
 
     //
     // PIDTEMPCHAMBER
     //
     {
       _FIELD_TEST(chamberPID);
 
       const PID_t chamber_pid = {
         #if DISABLED(PIDTEMPCHAMBER)
-          MFNAN, MFNAN, MFNAN
+          NAN, NAN, NAN
         #else
           // Store the unscaled PID values
           thermalManager.temp_chamber.pid.Kp,
           unscalePID_i(thermalManager.temp_chamber.pid.Ki),
           unscalePID_d(thermalManager.temp_chamber.pid.Kd)
         #endif
       };
       EEPROM_WRITE(chamber_pid);
     }
 
@@ -1779,21 +1779,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Hotend PID
       //
       {
         HOTEND_LOOP() {
           PIDCF_t pidcf;
           EEPROM_READ(pidcf);
           #if ENABLED(PIDTEMP)
-            if (!validating && !ISNAN(pidcf.Kp)) {
+            if (!validating && !isnan(pidcf.Kp)) {
               // Scale PID values since EEPROM values are unscaled
               PID_PARAM(Kp, e) = pidcf.Kp;
               PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
               PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
               TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
               TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
             }
           #endif
         }
       }
@@ -1811,37 +1811,37 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(lpq_len);
       }
 
       //
       // Heated Bed PID
       //
       {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
-          if (!validating && !ISNAN(pid.Kp)) {
+          if (!validating && !isnan(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_bed.pid.Kp = pid.Kp;
             thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
             thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
       //
       // Heated Chamber PID
       //
       {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPCHAMBER)
-          if (!validating && !ISNAN(pid.Kp)) {
+          if (!validating && !isnan(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_chamber.pid.Kp = pid.Kp;
             thermalManager.temp_chamber.pid.Ki = scalePID_i(pid.Ki);
             thermalManager.temp_chamber.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
       //
       // User-defined Thermistors

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 915886fe4a..d1fd719cfb 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -893,22 +893,22 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
     // PIDTEMP
     //
     {
       _FIELD_TEST(hotendPID);
       HOTEND_LOOP() {
         PIDCF_t pidcf = {
           #if DISABLED(PIDTEMP)
-            NAN, NAN, NAN,
-            NAN, NAN
+            MFNAN, MFNAN, MFNAN,
+            MFNAN, MFNAN
           #else
                          PID_PARAM(Kp, e),
             unscalePID_i(PID_PARAM(Ki, e)),
             unscalePID_d(PID_PARAM(Kd, e)),
                          PID_PARAM(Kc, e),
                          PID_PARAM(Kf, e)
           #endif
         };
         EEPROM_WRITE(pidcf);
       }
@@ -921,40 +921,40 @@ void MarlinSettings::postprocess() {
     }
 
     //
     // PIDTEMPBED
     //
     {
       _FIELD_TEST(bedPID);
 
       const PID_t bed_pid = {
         #if DISABLED(PIDTEMPBED)
-          NAN, NAN, NAN
+          MFNAN, MFNAN, MFNAN
         #else
           // Store the unscaled PID values
           thermalManager.temp_bed.pid.Kp,
           unscalePID_i(thermalManager.temp_bed.pid.Ki),
           unscalePID_d(thermalManager.temp_bed.pid.Kd)
         #endif
       };
       EEPROM_WRITE(bed_pid);
     }
 
     //
     // PIDTEMPCHAMBER
     //
     {
       _FIELD_TEST(chamberPID);
 
       const PID_t chamber_pid = {
         #if DISABLED(PIDTEMPCHAMBER)
-          NAN, NAN, NAN
+          MFNAN, MFNAN, MFNAN
         #else
           // Store the unscaled PID values
           thermalManager.temp_chamber.pid.Kp,
           unscalePID_i(thermalManager.temp_chamber.pid.Ki),
           unscalePID_d(thermalManager.temp_chamber.pid.Kd)
         #endif
       };
       EEPROM_WRITE(chamber_pid);
     }
 
@@ -1779,21 +1779,21 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Hotend PID
       //
       {
         HOTEND_LOOP() {
           PIDCF_t pidcf;
           EEPROM_READ(pidcf);
           #if ENABLED(PIDTEMP)
-            if (!validating && !isnan(pidcf.Kp)) {
+            if (!validating && !ISNAN(pidcf.Kp)) {
               // Scale PID values since EEPROM values are unscaled
               PID_PARAM(Kp, e) = pidcf.Kp;
               PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
               PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
               TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
               TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
             }
           #endif
         }
       }
@@ -1811,37 +1811,37 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(lpq_len);
       }
 
       //
       // Heated Bed PID
       //
       {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPBED)
-          if (!validating && !isnan(pid.Kp)) {
+          if (!validating && !ISNAN(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_bed.pid.Kp = pid.Kp;
             thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
             thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
       //
       // Heated Chamber PID
       //
       {
         PID_t pid;
         EEPROM_READ(pid);
         #if ENABLED(PIDTEMPCHAMBER)
-          if (!validating && !isnan(pid.Kp)) {
+          if (!validating && !ISNAN(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_chamber.pid.Kp = pid.Kp;
             thermalManager.temp_chamber.pid.Ki = scalePID_i(pid.Ki);
             thermalManager.temp_chamber.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
       //
       // User-defined Thermistors

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ced33a1986..915886fe4a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1598,21 +1598,21 @@ void MarlinSettings::postprocess() {
       // Mesh (Manual) Bed Leveling
       //
       {
         uint8_t mesh_num_x, mesh_num_y;
         EEPROM_READ(dummyf);
         EEPROM_READ_ALWAYS(mesh_num_x);
         EEPROM_READ_ALWAYS(mesh_num_y);
 
         #if ENABLED(MESH_BED_LEVELING)
           if (!validating) mbl.z_offset = dummyf;
-          if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
+          if (mesh_num_x == (GRID_MAX_POINTS_X) && mesh_num_y == (GRID_MAX_POINTS_Y)) {
             // EEPROM data fits the current mesh
             EEPROM_READ(mbl.z_values);
           }
           else {
             // EEPROM data is stale
             if (!validating) mbl.reset();
             for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
           }
         #else
           // MBL is disabled - skip the stored data
@@ -1645,21 +1645,21 @@ void MarlinSettings::postprocess() {
       }
 
       //
       // Bilinear Auto Bed Leveling
       //
       {
         uint8_t grid_max_x, grid_max_y;
         EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
         EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
+          if (grid_max_x == (GRID_MAX_POINTS_X) && grid_max_y == (GRID_MAX_POINTS_Y)) {
             if (!validating) set_bed_leveling_enabled(false);
             EEPROM_READ(bilinear_grid_spacing);        // 2 ints
             EEPROM_READ(bilinear_start);               // 2 ints
             EEPROM_READ(z_values);                     // 9 to 256 floats
           }
           else // EEPROM data is stale
         #endif // AUTO_BED_LEVELING_BILINEAR
           {
             // Skip past disabled (or stale) Bilinear Grid data
             xy_pos_t bgs, bs;

commit 4d17613050e7d77bb1bf229f9682743f3924caf4
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Wed Mar 31 15:34:17 2021 +0800

    MKS H43 fix, cleanup (#21485)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d98ee3c218..ced33a1986 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -146,20 +146,25 @@
 #endif
 
 #if HAS_ETHERNET
   #include "../feature/ethernet.h"
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   #include "../libs/buzzer.h"
 #endif
 
+#if ENABLED(DGUS_LCD_UI_MKS)
+  #include "../lcd/extui/lib/dgus/DGUSScreenHandler.h"
+  #include "../lcd/extui/lib/dgus/DGUSDisplayDef.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();
 #endif
 
@@ -454,20 +459,30 @@ typedef struct SettingsDataStruct {
              ethernet_subnet;                           // M554 P
   #endif
 
   //
   // Buzzer enable/disable
   //
   #if ENABLED(SOUND_MENU_ITEM)
     bool buzzer_enabled;
   #endif
 
+  //
+  // MKS UI controller
+  //
+  #if ENABLED(DGUS_LCD_UI_MKS)
+    uint8_t mks_language_index;                         // Display Language
+    xy_int_t mks_corner_offsets[5];                     // Bed Tramming
+    xyz_int_t mks_park_pos;                             // Custom Parking (without NOZZLE_PARK)
+    celsius_t mks_min_extrusion_temp;                   // Min E Temp (shadow M302 value)
+  #endif
+
   #if HAS_MULTI_LANGUAGE
     uint8_t ui_language;                                // M414 S
   #endif
 
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
@@ -1395,20 +1410,30 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
     //
     // Buzzer enable/disable
     //
     #if ENABLED(SOUND_MENU_ITEM)
       EEPROM_WRITE(ui.buzzer_enabled);
     #endif
 
+    //
+    // MKS UI controller
+    //
+    #if ENABLED(DGUS_LCD_UI_MKS)
+      EEPROM_WRITE(mks_language_index);
+      EEPROM_WRITE(mks_corner_offsets);
+      EEPROM_WRITE(mks_park_pos);
+      EEPROM_WRITE(mks_min_extrusion_temp);
+    #endif
+
     //
     // Selected LCD language
     //
     #if HAS_MULTI_LANGUAGE
       EEPROM_WRITE(ui.language);
     #endif
 
     //
     // Report final CRC and Data Size
     //
@@ -2295,20 +2320,31 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Buzzer enable/disable
       //
       #if ENABLED(SOUND_MENU_ITEM)
         _FIELD_TEST(buzzer_enabled);
         EEPROM_READ(ui.buzzer_enabled);
       #endif
 
+      //
+      // MKS UI controller
+      //
+      #if ENABLED(DGUS_LCD_UI_MKS)
+        _FIELD_TEST(mks_language_index);
+        EEPROM_READ(mks_language_index);
+        EEPROM_READ(mks_corner_offsets);
+        EEPROM_READ(mks_park_pos);
+        EEPROM_READ(mks_min_extrusion_temp);
+      #endif
+
       //
       // Selected LCD language
       //
       #if HAS_MULTI_LANGUAGE
       {
         uint8_t ui_language;
         EEPROM_READ(ui_language);
         if (ui_language >= NUM_LANGUAGES) ui_language = 0;
         ui.set_language(ui_language);
       }
@@ -2960,20 +2996,25 @@ void MarlinSettings::reset() {
 
   #if ENABLED(PASSWORD_FEATURE)
     #ifdef PASSWORD_DEFAULT_VALUE
       password.is_set = true;
       password.value = PASSWORD_DEFAULT_VALUE;
     #else
       password.is_set = false;
     #endif
   #endif
 
+  //
+  // MKS UI controller
+  //
+  TERN_(DGUS_LCD_UI_MKS, MKS_reset_settings());
+
   postprocess();
 
   DEBUG_ECHO_START();
   DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 

commit 3ced55aa930076c912bad5df2ec5b4376a0eaba9
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Wed Mar 24 13:32:08 2021 +0100

    Optimize MarlinSettings with template methods (#21426)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index bf10902c60..d98ee3c218 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -565,61 +565,54 @@ void MarlinSettings::postprocess() {
 #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
   static_assert(EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
                 "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
-                                  int eeprom_index = EEPROM_OFFSET
-  #define EEPROM_FINISH()         persistentStore.access_finish()
-  #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
-  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
-  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)
-  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               }while(0)
   #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
 
   #if ENABLED(DEBUG_EEPROM_READWRITE)
     #define _FIELD_TEST(FIELD) \
       EEPROM_ASSERT( \
         eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
         "Field " STRINGIFY(FIELD) " mismatch." \
       )
   #else
     #define _FIELD_TEST(FIELD) NOOP
   #endif
 
   const char version[4] = EEPROM_VERSION;
 
   bool MarlinSettings::eeprom_error, MarlinSettings::validating;
+  int MarlinSettings::eeprom_index;
+  uint16_t MarlinSettings::working_crc;
 
   bool MarlinSettings::size_error(const uint16_t size) {
     if (size != datasize()) {
       DEBUG_ERROR_MSG("EEPROM datasize error.");
       return true;
     }
     return false;
   }
 
   /**
    * M500 - Store Configuration
    */
   bool MarlinSettings::save() {
     float dummyf = 0;
     char ver[4] = "ERR";
 
-    uint16_t working_crc = 0;
-
-    EEPROM_START();
+    if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     eeprom_error = false;
 
     // Write or Skip version. (Flash doesn't allow rewrite without erase.)
     TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
 
     EEPROM_SKIP(working_crc); // Skip the checksum slot
 
     working_crc = 0; // clear before first "real data"
 
@@ -1449,23 +1442,21 @@ void MarlinSettings::postprocess() {
 
     TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
 
     return !eeprom_error;
   }
 
   /**
    * M501 - Retrieve Configuration
    */
   bool MarlinSettings::_load() {
-    uint16_t working_crc = 0;
-
-    EEPROM_START();
+    if (!EEPROM_START(EEPROM_OFFSET)) return false;
 
     char stored_ver[4];
     EEPROM_READ_ALWAYS(stored_ver);
 
     uint16_t stored_crc;
     EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
@@ -1489,24 +1480,24 @@ void MarlinSettings::postprocess() {
 
       //
       // Planner Motion
       //
       {
         // Get only the number of E stepper parameters previously stored
         // Any steppers added later are set to their defaults
         uint32_t tmp1[XYZ + esteppers];
         float tmp2[XYZ + esteppers];
         feedRate_t tmp3[XYZ + esteppers];
-        EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
+        EEPROM_READ((uint8_t *)tmp1, sizeof(tmp1)); // max_acceleration_mm_per_s2
         EEPROM_READ(planner.settings.min_segment_time_us);
-        EEPROM_READ(tmp2);                         // axis_steps_per_mm
-        EEPROM_READ(tmp3);                         // max_feedrate_mm_s
+        EEPROM_READ((uint8_t *)tmp2, sizeof(tmp2)); // axis_steps_per_mm
+        EEPROM_READ((uint8_t *)tmp3, sizeof(tmp3)); // max_feedrate_mm_s
 
         if (!validating) LOOP_XYZE_N(i) {
           const bool in = (i < esteppers + XYZ);
           planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
           planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
           planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
         }
 
         EEPROM_READ(planner.settings.acceleration);
         EEPROM_READ(planner.settings.retract_acceleration);

commit cfa6c7d45ba72d1a0b26e6308191e008dcd0d9c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:34:10 2021 -0500

    Improve max temp / target

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d38ad51934..bf10902c60 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3379,24 +3379,24 @@ void MarlinSettings::reset() {
     #endif // [XYZ]_DUAL_ENDSTOPS
 
     #if PREHEAT_COUNT
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       LOOP_L_N(i, PREHEAT_COUNT) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
           PSTR("  M145 S"), i
           #if HAS_HOTEND
-            , PSTR(" H"), TEMP_UNIT(ui.material_preset[i].hotend_temp)
+            , PSTR(" H"), parser.to_temp_units(ui.material_preset[i].hotend_temp)
           #endif
           #if HAS_HEATED_BED
-            , SP_B_STR, TEMP_UNIT(ui.material_preset[i].bed_temp)
+            , SP_B_STR, parser.to_temp_units(ui.material_preset[i].bed_temp)
           #endif
           #if HAS_FAN
             , PSTR(" F"), ui.material_preset[i].fan_speed
           #endif
         );
       }
 
     #endif
 
     #if HAS_PID_HEATING

commit 7f1fa0d1ff28cea68f5982eafab816b438c2ccdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 12 09:25:41 2021 -0600

    Add M207/8/9 reporting (#21335)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c82ed0eb8f..d38ad51934 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3459,43 +3459,24 @@ void MarlinSettings::reset() {
     #endif
 
     TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
       CONFIG_ECHO_MSG("  M413 S", recovery.enabled);
     #endif
 
     #if ENABLED(FWRETRACT)
-
-      CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
-        , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
-        , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
-        , SP_Z_STR, LINEAR_UNIT(fwretract.settings.retract_zraise)
-      );
-
-      CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
-      CONFIG_ECHO_MSG(
-          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
-        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
-        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
-      );
-
-      #if ENABLED(FWRETRACT_AUTORETRACT)
-        CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-        CONFIG_ECHO_MSG("  M209 S", fwretract.autoretract_enabled);
-      #endif
-
-    #endif // FWRETRACT
+      fwretract.M207_report(forReplay);
+      fwretract.M208_report(forReplay);
+      TERN_(FWRETRACT_AUTORETRACT, fwretract.M209_report(forReplay));
+    #endif
 
     /**
      * Probe Offset
      */
     #if HAS_BED_PROBE
       config_heading(forReplay, PSTR("Z-Probe Offset"), false);
       if (!forReplay) say_units(true);
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
         #if HAS_PROBE_XY_OFFSET

commit a0d312396adb089d31b1d4c1379d86dcd5b734ee
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Mar 5 00:34:38 2021 +0100

    Followup to MP_SCARA/TPARA patches (#21248)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d78d97e688..c82ed0eb8f 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -272,21 +272,21 @@ typedef struct SettingsDataStruct {
   bool bltouch_last_written_mode;
 
   //
   // DELTA / [XYZ]_DUAL_ENDSTOPS
   //
   #if ENABLED(DELTA)
     float delta_height;                                 // M666 H
     abc_float_t delta_endstop_adj;                      // M666 X Y Z
     float delta_radius,                                 // M665 R
           delta_diagonal_rod,                           // M665 L
-          delta_segments_per_second;                    // M665 S
+          segments_per_second;                          // M665 S
     abc_float_t delta_tower_angle_trim,                 // M665 X Y Z
                 delta_diagonal_rod_trim;                // M665 A B C
   #elif HAS_EXTRA_ENDSTOPS
     float x2_endstop_adj,                               // M666 X
           y2_endstop_adj,                               // M666 Y
           z2_endstop_adj,                               // M666 (S2) Z
           z3_endstop_adj,                               // M666 (S3) Z
           z4_endstop_adj;                               // M666 (S4) Z
   #endif
 
@@ -833,21 +833,21 @@ void MarlinSettings::postprocess() {
     //
     {
       #if ENABLED(DELTA)
 
         _FIELD_TEST(delta_height);
 
         EEPROM_WRITE(delta_height);              // 1 float
         EEPROM_WRITE(delta_endstop_adj);         // 3 floats
         EEPROM_WRITE(delta_radius);              // 1 float
         EEPROM_WRITE(delta_diagonal_rod);        // 1 float
-        EEPROM_WRITE(delta_segments_per_second); // 1 float
+        EEPROM_WRITE(segments_per_second);       // 1 float
         EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
         EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
 
       #elif HAS_EXTRA_ENDSTOPS
 
         _FIELD_TEST(x2_endstop_adj);
 
         // Write dual endstops in X, Y, Z order. Unused = 0.0
         dummyf = 0;
         EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
@@ -1714,21 +1714,21 @@ void MarlinSettings::postprocess() {
       //
       {
         #if ENABLED(DELTA)
 
           _FIELD_TEST(delta_height);
 
           EEPROM_READ(delta_height);              // 1 float
           EEPROM_READ(delta_endstop_adj);         // 3 floats
           EEPROM_READ(delta_radius);              // 1 float
           EEPROM_READ(delta_diagonal_rod);        // 1 float
-          EEPROM_READ(delta_segments_per_second); // 1 float
+          EEPROM_READ(segments_per_second);       // 1 float
           EEPROM_READ(delta_tower_angle_trim);    // 3 floats
           EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
 
         #elif HAS_EXTRA_ENDSTOPS
 
           _FIELD_TEST(x2_endstop_adj);
 
           EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
           EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
           EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
@@ -2704,21 +2704,21 @@ void MarlinSettings::reset() {
   //
   // Endstop Adjustments
   //
 
   #if ENABLED(DELTA)
     const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
     delta_height = DELTA_HEIGHT;
     delta_endstop_adj = adj;
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
-    delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
+    segments_per_second = DELTA_SEGMENTS_PER_SECOND;
     delta_tower_angle_trim = dta;
     delta_diagonal_rod_trim = ddr;
   #endif
 
   #if ENABLED(X_DUAL_ENDSTOPS)
     #ifndef X2_ENDSTOP_ADJUSTMENT
       #define X2_ENDSTOP_ADJUSTMENT 0
     #endif
     endstops.x2_endstop_adj = X2_ENDSTOP_ADJUSTMENT;
   #endif
@@ -3313,21 +3313,21 @@ void MarlinSettings::reset() {
         }
       }
 
     #endif // EDITABLE_SERVO_ANGLES
 
     #if HAS_SCARA_OFFSET
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
-          PSTR("  M665 S"), delta_segments_per_second
+          PSTR("  M665 S"), segments_per_second
         , SP_P_STR, scara_home_offset.a
         , SP_T_STR, scara_home_offset.b
         , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
       );
 
     #elif ENABLED(DELTA)
 
       CONFIG_ECHO_HEADING("Endstop adjustment:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
@@ -3335,21 +3335,21 @@ void MarlinSettings::reset() {
         , SP_Y_STR, LINEAR_UNIT(delta_endstop_adj.b)
         , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
       );
 
       CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
         , PSTR(" R"), LINEAR_UNIT(delta_radius)
         , PSTR(" H"), LINEAR_UNIT(delta_height)
-        , PSTR(" S"), delta_segments_per_second
+        , PSTR(" S"), segments_per_second
         , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
         , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
         , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
         , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
         , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
         , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
       );
 
     #elif HAS_EXTRA_ENDSTOPS
 

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f4b4bf0b8b..d78d97e688 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2983,56 +2983,56 @@ void MarlinSettings::reset() {
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 
   static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
     if (!repl) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("; ");
-      serialprintPGM(pstr);
+      SERIAL_ECHOPGM_P(pstr);
       if (eol) SERIAL_EOL();
     }
   }
 
   #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
   #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
 
   #if HAS_TRINAMIC_CONFIG
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
       void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
         CONFIG_ECHO_START();
         SERIAL_ECHOPGM("  M569 S1");
         if (etc) {
           SERIAL_CHAR(' ');
-          serialprintPGM(etc);
+          SERIAL_ECHOPGM_P(etc);
         }
         if (newLine) SERIAL_EOL();
       }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
       inline void say_M913(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M913"); }
     #endif
     #if USE_SENSORLESS
       inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
     #endif
   #endif
 
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     inline void say_M603(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M603 "); }
   #endif
 
   inline void say_units(const bool colon) {
-    serialprintPGM(
+    SERIAL_ECHOPGM_P(
       #if ENABLED(INCH_MODE_SUPPORT)
         parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
       #endif
       PSTR(" (mm)")
     );
     if (colon) SERIAL_ECHOLNPGM(":");
   }
 
   void report_M92(const bool echo=true, const int8_t e=-1);
 
@@ -3059,21 +3059,21 @@ void MarlinSettings::reset() {
 
     #if HAS_LCD_MENU
 
       // Temperature units - for Ultipanel temperature options
 
       CONFIG_ECHO_START();
       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
         SERIAL_ECHOPGM("  M149 ");
         SERIAL_CHAR(parser.temp_units_code());
         SERIAL_ECHOPGM(" ; Units in ");
-        serialprintPGM(parser.temp_units_name());
+        SERIAL_ECHOPGM_P(parser.temp_units_name());
       #else
         SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
       #endif
 
     #endif
 
     SERIAL_EOL();
 
     #if EXTRUDERS && DISABLED(NO_VOLUMETRICS)
 
@@ -3247,26 +3247,26 @@ void MarlinSettings::reset() {
           , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
         #endif
       );
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), px, PSTR(" J"), py);
+              SERIAL_ECHOPAIR("  G29 S3 I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR_F_P(PSTR("  G29 S4 Z"), LINEAR_UNIT(mbl.z_offset), 5);
+          SERIAL_ECHOLNPAIR_F("  G29 S4 Z", LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
           SERIAL_EOL();
           ubl.report_state();
           SERIAL_EOL();
           config_heading(false, PSTR("Active Mesh Slot: "), false);
           SERIAL_ECHOLN(ubl.storage_slot);

commit a3a10b62f21cfbedfd001746faa46ac55d248b36
Author: Ken Sanislo <ksanislo@users.noreply.github.com>
Date:   Wed Feb 24 16:26:51 2021 -0800

    Chamber Heater PID (#21156)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 7fb378191e..f4b4bf0b8b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -311,20 +311,25 @@ typedef struct SettingsDataStruct {
   // PIDTEMP
   //
   PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
   int16_t lpq_len;                                      // M301 L
 
   //
   // PIDTEMPBED
   //
   PID_t bedPID;                                         // M304 PID / M303 E-1 U
 
+  //
+  // PIDTEMPCHAMBER
+  //
+  PID_t chamberPID;                                     // M309 PID / M303 E-2 U
+
   //
   // User-defined Thermistors
   //
   #if HAS_USER_THERMISTORS
     user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
   #endif
 
   //
   // Power monitor
   //
@@ -919,20 +924,39 @@ void MarlinSettings::postprocess() {
         #else
           // Store the unscaled PID values
           thermalManager.temp_bed.pid.Kp,
           unscalePID_i(thermalManager.temp_bed.pid.Ki),
           unscalePID_d(thermalManager.temp_bed.pid.Kd)
         #endif
       };
       EEPROM_WRITE(bed_pid);
     }
 
+    //
+    // PIDTEMPCHAMBER
+    //
+    {
+      _FIELD_TEST(chamberPID);
+
+      const PID_t chamber_pid = {
+        #if DISABLED(PIDTEMPCHAMBER)
+          NAN, NAN, NAN
+        #else
+          // Store the unscaled PID values
+          thermalManager.temp_chamber.pid.Kp,
+          unscalePID_i(thermalManager.temp_chamber.pid.Ki),
+          unscalePID_d(thermalManager.temp_chamber.pid.Kd)
+        #endif
+      };
+      EEPROM_WRITE(chamber_pid);
+    }
+
     //
     // User-defined Thermistors
     //
     #if HAS_USER_THERMISTORS
     {
       _FIELD_TEST(user_thermistor);
       EEPROM_WRITE(thermalManager.user_thermistor);
     }
     #endif
 
@@ -1780,20 +1804,36 @@ void MarlinSettings::postprocess() {
         #if ENABLED(PIDTEMPBED)
           if (!validating && !isnan(pid.Kp)) {
             // Scale PID values since EEPROM values are unscaled
             thermalManager.temp_bed.pid.Kp = pid.Kp;
             thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
             thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
           }
         #endif
       }
 
+      //
+      // Heated Chamber PID
+      //
+      {
+        PID_t pid;
+        EEPROM_READ(pid);
+        #if ENABLED(PIDTEMPCHAMBER)
+          if (!validating && !isnan(pid.Kp)) {
+            // Scale PID values since EEPROM values are unscaled
+            thermalManager.temp_chamber.pid.Kp = pid.Kp;
+            thermalManager.temp_chamber.pid.Ki = scalePID_i(pid.Ki);
+            thermalManager.temp_chamber.pid.Kd = scalePID_d(pid.Kd);
+          }
+        #endif
+      }
+
       //
       // User-defined Thermistors
       //
       #if HAS_USER_THERMISTORS
       {
         _FIELD_TEST(user_thermistor);
         EEPROM_READ(thermalManager.user_thermistor);
       }
       #endif
 
@@ -2804,20 +2844,30 @@ void MarlinSettings::reset() {
   //
   // Heated Bed PID
   //
 
   #if ENABLED(PIDTEMPBED)
     thermalManager.temp_bed.pid.Kp = DEFAULT_bedKp;
     thermalManager.temp_bed.pid.Ki = scalePID_i(DEFAULT_bedKi);
     thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
   #endif
 
+  //
+  // Heated Chamber PID
+  //
+
+  #if ENABLED(PIDTEMPCHAMBER)
+    thermalManager.temp_chamber.pid.Kp = DEFAULT_chamberKp;
+    thermalManager.temp_chamber.pid.Ki = scalePID_i(DEFAULT_chamberKi);
+    thermalManager.temp_chamber.pid.Kd = scalePID_d(DEFAULT_chamberKd);
+  #endif
+
   //
   // User-Defined Thermistors
   //
   TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
 
   //
   // Power Monitor
   //
   TERN_(POWER_MONITOR, power_monitor.reset());
 
@@ -3379,21 +3429,30 @@ void MarlinSettings::reset() {
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
         CONFIG_ECHO_MSG(
             "  M304 P", thermalManager.temp_bed.pid.Kp
           , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
           , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
         );
       #endif
 
-    #endif // PIDTEMP || PIDTEMPBED
+      #if ENABLED(PIDTEMPCHAMBER)
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR(
+            "  M309 P", thermalManager.temp_chamber.pid.Kp
+          , " I", unscalePID_i(thermalManager.temp_chamber.pid.Ki)
+          , " D", unscalePID_d(thermalManager.temp_chamber.pid.Kd)
+        );
+      #endif
+
+    #endif // PIDTEMP || PIDTEMPBED || PIDTEMPCHAMBER
 
     #if HAS_USER_THERMISTORS
       CONFIG_ECHO_HEADING("User thermistors:");
       LOOP_L_N(i, USER_THERMISTORS)
         thermalManager.log_user_thermistor(i, true);
     #endif
 
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
       CONFIG_ECHO_MSG("  M250 C", ui.contrast);

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 089481d076..7fb378191e 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2282,21 +2282,21 @@ void MarlinSettings::postprocess() {
         ui.set_language(ui_language);
       }
       #endif
 
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
-        DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
+        DEBUG_ECHOLNPAIR("Index: ", eeprom_index - (EEPROM_OFFSET), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
@@ -3032,36 +3032,36 @@ void MarlinSettings::reset() {
        */
       if (!forReplay) {
         config_heading(forReplay, PSTR("Filament settings:"), false);
         if (parser.volumetric_enabled)
           SERIAL_EOL();
         else
           SERIAL_ECHOLNPGM(" Disabled");
       }
 
       #if EXTRUDERS == 1
-        CONFIG_ECHO_MSG("  M200 S", int(parser.volumetric_enabled)
+        CONFIG_ECHO_MSG("  M200 S", parser.volumetric_enabled
                             , " D", LINEAR_UNIT(planner.filament_size[0])
                             #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
                               , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
                             #endif
                        );
       #else
         LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_MSG("  M200 T", int(i)
+          CONFIG_ECHO_MSG("  M200 T", i
                               , " D", LINEAR_UNIT(planner.filament_size[i])
                               #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
                                 , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
                               #endif
                          );
         }
-        CONFIG_ECHO_MSG("  M200 S", int(parser.volumetric_enabled));
+        CONFIG_ECHO_MSG("  M200 S", parser.volumetric_enabled);
       #endif
 
     #endif // EXTRUDERS && !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
     report_M92(!forReplay);
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
@@ -3069,41 +3069,41 @@ void MarlinSettings::reset() {
       , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
       , SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
       #if DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
-            PSTR("  M203 T"), (int)i
+            PSTR("  M203 T"), i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
         );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
       , SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
       , SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
       #if DISABLED(DISTINCT_E_FACTORS)
         , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
       #endif
     );
     #if ENABLED(DISTINCT_E_FACTORS)
       LOOP_L_N(i, E_STEPPERS) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
-            PSTR("  M201 T"), (int)i
+            PSTR("  M201 T"), i
           , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
         );
       }
     #endif
 
     CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
       , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
@@ -3151,21 +3151,21 @@ void MarlinSettings::reset() {
         #endif
         , LINEAR_UNIT(home_offset.z)
       );
     #endif
 
     #if HAS_HOTEND_OFFSET
       CONFIG_ECHO_HEADING("Hotend offsets:");
       CONFIG_ECHO_START();
       LOOP_S_L_N(e, 1, HOTENDS) {
         SERIAL_ECHOPAIR_P(
-          PSTR("  M218 T"), (int)e,
+          PSTR("  M218 T"), e,
           SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
           SP_Y_STR, LINEAR_UNIT(hotend_offset[e].y)
         );
         SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(hotend_offset[e].z), 3);
       }
     #endif
 
     /**
      * Bed Leveling
      */
@@ -3185,33 +3185,33 @@ void MarlinSettings::reset() {
         }
 
       #elif HAS_ABL_OR_UBL
 
         CONFIG_ECHO_HEADING("Auto Bed Leveling:");
 
       #endif
 
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
-        PSTR("  M420 S"), int(planner.leveling_active)
+        PSTR("  M420 S"), planner.leveling_active
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
         #endif
       );
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), (int)px, PSTR(" J"), (int)py);
+              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), px, PSTR(" J"), py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
             }
           }
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR_F_P(PSTR("  G29 S4 Z"), LINEAR_UNIT(mbl.z_offset), 5);
         }
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
         if (!forReplay) {
@@ -3226,21 +3226,21 @@ void MarlinSettings::reset() {
         }
 
        //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
                                                   // solution needs to be found.
       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
               CONFIG_ECHO_START();
-              SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
+              SERIAL_ECHOPAIR("  G29 W I", px, " J", py);
               SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
             }
           }
         }
 
       #endif
 
     #endif // HAS_LEVELING
 
     #if ENABLED(EDITABLE_SERVO_ANGLES)
@@ -3251,21 +3251,21 @@ void MarlinSettings::reset() {
           #if ENABLED(SWITCHING_EXTRUDER)
             case SWITCHING_EXTRUDER_SERVO_NR:
             #if EXTRUDERS > 3
               case SWITCHING_EXTRUDER_E23_SERVO_NR:
             #endif
           #elif ENABLED(SWITCHING_NOZZLE)
             case SWITCHING_NOZZLE_SERVO_NR:
           #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
             case Z_PROBE_SERVO_NR:
           #endif
-            CONFIG_ECHO_MSG("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
+            CONFIG_ECHO_MSG("  M281 P", i, " L", servo_angles[i][0], " U", servo_angles[i][1]);
           default: break;
         }
       }
 
     #endif // EDITABLE_SERVO_ANGLES
 
     #if HAS_SCARA_OFFSET
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
@@ -3327,21 +3327,21 @@ void MarlinSettings::reset() {
       #endif
 
     #endif // [XYZ]_DUAL_ENDSTOPS
 
     #if PREHEAT_COUNT
 
       CONFIG_ECHO_HEADING("Material heatup parameters:");
       LOOP_L_N(i, PREHEAT_COUNT) {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR_P(
-          PSTR("  M145 S"), (int)i
+          PSTR("  M145 S"), i
           #if HAS_HOTEND
             , PSTR(" H"), TEMP_UNIT(ui.material_preset[i].hotend_temp)
           #endif
           #if HAS_HEATED_BED
             , SP_B_STR, TEMP_UNIT(ui.material_preset[i].bed_temp)
           #endif
           #if HAS_FAN
             , PSTR(" F"), ui.material_preset[i].fan_speed
           #endif
         );
@@ -3396,21 +3396,21 @@ void MarlinSettings::reset() {
 
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
       CONFIG_ECHO_MSG("  M250 C", ui.contrast);
     #endif
 
     TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
-      CONFIG_ECHO_MSG("  M413 S", int(recovery.enabled));
+      CONFIG_ECHO_MSG("  M413 S", recovery.enabled);
     #endif
 
     #if ENABLED(FWRETRACT)
 
       CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
         , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
         , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
@@ -3418,25 +3418,23 @@ void MarlinSettings::reset() {
       );
 
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
       CONFIG_ECHO_MSG(
           "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
         , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
         , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
       );
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
-
         CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-        CONFIG_ECHO_MSG("  M209 S", int(fwretract.autoretract_enabled));
-
-      #endif // FWRETRACT_AUTORETRACT
+        CONFIG_ECHO_MSG("  M209 S", fwretract.autoretract_enabled);
+      #endif
 
     #endif // FWRETRACT
 
     /**
      * Probe Offset
      */
     #if HAS_BED_PROBE
       config_heading(forReplay, PSTR("Z-Probe Offset"), false);
       if (!forReplay) say_units(true);
       CONFIG_ECHO_START();
@@ -3768,21 +3766,21 @@ void MarlinSettings::reset() {
 
     /**
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)
       CONFIG_ECHO_HEADING("Linear Advance:");
       #if EXTRUDERS < 2
         CONFIG_ECHO_MSG("  M900 K", planner.extruder_advance_K[0]);
       #else
         LOOP_L_N(i, EXTRUDERS)
-          CONFIG_ECHO_MSG("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
+          CONFIG_ECHO_MSG("  M900 T", i, " K", planner.extruder_advance_K[i]);
       #endif
     #endif
 
     #if EITHER(HAS_MOTOR_CURRENT_SPI, HAS_MOTOR_CURRENT_PWM)
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
         SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
             PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
                   , SP_Z_STR, stepper.motor_current_setting[1] // Z
@@ -3834,35 +3832,35 @@ void MarlinSettings::reset() {
         , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
         #ifdef BACKLASH_SMOOTHING_MM
           , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
         #endif
       );
     #endif
 
     #if HAS_FILAMENT_SENSOR
       CONFIG_ECHO_HEADING("Filament runout sensor:");
       CONFIG_ECHO_MSG(
-        "  M412 S", int(runout.enabled)
+        "  M412 S", runout.enabled
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           , " D", LINEAR_UNIT(runout.runout_distance())
         #endif
       );
     #endif
 
     #if HAS_ETHERNET
       CONFIG_ECHO_HEADING("Ethernet:");
       if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M552_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M553_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M554_report();
     #endif
 
     #if HAS_MULTI_LANGUAGE
       CONFIG_ECHO_HEADING("UI Language:");
-      SERIAL_ECHO_MSG("  M414 S", int(ui.language));
+      SERIAL_ECHO_MSG("  M414 S", ui.language);
     #endif
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit 708ea3d0bb82f067424c75636c28a549aa3d3b06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 23:22:42 2021 -0600

    Use serial shorthand

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6908635d6e..089481d076 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2939,21 +2939,21 @@ void MarlinSettings::reset() {
   static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
     if (!repl) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("; ");
       serialprintPGM(pstr);
       if (eol) SERIAL_EOL();
     }
   }
 
   #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
-  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
+  #define CONFIG_ECHO_MSG(V...)     do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPAIR(V); }while(0)
   #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
 
   #if HAS_TRINAMIC_CONFIG
     inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
     #if HAS_STEALTHCHOP
       void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
         CONFIG_ECHO_START();
         SERIAL_ECHOPGM("  M569 S1");
         if (etc) {
           SERIAL_CHAR(' ');
@@ -3032,40 +3032,38 @@ void MarlinSettings::reset() {
        */
       if (!forReplay) {
         config_heading(forReplay, PSTR("Filament settings:"), false);
         if (parser.volumetric_enabled)
           SERIAL_EOL();
         else
           SERIAL_ECHOLNPGM(" Disabled");
       }
 
       #if EXTRUDERS == 1
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled)
-                              , " D", LINEAR_UNIT(planner.filament_size[0])
+        CONFIG_ECHO_MSG("  M200 S", int(parser.volumetric_enabled)
+                            , " D", LINEAR_UNIT(planner.filament_size[0])
+                            #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+                              , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
+                            #endif
+                       );
+      #else
+        LOOP_L_N(i, EXTRUDERS) {
+          CONFIG_ECHO_MSG("  M200 T", int(i)
+                              , " D", LINEAR_UNIT(planner.filament_size[i])
                               #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
+                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
                               #endif
                          );
-      #else
-        LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR("  M200 T", int(i)
-                                , " D", LINEAR_UNIT(planner.filament_size[i])
-                                #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-                                  , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
-                                #endif
-                           );
         }
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled));
+        CONFIG_ECHO_MSG("  M200 S", int(parser.volumetric_enabled));
       #endif
+
     #endif // EXTRUDERS && !NO_VOLUMETRICS
 
     CONFIG_ECHO_HEADING("Steps per unit:");
     report_M92(!forReplay);
 
     CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
     CONFIG_ECHO_START();
     SERIAL_ECHOLNPAIR_P(
         PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
       , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
@@ -3187,21 +3185,21 @@ void MarlinSettings::reset() {
         }
 
       #elif HAS_ABL_OR_UBL
 
         CONFIG_ECHO_HEADING("Auto Bed Leveling:");
 
       #endif
 
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
-        PSTR("  M420 S"), planner.leveling_active ? 1 : 0
+        PSTR("  M420 S"), int(planner.leveling_active)
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
         #endif
       );
 
       #if ENABLED(MESH_BED_LEVELING)
 
         if (leveling_is_valid()) {
           LOOP_L_N(py, GRID_MAX_POINTS_Y) {
             LOOP_L_N(px, GRID_MAX_POINTS_X) {
@@ -3253,22 +3251,21 @@ void MarlinSettings::reset() {
           #if ENABLED(SWITCHING_EXTRUDER)
             case SWITCHING_EXTRUDER_SERVO_NR:
             #if EXTRUDERS > 3
               case SWITCHING_EXTRUDER_E23_SERVO_NR:
             #endif
           #elif ENABLED(SWITCHING_NOZZLE)
             case SWITCHING_NOZZLE_SERVO_NR:
           #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
             case Z_PROBE_SERVO_NR:
           #endif
-            CONFIG_ECHO_START();
-            SERIAL_ECHOLNPAIR("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
+            CONFIG_ECHO_MSG("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
           default: break;
         }
       }
 
     #endif // EDITABLE_SERVO_ANGLES
 
     #if HAS_SCARA_OFFSET
 
       CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
       CONFIG_ECHO_START();
@@ -3375,74 +3372,69 @@ void MarlinSettings::reset() {
             if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
           #endif
           #if ENABLED(PID_FAN_SCALING)
             SERIAL_ECHOPAIR(" F", PID_PARAM(Kf, e));
           #endif
           SERIAL_EOL();
         }
       #endif // PIDTEMP
 
       #if ENABLED(PIDTEMPBED)
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR(
+        CONFIG_ECHO_MSG(
             "  M304 P", thermalManager.temp_bed.pid.Kp
           , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
           , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
         );
       #endif
 
     #endif // PIDTEMP || PIDTEMPBED
 
     #if HAS_USER_THERMISTORS
       CONFIG_ECHO_HEADING("User thermistors:");
       LOOP_L_N(i, USER_THERMISTORS)
         thermalManager.log_user_thermistor(i, true);
     #endif
 
     #if HAS_LCD_CONTRAST
       CONFIG_ECHO_HEADING("LCD Contrast:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
+      CONFIG_ECHO_MSG("  M250 C", ui.contrast);
     #endif
 
     TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
 
     #if ENABLED(POWER_LOSS_RECOVERY)
       CONFIG_ECHO_HEADING("Power-Loss Recovery:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR("  M413 S", int(recovery.enabled));
+      CONFIG_ECHO_MSG("  M413 S", int(recovery.enabled));
     #endif
 
     #if ENABLED(FWRETRACT)
 
       CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
         , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
         , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
         , SP_Z_STR, LINEAR_UNIT(fwretract.settings.retract_zraise)
       );
 
       CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
+      CONFIG_ECHO_MSG(
           "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
         , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
         , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
       );
 
       #if ENABLED(FWRETRACT_AUTORETRACT)
 
         CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+        CONFIG_ECHO_MSG("  M209 S", int(fwretract.autoretract_enabled));
 
       #endif // FWRETRACT_AUTORETRACT
 
     #endif // FWRETRACT
 
     /**
      * Probe Offset
      */
     #if HAS_BED_PROBE
       config_heading(forReplay, PSTR("Z-Probe Offset"), false);
@@ -3773,27 +3765,24 @@ void MarlinSettings::reset() {
       #endif // HAS_STEALTHCHOP
 
     #endif // HAS_TRINAMIC_CONFIG
 
     /**
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)
       CONFIG_ECHO_HEADING("Linear Advance:");
       #if EXTRUDERS < 2
-        CONFIG_ECHO_START();
-        SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
+        CONFIG_ECHO_MSG("  M900 K", planner.extruder_advance_K[0]);
       #else
-        LOOP_L_N(i, EXTRUDERS) {
-          CONFIG_ECHO_START();
-          SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
-        }
+        LOOP_L_N(i, EXTRUDERS)
+          CONFIG_ECHO_MSG("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
       #endif
     #endif
 
     #if EITHER(HAS_MOTOR_CURRENT_SPI, HAS_MOTOR_CURRENT_PWM)
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
         SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
             PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
                   , SP_Z_STR, stepper.motor_current_setting[1] // Z
@@ -3844,22 +3833,21 @@ void MarlinSettings::reset() {
         , SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y)
         , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
         #ifdef BACKLASH_SMOOTHING_MM
           , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
         #endif
       );
     #endif
 
     #if HAS_FILAMENT_SENSOR
       CONFIG_ECHO_HEADING("Filament runout sensor:");
-      CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR(
+      CONFIG_ECHO_MSG(
         "  M412 S", int(runout.enabled)
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           , " D", LINEAR_UNIT(runout.runout_distance())
         #endif
       );
     #endif
 
     #if HAS_ETHERNET
       CONFIG_ECHO_HEADING("Ethernet:");
       if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0a5439facd..6908635d6e 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -169,22 +169,20 @@ typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
-extern const char SP_X_STR[], SP_Y_STR[], SP_Z_STR[], SP_E_STR[];
-
 /**
  * Current EEPROM Layout
  *
  * Keep this data structure up to date so
  * EEPROM size is known at compile time!
  */
 typedef struct SettingsDataStruct {
   char      version[4];                                 // Vnn\0
   uint16_t  crc;                                        // Data Checksum
 
@@ -3174,21 +3172,21 @@ void MarlinSettings::reset() {
      * Bed Leveling
      */
     #if HAS_LEVELING
 
       #if ENABLED(MESH_BED_LEVELING)
 
         CONFIG_ECHO_HEADING("Mesh Bed Leveling:");
 
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
-        config_heading(forReplay, PSTR(""), false);
+        config_heading(forReplay, NUL_STR, false);
         if (!forReplay) {
           ubl.echo_name();
           SERIAL_CHAR(':');
           SERIAL_EOL();
         }
 
       #elif HAS_ABL_OR_UBL
 
         CONFIG_ECHO_HEADING("Auto Bed Leveling:");
 

commit 68abaeab19b41824bc151bc0f65e76ce8a2e4916
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 20 18:52:06 2021 -0600

    MarlinUI multi-language support (#20725)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 58cdd5296f..0a5439facd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V82"
+#define EEPROM_VERSION "V83"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -450,20 +450,25 @@ typedef struct SettingsDataStruct {
              ethernet_gateway,                          // M553 P
              ethernet_subnet;                           // M554 P
   #endif
 
   //
   // Buzzer enable/disable
   //
   #if ENABLED(SOUND_MENU_ITEM)
     bool buzzer_enabled;
   #endif
+
+  #if HAS_MULTI_LANGUAGE
+    uint8_t ui_language;                                // M414 S
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1375,20 +1380,27 @@ void MarlinSettings::postprocess() {
     }
     #endif
 
     //
     // Buzzer enable/disable
     //
     #if ENABLED(SOUND_MENU_ITEM)
       EEPROM_WRITE(ui.buzzer_enabled);
     #endif
 
+    //
+    // Selected LCD language
+    //
+    #if HAS_MULTI_LANGUAGE
+      EEPROM_WRITE(ui.language);
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2254,20 +2266,32 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Buzzer enable/disable
       //
       #if ENABLED(SOUND_MENU_ITEM)
         _FIELD_TEST(buzzer_enabled);
         EEPROM_READ(ui.buzzer_enabled);
       #endif
 
+      //
+      // Selected LCD language
+      //
+      #if HAS_MULTI_LANGUAGE
+      {
+        uint8_t ui_language;
+        EEPROM_READ(ui_language);
+        if (ui_language >= NUM_LANGUAGES) ui_language = 0;
+        ui.set_language(ui_language);
+      }
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
         IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
@@ -3839,15 +3863,20 @@ void MarlinSettings::reset() {
     #endif
 
     #if HAS_ETHERNET
       CONFIG_ECHO_HEADING("Ethernet:");
       if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M552_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M553_report();
       CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M554_report();
     #endif
+
+    #if HAS_MULTI_LANGUAGE
+      CONFIG_ECHO_HEADING("UI Language:");
+      SERIAL_ECHO_MSG("  M414 S", int(ui.language));
+    #endif
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit 6376b683c78ec410ace0765ba91314055b78d927
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Thu Jan 14 08:48:29 2021 -0700

    Silence unused parameter warnings

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0728840f5b..58cdd5296f 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2356,21 +2356,21 @@ void MarlinSettings::postprocess() {
     #if ENABLED(EEPROM_AUTO_INIT)
       (void)save();
       SERIAL_ECHO_MSG("EEPROM Initialized");
     #endif
     return false;
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
 
     inline void ubl_invalid_slot(const int s) {
-      #if ENABLED(EEPROM_CHITCHAT)
+      #if BOTH(EEPROM_CHITCHAT, DEBUG_OUT)
         DEBUG_ECHOLNPGM("?Invalid slot.");
         DEBUG_ECHO(s);
         DEBUG_ECHOLNPGM(" mesh slots available.");
       #else
         UNUSED(s);
       #endif
     }
 
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
                                                                                   // is a placeholder for the size of the MAT; the MAT will always

commit 7f3dcb3e8a8cc1a82c1d9315e9fada5ff59058f2
Author: Johan van der Vyver <9843081+jvandervyver@users.noreply.github.com>
Date:   Wed Jan 13 02:05:49 2021 +0200

    Multi-platform DWIN_CREALITY_LCD support (#20738)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index e667696007..0728840f5b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -43,24 +43,20 @@
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 
-#if ENABLED(DWIN_CREALITY_LCD)
-  #include "../lcd/dwin/e3v2/dwin.h"
-#endif
-
 #include "../lcd/marlinui.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"

commit 844a8c7074d555bda31a53ae834cee5fac020ca8
Author: ubik2 <ubik2@users.noreply.github.com>
Date:   Wed Dec 23 16:19:48 2020 -0800

    Add OPTIMIZED_MESH_STORAGE option (for UBL) (#20371)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index ec549ea2f6..e667696007 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2378,45 +2378,55 @@ void MarlinSettings::postprocess() {
 
     const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
                                                                                   // is a placeholder for the size of the MAT; the MAT will always
                                                                                   // live at the very end of the eeprom
 
     uint16_t MarlinSettings::meshes_start_index() {
       return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
                                                           // or down a little bit without disrupting the mesh data
     }
 
+    #define MESH_STORE_SIZE sizeof(TERN(OPTIMIZED_MESH_STORAGE, mesh_store_t, ubl.z_values))
+
     uint16_t MarlinSettings::calc_num_meshes() {
-      return (meshes_end - meshes_start_index()) / sizeof(ubl.z_values);
+      return (meshes_end - meshes_start_index()) / MESH_STORE_SIZE;
     }
 
     int MarlinSettings::mesh_slot_offset(const int8_t slot) {
-      return meshes_end - (slot + 1) * sizeof(ubl.z_values);
+      return meshes_end - (slot + 1) * MESH_STORE_SIZE;
     }
 
     void MarlinSettings::store_mesh(const int8_t slot) {
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         const int16_t a = calc_num_meshes();
         if (!WITHIN(slot, 0, a - 1)) {
           ubl_invalid_slot(a);
           DEBUG_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
           DEBUG_EOL();
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
 
+        #if ENABLED(OPTIMIZED_MESH_STORAGE)
+          int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+          ubl.set_store_from_mesh(ubl.z_values, z_mesh_store);
+          uint8_t * const src = (uint8_t*)&z_mesh_store;
+        #else
+          uint8_t * const src = (uint8_t*)&ubl.z_values;
+        #endif
+
         // Write crc to MAT along with other data, or just tack on to the beginning or end
         persistentStore.access_start();
-        const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        const bool status = persistentStore.write_data(pos, src, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
         if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
         else        DEBUG_ECHOLNPAIR("Mesh saved in slot ", slot);
 
       #else
 
         // Other mesh types
 
       #endif
@@ -2428,26 +2438,41 @@ void MarlinSettings::postprocess() {
 
         const int16_t a = settings.calc_num_meshes();
 
         if (!WITHIN(slot, 0, a - 1)) {
           ubl_invalid_slot(a);
           return;
         }
 
         int pos = mesh_slot_offset(slot);
         uint16_t crc = 0;
-        uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
+        #if ENABLED(OPTIMIZED_MESH_STORAGE)
+          int16_t z_mesh_store[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+          uint8_t * const dest = (uint8_t*)&z_mesh_store;
+        #else
+          uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
+        #endif
 
         persistentStore.access_start();
-        const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        const uint16_t status = persistentStore.read_data(pos, dest, MESH_STORE_SIZE, &crc);
         persistentStore.access_finish();
 
+        #if ENABLED(OPTIMIZED_MESH_STORAGE)
+          if (into) {
+            float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+            ubl.set_mesh_from_store(z_mesh_store, z_values);
+            memcpy(into, z_values, sizeof(z_values));
+          }
+          else
+            ubl.set_mesh_from_store(z_mesh_store, ubl.z_values);
+        #endif
+
         if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
         else        DEBUG_ECHOLNPAIR("Mesh loaded from slot ", slot);
 
         EEPROM_FINISH();
 
       #else
 
         // Other mesh types
 
       #endif

commit 22de37ad5037eb829de9e817f74d25768bd8e117
Author: ellensp <ellensp@hotmail.com>
Date:   Fri Dec 11 07:30:58 2020 +1300

    Fix UBL Debug Messages (#20423)
    
    Co-authored-by: ellensp <ellensp@hotmsil.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c6eee271a0..ec549ea2f6 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -556,21 +556,21 @@ void MarlinSettings::postprocess() {
     return true;
   }
 
 #endif // SD_FIRMWARE_UPDATE
 
 #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
   static_assert(EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
                 "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
-//#define DEBUG_OUT 1
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
                                   int eeprom_index = EEPROM_OFFSET
   #define EEPROM_FINISH()         persistentStore.access_finish()
   #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
   #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
   #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)
@@ -2287,28 +2287,28 @@ void MarlinSettings::postprocess() {
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!validating) {
           ubl.report_state();
 
           if (!ubl.sanity_check()) {
             SERIAL_EOL();
-            #if ENABLED(EEPROM_CHITCHAT)
+            #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               ubl.echo_name();
               DEBUG_ECHOLNPGM(" initialized.\n");
             #endif
           }
           else {
             eeprom_error = true;
-            #if ENABLED(EEPROM_CHITCHAT)
+            #if BOTH(EEPROM_CHITCHAT, DEBUG_LEVELING_FEATURE)
               DEBUG_ECHOPGM("?Can't enable ");
               ubl.echo_name();
               DEBUG_ECHOLNPGM(".");
             #endif
             ubl.reset();
           }
 
           if (ubl.storage_slot >= 0) {
             load_mesh(ubl.storage_slot);
             DEBUG_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");

commit df0a0c9490346f57e1b8224cb0fe7a1ad46d76bb
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 29 13:00:08 2020 -0800

    Leveling Fade Height default setting (#20316)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c49c643b60..c6eee271a0 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -689,21 +689,21 @@ void MarlinSettings::postprocess() {
       #else
         constexpr float runout_distance_mm = 0;
       #endif
       EEPROM_WRITE(runout_distance_mm);
     }
 
     //
     // Global Leveling
     //
     {
-      const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, 10.0f);
+      const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, (DEFAULT_LEVELING_FADE_HEIGHT));
       EEPROM_WRITE(zfh);
     }
 
     //
     // Mesh Bed Leveling
     //
     {
       #if ENABLED(MESH_BED_LEVELING)
         static_assert(
           sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
@@ -2581,21 +2581,21 @@ void MarlinSettings::reset() {
   TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
 
   //
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
-  TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
+  TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = (DEFAULT_LEVELING_FADE_HEIGHT));
   TERN_(HAS_LEVELING, reset_bed_level());
 
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     #if HAS_PROBE_XY_OFFSET
       LOOP_XYZ(a) probe.offset[a] = dpo[a];
     #else
       probe.offset.set(0, 0, dpo[Z_AXIS]);
     #endif

commit 7ce675e60497f1f68ab1f3753e3d114c9418dd66
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 25 23:36:22 2020 -0600

    No auto debug for EEPROM_CHITCHAT

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6614aec35b..c49c643b60 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -552,27 +552,25 @@ void MarlinSettings::postprocess() {
       persistentStore.write_data(
         SD_FIRMWARE_UPDATE_EEPROM_ADDR,
         enable ? SD_FIRMWARE_UPDATE_ACTIVE_VALUE : SD_FIRMWARE_UPDATE_INACTIVE_VALUE
       );
     return true;
   }
 
 #endif // SD_FIRMWARE_UPDATE
 
 #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
-  static_assert(
-      EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
-      "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data."
-    );
+  static_assert(EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
+                "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data.");
 #endif
 
-#define DEBUG_OUT ENABLED(EEPROM_CHITCHAT)
+//#define DEBUG_OUT 1
 #include "../core/debug_out.h"
 
 #if ENABLED(EEPROM_SETTINGS)
 
   #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
                                   int eeprom_index = EEPROM_OFFSET
   #define EEPROM_FINISH()         persistentStore.access_finish()
   #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
   #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
   #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)

commit 41529b65988a58ba512977e0fe1692aaeeb6c811
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 18 08:27:21 2020 +0100

    SMUFF (MMU2 clone) support (#19912)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 21997b4740..6614aec35b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1061,60 +1061,44 @@ void MarlinSettings::postprocess() {
         #endif
         #if AXIS_IS_TMC(Z2)
           tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z3)
           tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
         #endif
         #if AXIS_IS_TMC(Z4)
           tmc_stepper_current.Z4 = stepperZ4.getMilliamps();
         #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_IS_TMC(E0)
-            tmc_stepper_current.E0 = stepperE0.getMilliamps();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_IS_TMC(E1)
-              tmc_stepper_current.E1 = stepperE1.getMilliamps();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_IS_TMC(E2)
-                tmc_stepper_current.E2 = stepperE2.getMilliamps();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_IS_TMC(E3)
-                  tmc_stepper_current.E3 = stepperE3.getMilliamps();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_IS_TMC(E4)
-                    tmc_stepper_current.E4 = stepperE4.getMilliamps();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_IS_TMC(E5)
-                      tmc_stepper_current.E5 = stepperE5.getMilliamps();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_IS_TMC(E6)
-                        tmc_stepper_current.E6 = stepperE6.getMilliamps();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_IS_TMC(E7)
-                          tmc_stepper_current.E7 = stepperE7.getMilliamps();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
+        #if AXIS_IS_TMC(E0)
+          tmc_stepper_current.E0 = stepperE0.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E1)
+          tmc_stepper_current.E1 = stepperE1.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E2)
+          tmc_stepper_current.E2 = stepperE2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E3)
+          tmc_stepper_current.E3 = stepperE3.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E4)
+          tmc_stepper_current.E4 = stepperE4.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E5)
+          tmc_stepper_current.E5 = stepperE5.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E6)
+          tmc_stepper_current.E6 = stepperE6.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(E7)
+          tmc_stepper_current.E7 = stepperE7.getMilliamps();
+        #endif
       #endif
       EEPROM_WRITE(tmc_stepper_current);
     }
 
     //
     // TMC Hybrid Threshold, and placeholder values
     //
     {
       _FIELD_TEST(tmc_hybrid_threshold);
 
@@ -1137,60 +1121,44 @@ void MarlinSettings::postprocess() {
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
           tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z3)
           tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z4)
           tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs();
         #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
+        #if AXIS_HAS_STEALTHCHOP(E0)
+          tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E1)
+          tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E2)
+          tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E3)
+          tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E4)
+          tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E5)
+          tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E6)
+          tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E7)
+          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
+        #endif
       #else
         const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
           .X  = 100, .Y  = 100, .Z  =   3,
           .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
           .E0 =  30, .E1 =  30, .E2 =  30,
           .E3 =  30, .E4 =  30, .E5 =  30
         };
       #endif
       EEPROM_WRITE(tmc_hybrid_threshold);
     }
@@ -1212,87 +1180,68 @@ void MarlinSettings::postprocess() {
       #endif
       EEPROM_WRITE(tmc_sgt);
     }
 
     //
     // TMC stepping mode
     //
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
-      tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
-
-      #if HAS_STEALTHCHOP
-        #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_stealth_enabled.X = stepperX.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop();
-        #endif
-        #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop();
-        #endif
-        #if MAX_EXTRUDERS
-          #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop();
-          #endif
-          #if MAX_EXTRUDERS > 1
-            #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop();
-            #endif
-            #if MAX_EXTRUDERS > 2
-              #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop();
-              #endif
-              #if MAX_EXTRUDERS > 3
-                #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop();
-                #endif
-                #if MAX_EXTRUDERS > 4
-                  #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop();
-                  #endif
-                  #if MAX_EXTRUDERS > 5
-                    #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop();
-                    #endif
-                    #if MAX_EXTRUDERS > 6
-                      #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop();
-                      #endif
-                      #if MAX_EXTRUDERS > 7
-                        #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop();
-                        #endif
-                      #endif // MAX_EXTRUDERS > 7
-                    #endif // MAX_EXTRUDERS > 6
-                  #endif // MAX_EXTRUDERS > 5
-                #endif // MAX_EXTRUDERS > 4
-              #endif // MAX_EXTRUDERS > 3
-            #endif // MAX_EXTRUDERS > 2
-          #endif // MAX_EXTRUDERS > 1
-        #endif // MAX_EXTRUDERS
+      tmc_stealth_enabled_t tmc_stealth_enabled = { false };
+      #if AXIS_HAS_STEALTHCHOP(X)
+        tmc_stealth_enabled.X = stepperX.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Y)
+        tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z)
+        tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(X2)
+        tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Y2)
+        tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z2)
+        tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z3)
+        tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(Z4)
+        tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E0)
+        tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E1)
+        tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E2)
+        tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E3)
+        tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E4)
+        tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E5)
+        tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E6)
+        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop();
+      #endif
+      #if AXIS_HAS_STEALTHCHOP(E7)
+        tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop();
       #endif
       EEPROM_WRITE(tmc_stealth_enabled);
     }
 
     //
     // Linear Advance
     //
     {
       _FIELD_TEST(planner_extruder_advance_K);
 

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index b1b9bb6e0a..21997b4740 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -139,21 +139,21 @@
 
 #if ENABLED(CASE_LIGHT_ENABLE)
   #include "../feature/caselight.h"
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  #include "../lcd/tft/touch.h"
+  #include "../lcd/tft_io/touch_calibration.h"
 #endif
 
 #if HAS_ETHERNET
   #include "../feature/ethernet.h"
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   #include "../libs/buzzer.h"
 #endif
 
@@ -436,21 +436,21 @@ typedef struct SettingsDataStruct {
   //
   #if ENABLED(PASSWORD_FEATURE)
     bool password_is_set;
     uint32_t password_value;
   #endif
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-    touch_calibration_t touch_calibration;
+    touch_calibration_t touch_calibration_data;
   #endif
 
   // Ethernet settings
   #if HAS_ETHERNET
     bool ethernet_hardware_enabled;                     // M552 S
     uint32_t ethernet_ip,                               // M552 P
              ethernet_dns,
              ethernet_gateway,                          // M553 P
              ethernet_subnet;                           // M554 P
   #endif
@@ -1403,21 +1403,21 @@ void MarlinSettings::postprocess() {
     //
     #if ENABLED(PASSWORD_FEATURE)
       EEPROM_WRITE(password.is_set);
       EEPROM_WRITE(password.value);
     #endif
 
     //
     // TOUCH_SCREEN_CALIBRATION
     //
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-      EEPROM_WRITE(touch.calibration);
+      EEPROM_WRITE(touch_calibration.calibration);
     #endif
 
     //
     // Ethernet network info
     //
     #if HAS_ETHERNET
     {
       _FIELD_TEST(ethernet_hardware_enabled);
       const bool ethernet_hardware_enabled = ethernet.hardware_enabled;
       const uint32_t ethernet_ip      = ethernet.ip,
@@ -2286,22 +2286,22 @@ void MarlinSettings::postprocess() {
       #if ENABLED(PASSWORD_FEATURE)
         _FIELD_TEST(password_is_set);
         EEPROM_READ(password.is_set);
         EEPROM_READ(password.value);
       #endif
 
       //
       // TOUCH_SCREEN_CALIBRATION
       //
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-        _FIELD_TEST(touch.calibration);
-        EEPROM_READ(touch.calibration);
+        _FIELD_TEST(touch_calibration_data);
+        EEPROM_READ(touch_calibration.calibration);
       #endif
 
       //
       // Ethernet network info
       //
       #if HAS_ETHERNET
         _FIELD_TEST(ethernet_hardware_enabled);
         uint32_t ethernet_ip, ethernet_dns, ethernet_gateway, ethernet_subnet;
         EEPROM_READ(ethernet.hardware_enabled);
         EEPROM_READ(ethernet_ip);      ethernet.ip      = ethernet_ip;
@@ -2619,21 +2619,21 @@ void MarlinSettings::reset() {
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
-  TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
+  TERN_(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration_reset());
 
   //
   // Buzzer enable/disable
   //
   TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
 
   //
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index fc432b7e9b..b1b9bb6e0a 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1490,21 +1490,21 @@ void MarlinSettings::postprocess() {
     EEPROM_READ_ALWAYS(stored_crc);
 
     // Version has to match or defaults are used
     if (strncmp(version, stored_ver, 3) != 0) {
       if (stored_ver[3] != '\0') {
         stored_ver[0] = '?';
         stored_ver[1] = '\0';
       }
       DEBUG_ECHO_START();
       DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
-      TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_version());
+      IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_version());
       eeprom_error = true;
     }
     else {
       float dummyf = 0;
       working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
 
       _FIELD_TEST(esteppers);
 
       // Number of esteppers may change
       uint8_t esteppers;
@@ -2318,27 +2318,27 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(ui.buzzer_enabled);
       #endif
 
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
-        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
+        IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
-        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_crc());
+        IF_DISABLED(EEPROM_AUTO_INIT, ui.eeprom_alert_crc());
       }
       else if (!validating) {
         DEBUG_ECHO_START();
         DEBUG_ECHO(version);
         DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
       }
 
       if (!validating && !eeprom_error) postprocess();
 
       #if ENABLED(AUTO_BED_LEVELING_UBL)

commit bdb3f1ae2fc48fd3f190d33b6dd84184e99f581c
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Oct 27 19:40:12 2020 -0700

    Fix LCD menus + DAC (#19907)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2ae4be5f49..fc432b7e9b 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3793,42 +3793,42 @@ void MarlinSettings::reset() {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
       #else
         LOOP_L_N(i, EXTRUDERS) {
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
         }
       #endif
     #endif
 
-    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+    #if EITHER(HAS_MOTOR_CURRENT_SPI, HAS_MOTOR_CURRENT_PWM)
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
         SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
             PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
                   , SP_Z_STR, stepper.motor_current_setting[1] // Z
                   , SP_E_STR, stepper.motor_current_setting[2] // E
         );
       #elif HAS_MOTOR_CURRENT_SPI
         SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
         LOOP_XYZE(q) {                                         // X Y Z E (map to X Y Z E0 by default)
           SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
         SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
         SERIAL_ECHOLN(stepper.motor_current_setting[4]);
       #endif
-    #elif HAS_MOTOR_CURRENT_I2C                                // i2c-based has any number of values
+    #elif ENABLED(HAS_MOTOR_CURRENT_I2C)                       // i2c-based has any number of values
       // Values sent over i2c are not stored.
       // Indexes map directly to drivers, not axes.
-    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                                // DAC-based has 4 values, for X Y Z E
+    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                       // DAC-based has 4 values, for X Y Z E
       // Values sent over i2c are not stored. Uses indirect mapping.
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);

commit e3f1f7cd857f9fbfdbf6d0872324cb37d069b3f6
Author: Orel <37673727+0r31@users.noreply.github.com>
Date:   Wed Oct 28 03:37:10 2020 +0100

    Fix DAC-related bugs (#19921)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 5c646c85dd..2ae4be5f49 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3814,21 +3814,21 @@ void MarlinSettings::reset() {
         LOOP_XYZE(q) {                                         // X Y Z E (map to X Y Z E0 by default)
           SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
         SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
         SERIAL_ECHOLN(stepper.motor_current_setting[4]);
       #endif
     #elif HAS_MOTOR_CURRENT_I2C                                // i2c-based has any number of values
       // Values sent over i2c are not stored.
       // Indexes map directly to drivers, not axes.
-    #elif HAS_MOTOR_CURRENT_DAC                                // DAC-based has 4 values, for X Y Z E
+    #elif ENABLED(HAS_MOTOR_CURRENT_DAC)                                // DAC-based has 4 values, for X Y Z E
       // Values sent over i2c are not stored. Uses indirect mapping.
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);

commit c0b4f4eb47ee9d657581035737383d15b3706b79
Author: Lucas Seiki Oshiro <lucasseikioshiro@gmail.com>
Date:   Tue Oct 27 22:41:12 2020 -0300

    "Sound: ON/OFF" menu item (#19901)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d01486a80d..5c646c85dd 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -146,20 +146,24 @@
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../lcd/tft/touch.h"
 #endif
 
 #if HAS_ETHERNET
   #include "../feature/ethernet.h"
 #endif
 
+#if ENABLED(SOUND_MENU_ITEM)
+  #include "../libs/buzzer.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
   void ETH0_report();
   void MAC_report();
   void M552_report();
   void M553_report();
   void M554_report();
 #endif
 
@@ -444,20 +448,26 @@ typedef struct SettingsDataStruct {
 
   // Ethernet settings
   #if HAS_ETHERNET
     bool ethernet_hardware_enabled;                     // M552 S
     uint32_t ethernet_ip,                               // M552 P
              ethernet_dns,
              ethernet_gateway,                          // M553 P
              ethernet_subnet;                           // M554 P
   #endif
 
+  //
+  // Buzzer enable/disable
+  //
+  #if ENABLED(SOUND_MENU_ITEM)
+    bool buzzer_enabled;
+  #endif
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1415,20 +1425,27 @@ void MarlinSettings::postprocess() {
                      ethernet_gateway = ethernet.gateway,
                      ethernet_subnet  = ethernet.subnet;
       EEPROM_WRITE(ethernet_hardware_enabled);
       EEPROM_WRITE(ethernet_ip);
       EEPROM_WRITE(ethernet_dns);
       EEPROM_WRITE(ethernet_gateway);
       EEPROM_WRITE(ethernet_subnet);
     }
     #endif
 
+    //
+    // Buzzer enable/disable
+    //
+    #if ENABLED(SOUND_MENU_ITEM)
+      EEPROM_WRITE(ui.buzzer_enabled);
+    #endif
+
     //
     // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
@@ -2286,20 +2303,28 @@ void MarlinSettings::postprocess() {
       #if HAS_ETHERNET
         _FIELD_TEST(ethernet_hardware_enabled);
         uint32_t ethernet_ip, ethernet_dns, ethernet_gateway, ethernet_subnet;
         EEPROM_READ(ethernet.hardware_enabled);
         EEPROM_READ(ethernet_ip);      ethernet.ip      = ethernet_ip;
         EEPROM_READ(ethernet_dns);     ethernet.myDns   = ethernet_dns;
         EEPROM_READ(ethernet_gateway); ethernet.gateway = ethernet_gateway;
         EEPROM_READ(ethernet_subnet);  ethernet.subnet  = ethernet_subnet;
       #endif
 
+      //
+      // Buzzer enable/disable
+      //
+      #if ENABLED(SOUND_MENU_ITEM)
+        _FIELD_TEST(buzzer_enabled);
+        EEPROM_READ(ui.buzzer_enabled);
+      #endif
+
       //
       // Validate Final Size and CRC
       //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
         TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
@@ -2596,20 +2621,25 @@ void MarlinSettings::reset() {
   //
   // Case Light Brightness
   //
   TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
 
+  //
+  // Buzzer enable/disable
+  //
+  TERN_(SOUND_MENU_ITEM, ui.buzzer_enabled = true);
+
   //
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
 
   //
   // Global Leveling
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
   TERN_(HAS_LEVELING, reset_bed_level());

commit 0ffee29a11eeaa488bc3f64c773e86c5944ec286
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 22:31:48 2020 -0500

    Case light brightness cleanup (#19856)
    
    Co-authored-by: Chris <chris@chrisnovoa.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 972d375848..d01486a80d 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -130,23 +130,22 @@
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #include "../feature/controllerfan.h"
 #if ENABLED(CONTROLLER_FAN_EDITABLE)
   void M710_report(const bool forReplay);
 #endif
 
-#if ENABLED(CASE_LIGHT_ENABLE) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+#if ENABLED(CASE_LIGHT_ENABLE)
   #include "../feature/caselight.h"
-  #define HAS_CASE_LIGHT_BRIGHTNESS 1
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../lcd/tft/touch.h"
 #endif
 
@@ -415,23 +414,23 @@ typedef struct SettingsDataStruct {
 
   //
   // EXTENSIBLE_UI
   //
   #if ENABLED(EXTENSIBLE_UI)
     // This is a significant hardware change; don't reserve space when not present
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
-  // HAS_CASE_LIGHT_BRIGHTNESS
+  // CASELIGHT_USES_BRIGHTNESS
   //
-  #if HAS_CASE_LIGHT_BRIGHTNESS
+  #if CASELIGHT_USES_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
   //
   // PASSWORD_FEATURE
   //
   #if ENABLED(PASSWORD_FEATURE)
     bool password_is_set;
     uint32_t password_value;
   #endif
@@ -496,21 +495,21 @@ void MarlinSettings::postprocess() {
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
 
   TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
 
   TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
 
   TERN_(FWRETRACT, fwretract.refresh_autoretract());
 
   TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
 
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.update_brightness());
+  TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.update_brightness());
 
   // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
   // and init stepper.count[], planner.position[] with current_position
   planner.refresh_positioning();
 
   // Various factors can change the current position
   if (oldpos != current_position)
     report_current_position();
 }
 
@@ -1378,21 +1377,21 @@ void MarlinSettings::postprocess() {
         char extui_data[ExtUI::eeprom_data_size] = { 0 };
         ExtUI::onStoreSettings(extui_data);
         _FIELD_TEST(extui_data);
         EEPROM_WRITE(extui_data);
       }
     #endif
 
     //
     // Case Light Brightness
     //
-    #if HAS_CASE_LIGHT_BRIGHTNESS
+    #if CASELIGHT_USES_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
     //
     // Password feature
     //
     #if ENABLED(PASSWORD_FEATURE)
       EEPROM_WRITE(password.is_set);
       EEPROM_WRITE(password.value);
     #endif
@@ -2252,21 +2251,21 @@ void MarlinSettings::postprocess() {
           const char extui_data[ExtUI::eeprom_data_size] = { 0 };
           _FIELD_TEST(extui_data);
           EEPROM_READ(extui_data);
           if (!validating) ExtUI::onLoadSettings(extui_data);
         }
       #endif
 
       //
       // Case Light Brightness
       //
-      #if HAS_CASE_LIGHT_BRIGHTNESS
+      #if CASELIGHT_USES_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 
       //
       // Password feature
       //
       #if ENABLED(PASSWORD_FEATURE)
         _FIELD_TEST(password_is_set);
         EEPROM_READ(password.is_set);
@@ -2590,21 +2589,21 @@ void MarlinSettings::reset() {
     #ifdef BACKLASH_SMOOTHING_MM
       backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 
   //
   // Case Light Brightness
   //
-  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
+  TERN_(CASELIGHT_USES_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
 
   //
   // Magnetic Parking Extruder
   //
   TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());

commit c75e98dc846d9662a7f4a234a6a73215a48e9833
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 20:54:11 2020 -0500

    Shorten a method name

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 9ed78efd63..972d375848 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1207,74 +1207,74 @@ void MarlinSettings::postprocess() {
     //
     // TMC stepping mode
     //
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
       tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
 
       #if HAS_STEALTHCHOP
         #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_stealth_enabled.X = stepperX.get_stored_stealthChop_status();
+          tmc_stealth_enabled.X = stepperX.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop_status();
+          tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop_status();
+          tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop();
         #endif
         #if MAX_EXTRUDERS
           #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop_status();
+            tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop();
           #endif
           #if MAX_EXTRUDERS > 1
             #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop_status();
+              tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop();
             #endif
             #if MAX_EXTRUDERS > 2
               #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop_status();
+                tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop();
               #endif
               #if MAX_EXTRUDERS > 3
                 #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop_status();
+                  tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop();
                 #endif
                 #if MAX_EXTRUDERS > 4
                   #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop_status();
+                    tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop();
                   #endif
                   #if MAX_EXTRUDERS > 5
                     #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop_status();
+                      tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop();
                     #endif
                     #if MAX_EXTRUDERS > 6
                       #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop_status();
+                        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop();
                       #endif
                       #if MAX_EXTRUDERS > 7
                         #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop_status();
+                          tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop();
                         #endif
                       #endif // MAX_EXTRUDERS > 7
                     #endif // MAX_EXTRUDERS > 6
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
               #endif // MAX_EXTRUDERS > 3
             #endif // MAX_EXTRUDERS > 2
           #endif // MAX_EXTRUDERS > 1
         #endif // MAX_EXTRUDERS
       #endif
@@ -3664,98 +3664,98 @@ void MarlinSettings::reset() {
         #endif
 
       #endif // USE_SENSORLESS
 
       /**
        * TMC stepping mode
        */
       #if HAS_STEALTHCHOP
         CONFIG_ECHO_HEADING("Driver stepping mode:");
         #if AXIS_HAS_STEALTHCHOP(X)
-          const bool chop_x = stepperX.get_stored_stealthChop_status();
+          const bool chop_x = stepperX.get_stored_stealthChop();
         #else
           constexpr bool chop_x = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          const bool chop_y = stepperY.get_stored_stealthChop_status();
+          const bool chop_y = stepperY.get_stored_stealthChop();
         #else
           constexpr bool chop_y = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          const bool chop_z = stepperZ.get_stored_stealthChop_status();
+          const bool chop_z = stepperZ.get_stored_stealthChop();
         #else
           constexpr bool chop_z = false;
         #endif
 
         if (chop_x || chop_y || chop_z) {
           say_M569(forReplay);
           if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
           if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
           if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
         #if AXIS_HAS_STEALTHCHOP(X2)
-          const bool chop_x2 = stepperX2.get_stored_stealthChop_status();
+          const bool chop_x2 = stepperX2.get_stored_stealthChop();
         #else
           constexpr bool chop_x2 = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          const bool chop_y2 = stepperY2.get_stored_stealthChop_status();
+          const bool chop_y2 = stepperY2.get_stored_stealthChop();
         #else
           constexpr bool chop_y2 = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          const bool chop_z2 = stepperZ2.get_stored_stealthChop_status();
+          const bool chop_z2 = stepperZ2.get_stored_stealthChop();
         #else
           constexpr bool chop_z2 = false;
         #endif
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
           if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
           if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
           if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
+          if (stepperZ3.get_stored_stealthChop()) { say_M569(forReplay, PSTR("I2 Z"), true); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(Z4)
-          if (stepperZ4.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
+          if (stepperZ4.get_stored_stealthChop()) { say_M569(forReplay, PSTR("I3 Z"), true); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
+          if (stepperE0.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T0 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
+          if (stepperE1.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T1 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
+          if (stepperE2.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T2 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
+          if (stepperE3.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T3 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
+          if (stepperE4.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T4 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
+          if (stepperE5.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T5 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E6)
-          if (stepperE6.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
+          if (stepperE6.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T6 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E7)
-          if (stepperE7.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
+          if (stepperE7.get_stored_stealthChop()) { say_M569(forReplay, PSTR("T7 E"), true); }
         #endif
 
       #endif // HAS_STEALTHCHOP
 
     #endif // HAS_TRINAMIC_CONFIG
 
     /**
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)

commit 9baa944460e0bf5f15e46a501b64ebd39a9d5f34
Author: bilsef <bilsef1@gmail.com>
Date:   Tue Oct 20 12:35:29 2020 -0700

    Teensy 4.1 Ethernet support (#19801)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index e65ace2e01..9ed78efd63 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -143,22 +143,34 @@
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../lcd/tft/touch.h"
 #endif
 
+#if HAS_ETHERNET
+  #include "../feature/ethernet.h"
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
+#if HAS_ETHERNET
+  void ETH0_report();
+  void MAC_report();
+  void M552_report();
+  void M553_report();
+  void M554_report();
+#endif
+
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
 typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
 typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
 #define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
@@ -424,20 +436,29 @@ typedef struct SettingsDataStruct {
     uint32_t password_value;
   #endif
 
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   #if ENABLED(TOUCH_SCREEN_CALIBRATION)
     touch_calibration_t touch_calibration;
   #endif
 
+  // Ethernet settings
+  #if HAS_ETHERNET
+    bool ethernet_hardware_enabled;                     // M552 S
+    uint32_t ethernet_ip,                               // M552 P
+             ethernet_dns,
+             ethernet_gateway,                          // M553 P
+             ethernet_subnet;                           // M554 P
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
 
 MarlinSettings settings;
 
 uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
 
 /**
  * Post-process after Retrieve or Reset
@@ -1377,21 +1398,40 @@ void MarlinSettings::postprocess() {
     #endif
 
     //
     // TOUCH_SCREEN_CALIBRATION
     //
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       EEPROM_WRITE(touch.calibration);
     #endif
 
     //
-    // Validate CRC and Data Size
+    // Ethernet network info
+    //
+    #if HAS_ETHERNET
+    {
+      _FIELD_TEST(ethernet_hardware_enabled);
+      const bool ethernet_hardware_enabled = ethernet.hardware_enabled;
+      const uint32_t ethernet_ip      = ethernet.ip,
+                     ethernet_dns     = ethernet.myDns,
+                     ethernet_gateway = ethernet.gateway,
+                     ethernet_subnet  = ethernet.subnet;
+      EEPROM_WRITE(ethernet_hardware_enabled);
+      EEPROM_WRITE(ethernet_ip);
+      EEPROM_WRITE(ethernet_dns);
+      EEPROM_WRITE(ethernet_gateway);
+      EEPROM_WRITE(ethernet_subnet);
+    }
+    #endif
+
+    //
+    // Report final CRC and Data Size
     //
     if (!eeprom_error) {
       const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
                      final_crc = working_crc;
 
       // Write the EEPROM header
       eeprom_index = EEPROM_OFFSET;
 
       EEPROM_WRITE(version);
       EEPROM_WRITE(final_crc);
@@ -2234,20 +2274,36 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // TOUCH_SCREEN_CALIBRATION
       //
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         _FIELD_TEST(touch.calibration);
         EEPROM_READ(touch.calibration);
       #endif
 
+      //
+      // Ethernet network info
+      //
+      #if HAS_ETHERNET
+        _FIELD_TEST(ethernet_hardware_enabled);
+        uint32_t ethernet_ip, ethernet_dns, ethernet_gateway, ethernet_subnet;
+        EEPROM_READ(ethernet.hardware_enabled);
+        EEPROM_READ(ethernet_ip);      ethernet.ip      = ethernet_ip;
+        EEPROM_READ(ethernet_dns);     ethernet.myDns   = ethernet_dns;
+        EEPROM_READ(ethernet_gateway); ethernet.gateway = ethernet_gateway;
+        EEPROM_READ(ethernet_subnet);  ethernet.subnet  = ethernet_subnet;
+      #endif
+
+      //
+      // Validate Final Size and CRC
+      //
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
         DEBUG_ECHO_START();
         DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
         TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
       }
       else if (working_crc != stored_crc) {
         eeprom_error = true;
         DEBUG_ERROR_START();
         DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
@@ -3777,15 +3833,24 @@ void MarlinSettings::reset() {
     #if HAS_FILAMENT_SENSOR
       CONFIG_ECHO_HEADING("Filament runout sensor:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR(
         "  M412 S", int(runout.enabled)
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           , " D", LINEAR_UNIT(runout.runout_distance())
         #endif
       );
     #endif
+
+    #if HAS_ETHERNET
+      CONFIG_ECHO_HEADING("Ethernet:");
+      if (!forReplay) { CONFIG_ECHO_START(); ETH0_report(); }
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); MAC_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M552_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M553_report();
+      CONFIG_ECHO_START(); SERIAL_ECHO_SP(2); M554_report();
+    #endif
   }
 
 #endif // !DISABLE_M503
 
 #pragma pack(pop)

commit 92767f5513924842498af90e8557bdf3da91c000
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 19 20:38:24 2020 -0500

    Misc. cleanup, serial strings

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f5a954f5de..e65ace2e01 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2289,21 +2289,21 @@ void MarlinSettings::postprocess() {
           else {
             ubl.reset();
             DEBUG_ECHOLNPGM("UBL reset");
           }
         }
       #endif
     }
 
     #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
       // Report the EEPROM settings
-      if (!validating && (DISABLED(EEPROM_BOOT_SILENT) || IsRunning())) report();
+      if (!validating && TERN1(EEPROM_BOOT_SILENT, IsRunning())) report();
     #endif
 
     EEPROM_FINISH();
 
     return !eeprom_error;
   }
 
   #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
     extern bool restoreEEPROM();
   #endif

commit 6fed11896ba7c51ba5f5ade4346c94ff048b1718
Author: Sten Uusvali <31988255+nuevocampo@users.noreply.github.com>
Date:   Sat Oct 17 14:11:22 2020 -0700

    Fix M503 output for M907 motor current (#19777)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index eac2af38c3..f5a954f5de 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -3712,33 +3712,39 @@ void MarlinSettings::reset() {
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
         }
       #endif
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
       #if HAS_MOTOR_CURRENT_PWM
-        SERIAL_ECHOLNPAIR_P(
-            PSTR("  M907 X"), stepper.motor_current_setting[0]
-          , SP_Z_STR, stepper.motor_current_setting[1]
-          , SP_E_STR, stepper.motor_current_setting[2]
+        SERIAL_ECHOLNPAIR_P(                                   // PWM-based has 3 values:
+            PSTR("  M907 X"), stepper.motor_current_setting[0] // X and Y
+                  , SP_Z_STR, stepper.motor_current_setting[1] // Z
+                  , SP_E_STR, stepper.motor_current_setting[2] // E
         );
       #elif HAS_MOTOR_CURRENT_SPI
-        SERIAL_ECHOPGM("  M907");
-        LOOP_L_N(q, MOTOR_CURRENT_COUNT) {
-          SERIAL_CHAR(' ');
-          SERIAL_CHAR(axis_codes[q]);
+        SERIAL_ECHOPGM("  M907");                              // SPI-based has 5 values:
+        LOOP_XYZE(q) {                                         // X Y Z E (map to X Y Z E0 by default)
+          SERIAL_CHAR(' ', axis_codes[q]);
           SERIAL_ECHO(stepper.motor_current_setting[q]);
         }
-      #endif
+        SERIAL_CHAR(' ', 'B');                                 // B (maps to E1 by default)
+        SERIAL_ECHOLN(stepper.motor_current_setting[4]);
+      #endif
+    #elif HAS_MOTOR_CURRENT_I2C                                // i2c-based has any number of values
+      // Values sent over i2c are not stored.
+      // Indexes map directly to drivers, not axes.
+    #elif HAS_MOTOR_CURRENT_DAC                                // DAC-based has 4 values, for X Y Z E
+      // Values sent over i2c are not stored. Uses indirect mapping.
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);
         SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 33e5c351ab..eac2af38c3 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -47,21 +47,21 @@
 
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif
 
 #include "probe.h"
 

commit 492ba2a111ce541513d4515c4af3f57ceaa897ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 11 14:58:35 2020 -0500

    Digipots refactor / cleanup (#19690)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3ccd8ffd91..33e5c351ab 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -29,21 +29,21 @@
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V81"
+#define EEPROM_VERSION "V82"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
@@ -358,21 +358,24 @@ typedef struct SettingsDataStruct {
   tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
 
   //
   // LIN_ADVANCE
   //
   float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
 
   //
   // HAS_MOTOR_CURRENT_PWM
   //
-  uint32_t motor_current_setting[3];                    // M907 X Z E
+  #ifndef MOTOR_CURRENT_COUNT
+    #define MOTOR_CURRENT_COUNT 3
+  #endif
+  uint32_t motor_current_setting[MOTOR_CURRENT_COUNT];  // M907 X Z E
 
   //
   // CNC_COORDINATE_SYSTEMS
   //
   xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
 
   //
   // SKEW_CORRECTION
   //
   skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
@@ -1270,24 +1273,24 @@ void MarlinSettings::postprocess() {
         for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummyf);
       #endif
     }
 
     //
     // Motor Current PWM
     //
     {
       _FIELD_TEST(motor_current_setting);
 
-      #if HAS_MOTOR_CURRENT_PWM
+      #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
         EEPROM_WRITE(stepper.motor_current_setting);
       #else
-        const uint32_t no_current[3] = { 0 };
+        const uint32_t no_current[MOTOR_CURRENT_COUNT] = { 0 };
         EEPROM_WRITE(no_current);
       #endif
     }
 
     //
     // CNC Coordinate Systems
     //
 
     _FIELD_TEST(coordinate_system);
 
@@ -2103,24 +2106,30 @@ void MarlinSettings::postprocess() {
         #if ENABLED(LIN_ADVANCE)
           if (!validating)
             COPY(planner.extruder_advance_K, extruder_advance_K);
         #endif
       }
 
       //
       // Motor Current PWM
       //
       {
-        uint32_t motor_current_setting[3];
         _FIELD_TEST(motor_current_setting);
+        uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]
+          #if HAS_MOTOR_CURRENT_SPI
+             = DIGIPOT_MOTOR_CURRENT
+          #endif
+        ;
+        DEBUG_ECHOLNPGM("DIGIPOTS Loading");
         EEPROM_READ(motor_current_setting);
-        #if HAS_MOTOR_CURRENT_PWM
+        DEBUG_ECHOLNPGM("DIGIPOTS Loaded");
+        #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
           if (!validating)
             COPY(stepper.motor_current_setting, motor_current_setting);
         #endif
       }
 
       //
       // CNC Coordinate System
       //
       {
         _FIELD_TEST(coordinate_system);
@@ -2784,23 +2793,34 @@ void MarlinSettings::reset() {
       planner.extruder_advance_K[i] = LIN_ADVANCE_K;
       TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[i] = LIN_ADVANCE_K);
     }
   #endif
 
   //
   // Motor Current PWM
   //
 
   #if HAS_MOTOR_CURRENT_PWM
-    constexpr uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
-    LOOP_L_N(q, 3)
-      stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
+    constexpr uint32_t tmp_motor_current_setting[MOTOR_CURRENT_COUNT] = PWM_MOTOR_CURRENT;
+    LOOP_L_N(q, MOTOR_CURRENT_COUNT)
+      stepper.set_digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
+  #endif
+
+  //
+  // DIGIPOTS
+  //
+  #if HAS_MOTOR_CURRENT_SPI
+    static constexpr uint32_t tmp_motor_current_setting[] = DIGIPOT_MOTOR_CURRENT;
+    DEBUG_ECHOLNPGM("Writing Digipot");
+    LOOP_L_N(q, COUNT(tmp_motor_current_setting))
+      stepper.set_digipot_current(q, tmp_motor_current_setting[q]);
+    DEBUG_ECHOLNPGM("Digipot Written");
   #endif
 
   //
   // CNC Coordinate System
   //
   TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
 
   //
   // Skew Correction
   //
@@ -3688,28 +3708,37 @@ void MarlinSettings::reset() {
         CONFIG_ECHO_START();
         SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
       #else
         LOOP_L_N(i, EXTRUDERS) {
           CONFIG_ECHO_START();
           SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
         }
       #endif
     #endif
 
-    #if HAS_MOTOR_CURRENT_PWM
+    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       CONFIG_ECHO_HEADING("Stepper motor currents:");
       CONFIG_ECHO_START();
-      SERIAL_ECHOLNPAIR_P(
-          PSTR("  M907 X"), stepper.motor_current_setting[0]
-        , SP_Z_STR, stepper.motor_current_setting[1]
-        , SP_E_STR, stepper.motor_current_setting[2]
-      );
+      #if HAS_MOTOR_CURRENT_PWM
+        SERIAL_ECHOLNPAIR_P(
+            PSTR("  M907 X"), stepper.motor_current_setting[0]
+          , SP_Z_STR, stepper.motor_current_setting[1]
+          , SP_E_STR, stepper.motor_current_setting[2]
+        );
+      #elif HAS_MOTOR_CURRENT_SPI
+        SERIAL_ECHOPGM("  M907");
+        LOOP_L_N(q, MOTOR_CURRENT_COUNT) {
+          SERIAL_CHAR(' ');
+          SERIAL_CHAR(axis_codes[q]);
+          SERIAL_ECHO(stepper.motor_current_setting[q]);
+        }
+      #endif
     #endif
 
     /**
      * Advanced Pause filament load & unload lengths
      */
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);
         SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 0fc23099cc..3ccd8ffd91 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -26,21 +26,20 @@
  * Settings and EEPROM storage
  *
  * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,
  *       either sets a Sane Default, or results in No Change to the existing value.
- *
  */
 
 // Change EEPROM version if the structure changes
 #define EEPROM_VERSION "V81"
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
 // Can be disabled for production build.
 //#define DEBUG_EEPROM_READWRITE
 

commit e3d4e328f93a04020124082a8342a34956a79ce4
Author: ellensp <ellensp@hotmail.com>
Date:   Thu Sep 24 08:44:15 2020 +1200

    Preserve brightness in EEPROM validate (#19485)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 6608b40332..0fc23099cc 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1797,24 +1797,25 @@ void MarlinSettings::postprocess() {
         #endif
         _FIELD_TEST(power_monitor_flags);
         EEPROM_READ(power_monitor_flags);
       }
 
       //
       // LCD Contrast
       //
       {
         _FIELD_TEST(lcd_contrast);
-
         int16_t lcd_contrast;
         EEPROM_READ(lcd_contrast);
-        TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
+        if (!validating) {
+          TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
+        }
       }
 
       //
       // Controller Fan
       //
       {
         _FIELD_TEST(controllerFan_settings);
         #if ENABLED(CONTROLLER_FAN_EDITABLE)
           const controllerFan_settings_t &cfs = controllerFan.settings;
         #else

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3cb88da4ee..6608b40332 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -108,21 +108,21 @@
   #include "../feature/runout.h"
   #ifndef FIL_RUNOUT_ENABLED_DEFAULT
     #define FIL_RUNOUT_ENABLED_DEFAULT true
   #endif
 #endif
 
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
   extern float other_extruder_advance_K[EXTRUDERS];
 #endif
 
-#if EXTRUDERS > 1
+#if HAS_MULTI_EXTRUDER
   #include "tool_change.h"
   void M217_report(const bool eeprom);
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "stepper/indirection.h"
@@ -381,21 +381,21 @@ typedef struct SettingsDataStruct {
   //
   // ADVANCED_PAUSE_FEATURE
   //
   #if EXTRUDERS
     fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
   #endif
 
   //
   // Tool-change settings
   //
-  #if EXTRUDERS > 1
+  #if HAS_MULTI_EXTRUDER
     toolchange_settings_t toolchange_settings;          // M217 S P R
   #endif
 
   //
   // BACKLASH_COMPENSATION
   //
   xyz_float_t backlash_distance_mm;                     // M425 X Y Z
   uint8_t backlash_correction;                          // M425 F
   float backlash_smoothing_mm;                          // M425 S
 
@@ -1313,21 +1313,21 @@ void MarlinSettings::postprocess() {
       #endif
       _FIELD_TEST(fc_settings);
       EEPROM_WRITE(fc_settings);
     }
     #endif
 
     //
     // Multiple Extruders
     //
 
-    #if EXTRUDERS > 1
+    #if HAS_MULTI_EXTRUDER
       _FIELD_TEST(toolchange_settings);
       EEPROM_WRITE(toolchange_settings);
     #endif
 
     //
     // Backlash Compensation
     //
     {
       #if ENABLED(BACKLASH_GCODE)
         const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
@@ -2160,21 +2160,21 @@ void MarlinSettings::postprocess() {
           fil_change_settings_t fc_settings[EXTRUDERS];
         #endif
         _FIELD_TEST(fc_settings);
         EEPROM_READ(fc_settings);
       }
       #endif
 
       //
       // Tool-change settings
       //
-      #if EXTRUDERS > 1
+      #if HAS_MULTI_EXTRUDER
         _FIELD_TEST(toolchange_settings);
         EEPROM_READ(toolchange_settings);
       #endif
 
       //
       // Backlash Compensation
       //
       {
         #if ENABLED(BACKLASH_GCODE)
           const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
@@ -2481,21 +2481,21 @@ void MarlinSettings::reset() {
   #if HAS_FILAMENT_SENSOR
     runout.enabled = FIL_RUNOUT_ENABLED_DEFAULT;
     runout.reset();
     TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM));
   #endif
 
   //
   // Tool-change Settings
   //
 
-  #if EXTRUDERS > 1
+  #if HAS_MULTI_EXTRUDER
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       toolchange_settings.swap_length     = TOOLCHANGE_FS_LENGTH;
       toolchange_settings.extra_resume    = TOOLCHANGE_FS_EXTRA_RESUME_LENGTH;
       toolchange_settings.retract_speed   = TOOLCHANGE_FS_RETRACT_SPEED;
       toolchange_settings.unretract_speed = TOOLCHANGE_FS_UNRETRACT_SPEED;
       toolchange_settings.extra_prime     = TOOLCHANGE_FS_EXTRA_PRIME;
       toolchange_settings.prime_speed     = TOOLCHANGE_FS_PRIME_SPEED;
       toolchange_settings.fan_speed       = TOOLCHANGE_FS_FAN_SPEED;
       toolchange_settings.fan_time        = TOOLCHANGE_FS_FAN_TIME;
     #endif
@@ -3712,21 +3712,21 @@ void MarlinSettings::reset() {
       CONFIG_ECHO_HEADING("Filament load/unload lengths:");
       #if EXTRUDERS == 1
         say_M603(forReplay);
         SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
       #else
         #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0);
         REPEAT(EXTRUDERS, _ECHO_603)
       #endif
     #endif
 
-    #if EXTRUDERS > 1
+    #if HAS_MULTI_EXTRUDER
       CONFIG_ECHO_HEADING("Tool-changing:");
       CONFIG_ECHO_START();
       M217_report(true);
     #endif
 
     #if ENABLED(BACKLASH_GCODE)
       CONFIG_ECHO_HEADING("Backlash compensation:");
       CONFIG_ECHO_START();
       SERIAL_ECHOLNPAIR_P(
           PSTR("  M425 F"), backlash.get_correction()

commit 9fd06fa7678efd6838fbe7c47e2b65a892be4b2c
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Sep 19 08:23:56 2020 -0600

    Fix case light brightness save/load (#19436)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 2c679068b9..3cb88da4ee 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -131,21 +131,21 @@
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
   #include "../feature/probe_temp_comp.h"
 #endif
 
 #include "../feature/controllerfan.h"
 #if ENABLED(CONTROLLER_FAN_EDITABLE)
   void M710_report(const bool forReplay);
 #endif
 
-#if ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+#if ENABLED(CASE_LIGHT_ENABLE) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
   #include "../feature/caselight.h"
   #define HAS_CASE_LIGHT_BRIGHTNESS 1
 #endif
 
 #if ENABLED(PASSWORD_FEATURE)
   #include "../feature/password/password.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../lcd/tft/touch.h"

commit c04d5624da568c1069065902373f1abce11e03ba
Author: ManuelMcLure <manuel@mclure.org>
Date:   Sat Sep 12 20:59:20 2020 -0700

    Read from backup TMC StealthChop state (#19364)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8af2071e36..2c679068b9 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1184,74 +1184,74 @@ void MarlinSettings::postprocess() {
     //
     // TMC stepping mode
     //
     {
       _FIELD_TEST(tmc_stealth_enabled);
 
       tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
 
       #if HAS_STEALTHCHOP
         #if AXIS_HAS_STEALTHCHOP(X)
-          tmc_stealth_enabled.X = stepperX.get_stealthChop_status();
+          tmc_stealth_enabled.X = stepperX.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          tmc_stealth_enabled.Y = stepperY.get_stealthChop_status();
+          tmc_stealth_enabled.Y = stepperY.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          tmc_stealth_enabled.Z = stepperZ.get_stealthChop_status();
+          tmc_stealth_enabled.Z = stepperZ.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(X2)
-          tmc_stealth_enabled.X2 = stepperX2.get_stealthChop_status();
+          tmc_stealth_enabled.X2 = stepperX2.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          tmc_stealth_enabled.Y2 = stepperY2.get_stealthChop_status();
+          tmc_stealth_enabled.Y2 = stepperY2.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          tmc_stealth_enabled.Z2 = stepperZ2.get_stealthChop_status();
+          tmc_stealth_enabled.Z2 = stepperZ2.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          tmc_stealth_enabled.Z3 = stepperZ3.get_stealthChop_status();
+          tmc_stealth_enabled.Z3 = stepperZ3.get_stored_stealthChop_status();
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z4)
-          tmc_stealth_enabled.Z4 = stepperZ4.get_stealthChop_status();
+          tmc_stealth_enabled.Z4 = stepperZ4.get_stored_stealthChop_status();
         #endif
         #if MAX_EXTRUDERS
           #if AXIS_HAS_STEALTHCHOP(E0)
-            tmc_stealth_enabled.E0 = stepperE0.get_stealthChop_status();
+            tmc_stealth_enabled.E0 = stepperE0.get_stored_stealthChop_status();
           #endif
           #if MAX_EXTRUDERS > 1
             #if AXIS_HAS_STEALTHCHOP(E1)
-              tmc_stealth_enabled.E1 = stepperE1.get_stealthChop_status();
+              tmc_stealth_enabled.E1 = stepperE1.get_stored_stealthChop_status();
             #endif
             #if MAX_EXTRUDERS > 2
               #if AXIS_HAS_STEALTHCHOP(E2)
-                tmc_stealth_enabled.E2 = stepperE2.get_stealthChop_status();
+                tmc_stealth_enabled.E2 = stepperE2.get_stored_stealthChop_status();
               #endif
               #if MAX_EXTRUDERS > 3
                 #if AXIS_HAS_STEALTHCHOP(E3)
-                  tmc_stealth_enabled.E3 = stepperE3.get_stealthChop_status();
+                  tmc_stealth_enabled.E3 = stepperE3.get_stored_stealthChop_status();
                 #endif
                 #if MAX_EXTRUDERS > 4
                   #if AXIS_HAS_STEALTHCHOP(E4)
-                    tmc_stealth_enabled.E4 = stepperE4.get_stealthChop_status();
+                    tmc_stealth_enabled.E4 = stepperE4.get_stored_stealthChop_status();
                   #endif
                   #if MAX_EXTRUDERS > 5
                     #if AXIS_HAS_STEALTHCHOP(E5)
-                      tmc_stealth_enabled.E5 = stepperE5.get_stealthChop_status();
+                      tmc_stealth_enabled.E5 = stepperE5.get_stored_stealthChop_status();
                     #endif
                     #if MAX_EXTRUDERS > 6
                       #if AXIS_HAS_STEALTHCHOP(E6)
-                        tmc_stealth_enabled.E6 = stepperE6.get_stealthChop_status();
+                        tmc_stealth_enabled.E6 = stepperE6.get_stored_stealthChop_status();
                       #endif
                       #if MAX_EXTRUDERS > 7
                         #if AXIS_HAS_STEALTHCHOP(E7)
-                          tmc_stealth_enabled.E7 = stepperE7.get_stealthChop_status();
+                          tmc_stealth_enabled.E7 = stepperE7.get_stored_stealthChop_status();
                         #endif
                       #endif // MAX_EXTRUDERS > 7
                     #endif // MAX_EXTRUDERS > 6
                   #endif // MAX_EXTRUDERS > 5
                 #endif // MAX_EXTRUDERS > 4
               #endif // MAX_EXTRUDERS > 3
             #endif // MAX_EXTRUDERS > 2
           #endif // MAX_EXTRUDERS > 1
         #endif // MAX_EXTRUDERS
       #endif
@@ -3588,98 +3588,98 @@ void MarlinSettings::reset() {
         #endif
 
       #endif // USE_SENSORLESS
 
       /**
        * TMC stepping mode
        */
       #if HAS_STEALTHCHOP
         CONFIG_ECHO_HEADING("Driver stepping mode:");
         #if AXIS_HAS_STEALTHCHOP(X)
-          const bool chop_x = stepperX.get_stealthChop_status();
+          const bool chop_x = stepperX.get_stored_stealthChop_status();
         #else
           constexpr bool chop_x = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y)
-          const bool chop_y = stepperY.get_stealthChop_status();
+          const bool chop_y = stepperY.get_stored_stealthChop_status();
         #else
           constexpr bool chop_y = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z)
-          const bool chop_z = stepperZ.get_stealthChop_status();
+          const bool chop_z = stepperZ.get_stored_stealthChop_status();
         #else
           constexpr bool chop_z = false;
         #endif
 
         if (chop_x || chop_y || chop_z) {
           say_M569(forReplay);
           if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
           if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
           if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
         #if AXIS_HAS_STEALTHCHOP(X2)
-          const bool chop_x2 = stepperX2.get_stealthChop_status();
+          const bool chop_x2 = stepperX2.get_stored_stealthChop_status();
         #else
           constexpr bool chop_x2 = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Y2)
-          const bool chop_y2 = stepperY2.get_stealthChop_status();
+          const bool chop_y2 = stepperY2.get_stored_stealthChop_status();
         #else
           constexpr bool chop_y2 = false;
         #endif
         #if AXIS_HAS_STEALTHCHOP(Z2)
-          const bool chop_z2 = stepperZ2.get_stealthChop_status();
+          const bool chop_z2 = stepperZ2.get_stored_stealthChop_status();
         #else
           constexpr bool chop_z2 = false;
         #endif
 
         if (chop_x2 || chop_y2 || chop_z2) {
           say_M569(forReplay, PSTR("I1"));
           if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
           if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
           if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
           SERIAL_EOL();
         }
 
         #if AXIS_HAS_STEALTHCHOP(Z3)
-          if (stepperZ3.get_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
+          if (stepperZ3.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(Z4)
-          if (stepperZ4.get_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
+          if (stepperZ4.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
         #endif
 
         #if AXIS_HAS_STEALTHCHOP(E0)
-          if (stepperE0.get_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
+          if (stepperE0.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E1)
-          if (stepperE1.get_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
+          if (stepperE1.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E2)
-          if (stepperE2.get_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
+          if (stepperE2.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E3)
-          if (stepperE3.get_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
+          if (stepperE3.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E4)
-          if (stepperE4.get_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
+          if (stepperE4.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E5)
-          if (stepperE5.get_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
+          if (stepperE5.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E6)
-          if (stepperE6.get_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
+          if (stepperE6.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
         #endif
         #if AXIS_HAS_STEALTHCHOP(E7)
-          if (stepperE7.get_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
+          if (stepperE7.get_stored_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
         #endif
 
       #endif // HAS_STEALTHCHOP
 
     #endif // HAS_TRINAMIC_CONFIG
 
     /**
      * Linear Advance
      */
     #if ENABLED(LIN_ADVANCE)

commit a445746a8b6dd752de725eb67d264153c3b393d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 6 21:40:58 2020 -0500

    Clean up LCD conditionals, DWIN

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index d5f41a3246..8af2071e36 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -45,21 +45,21 @@
 //#define DEBUG_EEPROM_READWRITE
 
 #include "settings.h"
 
 #include "endstops.h"
 #include "planner.h"
 #include "stepper.h"
 #include "temperature.h"
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../lcd/dwin/dwin.h"
+  #include "../lcd/dwin/e3v2/dwin.h"
 #endif
 
 #include "../lcd/ultralcd.h"
 #include "../libs/vector_3.h"   // for matrix_3x3
 #include "../gcode/gcode.h"
 #include "../MarlinCore.h"
 
 #if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
   #include "../HAL/shared/eeprom_api.h"
 #endif

commit 7807b613d5c0ff74a26b884c1aaf1b253467c3bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 20 00:08:06 2020 -0500

    Update some comments

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 29b12e5caf..d5f41a3246 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -14,21 +14,21 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
- * configuration_store.cpp
+ * settings.cpp
  *
  * Settings and EEPROM storage
  *
  * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
  * in the functions below, also increment the version number. This makes sure that
  * the default values are used whenever there is a change to the data, to prevent
  * wrong data being written to the variables.
  *
  * ALSO: Variables in the Store and Retrieve sections must be in the same order.
  *       If a feature is disabled, some data must still be written that, when read,

commit a62ae2aa2d74613fe15bf2b8ca4390fca53ebf01
Author: Steven Haigh <netwiz@crc.id.au>
Date:   Thu Aug 20 09:58:18 2020 +1000

    Default Filament Runout Sensor enabled state (#19013)

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index c84bbb44ae..29b12e5caf 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -99,20 +99,23 @@
 #endif
 
 #include "../feature/pause.h"
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "../feature/runout.h"
+  #ifndef FIL_RUNOUT_ENABLED_DEFAULT
+    #define FIL_RUNOUT_ENABLED_DEFAULT true
+  #endif
 #endif
 
 #if ENABLED(EXTRA_LIN_ADVANCE_K)
   extern float other_extruder_advance_K[EXTRUDERS];
 #endif
 
 #if EXTRUDERS > 1
   #include "tool_change.h"
   void M217_report(const bool eeprom);
 #endif
@@ -639,29 +642,30 @@ void MarlinSettings::postprocess() {
       #endif
     }
 
     //
     // Filament Runout Sensor
     //
     {
       #if HAS_FILAMENT_SENSOR
         const bool &runout_sensor_enabled = runout.enabled;
       #else
-        constexpr bool runout_sensor_enabled = true;
+        constexpr int8_t runout_sensor_enabled = -1;
       #endif
+      _FIELD_TEST(runout_sensor_enabled);
+      EEPROM_WRITE(runout_sensor_enabled);
+
       #if HAS_FILAMENT_RUNOUT_DISTANCE
         const float &runout_distance_mm = runout.runout_distance();
       #else
         constexpr float runout_distance_mm = 0;
       #endif
-      _FIELD_TEST(runout_sensor_enabled);
-      EEPROM_WRITE(runout_sensor_enabled);
       EEPROM_WRITE(runout_distance_mm);
     }
 
     //
     // Global Leveling
     //
     {
       const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, 10.0f);
       EEPROM_WRITE(zfh);
     }
@@ -1511,27 +1515,26 @@ void MarlinSettings::postprocess() {
           // Skip hotend 0 which must be 0
           LOOP_S_L_N(e, 1, HOTENDS)
             EEPROM_READ(hotend_offset[e]);
         #endif
       }
 
       //
       // Filament Runout Sensor
       //
       {
-        #if HAS_FILAMENT_SENSOR
-          const bool &runout_sensor_enabled = runout.enabled;
-        #else
-          bool runout_sensor_enabled;
-        #endif
+        int8_t runout_sensor_enabled;
         _FIELD_TEST(runout_sensor_enabled);
         EEPROM_READ(runout_sensor_enabled);
+        #if HAS_FILAMENT_SENSOR
+          runout.enabled = runout_sensor_enabled < 0 ? FIL_RUNOUT_ENABLED_DEFAULT : runout_sensor_enabled;
+        #endif
 
         TERN_(HAS_FILAMENT_SENSOR, if (runout.enabled) runout.reset());
 
         float runout_distance_mm;
         EEPROM_READ(runout_distance_mm);
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
 
@@ -2469,21 +2472,21 @@ void MarlinSettings::reset() {
     home_offset.reset();
   #endif
 
   TERN_(HAS_HOTEND_OFFSET, reset_hotend_offsets());
 
   //
   // Filament Runout Sensor
   //
 
   #if HAS_FILAMENT_SENSOR
-    runout.enabled = true;
+    runout.enabled = FIL_RUNOUT_ENABLED_DEFAULT;
     runout.reset();
     TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM));
   #endif
 
   //
   // Tool-change Settings
   //
 
   #if EXTRUDERS > 1
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)

commit 56b35fc1039843bd6884fea872e424018335c0cb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 14 00:16:12 2020 -0500

    Do runout.reset after EEPROM read

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index f1ab0fca69..c84bbb44ae 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -619,21 +619,26 @@ void MarlinSettings::postprocess() {
       _FIELD_TEST(home_offset);
 
       #if HAS_SCARA_OFFSET
         EEPROM_WRITE(scara_home_offset);
       #else
         #if !HAS_HOME_OFFSET
           const xyz_pos_t home_offset{0};
         #endif
         EEPROM_WRITE(home_offset);
       #endif
+    }
 
+    //
+    // Hotend Offsets, if any
+    //
+    {
       #if HAS_HOTEND_OFFSET
         // Skip hotend 0 which must be 0
         LOOP_S_L_N(e, 1, HOTENDS)
           EEPROM_WRITE(hotend_offset[e]);
       #endif
     }
 
     //
     // Filament Runout Sensor
     //
@@ -1514,20 +1519,22 @@ void MarlinSettings::postprocess() {
       //
       {
         #if HAS_FILAMENT_SENSOR
           const bool &runout_sensor_enabled = runout.enabled;
         #else
           bool runout_sensor_enabled;
         #endif
         _FIELD_TEST(runout_sensor_enabled);
         EEPROM_READ(runout_sensor_enabled);
 
+        TERN_(HAS_FILAMENT_SENSOR, if (runout.enabled) runout.reset());
+
         float runout_distance_mm;
         EEPROM_READ(runout_distance_mm);
         #if HAS_FILAMENT_RUNOUT_DISTANCE
           if (!validating) runout.set_runout_distance(runout_distance_mm);
         #endif
       }
 
       //
       // Global Leveling
       //

commit 852e5ae0421810ecc6f44631237208030e70751f
Author: sherwin-dc <59867245+sherwin-dc@users.noreply.github.com>
Date:   Sun Aug 9 09:00:42 2020 +0800

    Password via G-code and MarlinUI (#18399)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 34af8f2ea3..f1ab0fca69 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -133,33 +133,37 @@
 #include "../feature/controllerfan.h"
 #if ENABLED(CONTROLLER_FAN_EDITABLE)
   void M710_report(const bool forReplay);
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
   #include "../feature/caselight.h"
   #define HAS_CASE_LIGHT_BRIGHTNESS 1
 #endif
 
+#if ENABLED(PASSWORD_FEATURE)
+  #include "../feature/password/password.h"
+#endif
+
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../lcd/tft/touch.h"
 #endif
 
 #pragma pack(push, 1) // No padding between variables
 
 typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
 typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
 typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
 typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
 
 // Limit an index to an array size
-#define ALIM(I,ARR) _MIN(I, signed(COUNT(ARR) - 1))
+#define ALIM(I,ARR) _MIN(I, (signed)COUNT(ARR) - 1)
 
 // Defaults for reset / fill in on load
 static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
 static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
 static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
 
 extern const char SP_X_STR[], SP_Y_STR[], SP_Z_STR[], SP_E_STR[];
 
 /**
  * Current EEPROM Layout
@@ -400,20 +404,28 @@ typedef struct SettingsDataStruct {
     uint8_t extui_data[ExtUI::eeprom_data_size];
   #endif
 
   //
   // HAS_CASE_LIGHT_BRIGHTNESS
   //
   #if HAS_CASE_LIGHT_BRIGHTNESS
     uint8_t caselight_brightness;                        // M355 P
   #endif
 
+  //
+  // PASSWORD_FEATURE
+  //
+  #if ENABLED(PASSWORD_FEATURE)
+    bool password_is_set;
+    uint32_t password_value;
+  #endif
+
   //
   // TOUCH_SCREEN_CALIBRATION
   //
   #if ENABLED(TOUCH_SCREEN_CALIBRATION)
     touch_calibration_t touch_calibration;
   #endif
 
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
@@ -1338,20 +1350,28 @@ void MarlinSettings::postprocess() {
       }
     #endif
 
     //
     // Case Light Brightness
     //
     #if HAS_CASE_LIGHT_BRIGHTNESS
       EEPROM_WRITE(caselight.brightness);
     #endif
 
+    //
+    // Password feature
+    //
+    #if ENABLED(PASSWORD_FEATURE)
+      EEPROM_WRITE(password.is_set);
+      EEPROM_WRITE(password.value);
+    #endif
+
     //
     // TOUCH_SCREEN_CALIBRATION
     //
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       EEPROM_WRITE(touch.calibration);
     #endif
 
     //
     // Validate CRC and Data Size
     //
@@ -2178,20 +2198,29 @@ void MarlinSettings::postprocess() {
       #endif
 
       //
       // Case Light Brightness
       //
       #if HAS_CASE_LIGHT_BRIGHTNESS
         _FIELD_TEST(caselight_brightness);
         EEPROM_READ(caselight.brightness);
       #endif
 
+      //
+      // Password feature
+      //
+      #if ENABLED(PASSWORD_FEATURE)
+        _FIELD_TEST(password_is_set);
+        EEPROM_READ(password.is_set);
+        EEPROM_READ(password.value);
+      #endif
+
       //
       // TOUCH_SCREEN_CALIBRATION
       //
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         _FIELD_TEST(touch.calibration);
         EEPROM_READ(touch.calibration);
       #endif
 
       eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
       if (eeprom_error) {
@@ -2658,21 +2687,21 @@ void MarlinSettings::reset() {
             ARRAY_BY_HOTENDS1(DEFAULT_Kf)
           #endif
         ;
         static_assert(WITHIN(COUNT(defKf), 1, HOTENDS), "DEFAULT_Kf_LIST must have between 1 and HOTENDS items.");
       #endif
       #define PID_DEFAULT(N,E) def##N[E]
     #else
       #define PID_DEFAULT(N,E) DEFAULT_##N
     #endif
     HOTEND_LOOP() {
-      PID_PARAM(Kp, e) = float(PID_DEFAULT(Kp, ALIM(e, defKp)));
+      PID_PARAM(Kp, e) =      float(PID_DEFAULT(Kp, ALIM(e, defKp)));
       PID_PARAM(Ki, e) = scalePID_i(PID_DEFAULT(Ki, ALIM(e, defKi)));
       PID_PARAM(Kd, e) = scalePID_d(PID_DEFAULT(Kd, ALIM(e, defKd)));
       TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = float(PID_DEFAULT(Kc, ALIM(e, defKc))));
       TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = float(PID_DEFAULT(Kf, ALIM(e, defKf))));
     }
   #endif
 
   //
   // PID Extrusion Scaling
   //
@@ -2776,20 +2805,29 @@ void MarlinSettings::reset() {
   //
   // Advanced Pause filament load & unload lengths
   //
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     LOOP_L_N(e, EXTRUDERS) {
       fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
       fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
     }
   #endif
 
+  #if ENABLED(PASSWORD_FEATURE)
+    #ifdef PASSWORD_DEFAULT_VALUE
+      password.is_set = true;
+      password.value = PASSWORD_DEFAULT_VALUE;
+    #else
+      password.is_set = false;
+    #endif
+  #endif
+
   postprocess();
 
   DEBUG_ECHO_START();
   DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
 
   TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
 }
 
 #if DISABLED(DISABLE_M503)
 

commit 97cb0a8c3e3dbaeac07935938b145237a7285d8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 27 18:09:52 2020 -0500

    General cleanup

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 3df2067f5f..34af8f2ea3 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -2510,22 +2510,21 @@ void MarlinSettings::reset() {
   //
   TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
   TERN_(HAS_LEVELING, reset_bed_level());
 
   #if HAS_BED_PROBE
     constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
     static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
     #if HAS_PROBE_XY_OFFSET
       LOOP_XYZ(a) probe.offset[a] = dpo[a];
     #else
-      probe.offset.x = probe.offset.y = 0;
-      probe.offset.z = dpo[Z_AXIS];
+      probe.offset.set(0, 0, dpo[Z_AXIS]);
     #endif
   #endif
 
   //
   // Z Stepper Auto-alignment points
   //
   TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
 
   //
   // Servo Angles

commit 18adfe87bcd516436db001b53a0e09e58246c9e2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 7 20:51:40 2020 -0500

    configuration_store => settings

diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
new file mode 100644
index 0000000000..3df2067f5f
--- /dev/null
+++ b/Marlin/src/module/settings.cpp
@@ -0,0 +1,3709 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * configuration_store.cpp
+ *
+ * Settings and EEPROM storage
+ *
+ * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM
+ * in the functions below, also increment the version number. This makes sure that
+ * the default values are used whenever there is a change to the data, to prevent
+ * wrong data being written to the variables.
+ *
+ * ALSO: Variables in the Store and Retrieve sections must be in the same order.
+ *       If a feature is disabled, some data must still be written that, when read,
+ *       either sets a Sane Default, or results in No Change to the existing value.
+ *
+ */
+
+// Change EEPROM version if the structure changes
+#define EEPROM_VERSION "V81"
+#define EEPROM_OFFSET 100
+
+// Check the integrity of data offsets.
+// Can be disabled for production build.
+//#define DEBUG_EEPROM_READWRITE
+
+#include "settings.h"
+
+#include "endstops.h"
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../lcd/dwin/dwin.h"
+#endif
+
+#include "../lcd/ultralcd.h"
+#include "../libs/vector_3.h"   // for matrix_3x3
+#include "../gcode/gcode.h"
+#include "../MarlinCore.h"
+
+#if EITHER(EEPROM_SETTINGS, SD_FIRMWARE_UPDATE)
+  #include "../HAL/shared/eeprom_api.h"
+#endif
+
+#include "probe.h"
+
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
+#if ENABLED(Z_STEPPER_AUTO_ALIGN)
+  #include "../feature/z_stepper_align.h"
+#endif
+
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extui/ui_api.h"
+#endif
+
+#if HAS_SERVOS
+  #include "servo.h"
+#endif
+
+#if HAS_SERVOS && HAS_SERVO_ANGLES
+  #define EEPROM_NUM_SERVOS NUM_SERVOS
+#else
+  #define EEPROM_NUM_SERVOS NUM_SERVO_PLUGS
+#endif
+
+#include "../feature/fwretract.h"
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/powerloss.h"
+#endif
+
+#if HAS_POWER_MONITOR
+  #include "../feature/power_monitor.h"
+#endif
+
+#include "../feature/pause.h"
+
+#if ENABLED(BACKLASH_COMPENSATION)
+  #include "../feature/backlash.h"
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  #include "../feature/runout.h"
+#endif
+
+#if ENABLED(EXTRA_LIN_ADVANCE_K)
+  extern float other_extruder_advance_K[EXTRUDERS];
+#endif
+
+#if EXTRUDERS > 1
+  #include "tool_change.h"
+  void M217_report(const bool eeprom);
+#endif
+
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
+#if HAS_TRINAMIC_CONFIG
+  #include "stepper/indirection.h"
+  #include "../feature/tmc_util.h"
+#endif
+
+#if ENABLED(PROBE_TEMP_COMPENSATION)
+  #include "../feature/probe_temp_comp.h"
+#endif
+
+#include "../feature/controllerfan.h"
+#if ENABLED(CONTROLLER_FAN_EDITABLE)
+  void M710_report(const bool forReplay);
+#endif
+
+#if ENABLED(CASE_LIGHT_MENU) && DISABLED(CASE_LIGHT_NO_BRIGHTNESS)
+  #include "../feature/caselight.h"
+  #define HAS_CASE_LIGHT_BRIGHTNESS 1
+#endif
+
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  #include "../lcd/tft/touch.h"
+#endif
+
+#pragma pack(push, 1) // No padding between variables
+
+typedef struct { uint16_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stepper_current_t;
+typedef struct { uint32_t X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_hybrid_threshold_t;
+typedef struct {  int16_t X, Y, Z, X2, Y2, Z2, Z3, Z4;                                 } tmc_sgt_t;
+typedef struct {     bool X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7; } tmc_stealth_enabled_t;
+
+// Limit an index to an array size
+#define ALIM(I,ARR) _MIN(I, signed(COUNT(ARR) - 1))
+
+// Defaults for reset / fill in on load
+static const uint32_t   _DMA[] PROGMEM = DEFAULT_MAX_ACCELERATION;
+static const float     _DASU[] PROGMEM = DEFAULT_AXIS_STEPS_PER_UNIT;
+static const feedRate_t _DMF[] PROGMEM = DEFAULT_MAX_FEEDRATE;
+
+extern const char SP_X_STR[], SP_Y_STR[], SP_Z_STR[], SP_E_STR[];
+
+/**
+ * Current EEPROM Layout
+ *
+ * Keep this data structure up to date so
+ * EEPROM size is known at compile time!
+ */
+typedef struct SettingsDataStruct {
+  char      version[4];                                 // Vnn\0
+  uint16_t  crc;                                        // Data Checksum
+
+  //
+  // DISTINCT_E_FACTORS
+  //
+  uint8_t   esteppers;                                  // XYZE_N - XYZ
+
+  planner_settings_t planner_settings;
+
+  xyze_float_t planner_max_jerk;                        // M205 XYZE  planner.max_jerk
+  float planner_junction_deviation_mm;                  // M205 J     planner.junction_deviation_mm
+
+  xyz_pos_t home_offset;                                // M206 XYZ / M665 TPZ
+
+  #if HAS_HOTEND_OFFSET
+    xyz_pos_t hotend_offset[HOTENDS - 1];               // M218 XYZ
+  #endif
+
+  //
+  // FILAMENT_RUNOUT_SENSOR
+  //
+  bool runout_sensor_enabled;                           // M412 S
+  float runout_distance_mm;                             // M412 D
+
+  //
+  // ENABLE_LEVELING_FADE_HEIGHT
+  //
+  float planner_z_fade_height;                          // M420 Zn  planner.z_fade_height
+
+  //
+  // MESH_BED_LEVELING
+  //
+  float mbl_z_offset;                                   // mbl.z_offset
+  uint8_t mesh_num_x, mesh_num_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  float mbl_z_values[TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3)]   // mbl.z_values
+                    [TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3)];
+
+  //
+  // HAS_BED_PROBE
+  //
+
+  xyz_pos_t probe_offset;
+
+  //
+  // ABL_PLANAR
+  //
+  matrix_3x3 planner_bed_level_matrix;                  // planner.bed_level_matrix
+
+  //
+  // AUTO_BED_LEVELING_BILINEAR
+  //
+  uint8_t grid_max_x, grid_max_y;                       // GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y
+  xy_pos_t bilinear_grid_spacing, bilinear_start;       // G29 L F
+  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    bed_mesh_t z_values;                                // G29
+  #else
+    float z_values[3][3];
+  #endif
+
+  //
+  // AUTO_BED_LEVELING_UBL
+  //
+  bool planner_leveling_active;                         // M420 S  planner.leveling_active
+  int8_t ubl_storage_slot;                              // ubl.storage_slot
+
+  //
+  // SERVO_ANGLES
+  //
+  uint16_t servo_angles[EEPROM_NUM_SERVOS][2];          // M281 P L U
+
+  //
+  // Temperature first layer compensation values
+  //
+  #if ENABLED(PROBE_TEMP_COMPENSATION)
+    int16_t z_offsets_probe[COUNT(temp_comp.z_offsets_probe)], // M871 P I V
+            z_offsets_bed[COUNT(temp_comp.z_offsets_bed)]      // M871 B I V
+            #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+              , z_offsets_ext[COUNT(temp_comp.z_offsets_ext)]  // M871 E I V
+            #endif
+            ;
+  #endif
+
+  //
+  // BLTOUCH
+  //
+  bool bltouch_last_written_mode;
+
+  //
+  // DELTA / [XYZ]_DUAL_ENDSTOPS
+  //
+  #if ENABLED(DELTA)
+    float delta_height;                                 // M666 H
+    abc_float_t delta_endstop_adj;                      // M666 X Y Z
+    float delta_radius,                                 // M665 R
+          delta_diagonal_rod,                           // M665 L
+          delta_segments_per_second;                    // M665 S
+    abc_float_t delta_tower_angle_trim,                 // M665 X Y Z
+                delta_diagonal_rod_trim;                // M665 A B C
+  #elif HAS_EXTRA_ENDSTOPS
+    float x2_endstop_adj,                               // M666 X
+          y2_endstop_adj,                               // M666 Y
+          z2_endstop_adj,                               // M666 (S2) Z
+          z3_endstop_adj,                               // M666 (S3) Z
+          z4_endstop_adj;                               // M666 (S4) Z
+  #endif
+
+  //
+  // Z_STEPPER_AUTO_ALIGN, Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
+  //
+  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+    xy_pos_t z_stepper_align_xy[NUM_Z_STEPPER_DRIVERS];             // M422 S X Y
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      xy_pos_t z_stepper_align_stepper_xy[NUM_Z_STEPPER_DRIVERS];   // M422 W X Y
+    #endif
+  #endif
+
+  //
+  // Material Presets
+  //
+  #if PREHEAT_COUNT
+    preheat_t ui_material_preset[PREHEAT_COUNT];        // M145 S0 H B F
+  #endif
+
+  //
+  // PIDTEMP
+  //
+  PIDCF_t hotendPID[HOTENDS];                           // M301 En PIDCF / M303 En U
+  int16_t lpq_len;                                      // M301 L
+
+  //
+  // PIDTEMPBED
+  //
+  PID_t bedPID;                                         // M304 PID / M303 E-1 U
+
+  //
+  // User-defined Thermistors
+  //
+  #if HAS_USER_THERMISTORS
+    user_thermistor_t user_thermistor[USER_THERMISTORS]; // M305 P0 R4700 T100000 B3950
+  #endif
+
+  //
+  // Power monitor
+  //
+  uint8_t power_monitor_flags;                          // M430 I V W
+
+  //
+  // HAS_LCD_CONTRAST
+  //
+  int16_t lcd_contrast;                                 // M250 C
+
+  //
+  // Controller fan settings
+  //
+  controllerFan_settings_t controllerFan_settings;      // M710
+
+  //
+  // POWER_LOSS_RECOVERY
+  //
+  bool recovery_enabled;                                // M413 S
+
+  //
+  // FWRETRACT
+  //
+  fwretract_settings_t fwretract_settings;              // M207 S F Z W, M208 S F W R
+  bool autoretract_enabled;                             // M209 S
+
+  //
+  // !NO_VOLUMETRIC
+  //
+  bool parser_volumetric_enabled;                       // M200 S  parser.volumetric_enabled
+  float planner_filament_size[EXTRUDERS];               // M200 T D  planner.filament_size[]
+  float planner_volumetric_extruder_limit[EXTRUDERS];   // M200 T L  planner.volumetric_extruder_limit[]
+
+  //
+  // HAS_TRINAMIC_CONFIG
+  //
+  tmc_stepper_current_t tmc_stepper_current;            // M906 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  tmc_hybrid_threshold_t tmc_hybrid_threshold;          // M913 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+  tmc_sgt_t tmc_sgt;                                    // M914 X Y Z X2 Y2 Z2 Z3 Z4
+  tmc_stealth_enabled_t tmc_stealth_enabled;            // M569 X Y Z X2 Y2 Z2 Z3 Z4 E0 E1 E2 E3 E4 E5
+
+  //
+  // LIN_ADVANCE
+  //
+  float planner_extruder_advance_K[_MAX(EXTRUDERS, 1)]; // M900 K  planner.extruder_advance_K
+
+  //
+  // HAS_MOTOR_CURRENT_PWM
+  //
+  uint32_t motor_current_setting[3];                    // M907 X Z E
+
+  //
+  // CNC_COORDINATE_SYSTEMS
+  //
+  xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];  // G54-G59.3
+
+  //
+  // SKEW_CORRECTION
+  //
+  skew_factor_t planner_skew_factor;                    // M852 I J K  planner.skew_factor
+
+  //
+  // ADVANCED_PAUSE_FEATURE
+  //
+  #if EXTRUDERS
+    fil_change_settings_t fc_settings[EXTRUDERS];       // M603 T U L
+  #endif
+
+  //
+  // Tool-change settings
+  //
+  #if EXTRUDERS > 1
+    toolchange_settings_t toolchange_settings;          // M217 S P R
+  #endif
+
+  //
+  // BACKLASH_COMPENSATION
+  //
+  xyz_float_t backlash_distance_mm;                     // M425 X Y Z
+  uint8_t backlash_correction;                          // M425 F
+  float backlash_smoothing_mm;                          // M425 S
+
+  //
+  // EXTENSIBLE_UI
+  //
+  #if ENABLED(EXTENSIBLE_UI)
+    // This is a significant hardware change; don't reserve space when not present
+    uint8_t extui_data[ExtUI::eeprom_data_size];
+  #endif
+
+  //
+  // HAS_CASE_LIGHT_BRIGHTNESS
+  //
+  #if HAS_CASE_LIGHT_BRIGHTNESS
+    uint8_t caselight_brightness;                        // M355 P
+  #endif
+
+  //
+  // TOUCH_SCREEN_CALIBRATION
+  //
+  #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+    touch_calibration_t touch_calibration;
+  #endif
+
+} SettingsData;
+
+//static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
+
+MarlinSettings settings;
+
+uint16_t MarlinSettings::datasize() { return sizeof(SettingsData); }
+
+/**
+ * Post-process after Retrieve or Reset
+ */
+
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+  float new_z_fade_height;
+#endif
+
+void MarlinSettings::postprocess() {
+  xyze_pos_t oldpos = current_position;
+
+  // steps per s2 needs to be updated to agree with units per s2
+  planner.reset_acceleration_rates();
+
+  // Make sure delta kinematics are updated before refreshing the
+  // planner position so the stepper counts will be set correctly.
+  TERN_(DELTA, recalc_delta_settings());
+
+  TERN_(PIDTEMP, thermalManager.updatePID());
+
+  #if DISABLED(NO_VOLUMETRICS)
+    planner.calculate_volumetric_multipliers();
+  #elif EXTRUDERS
+    for (uint8_t i = COUNT(planner.e_factor); i--;)
+      planner.refresh_e_factor(i);
+  #endif
+
+  // Software endstops depend on home_offset
+  LOOP_XYZ(i) {
+    update_workspace_offset((AxisEnum)i);
+    update_software_endstops((AxisEnum)i);
+  }
+
+  TERN_(ENABLE_LEVELING_FADE_HEIGHT, set_z_fade_height(new_z_fade_height, false)); // false = no report
+
+  TERN_(AUTO_BED_LEVELING_BILINEAR, refresh_bed_level());
+
+  TERN_(HAS_MOTOR_CURRENT_PWM, stepper.refresh_motor_power());
+
+  TERN_(FWRETRACT, fwretract.refresh_autoretract());
+
+  TERN_(HAS_LINEAR_E_JERK, planner.recalculate_max_e_jerk());
+
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.update_brightness());
+
+  // Refresh steps_to_mm with the reciprocal of axis_steps_per_mm
+  // and init stepper.count[], planner.position[] with current_position
+  planner.refresh_positioning();
+
+  // Various factors can change the current position
+  if (oldpos != current_position)
+    report_current_position();
+}
+
+#if BOTH(PRINTCOUNTER, EEPROM_SETTINGS)
+  #include "printcounter.h"
+  static_assert(
+    !WITHIN(STATS_EEPROM_ADDRESS, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)) &&
+    !WITHIN(STATS_EEPROM_ADDRESS + sizeof(printStatistics), EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
+    "STATS_EEPROM_ADDRESS collides with EEPROM settings storage."
+  );
+#endif
+
+#if ENABLED(SD_FIRMWARE_UPDATE)
+
+  #if ENABLED(EEPROM_SETTINGS)
+    static_assert(
+      !WITHIN(SD_FIRMWARE_UPDATE_EEPROM_ADDR, EEPROM_OFFSET, EEPROM_OFFSET + sizeof(SettingsData)),
+      "SD_FIRMWARE_UPDATE_EEPROM_ADDR collides with EEPROM settings storage."
+    );
+  #endif
+
+  bool MarlinSettings::sd_update_status() {
+    uint8_t val;
+    persistentStore.read_data(SD_FIRMWARE_UPDATE_EEPROM_ADDR, &val);
+    return (val == SD_FIRMWARE_UPDATE_ACTIVE_VALUE);
+  }
+
+  bool MarlinSettings::set_sd_update_status(const bool enable) {
+    if (enable != sd_update_status())
+      persistentStore.write_data(
+        SD_FIRMWARE_UPDATE_EEPROM_ADDR,
+        enable ? SD_FIRMWARE_UPDATE_ACTIVE_VALUE : SD_FIRMWARE_UPDATE_INACTIVE_VALUE
+      );
+    return true;
+  }
+
+#endif // SD_FIRMWARE_UPDATE
+
+#ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+  static_assert(
+      EEPROM_OFFSET + sizeof(SettingsData) < ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE,
+      "ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE is insufficient to capture all EEPROM data."
+    );
+#endif
+
+#define DEBUG_OUT ENABLED(EEPROM_CHITCHAT)
+#include "../core/debug_out.h"
+
+#if ENABLED(EEPROM_SETTINGS)
+
+  #define EEPROM_START()          if (!persistentStore.access_start()) { SERIAL_ECHO_MSG("No EEPROM."); return false; } \
+                                  int eeprom_index = EEPROM_OFFSET
+  #define EEPROM_FINISH()         persistentStore.access_finish()
+  #define EEPROM_SKIP(VAR)        (eeprom_index += sizeof(VAR))
+  #define EEPROM_WRITE(VAR)       do{ persistentStore.write_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);              }while(0)
+  #define EEPROM_READ(VAR)        do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc, !validating);  }while(0)
+  #define EEPROM_READ_ALWAYS(VAR) do{ persistentStore.read_data(eeprom_index, (uint8_t*)&VAR, sizeof(VAR), &working_crc);               }while(0)
+  #define EEPROM_ASSERT(TST,ERR)  do{ if (!(TST)) { SERIAL_ERROR_MSG(ERR); eeprom_error = true; } }while(0)
+
+  #if ENABLED(DEBUG_EEPROM_READWRITE)
+    #define _FIELD_TEST(FIELD) \
+      EEPROM_ASSERT( \
+        eeprom_error || eeprom_index == offsetof(SettingsData, FIELD) + EEPROM_OFFSET, \
+        "Field " STRINGIFY(FIELD) " mismatch." \
+      )
+  #else
+    #define _FIELD_TEST(FIELD) NOOP
+  #endif
+
+  const char version[4] = EEPROM_VERSION;
+
+  bool MarlinSettings::eeprom_error, MarlinSettings::validating;
+
+  bool MarlinSettings::size_error(const uint16_t size) {
+    if (size != datasize()) {
+      DEBUG_ERROR_MSG("EEPROM datasize error.");
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * M500 - Store Configuration
+   */
+  bool MarlinSettings::save() {
+    float dummyf = 0;
+    char ver[4] = "ERR";
+
+    uint16_t working_crc = 0;
+
+    EEPROM_START();
+
+    eeprom_error = false;
+
+    // Write or Skip version. (Flash doesn't allow rewrite without erase.)
+    TERN(FLASH_EEPROM_EMULATION, EEPROM_SKIP, EEPROM_WRITE)(ver);
+
+    EEPROM_SKIP(working_crc); // Skip the checksum slot
+
+    working_crc = 0; // clear before first "real data"
+
+    _FIELD_TEST(esteppers);
+
+    const uint8_t esteppers = COUNT(planner.settings.axis_steps_per_mm) - XYZ;
+    EEPROM_WRITE(esteppers);
+
+    //
+    // Planner Motion
+    //
+    {
+      EEPROM_WRITE(planner.settings);
+
+      #if HAS_CLASSIC_JERK
+        EEPROM_WRITE(planner.max_jerk);
+        #if HAS_LINEAR_E_JERK
+          dummyf = float(DEFAULT_EJERK);
+          EEPROM_WRITE(dummyf);
+        #endif
+      #else
+        const xyze_pos_t planner_max_jerk = { 10, 10, 0.4, float(DEFAULT_EJERK) };
+        EEPROM_WRITE(planner_max_jerk);
+      #endif
+
+      TERN_(CLASSIC_JERK, dummyf = 0.02f);
+      EEPROM_WRITE(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
+    }
+
+    //
+    // Home Offset
+    //
+    {
+      _FIELD_TEST(home_offset);
+
+      #if HAS_SCARA_OFFSET
+        EEPROM_WRITE(scara_home_offset);
+      #else
+        #if !HAS_HOME_OFFSET
+          const xyz_pos_t home_offset{0};
+        #endif
+        EEPROM_WRITE(home_offset);
+      #endif
+
+      #if HAS_HOTEND_OFFSET
+        // Skip hotend 0 which must be 0
+        LOOP_S_L_N(e, 1, HOTENDS)
+          EEPROM_WRITE(hotend_offset[e]);
+      #endif
+    }
+
+    //
+    // Filament Runout Sensor
+    //
+    {
+      #if HAS_FILAMENT_SENSOR
+        const bool &runout_sensor_enabled = runout.enabled;
+      #else
+        constexpr bool runout_sensor_enabled = true;
+      #endif
+      #if HAS_FILAMENT_RUNOUT_DISTANCE
+        const float &runout_distance_mm = runout.runout_distance();
+      #else
+        constexpr float runout_distance_mm = 0;
+      #endif
+      _FIELD_TEST(runout_sensor_enabled);
+      EEPROM_WRITE(runout_sensor_enabled);
+      EEPROM_WRITE(runout_distance_mm);
+    }
+
+    //
+    // Global Leveling
+    //
+    {
+      const float zfh = TERN(ENABLE_LEVELING_FADE_HEIGHT, planner.z_fade_height, 10.0f);
+      EEPROM_WRITE(zfh);
+    }
+
+    //
+    // Mesh Bed Leveling
+    //
+    {
+      #if ENABLED(MESH_BED_LEVELING)
+        static_assert(
+          sizeof(mbl.z_values) == (GRID_MAX_POINTS) * sizeof(mbl.z_values[0][0]),
+          "MBL Z array is the wrong size."
+        );
+      #else
+        dummyf = 0;
+      #endif
+
+      const uint8_t mesh_num_x = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_X, 3),
+                    mesh_num_y = TERN(MESH_BED_LEVELING, GRID_MAX_POINTS_Y, 3);
+
+      EEPROM_WRITE(TERN(MESH_BED_LEVELING, mbl.z_offset, dummyf));
+      EEPROM_WRITE(mesh_num_x);
+      EEPROM_WRITE(mesh_num_y);
+
+      #if ENABLED(MESH_BED_LEVELING)
+        EEPROM_WRITE(mbl.z_values);
+      #else
+        for (uint8_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_WRITE(dummyf);
+      #endif
+    }
+
+    //
+    // Probe XYZ Offsets
+    //
+    {
+      _FIELD_TEST(probe_offset);
+      #if HAS_BED_PROBE
+        const xyz_pos_t &zpo = probe.offset;
+      #else
+        constexpr xyz_pos_t zpo{0};
+      #endif
+      EEPROM_WRITE(zpo);
+    }
+
+    //
+    // Planar Bed Leveling matrix
+    //
+    {
+      #if ABL_PLANAR
+        EEPROM_WRITE(planner.bed_level_matrix);
+      #else
+        dummyf = 0;
+        for (uint8_t q = 9; q--;) EEPROM_WRITE(dummyf);
+      #endif
+    }
+
+    //
+    // Bilinear Auto Bed Leveling
+    //
+    {
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        static_assert(
+          sizeof(z_values) == (GRID_MAX_POINTS) * sizeof(z_values[0][0]),
+          "Bilinear Z array is the wrong size."
+        );
+      #else
+        const xy_pos_t bilinear_start{0}, bilinear_grid_spacing{0};
+      #endif
+
+      const uint8_t grid_max_x = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_X, 3),
+                    grid_max_y = TERN(AUTO_BED_LEVELING_BILINEAR, GRID_MAX_POINTS_Y, 3);
+      EEPROM_WRITE(grid_max_x);
+      EEPROM_WRITE(grid_max_y);
+      EEPROM_WRITE(bilinear_grid_spacing);
+      EEPROM_WRITE(bilinear_start);
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        EEPROM_WRITE(z_values);              // 9-256 floats
+      #else
+        dummyf = 0;
+        for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_WRITE(dummyf);
+      #endif
+    }
+
+    //
+    // Unified Bed Leveling
+    //
+    {
+      _FIELD_TEST(planner_leveling_active);
+      const bool ubl_active = TERN(AUTO_BED_LEVELING_UBL, planner.leveling_active, false);
+      const int8_t storage_slot = TERN(AUTO_BED_LEVELING_UBL, ubl.storage_slot, -1);
+      EEPROM_WRITE(ubl_active);
+      EEPROM_WRITE(storage_slot);
+    }
+
+    //
+    // Servo Angles
+    //
+    {
+      _FIELD_TEST(servo_angles);
+      #if !HAS_SERVO_ANGLES
+        uint16_t servo_angles[EEPROM_NUM_SERVOS][2] = { { 0, 0 } };
+      #endif
+      EEPROM_WRITE(servo_angles);
+    }
+
+    //
+    // Thermal first layer compensation values
+    //
+    #if ENABLED(PROBE_TEMP_COMPENSATION)
+      EEPROM_WRITE(temp_comp.z_offsets_probe);
+      EEPROM_WRITE(temp_comp.z_offsets_bed);
+      #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+        EEPROM_WRITE(temp_comp.z_offsets_ext);
+      #endif
+    #else
+      // No placeholder data for this feature
+    #endif
+
+    //
+    // BLTOUCH
+    //
+    {
+      _FIELD_TEST(bltouch_last_written_mode);
+      const bool bltouch_last_written_mode = TERN(BLTOUCH, bltouch.last_written_mode, false);
+      EEPROM_WRITE(bltouch_last_written_mode);
+    }
+
+    //
+    // DELTA Geometry or Dual Endstops offsets
+    //
+    {
+      #if ENABLED(DELTA)
+
+        _FIELD_TEST(delta_height);
+
+        EEPROM_WRITE(delta_height);              // 1 float
+        EEPROM_WRITE(delta_endstop_adj);         // 3 floats
+        EEPROM_WRITE(delta_radius);              // 1 float
+        EEPROM_WRITE(delta_diagonal_rod);        // 1 float
+        EEPROM_WRITE(delta_segments_per_second); // 1 float
+        EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
+        EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
+
+      #elif HAS_EXTRA_ENDSTOPS
+
+        _FIELD_TEST(x2_endstop_adj);
+
+        // Write dual endstops in X, Y, Z order. Unused = 0.0
+        dummyf = 0;
+        EEPROM_WRITE(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));   // 1 float
+        EEPROM_WRITE(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));   // 1 float
+        EEPROM_WRITE(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf));  // 1 float
+
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+          EEPROM_WRITE(endstops.z3_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummyf);
+        #endif
+
+        #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+          EEPROM_WRITE(endstops.z4_endstop_adj);   // 1 float
+        #else
+          EEPROM_WRITE(dummyf);
+        #endif
+
+      #endif
+    }
+
+    #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+      EEPROM_WRITE(z_stepper_align.xy);
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        EEPROM_WRITE(z_stepper_align.stepper_xy);
+      #endif
+    #endif
+
+    //
+    // LCD Preheat settings
+    //
+    #if PREHEAT_COUNT
+      _FIELD_TEST(ui_material_preset);
+      EEPROM_WRITE(ui.material_preset);
+    #endif
+
+    //
+    // PIDTEMP
+    //
+    {
+      _FIELD_TEST(hotendPID);
+      HOTEND_LOOP() {
+        PIDCF_t pidcf = {
+          #if DISABLED(PIDTEMP)
+            NAN, NAN, NAN,
+            NAN, NAN
+          #else
+                         PID_PARAM(Kp, e),
+            unscalePID_i(PID_PARAM(Ki, e)),
+            unscalePID_d(PID_PARAM(Kd, e)),
+                         PID_PARAM(Kc, e),
+                         PID_PARAM(Kf, e)
+          #endif
+        };
+        EEPROM_WRITE(pidcf);
+      }
+
+      _FIELD_TEST(lpq_len);
+      #if DISABLED(PID_EXTRUSION_SCALING)
+        const int16_t lpq_len = 20;
+      #endif
+      EEPROM_WRITE(TERN(PID_EXTRUSION_SCALING, thermalManager.lpq_len, lpq_len));
+    }
+
+    //
+    // PIDTEMPBED
+    //
+    {
+      _FIELD_TEST(bedPID);
+
+      const PID_t bed_pid = {
+        #if DISABLED(PIDTEMPBED)
+          NAN, NAN, NAN
+        #else
+          // Store the unscaled PID values
+          thermalManager.temp_bed.pid.Kp,
+          unscalePID_i(thermalManager.temp_bed.pid.Ki),
+          unscalePID_d(thermalManager.temp_bed.pid.Kd)
+        #endif
+      };
+      EEPROM_WRITE(bed_pid);
+    }
+
+    //
+    // User-defined Thermistors
+    //
+    #if HAS_USER_THERMISTORS
+    {
+      _FIELD_TEST(user_thermistor);
+      EEPROM_WRITE(thermalManager.user_thermistor);
+    }
+    #endif
+
+    //
+    // Power monitor
+    //
+    {
+      #if HAS_POWER_MONITOR
+        const uint8_t &power_monitor_flags = power_monitor.flags;
+      #else
+        constexpr uint8_t power_monitor_flags = 0x00;
+      #endif
+      _FIELD_TEST(power_monitor_flags);
+      EEPROM_WRITE(power_monitor_flags);
+    }
+
+    //
+    // LCD Contrast
+    //
+    {
+      _FIELD_TEST(lcd_contrast);
+
+      const int16_t lcd_contrast =
+        #if HAS_LCD_CONTRAST
+          ui.contrast
+        #else
+          127
+        #endif
+      ;
+      EEPROM_WRITE(lcd_contrast);
+    }
+
+    //
+    // Controller Fan
+    //
+    {
+      _FIELD_TEST(controllerFan_settings);
+      #if ENABLED(USE_CONTROLLER_FAN)
+        const controllerFan_settings_t &cfs = controllerFan.settings;
+      #else
+        controllerFan_settings_t cfs = controllerFan_defaults;
+      #endif
+      EEPROM_WRITE(cfs);
+    }
+
+    //
+    // Power-Loss Recovery
+    //
+    {
+      _FIELD_TEST(recovery_enabled);
+      const bool recovery_enabled = TERN(POWER_LOSS_RECOVERY, recovery.enabled, ENABLED(PLR_ENABLED_DEFAULT));
+      EEPROM_WRITE(recovery_enabled);
+    }
+
+    //
+    // Firmware Retraction
+    //
+    {
+      _FIELD_TEST(fwretract_settings);
+      #if DISABLED(FWRETRACT)
+        const fwretract_settings_t autoretract_defaults = { 3, 45, 0, 0, 0, 13, 0, 8 };
+      #endif
+      EEPROM_WRITE(TERN(FWRETRACT, fwretract.settings, autoretract_defaults));
+
+      #if DISABLED(FWRETRACT_AUTORETRACT)
+        const bool autoretract_enabled = false;
+      #endif
+      EEPROM_WRITE(TERN(FWRETRACT_AUTORETRACT, fwretract.autoretract_enabled, autoretract_enabled));
+    }
+
+    //
+    // Volumetric & Filament Size
+    //
+    {
+      _FIELD_TEST(parser_volumetric_enabled);
+
+      #if DISABLED(NO_VOLUMETRICS)
+
+        EEPROM_WRITE(parser.volumetric_enabled);
+        EEPROM_WRITE(planner.filament_size);
+        #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+          EEPROM_WRITE(planner.volumetric_extruder_limit);
+        #else
+          dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
+          for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
+        #endif
+
+      #else
+
+        const bool volumetric_enabled = false;
+        EEPROM_WRITE(volumetric_enabled);
+        dummyf = DEFAULT_NOMINAL_FILAMENT_DIA;
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
+        dummyf = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
+        for (uint8_t q = EXTRUDERS; q--;) EEPROM_WRITE(dummyf);
+
+      #endif
+    }
+
+    //
+    // TMC Configuration
+    //
+    {
+      _FIELD_TEST(tmc_stepper_current);
+
+      tmc_stepper_current_t tmc_stepper_current = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+      #if HAS_TRINAMIC_CONFIG
+        #if AXIS_IS_TMC(X)
+          tmc_stepper_current.X = stepperX.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y)
+          tmc_stepper_current.Y = stepperY.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z)
+          tmc_stepper_current.Z = stepperZ.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(X2)
+          tmc_stepper_current.X2 = stepperX2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          tmc_stepper_current.Y2 = stepperY2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          tmc_stepper_current.Z2 = stepperZ2.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z3)
+          tmc_stepper_current.Z3 = stepperZ3.getMilliamps();
+        #endif
+        #if AXIS_IS_TMC(Z4)
+          tmc_stepper_current.Z4 = stepperZ4.getMilliamps();
+        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_IS_TMC(E0)
+            tmc_stepper_current.E0 = stepperE0.getMilliamps();
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_IS_TMC(E1)
+              tmc_stepper_current.E1 = stepperE1.getMilliamps();
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_IS_TMC(E2)
+                tmc_stepper_current.E2 = stepperE2.getMilliamps();
+              #endif
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_IS_TMC(E3)
+                  tmc_stepper_current.E3 = stepperE3.getMilliamps();
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_IS_TMC(E4)
+                    tmc_stepper_current.E4 = stepperE4.getMilliamps();
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_IS_TMC(E5)
+                      tmc_stepper_current.E5 = stepperE5.getMilliamps();
+                    #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_IS_TMC(E6)
+                        tmc_stepper_current.E6 = stepperE6.getMilliamps();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_IS_TMC(E7)
+                          tmc_stepper_current.E7 = stepperE7.getMilliamps();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #endif
+      EEPROM_WRITE(tmc_stepper_current);
+    }
+
+    //
+    // TMC Hybrid Threshold, and placeholder values
+    //
+    {
+      _FIELD_TEST(tmc_hybrid_threshold);
+
+      #if ENABLED(HYBRID_THRESHOLD)
+       tmc_hybrid_threshold_t tmc_hybrid_threshold = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+        #if AXIS_HAS_STEALTHCHOP(X)
+          tmc_hybrid_threshold.X = stepperX.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          tmc_hybrid_threshold.Y = stepperY.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          tmc_hybrid_threshold.Z = stepperZ.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          tmc_hybrid_threshold.X2 = stepperX2.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          tmc_hybrid_threshold.Y2 = stepperY2.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          tmc_hybrid_threshold.Z2 = stepperZ2.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          tmc_hybrid_threshold.Z3 = stepperZ3.get_pwm_thrs();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          tmc_hybrid_threshold.Z4 = stepperZ4.get_pwm_thrs();
+        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_HAS_STEALTHCHOP(E0)
+            tmc_hybrid_threshold.E0 = stepperE0.get_pwm_thrs();
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              tmc_hybrid_threshold.E1 = stepperE1.get_pwm_thrs();
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_HAS_STEALTHCHOP(E2)
+                tmc_hybrid_threshold.E2 = stepperE2.get_pwm_thrs();
+              #endif
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_HAS_STEALTHCHOP(E3)
+                  tmc_hybrid_threshold.E3 = stepperE3.get_pwm_thrs();
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_HAS_STEALTHCHOP(E4)
+                    tmc_hybrid_threshold.E4 = stepperE4.get_pwm_thrs();
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_HAS_STEALTHCHOP(E5)
+                      tmc_hybrid_threshold.E5 = stepperE5.get_pwm_thrs();
+                    #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_HAS_STEALTHCHOP(E6)
+                        tmc_hybrid_threshold.E6 = stepperE6.get_pwm_thrs();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_HAS_STEALTHCHOP(E7)
+                          tmc_hybrid_threshold.E7 = stepperE7.get_pwm_thrs();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #else
+        const tmc_hybrid_threshold_t tmc_hybrid_threshold = {
+          .X  = 100, .Y  = 100, .Z  =   3,
+          .X2 = 100, .Y2 = 100, .Z2 =   3, .Z3 =   3, .Z4 = 3,
+          .E0 =  30, .E1 =  30, .E2 =  30,
+          .E3 =  30, .E4 =  30, .E5 =  30
+        };
+      #endif
+      EEPROM_WRITE(tmc_hybrid_threshold);
+    }
+
+    //
+    // TMC StallGuard threshold
+    //
+    {
+      tmc_sgt_t tmc_sgt{0};
+      #if USE_SENSORLESS
+        TERN_(X_SENSORLESS,  tmc_sgt.X  = stepperX.homing_threshold());
+        TERN_(X2_SENSORLESS, tmc_sgt.X2 = stepperX2.homing_threshold());
+        TERN_(Y_SENSORLESS,  tmc_sgt.Y  = stepperY.homing_threshold());
+        TERN_(Y2_SENSORLESS, tmc_sgt.Y2 = stepperY2.homing_threshold());
+        TERN_(Z_SENSORLESS,  tmc_sgt.Z  = stepperZ.homing_threshold());
+        TERN_(Z2_SENSORLESS, tmc_sgt.Z2 = stepperZ2.homing_threshold());
+        TERN_(Z3_SENSORLESS, tmc_sgt.Z3 = stepperZ3.homing_threshold());
+        TERN_(Z4_SENSORLESS, tmc_sgt.Z4 = stepperZ4.homing_threshold());
+      #endif
+      EEPROM_WRITE(tmc_sgt);
+    }
+
+    //
+    // TMC stepping mode
+    //
+    {
+      _FIELD_TEST(tmc_stealth_enabled);
+
+      tmc_stealth_enabled_t tmc_stealth_enabled = { false, false, false, false, false, false, false, false, false, false, false, false, false };
+
+      #if HAS_STEALTHCHOP
+        #if AXIS_HAS_STEALTHCHOP(X)
+          tmc_stealth_enabled.X = stepperX.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          tmc_stealth_enabled.Y = stepperY.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          tmc_stealth_enabled.Z = stepperZ.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          tmc_stealth_enabled.X2 = stepperX2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          tmc_stealth_enabled.Y2 = stepperY2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          tmc_stealth_enabled.Z2 = stepperZ2.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          tmc_stealth_enabled.Z3 = stepperZ3.get_stealthChop_status();
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          tmc_stealth_enabled.Z4 = stepperZ4.get_stealthChop_status();
+        #endif
+        #if MAX_EXTRUDERS
+          #if AXIS_HAS_STEALTHCHOP(E0)
+            tmc_stealth_enabled.E0 = stepperE0.get_stealthChop_status();
+          #endif
+          #if MAX_EXTRUDERS > 1
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              tmc_stealth_enabled.E1 = stepperE1.get_stealthChop_status();
+            #endif
+            #if MAX_EXTRUDERS > 2
+              #if AXIS_HAS_STEALTHCHOP(E2)
+                tmc_stealth_enabled.E2 = stepperE2.get_stealthChop_status();
+              #endif
+              #if MAX_EXTRUDERS > 3
+                #if AXIS_HAS_STEALTHCHOP(E3)
+                  tmc_stealth_enabled.E3 = stepperE3.get_stealthChop_status();
+                #endif
+                #if MAX_EXTRUDERS > 4
+                  #if AXIS_HAS_STEALTHCHOP(E4)
+                    tmc_stealth_enabled.E4 = stepperE4.get_stealthChop_status();
+                  #endif
+                  #if MAX_EXTRUDERS > 5
+                    #if AXIS_HAS_STEALTHCHOP(E5)
+                      tmc_stealth_enabled.E5 = stepperE5.get_stealthChop_status();
+                    #endif
+                    #if MAX_EXTRUDERS > 6
+                      #if AXIS_HAS_STEALTHCHOP(E6)
+                        tmc_stealth_enabled.E6 = stepperE6.get_stealthChop_status();
+                      #endif
+                      #if MAX_EXTRUDERS > 7
+                        #if AXIS_HAS_STEALTHCHOP(E7)
+                          tmc_stealth_enabled.E7 = stepperE7.get_stealthChop_status();
+                        #endif
+                      #endif // MAX_EXTRUDERS > 7
+                    #endif // MAX_EXTRUDERS > 6
+                  #endif // MAX_EXTRUDERS > 5
+                #endif // MAX_EXTRUDERS > 4
+              #endif // MAX_EXTRUDERS > 3
+            #endif // MAX_EXTRUDERS > 2
+          #endif // MAX_EXTRUDERS > 1
+        #endif // MAX_EXTRUDERS
+      #endif
+      EEPROM_WRITE(tmc_stealth_enabled);
+    }
+
+    //
+    // Linear Advance
+    //
+    {
+      _FIELD_TEST(planner_extruder_advance_K);
+
+      #if ENABLED(LIN_ADVANCE)
+        EEPROM_WRITE(planner.extruder_advance_K);
+      #else
+        dummyf = 0;
+        for (uint8_t q = _MAX(EXTRUDERS, 1); q--;) EEPROM_WRITE(dummyf);
+      #endif
+    }
+
+    //
+    // Motor Current PWM
+    //
+    {
+      _FIELD_TEST(motor_current_setting);
+
+      #if HAS_MOTOR_CURRENT_PWM
+        EEPROM_WRITE(stepper.motor_current_setting);
+      #else
+        const uint32_t no_current[3] = { 0 };
+        EEPROM_WRITE(no_current);
+      #endif
+    }
+
+    //
+    // CNC Coordinate Systems
+    //
+
+    _FIELD_TEST(coordinate_system);
+
+    #if DISABLED(CNC_COORDINATE_SYSTEMS)
+      const xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS] = { { 0 } };
+    #endif
+    EEPROM_WRITE(TERN(CNC_COORDINATE_SYSTEMS, gcode.coordinate_system, coordinate_system));
+
+    //
+    // Skew correction factors
+    //
+    _FIELD_TEST(planner_skew_factor);
+    EEPROM_WRITE(planner.skew_factor);
+
+    //
+    // Advanced Pause filament load & unload lengths
+    //
+    #if EXTRUDERS
+    {
+      #if DISABLED(ADVANCED_PAUSE_FEATURE)
+        const fil_change_settings_t fc_settings[EXTRUDERS] = { 0, 0 };
+      #endif
+      _FIELD_TEST(fc_settings);
+      EEPROM_WRITE(fc_settings);
+    }
+    #endif
+
+    //
+    // Multiple Extruders
+    //
+
+    #if EXTRUDERS > 1
+      _FIELD_TEST(toolchange_settings);
+      EEPROM_WRITE(toolchange_settings);
+    #endif
+
+    //
+    // Backlash Compensation
+    //
+    {
+      #if ENABLED(BACKLASH_GCODE)
+        const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
+        const uint8_t &backlash_correction = backlash.correction;
+      #else
+        const xyz_float_t backlash_distance_mm{0};
+        const uint8_t backlash_correction = 0;
+      #endif
+      #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
+        const float &backlash_smoothing_mm = backlash.smoothing_mm;
+      #else
+        const float backlash_smoothing_mm = 3;
+      #endif
+      _FIELD_TEST(backlash_distance_mm);
+      EEPROM_WRITE(backlash_distance_mm);
+      EEPROM_WRITE(backlash_correction);
+      EEPROM_WRITE(backlash_smoothing_mm);
+    }
+
+    //
+    // Extensible UI User Data
+    //
+    #if ENABLED(EXTENSIBLE_UI)
+      {
+        char extui_data[ExtUI::eeprom_data_size] = { 0 };
+        ExtUI::onStoreSettings(extui_data);
+        _FIELD_TEST(extui_data);
+        EEPROM_WRITE(extui_data);
+      }
+    #endif
+
+    //
+    // Case Light Brightness
+    //
+    #if HAS_CASE_LIGHT_BRIGHTNESS
+      EEPROM_WRITE(caselight.brightness);
+    #endif
+
+    //
+    // TOUCH_SCREEN_CALIBRATION
+    //
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      EEPROM_WRITE(touch.calibration);
+    #endif
+
+    //
+    // Validate CRC and Data Size
+    //
+    if (!eeprom_error) {
+      const uint16_t eeprom_size = eeprom_index - (EEPROM_OFFSET),
+                     final_crc = working_crc;
+
+      // Write the EEPROM header
+      eeprom_index = EEPROM_OFFSET;
+
+      EEPROM_WRITE(version);
+      EEPROM_WRITE(final_crc);
+
+      // Report storage size
+      DEBUG_ECHO_START();
+      DEBUG_ECHOLNPAIR("Settings Stored (", eeprom_size, " bytes; crc ", (uint32_t)final_crc, ")");
+
+      eeprom_error |= size_error(eeprom_size);
+    }
+    EEPROM_FINISH();
+
+    //
+    // UBL Mesh
+    //
+    #if ENABLED(UBL_SAVE_ACTIVE_ON_M500)
+      if (ubl.storage_slot >= 0)
+        store_mesh(ubl.storage_slot);
+    #endif
+
+    if (!eeprom_error) LCD_MESSAGEPGM(MSG_SETTINGS_STORED);
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreWritten(!eeprom_error));
+
+    return !eeprom_error;
+  }
+
+  /**
+   * M501 - Retrieve Configuration
+   */
+  bool MarlinSettings::_load() {
+    uint16_t working_crc = 0;
+
+    EEPROM_START();
+
+    char stored_ver[4];
+    EEPROM_READ_ALWAYS(stored_ver);
+
+    uint16_t stored_crc;
+    EEPROM_READ_ALWAYS(stored_crc);
+
+    // Version has to match or defaults are used
+    if (strncmp(version, stored_ver, 3) != 0) {
+      if (stored_ver[3] != '\0') {
+        stored_ver[0] = '?';
+        stored_ver[1] = '\0';
+      }
+      DEBUG_ECHO_START();
+      DEBUG_ECHOLNPAIR("EEPROM version mismatch (EEPROM=", stored_ver, " Marlin=" EEPROM_VERSION ")");
+      TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_version());
+      eeprom_error = true;
+    }
+    else {
+      float dummyf = 0;
+      working_crc = 0;  // Init to 0. Accumulated by EEPROM_READ
+
+      _FIELD_TEST(esteppers);
+
+      // Number of esteppers may change
+      uint8_t esteppers;
+      EEPROM_READ_ALWAYS(esteppers);
+
+      //
+      // Planner Motion
+      //
+      {
+        // Get only the number of E stepper parameters previously stored
+        // Any steppers added later are set to their defaults
+        uint32_t tmp1[XYZ + esteppers];
+        float tmp2[XYZ + esteppers];
+        feedRate_t tmp3[XYZ + esteppers];
+        EEPROM_READ(tmp1);                         // max_acceleration_mm_per_s2
+        EEPROM_READ(planner.settings.min_segment_time_us);
+        EEPROM_READ(tmp2);                         // axis_steps_per_mm
+        EEPROM_READ(tmp3);                         // max_feedrate_mm_s
+
+        if (!validating) LOOP_XYZE_N(i) {
+          const bool in = (i < esteppers + XYZ);
+          planner.settings.max_acceleration_mm_per_s2[i] = in ? tmp1[i] : pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
+          planner.settings.axis_steps_per_mm[i]          = in ? tmp2[i] : pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+          planner.settings.max_feedrate_mm_s[i]          = in ? tmp3[i] : pgm_read_float(&_DMF[ALIM(i, _DMF)]);
+        }
+
+        EEPROM_READ(planner.settings.acceleration);
+        EEPROM_READ(planner.settings.retract_acceleration);
+        EEPROM_READ(planner.settings.travel_acceleration);
+        EEPROM_READ(planner.settings.min_feedrate_mm_s);
+        EEPROM_READ(planner.settings.min_travel_feedrate_mm_s);
+
+        #if HAS_CLASSIC_JERK
+          EEPROM_READ(planner.max_jerk);
+          #if HAS_LINEAR_E_JERK
+            EEPROM_READ(dummyf);
+          #endif
+        #else
+          for (uint8_t q = 4; q--;) EEPROM_READ(dummyf);
+        #endif
+
+        EEPROM_READ(TERN(CLASSIC_JERK, dummyf, planner.junction_deviation_mm));
+      }
+
+      //
+      // Home Offset (M206 / M665)
+      //
+      {
+        _FIELD_TEST(home_offset);
+
+        #if HAS_SCARA_OFFSET
+          EEPROM_READ(scara_home_offset);
+        #else
+          #if !HAS_HOME_OFFSET
+            xyz_pos_t home_offset;
+          #endif
+          EEPROM_READ(home_offset);
+        #endif
+      }
+
+      //
+      // Hotend Offsets, if any
+      //
+      {
+        #if HAS_HOTEND_OFFSET
+          // Skip hotend 0 which must be 0
+          LOOP_S_L_N(e, 1, HOTENDS)
+            EEPROM_READ(hotend_offset[e]);
+        #endif
+      }
+
+      //
+      // Filament Runout Sensor
+      //
+      {
+        #if HAS_FILAMENT_SENSOR
+          const bool &runout_sensor_enabled = runout.enabled;
+        #else
+          bool runout_sensor_enabled;
+        #endif
+        _FIELD_TEST(runout_sensor_enabled);
+        EEPROM_READ(runout_sensor_enabled);
+
+        float runout_distance_mm;
+        EEPROM_READ(runout_distance_mm);
+        #if HAS_FILAMENT_RUNOUT_DISTANCE
+          if (!validating) runout.set_runout_distance(runout_distance_mm);
+        #endif
+      }
+
+      //
+      // Global Leveling
+      //
+      EEPROM_READ(TERN(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height, dummyf));
+
+      //
+      // Mesh (Manual) Bed Leveling
+      //
+      {
+        uint8_t mesh_num_x, mesh_num_y;
+        EEPROM_READ(dummyf);
+        EEPROM_READ_ALWAYS(mesh_num_x);
+        EEPROM_READ_ALWAYS(mesh_num_y);
+
+        #if ENABLED(MESH_BED_LEVELING)
+          if (!validating) mbl.z_offset = dummyf;
+          if (mesh_num_x == GRID_MAX_POINTS_X && mesh_num_y == GRID_MAX_POINTS_Y) {
+            // EEPROM data fits the current mesh
+            EEPROM_READ(mbl.z_values);
+          }
+          else {
+            // EEPROM data is stale
+            if (!validating) mbl.reset();
+            for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
+          }
+        #else
+          // MBL is disabled - skip the stored data
+          for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
+        #endif // MESH_BED_LEVELING
+      }
+
+      //
+      // Probe Z Offset
+      //
+      {
+        _FIELD_TEST(probe_offset);
+        #if HAS_BED_PROBE
+          const xyz_pos_t &zpo = probe.offset;
+        #else
+          xyz_pos_t zpo;
+        #endif
+        EEPROM_READ(zpo);
+      }
+
+      //
+      // Planar Bed Leveling matrix
+      //
+      {
+        #if ABL_PLANAR
+          EEPROM_READ(planner.bed_level_matrix);
+        #else
+          for (uint8_t q = 9; q--;) EEPROM_READ(dummyf);
+        #endif
+      }
+
+      //
+      // Bilinear Auto Bed Leveling
+      //
+      {
+        uint8_t grid_max_x, grid_max_y;
+        EEPROM_READ_ALWAYS(grid_max_x);                // 1 byte
+        EEPROM_READ_ALWAYS(grid_max_y);                // 1 byte
+        #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          if (grid_max_x == GRID_MAX_POINTS_X && grid_max_y == GRID_MAX_POINTS_Y) {
+            if (!validating) set_bed_leveling_enabled(false);
+            EEPROM_READ(bilinear_grid_spacing);        // 2 ints
+            EEPROM_READ(bilinear_start);               // 2 ints
+            EEPROM_READ(z_values);                     // 9 to 256 floats
+          }
+          else // EEPROM data is stale
+        #endif // AUTO_BED_LEVELING_BILINEAR
+          {
+            // Skip past disabled (or stale) Bilinear Grid data
+            xy_pos_t bgs, bs;
+            EEPROM_READ(bgs);
+            EEPROM_READ(bs);
+            for (uint16_t q = grid_max_x * grid_max_y; q--;) EEPROM_READ(dummyf);
+          }
+      }
+
+      //
+      // Unified Bed Leveling active state
+      //
+      {
+        _FIELD_TEST(planner_leveling_active);
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          const bool &planner_leveling_active = planner.leveling_active;
+          const int8_t &ubl_storage_slot = ubl.storage_slot;
+        #else
+          bool planner_leveling_active;
+          int8_t ubl_storage_slot;
+        #endif
+        EEPROM_READ(planner_leveling_active);
+        EEPROM_READ(ubl_storage_slot);
+      }
+
+      //
+      // SERVO_ANGLES
+      //
+      {
+        _FIELD_TEST(servo_angles);
+        #if ENABLED(EDITABLE_SERVO_ANGLES)
+          uint16_t (&servo_angles_arr)[EEPROM_NUM_SERVOS][2] = servo_angles;
+        #else
+          uint16_t servo_angles_arr[EEPROM_NUM_SERVOS][2];
+        #endif
+        EEPROM_READ(servo_angles_arr);
+      }
+
+      //
+      // Thermal first layer compensation values
+      //
+      #if ENABLED(PROBE_TEMP_COMPENSATION)
+        EEPROM_READ(temp_comp.z_offsets_probe);
+        EEPROM_READ(temp_comp.z_offsets_bed);
+        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+          EEPROM_READ(temp_comp.z_offsets_ext);
+        #endif
+        temp_comp.reset_index();
+      #else
+        // No placeholder data for this feature
+      #endif
+
+      //
+      // BLTOUCH
+      //
+      {
+        _FIELD_TEST(bltouch_last_written_mode);
+        #if ENABLED(BLTOUCH)
+          const bool &bltouch_last_written_mode = bltouch.last_written_mode;
+        #else
+          bool bltouch_last_written_mode;
+        #endif
+        EEPROM_READ(bltouch_last_written_mode);
+      }
+
+      //
+      // DELTA Geometry or Dual Endstops offsets
+      //
+      {
+        #if ENABLED(DELTA)
+
+          _FIELD_TEST(delta_height);
+
+          EEPROM_READ(delta_height);              // 1 float
+          EEPROM_READ(delta_endstop_adj);         // 3 floats
+          EEPROM_READ(delta_radius);              // 1 float
+          EEPROM_READ(delta_diagonal_rod);        // 1 float
+          EEPROM_READ(delta_segments_per_second); // 1 float
+          EEPROM_READ(delta_tower_angle_trim);    // 3 floats
+          EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
+
+        #elif HAS_EXTRA_ENDSTOPS
+
+          _FIELD_TEST(x2_endstop_adj);
+
+          EEPROM_READ(TERN(X_DUAL_ENDSTOPS, endstops.x2_endstop_adj, dummyf));  // 1 float
+          EEPROM_READ(TERN(Y_DUAL_ENDSTOPS, endstops.y2_endstop_adj, dummyf));  // 1 float
+          EEPROM_READ(TERN(Z_MULTI_ENDSTOPS, endstops.z2_endstop_adj, dummyf)); // 1 float
+
+          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 3
+            EEPROM_READ(endstops.z3_endstop_adj); // 1 float
+          #else
+            EEPROM_READ(dummyf);
+          #endif
+          #if ENABLED(Z_MULTI_ENDSTOPS) && NUM_Z_STEPPER_DRIVERS >= 4
+            EEPROM_READ(endstops.z4_endstop_adj); // 1 float
+          #else
+            EEPROM_READ(dummyf);
+          #endif
+
+        #endif
+      }
+
+      #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+        EEPROM_READ(z_stepper_align.xy);
+        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          EEPROM_READ(z_stepper_align.stepper_xy);
+        #endif
+      #endif
+
+      //
+      // LCD Preheat settings
+      //
+      #if PREHEAT_COUNT
+        _FIELD_TEST(ui_material_preset);
+        EEPROM_READ(ui.material_preset);
+      #endif
+
+      //
+      // Hotend PID
+      //
+      {
+        HOTEND_LOOP() {
+          PIDCF_t pidcf;
+          EEPROM_READ(pidcf);
+          #if ENABLED(PIDTEMP)
+            if (!validating && !isnan(pidcf.Kp)) {
+              // Scale PID values since EEPROM values are unscaled
+              PID_PARAM(Kp, e) = pidcf.Kp;
+              PID_PARAM(Ki, e) = scalePID_i(pidcf.Ki);
+              PID_PARAM(Kd, e) = scalePID_d(pidcf.Kd);
+              TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = pidcf.Kc);
+              TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = pidcf.Kf);
+            }
+          #endif
+        }
+      }
+
+      //
+      // PID Extrusion Scaling
+      //
+      {
+        _FIELD_TEST(lpq_len);
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          const int16_t &lpq_len = thermalManager.lpq_len;
+        #else
+          int16_t lpq_len;
+        #endif
+        EEPROM_READ(lpq_len);
+      }
+
+      //
+      // Heated Bed PID
+      //
+      {
+        PID_t pid;
+        EEPROM_READ(pid);
+        #if ENABLED(PIDTEMPBED)
+          if (!validating && !isnan(pid.Kp)) {
+            // Scale PID values since EEPROM values are unscaled
+            thermalManager.temp_bed.pid.Kp = pid.Kp;
+            thermalManager.temp_bed.pid.Ki = scalePID_i(pid.Ki);
+            thermalManager.temp_bed.pid.Kd = scalePID_d(pid.Kd);
+          }
+        #endif
+      }
+
+      //
+      // User-defined Thermistors
+      //
+      #if HAS_USER_THERMISTORS
+      {
+        _FIELD_TEST(user_thermistor);
+        EEPROM_READ(thermalManager.user_thermistor);
+      }
+      #endif
+
+      //
+      // Power monitor
+      //
+      {
+        #if HAS_POWER_MONITOR
+          uint8_t &power_monitor_flags = power_monitor.flags;
+        #else
+          uint8_t power_monitor_flags;
+        #endif
+        _FIELD_TEST(power_monitor_flags);
+        EEPROM_READ(power_monitor_flags);
+      }
+
+      //
+      // LCD Contrast
+      //
+      {
+        _FIELD_TEST(lcd_contrast);
+
+        int16_t lcd_contrast;
+        EEPROM_READ(lcd_contrast);
+        TERN_(HAS_LCD_CONTRAST, ui.set_contrast(lcd_contrast));
+      }
+
+      //
+      // Controller Fan
+      //
+      {
+        _FIELD_TEST(controllerFan_settings);
+        #if ENABLED(CONTROLLER_FAN_EDITABLE)
+          const controllerFan_settings_t &cfs = controllerFan.settings;
+        #else
+          controllerFan_settings_t cfs = { 0 };
+        #endif
+        EEPROM_READ(cfs);
+      }
+
+      //
+      // Power-Loss Recovery
+      //
+      {
+        _FIELD_TEST(recovery_enabled);
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          const bool &recovery_enabled = recovery.enabled;
+        #else
+          bool recovery_enabled;
+        #endif
+        EEPROM_READ(recovery_enabled);
+      }
+
+      //
+      // Firmware Retraction
+      //
+      {
+        _FIELD_TEST(fwretract_settings);
+
+        #if ENABLED(FWRETRACT)
+          EEPROM_READ(fwretract.settings);
+        #else
+          fwretract_settings_t fwretract_settings;
+          EEPROM_READ(fwretract_settings);
+        #endif
+        #if BOTH(FWRETRACT, FWRETRACT_AUTORETRACT)
+          EEPROM_READ(fwretract.autoretract_enabled);
+        #else
+          bool autoretract_enabled;
+          EEPROM_READ(autoretract_enabled);
+        #endif
+      }
+
+      //
+      // Volumetric & Filament Size
+      //
+      {
+        struct {
+          bool volumetric_enabled;
+          float filament_size[EXTRUDERS];
+          float volumetric_extruder_limit[EXTRUDERS];
+        } storage;
+
+        _FIELD_TEST(parser_volumetric_enabled);
+        EEPROM_READ(storage);
+
+        #if DISABLED(NO_VOLUMETRICS)
+          if (!validating) {
+            parser.volumetric_enabled = storage.volumetric_enabled;
+            COPY(planner.filament_size, storage.filament_size);
+            #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+              COPY(planner.volumetric_extruder_limit, storage.volumetric_extruder_limit);
+            #endif
+          }
+        #endif
+      }
+
+      //
+      // TMC Stepper Settings
+      //
+
+      if (!validating) reset_stepper_drivers();
+
+      // TMC Stepper Current
+      {
+        _FIELD_TEST(tmc_stepper_current);
+
+        tmc_stepper_current_t currents;
+        EEPROM_READ(currents);
+
+        #if HAS_TRINAMIC_CONFIG
+
+          #define SET_CURR(Q) stepper##Q.rms_current(currents.Q ? currents.Q : Q##_CURRENT)
+          if (!validating) {
+            #if AXIS_IS_TMC(X)
+              SET_CURR(X);
+            #endif
+            #if AXIS_IS_TMC(Y)
+              SET_CURR(Y);
+            #endif
+            #if AXIS_IS_TMC(Z)
+              SET_CURR(Z);
+            #endif
+            #if AXIS_IS_TMC(X2)
+              SET_CURR(X2);
+            #endif
+            #if AXIS_IS_TMC(Y2)
+              SET_CURR(Y2);
+            #endif
+            #if AXIS_IS_TMC(Z2)
+              SET_CURR(Z2);
+            #endif
+            #if AXIS_IS_TMC(Z3)
+              SET_CURR(Z3);
+            #endif
+            #if AXIS_IS_TMC(Z4)
+              SET_CURR(Z4);
+            #endif
+            #if AXIS_IS_TMC(E0)
+              SET_CURR(E0);
+            #endif
+            #if AXIS_IS_TMC(E1)
+              SET_CURR(E1);
+            #endif
+            #if AXIS_IS_TMC(E2)
+              SET_CURR(E2);
+            #endif
+            #if AXIS_IS_TMC(E3)
+              SET_CURR(E3);
+            #endif
+            #if AXIS_IS_TMC(E4)
+              SET_CURR(E4);
+            #endif
+            #if AXIS_IS_TMC(E5)
+              SET_CURR(E5);
+            #endif
+            #if AXIS_IS_TMC(E6)
+              SET_CURR(E6);
+            #endif
+            #if AXIS_IS_TMC(E7)
+              SET_CURR(E7);
+            #endif
+          }
+        #endif
+      }
+
+      // TMC Hybrid Threshold
+      {
+        tmc_hybrid_threshold_t tmc_hybrid_threshold;
+        _FIELD_TEST(tmc_hybrid_threshold);
+        EEPROM_READ(tmc_hybrid_threshold);
+
+        #if ENABLED(HYBRID_THRESHOLD)
+          if (!validating) {
+            #if AXIS_HAS_STEALTHCHOP(X)
+              stepperX.set_pwm_thrs(tmc_hybrid_threshold.X);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y)
+              stepperY.set_pwm_thrs(tmc_hybrid_threshold.Y);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z)
+              stepperZ.set_pwm_thrs(tmc_hybrid_threshold.Z);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(X2)
+              stepperX2.set_pwm_thrs(tmc_hybrid_threshold.X2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y2)
+              stepperY2.set_pwm_thrs(tmc_hybrid_threshold.Y2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z2)
+              stepperZ2.set_pwm_thrs(tmc_hybrid_threshold.Z2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z3)
+              stepperZ3.set_pwm_thrs(tmc_hybrid_threshold.Z3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z4)
+              stepperZ4.set_pwm_thrs(tmc_hybrid_threshold.Z4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E0)
+              stepperE0.set_pwm_thrs(tmc_hybrid_threshold.E0);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              stepperE1.set_pwm_thrs(tmc_hybrid_threshold.E1);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E2)
+              stepperE2.set_pwm_thrs(tmc_hybrid_threshold.E2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E3)
+              stepperE3.set_pwm_thrs(tmc_hybrid_threshold.E3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E4)
+              stepperE4.set_pwm_thrs(tmc_hybrid_threshold.E4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E5)
+              stepperE5.set_pwm_thrs(tmc_hybrid_threshold.E5);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E6)
+              stepperE6.set_pwm_thrs(tmc_hybrid_threshold.E6);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E7)
+              stepperE7.set_pwm_thrs(tmc_hybrid_threshold.E7);
+            #endif
+          }
+        #endif
+      }
+
+      //
+      // TMC StallGuard threshold.
+      //
+      {
+        tmc_sgt_t tmc_sgt;
+        _FIELD_TEST(tmc_sgt);
+        EEPROM_READ(tmc_sgt);
+        #if USE_SENSORLESS
+          if (!validating) {
+            TERN_(X_SENSORLESS,  stepperX.homing_threshold(tmc_sgt.X));
+            TERN_(X2_SENSORLESS, stepperX2.homing_threshold(tmc_sgt.X2));
+            TERN_(Y_SENSORLESS,  stepperY.homing_threshold(tmc_sgt.Y));
+            TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(tmc_sgt.Y2));
+            TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(tmc_sgt.Z));
+            TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(tmc_sgt.Z2));
+            TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(tmc_sgt.Z3));
+            TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(tmc_sgt.Z4));
+          }
+        #endif
+      }
+
+      // TMC stepping mode
+      {
+        _FIELD_TEST(tmc_stealth_enabled);
+
+        tmc_stealth_enabled_t tmc_stealth_enabled;
+        EEPROM_READ(tmc_stealth_enabled);
+
+        #if HAS_TRINAMIC_CONFIG
+
+          #define SET_STEPPING_MODE(ST) stepper##ST.stored.stealthChop_enabled = tmc_stealth_enabled.ST; stepper##ST.refresh_stepping_mode();
+          if (!validating) {
+            #if AXIS_HAS_STEALTHCHOP(X)
+              SET_STEPPING_MODE(X);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y)
+              SET_STEPPING_MODE(Y);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z)
+              SET_STEPPING_MODE(Z);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(X2)
+              SET_STEPPING_MODE(X2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Y2)
+              SET_STEPPING_MODE(Y2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z2)
+              SET_STEPPING_MODE(Z2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z3)
+              SET_STEPPING_MODE(Z3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(Z4)
+              SET_STEPPING_MODE(Z4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E0)
+              SET_STEPPING_MODE(E0);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E1)
+              SET_STEPPING_MODE(E1);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E2)
+              SET_STEPPING_MODE(E2);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E3)
+              SET_STEPPING_MODE(E3);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E4)
+              SET_STEPPING_MODE(E4);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E5)
+              SET_STEPPING_MODE(E5);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E6)
+              SET_STEPPING_MODE(E6);
+            #endif
+            #if AXIS_HAS_STEALTHCHOP(E7)
+              SET_STEPPING_MODE(E7);
+            #endif
+          }
+        #endif
+      }
+
+      //
+      // Linear Advance
+      //
+      {
+        float extruder_advance_K[_MAX(EXTRUDERS, 1)];
+        _FIELD_TEST(planner_extruder_advance_K);
+        EEPROM_READ(extruder_advance_K);
+        #if ENABLED(LIN_ADVANCE)
+          if (!validating)
+            COPY(planner.extruder_advance_K, extruder_advance_K);
+        #endif
+      }
+
+      //
+      // Motor Current PWM
+      //
+      {
+        uint32_t motor_current_setting[3];
+        _FIELD_TEST(motor_current_setting);
+        EEPROM_READ(motor_current_setting);
+        #if HAS_MOTOR_CURRENT_PWM
+          if (!validating)
+            COPY(stepper.motor_current_setting, motor_current_setting);
+        #endif
+      }
+
+      //
+      // CNC Coordinate System
+      //
+      {
+        _FIELD_TEST(coordinate_system);
+        #if ENABLED(CNC_COORDINATE_SYSTEMS)
+          if (!validating) (void)gcode.select_coordinate_system(-1); // Go back to machine space
+          EEPROM_READ(gcode.coordinate_system);
+        #else
+          xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
+          EEPROM_READ(coordinate_system);
+        #endif
+      }
+
+      //
+      // Skew correction factors
+      //
+      {
+        skew_factor_t skew_factor;
+        _FIELD_TEST(planner_skew_factor);
+        EEPROM_READ(skew_factor);
+        #if ENABLED(SKEW_CORRECTION_GCODE)
+          if (!validating) {
+            planner.skew_factor.xy = skew_factor.xy;
+            #if ENABLED(SKEW_CORRECTION_FOR_Z)
+              planner.skew_factor.xz = skew_factor.xz;
+              planner.skew_factor.yz = skew_factor.yz;
+            #endif
+          }
+        #endif
+      }
+
+      //
+      // Advanced Pause filament load & unload lengths
+      //
+      #if EXTRUDERS
+      {
+        #if DISABLED(ADVANCED_PAUSE_FEATURE)
+          fil_change_settings_t fc_settings[EXTRUDERS];
+        #endif
+        _FIELD_TEST(fc_settings);
+        EEPROM_READ(fc_settings);
+      }
+      #endif
+
+      //
+      // Tool-change settings
+      //
+      #if EXTRUDERS > 1
+        _FIELD_TEST(toolchange_settings);
+        EEPROM_READ(toolchange_settings);
+      #endif
+
+      //
+      // Backlash Compensation
+      //
+      {
+        #if ENABLED(BACKLASH_GCODE)
+          const xyz_float_t &backlash_distance_mm = backlash.distance_mm;
+          const uint8_t &backlash_correction = backlash.correction;
+        #else
+          float backlash_distance_mm[XYZ];
+          uint8_t backlash_correction;
+        #endif
+        #if ENABLED(BACKLASH_GCODE) && defined(BACKLASH_SMOOTHING_MM)
+          const float &backlash_smoothing_mm = backlash.smoothing_mm;
+        #else
+          float backlash_smoothing_mm;
+        #endif
+        _FIELD_TEST(backlash_distance_mm);
+        EEPROM_READ(backlash_distance_mm);
+        EEPROM_READ(backlash_correction);
+        EEPROM_READ(backlash_smoothing_mm);
+      }
+
+      //
+      // Extensible UI User Data
+      //
+      #if ENABLED(EXTENSIBLE_UI)
+        // This is a significant hardware change; don't reserve EEPROM space when not present
+        {
+          const char extui_data[ExtUI::eeprom_data_size] = { 0 };
+          _FIELD_TEST(extui_data);
+          EEPROM_READ(extui_data);
+          if (!validating) ExtUI::onLoadSettings(extui_data);
+        }
+      #endif
+
+      //
+      // Case Light Brightness
+      //
+      #if HAS_CASE_LIGHT_BRIGHTNESS
+        _FIELD_TEST(caselight_brightness);
+        EEPROM_READ(caselight.brightness);
+      #endif
+
+      //
+      // TOUCH_SCREEN_CALIBRATION
+      //
+      #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+        _FIELD_TEST(touch.calibration);
+        EEPROM_READ(touch.calibration);
+      #endif
+
+      eeprom_error = size_error(eeprom_index - (EEPROM_OFFSET));
+      if (eeprom_error) {
+        DEBUG_ECHO_START();
+        DEBUG_ECHOLNPAIR("Index: ", int(eeprom_index - (EEPROM_OFFSET)), " Size: ", datasize());
+        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_index());
+      }
+      else if (working_crc != stored_crc) {
+        eeprom_error = true;
+        DEBUG_ERROR_START();
+        DEBUG_ECHOLNPAIR("EEPROM CRC mismatch - (stored) ", stored_crc, " != ", working_crc, " (calculated)!");
+        TERN(EEPROM_AUTO_INIT,,ui.eeprom_alert_crc());
+      }
+      else if (!validating) {
+        DEBUG_ECHO_START();
+        DEBUG_ECHO(version);
+        DEBUG_ECHOLNPAIR(" stored settings retrieved (", eeprom_index - (EEPROM_OFFSET), " bytes; crc ", (uint32_t)working_crc, ")");
+      }
+
+      if (!validating && !eeprom_error) postprocess();
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        if (!validating) {
+          ubl.report_state();
+
+          if (!ubl.sanity_check()) {
+            SERIAL_EOL();
+            #if ENABLED(EEPROM_CHITCHAT)
+              ubl.echo_name();
+              DEBUG_ECHOLNPGM(" initialized.\n");
+            #endif
+          }
+          else {
+            eeprom_error = true;
+            #if ENABLED(EEPROM_CHITCHAT)
+              DEBUG_ECHOPGM("?Can't enable ");
+              ubl.echo_name();
+              DEBUG_ECHOLNPGM(".");
+            #endif
+            ubl.reset();
+          }
+
+          if (ubl.storage_slot >= 0) {
+            load_mesh(ubl.storage_slot);
+            DEBUG_ECHOLNPAIR("Mesh ", ubl.storage_slot, " loaded from storage.");
+          }
+          else {
+            ubl.reset();
+            DEBUG_ECHOLNPGM("UBL reset");
+          }
+        }
+      #endif
+    }
+
+    #if ENABLED(EEPROM_CHITCHAT) && DISABLED(DISABLE_M503)
+      // Report the EEPROM settings
+      if (!validating && (DISABLED(EEPROM_BOOT_SILENT) || IsRunning())) report();
+    #endif
+
+    EEPROM_FINISH();
+
+    return !eeprom_error;
+  }
+
+  #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+    extern bool restoreEEPROM();
+  #endif
+
+  bool MarlinSettings::validate() {
+    validating = true;
+    #ifdef ARCHIM2_SPI_FLASH_EEPROM_BACKUP_SIZE
+      bool success = _load();
+      if (!success && restoreEEPROM()) {
+        SERIAL_ECHOLNPGM("Recovered backup EEPROM settings from SPI Flash");
+        success = _load();
+      }
+    #else
+      const bool success = _load();
+    #endif
+    validating = false;
+    return success;
+  }
+
+  bool MarlinSettings::load() {
+    if (validate()) {
+      const bool success = _load();
+      TERN_(EXTENSIBLE_UI, ExtUI::onConfigurationStoreRead(success));
+      return success;
+    }
+    reset();
+    #if ENABLED(EEPROM_AUTO_INIT)
+      (void)save();
+      SERIAL_ECHO_MSG("EEPROM Initialized");
+    #endif
+    return false;
+  }
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    inline void ubl_invalid_slot(const int s) {
+      #if ENABLED(EEPROM_CHITCHAT)
+        DEBUG_ECHOLNPGM("?Invalid slot.");
+        DEBUG_ECHO(s);
+        DEBUG_ECHOLNPGM(" mesh slots available.");
+      #else
+        UNUSED(s);
+      #endif
+    }
+
+    const uint16_t MarlinSettings::meshes_end = persistentStore.capacity() - 129; // 128 (+1 because of the change to capacity rather than last valid address)
+                                                                                  // is a placeholder for the size of the MAT; the MAT will always
+                                                                                  // live at the very end of the eeprom
+
+    uint16_t MarlinSettings::meshes_start_index() {
+      return (datasize() + EEPROM_OFFSET + 32) & 0xFFF8;  // Pad the end of configuration data so it can float up
+                                                          // or down a little bit without disrupting the mesh data
+    }
+
+    uint16_t MarlinSettings::calc_num_meshes() {
+      return (meshes_end - meshes_start_index()) / sizeof(ubl.z_values);
+    }
+
+    int MarlinSettings::mesh_slot_offset(const int8_t slot) {
+      return meshes_end - (slot + 1) * sizeof(ubl.z_values);
+    }
+
+    void MarlinSettings::store_mesh(const int8_t slot) {
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        const int16_t a = calc_num_meshes();
+        if (!WITHIN(slot, 0, a - 1)) {
+          ubl_invalid_slot(a);
+          DEBUG_ECHOLNPAIR("E2END=", persistentStore.capacity() - 1, " meshes_end=", meshes_end, " slot=", slot);
+          DEBUG_EOL();
+          return;
+        }
+
+        int pos = mesh_slot_offset(slot);
+        uint16_t crc = 0;
+
+        // Write crc to MAT along with other data, or just tack on to the beginning or end
+        persistentStore.access_start();
+        const bool status = persistentStore.write_data(pos, (uint8_t *)&ubl.z_values, sizeof(ubl.z_values), &crc);
+        persistentStore.access_finish();
+
+        if (status) SERIAL_ECHOLNPGM("?Unable to save mesh data.");
+        else        DEBUG_ECHOLNPAIR("Mesh saved in slot ", slot);
+
+      #else
+
+        // Other mesh types
+
+      #endif
+    }
+
+    void MarlinSettings::load_mesh(const int8_t slot, void * const into/*=nullptr*/) {
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+        const int16_t a = settings.calc_num_meshes();
+
+        if (!WITHIN(slot, 0, a - 1)) {
+          ubl_invalid_slot(a);
+          return;
+        }
+
+        int pos = mesh_slot_offset(slot);
+        uint16_t crc = 0;
+        uint8_t * const dest = into ? (uint8_t*)into : (uint8_t*)&ubl.z_values;
+
+        persistentStore.access_start();
+        const uint16_t status = persistentStore.read_data(pos, dest, sizeof(ubl.z_values), &crc);
+        persistentStore.access_finish();
+
+        if (status) SERIAL_ECHOLNPGM("?Unable to load mesh data.");
+        else        DEBUG_ECHOLNPAIR("Mesh loaded from slot ", slot);
+
+        EEPROM_FINISH();
+
+      #else
+
+        // Other mesh types
+
+      #endif
+    }
+
+    //void MarlinSettings::delete_mesh() { return; }
+    //void MarlinSettings::defrag_meshes() { return; }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+#else // !EEPROM_SETTINGS
+
+  bool MarlinSettings::save() {
+    DEBUG_ERROR_MSG("EEPROM disabled");
+    return false;
+  }
+
+#endif // !EEPROM_SETTINGS
+
+/**
+ * M502 - Reset Configuration
+ */
+void MarlinSettings::reset() {
+  LOOP_XYZE_N(i) {
+    planner.settings.max_acceleration_mm_per_s2[i] = pgm_read_dword(&_DMA[ALIM(i, _DMA)]);
+    planner.settings.axis_steps_per_mm[i]          = pgm_read_float(&_DASU[ALIM(i, _DASU)]);
+    planner.settings.max_feedrate_mm_s[i]          = pgm_read_float(&_DMF[ALIM(i, _DMF)]);
+  }
+
+  planner.settings.min_segment_time_us = DEFAULT_MINSEGMENTTIME;
+  planner.settings.acceleration = DEFAULT_ACCELERATION;
+  planner.settings.retract_acceleration = DEFAULT_RETRACT_ACCELERATION;
+  planner.settings.travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;
+  planner.settings.min_feedrate_mm_s = feedRate_t(DEFAULT_MINIMUMFEEDRATE);
+  planner.settings.min_travel_feedrate_mm_s = feedRate_t(DEFAULT_MINTRAVELFEEDRATE);
+
+  #if HAS_CLASSIC_JERK
+    #ifndef DEFAULT_XJERK
+      #define DEFAULT_XJERK 0
+    #endif
+    #ifndef DEFAULT_YJERK
+      #define DEFAULT_YJERK 0
+    #endif
+    #ifndef DEFAULT_ZJERK
+      #define DEFAULT_ZJERK 0
+    #endif
+    planner.max_jerk.set(DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK);
+    TERN_(HAS_CLASSIC_E_JERK, planner.max_jerk.e = DEFAULT_EJERK;);
+  #endif
+
+  #if HAS_JUNCTION_DEVIATION
+    planner.junction_deviation_mm = float(JUNCTION_DEVIATION_MM);
+  #endif
+
+  #if HAS_SCARA_OFFSET
+    scara_home_offset.reset();
+  #elif HAS_HOME_OFFSET
+    home_offset.reset();
+  #endif
+
+  TERN_(HAS_HOTEND_OFFSET, reset_hotend_offsets());
+
+  //
+  // Filament Runout Sensor
+  //
+
+  #if HAS_FILAMENT_SENSOR
+    runout.enabled = true;
+    runout.reset();
+    TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.set_runout_distance(FILAMENT_RUNOUT_DISTANCE_MM));
+  #endif
+
+  //
+  // Tool-change Settings
+  //
+
+  #if EXTRUDERS > 1
+    #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+      toolchange_settings.swap_length     = TOOLCHANGE_FS_LENGTH;
+      toolchange_settings.extra_resume    = TOOLCHANGE_FS_EXTRA_RESUME_LENGTH;
+      toolchange_settings.retract_speed   = TOOLCHANGE_FS_RETRACT_SPEED;
+      toolchange_settings.unretract_speed = TOOLCHANGE_FS_UNRETRACT_SPEED;
+      toolchange_settings.extra_prime     = TOOLCHANGE_FS_EXTRA_PRIME;
+      toolchange_settings.prime_speed     = TOOLCHANGE_FS_PRIME_SPEED;
+      toolchange_settings.fan_speed       = TOOLCHANGE_FS_FAN_SPEED;
+      toolchange_settings.fan_time        = TOOLCHANGE_FS_FAN_TIME;
+    #endif
+
+    #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
+      enable_first_prime = false;
+    #endif
+
+    #if ENABLED(TOOLCHANGE_PARK)
+      constexpr xyz_pos_t tpxy = TOOLCHANGE_PARK_XY;
+      toolchange_settings.enable_park = true;
+      toolchange_settings.change_point = tpxy;
+    #endif
+
+    toolchange_settings.z_raise = TOOLCHANGE_ZRAISE;
+
+    #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
+      migration = migration_defaults;
+    #endif
+
+  #endif
+
+  #if ENABLED(BACKLASH_GCODE)
+    backlash.correction = (BACKLASH_CORRECTION) * 255;
+    constexpr xyz_float_t tmp = BACKLASH_DISTANCE_MM;
+    backlash.distance_mm = tmp;
+    #ifdef BACKLASH_SMOOTHING_MM
+      backlash.smoothing_mm = BACKLASH_SMOOTHING_MM;
+    #endif
+  #endif
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
+
+  //
+  // Case Light Brightness
+  //
+  TERN_(HAS_CASE_LIGHT_BRIGHTNESS, caselight.brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS);
+
+  //
+  // TOUCH_SCREEN_CALIBRATION
+  //
+  TERN_(TOUCH_SCREEN_CALIBRATION, touch.calibration_reset());
+
+  //
+  // Magnetic Parking Extruder
+  //
+  TERN_(MAGNETIC_PARKING_EXTRUDER, mpe_settings_init());
+
+  //
+  // Global Leveling
+  //
+  TERN_(ENABLE_LEVELING_FADE_HEIGHT, new_z_fade_height = 0.0);
+  TERN_(HAS_LEVELING, reset_bed_level());
+
+  #if HAS_BED_PROBE
+    constexpr float dpo[] = NOZZLE_TO_PROBE_OFFSET;
+    static_assert(COUNT(dpo) == 3, "NOZZLE_TO_PROBE_OFFSET must contain offsets for X, Y, and Z.");
+    #if HAS_PROBE_XY_OFFSET
+      LOOP_XYZ(a) probe.offset[a] = dpo[a];
+    #else
+      probe.offset.x = probe.offset.y = 0;
+      probe.offset.z = dpo[Z_AXIS];
+    #endif
+  #endif
+
+  //
+  // Z Stepper Auto-alignment points
+  //
+  TERN_(Z_STEPPER_AUTO_ALIGN, z_stepper_align.reset_to_default());
+
+  //
+  // Servo Angles
+  //
+  TERN_(EDITABLE_SERVO_ANGLES, COPY(servo_angles, base_servo_angles)); // When not editable only one copy of servo angles exists
+
+  //
+  // BLTOUCH
+  //
+  //#if ENABLED(BLTOUCH)
+  //  bltouch.last_written_mode;
+  //#endif
+
+  //
+  // Endstop Adjustments
+  //
+
+  #if ENABLED(DELTA)
+    const abc_float_t adj = DELTA_ENDSTOP_ADJ, dta = DELTA_TOWER_ANGLE_TRIM, ddr = DELTA_DIAGONAL_ROD_TRIM_TOWER;
+    delta_height = DELTA_HEIGHT;
+    delta_endstop_adj = adj;
+    delta_radius = DELTA_RADIUS;
+    delta_diagonal_rod = DELTA_DIAGONAL_ROD;
+    delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
+    delta_tower_angle_trim = dta;
+    delta_diagonal_rod_trim = ddr;
+  #endif
+
+  #if ENABLED(X_DUAL_ENDSTOPS)
+    #ifndef X2_ENDSTOP_ADJUSTMENT
+      #define X2_ENDSTOP_ADJUSTMENT 0
+    #endif
+    endstops.x2_endstop_adj = X2_ENDSTOP_ADJUSTMENT;
+  #endif
+
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    #ifndef Y2_ENDSTOP_ADJUSTMENT
+      #define Y2_ENDSTOP_ADJUSTMENT 0
+    #endif
+    endstops.y2_endstop_adj = Y2_ENDSTOP_ADJUSTMENT;
+  #endif
+
+  #if ENABLED(Z_MULTI_ENDSTOPS)
+    #ifndef Z2_ENDSTOP_ADJUSTMENT
+      #define Z2_ENDSTOP_ADJUSTMENT 0
+    #endif
+    endstops.z2_endstop_adj = Z2_ENDSTOP_ADJUSTMENT;
+    #if NUM_Z_STEPPER_DRIVERS >= 3
+      #ifndef Z3_ENDSTOP_ADJUSTMENT
+        #define Z3_ENDSTOP_ADJUSTMENT 0
+      #endif
+      endstops.z3_endstop_adj = Z3_ENDSTOP_ADJUSTMENT;
+    #endif
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      #ifndef Z4_ENDSTOP_ADJUSTMENT
+        #define Z4_ENDSTOP_ADJUSTMENT 0
+      #endif
+      endstops.z4_endstop_adj = Z4_ENDSTOP_ADJUSTMENT;
+    #endif
+  #endif
+
+  //
+  // Preheat parameters
+  //
+  #if PREHEAT_COUNT
+    #if HAS_HOTEND
+      constexpr uint16_t hpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_HOTEND, PREHEAT_2_TEMP_HOTEND, PREHEAT_3_TEMP_HOTEND, PREHEAT_4_TEMP_HOTEND, PREHEAT_5_TEMP_HOTEND);
+    #endif
+    #if HAS_HEATED_BED
+      constexpr uint16_t bpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_TEMP_BED, PREHEAT_2_TEMP_BED, PREHEAT_3_TEMP_BED, PREHEAT_4_TEMP_BED, PREHEAT_5_TEMP_BED);
+    #endif
+    #if HAS_FAN
+      constexpr uint8_t fpre[] = ARRAY_N(PREHEAT_COUNT, PREHEAT_1_FAN_SPEED, PREHEAT_2_FAN_SPEED, PREHEAT_3_FAN_SPEED, PREHEAT_4_FAN_SPEED, PREHEAT_5_FAN_SPEED);
+    #endif
+    LOOP_L_N(i, PREHEAT_COUNT) {
+      #if HAS_HOTEND
+        ui.material_preset[i].hotend_temp = hpre[i];
+      #endif
+      #if HAS_HEATED_BED
+        ui.material_preset[i].bed_temp = bpre[i];
+      #endif
+      #if HAS_FAN
+        ui.material_preset[i].fan_speed = fpre[i];
+      #endif
+    }
+  #endif
+
+  //
+  // Hotend PID
+  //
+
+  #if ENABLED(PIDTEMP)
+    #if ENABLED(PID_PARAMS_PER_HOTEND)
+      constexpr float defKp[] =
+        #ifdef DEFAULT_Kp_LIST
+          DEFAULT_Kp_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Kp)
+        #endif
+      , defKi[] =
+        #ifdef DEFAULT_Ki_LIST
+          DEFAULT_Ki_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Ki)
+        #endif
+      , defKd[] =
+        #ifdef DEFAULT_Kd_LIST
+          DEFAULT_Kd_LIST
+        #else
+          ARRAY_BY_HOTENDS1(DEFAULT_Kd)
+        #endif
+      ;
+      static_assert(WITHIN(COUNT(defKp), 1, HOTENDS), "DEFAULT_Kp_LIST must have between 1 and HOTENDS items.");
+      static_assert(WITHIN(COUNT(defKi), 1, HOTENDS), "DEFAULT_Ki_LIST must have between 1 and HOTENDS items.");
+      static_assert(WITHIN(COUNT(defKd), 1, HOTENDS), "DEFAULT_Kd_LIST must have between 1 and HOTENDS items.");
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        constexpr float defKc[] =
+          #ifdef DEFAULT_Kc_LIST
+            DEFAULT_Kc_LIST
+          #else
+            ARRAY_BY_HOTENDS1(DEFAULT_Kc)
+          #endif
+        ;
+        static_assert(WITHIN(COUNT(defKc), 1, HOTENDS), "DEFAULT_Kc_LIST must have between 1 and HOTENDS items.");
+      #endif
+      #if ENABLED(PID_FAN_SCALING)
+        constexpr float defKf[] =
+          #ifdef DEFAULT_Kf_LIST
+            DEFAULT_Kf_LIST
+          #else
+            ARRAY_BY_HOTENDS1(DEFAULT_Kf)
+          #endif
+        ;
+        static_assert(WITHIN(COUNT(defKf), 1, HOTENDS), "DEFAULT_Kf_LIST must have between 1 and HOTENDS items.");
+      #endif
+      #define PID_DEFAULT(N,E) def##N[E]
+    #else
+      #define PID_DEFAULT(N,E) DEFAULT_##N
+    #endif
+    HOTEND_LOOP() {
+      PID_PARAM(Kp, e) = float(PID_DEFAULT(Kp, ALIM(e, defKp)));
+      PID_PARAM(Ki, e) = scalePID_i(PID_DEFAULT(Ki, ALIM(e, defKi)));
+      PID_PARAM(Kd, e) = scalePID_d(PID_DEFAULT(Kd, ALIM(e, defKd)));
+      TERN_(PID_EXTRUSION_SCALING, PID_PARAM(Kc, e) = float(PID_DEFAULT(Kc, ALIM(e, defKc))));
+      TERN_(PID_FAN_SCALING, PID_PARAM(Kf, e) = float(PID_DEFAULT(Kf, ALIM(e, defKf))));
+    }
+  #endif
+
+  //
+  // PID Extrusion Scaling
+  //
+  TERN_(PID_EXTRUSION_SCALING, thermalManager.lpq_len = 20); // Default last-position-queue size
+
+  //
+  // Heated Bed PID
+  //
+
+  #if ENABLED(PIDTEMPBED)
+    thermalManager.temp_bed.pid.Kp = DEFAULT_bedKp;
+    thermalManager.temp_bed.pid.Ki = scalePID_i(DEFAULT_bedKi);
+    thermalManager.temp_bed.pid.Kd = scalePID_d(DEFAULT_bedKd);
+  #endif
+
+  //
+  // User-Defined Thermistors
+  //
+  TERN_(HAS_USER_THERMISTORS, thermalManager.reset_user_thermistors());
+
+  //
+  // Power Monitor
+  //
+  TERN_(POWER_MONITOR, power_monitor.reset());
+
+  //
+  // LCD Contrast
+  //
+  TERN_(HAS_LCD_CONTRAST, ui.set_contrast(DEFAULT_LCD_CONTRAST));
+
+  //
+  // Controller Fan
+  //
+  TERN_(USE_CONTROLLER_FAN, controllerFan.reset());
+
+  //
+  // Power-Loss Recovery
+  //
+  TERN_(POWER_LOSS_RECOVERY, recovery.enable(ENABLED(PLR_ENABLED_DEFAULT)));
+
+  //
+  // Firmware Retraction
+  //
+  TERN_(FWRETRACT, fwretract.reset());
+
+  //
+  // Volumetric & Filament Size
+  //
+
+  #if DISABLED(NO_VOLUMETRICS)
+    parser.volumetric_enabled = ENABLED(VOLUMETRIC_DEFAULT_ON);
+    LOOP_L_N(q, COUNT(planner.filament_size))
+      planner.filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      LOOP_L_N(q, COUNT(planner.volumetric_extruder_limit))
+        planner.volumetric_extruder_limit[q] = DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT;
+    #endif
+  #endif
+
+  endstops.enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
+
+  reset_stepper_drivers();
+
+  //
+  // Linear Advance
+  //
+
+  #if ENABLED(LIN_ADVANCE)
+    LOOP_L_N(i, EXTRUDERS) {
+      planner.extruder_advance_K[i] = LIN_ADVANCE_K;
+      TERN_(EXTRA_LIN_ADVANCE_K, other_extruder_advance_K[i] = LIN_ADVANCE_K);
+    }
+  #endif
+
+  //
+  // Motor Current PWM
+  //
+
+  #if HAS_MOTOR_CURRENT_PWM
+    constexpr uint32_t tmp_motor_current_setting[3] = PWM_MOTOR_CURRENT;
+    LOOP_L_N(q, 3)
+      stepper.digipot_current(q, (stepper.motor_current_setting[q] = tmp_motor_current_setting[q]));
+  #endif
+
+  //
+  // CNC Coordinate System
+  //
+  TERN_(CNC_COORDINATE_SYSTEMS, (void)gcode.select_coordinate_system(-1)); // Go back to machine space
+
+  //
+  // Skew Correction
+  //
+  #if ENABLED(SKEW_CORRECTION_GCODE)
+    planner.skew_factor.xy = XY_SKEW_FACTOR;
+    #if ENABLED(SKEW_CORRECTION_FOR_Z)
+      planner.skew_factor.xz = XZ_SKEW_FACTOR;
+      planner.skew_factor.yz = YZ_SKEW_FACTOR;
+    #endif
+  #endif
+
+  //
+  // Advanced Pause filament load & unload lengths
+  //
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    LOOP_L_N(e, EXTRUDERS) {
+      fc_settings[e].unload_length = FILAMENT_CHANGE_UNLOAD_LENGTH;
+      fc_settings[e].load_length = FILAMENT_CHANGE_FAST_LOAD_LENGTH;
+    }
+  #endif
+
+  postprocess();
+
+  DEBUG_ECHO_START();
+  DEBUG_ECHOLNPGM("Hardcoded Default Settings Loaded");
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onFactoryReset());
+}
+
+#if DISABLED(DISABLE_M503)
+
+  static void config_heading(const bool repl, PGM_P const pstr, const bool eol=true) {
+    if (!repl) {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM("; ");
+      serialprintPGM(pstr);
+      if (eol) SERIAL_EOL();
+    }
+  }
+
+  #define CONFIG_ECHO_START()       do{ if (!forReplay) SERIAL_ECHO_START(); }while(0)
+  #define CONFIG_ECHO_MSG(STR)      do{ CONFIG_ECHO_START(); SERIAL_ECHOLNPGM(STR); }while(0)
+  #define CONFIG_ECHO_HEADING(STR)  config_heading(forReplay, PSTR(STR))
+
+  #if HAS_TRINAMIC_CONFIG
+    inline void say_M906(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M906"); }
+    #if HAS_STEALTHCHOP
+      void say_M569(const bool forReplay, const char * const etc=nullptr, const bool newLine = false) {
+        CONFIG_ECHO_START();
+        SERIAL_ECHOPGM("  M569 S1");
+        if (etc) {
+          SERIAL_CHAR(' ');
+          serialprintPGM(etc);
+        }
+        if (newLine) SERIAL_EOL();
+      }
+    #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      inline void say_M913(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M913"); }
+    #endif
+    #if USE_SENSORLESS
+      inline void say_M914() { SERIAL_ECHOPGM("  M914"); }
+    #endif
+  #endif
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    inline void say_M603(const bool forReplay) { CONFIG_ECHO_START(); SERIAL_ECHOPGM("  M603 "); }
+  #endif
+
+  inline void say_units(const bool colon) {
+    serialprintPGM(
+      #if ENABLED(INCH_MODE_SUPPORT)
+        parser.linear_unit_factor != 1.0 ? PSTR(" (in)") :
+      #endif
+      PSTR(" (mm)")
+    );
+    if (colon) SERIAL_ECHOLNPGM(":");
+  }
+
+  void report_M92(const bool echo=true, const int8_t e=-1);
+
+  /**
+   * M503 - Report current settings in RAM
+   *
+   * Unless specifically disabled, M503 is available even without EEPROM
+   */
+  void MarlinSettings::report(const bool forReplay) {
+    /**
+     * Announce current units, in case inches are being displayed
+     */
+    CONFIG_ECHO_START();
+    #if ENABLED(INCH_MODE_SUPPORT)
+      SERIAL_ECHOPGM("  G2");
+      SERIAL_CHAR(parser.linear_unit_factor == 1.0 ? '1' : '0');
+      SERIAL_ECHOPGM(" ;");
+      say_units(false);
+    #else
+      SERIAL_ECHOPGM("  G21    ; Units in mm");
+      say_units(false);
+    #endif
+    SERIAL_EOL();
+
+    #if HAS_LCD_MENU
+
+      // Temperature units - for Ultipanel temperature options
+
+      CONFIG_ECHO_START();
+      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+        SERIAL_ECHOPGM("  M149 ");
+        SERIAL_CHAR(parser.temp_units_code());
+        SERIAL_ECHOPGM(" ; Units in ");
+        serialprintPGM(parser.temp_units_name());
+      #else
+        SERIAL_ECHOLNPGM("  M149 C ; Units in Celsius");
+      #endif
+
+    #endif
+
+    SERIAL_EOL();
+
+    #if EXTRUDERS && DISABLED(NO_VOLUMETRICS)
+
+      /**
+       * Volumetric extrusion M200
+       */
+      if (!forReplay) {
+        config_heading(forReplay, PSTR("Filament settings:"), false);
+        if (parser.volumetric_enabled)
+          SERIAL_EOL();
+        else
+          SERIAL_ECHOLNPGM(" Disabled");
+      }
+
+      #if EXTRUDERS == 1
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled)
+                              , " D", LINEAR_UNIT(planner.filament_size[0])
+                              #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+                                , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[0])
+                              #endif
+                         );
+      #else
+        LOOP_L_N(i, EXTRUDERS) {
+          CONFIG_ECHO_START();
+          SERIAL_ECHOLNPAIR("  M200 T", int(i)
+                                , " D", LINEAR_UNIT(planner.filament_size[i])
+                                #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+                                  , " L", LINEAR_UNIT(planner.volumetric_extruder_limit[i])
+                                #endif
+                           );
+        }
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR("  M200 S", int(parser.volumetric_enabled));
+      #endif
+    #endif // EXTRUDERS && !NO_VOLUMETRICS
+
+    CONFIG_ECHO_HEADING("Steps per unit:");
+    report_M92(!forReplay);
+
+    CONFIG_ECHO_HEADING("Maximum feedrates (units/s):");
+    CONFIG_ECHO_START();
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M203 X"), LINEAR_UNIT(planner.settings.max_feedrate_mm_s[X_AXIS])
+      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Y_AXIS])
+      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_feedrate_mm_s[Z_AXIS])
+      #if DISABLED(DISTINCT_E_FACTORS)
+        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS])
+      #endif
+    );
+    #if ENABLED(DISTINCT_E_FACTORS)
+      LOOP_L_N(i, E_STEPPERS) {
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR_P(
+            PSTR("  M203 T"), (int)i
+          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_feedrate_mm_s[E_AXIS_N(i)])
+        );
+      }
+    #endif
+
+    CONFIG_ECHO_HEADING("Maximum Acceleration (units/s2):");
+    CONFIG_ECHO_START();
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M201 X"), LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[X_AXIS])
+      , SP_Y_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Y_AXIS])
+      , SP_Z_STR, LINEAR_UNIT(planner.settings.max_acceleration_mm_per_s2[Z_AXIS])
+      #if DISABLED(DISTINCT_E_FACTORS)
+        , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS])
+      #endif
+    );
+    #if ENABLED(DISTINCT_E_FACTORS)
+      LOOP_L_N(i, E_STEPPERS) {
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR_P(
+            PSTR("  M201 T"), (int)i
+          , SP_E_STR, VOLUMETRIC_UNIT(planner.settings.max_acceleration_mm_per_s2[E_AXIS_N(i)])
+        );
+      }
+    #endif
+
+    CONFIG_ECHO_HEADING("Acceleration (units/s2): P<print_accel> R<retract_accel> T<travel_accel>");
+    CONFIG_ECHO_START();
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M204 P"), LINEAR_UNIT(planner.settings.acceleration)
+      , PSTR(" R"), LINEAR_UNIT(planner.settings.retract_acceleration)
+      , SP_T_STR, LINEAR_UNIT(planner.settings.travel_acceleration)
+    );
+
+    CONFIG_ECHO_HEADING(
+      "Advanced: B<min_segment_time_us> S<min_feedrate> T<min_travel_feedrate>"
+      #if HAS_JUNCTION_DEVIATION
+        " J<junc_dev>"
+      #endif
+      #if HAS_CLASSIC_JERK
+        " X<max_x_jerk> Y<max_y_jerk> Z<max_z_jerk>"
+        TERN_(HAS_CLASSIC_E_JERK, " E<max_e_jerk>")
+      #endif
+    );
+    CONFIG_ECHO_START();
+    SERIAL_ECHOLNPAIR_P(
+        PSTR("  M205 B"), LINEAR_UNIT(planner.settings.min_segment_time_us)
+      , PSTR(" S"), LINEAR_UNIT(planner.settings.min_feedrate_mm_s)
+      , SP_T_STR, LINEAR_UNIT(planner.settings.min_travel_feedrate_mm_s)
+      #if HAS_JUNCTION_DEVIATION
+        , PSTR(" J"), LINEAR_UNIT(planner.junction_deviation_mm)
+      #endif
+      #if HAS_CLASSIC_JERK
+        , SP_X_STR, LINEAR_UNIT(planner.max_jerk.x)
+        , SP_Y_STR, LINEAR_UNIT(planner.max_jerk.y)
+        , SP_Z_STR, LINEAR_UNIT(planner.max_jerk.z)
+        #if HAS_CLASSIC_E_JERK
+          , SP_E_STR, LINEAR_UNIT(planner.max_jerk.e)
+        #endif
+      #endif
+    );
+
+    #if HAS_M206_COMMAND
+      CONFIG_ECHO_HEADING("Home offset:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+        #if IS_CARTESIAN
+            PSTR("  M206 X"), LINEAR_UNIT(home_offset.x)
+          , SP_Y_STR, LINEAR_UNIT(home_offset.y)
+          , SP_Z_STR
+        #else
+          PSTR("  M206 Z")
+        #endif
+        , LINEAR_UNIT(home_offset.z)
+      );
+    #endif
+
+    #if HAS_HOTEND_OFFSET
+      CONFIG_ECHO_HEADING("Hotend offsets:");
+      CONFIG_ECHO_START();
+      LOOP_S_L_N(e, 1, HOTENDS) {
+        SERIAL_ECHOPAIR_P(
+          PSTR("  M218 T"), (int)e,
+          SP_X_STR, LINEAR_UNIT(hotend_offset[e].x),
+          SP_Y_STR, LINEAR_UNIT(hotend_offset[e].y)
+        );
+        SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(hotend_offset[e].z), 3);
+      }
+    #endif
+
+    /**
+     * Bed Leveling
+     */
+    #if HAS_LEVELING
+
+      #if ENABLED(MESH_BED_LEVELING)
+
+        CONFIG_ECHO_HEADING("Mesh Bed Leveling:");
+
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+        config_heading(forReplay, PSTR(""), false);
+        if (!forReplay) {
+          ubl.echo_name();
+          SERIAL_CHAR(':');
+          SERIAL_EOL();
+        }
+
+      #elif HAS_ABL_OR_UBL
+
+        CONFIG_ECHO_HEADING("Auto Bed Leveling:");
+
+      #endif
+
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+        PSTR("  M420 S"), planner.leveling_active ? 1 : 0
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          , SP_Z_STR, LINEAR_UNIT(planner.z_fade_height)
+        #endif
+      );
+
+      #if ENABLED(MESH_BED_LEVELING)
+
+        if (leveling_is_valid()) {
+          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
+            LOOP_L_N(px, GRID_MAX_POINTS_X) {
+              CONFIG_ECHO_START();
+              SERIAL_ECHOPAIR_P(PSTR("  G29 S3 I"), (int)px, PSTR(" J"), (int)py);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(mbl.z_values[px][py]), 5);
+            }
+          }
+          CONFIG_ECHO_START();
+          SERIAL_ECHOLNPAIR_F_P(PSTR("  G29 S4 Z"), LINEAR_UNIT(mbl.z_offset), 5);
+        }
+
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+        if (!forReplay) {
+          SERIAL_EOL();
+          ubl.report_state();
+          SERIAL_EOL();
+          config_heading(false, PSTR("Active Mesh Slot: "), false);
+          SERIAL_ECHOLN(ubl.storage_slot);
+          config_heading(false, PSTR("EEPROM can hold "), false);
+          SERIAL_ECHO(calc_num_meshes());
+          SERIAL_ECHOLNPGM(" meshes.\n");
+        }
+
+       //ubl.report_current_mesh();   // This is too verbose for large meshes. A better (more terse)
+                                                  // solution needs to be found.
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        if (leveling_is_valid()) {
+          LOOP_L_N(py, GRID_MAX_POINTS_Y) {
+            LOOP_L_N(px, GRID_MAX_POINTS_X) {
+              CONFIG_ECHO_START();
+              SERIAL_ECHOPAIR("  G29 W I", (int)px, " J", (int)py);
+              SERIAL_ECHOLNPAIR_F_P(SP_Z_STR, LINEAR_UNIT(z_values[px][py]), 5);
+            }
+          }
+        }
+
+      #endif
+
+    #endif // HAS_LEVELING
+
+    #if ENABLED(EDITABLE_SERVO_ANGLES)
+
+      CONFIG_ECHO_HEADING("Servo Angles:");
+      LOOP_L_N(i, NUM_SERVOS) {
+        switch (i) {
+          #if ENABLED(SWITCHING_EXTRUDER)
+            case SWITCHING_EXTRUDER_SERVO_NR:
+            #if EXTRUDERS > 3
+              case SWITCHING_EXTRUDER_E23_SERVO_NR:
+            #endif
+          #elif ENABLED(SWITCHING_NOZZLE)
+            case SWITCHING_NOZZLE_SERVO_NR:
+          #elif ENABLED(BLTOUCH) || (HAS_Z_SERVO_PROBE && defined(Z_SERVO_ANGLES))
+            case Z_PROBE_SERVO_NR:
+          #endif
+            CONFIG_ECHO_START();
+            SERIAL_ECHOLNPAIR("  M281 P", int(i), " L", servo_angles[i][0], " U", servo_angles[i][1]);
+          default: break;
+        }
+      }
+
+    #endif // EDITABLE_SERVO_ANGLES
+
+    #if HAS_SCARA_OFFSET
+
+      CONFIG_ECHO_HEADING("SCARA settings: S<seg-per-sec> P<theta-psi-offset> T<theta-offset>");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M665 S"), delta_segments_per_second
+        , SP_P_STR, scara_home_offset.a
+        , SP_T_STR, scara_home_offset.b
+        , SP_Z_STR, LINEAR_UNIT(scara_home_offset.z)
+      );
+
+    #elif ENABLED(DELTA)
+
+      CONFIG_ECHO_HEADING("Endstop adjustment:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M666 X"), LINEAR_UNIT(delta_endstop_adj.a)
+        , SP_Y_STR, LINEAR_UNIT(delta_endstop_adj.b)
+        , SP_Z_STR, LINEAR_UNIT(delta_endstop_adj.c)
+      );
+
+      CONFIG_ECHO_HEADING("Delta settings: L<diagonal rod> R<radius> H<height> S<segments per sec> XYZ<tower angle trim> ABC<rod trim>");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M665 L"), LINEAR_UNIT(delta_diagonal_rod)
+        , PSTR(" R"), LINEAR_UNIT(delta_radius)
+        , PSTR(" H"), LINEAR_UNIT(delta_height)
+        , PSTR(" S"), delta_segments_per_second
+        , SP_X_STR, LINEAR_UNIT(delta_tower_angle_trim.a)
+        , SP_Y_STR, LINEAR_UNIT(delta_tower_angle_trim.b)
+        , SP_Z_STR, LINEAR_UNIT(delta_tower_angle_trim.c)
+        , PSTR(" A"), LINEAR_UNIT(delta_diagonal_rod_trim.a)
+        , PSTR(" B"), LINEAR_UNIT(delta_diagonal_rod_trim.b)
+        , PSTR(" C"), LINEAR_UNIT(delta_diagonal_rod_trim.c)
+      );
+
+    #elif HAS_EXTRA_ENDSTOPS
+
+      CONFIG_ECHO_HEADING("Endstop adjustment:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOPGM("  M666");
+      #if ENABLED(X_DUAL_ENDSTOPS)
+        SERIAL_ECHOLNPAIR_P(SP_X_STR, LINEAR_UNIT(endstops.x2_endstop_adj));
+      #endif
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+        SERIAL_ECHOLNPAIR_P(SP_Y_STR, LINEAR_UNIT(endstops.y2_endstop_adj));
+      #endif
+      #if ENABLED(Z_MULTI_ENDSTOPS)
+        #if NUM_Z_STEPPER_DRIVERS >= 3
+          SERIAL_ECHOPAIR(" S2 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+          CONFIG_ECHO_START();
+          SERIAL_ECHOPAIR("  M666 S3 Z", LINEAR_UNIT(endstops.z3_endstop_adj));
+          #if NUM_Z_STEPPER_DRIVERS >= 4
+            CONFIG_ECHO_START();
+            SERIAL_ECHOPAIR("  M666 S4 Z", LINEAR_UNIT(endstops.z4_endstop_adj));
+          #endif
+        #else
+          SERIAL_ECHOLNPAIR_P(SP_Z_STR, LINEAR_UNIT(endstops.z2_endstop_adj));
+        #endif
+      #endif
+
+    #endif // [XYZ]_DUAL_ENDSTOPS
+
+    #if PREHEAT_COUNT
+
+      CONFIG_ECHO_HEADING("Material heatup parameters:");
+      LOOP_L_N(i, PREHEAT_COUNT) {
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR_P(
+          PSTR("  M145 S"), (int)i
+          #if HAS_HOTEND
+            , PSTR(" H"), TEMP_UNIT(ui.material_preset[i].hotend_temp)
+          #endif
+          #if HAS_HEATED_BED
+            , SP_B_STR, TEMP_UNIT(ui.material_preset[i].bed_temp)
+          #endif
+          #if HAS_FAN
+            , PSTR(" F"), ui.material_preset[i].fan_speed
+          #endif
+        );
+      }
+
+    #endif
+
+    #if HAS_PID_HEATING
+
+      CONFIG_ECHO_HEADING("PID settings:");
+
+      #if ENABLED(PIDTEMP)
+        HOTEND_LOOP() {
+          CONFIG_ECHO_START();
+          SERIAL_ECHOPAIR_P(
+            #if ENABLED(PID_PARAMS_PER_HOTEND)
+              PSTR("  M301 E"), e,
+              SP_P_STR
+            #else
+              PSTR("  M301 P")
+            #endif
+                        , PID_PARAM(Kp, e)
+            , PSTR(" I"), unscalePID_i(PID_PARAM(Ki, e))
+            , PSTR(" D"), unscalePID_d(PID_PARAM(Kd, e))
+          );
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            SERIAL_ECHOPAIR_P(SP_C_STR, PID_PARAM(Kc, e));
+            if (e == 0) SERIAL_ECHOPAIR(" L", thermalManager.lpq_len);
+          #endif
+          #if ENABLED(PID_FAN_SCALING)
+            SERIAL_ECHOPAIR(" F", PID_PARAM(Kf, e));
+          #endif
+          SERIAL_EOL();
+        }
+      #endif // PIDTEMP
+
+      #if ENABLED(PIDTEMPBED)
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR(
+            "  M304 P", thermalManager.temp_bed.pid.Kp
+          , " I", unscalePID_i(thermalManager.temp_bed.pid.Ki)
+          , " D", unscalePID_d(thermalManager.temp_bed.pid.Kd)
+        );
+      #endif
+
+    #endif // PIDTEMP || PIDTEMPBED
+
+    #if HAS_USER_THERMISTORS
+      CONFIG_ECHO_HEADING("User thermistors:");
+      LOOP_L_N(i, USER_THERMISTORS)
+        thermalManager.log_user_thermistor(i, true);
+    #endif
+
+    #if HAS_LCD_CONTRAST
+      CONFIG_ECHO_HEADING("LCD Contrast:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR("  M250 C", ui.contrast);
+    #endif
+
+    TERN_(CONTROLLER_FAN_EDITABLE, M710_report(forReplay));
+
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      CONFIG_ECHO_HEADING("Power-Loss Recovery:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR("  M413 S", int(recovery.enabled));
+    #endif
+
+    #if ENABLED(FWRETRACT)
+
+      CONFIG_ECHO_HEADING("Retract: S<length> F<units/m> Z<lift>");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M207 S"), LINEAR_UNIT(fwretract.settings.retract_length)
+        , PSTR(" W"), LINEAR_UNIT(fwretract.settings.swap_retract_length)
+        , PSTR(" F"), LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_feedrate_mm_s))
+        , SP_Z_STR, LINEAR_UNIT(fwretract.settings.retract_zraise)
+      );
+
+      CONFIG_ECHO_HEADING("Recover: S<length> F<units/m>");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR(
+          "  M208 S", LINEAR_UNIT(fwretract.settings.retract_recover_extra)
+        , " W", LINEAR_UNIT(fwretract.settings.swap_retract_recover_extra)
+        , " F", LINEAR_UNIT(MMS_TO_MMM(fwretract.settings.retract_recover_feedrate_mm_s))
+      );
+
+      #if ENABLED(FWRETRACT_AUTORETRACT)
+
+        CONFIG_ECHO_HEADING("Auto-Retract: S=0 to disable, 1 to interpret E-only moves as retract/recover");
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR("  M209 S", fwretract.autoretract_enabled ? 1 : 0);
+
+      #endif // FWRETRACT_AUTORETRACT
+
+    #endif // FWRETRACT
+
+    /**
+     * Probe Offset
+     */
+    #if HAS_BED_PROBE
+      config_heading(forReplay, PSTR("Z-Probe Offset"), false);
+      if (!forReplay) say_units(true);
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+        #if HAS_PROBE_XY_OFFSET
+          PSTR("  M851 X"), LINEAR_UNIT(probe.offset_xy.x),
+                  SP_Y_STR, LINEAR_UNIT(probe.offset_xy.y),
+                  SP_Z_STR
+        #else
+          PSTR("  M851 X0 Y0 Z")
+        #endif
+        , LINEAR_UNIT(probe.offset.z)
+      );
+    #endif
+
+    /**
+     * Bed Skew Correction
+     */
+    #if ENABLED(SKEW_CORRECTION_GCODE)
+      CONFIG_ECHO_HEADING("Skew Factor: ");
+      CONFIG_ECHO_START();
+      #if ENABLED(SKEW_CORRECTION_FOR_Z)
+        SERIAL_ECHOPAIR_F("  M852 I", LINEAR_UNIT(planner.skew_factor.xy), 6);
+        SERIAL_ECHOPAIR_F(" J", LINEAR_UNIT(planner.skew_factor.xz), 6);
+        SERIAL_ECHOLNPAIR_F(" K", LINEAR_UNIT(planner.skew_factor.yz), 6);
+      #else
+        SERIAL_ECHOLNPAIR_F("  M852 S", LINEAR_UNIT(planner.skew_factor.xy), 6);
+      #endif
+    #endif
+
+    #if HAS_TRINAMIC_CONFIG
+
+      /**
+       * TMC stepper driver current
+       */
+      CONFIG_ECHO_HEADING("Stepper driver current:");
+
+      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(Y) || AXIS_IS_TMC(Z)
+        say_M906(forReplay);
+        #if AXIS_IS_TMC(X)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.getMilliamps());
+        #endif
+        SERIAL_EOL();
+      #endif
+
+      #if AXIS_IS_TMC(X2) || AXIS_IS_TMC(Y2) || AXIS_IS_TMC(Z2)
+        say_M906(forReplay);
+        SERIAL_ECHOPGM(" I1");
+        #if AXIS_IS_TMC(X2)
+          SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.getMilliamps());
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.getMilliamps());
+        #endif
+        SERIAL_EOL();
+      #endif
+
+      #if AXIS_IS_TMC(Z3)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.getMilliamps());
+      #endif
+
+      #if AXIS_IS_TMC(Z4)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.getMilliamps());
+      #endif
+
+      #if AXIS_IS_TMC(E0)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T0 E", stepperE0.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E1)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T1 E", stepperE1.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E2)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T2 E", stepperE2.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E3)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T3 E", stepperE3.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E4)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T4 E", stepperE4.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E5)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T5 E", stepperE5.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E6)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T6 E", stepperE6.getMilliamps());
+      #endif
+      #if AXIS_IS_TMC(E7)
+        say_M906(forReplay);
+        SERIAL_ECHOLNPAIR(" T7 E", stepperE7.getMilliamps());
+      #endif
+      SERIAL_EOL();
+
+      /**
+       * TMC Hybrid Threshold
+       */
+      #if ENABLED(HYBRID_THRESHOLD)
+        CONFIG_ECHO_HEADING("Hybrid Threshold:");
+        #if AXIS_HAS_STEALTHCHOP(X) || AXIS_HAS_STEALTHCHOP(Y) || AXIS_HAS_STEALTHCHOP(Z)
+          say_M913(forReplay);
+          #if AXIS_HAS_STEALTHCHOP(X)
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Y)
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Z)
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.get_pwm_thrs());
+          #endif
+          SERIAL_EOL();
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(X2) || AXIS_HAS_STEALTHCHOP(Y2) || AXIS_HAS_STEALTHCHOP(Z2)
+          say_M913(forReplay);
+          SERIAL_ECHOPGM(" I1");
+          #if AXIS_HAS_STEALTHCHOP(X2)
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Y2)
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.get_pwm_thrs());
+          #endif
+          #if AXIS_HAS_STEALTHCHOP(Z2)
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.get_pwm_thrs());
+          #endif
+          SERIAL_EOL();
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.get_pwm_thrs());
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.get_pwm_thrs());
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(E0)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T0 E", stepperE0.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E1)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T1 E", stepperE1.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E2)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T2 E", stepperE2.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E3)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T3 E", stepperE3.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E4)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T4 E", stepperE4.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E5)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T5 E", stepperE5.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E6)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T6 E", stepperE6.get_pwm_thrs());
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E7)
+          say_M913(forReplay);
+          SERIAL_ECHOLNPAIR(" T7 E", stepperE7.get_pwm_thrs());
+        #endif
+        SERIAL_EOL();
+      #endif // HYBRID_THRESHOLD
+
+      /**
+       * TMC Sensorless homing thresholds
+       */
+      #if USE_SENSORLESS
+        CONFIG_ECHO_HEADING("StallGuard threshold:");
+        #if X_SENSORLESS || Y_SENSORLESS || Z_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          #if X_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX.homing_threshold());
+          #endif
+          #if Y_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY.homing_threshold());
+          #endif
+          #if Z_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ.homing_threshold());
+          #endif
+          SERIAL_EOL();
+        #endif
+
+        #if X2_SENSORLESS || Y2_SENSORLESS || Z2_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOPGM(" I1");
+          #if X2_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_X_STR, stepperX2.homing_threshold());
+          #endif
+          #if Y2_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_Y_STR, stepperY2.homing_threshold());
+          #endif
+          #if Z2_SENSORLESS
+            SERIAL_ECHOPAIR_P(SP_Z_STR, stepperZ2.homing_threshold());
+          #endif
+          SERIAL_EOL();
+        #endif
+
+        #if Z3_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR(" I2 Z", stepperZ3.homing_threshold());
+        #endif
+
+        #if Z4_SENSORLESS
+          CONFIG_ECHO_START();
+          say_M914();
+          SERIAL_ECHOLNPAIR(" I3 Z", stepperZ4.homing_threshold());
+        #endif
+
+      #endif // USE_SENSORLESS
+
+      /**
+       * TMC stepping mode
+       */
+      #if HAS_STEALTHCHOP
+        CONFIG_ECHO_HEADING("Driver stepping mode:");
+        #if AXIS_HAS_STEALTHCHOP(X)
+          const bool chop_x = stepperX.get_stealthChop_status();
+        #else
+          constexpr bool chop_x = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y)
+          const bool chop_y = stepperY.get_stealthChop_status();
+        #else
+          constexpr bool chop_y = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z)
+          const bool chop_z = stepperZ.get_stealthChop_status();
+        #else
+          constexpr bool chop_z = false;
+        #endif
+
+        if (chop_x || chop_y || chop_z) {
+          say_M569(forReplay);
+          if (chop_x) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z) SERIAL_ECHOPGM_P(SP_Z_STR);
+          SERIAL_EOL();
+        }
+
+        #if AXIS_HAS_STEALTHCHOP(X2)
+          const bool chop_x2 = stepperX2.get_stealthChop_status();
+        #else
+          constexpr bool chop_x2 = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Y2)
+          const bool chop_y2 = stepperY2.get_stealthChop_status();
+        #else
+          constexpr bool chop_y2 = false;
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(Z2)
+          const bool chop_z2 = stepperZ2.get_stealthChop_status();
+        #else
+          constexpr bool chop_z2 = false;
+        #endif
+
+        if (chop_x2 || chop_y2 || chop_z2) {
+          say_M569(forReplay, PSTR("I1"));
+          if (chop_x2) SERIAL_ECHOPGM_P(SP_X_STR);
+          if (chop_y2) SERIAL_ECHOPGM_P(SP_Y_STR);
+          if (chop_z2) SERIAL_ECHOPGM_P(SP_Z_STR);
+          SERIAL_EOL();
+        }
+
+        #if AXIS_HAS_STEALTHCHOP(Z3)
+          if (stepperZ3.get_stealthChop_status()) { say_M569(forReplay, PSTR("I2 Z"), true); }
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(Z4)
+          if (stepperZ4.get_stealthChop_status()) { say_M569(forReplay, PSTR("I3 Z"), true); }
+        #endif
+
+        #if AXIS_HAS_STEALTHCHOP(E0)
+          if (stepperE0.get_stealthChop_status()) { say_M569(forReplay, PSTR("T0 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E1)
+          if (stepperE1.get_stealthChop_status()) { say_M569(forReplay, PSTR("T1 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E2)
+          if (stepperE2.get_stealthChop_status()) { say_M569(forReplay, PSTR("T2 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E3)
+          if (stepperE3.get_stealthChop_status()) { say_M569(forReplay, PSTR("T3 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E4)
+          if (stepperE4.get_stealthChop_status()) { say_M569(forReplay, PSTR("T4 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E5)
+          if (stepperE5.get_stealthChop_status()) { say_M569(forReplay, PSTR("T5 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E6)
+          if (stepperE6.get_stealthChop_status()) { say_M569(forReplay, PSTR("T6 E"), true); }
+        #endif
+        #if AXIS_HAS_STEALTHCHOP(E7)
+          if (stepperE7.get_stealthChop_status()) { say_M569(forReplay, PSTR("T7 E"), true); }
+        #endif
+
+      #endif // HAS_STEALTHCHOP
+
+    #endif // HAS_TRINAMIC_CONFIG
+
+    /**
+     * Linear Advance
+     */
+    #if ENABLED(LIN_ADVANCE)
+      CONFIG_ECHO_HEADING("Linear Advance:");
+      #if EXTRUDERS < 2
+        CONFIG_ECHO_START();
+        SERIAL_ECHOLNPAIR("  M900 K", planner.extruder_advance_K[0]);
+      #else
+        LOOP_L_N(i, EXTRUDERS) {
+          CONFIG_ECHO_START();
+          SERIAL_ECHOLNPAIR("  M900 T", int(i), " K", planner.extruder_advance_K[i]);
+        }
+      #endif
+    #endif
+
+    #if HAS_MOTOR_CURRENT_PWM
+      CONFIG_ECHO_HEADING("Stepper motor currents:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M907 X"), stepper.motor_current_setting[0]
+        , SP_Z_STR, stepper.motor_current_setting[1]
+        , SP_E_STR, stepper.motor_current_setting[2]
+      );
+    #endif
+
+    /**
+     * Advanced Pause filament load & unload lengths
+     */
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      CONFIG_ECHO_HEADING("Filament load/unload lengths:");
+      #if EXTRUDERS == 1
+        say_M603(forReplay);
+        SERIAL_ECHOLNPAIR("L", LINEAR_UNIT(fc_settings[0].load_length), " U", LINEAR_UNIT(fc_settings[0].unload_length));
+      #else
+        #define _ECHO_603(N) do{ say_M603(forReplay); SERIAL_ECHOLNPAIR("T" STRINGIFY(N) " L", LINEAR_UNIT(fc_settings[N].load_length), " U", LINEAR_UNIT(fc_settings[N].unload_length)); }while(0);
+        REPEAT(EXTRUDERS, _ECHO_603)
+      #endif
+    #endif
+
+    #if EXTRUDERS > 1
+      CONFIG_ECHO_HEADING("Tool-changing:");
+      CONFIG_ECHO_START();
+      M217_report(true);
+    #endif
+
+    #if ENABLED(BACKLASH_GCODE)
+      CONFIG_ECHO_HEADING("Backlash compensation:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR_P(
+          PSTR("  M425 F"), backlash.get_correction()
+        , SP_X_STR, LINEAR_UNIT(backlash.distance_mm.x)
+        , SP_Y_STR, LINEAR_UNIT(backlash.distance_mm.y)
+        , SP_Z_STR, LINEAR_UNIT(backlash.distance_mm.z)
+        #ifdef BACKLASH_SMOOTHING_MM
+          , PSTR(" S"), LINEAR_UNIT(backlash.smoothing_mm)
+        #endif
+      );
+    #endif
+
+    #if HAS_FILAMENT_SENSOR
+      CONFIG_ECHO_HEADING("Filament runout sensor:");
+      CONFIG_ECHO_START();
+      SERIAL_ECHOLNPAIR(
+        "  M412 S", int(runout.enabled)
+        #if HAS_FILAMENT_RUNOUT_DISTANCE
+          , " D", LINEAR_UNIT(runout.runout_distance())
+        #endif
+      );
+    #endif
+  }
+
+#endif // !DISABLE_M503
+
+#pragma pack(pop)
