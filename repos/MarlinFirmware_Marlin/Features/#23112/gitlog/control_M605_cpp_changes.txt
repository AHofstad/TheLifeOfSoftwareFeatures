commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    üßë‚Äçüíª AS_CHAR => C (#26569)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 6bf99df4c2..167cdae4a9 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -137,21 +137,21 @@
           "\ndelayed_move_time: ", delayed_move_time,
           "\nX1 Home: ", x_home_pos(0), " X1_MIN_POS=", X1_MIN_POS, " X1_MAX_POS=", X1_MAX_POS,
           "\nX2 Home: ", x_home_pos(1), " X2_MIN_POS=", X2_MIN_POS, " X2_MAX_POS=", X2_MAX_POS,
           "\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE),
           "\toolchange_settings.z_raise=", toolchange_settings.z_raise,
           "\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET
         );
 
         HOTEND_LOOP() {
           DEBUG_ECHOPGM_P(SP_T_STR, e);
-          LOOP_NUM_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
+          LOOP_NUM_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", C(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index a52c706fa6..6bf99df4c2 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -120,35 +120,34 @@
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
           case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
           case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
           case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
         DEBUG_ECHOPGM("\nActive Ext: ", active_extruder);
-        if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
-        DEBUG_ECHOPGM(" parked.");
-        DEBUG_ECHOPGM("\nactive_extruder_x_pos: ", current_position.x);
-        DEBUG_ECHOPGM("\ninactive_extruder_x: ", inactive_extruder_x);
-        DEBUG_ECHOPGM("\nextruder_duplication_enabled: ", extruder_duplication_enabled);
-        DEBUG_ECHOPGM("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
-        DEBUG_ECHOPGM("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
-        DEBUG_ECHOPGM("\ndelayed_move_time: ", delayed_move_time);
-        DEBUG_ECHOPGM("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
-        DEBUG_ECHOPGM("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
-        DEBUG_ECHOPGM("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
-        DEBUG_ECHOPGM("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
-        DEBUG_ECHOPGM("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
-        DEBUG_ECHOPGM("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
-        DEBUG_EOL();
+        if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ", F(" parked."));
+        DEBUG_ECHOLNPGM(
+          "\nactive_extruder_x_pos: ", current_position.x,
+          "\ninactive_extruder_x: ", inactive_extruder_x,
+          "\nextruder_duplication_enabled: ", extruder_duplication_enabled,
+          "\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset,
+          "\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset,
+          "\ndelayed_move_time: ", delayed_move_time,
+          "\nX1 Home: ", x_home_pos(0), " X1_MIN_POS=", X1_MIN_POS, " X1_MAX_POS=", X1_MAX_POS,
+          "\nX2 Home: ", x_home_pos(1), " X2_MIN_POS=", X2_MIN_POS, " X2_MAX_POS=", X2_MAX_POS,
+          "\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE),
+          "\toolchange_settings.z_raise=", toolchange_settings.z_raise,
+          "\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET
+        );
 
         HOTEND_LOOP() {
           DEBUG_ECHOPGM_P(SP_T_STR, e);
           LOOP_NUM_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }

commit 037444548859fce47e2034383937738017fe8cb1
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Jan 7 19:07:39 2023 +1300

    ü©π Replace pow() with _BV() (#25186)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index e3ca43e17f..a52c706fa6 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -162,21 +162,21 @@
    *  P[mask]  - Bit-mask of nozzles to include in the duplication set.
    *             A value of 0 disables duplication.
    *  E[index] - Last nozzle index to include in the duplication set.
    *             A value of 0 disables duplication.
    */
   void GcodeSuite::M605() {
     bool ena = false;
     if (parser.seen("EPS")) {
       planner.synchronize();
       if (parser.seenval('P')) duplication_e_mask = parser.value_int();   // Set the mask directly
-      else if (parser.seenval('E')) duplication_e_mask = pow(2, parser.value_int() + 1) - 1; // Set the mask by E index
+      else if (parser.seenval('E')) duplication_e_mask = _BV(parser.value_int() + 1) - 1; // Set the mask by E index
       ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
       set_duplication_enabled(ena && (duplication_e_mask >= 3));
     }
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_DUPLICATION_MODE);
     serialprint_onoff(extruder_duplication_enabled);
     if (ena) {
       SERIAL_ECHOPGM(" ( ");
       HOTEND_LOOP() if (TEST(duplication_e_mask, e)) { SERIAL_ECHO(e); SERIAL_CHAR(' '); }
       SERIAL_CHAR(')');

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    üßë‚Äçüíª  Update planner/stepper includes

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 06d92c8448..e3ca43e17f 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -21,21 +21,20 @@
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if HAS_DUPLICATION_MODE
 
 //#define DEBUG_DXC_MODE
 
 #include "../gcode.h"
 #include "../../module/motion.h"
-#include "../../module/stepper.h"
 #include "../../module/tool_change.h"
 #include "../../module/planner.h"
 
 #define DEBUG_OUT ENABLED(DEBUG_DXC_MODE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode

commit 2ee39b62f33027f49fc1c62a05379a37fc52077c
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Apr 18 06:03:39 2022 +0200

    ü©π Fix some parameters w/out values (#24051)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index a0296bba57..06d92c8448 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -57,36 +57,36 @@
    *             The temperature differential and initial X offset must be set with "M605 S2 X[offs] R[deg]",
    *             then followed by "M605 S3" to initiate mirrored movement.
    *
    *    M605 W  : IDEX What? command.
    *
    *    Note: the X axis should be homed after changing Dual X-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
-    if (parser.seen('S')) {
+    if (parser.seenval('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
       idex_set_mirrored_mode(false);
 
       switch (dual_x_carriage_mode) {
 
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
 
         case DXC_DUPLICATION_MODE:
           // Set the X offset, but no less than the safety gap
-          if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), (X2_MIN_POS) - (X1_MIN_POS));
-          if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
+          if (parser.seenval('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), (X2_MIN_POS) - (X1_MIN_POS));
+          if (parser.seenval('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           // Always switch back to tool 0
           if (active_extruder != 0) tool_change(0);
           break;
 
         case DXC_MIRRORED_MODE: {
           if (previous_mode != DXC_DUPLICATION_MODE) {
             SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
             SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
             dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
             return;

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 788659e7e2..a0296bba57 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -139,21 +139,21 @@
         DEBUG_ECHOPGM("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
         DEBUG_ECHOPGM("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
         DEBUG_ECHOPGM("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
         DEBUG_ECHOPGM("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPGM("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPGM("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPGM_P(SP_T_STR, e);
-          LOOP_LINEAR_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
+          LOOP_NUM_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    üé® Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 08efaab59d..788659e7e2 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -103,21 +103,21 @@
 
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
 
       idex_set_parked(false);
       set_duplication_enabled(false);
 
       #ifdef EVENT_GCODE_IDEX_AFTER_MODECHANGE
-        gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_IDEX_AFTER_MODECHANGE));
+        process_subcommands_now(F(EVENT_GCODE_IDEX_AFTER_MODECHANGE));
       #endif
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
     #ifdef DEBUG_DXC_MODE
 
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 23d43dd0a6..08efaab59d 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -120,40 +120,40 @@
 
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
           case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
           case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
           case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
-        DEBUG_ECHOPAIR("\nActive Ext: ", active_extruder);
+        DEBUG_ECHOPGM("\nActive Ext: ", active_extruder);
         if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
         DEBUG_ECHOPGM(" parked.");
-        DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position.x);
-        DEBUG_ECHOPAIR("\ninactive_extruder_x: ", inactive_extruder_x);
-        DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", extruder_duplication_enabled);
-        DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
-        DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
-        DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
-        DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
-        DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
-        DEBUG_ECHOPAIR("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
-        DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
-        DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
-        DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
+        DEBUG_ECHOPGM("\nactive_extruder_x_pos: ", current_position.x);
+        DEBUG_ECHOPGM("\ninactive_extruder_x: ", inactive_extruder_x);
+        DEBUG_ECHOPGM("\nextruder_duplication_enabled: ", extruder_duplication_enabled);
+        DEBUG_ECHOPGM("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
+        DEBUG_ECHOPGM("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
+        DEBUG_ECHOPGM("\ndelayed_move_time: ", delayed_move_time);
+        DEBUG_ECHOPGM("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
+        DEBUG_ECHOPGM("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
+        DEBUG_ECHOPGM("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
+        DEBUG_ECHOPGM("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
+        DEBUG_ECHOPGM("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
+        DEBUG_ECHOPGM("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
         DEBUG_EOL();
 
         HOTEND_LOOP() {
-          DEBUG_ECHOPAIR_P(SP_T_STR, e);
-          LOOP_LINEAR_AXES(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
+          DEBUG_ECHOPGM_P(SP_T_STR, e);
+          LOOP_LINEAR_AXES(a) DEBUG_ECHOPGM("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index ac84ac6217..23d43dd0a6 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -63,51 +63,56 @@
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
     if (parser.seen('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
       idex_set_mirrored_mode(false);
 
-      if (dual_x_carriage_mode == DXC_MIRRORED_MODE) {
-        if (previous_mode != DXC_DUPLICATION_MODE) {
-          SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
-          SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
-          dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
-          return;
-        }
-        idex_set_mirrored_mode(true);
-        float x_jog = current_position.x - .1;
-        for (uint8_t i = 2; --i;) {
-          planner.buffer_line(x_jog, current_position.y, current_position.z, current_position.e, feedrate_mm_s, 0);
-          x_jog += .1;
-        }
-        return;
-      }
-
       switch (dual_x_carriage_mode) {
+
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
+
         case DXC_DUPLICATION_MODE:
           // Set the X offset, but no less than the safety gap
           if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), (X2_MIN_POS) - (X1_MIN_POS));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           // Always switch back to tool 0
           if (active_extruder != 0) tool_change(0);
           break;
+
+        case DXC_MIRRORED_MODE: {
+          if (previous_mode != DXC_DUPLICATION_MODE) {
+            SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
+            SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
+            dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+            return;
+          }
+          idex_set_mirrored_mode(true);
+
+          // Do a small 'jog' motion in the X axis
+          xyze_pos_t dest = current_position; dest.x -= 0.1f;
+          for (uint8_t i = 2; --i;) {
+            planner.buffer_line(dest, feedrate_mm_s, 0);
+            dest.x += 0.1f;
+          }
+        } return;
+
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
+
       idex_set_parked(false);
       set_duplication_enabled(false);
 
       #ifdef EVENT_GCODE_IDEX_AFTER_MODECHANGE
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_IDEX_AFTER_MODECHANGE));
       #endif
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index e0c79f0e54..ac84ac6217 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -134,21 +134,21 @@
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPAIR_P(SP_T_STR, e);
-          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", AS_CHAR(XYZ_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
+          LOOP_LINEAR_AXES(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", AS_CHAR(AXIS_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 1879eede0d2910cac58f2a90b95989ff4531fa6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 7 15:43:07 2021 -0500

    Fix axis char printing

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 3d13cb1c24..e0c79f0e54 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -134,21 +134,21 @@
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPAIR_P(SP_T_STR, e);
-          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", XYZ_CHAR(a) | 0x20, "=", hotend_offset[e][a]);
+          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", AS_CHAR(XYZ_CHAR(a) | 0x20), "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 0d7a9f431b..3d13cb1c24 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -115,40 +115,40 @@
 
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
           case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
           case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
           case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
-        DEBUG_ECHOPAIR("\nActive Ext: ", int(active_extruder));
+        DEBUG_ECHOPAIR("\nActive Ext: ", active_extruder);
         if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
         DEBUG_ECHOPGM(" parked.");
         DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position.x);
         DEBUG_ECHOPAIR("\ninactive_extruder_x: ", inactive_extruder_x);
-        DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
+        DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", extruder_duplication_enabled);
         DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
         DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
-        DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
-        DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
-        DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
+        DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", X1_MIN_POS, "\nX1_MAX_POS=", X1_MAX_POS);
+        DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", X2_MIN_POS, "\nX2_MAX_POS=", X2_MAX_POS);
+        DEBUG_ECHOPAIR("\nX2_HOME_DIR=", X2_HOME_DIR, "\nX2_HOME_POS=", X2_HOME_POS);
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
-        DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
+        DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", DEFAULT_DUPLICATION_X_OFFSET);
         DEBUG_EOL();
 
         HOTEND_LOOP() {
-          DEBUG_ECHOPAIR_P(SP_T_STR, int(e));
-          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", int(e), "].", XYZ_CHAR(a) | 0x20, "=", hotend_offset[e][a]);
+          DEBUG_ECHOPAIR_P(SP_T_STR, e);
+          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", e, "].", XYZ_CHAR(a) | 0x20, "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit e955dce3dc08163cd8c83d8a87ddd1357acc1f97
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Nov 16 00:56:05 2020 -0500

    Update IDEX menus, add post-M605 event G-code (#20133)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index b1e54b25e7..0d7a9f431b 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -96,20 +96,24 @@
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           // Always switch back to tool 0
           if (active_extruder != 0) tool_change(0);
           break;
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
       idex_set_parked(false);
       set_duplication_enabled(false);
+
+      #ifdef EVENT_GCODE_IDEX_AFTER_MODECHANGE
+        gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_IDEX_AFTER_MODECHANGE));
+      #endif
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
     #ifdef DEBUG_DXC_MODE
 
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 5dc36428b5..b1e54b25e7 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -61,31 +61,30 @@
    *
    *    Note: the X axis should be homed after changing Dual X-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
     if (parser.seen('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
-      mirrored_duplication_mode = false;
+      idex_set_mirrored_mode(false);
 
       if (dual_x_carriage_mode == DXC_MIRRORED_MODE) {
         if (previous_mode != DXC_DUPLICATION_MODE) {
           SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
           SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           return;
         }
-        mirrored_duplication_mode = true;
-        stepper.set_directions();
+        idex_set_mirrored_mode(true);
         float x_jog = current_position.x - .1;
         for (uint8_t i = 2; --i;) {
           planner.buffer_line(x_jog, current_position.y, current_position.z, current_position.e, feedrate_mm_s, 0);
           x_jog += .1;
         }
         return;
       }
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
@@ -95,44 +94,42 @@
           // Set the X offset, but no less than the safety gap
           if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), (X2_MIN_POS) - (X1_MIN_POS));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           // Always switch back to tool 0
           if (active_extruder != 0) tool_change(0);
           break;
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
-      active_extruder_parked = false;
-      extruder_duplication_enabled = false;
-      stepper.set_directions();
-      delayed_move_time = 0;
+      idex_set_parked(false);
+      set_duplication_enabled(false);
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
     #ifdef DEBUG_DXC_MODE
 
       if (parser.seen('W')) {
         DEBUG_ECHO_START();
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
           case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
           case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
           case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
         DEBUG_ECHOPAIR("\nActive Ext: ", int(active_extruder));
         if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
         DEBUG_ECHOPGM(" parked.");
         DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position.x);
-        DEBUG_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
+        DEBUG_ECHOPAIR("\ninactive_extruder_x: ", inactive_extruder_x);
         DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
         DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
         DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
@@ -159,21 +156,21 @@
    *  E[index] - Last nozzle index to include in the duplication set.
    *             A value of 0 disables duplication.
    */
   void GcodeSuite::M605() {
     bool ena = false;
     if (parser.seen("EPS")) {
       planner.synchronize();
       if (parser.seenval('P')) duplication_e_mask = parser.value_int();   // Set the mask directly
       else if (parser.seenval('E')) duplication_e_mask = pow(2, parser.value_int() + 1) - 1; // Set the mask by E index
       ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
-      extruder_duplication_enabled = ena && (duplication_e_mask >= 3);
+      set_duplication_enabled(ena && (duplication_e_mask >= 3));
     }
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_DUPLICATION_MODE);
     serialprint_onoff(extruder_duplication_enabled);
     if (ena) {
       SERIAL_ECHOPGM(" ( ");
       HOTEND_LOOP() if (TEST(duplication_e_mask, e)) { SERIAL_ECHO(e); SERIAL_CHAR(' '); }
       SERIAL_CHAR(')');
     }
     SERIAL_EOL();

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 7740c013f5..5dc36428b5 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if HAS_DUPLICATION_MODE
 
 //#define DEBUG_DXC_MODE
 
 #include "../gcode.h"

commit b40440cf3846bca4a0a10bb43d6d60f725a26cfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 17:58:37 2020 -0500

    Tool-change debug option

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index ab5efbbb48..7740c013f5 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -85,22 +85,24 @@
           x_jog += .1;
         }
         return;
       }
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
-          if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+          // Set the X offset, but no less than the safety gap
+          if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), (X2_MIN_POS) - (X1_MIN_POS));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
+          // Always switch back to tool 0
           if (active_extruder != 0) tool_change(0);
           break;
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
       active_extruder_parked = false;
       extruder_duplication_enabled = false;
       stepper.set_directions();
       delayed_move_time = 0;

commit c4db8e49a7429a696431c0d3419b545d13eead31
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 10:36:15 2020 -0600

    XYZ_CHAR macro

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 99bab4ddc9..ab5efbbb48 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -131,21 +131,21 @@
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPAIR_P(SP_T_STR, int(e));
-          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", int(e), "].", axis_codes[a] | 0x20, "=", hotend_offset[e][a]);
+          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", int(e), "].", XYZ_CHAR(a) | 0x20, "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index e45dedf27b..99bab4ddc9 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -160,21 +160,21 @@
   void GcodeSuite::M605() {
     bool ena = false;
     if (parser.seen("EPS")) {
       planner.synchronize();
       if (parser.seenval('P')) duplication_e_mask = parser.value_int();   // Set the mask directly
       else if (parser.seenval('E')) duplication_e_mask = pow(2, parser.value_int() + 1) - 1; // Set the mask by E index
       ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
       extruder_duplication_enabled = ena && (duplication_e_mask >= 3);
     }
     SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_DUPLICATION_MODE);
+    SERIAL_ECHOPGM(STR_DUPLICATION_MODE);
     serialprint_onoff(extruder_duplication_enabled);
     if (ena) {
       SERIAL_ECHOPGM(" ( ");
       HOTEND_LOOP() if (TEST(duplication_e_mask, e)) { SERIAL_ECHO(e); SERIAL_CHAR(' '); }
       SERIAL_CHAR(')');
     }
     SERIAL_EOL();
   }
 
 #endif // MULTI_NOZZLE_DUPLICATION

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 95d72b65d7..e45dedf27b 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 0e72c315a0be49e98758d9744ac0117b0904b7e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 17:05:42 2020 -0600

    Minor string storage optimization

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 007c6fc6b8..95d72b65d7 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -130,21 +130,21 @@
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
         DEBUG_EOL();
 
         HOTEND_LOOP() {
-          DEBUG_ECHOPAIR(" T", int(e));
+          DEBUG_ECHOPAIR_P(SP_T_STR, int(e));
           LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", int(e), "].", axis_codes[a] | 0x20, "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 84a75686a4..007c6fc6b8 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -72,23 +72,23 @@
 
       if (dual_x_carriage_mode == DXC_MIRRORED_MODE) {
         if (previous_mode != DXC_DUPLICATION_MODE) {
           SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
           SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           return;
         }
         mirrored_duplication_mode = true;
         stepper.set_directions();
-        float x_jog = current_position[X_AXIS] - .1;
+        float x_jog = current_position.x - .1;
         for (uint8_t i = 2; --i;) {
-          planner.buffer_line(x_jog, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, 0);
+          planner.buffer_line(x_jog, current_position.y, current_position.z, current_position.e, feedrate_mm_s, 0);
           x_jog += .1;
         }
         return;
       }
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
@@ -115,37 +115,37 @@
         DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
           case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
           case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
           case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
         DEBUG_ECHOPAIR("\nActive Ext: ", int(active_extruder));
         if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
         DEBUG_ECHOPGM(" parked.");
-        DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
+        DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position.x);
         DEBUG_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
         DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
         DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
         DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPAIR(" T", int(e));
-          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", axis_codes[a], "_AXIS][", int(e), "]=", hotend_offset[a][e]);
+          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", int(e), "].", axis_codes[a] | 0x20, "=", hotend_offset[e][a]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 4009a23706..84a75686a4 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -130,22 +130,22 @@
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
         DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
         DEBUG_EOL();
 
         HOTEND_LOOP() {
-          DEBUG_ECHOPAIR(" nozzle:", int(e));
-          LOOP_XYZ(j) DEBUG_ECHOPAIR("  hotend_offset[", axis_codes[j], "_AXIS][", int(e), "]=", hotend_offset[j][e]);
+          DEBUG_ECHOPAIR(" T", int(e));
+          LOOP_XYZ(a) DEBUG_ECHOPAIR("  hotend_offset[", axis_codes[a], "_AXIS][", int(e), "]=", hotend_offset[a][e]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 97e3406cfa..4009a23706 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -85,21 +85,21 @@
           x_jog += .1;
         }
         return;
       }
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
-          if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+          if (parser.seen('X')) duplicate_extruder_x_offset = _MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           if (active_extruder != 0) tool_change(0);
           break;
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
       active_extruder_parked = false;
       extruder_duplication_enabled = false;
       stepper.set_directions();

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index f44a4c7a64..97e3406cfa 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit bc2ff9b41f4372f463f473a2101c4fd687437207
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 12 20:01:08 2019 -0500

    Fix M605 bugs
    
    Fixes #14191

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 5829e2372c..f44a4c7a64 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -151,25 +151,26 @@
   /**
    * M605: Set multi-nozzle duplication mode
    *
    *  S2       - Enable duplication mode
    *  P[mask]  - Bit-mask of nozzles to include in the duplication set.
    *             A value of 0 disables duplication.
    *  E[index] - Last nozzle index to include in the duplication set.
    *             A value of 0 disables duplication.
    */
   void GcodeSuite::M605() {
+    bool ena = false;
     if (parser.seen("EPS")) {
       planner.synchronize();
       if (parser.seenval('P')) duplication_e_mask = parser.value_int();   // Set the mask directly
-      else if (parser.seenval('E')) duplication_e_mask = pow(2, e + 1) - 1;    // Set the mask by E index
-      const bool ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
+      else if (parser.seenval('E')) duplication_e_mask = pow(2, parser.value_int() + 1) - 1; // Set the mask by E index
+      ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
       extruder_duplication_enabled = ena && (duplication_e_mask >= 3);
     }
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_DUPLICATION_MODE);
     serialprint_onoff(extruder_duplication_enabled);
     if (ena) {
       SERIAL_ECHOPGM(" ( ");
       HOTEND_LOOP() if (TEST(duplication_e_mask, e)) { SERIAL_ECHO(e); SERIAL_CHAR(' '); }
       SERIAL_CHAR(')');
     }

commit 32afe1d1021d14300b90c4eb1e212625a0df15f7
Author: Minims <github@minims.fr>
Date:   Tue May 28 02:51:29 2019 +0200

    Fix TOOLCHANGE_ZRAISE warning (#14156)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index f1f64f0ce3..5829e2372c 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -125,21 +125,21 @@
         DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
         DEBUG_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
         DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
         DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
         DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
         DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
         DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
         DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
         DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
         DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
-        DEBUG_ECHOPAIR("\nTOOLCHANGE_ZRAISE=", float(TOOLCHANGE_ZRAISE));
+        DEBUG_ECHOPAIR("\toolchange_settings.z_raise=", toolchange_settings.z_raise);
         DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
         DEBUG_EOL();
 
         HOTEND_LOOP() {
           DEBUG_ECHOPAIR(" nozzle:", int(e));
           LOOP_XYZ(j) DEBUG_ECHOPAIR("  hotend_offset[", axis_codes[j], "_AXIS][", int(e), "]=", hotend_offset[j][e]);
           DEBUG_EOL();
         }
         DEBUG_EOL();
       }

commit cacec5764aee0d1fb5b439d550287970e19f1686
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 3 20:21:06 2019 -0500

    Clean up whitespace

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 5894e66da7..f1f64f0ce3 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -35,24 +35,24 @@
 #define DEBUG_OUT ENABLED(DEBUG_DXC_MODE)
 #include "../../core/debug_out.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode
    *
    *   M605 S0 : (FULL_CONTROL) The slicer has full control over both X-carriages and can achieve optimal travel
    *             results as long as it supports dual X-carriages.
-   * 
+   *
    *   M605 S1 : (AUTO_PARK) The firmware automatically parks and unparks the X-carriages on tool-change so that
    *             additional slicer support is not required.
-   * 
+   *
    *   M605 S2 X R : (DUPLICATION) The firmware moves the second X-carriage and extruder in synchronization with
    *             the first X-carriage and extruder, to print 2 copies of the same object at the same time.
    *             Set the constant X-offset and temperature differential with M605 S2 X[offs] R[deg] and
    *             follow with "M605 S2" to initiate duplicated movement. For example, use "M605 S2 X100 R2" to
    *             make a copy 100mm to the right with E1 2¬∞ hotter than E0.
    *
    *   M605 S3 : (MIRRORED) Formbot/Vivedino-inspired mirrored mode in which the second extruder duplicates
    *             the movement of the first except the second extruder is reversed in the X axis.
    *             The temperature differential and initial X offset must be set with "M605 S2 X[offs] R[deg]",
    *             then followed by "M605 S3" to initiate mirrored movement.

commit 09eb30dc05a727e3816ab5a407f02ada18700e23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Mar 15 23:46:27 2019 -0400

    IDEX Mirror mode based on Formbot / Vivedino Symmetric mode (#13404)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index a7eff37fc7..5894e66da7 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -25,68 +25,74 @@
 #if HAS_DUPLICATION_MODE
 
 //#define DEBUG_DXC_MODE
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/tool_change.h"
 #include "../../module/planner.h"
 
+#define DEBUG_OUT ENABLED(DEBUG_DXC_MODE)
+#include "../../core/debug_out.h"
+
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode
    *
-   *    M605    : Restore user specified DEFAULT_DUAL_X_CARRIAGE_MODE
-   *    M605 S0 : Full control mode. The slicer has full control over x-carriage movement
-   *    M605 S1 : Auto-park mode. The inactive head will auto park/unpark without slicer involvement
-   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
-   *                         units x-offset and an optional differential hotend temperature of
-   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
-   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
-   *    M605 S3 : Enable Scaled Duplication mode.  The second extruder will duplicate the first extruder's
-   *              movement similar to the M605 S2 mode.   However, the second extruder will be producing
-   *              a scaled image of the first extruder.  The initial x-offset and temperature differential are
-   *              set with M605 S2 [Xnnn] [Rmmm] and then followed with a M605 S3 to start the mirrored movement.
+   *   M605 S0 : (FULL_CONTROL) The slicer has full control over both X-carriages and can achieve optimal travel
+   *             results as long as it supports dual X-carriages.
+   * 
+   *   M605 S1 : (AUTO_PARK) The firmware automatically parks and unparks the X-carriages on tool-change so that
+   *             additional slicer support is not required.
+   * 
+   *   M605 S2 X R : (DUPLICATION) The firmware moves the second X-carriage and extruder in synchronization with
+   *             the first X-carriage and extruder, to print 2 copies of the same object at the same time.
+   *             Set the constant X-offset and temperature differential with M605 S2 X[offs] R[deg] and
+   *             follow with "M605 S2" to initiate duplicated movement. For example, use "M605 S2 X100 R2" to
+   *             make a copy 100mm to the right with E1 2¬∞ hotter than E0.
+   *
+   *   M605 S3 : (MIRRORED) Formbot/Vivedino-inspired mirrored mode in which the second extruder duplicates
+   *             the movement of the first except the second extruder is reversed in the X axis.
+   *             The temperature differential and initial X offset must be set with "M605 S2 X[offs] R[deg]",
+   *             then followed by "M605 S3" to initiate mirrored movement.
+   *
    *    M605 W  : IDEX What? command.
    *
-   *    Note: the X axis should be homed after changing dual x-carriage mode.
+   *    Note: the X axis should be homed after changing Dual X-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
     if (parser.seen('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
+      mirrored_duplication_mode = false;
 
-      #if 0
-      scaled_duplication_mode = false;
-
-      if (dual_x_carriage_mode == DXC_SCALED_DUPLICATION_MODE) {
+      if (dual_x_carriage_mode == DXC_MIRRORED_MODE) {
         if (previous_mode != DXC_DUPLICATION_MODE) {
           SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
-          SERIAL_ECHOLNPGM("specifying DXC_SCALED_DUPLICATION_MODE.");
+          SERIAL_ECHOLNPGM("specifying DXC_MIRRORED_MODE.");
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           return;
         }
-        scaled_duplication_mode = true;
+        mirrored_duplication_mode = true;
         stepper.set_directions();
         float x_jog = current_position[X_AXIS] - .1;
         for (uint8_t i = 2; --i;) {
           planner.buffer_line(x_jog, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, 0);
           x_jog += .1;
         }
         return;
       }
-      #endif
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
           if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           if (active_extruder != 0) tool_change(0);
           break;
@@ -98,61 +104,51 @@
       extruder_duplication_enabled = false;
       stepper.set_directions();
       delayed_move_time = 0;
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
     #ifdef DEBUG_DXC_MODE
 
       if (parser.seen('W')) {
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPGM("IDEX mode: ");
+        DEBUG_ECHO_START();
+        DEBUG_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
-          case DXC_FULL_CONTROL_MODE:       SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE");       break;
-          case DXC_AUTO_PARK_MODE:          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");          break;
-          case DXC_DUPLICATION_MODE:        SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");        break;
-          case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOPGM("DXC_SCALED_DUPLICATION_MODE"); break;
+          case DXC_FULL_CONTROL_MODE: DEBUG_ECHOPGM("FULL_CONTROL"); break;
+          case DXC_AUTO_PARK_MODE:    DEBUG_ECHOPGM("AUTO_PARK");    break;
+          case DXC_DUPLICATION_MODE:  DEBUG_ECHOPGM("DUPLICATION");  break;
+          case DXC_MIRRORED_MODE:     DEBUG_ECHOPGM("MIRRORED");     break;
         }
-        SERIAL_ECHOPAIR("\nActive Ext: ", int(active_extruder));
-        if (!active_extruder_parked) SERIAL_ECHOPGM(" NOT ");
-        SERIAL_ECHOPGM(" parked.");
-        SERIAL_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
-        SERIAL_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
-        SERIAL_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
-        SERIAL_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
-        SERIAL_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
-        SERIAL_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
-        SERIAL_ECHOPAIR("\nX1 Home X: ", x_home_pos(0));
-        SERIAL_ECHOPAIR("\nX1_MIN_POS=", int(X1_MIN_POS));
-        SERIAL_ECHOPAIR("\nX1_MAX_POS=", int(X1_MAX_POS));
-        SERIAL_ECHOPAIR("\nX2 Home X: ", x_home_pos(1));
-        SERIAL_ECHOPAIR("\nX2_MIN_POS=", int(X2_MIN_POS));
-        SERIAL_ECHOPAIR("\nX2_MAX_POS=", int(X2_MAX_POS));
-        SERIAL_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR));
-        SERIAL_ECHOPAIR("\nX2_HOME_POS=", int(X2_HOME_POS));
-        SERIAL_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
-        SERIAL_ECHOPAIR("\nTOOLCHANGE_ZRAISE=", float(TOOLCHANGE_ZRAISE));
-        SERIAL_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
-        SERIAL_EOL();
-
-        for (uint8_t i = 0; i < 2; i++) {
-          SERIAL_ECHOPAIR(" nozzle:", int(i));
-          LOOP_XYZ(j) {
-            SERIAL_ECHOPGM("    hotend_offset[");
-            SERIAL_CHAR(axis_codes[j]);
-            SERIAL_ECHOPAIR("_AXIS][", int(i));
-            SERIAL_ECHOPAIR("]=", hotend_offset[j][i]);
-          }
-          SERIAL_EOL();
+        DEBUG_ECHOPAIR("\nActive Ext: ", int(active_extruder));
+        if (!active_extruder_parked) DEBUG_ECHOPGM(" NOT ");
+        DEBUG_ECHOPGM(" parked.");
+        DEBUG_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
+        DEBUG_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
+        DEBUG_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
+        DEBUG_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
+        DEBUG_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
+        DEBUG_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
+        DEBUG_ECHOPAIR("\nX1 Home X: ", x_home_pos(0), "\nX1_MIN_POS=", int(X1_MIN_POS), "\nX1_MAX_POS=", int(X1_MAX_POS));
+        DEBUG_ECHOPAIR("\nX2 Home X: ", x_home_pos(1), "\nX2_MIN_POS=", int(X2_MIN_POS), "\nX2_MAX_POS=", int(X2_MAX_POS));
+        DEBUG_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR), "\nX2_HOME_POS=", int(X2_HOME_POS));
+        DEBUG_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
+        DEBUG_ECHOPAIR("\nTOOLCHANGE_ZRAISE=", float(TOOLCHANGE_ZRAISE));
+        DEBUG_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
+        DEBUG_EOL();
+
+        HOTEND_LOOP() {
+          DEBUG_ECHOPAIR(" nozzle:", int(e));
+          LOOP_XYZ(j) DEBUG_ECHOPAIR("  hotend_offset[", axis_codes[j], "_AXIS][", int(e), "]=", hotend_offset[j][e]);
+          DEBUG_EOL();
         }
-        SERIAL_EOL();
+        DEBUG_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   /**
    * M605: Set multi-nozzle duplication mode
    *
    *  S2       - Enable duplication mode

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index ce61f80a7d..a7eff37fc7 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -15,75 +15,78 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
-#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+#if HAS_DUPLICATION_MODE
 
 //#define DEBUG_DXC_MODE
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/tool_change.h"
 #include "../../module/planner.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode
    *
    *    M605    : Restore user specified DEFAULT_DUAL_X_CARRIAGE_MODE
-   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
-   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
+   *    M605 S0 : Full control mode. The slicer has full control over x-carriage movement
+   *    M605 S1 : Auto-park mode. The inactive head will auto park/unpark without slicer involvement
    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
    *                         units x-offset and an optional differential hotend temperature of
    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
    *    M605 S3 : Enable Scaled Duplication mode.  The second extruder will duplicate the first extruder's
    *              movement similar to the M605 S2 mode.   However, the second extruder will be producing
    *              a scaled image of the first extruder.  The initial x-offset and temperature differential are
    *              set with M605 S2 [Xnnn] [Rmmm] and then followed with a M605 S3 to start the mirrored movement.
    *    M605 W  : IDEX What? command.
    *
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
     if (parser.seen('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
+
+      #if 0
       scaled_duplication_mode = false;
 
       if (dual_x_carriage_mode == DXC_SCALED_DUPLICATION_MODE) {
         if (previous_mode != DXC_DUPLICATION_MODE) {
           SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
           SERIAL_ECHOLNPGM("specifying DXC_SCALED_DUPLICATION_MODE.");
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           return;
         }
         scaled_duplication_mode = true;
         stepper.set_directions();
         float x_jog = current_position[X_AXIS] - .1;
         for (uint8_t i = 2; --i;) {
           planner.buffer_line(x_jog, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, 0);
           x_jog += .1;
         }
         return;
       }
+      #endif
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
           if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           if (active_extruder != 0) tool_change(0);
           break;
@@ -140,23 +143,43 @@
             SERIAL_ECHOPAIR("_AXIS][", int(i));
             SERIAL_ECHOPAIR("]=", hotend_offset[j][i]);
           }
           SERIAL_EOL();
         }
         SERIAL_EOL();
       }
     #endif // DEBUG_DXC_MODE
   }
 
-#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+#elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
+  /**
+   * M605: Set multi-nozzle duplication mode
+   *
+   *  S2       - Enable duplication mode
+   *  P[mask]  - Bit-mask of nozzles to include in the duplication set.
+   *             A value of 0 disables duplication.
+   *  E[index] - Last nozzle index to include in the duplication set.
+   *             A value of 0 disables duplication.
+   */
   void GcodeSuite::M605() {
-    planner.synchronize();
-    extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
+    if (parser.seen("EPS")) {
+      planner.synchronize();
+      if (parser.seenval('P')) duplication_e_mask = parser.value_int();   // Set the mask directly
+      else if (parser.seenval('E')) duplication_e_mask = pow(2, e + 1) - 1;    // Set the mask by E index
+      const bool ena = (2 == parser.intval('S', extruder_duplication_enabled ? 2 : 0));
+      extruder_duplication_enabled = ena && (duplication_e_mask >= 3);
+    }
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_DUPLICATION_MODE);
-    serialprintln_onoff(extruder_duplication_enabled);
+    serialprint_onoff(extruder_duplication_enabled);
+    if (ena) {
+      SERIAL_ECHOPGM(" ( ");
+      HOTEND_LOOP() if (TEST(duplication_e_mask, e)) { SERIAL_ECHO(e); SERIAL_CHAR(' '); }
+      SERIAL_CHAR(')');
+    }
+    SERIAL_EOL();
   }
 
-#endif // DUAL_NOZZLE_DUPLICATION_MODE
+#endif // MULTI_NOZZLE_DUPLICATION
 
-#endif // DUAL_X_CARRIAGE || DUAL_NOZZLE_DUPLICATION_MODE
+#endif // HAS_DUPICATION_MODE

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 2c6d53e31c..ce61f80a7d 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index bcd0cf7b76..2c6d53e31c 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -56,22 +56,22 @@
     planner.synchronize();
 
     if (parser.seen('S')) {
       const DualXMode previous_mode = dual_x_carriage_mode;
 
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
       scaled_duplication_mode = false;
 
       if (dual_x_carriage_mode == DXC_SCALED_DUPLICATION_MODE) {
         if (previous_mode != DXC_DUPLICATION_MODE) {
-          SERIAL_ECHOPGM("Printer must be in DXC_DUPLICATION_MODE prior to \n");
-          SERIAL_ECHOPGM("specifying DXC_SCALED_DUPLICATION_MODE.\n");
+          SERIAL_ECHOLNPGM("Printer must be in DXC_DUPLICATION_MODE prior to ");
+          SERIAL_ECHOLNPGM("specifying DXC_SCALED_DUPLICATION_MODE.");
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           return;
         }
         scaled_duplication_mode = true;
         stepper.set_directions();
         float x_jog = current_position[X_AXIS] - .1;
         for (uint8_t i = 2; --i;) {
           planner.buffer_line(x_jog, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, 0);
           x_jog += .1;
         }

commit 50af1d1e0874c787fcafc9cf71c6a8ef55b20643
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 12 17:04:00 2018 -0600

    Differentiate translated On/Off from Serial ON/OFF

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 3530881f50..bcd0cf7b76 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -146,16 +146,17 @@
       }
     #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
     planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
+    SERIAL_ECHOPGM(MSG_DUPLICATION_MODE);
+    serialprintln_onoff(extruder_duplication_enabled);
   }
 
 #endif // DUAL_NOZZLE_DUPLICATION_MODE
 
 #endif // DUAL_X_CARRIAGE || DUAL_NOZZLE_DUPLICATION_MODE

commit 3ec38727305862c881f268e2fc27f8188b5bc767
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 17 12:11:41 2018 -0400

    Single Z raise value for all tool-changing / parking (#12090)
    
    * Universal tool-change Z lift
    * Add TOOLCHANGE_ZRAISE to example configs
    * Park/unpark changes to example configs
    * Implement DEBUG_DXC_MODE

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 780a7f57b5..3530881f50 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -15,24 +15,24 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
-#define DEBUG_DXC_MODE
-
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
+//#define DEBUG_DXC_MODE
+
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/tool_change.h"
 #include "../../module/planner.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode
@@ -92,64 +92,66 @@
           break;
       }
       active_extruder_parked = false;
       extruder_duplication_enabled = false;
       stepper.set_directions();
       delayed_move_time = 0;
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
-    if (parser.seen('W')) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("IDEX mode: ");
-      switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE:       SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE");       break;
-        case DXC_AUTO_PARK_MODE:          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");          break;
-        case DXC_DUPLICATION_MODE:        SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");        break;
-        case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOPGM("DXC_SCALED_DUPLICATION_MODE"); break;
-      }
-      SERIAL_ECHOPAIR("\nActive Ext: ", int(active_extruder));
-      if (!active_extruder_parked) SERIAL_ECHOPGM(" NOT ");
-      SERIAL_ECHOPGM(" parked.");
-      SERIAL_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
-      SERIAL_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
-      SERIAL_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
-      SERIAL_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
-      SERIAL_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
-      SERIAL_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
-      SERIAL_ECHOPAIR("\nX1 Home X: ", x_home_pos(0));
-      SERIAL_ECHOPAIR("\nX1_MIN_POS=", int(X1_MIN_POS));
-      SERIAL_ECHOPAIR("\nX1_MAX_POS=", int(X1_MAX_POS));
-      SERIAL_ECHOPAIR("\nX2 Home X: ", x_home_pos(1));
-      SERIAL_ECHOPAIR("\nX2_MIN_POS=", int(X2_MIN_POS));
-      SERIAL_ECHOPAIR("\nX2_MAX_POS=", int(X2_MAX_POS));
-      SERIAL_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR));
-      SERIAL_ECHOPAIR("\nX2_HOME_POS=", int(X2_HOME_POS));
-      SERIAL_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
-      SERIAL_ECHOPAIR("\nTOOLCHANGE_PARK_ZLIFT=", float(TOOLCHANGE_PARK_ZLIFT));
-      SERIAL_ECHOPAIR("\nTOOLCHANGE_UNPARK_ZLIFT=", float(TOOLCHANGE_UNPARK_ZLIFT));
-      SERIAL_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
-
-      SERIAL_EOL();
-      for (uint8_t i = 0; i < 2; i++) {
-        SERIAL_ECHOPAIR(" nozzle:", int(i));
-        LOOP_XYZ(j) {
-          SERIAL_ECHOPGM("    hotend_offset[");
-          SERIAL_CHAR(axis_codes[j]);
-          SERIAL_ECHOPAIR("_AXIS][", int(i));
-          SERIAL_ECHOPAIR("]=", hotend_offset[j][i]);
+    #ifdef DEBUG_DXC_MODE
+
+      if (parser.seen('W')) {
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPGM("IDEX mode: ");
+        switch (dual_x_carriage_mode) {
+          case DXC_FULL_CONTROL_MODE:       SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE");       break;
+          case DXC_AUTO_PARK_MODE:          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");          break;
+          case DXC_DUPLICATION_MODE:        SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");        break;
+          case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOPGM("DXC_SCALED_DUPLICATION_MODE"); break;
+        }
+        SERIAL_ECHOPAIR("\nActive Ext: ", int(active_extruder));
+        if (!active_extruder_parked) SERIAL_ECHOPGM(" NOT ");
+        SERIAL_ECHOPGM(" parked.");
+        SERIAL_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
+        SERIAL_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
+        SERIAL_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
+        SERIAL_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
+        SERIAL_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
+        SERIAL_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
+        SERIAL_ECHOPAIR("\nX1 Home X: ", x_home_pos(0));
+        SERIAL_ECHOPAIR("\nX1_MIN_POS=", int(X1_MIN_POS));
+        SERIAL_ECHOPAIR("\nX1_MAX_POS=", int(X1_MAX_POS));
+        SERIAL_ECHOPAIR("\nX2 Home X: ", x_home_pos(1));
+        SERIAL_ECHOPAIR("\nX2_MIN_POS=", int(X2_MIN_POS));
+        SERIAL_ECHOPAIR("\nX2_MAX_POS=", int(X2_MAX_POS));
+        SERIAL_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR));
+        SERIAL_ECHOPAIR("\nX2_HOME_POS=", int(X2_HOME_POS));
+        SERIAL_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
+        SERIAL_ECHOPAIR("\nTOOLCHANGE_ZRAISE=", float(TOOLCHANGE_ZRAISE));
+        SERIAL_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
+        SERIAL_EOL();
+
+        for (uint8_t i = 0; i < 2; i++) {
+          SERIAL_ECHOPAIR(" nozzle:", int(i));
+          LOOP_XYZ(j) {
+            SERIAL_ECHOPGM("    hotend_offset[");
+            SERIAL_CHAR(axis_codes[j]);
+            SERIAL_ECHOPAIR("_AXIS][", int(i));
+            SERIAL_ECHOPAIR("]=", hotend_offset[j][i]);
+          }
+          SERIAL_EOL();
         }
         SERIAL_EOL();
       }
-      SERIAL_EOL();
-    }
+    #endif // DEBUG_DXC_MODE
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
     planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
   }

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 80b39ef301..780a7f57b5 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -37,73 +37,118 @@
   /**
    * M605: Set dual x-carriage movement mode
    *
    *    M605    : Restore user specified DEFAULT_DUAL_X_CARRIAGE_MODE
    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
    *                         units x-offset and an optional differential hotend temperature of
    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
-   *    M605 S3 : Enable Symmetric Duplication mode.  The second extruder will duplicate the first extruder's
+   *    M605 S3 : Enable Scaled Duplication mode.  The second extruder will duplicate the first extruder's
    *              movement similar to the M605 S2 mode.   However, the second extruder will be producing
-   *              a mirror image of the first extruder.  The initial x-offset and temperature differential are
+   *              a scaled image of the first extruder.  The initial x-offset and temperature differential are
    *              set with M605 S2 [Xnnn] [Rmmm] and then followed with a M605 S3 to start the mirrored movement.
    *    M605 W  : IDEX What? command.
    *
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
     if (parser.seen('S')) {
+      const DualXMode previous_mode = dual_x_carriage_mode;
+
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
+      scaled_duplication_mode = false;
+
+      if (dual_x_carriage_mode == DXC_SCALED_DUPLICATION_MODE) {
+        if (previous_mode != DXC_DUPLICATION_MODE) {
+          SERIAL_ECHOPGM("Printer must be in DXC_DUPLICATION_MODE prior to \n");
+          SERIAL_ECHOPGM("specifying DXC_SCALED_DUPLICATION_MODE.\n");
+          dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+          return;
+        }
+        scaled_duplication_mode = true;
+        stepper.set_directions();
+        float x_jog = current_position[X_AXIS] - .1;
+        for (uint8_t i = 2; --i;) {
+          planner.buffer_line(x_jog, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, 0);
+          x_jog += .1;
+        }
+        return;
+      }
 
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
         case DXC_AUTO_PARK_MODE:
           break;
         case DXC_DUPLICATION_MODE:
           if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
           if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
           if (active_extruder != 0) tool_change(0);
           break;
         default:
           dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
       active_extruder_parked = false;
       extruder_duplication_enabled = false;
+      stepper.set_directions();
       delayed_move_time = 0;
     }
     else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
       dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
     if (parser.seen('W')) {
       SERIAL_ECHO_START();
       SERIAL_ECHOPGM("IDEX mode: ");
       switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE: SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE"); break;
-        case DXC_AUTO_PARK_MODE:    SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");    break;
-        case DXC_DUPLICATION_MODE:  SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");  break;
+        case DXC_FULL_CONTROL_MODE:       SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE");       break;
+        case DXC_AUTO_PARK_MODE:          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");          break;
+        case DXC_DUPLICATION_MODE:        SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");        break;
+        case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOPGM("DXC_SCALED_DUPLICATION_MODE"); break;
       }
       SERIAL_ECHOPAIR("\nActive Ext: ", int(active_extruder));
       if (!active_extruder_parked) SERIAL_ECHOPGM(" NOT ");
-      SERIAL_ECHOLNPGM(" parked.");
-      SERIAL_ECHOPAIR("active_extruder_x_pos: ", current_position[X_AXIS]);
-      SERIAL_ECHOPAIR("   inactive_extruder_x_pos: ", inactive_extruder_x_pos);
-      SERIAL_ECHOPAIR("\nT0 Home X: ", x_home_pos(0));
-      SERIAL_ECHOPAIR("\nT1 Home X: ", x_home_pos(1));
+      SERIAL_ECHOPGM(" parked.");
+      SERIAL_ECHOPAIR("\nactive_extruder_x_pos: ", current_position[X_AXIS]);
+      SERIAL_ECHOPAIR("\ninactive_extruder_x_pos: ", inactive_extruder_x_pos);
       SERIAL_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
       SERIAL_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
       SERIAL_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
       SERIAL_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
+      SERIAL_ECHOPAIR("\nX1 Home X: ", x_home_pos(0));
+      SERIAL_ECHOPAIR("\nX1_MIN_POS=", int(X1_MIN_POS));
+      SERIAL_ECHOPAIR("\nX1_MAX_POS=", int(X1_MAX_POS));
+      SERIAL_ECHOPAIR("\nX2 Home X: ", x_home_pos(1));
+      SERIAL_ECHOPAIR("\nX2_MIN_POS=", int(X2_MIN_POS));
+      SERIAL_ECHOPAIR("\nX2_MAX_POS=", int(X2_MAX_POS));
+      SERIAL_ECHOPAIR("\nX2_HOME_DIR=", int(X2_HOME_DIR));
+      SERIAL_ECHOPAIR("\nX2_HOME_POS=", int(X2_HOME_POS));
+      SERIAL_ECHOPAIR("\nDEFAULT_DUAL_X_CARRIAGE_MODE=", STRINGIFY(DEFAULT_DUAL_X_CARRIAGE_MODE));
+      SERIAL_ECHOPAIR("\nTOOLCHANGE_PARK_ZLIFT=", float(TOOLCHANGE_PARK_ZLIFT));
+      SERIAL_ECHOPAIR("\nTOOLCHANGE_UNPARK_ZLIFT=", float(TOOLCHANGE_UNPARK_ZLIFT));
+      SERIAL_ECHOPAIR("\nDEFAULT_DUPLICATION_X_OFFSET=", int(DEFAULT_DUPLICATION_X_OFFSET));
+
+      SERIAL_EOL();
+      for (uint8_t i = 0; i < 2; i++) {
+        SERIAL_ECHOPAIR(" nozzle:", int(i));
+        LOOP_XYZ(j) {
+          SERIAL_ECHOPGM("    hotend_offset[");
+          SERIAL_CHAR(axis_codes[j]);
+          SERIAL_ECHOPAIR("_AXIS][", int(i));
+          SERIAL_ECHOPAIR("]=", hotend_offset[j][i]);
+        }
+        SERIAL_EOL();
+      }
+      SERIAL_EOL();
     }
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
     planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 0088a3ce9f..80b39ef301 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -15,20 +15,22 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
+#define DEBUG_DXC_MODE
+
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
 #include "../../module/tool_change.h"
 #include "../../module/planner.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
@@ -46,89 +48,62 @@
    *              movement similar to the M605 S2 mode.   However, the second extruder will be producing
    *              a mirror image of the first extruder.  The initial x-offset and temperature differential are
    *              set with M605 S2 [Xnnn] [Rmmm] and then followed with a M605 S3 to start the mirrored movement.
    *    M605 W  : IDEX What? command.
    *
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
 
-    if (parser.seen('S')) { 
-      DualXMode  previous_mode, requested_mode = (DualXMode)parser.value_byte();
-      previous_mode = dual_x_carriage_mode;
+    if (parser.seen('S')) {
       dual_x_carriage_mode = (DualXMode)parser.value_byte();
 
-    switch (dual_x_carriage_mode) {
-      case DXC_FULL_CONTROL_MODE:
-      case DXC_AUTO_PARK_MODE:
-        break;
-      case DXC_DUPLICATION_MODE:
-        if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
-        if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
-          if (active_extruder != 0) tool_change(0);
-        break;
-      default:
-        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
-        break;
-    }
-    active_extruder_parked = false;
-    extruder_duplication_enabled = false;
-    delayed_move_time = 0;
-    } else
-      if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default 
-        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
-
-    if (parser.seen('W')) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("IDEX mode: ");
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE:
-          SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE\n");
-          break;
         case DXC_AUTO_PARK_MODE:
-          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE\n");
           break;
         case DXC_DUPLICATION_MODE:
-          SERIAL_ECHOPGM("DXC_DUPLICATION_MODE\n");
+          if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+          if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
+          if (active_extruder != 0) tool_change(0);
+          break;
+        default:
+          dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
           break;
       }
-      SERIAL_ECHOPGM("Active Ext: ");
-      SERIAL_ECHO((int) active_extruder);
-
-      if (active_extruder_parked == false)
-        SERIAL_ECHOPGM(" NOT ");
-      SERIAL_ECHOPGM(" parked.\n");
-
-      SERIAL_ECHOPGM("active_extruder_x_pos: ");
-      SERIAL_ECHO( current_position[X_AXIS]);
-
-      SERIAL_ECHOPGM("   inactive_extruder_x_pos: ");
-      SERIAL_ECHO( inactive_extruder_x_pos);
-
-      SERIAL_ECHOPGM("\n1st extruder x_home_pos(): ");
-      SERIAL_ECHO(x_home_pos(0));
-      SERIAL_ECHOPGM("\n2nd extruder x_home_pos(): ");
-      SERIAL_ECHO(x_home_pos(1));
-
-      SERIAL_ECHOPGM("\nextruder_duplication_enabled: ");
-      SERIAL_ECHO(extruder_duplication_enabled);
-
-      SERIAL_ECHOPGM("\nduplicate_extruder_x_offset: ");
-      SERIAL_ECHO(duplicate_extruder_x_offset);
-
-      SERIAL_ECHOPGM("\nduplicate_extruder_temp_offset: ");
-      SERIAL_ECHO(duplicate_extruder_temp_offset);
+      active_extruder_parked = false;
+      extruder_duplication_enabled = false;
+      delayed_move_time = 0;
+    }
+    else if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default
+      dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
 
-      SERIAL_ECHOPGM("\ndelayed_move_time: ");
-      SERIAL_ECHO(delayed_move_time);
-      SERIAL_ECHOPGM("\n"); 
+    if (parser.seen('W')) {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM("IDEX mode: ");
+      switch (dual_x_carriage_mode) {
+        case DXC_FULL_CONTROL_MODE: SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE"); break;
+        case DXC_AUTO_PARK_MODE:    SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE");    break;
+        case DXC_DUPLICATION_MODE:  SERIAL_ECHOPGM("DXC_DUPLICATION_MODE");  break;
+      }
+      SERIAL_ECHOPAIR("\nActive Ext: ", int(active_extruder));
+      if (!active_extruder_parked) SERIAL_ECHOPGM(" NOT ");
+      SERIAL_ECHOLNPGM(" parked.");
+      SERIAL_ECHOPAIR("active_extruder_x_pos: ", current_position[X_AXIS]);
+      SERIAL_ECHOPAIR("   inactive_extruder_x_pos: ", inactive_extruder_x_pos);
+      SERIAL_ECHOPAIR("\nT0 Home X: ", x_home_pos(0));
+      SERIAL_ECHOPAIR("\nT1 Home X: ", x_home_pos(1));
+      SERIAL_ECHOPAIR("\nextruder_duplication_enabled: ", int(extruder_duplication_enabled));
+      SERIAL_ECHOPAIR("\nduplicate_extruder_x_offset: ", duplicate_extruder_x_offset);
+      SERIAL_ECHOPAIR("\nduplicate_extruder_temp_offset: ", duplicate_extruder_temp_offset);
+      SERIAL_ECHOPAIR("\ndelayed_move_time: ", delayed_move_time);
     }
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
     planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 13ab424603..0088a3ce9f 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -20,63 +20,116 @@
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/stepper.h"
+#include "../../module/tool_change.h"
+#include "../../module/planner.h"
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * M605: Set dual x-carriage movement mode
    *
+   *    M605    : Restore user specified DEFAULT_DUAL_X_CARRIAGE_MODE
    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
    *                         units x-offset and an optional differential hotend temperature of
    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
+   *    M605 S3 : Enable Symmetric Duplication mode.  The second extruder will duplicate the first extruder's
+   *              movement similar to the M605 S2 mode.   However, the second extruder will be producing
+   *              a mirror image of the first extruder.  The initial x-offset and temperature differential are
+   *              set with M605 S2 [Xnnn] [Rmmm] and then followed with a M605 S3 to start the mirrored movement.
+   *    M605 W  : IDEX What? command.
    *
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
-    if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
+
+    if (parser.seen('S')) { 
+      DualXMode  previous_mode, requested_mode = (DualXMode)parser.value_byte();
+      previous_mode = dual_x_carriage_mode;
+      dual_x_carriage_mode = (DualXMode)parser.value_byte();
+
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
       case DXC_AUTO_PARK_MODE:
         break;
       case DXC_DUPLICATION_MODE:
         if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
-        SERIAL_CHAR(' ');
-        SERIAL_ECHO(hotend_offset[X_AXIS][0]);
-        SERIAL_CHAR(',');
-        SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
-        SERIAL_CHAR(' ');
-        SERIAL_ECHO(duplicate_extruder_x_offset);
-        SERIAL_CHAR(',');
-        SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
+          if (active_extruder != 0) tool_change(0);
         break;
       default:
         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
         break;
     }
     active_extruder_parked = false;
     extruder_duplication_enabled = false;
     delayed_move_time = 0;
+    } else
+      if (!parser.seen('W'))  // if no S or W parameter, the DXC mode gets reset to the user's default 
+        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+
+    if (parser.seen('W')) {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM("IDEX mode: ");
+      switch (dual_x_carriage_mode) {
+        case DXC_FULL_CONTROL_MODE:
+          SERIAL_ECHOPGM("DXC_FULL_CONTROL_MODE\n");
+          break;
+        case DXC_AUTO_PARK_MODE:
+          SERIAL_ECHOPGM("DXC_AUTO_PARK_MODE\n");
+          break;
+        case DXC_DUPLICATION_MODE:
+          SERIAL_ECHOPGM("DXC_DUPLICATION_MODE\n");
+          break;
+      }
+      SERIAL_ECHOPGM("Active Ext: ");
+      SERIAL_ECHO((int) active_extruder);
+
+      if (active_extruder_parked == false)
+        SERIAL_ECHOPGM(" NOT ");
+      SERIAL_ECHOPGM(" parked.\n");
+
+      SERIAL_ECHOPGM("active_extruder_x_pos: ");
+      SERIAL_ECHO( current_position[X_AXIS]);
+
+      SERIAL_ECHOPGM("   inactive_extruder_x_pos: ");
+      SERIAL_ECHO( inactive_extruder_x_pos);
+
+      SERIAL_ECHOPGM("\n1st extruder x_home_pos(): ");
+      SERIAL_ECHO(x_home_pos(0));
+      SERIAL_ECHOPGM("\n2nd extruder x_home_pos(): ");
+      SERIAL_ECHO(x_home_pos(1));
+
+      SERIAL_ECHOPGM("\nextruder_duplication_enabled: ");
+      SERIAL_ECHO(extruder_duplication_enabled);
+
+      SERIAL_ECHOPGM("\nduplicate_extruder_x_offset: ");
+      SERIAL_ECHO(duplicate_extruder_x_offset);
+
+      SERIAL_ECHOPGM("\nduplicate_extruder_temp_offset: ");
+      SERIAL_ECHO(duplicate_extruder_temp_offset);
+
+      SERIAL_ECHOPGM("\ndelayed_move_time: ");
+      SERIAL_ECHO(delayed_move_time);
+      SERIAL_ECHOPGM("\n"); 
+    }
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
     planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
   }

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index e94e076e46..13ab424603 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -43,21 +43,21 @@
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
     planner.synchronize();
     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
       case DXC_AUTO_PARK_MODE:
         break;
       case DXC_DUPLICATION_MODE:
-        if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+        if (parser.seen('X')) duplicate_extruder_x_offset = MAX(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
         SERIAL_CHAR(' ');
         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
         SERIAL_CHAR(',');
         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
         SERIAL_CHAR(' ');
         SERIAL_ECHO(duplicate_extruder_x_offset);
         SERIAL_CHAR(',');

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
index 4cfa571990..e94e076e46 100644
--- a/Marlin/src/gcode/control/M605.cpp
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -36,21 +36,21 @@
    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
    *                         units x-offset and an optional differential hotend temperature of
    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
    *
    *    Note: the X axis should be homed after changing dual x-carriage mode.
    */
   void GcodeSuite::M605() {
-    stepper.synchronize();
+    planner.synchronize();
     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
       case DXC_AUTO_PARK_MODE:
         break;
       case DXC_DUPLICATION_MODE:
         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
         SERIAL_ECHO_START();
         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
@@ -68,19 +68,19 @@
         break;
     }
     active_extruder_parked = false;
     extruder_duplication_enabled = false;
     delayed_move_time = 0;
   }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   void GcodeSuite::M605() {
-    stepper.synchronize();
+    planner.synchronize();
     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
   }
 
 #endif // DUAL_NOZZLE_DUPLICATION_MODE
 
 #endif // DUAL_X_CARRIAGE || DUAL_NOZZLE_DUPLICATION_MODE

commit 1b0acbff720046cdaa7d24dcbc8dbf5d26b3c1b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 17:24:56 2017 -0500

    Move M605 to cpp

diff --git a/Marlin/src/gcode/control/M605.cpp b/Marlin/src/gcode/control/M605.cpp
new file mode 100644
index 0000000000..4cfa571990
--- /dev/null
+++ b/Marlin/src/gcode/control/M605.cpp
@@ -0,0 +1,86 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+
+#include "../gcode.h"
+#include "../../module/motion.h"
+#include "../../module/stepper.h"
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  /**
+   * M605: Set dual x-carriage movement mode
+   *
+   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
+   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
+   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
+   *                         units x-offset and an optional differential hotend temperature of
+   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
+   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
+   *
+   *    Note: the X axis should be homed after changing dual x-carriage mode.
+   */
+  void GcodeSuite::M605() {
+    stepper.synchronize();
+    if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
+    switch (dual_x_carriage_mode) {
+      case DXC_FULL_CONTROL_MODE:
+      case DXC_AUTO_PARK_MODE:
+        break;
+      case DXC_DUPLICATION_MODE:
+        if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+        if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
+        SERIAL_CHAR(' ');
+        SERIAL_ECHO(hotend_offset[X_AXIS][0]);
+        SERIAL_CHAR(',');
+        SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
+        SERIAL_CHAR(' ');
+        SERIAL_ECHO(duplicate_extruder_x_offset);
+        SERIAL_CHAR(',');
+        SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
+        break;
+      default:
+        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+        break;
+    }
+    active_extruder_parked = false;
+    extruder_duplication_enabled = false;
+    delayed_move_time = 0;
+  }
+
+#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+
+  void GcodeSuite::M605() {
+    stepper.synchronize();
+    extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
+  }
+
+#endif // DUAL_NOZZLE_DUPLICATION_MODE
+
+#endif // DUAL_X_CARRIAGE || DUAL_NOZZLE_DUPLICATION_MODE
