commit 4aff10785ee96a35eb4777c08b81722a59cecf68
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 18:46:38 2024 -0500

    üßë‚Äçüíª Use "enum class"

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f9748871f5..bb8f36446b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -265,21 +265,21 @@ void report_current_position();
 void report_current_position_projected();
 
 #if ENABLED(AUTO_REPORT_POSITION)
   #include "../libs/autoreport.h"
   struct PositionReport { static void report() {
     TERN(AUTO_REPORT_REAL_POSITION, report_real_position(), report_current_position_projected());
   } };
   extern AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
-#if ANY(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+#if ENABLED(REALTIME_REPORTING_COMMANDS)
   #define HAS_GRBL_STATE 1
   /**
    * Machine states for GRBL or TinyG
    */
   enum M_StateEnum : uint8_t {
     M_INIT = 0, //  0 machine is initializing
     M_RESET,    //  1 machine is ready for use
     M_ALARM,    //  2 machine is in alarm state (soft shut down)
     M_IDLE,     //  3 program stop or no more blocks (M0, M1, M60)
     M_END,      //  4 program end via M2, M30
@@ -298,25 +298,23 @@ void report_current_position_projected();
 
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
     inline void set_and_report_grblstate(const M_StateEnum state, const bool force=true) {
       if (force || M_State_grbl != state) {
         M_State_grbl = state;
         report_current_grblstate_moving();
       }
     }
   #endif
 
-  #if ENABLED(REALTIME_REPORTING_COMMANDS)
-    void quickpause_stepper();
-    void quickresume_stepper();
-  #endif
-#endif
+  void quickpause_stepper();
+  void quickresume_stepper();
+#endif // REALTIME_REPORTING_COMMANDS
 
 float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool &is_cartesian_move));
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 void quickstop_stepper();
 
 /**
  * Set the planner/stepper positions directly from current_position with

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c7558db43f..f9748871f5 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -24,21 +24,21 @@
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-  #include "../lcd/e3v2/proui/dwin.h"
+  #include "../lcd/e3v2/proui/dwin.h" // for Z_POST_CLEARANCE
 #endif
 
 #if IS_SCARA
   #include "scara.h"
 #elif ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
@@ -406,26 +406,26 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
-  #if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-    #define Z_POST_CLEARANCE hmiData.zAfterHoming
-  #elif defined(Z_AFTER_HOMING)
-    #define Z_POST_CLEARANCE Z_AFTER_HOMING
-  #else
-    #define Z_POST_CLEARANCE Z_CLEARANCE_FOR_HOMING
+  #ifndef Z_POST_CLEARANCE  // May be set by proui/dwin.h :-P
+    #ifdef Z_AFTER_HOMING
+      #define Z_POST_CLEARANCE Z_AFTER_HOMING
+    #else
+      #define Z_POST_CLEARANCE Z_CLEARANCE_FOR_HOMING
+    #endif
   #endif
   void do_z_clearance(const_float_t zclear, const bool with_probe=true, const bool lower_allowed=false);
   void do_z_clearance_by(const_float_t zclear);
   void do_move_after_z_homing();
   inline void do_z_post_clearance() { do_z_clearance(Z_POST_CLEARANCE); }
 #else
   inline void do_z_clearance(float, bool=true, bool=false) {}
   inline void do_z_clearance_by(float) {}
 #endif
 

commit 5287cfbb5974fe324c82f135a17a79c2b5cd5da9
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 19 13:23:20 2023 -0800

    üêõ Fix rotational AxisFlags (#26444)
    
    Followup to #26438

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ae9224dea4..c7558db43f 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -137,23 +137,23 @@ inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 // Flags for rotational axes
 constexpr AxisFlags rotational{0 LOGICAL_AXIS_GANG(
-    || 0, || 0, || 0, || 0,
-    || (ENABLED(AXIS4_ROTATES)<<I_AXIS), || (ENABLED(AXIS5_ROTATES)<<J_AXIS), || (ENABLED(AXIS6_ROTATES)<<K_AXIS),
-    || (ENABLED(AXIS7_ROTATES)<<U_AXIS), || (ENABLED(AXIS8_ROTATES)<<V_AXIS), || (ENABLED(AXIS9_ROTATES)<<W_AXIS))
+    | 0, | 0, | 0, | 0,
+    | (ENABLED(AXIS4_ROTATES)<<I_AXIS), | (ENABLED(AXIS5_ROTATES)<<J_AXIS), | (ENABLED(AXIS6_ROTATES)<<K_AXIS),
+    | (ENABLED(AXIS7_ROTATES)<<U_AXIS), | (ENABLED(AXIS8_ROTATES)<<V_AXIS), | (ENABLED(AXIS9_ROTATES)<<W_AXIS))
 };
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
   return pgm_read_any(&home_bump_mm_P[axis]);
 }
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();

commit aed577271ff94c822e861d8f652f2bdf46b2aeb9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 17 22:39:00 2023 -0600

    üî® Rotational move items (#26438)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7d5d657ac7..ae9224dea4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -135,20 +135,27 @@ inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm
   inline T NAME(const AxisEnum axis) { \
     static const XYZval<T> NAME##_P DEFS_PROGMEM = NUM_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT, I_##OPT, J_##OPT, K_##OPT, U_##OPT, V_##OPT, W_##OPT); \
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
+// Flags for rotational axes
+constexpr AxisFlags rotational{0 LOGICAL_AXIS_GANG(
+    || 0, || 0, || 0, || 0,
+    || (ENABLED(AXIS4_ROTATES)<<I_AXIS), || (ENABLED(AXIS5_ROTATES)<<J_AXIS), || (ENABLED(AXIS6_ROTATES)<<K_AXIS),
+    || (ENABLED(AXIS7_ROTATES)<<U_AXIS), || (ENABLED(AXIS8_ROTATES)<<V_AXIS), || (ENABLED(AXIS9_ROTATES)<<W_AXIS))
+};
+
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
   return pgm_read_any(&home_bump_mm_P[axis]);
 }
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS
   constexpr xyz_pos_t hotend_offset[HOTENDS] = { { TERN_(HAS_X_AXIS, 0) } };

commit f7d5188b2f0a59b752fbabf6b96ff1ed4aed8112
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Sat Aug 19 22:53:45 2023 +0200

    üêõ Fixes for ProUI, build rename (#26177)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index fceeffa707..7d5d657ac7 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -400,21 +400,21 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   #if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-    #define Z_POST_CLEARANCE hmiData.z_after_homing
+    #define Z_POST_CLEARANCE hmiData.zAfterHoming
   #elif defined(Z_AFTER_HOMING)
     #define Z_POST_CLEARANCE Z_AFTER_HOMING
   #else
     #define Z_POST_CLEARANCE Z_CLEARANCE_FOR_HOMING
   #endif
   void do_z_clearance(const_float_t zclear, const bool with_probe=true, const bool lower_allowed=false);
   void do_z_clearance_by(const_float_t zclear);
   void do_move_after_z_homing();
   inline void do_z_post_clearance() { do_z_clearance(Z_POST_CLEARANCE); }
 #else

commit 9135e3f7d3fd0d634656f1c54c70a0ba1f878bfd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 21:10:03 2023 -0500

    üö∏ Revert M206 Home Offset behavior (#25996)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9d5da849e5..fceeffa707 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -140,26 +140,20 @@ XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
   return pgm_read_any(&home_bump_mm_P[axis]);
 }
 
-#if HAS_WORKSPACE_OFFSET
-  void update_workspace_offset(const AxisEnum axis);
-#else
-  inline void update_workspace_offset(const AxisEnum) {}
-#endif
-
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS
   constexpr xyz_pos_t hotend_offset[HOTENDS] = { { TERN_(HAS_X_AXIS, 0) } };
 #else
   constexpr xyz_pos_t hotend_offset[1] = { { TERN_(HAS_X_AXIS, 0) } };
 #endif
 
 #if HAS_SOFTWARE_ENDSTOPS
@@ -477,46 +471,37 @@ inline bool all_axes_trusted()                        { return main_axes_mask ==
 void home_if_needed(const bool keeplev=false);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 #define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))
 
+#if HAS_HOME_OFFSET
+  extern xyz_pos_t home_offset;
+#endif
+
 /**
  * Workspace offsets
  */
-#if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
-  #if HAS_HOME_OFFSET
-    extern xyz_pos_t home_offset;
-  #endif
-  #if HAS_POSITION_SHIFT
-    extern xyz_pos_t position_shift;
-  #endif
-  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-    extern xyz_pos_t workspace_offset;
-    #define _WS workspace_offset
-  #elif HAS_HOME_OFFSET
-    #define _WS home_offset
-  #else
-    #define _WS position_shift
-  #endif
-  #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + _WS[AXIS])
-  #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - _WS[AXIS])
-  FORCE_INLINE void toLogical(xy_pos_t &raw)   { raw += _WS; }
-  FORCE_INLINE void toLogical(xyz_pos_t &raw)  { raw += _WS; }
-  FORCE_INLINE void toLogical(xyze_pos_t &raw) { raw += _WS; }
-  FORCE_INLINE void toNative(xy_pos_t &raw)    { raw -= _WS; }
-  FORCE_INLINE void toNative(xyz_pos_t &raw)   { raw -= _WS; }
-  FORCE_INLINE void toNative(xyze_pos_t &raw)  { raw -= _WS; }
+#if HAS_WORKSPACE_OFFSET
+  extern xyz_pos_t workspace_offset;
+  #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + workspace_offset[AXIS])
+  #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - workspace_offset[AXIS])
+  FORCE_INLINE void toLogical(xy_pos_t &raw)   { raw += workspace_offset; }
+  FORCE_INLINE void toLogical(xyz_pos_t &raw)  { raw += workspace_offset; }
+  FORCE_INLINE void toLogical(xyze_pos_t &raw) { raw += workspace_offset; }
+  FORCE_INLINE void toNative(xy_pos_t &raw)    { raw -= workspace_offset; }
+  FORCE_INLINE void toNative(xyz_pos_t &raw)   { raw -= workspace_offset; }
+  FORCE_INLINE void toNative(xyze_pos_t &raw)  { raw -= workspace_offset; }
 #else
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
   FORCE_INLINE void toLogical(xy_pos_t&)   {}
   FORCE_INLINE void toLogical(xyz_pos_t&)  {}
   FORCE_INLINE void toLogical(xyze_pos_t&) {}
   FORCE_INLINE void toNative(xy_pos_t&)    {}
   FORCE_INLINE void toNative(xyz_pos_t&)   {}
   FORCE_INLINE void toNative(xyze_pos_t&)  {}
 #endif
@@ -626,19 +611,19 @@ void home_if_needed(const bool keeplev=false);
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
     FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
   #define TOOL_X_HOME_DIR(T) X_HOME_DIR
 
 #endif
 
-#if HAS_M206_COMMAND
+#if HAS_HOME_OFFSET
   void set_home_offset(const AxisEnum axis, const_float_t v);
 #endif
 
 #if USE_SENSORLESS
   struct sensorless_t;
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis);
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth);
 #endif

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1e6d02d2a7..9d5da849e5 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -406,21 +406,21 @@ void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   #if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-    #define Z_POST_CLEARANCE HMI_data.z_after_homing
+    #define Z_POST_CLEARANCE hmiData.z_after_homing
   #elif defined(Z_AFTER_HOMING)
     #define Z_POST_CLEARANCE Z_AFTER_HOMING
   #else
     #define Z_POST_CLEARANCE Z_CLEARANCE_FOR_HOMING
   #endif
   void do_z_clearance(const_float_t zclear, const bool with_probe=true, const bool lower_allowed=false);
   void do_z_clearance_by(const_float_t zclear);
   void do_move_after_z_homing();
   inline void do_z_post_clearance() { do_z_clearance(Z_POST_CLEARANCE); }
 #else

commit ba08dcfb76804a912380603b3f69831ea0d1d6eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 3 04:40:07 2023 -0500

    üßë‚Äçüíª Fix narrowing conversions (#25924)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ce05c82c77..1e6d02d2a7 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -427,23 +427,20 @@ void restore_feedrate_and_scaling();
   inline void do_z_clearance(float, bool=true, bool=false) {}
   inline void do_z_clearance_by(float) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
 typedef bits_t(NUM_AXES) main_axes_bits_t;
 constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;
 
-typedef bits_t(NUM_AXES + EXTRUDERS) e_axis_bits_t;
-constexpr e_axis_bits_t e_axis_mask = (_BV(EXTRUDERS) - 1) << NUM_AXES;
-
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
    * axes_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *
    * axes_trusted
    *   Flags that the position is trusted in each linear axis. Set when homed.

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index b7e37f6b70..ce05c82c77 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -264,21 +264,21 @@ void report_current_position();
 void report_current_position_projected();
 
 #if ENABLED(AUTO_REPORT_POSITION)
   #include "../libs/autoreport.h"
   struct PositionReport { static void report() {
     TERN(AUTO_REPORT_REAL_POSITION, report_real_position(), report_current_position_projected());
   } };
   extern AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
-#if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+#if ANY(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
   #define HAS_GRBL_STATE 1
   /**
    * Machine states for GRBL or TinyG
    */
   enum M_StateEnum : uint8_t {
     M_INIT = 0, //  0 machine is initializing
     M_RESET,    //  1 machine is ready for use
     M_ALARM,    //  2 machine is in alarm state (soft shut down)
     M_IDLE,     //  3 program stop or no more blocks (M0, M1, M60)
     M_END,      //  4 program end via M2, M30

commit d22ce55cd5b88d50dd67818c5e44db91575e4d60
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Sun May 21 18:34:19 2023 -0400

    ü©π Fix ProUI Manual Mesh / UBL Viewer (#25858)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 71d80f954e..b7e37f6b70 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -23,20 +23,24 @@
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
+#if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+  #include "../lcd/e3v2/proui/dwin.h"
+#endif
+
 #if IS_SCARA
   #include "scara.h"
 #elif ENABLED(POLAR)
   #include "polar.h"
 #endif
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;

commit 7d5bd4dfbc029c1be10a3de42c0eb6508965a22d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 19 04:48:11 2023 -0500

    üé® Cutter pins cleanup

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ae0976b44c..71d80f954e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -351,21 +351,21 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(NUM_AXIS_ARGS_(const_float_t) const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 #if HAS_X_AXIS
-    void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s=0.0f);

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 394c4748d9..ae0976b44c 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -146,40 +146,42 @@ inline float home_bump_mm(const AxisEnum axis) {
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   inline void update_workspace_offset(const AxisEnum) {}
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS
-  constexpr xyz_pos_t hotend_offset[HOTENDS] = { { 0 } };
+  constexpr xyz_pos_t hotend_offset[HOTENDS] = { { TERN_(HAS_X_AXIS, 0) } };
 #else
-  constexpr xyz_pos_t hotend_offset[1] = { { 0 } };
+  constexpr xyz_pos_t hotend_offset[1] = { { TERN_(HAS_X_AXIS, 0) } };
 #endif
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   typedef struct {
     bool _enabled, _loose;
     bool enabled() { return _enabled && !_loose; }
 
     xyz_pos_t min, max;
     void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
       amin = -100000; amax = 100000; // "No limits"
       #if HAS_SOFTWARE_ENDSTOPS
         if (enabled()) switch (axis) {
-          case X_AXIS:
-            TERN_(MIN_SOFTWARE_ENDSTOP_X, amin = min.x);
-            TERN_(MAX_SOFTWARE_ENDSTOP_X, amax = max.x);
-            break;
+          #if HAS_X_AXIS
+            case X_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_X, amin = min.x);
+              TERN_(MAX_SOFTWARE_ENDSTOP_X, amax = max.x);
+              break;
+          #endif
           #if HAS_Y_AXIS
             case Y_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
               TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
               break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
               TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
@@ -343,26 +345,28 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(NUM_AXIS_ARGS_(const_float_t) const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
-void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
+#if HAS_X_AXIS
+    void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
+#endif
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s=0.0f);
 #endif
@@ -508,22 +512,24 @@ void home_if_needed(const bool keeplev=false);
 #else
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
   FORCE_INLINE void toLogical(xy_pos_t&)   {}
   FORCE_INLINE void toLogical(xyz_pos_t&)  {}
   FORCE_INLINE void toLogical(xyze_pos_t&) {}
   FORCE_INLINE void toNative(xy_pos_t&)    {}
   FORCE_INLINE void toNative(xyz_pos_t&)   {}
   FORCE_INLINE void toNative(xyze_pos_t&)  {}
 #endif
-#define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
-#define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
+#if HAS_X_AXIS
+  #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
+  #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
+#endif
 #if HAS_Y_AXIS
   #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
   #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #endif
 #if HAS_Z_AXIS
   #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
   #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 #endif
 #if HAS_I_AXIS
   #define LOGICAL_I_POSITION(POS) NATIVE_TO_LOGICAL(POS, I_AXIS)
@@ -562,23 +568,23 @@ void home_if_needed(const bool keeplev=false);
   // Return true if the given point is within the printable area
   bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset=0);
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
 #else
 
   // Return true if the given position is within the machine bounds.
-  bool position_is_reachable(const_float_t rx, const_float_t ry);
+  bool position_is_reachable(TERN_(HAS_X_AXIS, const_float_t rx) OPTARG(HAS_Y_AXIS, const_float_t ry));
   inline bool position_is_reachable(const xy_pos_t &pos) {
-    return position_is_reachable(pos.x, pos.y);
+    return position_is_reachable(TERN_(HAS_X_AXIS, pos.x) OPTARG(HAS_Y_AXIS, pos.y));
   }
 
 #endif
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e899815c0f..394c4748d9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -601,21 +601,21 @@ void home_if_needed(const bool keeplev=false);
   extern xyz_pos_t raised_parked_position;          // Used in mode 1
   extern bool active_extruder_parked;               // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;                // Used in mode 1
   extern celsius_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
   extern bool idex_mirrored_mode;                   // Used in mode 3
 
   FORCE_INLINE bool idex_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const uint8_t extruder);
 
-  #define TOOL_X_HOME_DIR(T) ((T) ? X2_HOME_DIR : X_HOME_DIR)
+  #define TOOL_X_HOME_DIR(T) ((T) ? 1 : -1)
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index=-1);
   void idex_set_mirrored_mode(const bool mirr);
   void idex_set_parked(const bool park=true);
 
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };

commit 959f7308e760d85cdbfe90ea3581f42811823389
Author: TheSnowfield <17957399+TheSnowfield@users.noreply.github.com>
Date:   Thu Apr 27 20:37:11 2023 +0800

    ‚ú® AUTO_REPORT_REAL_POSITION option for M154 (#25738)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 4cd4641e3d..e899815c0f 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -252,21 +252,23 @@ inline float home_bump_mm(const AxisEnum axis) {
   #define SET_SOFT_ENDSTOP_LOOSE(V)     NOOP
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
 #if ENABLED(AUTO_REPORT_POSITION)
   #include "../libs/autoreport.h"
-  struct PositionReport { static void report() { report_current_position_projected(); } };
+  struct PositionReport { static void report() {
+    TERN(AUTO_REPORT_REAL_POSITION, report_real_position(), report_current_position_projected());
+  } };
   extern AutoReporter<PositionReport> position_auto_reporter;
 #endif
 
 #if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
   #define HAS_GRBL_STATE 1
   /**
    * Machine states for GRBL or TinyG
    */
   enum M_StateEnum : uint8_t {
     M_INIT = 0, //  0 machine is initializing

commit c8c5ab22ce242b93632a7e2b9f855bbaf38b557f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 19:29:53 2023 -0500

    üßë‚Äçüíª Gather Z clearances (#25701)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c93b1ef205..4cd4641e3d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -391,27 +391,35 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
-void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
+  #if ALL(DWIN_LCD_PROUI, INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+    #define Z_POST_CLEARANCE HMI_data.z_after_homing
+  #elif defined(Z_AFTER_HOMING)
+    #define Z_POST_CLEARANCE Z_AFTER_HOMING
+  #else
+    #define Z_POST_CLEARANCE Z_CLEARANCE_FOR_HOMING
+  #endif
   void do_z_clearance(const_float_t zclear, const bool with_probe=true, const bool lower_allowed=false);
   void do_z_clearance_by(const_float_t zclear);
+  void do_move_after_z_homing();
+  inline void do_z_post_clearance() { do_z_clearance(Z_POST_CLEARANCE); }
 #else
   inline void do_z_clearance(float, bool=true, bool=false) {}
   inline void do_z_clearance_by(float) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
 typedef bits_t(NUM_AXES) main_axes_bits_t;
 constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;

commit f53217b2c5bf7d61d21ee6784ec251bc7a670eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:01 2023 -0500

    üßë‚Äçüíª Probe flag in do_z_clearance

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index cdf1d7a969..c93b1ef205 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -396,24 +396,24 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
-  void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
+  void do_z_clearance(const_float_t zclear, const bool with_probe=true, const bool lower_allowed=false);
   void do_z_clearance_by(const_float_t zclear);
 #else
-  inline void do_z_clearance(float, bool=false) {}
+  inline void do_z_clearance(float, bool=true, bool=false) {}
   inline void do_z_clearance_by(float) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
 typedef bits_t(NUM_AXES) main_axes_bits_t;
 constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;
 
 typedef bits_t(NUM_AXES + EXTRUDERS) e_axis_bits_t;

commit 185961f898f8c9d2cf5e3d78dcd060e7c576cf7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 17:55:58 2023 -0500

    üßë‚Äçüíª More debug in motion.*

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index adc11f54d9..cdf1d7a969 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -429,40 +429,35 @@ void set_axis_is_at_home(const AxisEnum axis);
    *
    * axes_trusted
    *   Flags that the position is trusted in each linear axis. Set when homed.
    *   Cleared whenever a stepper powers off, potentially losing its position.
    */
   extern main_axes_bits_t axes_homed, axes_trusted;
   void homeaxis(const AxisEnum axis);
   void set_axis_never_homed(const AxisEnum axis);
   main_axes_bits_t axes_should_home(main_axes_bits_t axes_mask=main_axes_mask);
   bool homing_needed_error(main_axes_bits_t axes_mask=main_axes_mask);
-  inline void set_axis_unhomed(const AxisEnum axis)   { CBI(axes_homed, axis); }
-  inline void set_axis_untrusted(const AxisEnum axis) { CBI(axes_trusted, axis); }
-  inline void set_all_unhomed()                       { axes_homed = axes_trusted = 0; }
-  inline void set_axis_homed(const AxisEnum axis)     { SBI(axes_homed, axis); }
-  inline void set_axis_trusted(const AxisEnum axis)   { SBI(axes_trusted, axis); }
-  inline void set_all_homed()                         { axes_homed = axes_trusted = main_axes_mask; }
 #else
   constexpr main_axes_bits_t axes_homed = main_axes_mask, axes_trusted = main_axes_mask; // Zero-endstop machines are always homed and trusted
   inline void homeaxis(const AxisEnum axis)           {}
   inline void set_axis_never_homed(const AxisEnum)    {}
   inline main_axes_bits_t axes_should_home(main_axes_bits_t=main_axes_mask) { return 0; }
   inline bool homing_needed_error(main_axes_bits_t=main_axes_mask) { return false; }
-  inline void set_axis_unhomed(const AxisEnum axis)   {}
-  inline void set_axis_untrusted(const AxisEnum axis) {}
-  inline void set_all_unhomed()                       {}
-  inline void set_axis_homed(const AxisEnum axis)     {}
-  inline void set_axis_trusted(const AxisEnum axis)   {}
-  inline void set_all_homed()                         {}
 #endif
 
+inline void set_axis_unhomed(const AxisEnum axis)     { TERN_(HAS_ENDSTOPS, CBI(axes_homed, axis)); }
+inline void set_axis_untrusted(const AxisEnum axis)   { TERN_(HAS_ENDSTOPS, CBI(axes_trusted, axis)); }
+inline void set_all_unhomed()                         { TERN_(HAS_ENDSTOPS, axes_homed = axes_trusted = 0); }
+inline void set_axis_homed(const AxisEnum axis)       { TERN_(HAS_ENDSTOPS, SBI(axes_homed, axis)); }
+inline void set_axis_trusted(const AxisEnum axis)     { TERN_(HAS_ENDSTOPS, SBI(axes_trusted, axis)); }
+inline void set_all_homed()                           { TERN_(HAS_ENDSTOPS, axes_homed = axes_trusted = main_axes_mask); }
+
 inline bool axis_was_homed(const AxisEnum axis)       { return TEST(axes_homed, axis); }
 inline bool axis_is_trusted(const AxisEnum axis)      { return TEST(axes_trusted, axis); }
 inline bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
 inline bool no_axes_homed()                           { return !axes_homed; }
 inline bool all_axes_homed()                          { return main_axes_mask == (axes_homed & main_axes_mask); }
 inline bool homing_needed()                           { return !all_axes_homed(); }
 inline bool all_axes_trusted()                        { return main_axes_mask == (axes_trusted & main_axes_mask); }
 
 void home_if_needed(const bool keeplev=false);
 

commit 266786406c3e90654e94b91cd74e646d145cc4ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 30 15:12:56 2023 -0500

    üé® Misc. probe-related cleanup

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 611d3a17bd..adc11f54d9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -397,22 +397,24 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 #endif
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
+  void do_z_clearance_by(const_float_t zclear);
 #else
   inline void do_z_clearance(float, bool=false) {}
+  inline void do_z_clearance_by(float) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
 typedef bits_t(NUM_AXES) main_axes_bits_t;
 constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;
 
 typedef bits_t(NUM_AXES + EXTRUDERS) e_axis_bits_t;
 constexpr e_axis_bits_t e_axis_mask = (_BV(EXTRUDERS) - 1) << NUM_AXES;

commit f0c8c9182090f8929ec4766683ec2d6902d4bc00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 3 20:44:24 2023 -0600

    üßë‚Äçüíª Width/Magnitude-based types (#25458)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2acc54ebc2..611d3a17bd 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -404,24 +404,24 @@ void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 #else
   inline void do_z_clearance(float, bool=false) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
-typedef IF<(NUM_AXES > 8), uint16_t, uint8_t>::type main_axes_bits_t;
+typedef bits_t(NUM_AXES) main_axes_bits_t;
 constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;
 
-typedef IF<(NUM_AXES + EXTRUDERS > 8), uint16_t, uint8_t>::type e_axis_bits_t;
+typedef bits_t(NUM_AXES + EXTRUDERS) e_axis_bits_t;
 constexpr e_axis_bits_t e_axis_mask = (_BV(EXTRUDERS) - 1) << NUM_AXES;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
    * axes_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *

commit babd3b0037d660f52cccbb295b8839b8dd744036
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Feb 21 19:26:10 2023 +0100

    üßë‚Äçüíª Add get_move_distance for rotation/kinematics (#25370)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f0e4094f0f..2acc54ebc2 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -295,20 +295,22 @@ void report_current_position_projected();
       }
     }
   #endif
 
   #if ENABLED(REALTIME_REPORTING_COMMANDS)
     void quickpause_stepper();
     void quickresume_stepper();
   #endif
 #endif
 
+float get_move_distance(const xyze_pos_t &diff OPTARG(HAS_ROTATIONAL_AXES, bool &is_cartesian_move));
+
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 void quickstop_stepper();
 
 /**
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 8950cf6f22..f0e4094f0f 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -339,21 +339,21 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(NUM_AXIS_ARGS(const_float_t), const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
@@ -611,18 +611,18 @@ void home_if_needed(const bool keeplev=false);
     extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
     FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
   #define TOOL_X_HOME_DIR(T) X_HOME_DIR
 
 #endif
 
 #if HAS_M206_COMMAND
-  void set_home_offset(const AxisEnum axis, const float v);
+  void set_home_offset(const AxisEnum axis, const_float_t v);
 #endif
 
 #if USE_SENSORLESS
   struct sensorless_t;
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis);
   void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth);
 #endif

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ce90947657..8950cf6f22 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -25,20 +25,22 @@
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "scara.h"
+#elif ENABLED(POLAR)
+  #include "polar.h"
 #endif
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 

commit 9706cd0d7dc9e09faec2ed2b5ec106dbd22e5c61
Author: Arthur Masson <arthur.sw@gmail.com>
Date:   Sat Jul 16 23:58:18 2022 +0200

    ‚ú® Polargraph M665 settings (#24401)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ec47818877..ce90947657 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -542,77 +542,35 @@ void home_if_needed(const bool keeplev=false);
 /**
  * position_is_reachable family of functions
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
-  inline bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset=0) {
-    #if ENABLED(DELTA)
-
-      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
-
-    #elif ENABLED(POLARGRAPH)
-
-      const float x1 = rx - (X_MIN_POS), x2 = (X_MAX_POS) - rx, y = ry - (Y_MAX_POS),
-                  a = HYPOT(x1, y), b = HYPOT(x2, y);
-      return a < (POLARGRAPH_MAX_BELT_LEN) + 1
-          && b < (POLARGRAPH_MAX_BELT_LEN) + 1
-          && (a + b) > _MIN(X_BED_SIZE, Y_BED_SIZE);
-
-    #elif ENABLED(AXEL_TPARA)
-
-      const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
-      return (
-        R2 <= sq(L1 + L2) - inset
-        #if MIDDLE_DEAD_ZONE_R > 0
-          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
-        #endif
-      );
-
-    #elif IS_SCARA
-
-      const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
-      return (
-        R2 <= sq(L1 + L2) - inset
-        #if MIDDLE_DEAD_ZONE_R > 0
-          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
-        #endif
-      );
-
-    #endif
-  }
+  bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset=0);
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
-#else // CARTESIAN
+#else
 
   // Return true if the given position is within the machine bounds.
-  inline bool position_is_reachable(const_float_t rx, const_float_t ry) {
-    if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
-    #if ENABLED(DUAL_X_CARRIAGE)
-      if (active_extruder)
-        return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
-      else
-        return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
-    #else
-      return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
-    #endif
+  bool position_is_reachable(const_float_t rx, const_float_t ry);
+  inline bool position_is_reachable(const xy_pos_t &pos) {
+    return position_is_reachable(pos.x, pos.y);
   }
-  inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
-#endif // CARTESIAN
+#endif
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage

commit 1f322b565f409ab5068e225a4d9a929907c966f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 26 18:31:05 2022 -0500

    ‚ôªÔ∏è More updates for multi-axis

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 45dae5d609..ec47818877 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -400,67 +400,70 @@ void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 #else
   inline void do_z_clearance(float, bool=false) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
-typedef IF<(NUM_AXES > 8), uint16_t, uint8_t>::type linear_axis_bits_t;
-constexpr linear_axis_bits_t linear_bits = _BV(NUM_AXES) - 1;
+typedef IF<(NUM_AXES > 8), uint16_t, uint8_t>::type main_axes_bits_t;
+constexpr main_axes_bits_t main_axes_mask = _BV(NUM_AXES) - 1;
+
+typedef IF<(NUM_AXES + EXTRUDERS > 8), uint16_t, uint8_t>::type e_axis_bits_t;
+constexpr e_axis_bits_t e_axis_mask = (_BV(EXTRUDERS) - 1) << NUM_AXES;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
-   * axis_homed
+   * axes_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *
-   * axis_trusted
+   * axes_trusted
    *   Flags that the position is trusted in each linear axis. Set when homed.
    *   Cleared whenever a stepper powers off, potentially losing its position.
    */
-  extern linear_axis_bits_t axis_homed, axis_trusted;
+  extern main_axes_bits_t axes_homed, axes_trusted;
   void homeaxis(const AxisEnum axis);
   void set_axis_never_homed(const AxisEnum axis);
-  linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits=linear_bits);
-  bool homing_needed_error(linear_axis_bits_t axis_bits=linear_bits);
-  inline void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
-  inline void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
-  inline void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
-  inline void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
-  inline void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
-  inline void set_all_homed()                         { axis_homed = axis_trusted = linear_bits; }
+  main_axes_bits_t axes_should_home(main_axes_bits_t axes_mask=main_axes_mask);
+  bool homing_needed_error(main_axes_bits_t axes_mask=main_axes_mask);
+  inline void set_axis_unhomed(const AxisEnum axis)   { CBI(axes_homed, axis); }
+  inline void set_axis_untrusted(const AxisEnum axis) { CBI(axes_trusted, axis); }
+  inline void set_all_unhomed()                       { axes_homed = axes_trusted = 0; }
+  inline void set_axis_homed(const AxisEnum axis)     { SBI(axes_homed, axis); }
+  inline void set_axis_trusted(const AxisEnum axis)   { SBI(axes_trusted, axis); }
+  inline void set_all_homed()                         { axes_homed = axes_trusted = main_axes_mask; }
 #else
-  constexpr linear_axis_bits_t axis_homed = linear_bits, axis_trusted = linear_bits; // Zero-endstop machines are always homed and trusted
+  constexpr main_axes_bits_t axes_homed = main_axes_mask, axes_trusted = main_axes_mask; // Zero-endstop machines are always homed and trusted
   inline void homeaxis(const AxisEnum axis)           {}
   inline void set_axis_never_homed(const AxisEnum)    {}
-  inline linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return 0; }
-  inline bool homing_needed_error(linear_axis_bits_t=linear_bits) { return false; }
+  inline main_axes_bits_t axes_should_home(main_axes_bits_t=main_axes_mask) { return 0; }
+  inline bool homing_needed_error(main_axes_bits_t=main_axes_mask) { return false; }
   inline void set_axis_unhomed(const AxisEnum axis)   {}
   inline void set_axis_untrusted(const AxisEnum axis) {}
   inline void set_all_unhomed()                       {}
   inline void set_axis_homed(const AxisEnum axis)     {}
   inline void set_axis_trusted(const AxisEnum axis)   {}
   inline void set_all_homed()                         {}
 #endif
 
-inline bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }
-inline bool axis_is_trusted(const AxisEnum axis)      { return TEST(axis_trusted, axis); }
+inline bool axis_was_homed(const AxisEnum axis)       { return TEST(axes_homed, axis); }
+inline bool axis_is_trusted(const AxisEnum axis)      { return TEST(axes_trusted, axis); }
 inline bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
-inline bool no_axes_homed()                           { return !axis_homed; }
-inline bool all_axes_homed()                          { return linear_bits == (axis_homed & linear_bits); }
+inline bool no_axes_homed()                           { return !axes_homed; }
+inline bool all_axes_homed()                          { return main_axes_mask == (axes_homed & main_axes_mask); }
 inline bool homing_needed()                           { return !all_axes_homed(); }
-inline bool all_axes_trusted()                        { return linear_bits == (axis_trusted & linear_bits); }
+inline bool all_axes_trusted()                        { return main_axes_mask == (axes_trusted & main_axes_mask); }
 
 void home_if_needed(const bool keeplev=false);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 #define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1dd6d8c4ed..45dae5d609 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -37,21 +37,21 @@
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
-  extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3]; // TODO: Add support for LINEAR_AXES >= 4
+  extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3]; // TODO: Add support for HAS_I_AXIS
   extern xyze_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abce_pos_t delta;
 #endif
@@ -70,27 +70,30 @@ extern xyz_pos_t cartes;
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 constexpr xyz_feedrate_t homing_feedrate_mm_m = HOMING_FEEDRATE_MM_M;
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) {
   float v = TERN0(HAS_Z_AXIS, homing_feedrate_mm_m.z);
   #if DISABLED(DELTA)
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
            if (a == X_AXIS) v = homing_feedrate_mm_m.x,
       else if (a == Y_AXIS) v = homing_feedrate_mm_m.y,
       else if (a == Z_AXIS) v = homing_feedrate_mm_m.z,
       else if (a == I_AXIS) v = homing_feedrate_mm_m.i,
       else if (a == J_AXIS) v = homing_feedrate_mm_m.j,
-      else if (a == K_AXIS) v = homing_feedrate_mm_m.k
+      else if (a == K_AXIS) v = homing_feedrate_mm_m.k,
+      else if (a == U_AXIS) v = homing_feedrate_mm_m.u,
+      else if (a == V_AXIS) v = homing_feedrate_mm_m.v,
+      else if (a == W_AXIS) v = homing_feedrate_mm_m.w
     );
   #endif
   return MMM_TO_MMS(v);
 }
 
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 /**
  * The default feedrate for many moves, set by the most recent move
  */
@@ -117,21 +120,21 @@ extern int16_t feedrate_percentage;
   #define DEFS_PROGMEM
 #else
   #define DEFS_PROGMEM PROGMEM
 #endif
 
 inline float pgm_read_any(const float *p)   { return TERN(__IMXRT1062__, *p, pgm_read_float(p)); }
 inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm_read_byte(p)); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   inline T NAME(const AxisEnum axis) { \
-    static const XYZval<T> NAME##_P DEFS_PROGMEM = LINEAR_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT, I_##OPT, J_##OPT, K_##OPT); \
+    static const XYZval<T> NAME##_P DEFS_PROGMEM = NUM_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT, I_##OPT, J_##OPT, K_##OPT, U_##OPT, V_##OPT, W_##OPT); \
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
@@ -191,20 +194,38 @@ inline float home_bump_mm(const AxisEnum axis) {
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amin = min.j);
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amax = max.j);
               break;
           #endif
           #if HAS_K_AXIS
             case K_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_K, amin = min.k);
               TERN_(MIN_SOFTWARE_ENDSTOP_K, amax = max.k);
               break;
           #endif
+          #if HAS_U_AXIS
+            case U_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_U, amin = min.u);
+              TERN_(MIN_SOFTWARE_ENDSTOP_U, amax = max.u);
+              break;
+          #endif
+          #if HAS_V_AXIS
+            case V_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_V, amin = min.v);
+              TERN_(MIN_SOFTWARE_ENDSTOP_V, amax = max.v);
+              break;
+          #endif
+          #if HAS_W_AXIS
+            case W_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_W, amin = min.w);
+              TERN_(MIN_SOFTWARE_ENDSTOP_W, amax = max.w);
+              break;
+          #endif
           default: break;
         }
       #endif
     }
   } soft_endstops_t;
 
   extern soft_endstops_t soft_endstop;
   void apply_motion_limits(xyz_pos_t &target);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
@@ -316,21 +337,21 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(NUM_AXIS_ARGS(const float), const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
@@ -340,20 +361,32 @@ void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_J_AXIS
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_K_AXIS
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s=0.0f);
 #endif
+#if HAS_U_AXIS
+  void do_blocking_move_to_u(const_float_t ru, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xyzijk_u(const xyze_pos_t &raw, const_float_t u, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if HAS_V_AXIS
+  void do_blocking_move_to_v(const_float_t rv, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xyzijku_v(const xyze_pos_t &raw, const_float_t v, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if HAS_W_AXIS
+  void do_blocking_move_to_w(const float rw, const feedRate_t &fr_mm_s=0.0f);
+  void do_blocking_move_to_xyzijkuv_w(const xyze_pos_t &raw, const float w, const feedRate_t &fr_mm_s=0.0f);
+#endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 #endif
 
 #if HAS_Z_AXIS
   void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
@@ -367,22 +400,22 @@ void restore_feedrate_and_scaling();
 
 #if HAS_Z_AXIS
   void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 #else
   inline void do_z_clearance(float, bool=false) {}
 #endif
 
 /**
  * Homing and Trusted Axes
  */
-typedef IF<(LINEAR_AXES > 8), uint16_t, uint8_t>::type linear_axis_bits_t;
-constexpr linear_axis_bits_t linear_bits = _BV(LINEAR_AXES) - 1;
+typedef IF<(NUM_AXES > 8), uint16_t, uint8_t>::type linear_axis_bits_t;
+constexpr linear_axis_bits_t linear_bits = _BV(NUM_AXES) - 1;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
    * axis_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *
    * axis_trusted
@@ -483,20 +516,32 @@ void home_if_needed(const bool keeplev=false);
   #define RAW_I_POSITION(POS)     LOGICAL_TO_NATIVE(POS, I_AXIS)
 #endif
 #if HAS_J_AXIS
   #define LOGICAL_J_POSITION(POS) NATIVE_TO_LOGICAL(POS, J_AXIS)
   #define RAW_J_POSITION(POS)     LOGICAL_TO_NATIVE(POS, J_AXIS)
 #endif
 #if HAS_K_AXIS
   #define LOGICAL_K_POSITION(POS) NATIVE_TO_LOGICAL(POS, K_AXIS)
   #define RAW_K_POSITION(POS)     LOGICAL_TO_NATIVE(POS, K_AXIS)
 #endif
+#if HAS_U_AXIS
+  #define LOGICAL_U_POSITION(POS) NATIVE_TO_LOGICAL(POS, U_AXIS)
+  #define RAW_U_POSITION(POS)     LOGICAL_TO_NATIVE(POS, U_AXIS)
+#endif
+#if HAS_V_AXIS
+  #define LOGICAL_V_POSITION(POS) NATIVE_TO_LOGICAL(POS, V_AXIS)
+  #define RAW_V_POSITION(POS)     LOGICAL_TO_NATIVE(POS, V_AXIS)
+#endif
+#if HAS_W_AXIS
+  #define LOGICAL_W_POSITION(POS) NATIVE_TO_LOGICAL(POS, W_AXIS)
+  #define RAW_W_POSITION(POS)     LOGICAL_TO_NATIVE(POS, W_AXIS)
+#endif
 
 /**
  * position_is_reachable family of functions
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 

commit a58d35d765c091ec4aab6af893e5b3ad353cb3d5
Author: Mathew Winters <mathew@winters.org.nz>
Date:   Sun Mar 13 14:13:41 2022 +1300

    ‚ö°Ô∏è G12 - Only require used axes to be homed (#23422)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2fbb4ce114..1dd6d8c4ed 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -397,21 +397,21 @@ void set_axis_is_at_home(const AxisEnum axis);
   inline void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
   inline void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
   inline void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
   inline void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
   inline void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
   inline void set_all_homed()                         { axis_homed = axis_trusted = linear_bits; }
 #else
   constexpr linear_axis_bits_t axis_homed = linear_bits, axis_trusted = linear_bits; // Zero-endstop machines are always homed and trusted
   inline void homeaxis(const AxisEnum axis)           {}
   inline void set_axis_never_homed(const AxisEnum)    {}
-  inline linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return false; }
+  inline linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return 0; }
   inline bool homing_needed_error(linear_axis_bits_t=linear_bits) { return false; }
   inline void set_axis_unhomed(const AxisEnum axis)   {}
   inline void set_axis_untrusted(const AxisEnum axis) {}
   inline void set_all_unhomed()                       {}
   inline void set_axis_homed(const AxisEnum axis)     {}
   inline void set_axis_trusted(const AxisEnum axis)   {}
   inline void set_all_homed()                         {}
 #endif
 
 inline bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }

commit b07a34eb6bd8928aebef631554626aaa8c88c567
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 16:04:17 2022 -0600

    üêõ Fix M_State_grbl when G29 calls G28

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9fe61aad33..2fbb4ce114 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -258,23 +258,25 @@ void report_current_position_projected();
     M_HOMING,   //  9 machine is homing
     M_JOGGING,  // 10 machine is jogging
     M_ERROR     // 11 machine is in hard alarm state (shut down)
   };
   extern M_StateEnum M_State_grbl;
   M_StateEnum grbl_state_for_marlin_state();
   void report_current_grblstate_moving();
   void report_current_position_moving();
 
   #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
-    inline void set_and_report_grblstate(const M_StateEnum state) {
-      M_State_grbl = state;
-      report_current_grblstate_moving();
+    inline void set_and_report_grblstate(const M_StateEnum state, const bool force=true) {
+      if (force || M_State_grbl != state) {
+        M_State_grbl = state;
+        report_current_grblstate_moving();
+      }
     }
   #endif
 
   #if ENABLED(REALTIME_REPORTING_COMMANDS)
     void quickpause_stepper();
     void quickresume_stepper();
   #endif
 #endif
 
 void get_cartesian_from_steppers();

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 50df5675e6..9fe61aad33 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -173,33 +173,33 @@ inline float home_bump_mm(const AxisEnum axis) {
               TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
               TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
               break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
               TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
               break;
           #endif
-          #if LINEAR_AXES >= 4
+          #if HAS_I_AXIS
             case I_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_I, amin = min.i);
               TERN_(MIN_SOFTWARE_ENDSTOP_I, amax = max.i);
               break;
           #endif
-          #if LINEAR_AXES >= 5
+          #if HAS_J_AXIS
             case J_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amin = min.j);
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amax = max.j);
               break;
           #endif
-          #if LINEAR_AXES >= 6
+          #if HAS_K_AXIS
             case K_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_K, amin = min.k);
               TERN_(MIN_SOFTWARE_ENDSTOP_K, amax = max.k);
               break;
           #endif
           default: break;
         }
       #endif
     }
   } soft_endstops_t;
@@ -326,29 +326,29 @@ void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
 #if HAS_Y_AXIS
   void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 #endif
 #if HAS_Z_AXIS
   void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
 #endif
-#if LINEAR_AXES >= 4
+#if HAS_I_AXIS
   void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s=0.0f);
 #endif
-#if LINEAR_AXES >= 5
+#if HAS_J_AXIS
   void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s=0.0f);
 #endif
-#if LINEAR_AXES >= 6
+#if HAS_K_AXIS
   void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s=0.0f);
 #endif
 
 #if HAS_Y_AXIS
   void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
   void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
   FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
   FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 #endif
@@ -469,29 +469,29 @@ void home_if_needed(const bool keeplev=false);
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #if HAS_Y_AXIS
   #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
   #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #endif
 #if HAS_Z_AXIS
   #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
   #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 #endif
-#if LINEAR_AXES >= 4
+#if HAS_I_AXIS
   #define LOGICAL_I_POSITION(POS) NATIVE_TO_LOGICAL(POS, I_AXIS)
   #define RAW_I_POSITION(POS)     LOGICAL_TO_NATIVE(POS, I_AXIS)
 #endif
-#if LINEAR_AXES >= 5
+#if HAS_J_AXIS
   #define LOGICAL_J_POSITION(POS) NATIVE_TO_LOGICAL(POS, J_AXIS)
   #define RAW_J_POSITION(POS)     LOGICAL_TO_NATIVE(POS, J_AXIS)
 #endif
-#if LINEAR_AXES >= 6
+#if HAS_K_AXIS
   #define LOGICAL_K_POSITION(POS) NATIVE_TO_LOGICAL(POS, K_AXIS)
   #define RAW_K_POSITION(POS)     LOGICAL_TO_NATIVE(POS, K_AXIS)
 #endif
 
 /**
  * position_is_reachable family of functions
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c41738a5ab..50df5675e6 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -497,20 +497,28 @@ void home_if_needed(const bool keeplev=false);
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset=0) {
     #if ENABLED(DELTA)
 
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
 
+    #elif ENABLED(POLARGRAPH)
+
+      const float x1 = rx - (X_MIN_POS), x2 = (X_MAX_POS) - rx, y = ry - (Y_MAX_POS),
+                  a = HYPOT(x1, y), b = HYPOT(x2, y);
+      return a < (POLARGRAPH_MAX_BELT_LEN) + 1
+          && b < (POLARGRAPH_MAX_BELT_LEN) + 1
+          && (a + b) > _MIN(X_BED_SIZE, Y_BED_SIZE);
+
     #elif ENABLED(AXEL_TPARA)
 
       const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
 

commit 6bdd0fcda183068dcd8fe797a9a835765c3efe9e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Jun 14 23:52:42 2021 +0200

    ‚ö°Ô∏è Home Z (and maybe XY) at the start of G35 (#22060)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index d099246f17..c41738a5ab 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -385,47 +385,49 @@ void set_axis_is_at_home(const AxisEnum axis);
    *
    * axis_trusted
    *   Flags that the position is trusted in each linear axis. Set when homed.
    *   Cleared whenever a stepper powers off, potentially losing its position.
    */
   extern linear_axis_bits_t axis_homed, axis_trusted;
   void homeaxis(const AxisEnum axis);
   void set_axis_never_homed(const AxisEnum axis);
   linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits=linear_bits);
   bool homing_needed_error(linear_axis_bits_t axis_bits=linear_bits);
-  FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
-  FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
-  FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
-  FORCE_INLINE void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
-  FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
-  FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = linear_bits; }
+  inline void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
+  inline void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
+  inline void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
+  inline void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
+  inline void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
+  inline void set_all_homed()                         { axis_homed = axis_trusted = linear_bits; }
 #else
   constexpr linear_axis_bits_t axis_homed = linear_bits, axis_trusted = linear_bits; // Zero-endstop machines are always homed and trusted
-  FORCE_INLINE void homeaxis(const AxisEnum axis)           {}
-  FORCE_INLINE void set_axis_never_homed(const AxisEnum)    {}
-  FORCE_INLINE linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return false; }
-  FORCE_INLINE bool homing_needed_error(linear_axis_bits_t=linear_bits) { return false; }
-  FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   {}
-  FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) {}
-  FORCE_INLINE void set_all_unhomed()                       {}
-  FORCE_INLINE void set_axis_homed(const AxisEnum axis)     {}
-  FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   {}
-  FORCE_INLINE void set_all_homed()                         {}
-#endif
-
-FORCE_INLINE bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }
-FORCE_INLINE bool axis_is_trusted(const AxisEnum axis)      { return TEST(axis_trusted, axis); }
-FORCE_INLINE bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
-FORCE_INLINE bool no_axes_homed()                           { return !axis_homed; }
-FORCE_INLINE bool all_axes_homed()                          { return linear_bits == (axis_homed & linear_bits); }
-FORCE_INLINE bool homing_needed()                           { return !all_axes_homed(); }
-FORCE_INLINE bool all_axes_trusted()                        { return linear_bits == (axis_trusted & linear_bits); }
+  inline void homeaxis(const AxisEnum axis)           {}
+  inline void set_axis_never_homed(const AxisEnum)    {}
+  inline linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return false; }
+  inline bool homing_needed_error(linear_axis_bits_t=linear_bits) { return false; }
+  inline void set_axis_unhomed(const AxisEnum axis)   {}
+  inline void set_axis_untrusted(const AxisEnum axis) {}
+  inline void set_all_unhomed()                       {}
+  inline void set_axis_homed(const AxisEnum axis)     {}
+  inline void set_axis_trusted(const AxisEnum axis)   {}
+  inline void set_all_homed()                         {}
+#endif
+
+inline bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }
+inline bool axis_is_trusted(const AxisEnum axis)      { return TEST(axis_trusted, axis); }
+inline bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
+inline bool no_axes_homed()                           { return !axis_homed; }
+inline bool all_axes_homed()                          { return linear_bits == (axis_homed & linear_bits); }
+inline bool homing_needed()                           { return !all_axes_homed(); }
+inline bool all_axes_trusted()                        { return linear_bits == (axis_trusted & linear_bits); }
+
+void home_if_needed(const bool keeplev=false);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 #define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))
 
 /**

commit ba4fa4983411d03eae791b70d8ec3e26f0781785
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jun 6 08:30:39 2021 +0200

    ‚úèÔ∏è Followup to Six Linear Axes (#22056)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9095290cc7..d099246f17 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -173,21 +173,21 @@ inline float home_bump_mm(const AxisEnum axis) {
               TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
               TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
               break;
           #endif
           #if HAS_Z_AXIS
             case Z_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
               TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
               break;
           #endif
-          #if LINEAR_AXES >= 4 // TODO (DerAndere): Test for LINEAR_AXES >= 4
+          #if LINEAR_AXES >= 4
             case I_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_I, amin = min.i);
               TERN_(MIN_SOFTWARE_ENDSTOP_I, amax = max.i);
               break;
           #endif
           #if LINEAR_AXES >= 5
             case J_AXIS:
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amin = min.j);
               TERN_(MIN_SOFTWARE_ENDSTOP_J, amax = max.j);
               break;

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 0706b721b3..9095290cc7 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -37,30 +37,30 @@
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
-  extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
+  extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3]; // TODO: Add support for LINEAR_AXES >= 4
   extern xyze_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
-  extern abc_pos_t delta;
+  extern abce_pos_t delta;
 #endif
 
 #if HAS_ABL_NOT_UBL
   extern feedRate_t xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_FEEDRATE)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_FEEDRATE)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
@@ -68,30 +68,30 @@ extern xyz_pos_t cartes;
 #if HAS_BED_PROBE
   constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 constexpr xyz_feedrate_t homing_feedrate_mm_m = HOMING_FEEDRATE_MM_M;
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) {
-  float v;
-  #if ENABLED(DELTA)
-    v = homing_feedrate_mm_m.z;
-  #else
-    switch (a) {
-      case X_AXIS: v = homing_feedrate_mm_m.x; break;
-      case Y_AXIS: v = homing_feedrate_mm_m.y; break;
-      case Z_AXIS:
-          default: v = homing_feedrate_mm_m.z;
-    }
+  float v = TERN0(HAS_Z_AXIS, homing_feedrate_mm_m.z);
+  #if DISABLED(DELTA)
+    LINEAR_AXIS_CODE(
+           if (a == X_AXIS) v = homing_feedrate_mm_m.x,
+      else if (a == Y_AXIS) v = homing_feedrate_mm_m.y,
+      else if (a == Z_AXIS) v = homing_feedrate_mm_m.z,
+      else if (a == I_AXIS) v = homing_feedrate_mm_m.i,
+      else if (a == J_AXIS) v = homing_feedrate_mm_m.j,
+      else if (a == K_AXIS) v = homing_feedrate_mm_m.k
+    );
   #endif
   return MMM_TO_MMS(v);
 }
 
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 /**
  * The default feedrate for many moves, set by the most recent move
  */
 extern feedRate_t feedrate_mm_s;
@@ -117,21 +117,21 @@ extern int16_t feedrate_percentage;
   #define DEFS_PROGMEM
 #else
   #define DEFS_PROGMEM PROGMEM
 #endif
 
 inline float pgm_read_any(const float *p)   { return TERN(__IMXRT1062__, *p, pgm_read_float(p)); }
 inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm_read_byte(p)); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   inline T NAME(const AxisEnum axis) { \
-    static const XYZval<T> NAME##_P DEFS_PROGMEM = LINEAR_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT); \
+    static const XYZval<T> NAME##_P DEFS_PROGMEM = LINEAR_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT, I_##OPT, J_##OPT, K_##OPT); \
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
@@ -161,27 +161,50 @@ inline float home_bump_mm(const AxisEnum axis) {
 
     xyz_pos_t min, max;
     void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
       amin = -100000; amax = 100000; // "No limits"
       #if HAS_SOFTWARE_ENDSTOPS
         if (enabled()) switch (axis) {
           case X_AXIS:
             TERN_(MIN_SOFTWARE_ENDSTOP_X, amin = min.x);
             TERN_(MAX_SOFTWARE_ENDSTOP_X, amax = max.x);
             break;
-          case Y_AXIS:
-            TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
-            TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
-            break;
-          case Z_AXIS:
-            TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
-            TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
+          #if HAS_Y_AXIS
+            case Y_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
+              TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
+              break;
+          #endif
+          #if HAS_Z_AXIS
+            case Z_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
+              TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
+              break;
+          #endif
+          #if LINEAR_AXES >= 4 // TODO (DerAndere): Test for LINEAR_AXES >= 4
+            case I_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_I, amin = min.i);
+              TERN_(MIN_SOFTWARE_ENDSTOP_I, amax = max.i);
+              break;
+          #endif
+          #if LINEAR_AXES >= 5
+            case J_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_J, amin = min.j);
+              TERN_(MIN_SOFTWARE_ENDSTOP_J, amax = max.j);
+              break;
+          #endif
+          #if LINEAR_AXES >= 6
+            case K_AXIS:
+              TERN_(MIN_SOFTWARE_ENDSTOP_K, amin = min.k);
+              TERN_(MIN_SOFTWARE_ENDSTOP_K, amax = max.k);
+              break;
+          #endif
           default: break;
         }
       #endif
     }
   } soft_endstops_t;
 
   extern soft_endstops_t soft_endstop;
   void apply_motion_limits(xyz_pos_t &target);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
@@ -291,46 +314,67 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(
-  LINEAR_AXIS_LIST(const float rx, const float ry, const float rz),
-  const_feedRate_t fr_mm_s=0.0f
-);
+void do_blocking_move_to(LINEAR_AXIS_ARGS(const float), const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
-void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
-void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
+#if HAS_Y_AXIS
+  void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if HAS_Z_AXIS
+  void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if LINEAR_AXES >= 4
+  void do_blocking_move_to_i(const_float_t ri, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xyz_i(const xyze_pos_t &raw, const_float_t i, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if LINEAR_AXES >= 5
+  void do_blocking_move_to_j(const_float_t rj, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xyzi_j(const xyze_pos_t &raw, const_float_t j, const_feedRate_t fr_mm_s=0.0f);
+#endif
+#if LINEAR_AXES >= 6
+  void do_blocking_move_to_k(const_float_t rk, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xyzij_k(const xyze_pos_t &raw, const_float_t k, const_feedRate_t fr_mm_s=0.0f);
+#endif
 
-void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
-void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
-FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
-FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+#if HAS_Y_AXIS
+  void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
+  void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
+  FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+  FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+#endif
 
-void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
-FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
-FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+#if HAS_Z_AXIS
+  void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
+  FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+  FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+#endif
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
-void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
+#if HAS_Z_AXIS
+  void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
+#else
+  inline void do_z_clearance(float, bool=false) {}
+#endif
 
 /**
  * Homing and Trusted Axes
  */
 typedef IF<(LINEAR_AXES > 8), uint16_t, uint8_t>::type linear_axis_bits_t;
 constexpr linear_axis_bits_t linear_bits = _BV(LINEAR_AXES) - 1;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
@@ -414,25 +458,41 @@ FORCE_INLINE bool all_axes_trusted()                        { return linear_bits
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
   FORCE_INLINE void toLogical(xy_pos_t&)   {}
   FORCE_INLINE void toLogical(xyz_pos_t&)  {}
   FORCE_INLINE void toLogical(xyze_pos_t&) {}
   FORCE_INLINE void toNative(xy_pos_t&)    {}
   FORCE_INLINE void toNative(xyz_pos_t&)   {}
   FORCE_INLINE void toNative(xyze_pos_t&)  {}
 #endif
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
-#define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
-#define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
-#define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
-#define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
+#if HAS_Y_AXIS
+  #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
+  #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
+#endif
+#if HAS_Z_AXIS
+  #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
+  #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
+#endif
+#if LINEAR_AXES >= 4
+  #define LOGICAL_I_POSITION(POS) NATIVE_TO_LOGICAL(POS, I_AXIS)
+  #define RAW_I_POSITION(POS)     LOGICAL_TO_NATIVE(POS, I_AXIS)
+#endif
+#if LINEAR_AXES >= 5
+  #define LOGICAL_J_POSITION(POS) NATIVE_TO_LOGICAL(POS, J_AXIS)
+  #define RAW_J_POSITION(POS)     LOGICAL_TO_NATIVE(POS, J_AXIS)
+#endif
+#if LINEAR_AXES >= 6
+  #define LOGICAL_K_POSITION(POS) NATIVE_TO_LOGICAL(POS, K_AXIS)
+  #define RAW_K_POSITION(POS)     LOGICAL_TO_NATIVE(POS, K_AXIS)
+#endif
 
 /**
  * position_is_reachable family of functions
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 67205a7636..0706b721b3 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -117,21 +117,21 @@ extern int16_t feedrate_percentage;
   #define DEFS_PROGMEM
 #else
   #define DEFS_PROGMEM PROGMEM
 #endif
 
 inline float pgm_read_any(const float *p)   { return TERN(__IMXRT1062__, *p, pgm_read_float(p)); }
 inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm_read_byte(p)); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   inline T NAME(const AxisEnum axis) { \
-    static const XYZval<T> NAME##_P DEFS_PROGMEM = { X_##OPT, Y_##OPT, Z_##OPT }; \
+    static const XYZval<T> NAME##_P DEFS_PROGMEM = LINEAR_AXIS_ARRAY(X_##OPT, Y_##OPT, Z_##OPT); \
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
@@ -257,21 +257,24 @@ void report_current_position_projected();
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 void quickstop_stepper();
 
 /**
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
-void sync_plan_position_e();
+
+#if HAS_EXTRUDERS
+  void sync_plan_position_e();
+#endif
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s=feedrate_mm_s);
 
 #if HAS_EXTRUDERS
   void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s);
 #endif
@@ -288,21 +291,24 @@ inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f)
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(
+  LINEAR_AXIS_LIST(const float rx, const float ry, const float rz),
+  const_feedRate_t fr_mm_s=0.0f
+);
 void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
 
 void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
 void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
@@ -315,21 +321,21 @@ FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 
 /**
  * Homing and Trusted Axes
  */
-typedef IF<(LINEAR_AXES>8), uint16_t, uint8_t>::type linear_axis_bits_t;
+typedef IF<(LINEAR_AXES > 8), uint16_t, uint8_t>::type linear_axis_bits_t;
 constexpr linear_axis_bits_t linear_bits = _BV(LINEAR_AXES) - 1;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
    * axis_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a43af6446b..67205a7636 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -271,25 +271,21 @@ void sync_plan_position_e();
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s=feedrate_mm_s);
 
 #if HAS_EXTRUDERS
   void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s);
 #endif
 
 void prepare_line_to_destination();
 
-void _internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f
-  #if IS_KINEMATIC
-    , const bool is_fast=false
-  #endif
-);
+void _internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f OPTARG(IS_KINEMATIC, const bool is_fast=false));
 
 inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
   _internal_move_to_destination(fr_mm_s);
 }
 
 #if IS_KINEMATIC
   void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
   inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 3c6f044b21..a43af6446b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -265,21 +265,21 @@ void quickstop_stepper();
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const_feedRate_t fr_mm_s=feedrate_mm_s);
 
-#if EXTRUDERS
+#if HAS_EXTRUDERS
   void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s);
 #endif
 
 void prepare_line_to_destination();
 
 void _internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f
   #if IS_KINEMATIC
     , const bool is_fast=false
   #endif
 );

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    üé® Flags for homing directions

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 15713e6d4d..3c6f044b21 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -510,35 +510,35 @@ FORCE_INLINE bool all_axes_trusted()                        { return linear_bits
   extern xyz_pos_t raised_parked_position;          // Used in mode 1
   extern bool active_extruder_parked;               // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;                // Used in mode 1
   extern celsius_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
   extern bool idex_mirrored_mode;                   // Used in mode 3
 
   FORCE_INLINE bool idex_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const uint8_t extruder);
 
-  FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
+  #define TOOL_X_HOME_DIR(T) ((T) ? X2_HOME_DIR : X_HOME_DIR)
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index=-1);
   void idex_set_mirrored_mode(const bool mirr);
   void idex_set_parked(const bool park=true);
 
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
     FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
-  FORCE_INLINE int x_home_dir(const uint8_t) { return X_HOME_DIR; }
+  #define TOOL_X_HOME_DIR(T) X_HOME_DIR
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
 #if USE_SENSORLESS
   struct sensorless_t;
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis);

commit 458677c63a3f9ae32c988e2ab10d8f3a0935bf50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:56:05 2021 -0500

    ‚ôªÔ∏è Refactor axis homing/trusted state bits

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e01978c852..15713e6d4d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -319,66 +319,67 @@ FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 
 /**
  * Homing and Trusted Axes
  */
-constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
+typedef IF<(LINEAR_AXES>8), uint16_t, uint8_t>::type linear_axis_bits_t;
+constexpr linear_axis_bits_t linear_bits = _BV(LINEAR_AXES) - 1;
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
    * axis_homed
    *   Flags that each linear axis was homed.
    *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    *
    * axis_trusted
    *   Flags that the position is trusted in each linear axis. Set when homed.
    *   Cleared whenever a stepper powers off, potentially losing its position.
    */
-  extern uint8_t axis_homed, axis_trusted;
+  extern linear_axis_bits_t axis_homed, axis_trusted;
   void homeaxis(const AxisEnum axis);
   void set_axis_never_homed(const AxisEnum axis);
-  uint8_t axes_should_home(uint8_t axis_bits=0x07);
-  bool homing_needed_error(uint8_t axis_bits=0x07);
+  linear_axis_bits_t axes_should_home(linear_axis_bits_t axis_bits=linear_bits);
+  bool homing_needed_error(linear_axis_bits_t axis_bits=linear_bits);
   FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
   FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
   FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
   FORCE_INLINE void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
   FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
-  FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = xyz_bits; }
+  FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = linear_bits; }
 #else
-  constexpr uint8_t axis_homed = xyz_bits, axis_trusted = xyz_bits; // Zero-endstop machines are always homed and trusted
+  constexpr linear_axis_bits_t axis_homed = linear_bits, axis_trusted = linear_bits; // Zero-endstop machines are always homed and trusted
   FORCE_INLINE void homeaxis(const AxisEnum axis)           {}
   FORCE_INLINE void set_axis_never_homed(const AxisEnum)    {}
-  FORCE_INLINE uint8_t axes_should_home(uint8_t=0x07)       { return false; }
-  FORCE_INLINE bool homing_needed_error(uint8_t=0x07)       { return false; }
+  FORCE_INLINE linear_axis_bits_t axes_should_home(linear_axis_bits_t=linear_bits) { return false; }
+  FORCE_INLINE bool homing_needed_error(linear_axis_bits_t=linear_bits) { return false; }
   FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   {}
   FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) {}
   FORCE_INLINE void set_all_unhomed()                       {}
   FORCE_INLINE void set_axis_homed(const AxisEnum axis)     {}
   FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   {}
   FORCE_INLINE void set_all_homed()                         {}
 #endif
 
 FORCE_INLINE bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }
 FORCE_INLINE bool axis_is_trusted(const AxisEnum axis)      { return TEST(axis_trusted, axis); }
 FORCE_INLINE bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
 FORCE_INLINE bool no_axes_homed()                           { return !axis_homed; }
-FORCE_INLINE bool all_axes_homed()                          { return xyz_bits == (axis_homed & xyz_bits); }
+FORCE_INLINE bool all_axes_homed()                          { return linear_bits == (axis_homed & linear_bits); }
 FORCE_INLINE bool homing_needed()                           { return !all_axes_homed(); }
-FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits == (axis_trusted & xyz_bits); }
+FORCE_INLINE bool all_axes_trusted()                        { return linear_bits == (axis_trusted & linear_bits); }
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 #define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))
 
 /**

commit 7f774cab9005dd56667bf4db09c23370bd2c873f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Sat May 15 15:02:20 2021 -0500

    M154 Position Auto-Report (#18427)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c734fbdf34..e01978c852 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -204,20 +204,26 @@ inline float home_bump_mm(const AxisEnum axis) {
   #define apply_motion_limits(V)        NOOP
   #define update_software_endstops(...) NOOP
   #define SET_SOFT_ENDSTOP_LOOSE(V)     NOOP
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
+#if ENABLED(AUTO_REPORT_POSITION)
+  #include "../libs/autoreport.h"
+  struct PositionReport { static void report() { report_current_position_projected(); } };
+  extern AutoReporter<PositionReport> position_auto_reporter;
+#endif
+
 #if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
   #define HAS_GRBL_STATE 1
   /**
    * Machine states for GRBL or TinyG
    */
   enum M_StateEnum : uint8_t {
     M_INIT = 0, //  0 machine is initializing
     M_RESET,    //  1 machine is ready for use
     M_ALARM,    //  2 machine is in alarm state (soft shut down)
     M_IDLE,     //  3 program stop or no more blocks (M0, M1, M60)

commit 0d629c80c7e218cbe07a85ba0d9bfeb49feb65c6
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Wed May 12 10:17:06 2021 +0300

    ü©π G60-G61 Save E position (#21810)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 647b3af52a..c734fbdf34 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -38,21 +38,21 @@
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
   extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
-  extern xyz_pos_t stored_position[SAVED_POSITIONS];
+  extern xyze_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abc_pos_t delta;
 #endif
 

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2cfc8406a5..647b3af52a 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -204,28 +204,63 @@ inline float home_bump_mm(const AxisEnum axis) {
   #define apply_motion_limits(V)        NOOP
   #define update_software_endstops(...) NOOP
   #define SET_SOFT_ENDSTOP_LOOSE(V)     NOOP
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
+#if EITHER(FULL_REPORT_TO_HOST_FEATURE, REALTIME_REPORTING_COMMANDS)
+  #define HAS_GRBL_STATE 1
+  /**
+   * Machine states for GRBL or TinyG
+   */
+  enum M_StateEnum : uint8_t {
+    M_INIT = 0, //  0 machine is initializing
+    M_RESET,    //  1 machine is ready for use
+    M_ALARM,    //  2 machine is in alarm state (soft shut down)
+    M_IDLE,     //  3 program stop or no more blocks (M0, M1, M60)
+    M_END,      //  4 program end via M2, M30
+    M_RUNNING,  //  5 motion is running
+    M_HOLD,     //  6 motion is holding
+    M_PROBE,    //  7 probe cycle active
+    M_CYCLING,  //  8 machine is running (cycling)
+    M_HOMING,   //  9 machine is homing
+    M_JOGGING,  // 10 machine is jogging
+    M_ERROR     // 11 machine is in hard alarm state (shut down)
+  };
+  extern M_StateEnum M_State_grbl;
+  M_StateEnum grbl_state_for_marlin_state();
+  void report_current_grblstate_moving();
+  void report_current_position_moving();
+
+  #if ENABLED(FULL_REPORT_TO_HOST_FEATURE)
+    inline void set_and_report_grblstate(const M_StateEnum state) {
+      M_State_grbl = state;
+      report_current_grblstate_moving();
+    }
+  #endif
+
+  #if ENABLED(REALTIME_REPORTING_COMMANDS)
+    void quickpause_stepper();
+    void quickresume_stepper();
+  #endif
+#endif
+
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 void quickstop_stepper();
 
 /**
- * sync_plan_position
- *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7b8d2f2018..2cfc8406a5 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -222,72 +222,72 @@ void quickstop_stepper();
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position(const feedRate_t &fr_mm_s=feedrate_mm_s);
+void line_to_current_position(const_feedRate_t fr_mm_s=feedrate_mm_s);
 
 #if EXTRUDERS
-  void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s);
+  void unscaled_e_move(const_float_t length, const_feedRate_t fr_mm_s);
 #endif
 
 void prepare_line_to_destination();
 
-void _internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f
+void _internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f
   #if IS_KINEMATIC
     , const bool is_fast=false
   #endif
 );
 
-inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
+inline void prepare_internal_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
   _internal_move_to_destination(fr_mm_s);
 }
 
 #if IS_KINEMATIC
-  void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
+  void prepare_fast_move_to_destination(const_feedRate_t scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
-  inline void prepare_internal_fast_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
+  inline void prepare_internal_fast_move_to_destination(const_feedRate_t fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to(const float rx, const float ry, const float rz, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
 
-void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_x(const_float_t rx, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to_y(const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to_z(const_float_t rz, const_feedRate_t fr_mm_s=0.0f);
 
-void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
-FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
-FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+void do_blocking_move_to_xy(const_float_t rx, const_float_t ry, const_feedRate_t fr_mm_s=0.0f);
+void do_blocking_move_to_xy(const xy_pos_t &raw, const_feedRate_t fr_mm_s=0.0f);
+FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 
-void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f);
-FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
-FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+void do_blocking_move_to_xy_z(const xy_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f);
+FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const_float_t z, const_feedRate_t fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
-void do_z_clearance(const float &zclear, const bool lower_allowed=false);
+void do_z_clearance(const_float_t zclear, const bool lower_allowed=false);
 
 /**
  * Homing and Trusted Axes
  */
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**
@@ -386,21 +386,21 @@ FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits ==
 /**
  * position_is_reachable family of functions
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
-  inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
+  inline bool position_is_reachable(const_float_t rx, const_float_t ry, const float inset=0) {
     #if ENABLED(DELTA)
 
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
 
     #elif ENABLED(AXEL_TPARA)
 
       const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
@@ -421,21 +421,21 @@ FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits ==
     #endif
   }
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
-  inline bool position_is_reachable(const float &rx, const float &ry) {
+  inline bool position_is_reachable(const_float_t rx, const_float_t ry) {
     if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
       else
         return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
       return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
     #endif
   }

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 0328d015a4..7b8d2f2018 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -456,27 +456,27 @@ FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits ==
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
     DXC_DUPLICATION_MODE,
     DXC_MIRRORED_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
-  extern float inactive_extruder_x,               // Used in mode 0 & 1
-               duplicate_extruder_x_offset;       // Used in mode 2 & 3
-  extern xyz_pos_t raised_parked_position;        // Used in mode 1
-  extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
-  extern millis_t delayed_move_time;              // Used in mode 1
-  extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
-  extern bool idex_mirrored_mode;                 // Used in mode 3
+  extern float inactive_extruder_x,                 // Used in mode 0 & 1
+               duplicate_extruder_x_offset;         // Used in mode 2 & 3
+  extern xyz_pos_t raised_parked_position;          // Used in mode 1
+  extern bool active_extruder_parked;               // Used in mode 1, 2 & 3
+  extern millis_t delayed_move_time;                // Used in mode 1
+  extern celsius_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
+  extern bool idex_mirrored_mode;                   // Used in mode 3
 
   FORCE_INLINE bool idex_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const uint8_t extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index=-1);
   void idex_set_mirrored_mode(const bool mirr);
   void idex_set_parked(const bool park=true);

commit a46e0257252bcd50f4c7acb04215f3ad2a92047c
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Mar 3 20:46:32 2021 -0300

    TPARA - 3DOF robot arm IK (#21005)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f784c7bf80..0328d015a4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -388,29 +388,43 @@ FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits ==
  */
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
+
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
+
+    #elif ENABLED(AXEL_TPARA)
+
+      const float R2 = HYPOT2(rx - TPARA_OFFSET_X, ry - TPARA_OFFSET_Y);
+      return (
+        R2 <= sq(L1 + L2) - inset
+        #if MIDDLE_DEAD_ZONE_R > 0
+          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+        #endif
+      );
+
     #elif IS_SCARA
+
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
+
     #endif
   }
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.

commit dfa33082bbe7cdf2888349a301cfd6636430cd0a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 1 07:10:00 2021 -0600

    Fix some config builds

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2595084b4a..f784c7bf80 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -58,21 +58,23 @@ extern xyz_pos_t cartes;
 
 #if HAS_ABL_NOT_UBL
   extern feedRate_t xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_FEEDRATE)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_FEEDRATE)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
-constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
+#if HAS_BED_PROBE
+  constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
+#endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 constexpr xyz_feedrate_t homing_feedrate_mm_m = HOMING_FEEDRATE_MM_M;
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) {
   float v;
   #if ENABLED(DELTA)
     v = homing_feedrate_mm_m.z;

commit ee7701c15bc91f7a05f973e03624fb14815f5027
Author: jbuck2005 <59450931+jbuck2005@users.noreply.github.com>
Date:   Sat Feb 27 16:54:43 2021 -0500

    SPEED => FEEDRATE (#21217)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c8fb2c639b..2595084b4a 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -52,27 +52,27 @@ extern xyze_pos_t current_position,  // High-level current tool position
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abc_pos_t delta;
 #endif
 
 #if HAS_ABL_NOT_UBL
   extern feedRate_t xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
-#elif defined(XY_PROBE_SPEED)
-  #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
+#elif defined(XY_PROBE_FEEDRATE)
+  #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_FEEDRATE)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
-constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_SPEED_FAST);
+constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_FEEDRATE_FAST);
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 constexpr xyz_feedrate_t homing_feedrate_mm_m = HOMING_FEEDRATE_MM_M;
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) {
   float v;
   #if ENABLED(DELTA)
     v = homing_feedrate_mm_m.z;

commit bcda46e3f3435a1f87d224be2f81778c1855deb7
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Feb 25 17:09:00 2021 +0100

    Combine Z_AFTER_DEACTIVATE with UNKNOWN_Z_NO_RAISE (#20444)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2a23636d71..c8fb2c639b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -271,21 +271,21 @@ FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t
 FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f);
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
-void do_z_clearance(const float &zclear, const bool z_trusted=true, const bool raise_on_untrusted=true, const bool lower_allowed=false);
+void do_z_clearance(const float &zclear, const bool lower_allowed=false);
 
 /**
  * Homing and Trusted Axes
  */
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 #if HAS_ENDSTOPS
   /**

commit 468e437390afdb1de7059e7f9049d0b30c312024
Author: deirdreobyrne <deirdre.dub@gmail.com>
Date:   Thu Feb 25 10:49:34 2021 +0000

    Allow Zero Endstops (e.g., for CNC) (#21120)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 328bfe018d..2a23636d71 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -277,41 +277,65 @@ FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 void do_z_clearance(const float &zclear, const bool z_trusted=true, const bool raise_on_untrusted=true, const bool lower_allowed=false);
 
 /**
  * Homing and Trusted Axes
  */
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
-extern uint8_t axis_homed, axis_trusted;
 
-void homeaxis(const AxisEnum axis);
 void set_axis_is_at_home(const AxisEnum axis);
-void set_axis_never_homed(const AxisEnum axis);
-uint8_t axes_should_home(uint8_t axis_bits=0x07);
-bool homing_needed_error(uint8_t axis_bits=0x07);
-
-FORCE_INLINE bool axis_was_homed(const AxisEnum axis)     { return TEST(axis_homed, axis); }
-FORCE_INLINE bool axis_is_trusted(const AxisEnum axis)    { return TEST(axis_trusted, axis); }
-FORCE_INLINE bool axis_should_home(const AxisEnum axis)   { return (axes_should_home() & _BV(axis)) != 0; }
-FORCE_INLINE bool no_axes_homed()                         { return !axis_homed; }
-FORCE_INLINE bool all_axes_homed()                        { return xyz_bits == (axis_homed & xyz_bits); }
-FORCE_INLINE bool homing_needed()                         { return !all_axes_homed(); }
-FORCE_INLINE bool all_axes_trusted()                      { return xyz_bits == (axis_trusted & xyz_bits); }
-FORCE_INLINE void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
-FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
-FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
-FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
-FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = xyz_bits; }
-FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
+
+#if HAS_ENDSTOPS
+  /**
+   * axis_homed
+   *   Flags that each linear axis was homed.
+   *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
+   *
+   * axis_trusted
+   *   Flags that the position is trusted in each linear axis. Set when homed.
+   *   Cleared whenever a stepper powers off, potentially losing its position.
+   */
+  extern uint8_t axis_homed, axis_trusted;
+  void homeaxis(const AxisEnum axis);
+  void set_axis_never_homed(const AxisEnum axis);
+  uint8_t axes_should_home(uint8_t axis_bits=0x07);
+  bool homing_needed_error(uint8_t axis_bits=0x07);
+  FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
+  FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
+  FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
+  FORCE_INLINE void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
+  FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
+  FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = xyz_bits; }
+#else
+  constexpr uint8_t axis_homed = xyz_bits, axis_trusted = xyz_bits; // Zero-endstop machines are always homed and trusted
+  FORCE_INLINE void homeaxis(const AxisEnum axis)           {}
+  FORCE_INLINE void set_axis_never_homed(const AxisEnum)    {}
+  FORCE_INLINE uint8_t axes_should_home(uint8_t=0x07)       { return false; }
+  FORCE_INLINE bool homing_needed_error(uint8_t=0x07)       { return false; }
+  FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   {}
+  FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) {}
+  FORCE_INLINE void set_all_unhomed()                       {}
+  FORCE_INLINE void set_axis_homed(const AxisEnum axis)     {}
+  FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   {}
+  FORCE_INLINE void set_all_homed()                         {}
+#endif
+
+FORCE_INLINE bool axis_was_homed(const AxisEnum axis)       { return TEST(axis_homed, axis); }
+FORCE_INLINE bool axis_is_trusted(const AxisEnum axis)      { return TEST(axis_trusted, axis); }
+FORCE_INLINE bool axis_should_home(const AxisEnum axis)     { return (axes_should_home() & _BV(axis)) != 0; }
+FORCE_INLINE bool no_axes_homed()                           { return !axis_homed; }
+FORCE_INLINE bool all_axes_homed()                          { return xyz_bits == (axis_homed & xyz_bits); }
+FORCE_INLINE bool homing_needed()                           { return !all_axes_homed(); }
+FORCE_INLINE bool all_axes_trusted()                        { return xyz_bits == (axis_trusted & xyz_bits); }
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 #define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))
 
 /**
@@ -353,21 +377,20 @@ FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_tr
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
 #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
 #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
-
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
@@ -383,28 +406,28 @@ FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_tr
   }
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
-    if (!WITHIN(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
+    if (!COORDINATE_OKAY(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
-        return WITHIN(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
+        return COORDINATE_OKAY(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
       else
-        return WITHIN(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
+        return COORDINATE_OKAY(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
-      return WITHIN(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
+      return COORDINATE_OKAY(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
     #endif
   }
   inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
 #endif // CARTESIAN
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE

commit 7e172bf456ea52ce1a4206d1184e18745515039d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 16 21:13:53 2021 -0600

    Fix IDEX broken endstop test (#21110)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 887da1aa18..328bfe018d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -443,21 +443,21 @@ FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_tr
   void idex_set_parked(const bool park=true);
 
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
     FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
-  FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }
+  FORCE_INLINE int x_home_dir(const uint8_t) { return X_HOME_DIR; }
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
 #if USE_SENSORLESS
   struct sensorless_t;
   sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis);

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9352a4e4e6..887da1aa18 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -205,20 +205,22 @@ inline float home_bump_mm(const AxisEnum axis) {
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
+void quickstop_stepper();
+
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**

commit ba2cadb47934fa83f576aece2c45f1b6cb5829cf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 3 22:23:13 2021 -0600

    Move duplication_e_mask

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 18d8aa9f2e..9352a4e4e6 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -400,23 +400,20 @@ FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_tr
   }
   inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
 #endif // CARTESIAN
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
-  #if ENABLED(MULTI_NOZZLE_DUPLICATION)
-    extern uint8_t duplication_e_mask;
-  #endif
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
@@ -439,20 +436,21 @@ FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_tr
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
   void set_duplication_enabled(const bool dupe, const int8_t tool_index=-1);
   void idex_set_mirrored_mode(const bool mirr);
   void idex_set_parked(const bool park=true);
 
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
+    extern uint8_t duplication_e_mask;
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
     FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
   FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);

commit fbcc07261d944222cca30ef8590fb387f53fcc70
Author: rafaljot <rafal@jastrzebscy.org>
Date:   Thu Dec 17 13:02:05 2020 +0100

    Homing feedrates as XYZ array (#20426)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2eb54f36fb..18d8aa9f2e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -50,34 +50,50 @@ extern xyze_pos_t current_position,  // High-level current tool position
 
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abc_pos_t delta;
 #endif
 
 #if HAS_ABL_NOT_UBL
-  extern float xy_probe_feedrate_mm_s;
+  extern feedRate_t xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
+constexpr feedRate_t z_probe_fast_mm_s = MMM_TO_MMS(Z_PROBE_SPEED_FAST);
+
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
-extern const feedRate_t homing_feedrate_mm_s[XYZ];
-FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
+constexpr xyz_feedrate_t homing_feedrate_mm_m = HOMING_FEEDRATE_MM_M;
+FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) {
+  float v;
+  #if ENABLED(DELTA)
+    v = homing_feedrate_mm_m.z;
+  #else
+    switch (a) {
+      case X_AXIS: v = homing_feedrate_mm_m.x; break;
+      case Y_AXIS: v = homing_feedrate_mm_m.y; break;
+      case Z_AXIS:
+          default: v = homing_feedrate_mm_m.z;
+    }
+  #endif
+  return MMM_TO_MMS(v);
+}
+
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 /**
  * The default feedrate for many moves, set by the most recent move
  */
 extern feedRate_t feedrate_mm_s;
 
 /**
  * Feedrate scaling is applied to all G0/G1, G2/G3, and G5 moves
  */

commit 20b3af1cc2c4a5e8505d1aae3419ab9418ed88ab
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 16 22:18:40 2020 -0600

    Use homing_feedrate function

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index efbfd7de4d..2eb54f36fb 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -66,26 +66,30 @@ extern xyz_pos_t cartes;
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 extern const feedRate_t homing_feedrate_mm_s[XYZ];
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
+/**
+ * The default feedrate for many moves, set by the most recent move
+ */
 extern feedRate_t feedrate_mm_s;
 
 /**
- * Feedrate scaling
+ * Feedrate scaling is applied to all G0/G1, G2/G3, and G5 moves
  */
 extern int16_t feedrate_percentage;
+#define MMS_SCALED(V) ((V) * 0.01f * feedrate_percentage)
 
 // The active extruder (tool). Set with T<extruder> command.
 #if HAS_MULTI_EXTRUDER
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   extern float e_move_accumulator;

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index abc59f92b8..efbfd7de4d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -27,33 +27,20 @@
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "scara.h"
 #endif
 
-// Axis homed and known-position states
-extern uint8_t axis_homed, axis_known_position;
-constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
-FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
-FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
-FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
-FORCE_INLINE void set_all_homed() { axis_homed = axis_known_position = xyz_bits; }
-FORCE_INLINE void set_all_unhomed() { axis_homed = axis_known_position = 0; }
-
-FORCE_INLINE bool homing_needed() {
-  return !TERN(HOME_AFTER_DEACTIVATE, all_axes_known, all_axes_homed)();
-}
-
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
@@ -262,37 +249,56 @@ FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t
 FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f);
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
-void do_z_clearance(const float &zclear, const bool z_known=true, const bool raise_on_unknown=true, const bool lower_allowed=false);
+void do_z_clearance(const float &zclear, const bool z_trusted=true, const bool raise_on_untrusted=true, const bool lower_allowed=false);
+
+/**
+ * Homing and Trusted Axes
+ */
+constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
+extern uint8_t axis_homed, axis_trusted;
 
-//
-// Homing
-//
 void homeaxis(const AxisEnum axis);
 void set_axis_is_at_home(const AxisEnum axis);
 void set_axis_never_homed(const AxisEnum axis);
 uint8_t axes_should_home(uint8_t axis_bits=0x07);
 bool homing_needed_error(uint8_t axis_bits=0x07);
 
+FORCE_INLINE bool axis_was_homed(const AxisEnum axis)     { return TEST(axis_homed, axis); }
+FORCE_INLINE bool axis_is_trusted(const AxisEnum axis)    { return TEST(axis_trusted, axis); }
+FORCE_INLINE bool axis_should_home(const AxisEnum axis)   { return (axes_should_home() & _BV(axis)) != 0; }
+FORCE_INLINE bool no_axes_homed()                         { return !axis_homed; }
+FORCE_INLINE bool all_axes_homed()                        { return xyz_bits == (axis_homed & xyz_bits); }
+FORCE_INLINE bool homing_needed()                         { return !all_axes_homed(); }
+FORCE_INLINE bool all_axes_trusted()                      { return xyz_bits == (axis_trusted & xyz_bits); }
+FORCE_INLINE void set_axis_homed(const AxisEnum axis)     { SBI(axis_homed, axis); }
+FORCE_INLINE void set_axis_unhomed(const AxisEnum axis)   { CBI(axis_homed, axis); }
+FORCE_INLINE void set_axis_trusted(const AxisEnum axis)   { SBI(axis_trusted, axis); }
+FORCE_INLINE void set_axis_untrusted(const AxisEnum axis) { CBI(axis_trusted, axis); }
+FORCE_INLINE void set_all_homed()                         { axis_homed = axis_trusted = xyz_bits; }
+FORCE_INLINE void set_all_unhomed()                       { axis_homed = axis_trusted = 0; }
+
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
+#define BABYSTEP_ALLOWED() ((ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_trusted()) && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()))
+
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern xyz_pos_t home_offset;
   #endif
   #if HAS_POSITION_SHIFT
     extern xyz_pos_t position_shift;
   #endif

commit 6375829448eebe01b2835689aac69b73b63ebfd8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 18 16:53:12 2020 -0400

    Apply home offsets to probing, Z Safe Homing (#19423)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5a8a8e0045..abc59f92b8 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -71,24 +71,20 @@ extern xyz_pos_t cartes;
 
 #if HAS_ABL_NOT_UBL
   extern float xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
-#if ENABLED(Z_SAFE_HOMING)
-  constexpr xy_float_t safe_homing_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
-#endif
-
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 extern const feedRate_t homing_feedrate_mm_s[XYZ];
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 extern feedRate_t feedrate_mm_s;
 

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 85b70c057a..5a8a8e0045 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -377,57 +377,62 @@ bool homing_needed_error(uint8_t axis_bits=0x07);
     #endif
   }
   inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
 #endif // CARTESIAN
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
-  extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
-              mirrored_duplication_mode;          // Used in Dual X mode 3
+  extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
   #endif
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
     DXC_DUPLICATION_MODE,
     DXC_MIRRORED_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
-  extern float inactive_extruder_x_pos,           // Used in mode 0 & 1
+  extern float inactive_extruder_x,               // Used in mode 0 & 1
                duplicate_extruder_x_offset;       // Used in mode 2 & 3
   extern xyz_pos_t raised_parked_position;        // Used in mode 1
   extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // Used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
+  extern bool idex_mirrored_mode;                 // Used in mode 3
 
-  FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
+  FORCE_INLINE bool idex_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const uint8_t extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
+  void set_duplication_enabled(const bool dupe, const int8_t tool_index=-1);
+  void idex_set_mirrored_mode(const bool mirr);
+  void idex_set_parked(const bool park=true);
+
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
+    FORCE_INLINE void set_duplication_enabled(const bool dupe) { extruder_duplication_enabled = dupe; }
   #endif
 
   FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 

commit 9a23fb58639dec170d41415976293793131b667a
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Oct 14 11:50:03 2020 -0700

    Fix SET_SOFT_ENDSTOP_LOOSE w/out soft endstops (#19734)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 550168e8a8..85b70c057a 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -191,21 +191,21 @@ inline float home_bump_mm(const AxisEnum axis) {
     bool enabled() { return false; }
     void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
       // No limits
       amin = current_position[axis] - 1000;
       amax = current_position[axis] + 1000;
     }
   } soft_endstops_t;
   extern soft_endstops_t soft_endstop;
   #define apply_motion_limits(V)        NOOP
   #define update_software_endstops(...) NOOP
-  #define SET_SOFT_ENDSTOP_LOOSE()      NOOP
+  #define SET_SOFT_ENDSTOP_LOOSE(V)     NOOP
 
 #endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 

commit 733eb127e9abb6910f4cc0f1adabb4c696eeb571
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 13 14:54:56 2020 -0500

    Simple bool in soft_endstops_t

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 338eb387cf..550168e8a8 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -144,26 +144,24 @@ inline float home_bump_mm(const AxisEnum axis) {
   void reset_hotend_offsets();
 #elif HOTENDS
   constexpr xyz_pos_t hotend_offset[HOTENDS] = { { 0 } };
 #else
   constexpr xyz_pos_t hotend_offset[1] = { { 0 } };
 #endif
 
 #if HAS_SOFTWARE_ENDSTOPS
 
   typedef struct {
-    xyz_pos_t min, max;
-    struct {
-      bool _enabled:1;
-      bool _loose:1;
-    };
+    bool _enabled, _loose;
     bool enabled() { return _enabled && !_loose; }
+
+    xyz_pos_t min, max;
     void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
       amin = -100000; amax = 100000; // "No limits"
       #if HAS_SOFTWARE_ENDSTOPS
         if (enabled()) switch (axis) {
           case X_AXIS:
             TERN_(MIN_SOFTWARE_ENDSTOP_X, amin = min.x);
             TERN_(MAX_SOFTWARE_ENDSTOP_X, amax = max.x);
             break;
           case Y_AXIS:
             TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2b108b0531..338eb387cf 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -141,40 +141,75 @@ inline float home_bump_mm(const AxisEnum axis) {
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS
   constexpr xyz_pos_t hotend_offset[HOTENDS] = { { 0 } };
 #else
   constexpr xyz_pos_t hotend_offset[1] = { { 0 } };
 #endif
 
-typedef struct { xyz_pos_t min, max; } axis_limits_t;
 #if HAS_SOFTWARE_ENDSTOPS
-  extern bool soft_endstops_enabled;
-  extern axis_limits_t soft_endstop;
+
+  typedef struct {
+    xyz_pos_t min, max;
+    struct {
+      bool _enabled:1;
+      bool _loose:1;
+    };
+    bool enabled() { return _enabled && !_loose; }
+    void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
+      amin = -100000; amax = 100000; // "No limits"
+      #if HAS_SOFTWARE_ENDSTOPS
+        if (enabled()) switch (axis) {
+          case X_AXIS:
+            TERN_(MIN_SOFTWARE_ENDSTOP_X, amin = min.x);
+            TERN_(MAX_SOFTWARE_ENDSTOP_X, amax = max.x);
+            break;
+          case Y_AXIS:
+            TERN_(MIN_SOFTWARE_ENDSTOP_Y, amin = min.y);
+            TERN_(MAX_SOFTWARE_ENDSTOP_Y, amax = max.y);
+            break;
+          case Z_AXIS:
+            TERN_(MIN_SOFTWARE_ENDSTOP_Z, amin = min.z);
+            TERN_(MAX_SOFTWARE_ENDSTOP_Z, amax = max.z);
+          default: break;
+        }
+      #endif
+    }
+  } soft_endstops_t;
+
+  extern soft_endstops_t soft_endstop;
   void apply_motion_limits(xyz_pos_t &target);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0
     #endif
   );
-  #define TEMPORARY_SOFT_ENDSTOP_STATE(enable) REMEMBER(tes, soft_endstops_enabled, enable);
-#else
-  constexpr bool soft_endstops_enabled = false;
-  //constexpr axis_limits_t soft_endstop = {
-  //  { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
-  //  { X_MAX_POS, Y_MAX_POS, Z_MAX_POS } };
-  #define apply_motion_limits(V)    NOOP
+  #define SET_SOFT_ENDSTOP_LOOSE(loose) (soft_endstop._loose = loose)
+
+#else // !HAS_SOFTWARE_ENDSTOPS
+
+  typedef struct {
+    bool enabled() { return false; }
+    void get_manual_axis_limits(const AxisEnum axis, float &amin, float &amax) {
+      // No limits
+      amin = current_position[axis] - 1000;
+      amax = current_position[axis] + 1000;
+    }
+  } soft_endstops_t;
+  extern soft_endstops_t soft_endstop;
+  #define apply_motion_limits(V)        NOOP
   #define update_software_endstops(...) NOOP
-  #define TEMPORARY_SOFT_ENDSTOP_STATE(...) NOOP
-#endif
+  #define SET_SOFT_ENDSTOP_LOOSE()      NOOP
+
+#endif // !HAS_SOFTWARE_ENDSTOPS
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 052e3180c8..2b108b0531 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -91,21 +91,21 @@ FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_floa
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 extern feedRate_t feedrate_mm_s;
 
 /**
  * Feedrate scaling
  */
 extern int16_t feedrate_percentage;
 
 // The active extruder (tool). Set with T<extruder> command.
-#if EXTRUDERS > 1
+#if HAS_MULTI_EXTRUDER
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   extern float e_move_accumulator;
 #endif
 
 #ifdef __IMXRT1062__

commit 049fbc92a99d83178a5b99b14539b4ceeba8d5d4
Author: bilsef <bilsef1@gmail.com>
Date:   Wed Sep 9 16:57:20 2020 -0700

    Support for Teensy 4 (#19311)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c3f2d9b779..052e3180c8 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -101,36 +101,42 @@ extern int16_t feedrate_percentage;
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   extern float e_move_accumulator;
 #endif
 
-inline float pgm_read_any(const float *p) { return pgm_read_float(p); }
-inline signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
+#ifdef __IMXRT1062__
+  #define DEFS_PROGMEM
+#else
+  #define DEFS_PROGMEM PROGMEM
+#endif
+
+inline float pgm_read_any(const float *p)   { return TERN(__IMXRT1062__, *p, pgm_read_float(p)); }
+inline int8_t pgm_read_any(const int8_t *p) { return TERN(__IMXRT1062__, *p, pgm_read_byte(p)); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   inline T NAME(const AxisEnum axis) { \
-    static const XYZval<T> NAME##_P PROGMEM = { X_##OPT, Y_##OPT, Z_##OPT }; \
+    static const XYZval<T> NAME##_P DEFS_PROGMEM = { X_##OPT, Y_##OPT, Z_##OPT }; \
     return pgm_read_any(&NAME##_P[axis]); \
   }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
-XYZ_DEFS(signed char, home_dir, HOME_DIR);
+XYZ_DEFS(int8_t, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
-  static const xyz_pos_t home_bump_mm_P PROGMEM = HOMING_BUMP_MM;
+  static const xyz_pos_t home_bump_mm_P DEFS_PROGMEM = HOMING_BUMP_MM;
   return pgm_read_any(&home_bump_mm_P[axis]);
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   inline void update_workspace_offset(const AxisEnum) {}
 #endif
 
 #if HAS_HOTEND_OFFSET

commit e0b413cf19af87e73b0476daaddf395817db9b35
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 27 16:38:02 2020 -0500

    Add set_all_homed

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index d71003906f..c3f2d9b779 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -33,20 +33,21 @@
 #if IS_SCARA
   #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
+FORCE_INLINE void set_all_homed() { axis_homed = axis_known_position = xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
   return !TERN(HOME_AFTER_DEACTIVATE, all_axes_known, all_axes_homed)();
 }
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1a0971d281..d71003906f 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -33,22 +33,21 @@
 #if IS_SCARA
   #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
-FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
-FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
+FORCE_INLINE void set_all_unhomed() { axis_homed = axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
   return !TERN(HOME_AFTER_DEACTIVATE, all_axes_known, all_axes_homed)();
 }
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
@@ -232,36 +231,32 @@ FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 void do_z_clearance(const float &zclear, const bool z_known=true, const bool raise_on_unknown=true, const bool lower_allowed=false);
 
 //
 // Homing
 //
-
-uint8_t axes_need_homing(uint8_t axis_bits=0x07);
-bool axis_unhomed_error(uint8_t axis_bits=0x07);
+void homeaxis(const AxisEnum axis);
+void set_axis_is_at_home(const AxisEnum axis);
+void set_axis_never_homed(const AxisEnum axis);
+uint8_t axes_should_home(uint8_t axis_bits=0x07);
+bool homing_needed_error(uint8_t axis_bits=0x07);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
-  #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
+  #define MOTION_CONDITIONS (IsRunning() && !homing_needed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
-void set_axis_is_at_home(const AxisEnum axis);
-
-void set_axis_never_homed(const AxisEnum axis);
-
-void homeaxis(const AxisEnum axis);
-
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern xyz_pos_t home_offset;
   #endif
   #if HAS_POSITION_SHIFT
     extern xyz_pos_t position_shift;
   #endif

commit 462d3eeab15d173ade700faf961931050aed9d70
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 27 14:48:42 2020 -0500

    set_axis_not_trusted => set_axis_never_homed

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 38ce980dae..1a0971d281 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -244,21 +244,21 @@ uint8_t axes_need_homing(uint8_t axis_bits=0x07);
 bool axis_unhomed_error(uint8_t axis_bits=0x07);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
-void set_axis_not_trusted(const AxisEnum axis);
+void set_axis_never_homed(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern xyz_pos_t home_offset;
   #endif

commit 5d14c3712f96e0800cfe30e85036f4941a5a21ee
Author: Victor Tseng <palatis@gmail.com>
Date:   Tue Jul 28 09:15:14 2020 +0800

    Fix DELTA + TMC sensorless homing + SPI endstops (#18811)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index d33ce623a4..38ce980dae 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -388,10 +388,16 @@ void homeaxis(const AxisEnum axis);
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
   #endif
 
   FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
+
+#if USE_SENSORLESS
+  struct sensorless_t;
+  sensorless_t start_sensorless_homing_per_axis(const AxisEnum axis);
+  void end_sensorless_homing_per_axis(const AxisEnum axis, sensorless_t enable_stealth);
+#endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 6a984e5ebc..d33ce623a4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */

commit b40440cf3846bca4a0a10bb43d6d60f725a26cfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 17:58:37 2020 -0500

    Tool-change debug option

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f51b205b39..6a984e5ebc 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -371,21 +371,21 @@ void homeaxis(const AxisEnum axis);
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // Used in mode 0 & 1
                duplicate_extruder_x_offset;       // Used in mode 2 & 3
   extern xyz_pos_t raised_parked_position;        // Used in mode 1
   extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // Used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
 
   FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
-  float x_home_pos(const int extruder);
+  float x_home_pos(const uint8_t extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #else
 
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
   #endif
 
   FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1348adb3bd..f51b205b39 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -227,20 +227,22 @@ FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t
 FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
 
 void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f);
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
+void do_z_clearance(const float &zclear, const bool z_known=true, const bool raise_on_unknown=true, const bool lower_allowed=false);
+
 //
 // Homing
 //
 
 uint8_t axes_need_homing(uint8_t axis_bits=0x07);
 bool axis_unhomed_error(uint8_t axis_bits=0x07);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else

commit 2d758663db570d8fc37255bf75c1bd3a98c333fe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 29 03:25:35 2020 -0500

    G12 E soft endstops parameter (#17788)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index eb7bc37894..1348adb3bd 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -145,27 +145,29 @@ inline float home_bump_mm(const AxisEnum axis) {
 typedef struct { xyz_pos_t min, max; } axis_limits_t;
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   extern axis_limits_t soft_endstop;
   void apply_motion_limits(xyz_pos_t &target);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0
     #endif
   );
+  #define TEMPORARY_SOFT_ENDSTOP_STATE(enable) REMEMBER(tes, soft_endstops_enabled, enable);
 #else
   constexpr bool soft_endstops_enabled = false;
   //constexpr axis_limits_t soft_endstop = {
   //  { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
   //  { X_MAX_POS, Y_MAX_POS, Z_MAX_POS } };
   #define apply_motion_limits(V)    NOOP
   #define update_software_endstops(...) NOOP
+  #define TEMPORARY_SOFT_ENDSTOP_STATE(...) NOOP
 #endif
 
 void report_real_position();
 void report_current_position();
 void report_current_position_projected();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ee15205409..eb7bc37894 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -37,27 +37,21 @@
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
-  return !(
-    #if ENABLED(HOME_AFTER_DEACTIVATE)
-      all_axes_known()
-    #else
-      all_axes_homed()
-    #endif
-  );
+  return !TERN(HOME_AFTER_DEACTIVATE, all_axes_known, all_axes_homed)();
 }
 
 // Error margin to work around float imprecision
 constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
@@ -129,21 +123,21 @@ XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 inline float home_bump_mm(const AxisEnum axis) {
   static const xyz_pos_t home_bump_mm_P PROGMEM = HOMING_BUMP_MM;
   return pgm_read_any(&home_bump_mm_P[axis]);
 }
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
-  #define update_workspace_offset(x) NOOP
+  inline void update_workspace_offset(const AxisEnum) {}
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS
   constexpr xyz_pos_t hotend_offset[HOTENDS] = { { 0 } };
 #else
   constexpr xyz_pos_t hotend_offset[1] = { { 0 } };
 #endif

commit a794538c5417a38288c1af912f305755aec46894
Author: George Fu <nailao_5918@163.com>
Date:   Wed Mar 25 16:18:48 2020 +0800

    Homing backoff enhancements
    
    - Define homing bump as an array
    - Add pre and post homing backoff options
    - Consolidate homing config options

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e504f187f9..ee15205409 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -107,34 +107,39 @@ extern int16_t feedrate_percentage;
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
   extern float e_move_accumulator;
 #endif
 
-FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
-FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
+inline float pgm_read_any(const float *p) { return pgm_read_float(p); }
+inline signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
-  extern const XYZval<T> NAME##_P; \
-  FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); }
-
+  inline T NAME(const AxisEnum axis) { \
+    static const XYZval<T> NAME##_P PROGMEM = { X_##OPT, Y_##OPT, Z_##OPT }; \
+    return pgm_read_any(&NAME##_P[axis]); \
+  }
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
-XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
+inline float home_bump_mm(const AxisEnum axis) {
+  static const xyz_pos_t home_bump_mm_P PROGMEM = HOMING_BUMP_MM;
+  return pgm_read_any(&home_bump_mm_P[axis]);
+}
+
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   #define update_workspace_offset(x) NOOP
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
 #elif HOTENDS

commit 223aa5cc4efdab1ad987e490abe2e3020a7b211e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 17:20:01 2020 -0500

    No unscaled_e_move for CNC

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 4d1ab3bab8..e504f187f9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -177,21 +177,23 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s=feedrate_mm_s);
 
-void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s);
+#if EXTRUDERS
+  void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s);
+#endif
 
 void prepare_line_to_destination();
 
 void _internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f
   #if IS_KINEMATIC
     , const bool is_fast=false
   #endif
 );
 
 inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {

commit 765a9f3471b8a6b67c23f79cc6965e2f795f284a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 16:26:55 2020 -0500

    do_pause_e_move => unscaled_e_move

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f6a75a91a7..4d1ab3bab8 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -177,20 +177,22 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s=feedrate_mm_s);
 
+void unscaled_e_move(const float &length, const feedRate_t &fr_mm_s);
+
 void prepare_line_to_destination();
 
 void _internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f
   #if IS_KINEMATIC
     , const bool is_fast=false
   #endif
 );
 
 inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
   _internal_move_to_destination(fr_mm_s);

commit 627aa8db2dcb59584a815095e4a382a556323a9c
Author: jufimu12 <jufimu12@gmail.com>
Date:   Wed Mar 11 02:00:26 2020 +0100

    Fix G34, add HOME_AFTER_G34 option (#17108)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 4dfbe629dd..f6a75a91a7 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -237,21 +237,21 @@ uint8_t axes_need_homing(uint8_t axis_bits=0x07);
 bool axis_unhomed_error(uint8_t axis_bits=0x07);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
-void set_axis_is_not_at_home(const AxisEnum axis);
+void set_axis_not_trusted(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern xyz_pos_t home_offset;
   #endif

commit 64d092935b27ff89955f0430eef5815b15e5a92d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 7 22:20:41 2020 -0600

    More useful ENABLED / DISABLED macros (#17054)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 055c6eeecd..4dfbe629dd 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -368,21 +368,23 @@ void homeaxis(const AxisEnum axis);
   extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // Used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
 
   FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
-#elif ENABLED(MULTI_NOZZLE_DUPLICATION)
+#else
 
-  enum DualXMode : char {
-    DXC_DUPLICATION_MODE = 2
-  };
+  #if ENABLED(MULTI_NOZZLE_DUPLICATION)
+    enum DualXMode : char { DXC_DUPLICATION_MODE = 2 };
+  #endif
+
+  FORCE_INLINE int x_home_dir(const uint8_t) { return home_dir(X_AXIS); }
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif

commit 3a07b4412d24a6afd430f6d7e1b8c7f3c442a3c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 2 21:52:53 2020 -0600

    Asynchronous M114 and (R)ealtime position option (#17032)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 8e0eee7e33..055c6eeecd 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -155,21 +155,23 @@ typedef struct { xyz_pos_t min, max; } axis_limits_t;
   );
 #else
   constexpr bool soft_endstops_enabled = false;
   //constexpr axis_limits_t soft_endstop = {
   //  { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
   //  { X_MAX_POS, Y_MAX_POS, Z_MAX_POS } };
   #define apply_motion_limits(V)    NOOP
   #define update_software_endstops(...) NOOP
 #endif
 
+void report_real_position();
 void report_current_position();
+void report_current_position_projected();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */

commit 49c5f614c6ac9326275a2daf8f771df41041f142
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 16:59:04 2020 -0600

    Minor motion style changes

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f1c2dc069c..8e0eee7e33 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -175,21 +175,21 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position(const feedRate_t &fr_mm_s=feedrate_mm_s);
 
-void prepare_move_to_destination();
+void prepare_line_to_destination();
 
 void _internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f
   #if IS_KINEMATIC
     , const bool is_fast=false
   #endif
 );
 
 inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
   _internal_move_to_destination(fr_mm_s);
 }

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index c50da25a3e..f1c2dc069c 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -23,24 +23,20 @@
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
-#if HAS_BED_PROBE
-  #include "probe.h"
-#endif
-
 #if IS_SCARA
   #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
@@ -51,21 +47,21 @@ FORCE_INLINE bool homing_needed() {
   return !(
     #if ENABLED(HOME_AFTER_DEACTIVATE)
       all_axes_known()
     #else
       all_axes_homed()
     #endif
   );
 }
 
 // Error margin to work around float imprecision
-constexpr float slop = 0.0001;
+constexpr float fslop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
   extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
   extern xyz_pos_t stored_position[SAVED_POSITIONS];
@@ -299,97 +295,54 @@ void homeaxis(const AxisEnum axis);
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
-      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + slop);
+      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + fslop);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
     #endif
   }
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
-  #if HAS_BED_PROBE
-
-    #if HAS_PROBE_XY_OFFSET
-
-      // Return true if the both nozzle and the probe can reach the given point.
-      // Note: This won't work on SCARA since the probe offset rotates with the arm.
-      inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-        return position_is_reachable(rx - probe.offset_xy.x, ry - probe.offset_xy.y)
-               && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
-      }
-
-    #else
-
-      FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-        return position_is_reachable(rx, ry, MIN_PROBE_EDGE);
-      }
-
-    #endif
-
-  #endif // HAS_BED_PROBE
-
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
-    if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
+    if (!WITHIN(ry, Y_MIN_POS - fslop, Y_MAX_POS + fslop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
-        return WITHIN(rx, X2_MIN_POS - slop, X2_MAX_POS + slop);
+        return WITHIN(rx, X2_MIN_POS - fslop, X2_MAX_POS + fslop);
       else
-        return WITHIN(rx, X1_MIN_POS - slop, X1_MAX_POS + slop);
+        return WITHIN(rx, X1_MIN_POS - fslop, X1_MAX_POS + fslop);
     #else
-      return WITHIN(rx, X_MIN_POS - slop, X_MAX_POS + slop);
+      return WITHIN(rx, X_MIN_POS - fslop, X_MAX_POS + fslop);
     #endif
   }
   inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
-  #if HAS_BED_PROBE
-
-    /**
-     * Return whether the given position is within the bed, and whether the nozzle
-     * can reach the position required to put the probe at the given position.
-     *
-     * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
-     *          nozzle must be be able to reach +10,-10.
-     */
-    inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe.offset_xy.x, ry - probe.offset_xy.y)
-          && WITHIN(rx, probe.min_x() - slop, probe.max_x() + slop)
-          && WITHIN(ry, probe.min_y() - slop, probe.max_y() + slop);
-    }
-
-  #endif // HAS_BED_PROBE
-
 #endif // CARTESIAN
 
-#if !HAS_BED_PROBE
-  FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
-#endif
-FORCE_INLINE bool position_is_reachable_by_probe(const xy_pos_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
-
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
               mirrored_duplication_mode;          // Used in Dual X mode 3
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
   #endif
 #endif

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a159bdd4bf..c50da25a3e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index eafa5ca849..a159bdd4bf 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -322,21 +322,21 @@ void homeaxis(const AxisEnum axis);
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
   #if HAS_BED_PROBE
 
     #if HAS_PROBE_XY_OFFSET
 
       // Return true if the both nozzle and the probe can reach the given point.
       // Note: This won't work on SCARA since the probe offset rotates with the arm.
       inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-        return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
+        return position_is_reachable(rx - probe.offset_xy.x, ry - probe.offset_xy.y)
                && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
       }
 
     #else
 
       FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) {
         return position_is_reachable(rx, ry, MIN_PROBE_EDGE);
       }
 
     #endif
@@ -362,23 +362,23 @@ void homeaxis(const AxisEnum axis);
   #if HAS_BED_PROBE
 
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe_offset_xy.x, ry - probe_offset_xy.y)
-          && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
-          && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
+      return position_is_reachable(rx - probe.offset_xy.x, ry - probe.offset_xy.y)
+          && WITHIN(rx, probe.min_x() - slop, probe.max_x() + slop)
+          && WITHIN(ry, probe.min_y() - slop, probe.max_y() + slop);
     }
 
   #endif // HAS_BED_PROBE
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 FORCE_INLINE bool position_is_reachable_by_probe(const xy_pos_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }

commit 99b6a132bcf5ccf54215ef6962eea3e199ea4c0d
Author: chgi <chgi@users.noreply.github.com>
Date:   Thu Jan 30 18:18:45 2020 +0900

    Fix G60/G61 slots > 8 and compile error (#16715)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a30573e797..eafa5ca849 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -60,21 +60,21 @@ FORCE_INLINE bool homing_needed() {
 // Error margin to work around float imprecision
 constexpr float slop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
 // G60/G61 Position Save and Return
 #if SAVED_POSITIONS
-  extern uint8_t saved_slots;
+  extern uint8_t saved_slots[(SAVED_POSITIONS + 7) >> 3];
   extern xyz_pos_t stored_position[SAVED_POSITIONS];
 #endif
 
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abc_pos_t delta;
 #endif

commit e2eef1256a6feaceb8f4c7f02188e8d6d6d43519
Author: Hans007a <32525735+Hans007a@users.noreply.github.com>
Date:   Tue Jan 7 20:52:19 2020 +0100

    G60/G61 Position Save/Restore (#16557)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 43ae2b2303..a30573e797 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -58,20 +58,26 @@ FORCE_INLINE bool homing_needed() {
 }
 
 // Error margin to work around float imprecision
 constexpr float slop = 0.0001;
 
 extern bool relative_mode;
 
 extern xyze_pos_t current_position,  // High-level current tool position
                   destination;       // Destination for a move
 
+// G60/G61 Position Save and Return
+#if SAVED_POSITIONS
+  extern uint8_t saved_slots;
+  extern xyz_pos_t stored_position[SAVED_POSITIONS];
+#endif
+
 // Scratch space for a cartesian result
 extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern abc_pos_t delta;
 #endif
 
 #if HAS_ABL_NOT_UBL
   extern float xy_probe_feedrate_mm_s;

commit fbf2f36cae1a562c6f9417fb2bb0046d2e3c18f1
Author: FlyingSamson <59110786+FlyingSamson@users.noreply.github.com>
Date:   Sun Jan 12 00:06:52 2020 +0100

    Only constrain motion on homed axes (#16533)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 0128f66463..43ae2b2303 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -34,20 +34,21 @@
   #include "probe.h"
 #endif
 
 #if IS_SCARA
   #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
+FORCE_INLINE bool no_axes_homed() { return !axis_homed; }
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
   return !(
     #if ENABLED(HOME_AFTER_DEACTIVATE)
       all_axes_known()
     #else

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2e8ff64f52..0128f66463 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -284,20 +284,21 @@ void homeaxis(const AxisEnum axis);
 #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
+
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + slop);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
@@ -308,58 +309,72 @@ void homeaxis(const AxisEnum axis);
         #endif
       );
     #endif
   }
 
   inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
     return position_is_reachable(pos.x, pos.y, inset);
   }
 
   #if HAS_BED_PROBE
-    // Return true if the both nozzle and the probe can reach the given point.
-    // Note: This won't work on SCARA since the probe offset rotates with the arm.
-    inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
-             && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
-    }
-  #endif
+
+    #if HAS_PROBE_XY_OFFSET
+
+      // Return true if the both nozzle and the probe can reach the given point.
+      // Note: This won't work on SCARA since the probe offset rotates with the arm.
+      inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
+        return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
+               && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
+      }
+
+    #else
+
+      FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) {
+        return position_is_reachable(rx, ry, MIN_PROBE_EDGE);
+      }
+
+    #endif
+
+  #endif // HAS_BED_PROBE
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         return WITHIN(rx, X2_MIN_POS - slop, X2_MAX_POS + slop);
       else
         return WITHIN(rx, X1_MIN_POS - slop, X1_MAX_POS + slop);
     #else
       return WITHIN(rx, X_MIN_POS - slop, X_MAX_POS + slop);
     #endif
   }
   inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
   #if HAS_BED_PROBE
+
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
+      return position_is_reachable(rx - probe_offset_xy.x, ry - probe_offset_xy.y)
           && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
           && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
     }
-  #endif
+
+  #endif // HAS_BED_PROBE
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 FORCE_INLINE bool position_is_reachable_by_probe(const xy_pos_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
 
 /**
  * Duplication mode

commit 752a1e76aba505acc85e2dda0759ae214ed96b32
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 26 23:29:25 2019 -0800

    Float ABL mesh boundaries, no probe position rounding (#16018)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2006246267..2e8ff64f52 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -352,21 +352,20 @@ void homeaxis(const AxisEnum axis);
           && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
           && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
-FORCE_INLINE bool position_is_reachable_by_probe(const xy_int_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
 FORCE_INLINE bool position_is_reachable_by_probe(const xy_pos_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
               mirrored_duplication_mode;          // Used in Dual X mode 3
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;

commit d0282e5ba8a0868090ebf3aee878c1ebcc3ca665
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 26 00:53:28 2019 -0800

    Allow slop in position_is_reachable for delta (#16003)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 971e85e3b6..2006246267 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -291,21 +291,21 @@ void homeaxis(const AxisEnum axis);
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
   #if HAS_SCARA_OFFSET
     extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
-      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset);
+      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset + slop);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
     #endif
   }

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 8b9775ce98..971e85e3b6 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -100,20 +100,24 @@ extern feedRate_t feedrate_mm_s;
  */
 extern int16_t feedrate_percentage;
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
+#if ENABLED(LCD_SHOW_E_TOTAL)
+  extern float e_move_accumulator;
+#endif
+
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   extern const XYZval<T> NAME##_P; \
   FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); }
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);

commit 914605c89ccfbd1aac4665ab1b3df51a89dcaffd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 8 20:36:26 2019 -0500

    gcc is forgiving of stray ;

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5e07f710d4..8b9775ce98 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -105,22 +105,21 @@ extern int16_t feedrate_percentage;
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   extern const XYZval<T> NAME##_P; \
-  FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); } \
-  typedef void __void_##OPT##__ /* for semicolon */
+  FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); }
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);

commit 211ff674405d1291a177d071fb40f3da8c13c93c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 6 23:58:19 2019 -0500

    Patch blocking and manual moves

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ba37bebd46..5e07f710d4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -193,47 +193,37 @@ inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f)
 
   inline void prepare_internal_fast_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s=0.0f);
-
-FORCE_INLINE void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
-}
-FORCE_INLINE void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
-}
-FORCE_INLINE void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
-}
-
-void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
-
-FORCE_INLINE void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
-}
-FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
-}
-FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
-  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
-}
+void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
 
 void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
 
+void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f);
+FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy(xy_pos_t(raw), fr_mm_s); }
+
+void do_blocking_move_to_xy_z(const xy_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f);
+FORCE_INLINE void do_blocking_move_to_xy_z(const xyz_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f)  { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+FORCE_INLINE void do_blocking_move_to_xy_z(const xyze_pos_t &raw, const float &z, const feedRate_t &fr_mm_s=0.0f) { do_blocking_move_to_xy_z(xy_pos_t(raw), z, fr_mm_s); }
+
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 //
 // Homing
 //
 
 uint8_t axes_need_homing(uint8_t axis_bits=0x07);
 bool axis_unhomed_error(uint8_t axis_bits=0x07);

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 0da481e4e5..ba37bebd46 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -272,26 +272,26 @@ void homeaxis(const AxisEnum axis);
   #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - _WS[AXIS])
   FORCE_INLINE void toLogical(xy_pos_t &raw)   { raw += _WS; }
   FORCE_INLINE void toLogical(xyz_pos_t &raw)  { raw += _WS; }
   FORCE_INLINE void toLogical(xyze_pos_t &raw) { raw += _WS; }
   FORCE_INLINE void toNative(xy_pos_t &raw)    { raw -= _WS; }
   FORCE_INLINE void toNative(xyz_pos_t &raw)   { raw -= _WS; }
   FORCE_INLINE void toNative(xyze_pos_t &raw)  { raw -= _WS; }
 #else
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
-  FORCE_INLINE void toLogical(xy_pos_t &raw)   { UNUSED(raw); }
-  FORCE_INLINE void toLogical(xyz_pos_t &raw)  { UNUSED(raw); }
-  FORCE_INLINE void toLogical(xyze_pos_t &raw) { UNUSED(raw); }
-  FORCE_INLINE void toNative(xy_pos_t &raw)    { UNUSED(raw); }
-  FORCE_INLINE void toNative(xyz_pos_t &raw)   { UNUSED(raw); }
-  FORCE_INLINE void toNative(xyze_pos_t &raw)  { UNUSED(raw); }
+  FORCE_INLINE void toLogical(xy_pos_t&)   {}
+  FORCE_INLINE void toLogical(xyz_pos_t&)  {}
+  FORCE_INLINE void toLogical(xyze_pos_t&) {}
+  FORCE_INLINE void toNative(xy_pos_t&)    {}
+  FORCE_INLINE void toNative(xyz_pos_t&)   {}
+  FORCE_INLINE void toNative(xyze_pos_t&)  {}
 #endif
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
 #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
 #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions

commit b198f321c85bd03120fa340036bc915c2cf48236
Author: Timm <saeugetier@googlemail.com>
Date:   Tue Oct 1 02:57:22 2019 +0200

    Add missing motion inline methods (#15433)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9ea2ebe529..0da481e4e5 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -106,21 +106,21 @@ extern int16_t feedrate_percentage;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(T, NAME, OPT) \
   extern const XYZval<T> NAME##_P; \
   FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); } \
-  typedef void __void_##OPT##__
+  typedef void __void_##OPT##__ /* for semicolon */
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
@@ -193,37 +193,46 @@ inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f)
 
   inline void prepare_internal_fast_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
     _internal_move_to_destination(fr_mm_s, true);
   }
 #endif
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
-void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
 
 FORCE_INLINE void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
   do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
 }
 FORCE_INLINE void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
   do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
 }
 FORCE_INLINE void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
   do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
 }
+
+void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
+
 FORCE_INLINE void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
   do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
+FORCE_INLINE void do_blocking_move_to_xy(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
+}
+FORCE_INLINE void do_blocking_move_to_xy(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
+}
+
+void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 //
 // Homing
 //
 
 uint8_t axes_need_homing(uint8_t axis_bits=0x07);

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 9c465a1d59..9ea2ebe529 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -54,40 +54,44 @@ FORCE_INLINE bool homing_needed() {
       all_axes_homed()
     #endif
   );
 }
 
 // Error margin to work around float imprecision
 constexpr float slop = 0.0001;
 
 extern bool relative_mode;
 
-extern float current_position[XYZE],  // High-level current tool position
-             destination[XYZE];       // Destination for a move
+extern xyze_pos_t current_position,  // High-level current tool position
+                  destination;       // Destination for a move
 
 // Scratch space for a cartesian result
-extern float cartes[XYZ];
+extern xyz_pos_t cartes;
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
-  extern float delta[ABC];
+  extern abc_pos_t delta;
 #endif
 
 #if HAS_ABL_NOT_UBL
   extern float xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
+#if ENABLED(Z_SAFE_HOMING)
+  constexpr xy_float_t safe_homing_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
+#endif
+
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 extern const feedRate_t homing_feedrate_mm_s[XYZ];
 FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
 extern feedRate_t feedrate_mm_s;
 
@@ -99,69 +103,68 @@ extern int16_t feedrate_percentage;
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
-#define XYZ_DEFS(type, array, CONFIG) \
-  extern const type array##_P[XYZ]; \
-  FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
-  typedef void __void_##CONFIG##__
+#define XYZ_DEFS(T, NAME, OPT) \
+  extern const XYZval<T> NAME##_P; \
+  FORCE_INLINE T NAME(AxisEnum axis) { return pgm_read_any(&NAME##_P[axis]); } \
+  typedef void __void_##OPT##__
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   #define update_workspace_offset(x) NOOP
 #endif
 
 #if HAS_HOTEND_OFFSET
-  extern float hotend_offset[XYZ][HOTENDS];
+  extern xyz_pos_t hotend_offset[HOTENDS];
   void reset_hotend_offsets();
-#elif HOTENDS > 0
-  constexpr float hotend_offset[XYZ][HOTENDS] = { { 0 }, { 0 }, { 0 } };
+#elif HOTENDS
+  constexpr xyz_pos_t hotend_offset[HOTENDS] = { { 0 } };
 #else
-  constexpr float hotend_offset[XYZ][1] = { { 0 }, { 0 }, { 0 } };
+  constexpr xyz_pos_t hotend_offset[1] = { { 0 } };
 #endif
 
-typedef struct { float min, max; } axis_limits_t;
+typedef struct { xyz_pos_t min, max; } axis_limits_t;
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
-  extern axis_limits_t soft_endstop[XYZ];
-  void apply_motion_limits(float target[XYZ]);
+  extern axis_limits_t soft_endstop;
+  void apply_motion_limits(xyz_pos_t &target);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0
     #endif
   );
 #else
   constexpr bool soft_endstops_enabled = false;
-  //constexpr axis_limits_t soft_endstop[XYZ] = { { X_MIN_POS, X_MAX_POS }, { Y_MIN_POS, Y_MAX_POS }, { Z_MIN_POS, Z_MAX_POS } };
+  //constexpr axis_limits_t soft_endstop = {
+  //  { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
+  //  { X_MAX_POS, Y_MAX_POS, Z_MAX_POS } };
   #define apply_motion_limits(V)    NOOP
   #define update_software_endstops(...) NOOP
 #endif
 
 void report_current_position();
 
-inline void set_current_from_destination() { COPY(current_position, destination); }
-inline void set_destination_from_current() { COPY(destination, current_position); }
-
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
@@ -195,26 +198,31 @@ inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f)
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
 void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
 
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const feedRate_t &fr_mm_s=0) {
-  do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
+FORCE_INLINE void do_blocking_move_to(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to(raw.x, raw.y, current_position.z, fr_mm_s);
 }
-
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const feedRate_t &fr_mm_s=0) {
-  do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
+FORCE_INLINE void do_blocking_move_to(const xyz_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+}
+FORCE_INLINE void do_blocking_move_to(const xyze_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to(raw.x, raw.y, raw.z, fr_mm_s);
+}
+FORCE_INLINE void do_blocking_move_to_xy(const xy_pos_t &raw, const feedRate_t &fr_mm_s=0.0f) {
+  do_blocking_move_to_xy(raw.x, raw.y, fr_mm_s);
 }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 //
 // Homing
 //
 
@@ -231,114 +239,133 @@ void set_axis_is_at_home(const AxisEnum axis);
 
 void set_axis_is_not_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
-    extern float home_offset[XYZ];
+    extern xyz_pos_t home_offset;
   #endif
   #if HAS_POSITION_SHIFT
-    extern float position_shift[XYZ];
+    extern xyz_pos_t position_shift;
   #endif
   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-    extern float workspace_offset[XYZ];
-    #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
+    extern xyz_pos_t workspace_offset;
+    #define _WS workspace_offset
   #elif HAS_HOME_OFFSET
-    #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
+    #define _WS home_offset
   #else
-    #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
+    #define _WS position_shift
   #endif
-  #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
-  #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - WORKSPACE_OFFSET(AXIS))
+  #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + _WS[AXIS])
+  #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - _WS[AXIS])
+  FORCE_INLINE void toLogical(xy_pos_t &raw)   { raw += _WS; }
+  FORCE_INLINE void toLogical(xyz_pos_t &raw)  { raw += _WS; }
+  FORCE_INLINE void toLogical(xyze_pos_t &raw) { raw += _WS; }
+  FORCE_INLINE void toNative(xy_pos_t &raw)    { raw -= _WS; }
+  FORCE_INLINE void toNative(xyz_pos_t &raw)   { raw -= _WS; }
+  FORCE_INLINE void toNative(xyze_pos_t &raw)  { raw -= _WS; }
 #else
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
+  FORCE_INLINE void toLogical(xy_pos_t &raw)   { UNUSED(raw); }
+  FORCE_INLINE void toLogical(xyz_pos_t &raw)  { UNUSED(raw); }
+  FORCE_INLINE void toLogical(xyze_pos_t &raw) { UNUSED(raw); }
+  FORCE_INLINE void toNative(xy_pos_t &raw)    { UNUSED(raw); }
+  FORCE_INLINE void toNative(xyz_pos_t &raw)   { UNUSED(raw); }
+  FORCE_INLINE void toNative(xyze_pos_t &raw)  { UNUSED(raw); }
 #endif
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
 #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
 #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
   #if HAS_SCARA_OFFSET
-    extern float scara_home_offset[ABC]; // A and B angular offsets, Z mm offset
+    extern abc_pos_t scara_home_offset; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
     #endif
   }
 
+  inline bool position_is_reachable(const xy_pos_t &pos, const float inset=0) {
+    return position_is_reachable(pos.x, pos.y, inset);
+  }
+
   #if HAS_BED_PROBE
     // Return true if the both nozzle and the probe can reach the given point.
     // Note: This won't work on SCARA since the probe offset rotates with the arm.
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe_offset[X_AXIS], ry - probe_offset[Y_AXIS])
+      return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
       if (active_extruder)
         return WITHIN(rx, X2_MIN_POS - slop, X2_MAX_POS + slop);
       else
         return WITHIN(rx, X1_MIN_POS - slop, X1_MAX_POS + slop);
     #else
       return WITHIN(rx, X_MIN_POS - slop, X_MAX_POS + slop);
     #endif
   }
+  inline bool position_is_reachable(const xy_pos_t &pos) { return position_is_reachable(pos.x, pos.y); }
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - probe_offset[X_AXIS], ry - probe_offset[Y_AXIS])
+      return position_is_reachable(rx - probe_offset.x, ry - probe_offset.y)
           && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
           && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
+FORCE_INLINE bool position_is_reachable_by_probe(const xy_int_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
+FORCE_INLINE bool position_is_reachable_by_probe(const xy_pos_t &pos) { return position_is_reachable_by_probe(pos.x, pos.y); }
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
               mirrored_duplication_mode;          // Used in Dual X mode 3
   #if ENABLED(MULTI_NOZZLE_DUPLICATION)
     extern uint8_t duplication_e_mask;
   #endif
@@ -351,22 +378,22 @@ void homeaxis(const AxisEnum axis);
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
     DXC_DUPLICATION_MODE,
     DXC_MIRRORED_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // Used in mode 0 & 1
-               raised_parked_position[XYZE],      // Used in mode 1
                duplicate_extruder_x_offset;       // Used in mode 2 & 3
+  extern xyz_pos_t raised_parked_position;        // Used in mode 1
   extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // Used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
 
   FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index b3d79a7a0e..9c465a1d59 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -78,31 +78,30 @@ extern float cartes[XYZ];
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
-extern const float homing_feedrate_mm_s[XYZ];
-FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
-float get_homing_bump_feedrate(const AxisEnum axis);
+extern const feedRate_t homing_feedrate_mm_s[XYZ];
+FORCE_INLINE feedRate_t homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
+feedRate_t get_homing_bump_feedrate(const AxisEnum axis);
 
-extern float feedrate_mm_s;
+extern feedRate_t feedrate_mm_s;
 
 /**
- * Feedrate scaling and conversion
+ * Feedrate scaling
  */
 extern int16_t feedrate_percentage;
-#define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
@@ -165,48 +164,56 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position(const float &fr_mm_s=feedrate_mm_s);
+void line_to_current_position(const feedRate_t &fr_mm_s=feedrate_mm_s);
 
-/**
- * Move the planner to the position stored in the destination array, which is
- * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
- */
-void buffer_line_to_destination(const float fr_mm_s);
+void prepare_move_to_destination();
+
+void _internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f
+  #if IS_KINEMATIC
+    , const bool is_fast=false
+  #endif
+);
+
+inline void prepare_internal_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
+  _internal_move_to_destination(fr_mm_s);
+}
 
 #if IS_KINEMATIC
-  void prepare_uninterpolated_move_to_destination(const float &fr_mm_s=0);
-#endif
+  void prepare_fast_move_to_destination(const feedRate_t &scaled_fr_mm_s=MMS_SCALED(feedrate_mm_s));
 
-void prepare_move_to_destination();
+  inline void prepare_internal_fast_move_to_destination(const feedRate_t &fr_mm_s=0.0f) {
+    _internal_move_to_destination(fr_mm_s, true);
+  }
+#endif
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
-void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
-void do_blocking_move_to_y(const float &ry, const float &fr_mm_s=0);
-void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
-void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
+void do_blocking_move_to(const float rx, const float ry, const float rz, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_x(const float &rx, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_y(const float &ry, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_z(const float &rz, const feedRate_t &fr_mm_s=0.0f);
+void do_blocking_move_to_xy(const float &rx, const float &ry, const feedRate_t &fr_mm_s=0.0f);
 
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s=0) {
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const feedRate_t &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s=0) {
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const feedRate_t &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 //
 // Homing
 //

commit b2e1f77f58a67ac02503cbe36b22a21e5afaeac0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 21:01:29 2019 -0500

    Fix extraneous "Home XYZ First" message

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 664e9f13fe..b3d79a7a0e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -204,21 +204,22 @@ FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_
 }
 
 void remember_feedrate_and_scaling();
 void remember_feedrate_scaling_off();
 void restore_feedrate_and_scaling();
 
 //
 // Homing
 //
 
-bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
+uint8_t axes_need_homing(uint8_t axis_bits=0x07);
+bool axis_unhomed_error(uint8_t axis_bits=0x07);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void set_axis_is_not_at_home(const AxisEnum axis);

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 86fccc25c4..664e9f13fe 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -277,21 +277,21 @@ void homeaxis(const AxisEnum axis);
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
     #endif
   }
 
   #if HAS_BED_PROBE
     // Return true if the both nozzle and the probe can reach the given point.
     // Note: This won't work on SCARA since the probe offset rotates with the arm.
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - zprobe_offset[X_AXIS], ry - zprobe_offset[Y_AXIS])
+      return position_is_reachable(rx - probe_offset[X_AXIS], ry - probe_offset[Y_AXIS])
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
@@ -306,21 +306,21 @@ void homeaxis(const AxisEnum axis);
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - zprobe_offset[X_AXIS], ry - zprobe_offset[Y_AXIS])
+      return position_is_reachable(rx - probe_offset[X_AXIS], ry - probe_offset[Y_AXIS])
           && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
           && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ba1ac07f70..86fccc25c4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -23,28 +23,28 @@
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
-#if IS_SCARA
-  #include "scara.h"
-#endif
-
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
+#if IS_SCARA
+  #include "scara.h"
+#endif
+
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
   return !(
@@ -277,21 +277,21 @@ void homeaxis(const AxisEnum axis);
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
         #endif
       );
     #endif
   }
 
   #if HAS_BED_PROBE
     // Return true if the both nozzle and the probe can reach the given point.
     // Note: This won't work on SCARA since the probe offset rotates with the arm.
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+      return position_is_reachable(rx - zprobe_offset[X_AXIS], ry - zprobe_offset[Y_AXIS])
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
@@ -306,23 +306,23 @@ void homeaxis(const AxisEnum axis);
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
-          && WITHIN(rx, MIN_PROBE_X - slop, MAX_PROBE_X + slop)
-          && WITHIN(ry, MIN_PROBE_Y - slop, MAX_PROBE_Y + slop);
+      return position_is_reachable(rx - zprobe_offset[X_AXIS], ry - zprobe_offset[Y_AXIS])
+          && WITHIN(rx, probe_min_x() - slop, probe_max_x() + slop)
+          && WITHIN(ry, probe_min_y() - slop, probe_max_y() + slop);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**

commit 9aaa056286e3a32299012d1536f979e430f4d370
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Sep 24 15:29:25 2019 -0700

    Fix SCARA build from Arduino IDE (#15317)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f461aae004..ba1ac07f70 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -254,25 +254,20 @@ void homeaxis(const AxisEnum axis);
 #define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
-
-  #if IS_SCARA
-    extern const float L1, L2;
-  #endif
-
   #if HAS_SCARA_OFFSET
     extern float scara_home_offset[ABC]; // A and B angular offsets, Z mm offset
   #endif
 
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 3f9d0e9bda..f461aae004 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -196,22 +196,23 @@ void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
 
 FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
-void setup_for_endstop_or_probe_move();
-void clean_up_after_endstop_or_probe_move();
+void remember_feedrate_and_scaling();
+void remember_feedrate_scaling_off();
+void restore_feedrate_and_scaling();
 
 //
 // Homing
 //
 
 bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5a8a42d7fc..3f9d0e9bda 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -27,20 +27,24 @@
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "scara.h"
 #endif
 
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
+
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 
 FORCE_INLINE bool homing_needed() {
   return !(

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7c637f9cb8..5a8a42d7fc 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -117,22 +117,24 @@ XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   #define update_workspace_offset(x) NOOP
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
   void reset_hotend_offsets();
-#else
+#elif HOTENDS > 0
   constexpr float hotend_offset[XYZ][HOTENDS] = { { 0 }, { 0 }, { 0 } };
+#else
+  constexpr float hotend_offset[XYZ][1] = { { 0 }, { 0 }, { 0 } };
 #endif
 
 typedef struct { float min, max; } axis_limits_t;
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   extern axis_limits_t soft_endstop[XYZ];
   void apply_motion_limits(float target[XYZ]);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0

commit 6f8b8c394db5f5037e85d3b16dc63bfeb11f6891
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jul 31 21:50:23 2019 -0400

    Homing backoff per-axis / delta Z (#14789)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1d2ccf1105..7c637f9cb8 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -178,20 +178,21 @@ void buffer_line_to_destination(const float fr_mm_s);
   void prepare_uninterpolated_move_to_destination(const float &fr_mm_s=0);
 #endif
 
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
+void do_blocking_move_to_y(const float &ry, const float &fr_mm_s=0);
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
 
 FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }

commit c2b319360db9ae41d07e59412028eb51fabe2383
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 30 20:19:34 2019 -0500

    Remove extra pragmas

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 35819187ae..1d2ccf1105 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -20,21 +20,20 @@
  *
  */
 #pragma once
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
-#pragma once
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);

commit b6546ea33a0f6eebee520dda516e04d3b68ded55
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 4 22:44:12 2019 -0500

    Add include guards to some headers

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 552b7ead34..35819187ae 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -12,20 +12,21 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index d803093407..552b7ead34 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 49627069a50b5e6c2a80f49ccf1497f53e85f8ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 26 03:42:21 2019 -0500

    Shorthand for home-after-deactivate

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2252f4cac9..d803093407 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -35,20 +35,30 @@
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 
+FORCE_INLINE bool homing_needed() {
+  return !(
+    #if ENABLED(HOME_AFTER_DEACTIVATE)
+      all_axes_known()
+    #else
+      all_axes_homed()
+    #endif
+  );
+}
+
 // Error margin to work around float imprecision
 constexpr float slop = 0.0001;
 
 extern bool relative_mode;
 
 extern float current_position[XYZE],  // High-level current tool position
              destination[XYZE];       // Destination for a move
 
 // Scratch space for a cartesian result
 extern float cartes[XYZ];

commit d44e5b1fdeb4f5d6196ed0f3afe3076eef90a3da
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Apr 4 03:44:07 2019 -0400

    Fix stepper direction macros, multi-nozzle scope (#13569)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index fcae47beef..2252f4cac9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -311,24 +311,23 @@ void homeaxis(const AxisEnum axis);
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
   extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
               mirrored_duplication_mode;          // Used in Dual X mode 3
-#endif
-
-#if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
-  uint8_t duplication_e_mask;
+  #if ENABLED(MULTI_NOZZLE_DUPLICATION)
+    extern uint8_t duplication_e_mask;
+  #endif
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,

commit 09eb30dc05a727e3816ab5a407f02ada18700e23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Mar 15 23:46:27 2019 -0400

    IDEX Mirror mode based on Formbot / Vivedino Symmetric mode (#13404)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 6e32037612..fcae47beef 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -309,47 +309,47 @@ void homeaxis(const AxisEnum axis);
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
  * Duplication mode
  */
 #if HAS_DUPLICATION_MODE
-  extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
-              //scaled_duplication_mode;            // Used in Dual X mode 3
+  extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
+              mirrored_duplication_mode;          // Used in Dual X mode 3
 #endif
 
 #if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
   uint8_t duplication_e_mask;
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
     DXC_DUPLICATION_MODE,
-    DXC_SCALED_DUPLICATION_MODE
+    DXC_MIRRORED_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
-  extern float inactive_extruder_x_pos,           // used in mode 0 & 1
-               raised_parked_position[XYZE],      // used in mode 1
-               duplicate_extruder_x_offset;       // used in mode 2 & 3
-  extern bool active_extruder_parked;             // used in mode 1, 2 & 3
-  extern millis_t delayed_move_time;              // used in mode 1
-  extern int16_t duplicate_extruder_temp_offset;  // used in mode 2 & 3
+  extern float inactive_extruder_x_pos,           // Used in mode 0 & 1
+               raised_parked_position[XYZE],      // Used in mode 1
+               duplicate_extruder_x_offset;       // Used in mode 2 & 3
+  extern bool active_extruder_parked;             // Used in mode 1, 2 & 3
+  extern millis_t delayed_move_time;              // Used in mode 1
+  extern int16_t duplicate_extruder_temp_offset;  // Used in mode 2 & 3
 
   FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   enum DualXMode : char {

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e688cdb69e..6e32037612 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -111,37 +111,37 @@ XYZ_DEFS(signed char, home_dir, HOME_DIR);
   #define update_workspace_offset(x) NOOP
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
   void reset_hotend_offsets();
 #else
   constexpr float hotend_offset[XYZ][HOTENDS] = { { 0 }, { 0 }, { 0 } };
 #endif
 
+typedef struct { float min, max; } axis_limits_t;
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
-  extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
+  extern axis_limits_t soft_endstop[XYZ];
+  void apply_motion_limits(float target[XYZ]);
   void update_software_endstops(const AxisEnum axis
     #if HAS_HOTEND_OFFSET
       , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0
     #endif
   );
 #else
-  constexpr bool soft_endstops_enabled = true;
-  constexpr float soft_endstop_min[XYZ] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
-                  soft_endstop_max[XYZ] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+  constexpr bool soft_endstops_enabled = false;
+  //constexpr axis_limits_t soft_endstop[XYZ] = { { X_MIN_POS, X_MAX_POS }, { Y_MIN_POS, Y_MAX_POS }, { Z_MIN_POS, Z_MAX_POS } };
+  #define apply_motion_limits(V)    NOOP
   #define update_software_endstops(...) NOOP
 #endif
 
-void clamp_to_software_endstops(float target[XYZ]);
-
 void report_current_position();
 
 inline void set_current_from_destination() { COPY(current_position, destination); }
 inline void set_destination_from_current() { COPY(destination, current_position); }
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 8f5586cb64..e688cdb69e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -306,25 +306,29 @@ void homeaxis(const AxisEnum axis);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
- * Dual X Carriage / Dual Nozzle
+ * Duplication mode
  */
-#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
-              scaled_duplication_mode;            // Used in Dual X mode 3
+#if HAS_DUPLICATION_MODE
+  extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
+              //scaled_duplication_mode;            // Used in Dual X mode 3
+#endif
+
+#if ENABLED(MULTI_NOZZLE_DUPLICATION) && HOTENDS > 2
+  uint8_t duplication_e_mask;
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,
     DXC_AUTO_PARK_MODE,
@@ -339,21 +343,21 @@ void homeaxis(const AxisEnum axis);
   extern bool active_extruder_parked;             // used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2 & 3
 
   FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
-#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+#elif ENABLED(MULTI_NOZZLE_DUPLICATION)
 
   enum DualXMode : char {
     DXC_DUPLICATION_MODE = 2
   };
 
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif

commit 11d6a939df86cd40a989d0ece33505927d4f93dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 20:57:54 2019 -0500

    Always define axis_unhomed_err

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e14892d738..8f5586cb64 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -186,34 +186,21 @@ FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 //
 // Homing
 //
 
-#define HAS_AXIS_UNHOMED_ERR (                                                     \
-         ENABLED(Z_PROBE_ALLEN_KEY)                                                \
-      || ENABLED(Z_PROBE_SLED)                                                     \
-      || HAS_PROBING_PROCEDURE                                                     \
-      || HOTENDS > 1                                                               \
-      || ENABLED(NOZZLE_CLEAN_FEATURE)                                             \
-      || ENABLED(NOZZLE_PARK_FEATURE)                                              \
-      || (ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(HOME_BEFORE_FILAMENT_CHANGE)) \
-      || HAS_M206_COMMAND                                                          \
-    ) || ENABLED(NO_MOTION_BEFORE_HOMING)
-
-#if HAS_AXIS_UNHOMED_ERR
-  bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
-#endif
+bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void set_axis_is_not_at_home(const AxisEnum axis);

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 275fafe74e..e14892d738 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -83,24 +83,20 @@ extern float feedrate_mm_s;
 extern int16_t feedrate_percentage;
 #define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
 // The active extruder (tool). Set with T<extruder> command.
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
-#if HAS_HOTEND_OFFSET
-  extern float hotend_offset[XYZ][HOTENDS];
-#endif
-
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(type, array, CONFIG) \
   extern const type array##_P[XYZ]; \
   FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
   typedef void __void_##CONFIG##__
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
@@ -108,33 +104,44 @@ XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_WORKSPACE_OFFSET
   void update_workspace_offset(const AxisEnum axis);
 #else
   #define update_workspace_offset(x) NOOP
 #endif
 
+#if HAS_HOTEND_OFFSET
+  extern float hotend_offset[XYZ][HOTENDS];
+  void reset_hotend_offsets();
+#else
+  constexpr float hotend_offset[XYZ][HOTENDS] = { { 0 }, { 0 }, { 0 } };
+#endif
+
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
-  void clamp_to_software_endstops(float target[XYZ]);
-  void update_software_endstops(const AxisEnum axis);
+  void update_software_endstops(const AxisEnum axis
+    #if HAS_HOTEND_OFFSET
+      , const uint8_t old_tool_index=0, const uint8_t new_tool_index=0
+    #endif
+  );
 #else
-  constexpr bool soft_endstops_enabled = false;
-  constexpr float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
-                  soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
-  #define clamp_to_software_endstops(x) NOOP
-  #define update_software_endstops(x) NOOP
+  constexpr bool soft_endstops_enabled = true;
+  constexpr float soft_endstop_min[XYZ] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
+                  soft_endstop_max[XYZ] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
+  #define update_software_endstops(...) NOOP
 #endif
 
+void clamp_to_software_endstops(float target[XYZ]);
+
 void report_current_position();
 
 inline void set_current_from_destination() { COPY(current_position, destination); }
 inline void set_destination_from_current() { COPY(destination, current_position); }
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position

commit 5d28575d4d113aadf2f2c5a341b898e6a5b62d2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 25 14:28:01 2019 -0600

    Clean up some motion code

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 515a684a3a..275fafe74e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -142,30 +142,30 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
-void line_to_current_position();
+void line_to_current_position(const float &fr_mm_s=feedrate_mm_s);
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
 void buffer_line_to_destination(const float fr_mm_s);
 
 #if IS_KINEMATIC
-  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0);
+  void prepare_uninterpolated_move_to_destination(const float &fr_mm_s=0);
 #endif
 
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
@@ -175,24 +175,20 @@ FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_m
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
-void bracket_probe_move(const bool before);
-void setup_for_endstop_or_probe_move();
-void clean_up_after_endstop_or_probe_move();
-
 //
 // Homing
 //
 
 #define HAS_AXIS_UNHOMED_ERR (                                                     \
          ENABLED(Z_PROBE_ALLEN_KEY)                                                \
       || ENABLED(Z_PROBE_SLED)                                                     \
       || HAS_PROBING_PROCEDURE                                                     \
       || HOTENDS > 1                                                               \
       || ENABLED(NOZZLE_CLEAN_FEATURE)                                             \

commit 808b076000e89fd7dae071bd2e4899833c872af6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 24 20:29:03 2019 -0600

    Update some ABL/UBL conditionals

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5aea339a1e..515a684a3a 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -51,21 +51,21 @@ extern float current_position[XYZE],  // High-level current tool position
              destination[XYZE];       // Destination for a move
 
 // Scratch space for a cartesian result
 extern float cartes[XYZ];
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
   extern float delta[ABC];
 #endif
 
-#if OLDSCHOOL_ABL
+#if HAS_ABL_NOT_UBL
   extern float xy_probe_feedrate_mm_s;
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
 /**
  * Feed rates are often configured with mm/m

commit be9a409980a71e6dc15baf363791158b49d7450a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 14 05:25:29 2019 -0600

    Fix M125 XY parameters, export get_homing_bump_feedrate

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 29a0acef0e..5aea339a1e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -66,20 +66,21 @@ extern float cartes[XYZ];
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 extern const float homing_feedrate_mm_s[XYZ];
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
+float get_homing_bump_feedrate(const AxisEnum axis);
 
 extern float feedrate_mm_s;
 
 /**
  * Feedrate scaling and conversion
  */
 extern int16_t feedrate_percentage;
 #define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
 // The active extruder (tool). Set with T<extruder> command.

commit ce40c2e87c92c9c4f86ada6971b542994facfd84
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 14 02:21:42 2019 -0600

    Use do_blocking_move_to(ref, fr)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7575bfd5a7..29a0acef0e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -163,25 +163,25 @@ void buffer_line_to_destination(const float fr_mm_s);
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
 
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
-FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s) {
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s=0) {
   do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
 }
 
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 void bracket_probe_move(const bool before);
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7a93850e26..7575bfd5a7 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f43c8f7b44..7a93850e26 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -24,21 +24,21 @@
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
-  #include "../module/scara.h"
+  #include "scara.h"
 #endif
 
 // Axis homed and known-position states
 extern uint8_t axis_homed, axis_known_position;
 constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
 FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
 FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
 FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
 FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
 

commit 0358ffcd4caf64b7e78449a4c184ed5b00dfdb72
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 23 19:25:57 2019 -0600

    Drop E element from `homing_feedrate_mm_s`

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 59c0b32ff4..f43c8f7b44 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -64,21 +64,21 @@ extern float cartes[XYZ];
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
-extern const float homing_feedrate_mm_s[4];
+extern const float homing_feedrate_mm_s[XYZ];
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 extern float feedrate_mm_s;
 
 /**
  * Feedrate scaling and conversion
  */
 extern int16_t feedrate_percentage;
 #define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 702df69aec..59c0b32ff4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -209,24 +209,20 @@ void clean_up_after_endstop_or_probe_move();
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void set_axis_is_not_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 
-#if ENABLED(SENSORLESS_HOMING)
-  void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
-#endif
-
 /**
  * Workspace offsets
  */
 #if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern float home_offset[XYZ];
   #endif
   #if HAS_POSITION_SHIFT
     extern float position_shift[XYZ];
   #endif

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 299e0ae814..702df69aec 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -86,43 +86,52 @@ extern int16_t feedrate_percentage;
 #if EXTRUDERS > 1
   extern uint8_t active_extruder;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
 #endif
 
-extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
-
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(type, array, CONFIG) \
   extern const type array##_P[XYZ]; \
   FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
   typedef void __void_##CONFIG##__
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
+#if HAS_WORKSPACE_OFFSET
+  void update_workspace_offset(const AxisEnum axis);
+#else
+  #define update_workspace_offset(x) NOOP
+#endif
+
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
+  extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
   void clamp_to_software_endstops(float target[XYZ]);
+  void update_software_endstops(const AxisEnum axis);
 #else
   constexpr bool soft_endstops_enabled = false;
+  constexpr float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
+                  soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
   #define clamp_to_software_endstops(x) NOOP
+  #define update_software_endstops(x) NOOP
 #endif
 
 void report_current_position();
 
 inline void set_current_from_destination() { COPY(current_position, destination); }
 inline void set_destination_from_current() { COPY(destination, current_position); }
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
@@ -245,20 +254,24 @@ void homeaxis(const AxisEnum axis);
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   #if IS_SCARA
     extern const float L1, L2;
   #endif
 
+  #if HAS_SCARA_OFFSET
+    extern float scara_home_offset[ABC]; // A and B angular offsets, Z mm offset
+  #endif
+
   // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset);
     #elif IS_SCARA
       const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
       return (
         R2 <= sq(L1 + L2) - inset
         #if MIDDLE_DEAD_ZONE_R > 0
           && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
@@ -347,17 +360,13 @@ void homeaxis(const AxisEnum axis);
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   enum DualXMode : char {
     DXC_DUPLICATION_MODE = 2
   };
 
 #endif
 
-#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
-  void update_software_endstops(const AxisEnum axis);
-#endif
-
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif

commit 2c9586be0cb55fc821b50413287735ff83f0d321
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:39:15 2018 -0500

    Clear up HAS_WORKSPACE_OFFSET meaning

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 69981b8141..299e0ae814 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -204,40 +204,36 @@ void clean_up_after_endstop_or_probe_move();
 void set_axis_is_at_home(const AxisEnum axis);
 
 void set_axis_is_not_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 
 #if ENABLED(SENSORLESS_HOMING)
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
 #endif
 
-//
-// Macros
-//
-
 /**
  * Workspace offsets
  */
-#if HAS_WORKSPACE_OFFSET
+#if HAS_HOME_OFFSET || HAS_POSITION_SHIFT
   #if HAS_HOME_OFFSET
     extern float home_offset[XYZ];
   #endif
   #if HAS_POSITION_SHIFT
     extern float position_shift[XYZ];
   #endif
   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
     extern float workspace_offset[XYZ];
     #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
   #elif HAS_HOME_OFFSET
     #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
-  #elif HAS_POSITION_SHIFT
+  #else
     #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
   #endif
   #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
   #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - WORKSPACE_OFFSET(AXIS))
 #else
   #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
   #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
 #endif
 #define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
 #define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)

commit 31c28d0dd243331adba3debb4801fbd03f7f6ec2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 2 00:42:16 2018 -0500

    Drop pgm_read_*_near and let headers choose (#12301)
    
    - Drop `pgm_read_*_near` and let headers choose.
    - Define `USE_EXECUTE_COMMANDS_IMMEDIATE` as a conditional.
    - Add `process_subcommands_now` for SRAM-based commands.

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 86cc10dee9..69981b8141 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -88,22 +88,22 @@ extern int16_t feedrate_percentage;
 #else
   constexpr uint8_t active_extruder = 0;
 #endif
 
 #if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
 #endif
 
 extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
 
-FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
-FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
+FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float(p); }
+FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte(p); }
 
 #define XYZ_DEFS(type, array, CONFIG) \
   extern const type array##_P[XYZ]; \
   FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
   typedef void __void_##CONFIG##__
 
 XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);

commit 44f2a82a567333312c3d85f72176f437bafc9625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:07:52 2018 -0500

    Move axis_homed, axis_known_position to motion.*

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 792a1fec80..86cc10dee9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -19,30 +19,36 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * motion.h
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
-
-#ifndef MOTION_H
-#define MOTION_H
+#pragma once
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../module/scara.h"
 #endif
 
+// Axis homed and known-position states
+extern uint8_t axis_homed, axis_known_position;
+constexpr uint8_t xyz_bits = _BV(X_AXIS) | _BV(Y_AXIS) | _BV(Z_AXIS);
+FORCE_INLINE bool all_axes_homed() { return (axis_homed & xyz_bits) == xyz_bits; }
+FORCE_INLINE bool all_axes_known() { return (axis_known_position & xyz_bits) == xyz_bits; }
+FORCE_INLINE void set_all_unhomed() { axis_homed = 0; }
+FORCE_INLINE void set_all_unknown() { axis_known_position = 0; }
+
 // Error margin to work around float imprecision
 constexpr float slop = 0.0001;
 
 extern bool relative_mode;
 
 extern float current_position[XYZE],  // High-level current tool position
              destination[XYZE];       // Destination for a move
 
 // Scratch space for a cartesian result
 extern float cartes[XYZ];
@@ -352,12 +358,10 @@ void homeaxis(const AxisEnum axis);
 
 #endif
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
-
-#endif // MOTION_H

commit 553622835911b520c6ba43bc03e71868f3972cb3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Oct 29 20:01:36 2018 +0100

    G34 Auto-align multi-stepper Z axis (#11302)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index b0e13dd0a4..792a1fec80 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -190,20 +190,22 @@ void clean_up_after_endstop_or_probe_move();
 #endif
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
+void set_axis_is_not_at_home(const AxisEnum axis);
+
 void homeaxis(const AxisEnum axis);
 
 #if ENABLED(SENSORLESS_HOMING)
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
 #endif
 
 //
 // Macros
 //
 

commit 2bf18950ab2070e842c91057d5812dcaa1bff9a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 16:00:34 2018 -0500

    Refactor LCD menus

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 8d8b38d15b..b0e13dd0a4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -101,21 +101,21 @@ XYZ_DEFS(float, base_min_pos,   MIN_POS);
 XYZ_DEFS(float, base_max_pos,   MAX_POS);
 XYZ_DEFS(float, base_home_pos,  HOME_POS);
 XYZ_DEFS(float, max_length,     MAX_LENGTH);
 XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   void clamp_to_software_endstops(float target[XYZ]);
 #else
-  #define soft_endstops_enabled false
+  constexpr bool soft_endstops_enabled = false;
   #define clamp_to_software_endstops(x) NOOP
 #endif
 
 void report_current_position();
 
 inline void set_current_from_destination() { COPY(current_position, destination); }
 inline void set_destination_from_current() { COPY(destination, current_position); }
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);

commit 951b25163e8b9e09212594b47c26434f23dc1a1e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 13 23:08:20 2018 -0500

    Extend M217 with configurable park/raise (#12076)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 1b4f727c8e..8d8b38d15b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -148,20 +148,28 @@ void buffer_line_to_destination(const float fr_mm_s);
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
 void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
 
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
+  do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
+}
+
+FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZE], const float &fr_mm_s) {
+  do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
+}
+
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 void bracket_probe_move(const bool before);
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 //
 // Homing
 //

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7d05a0ebd4..1b4f727c8e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -298,42 +298,45 @@ void homeaxis(const AxisEnum axis);
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
-              symmetric_duplication_mode;         // Used in Dual X mode 2
+              scaled_duplication_mode;            // Used in Dual X mode 3
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
-    DXC_FULL_CONTROL_MODE,  // DUAL_X_CARRIAGE only
-    DXC_AUTO_PARK_MODE,     // DUAL_X_CARRIAGE only
-    DXC_DUPLICATION_MODE
+    DXC_FULL_CONTROL_MODE,
+    DXC_AUTO_PARK_MODE,
+    DXC_DUPLICATION_MODE,
+    DXC_SCALED_DUPLICATION_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
                duplicate_extruder_x_offset;       // used in mode 2 & 3
   extern bool active_extruder_parked;             // used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2 & 3
 
+  FORCE_INLINE bool dxc_is_duplicating() { return dual_x_carriage_mode >= DXC_DUPLICATION_MODE; }
+
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   enum DualXMode : char {
     DXC_DUPLICATION_MODE = 2
   };
 

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a680c01c9e..7d05a0ebd4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -122,27 +122,20 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
-#if IS_KINEMATIC
-  void sync_plan_position_kinematic();
-  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
-#else
-  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
-#endif
-
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position();
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
@@ -347,27 +340,11 @@ void homeaxis(const AxisEnum axis);
 #endif
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-  #if ENABLED(DELTA)
-    #define ADJUST_DELTA(V) \
-      if (planner.leveling_active) { \
-        const float zadj = bilinear_z_offset(V); \
-        delta[A_AXIS] += zadj; \
-        delta[B_AXIS] += zadj; \
-        delta[C_AXIS] += zadj; \
-      }
-  #else
-    #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
-  #endif
-#else
-  #define ADJUST_DELTA(V) NOOP
-#endif
-
 #endif // MOTION_H

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5bceeaded4..a680c01c9e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -69,21 +69,26 @@ extern const float homing_feedrate_mm_s[4];
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 extern float feedrate_mm_s;
 
 /**
  * Feedrate scaling and conversion
  */
 extern int16_t feedrate_percentage;
 #define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
-extern uint8_t active_extruder;
+// The active extruder (tool). Set with T<extruder> command.
+#if EXTRUDERS > 1
+  extern uint8_t active_extruder;
+#else
+  constexpr uint8_t active_extruder = 0;
+#endif
 
 #if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
 #endif
 
 extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
 

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7bc8492162..5bceeaded4 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -299,33 +299,33 @@ void homeaxis(const AxisEnum axis);
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
-  extern bool symmetric_duplication_mode;         // Used in Dual X mode 2
+  extern bool extruder_duplication_enabled,       // Used in Dual X mode 2
+              symmetric_duplication_mode;         // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,  // DUAL_X_CARRIAGE only
     DXC_AUTO_PARK_MODE,     // DUAL_X_CARRIAGE only
-    DXC_DUPLICATION_MODE,
+    DXC_DUPLICATION_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
                duplicate_extruder_x_offset;       // used in mode 2 & 3
   extern bool active_extruder_parked;             // used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2 & 3
 

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 51e0478928..7bc8492162 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -300,40 +300,41 @@ void homeaxis(const AxisEnum axis);
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
+  extern bool symmetric_duplication_mode;         // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,  // DUAL_X_CARRIAGE only
     DXC_AUTO_PARK_MODE,     // DUAL_X_CARRIAGE only
-    DXC_DUPLICATION_MODE
+    DXC_DUPLICATION_MODE,
   };
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
-               duplicate_extruder_x_offset;       // used in mode 2
-  extern bool active_extruder_parked;             // used in mode 1 & 2
+               duplicate_extruder_x_offset;       // used in mode 2 & 3
+  extern bool active_extruder_parked;             // used in mode 1, 2 & 3
   extern millis_t delayed_move_time;              // used in mode 1
-  extern int16_t duplicate_extruder_temp_offset;  // used in mode 2
+  extern int16_t duplicate_extruder_temp_offset;  // used in mode 2 & 3
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   enum DualXMode : char {
     DXC_DUPLICATION_MODE = 2
   };

commit d1c9517903da3e7ab84e34ffb2c23d0772f2ce8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:26:29 2018 -0500

    Followup to hotend_offset[Z] patch

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 6850250b6a..51e0478928 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -71,21 +71,21 @@ FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&ho
 extern float feedrate_mm_s;
 
 /**
  * Feedrate scaling and conversion
  */
 extern int16_t feedrate_percentage;
 #define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
 extern uint8_t active_extruder;
 
-#if HOTENDS > 1
+#if HAS_HOTEND_OFFSET
   extern float hotend_offset[XYZ][HOTENDS];
 #endif
 
 extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
 
 #define XYZ_DEFS(type, array, CONFIG) \
   extern const type array##_P[XYZ]; \

commit f0dbe61692247772c686bd2e1fb6be08810d6942
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Aug 21 23:33:55 2018 -0500

    Tweaks to motion.h reachable tests

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a94d90f91b..6850250b6a 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -29,20 +29,23 @@
 
 #ifndef MOTION_H
 #define MOTION_H
 
 #include "../inc/MarlinConfig.h"
 
 #if IS_SCARA
   #include "../module/scara.h"
 #endif
 
+// Error margin to work around float imprecision
+constexpr float slop = 0.0001;
+
 extern bool relative_mode;
 
 extern float current_position[XYZE],  // High-level current tool position
              destination[XYZE];       // Destination for a move
 
 // Scratch space for a cartesian result
 extern float cartes[XYZ];
 
 // Until kinematics.cpp is created, declare this here
 #if IS_KINEMATIC
@@ -258,51 +261,45 @@ void homeaxis(const AxisEnum axis);
     // Return true if the both nozzle and the probe can reach the given point.
     // Note: This won't work on SCARA since the probe offset rotates with the arm.
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
-   // Return true if the given position is within the machine bounds.
+  // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
+    if (!WITHIN(ry, Y_MIN_POS - slop, Y_MAX_POS + slop)) return false;
     #if ENABLED(DUAL_X_CARRIAGE)
-      if (active_extruder == 0) {
-        // Add 0.001 margin to deal with float imprecision
-        return WITHIN(rx, X1_MIN_POS - 0.001f, X1_MAX_POS + 0.001f)
-            && WITHIN(ry,  Y_MIN_POS - 0.001f,  Y_MAX_POS + 0.001f);
-      } else {
-       // Add 0.001 margin to deal with float imprecision
-       return WITHIN(rx, X2_MIN_POS - 0.001f, X2_MAX_POS + 0.001f)
-           && WITHIN(ry,  Y_MIN_POS - 0.001f,  Y_MAX_POS + 0.001f);
-      }
+      if (active_extruder)
+        return WITHIN(rx, X2_MIN_POS - slop, X2_MAX_POS + slop);
+      else
+        return WITHIN(rx, X1_MIN_POS - slop, X1_MAX_POS + slop);
     #else
-      // Add 0.001 margin to deal with float imprecision
-      return WITHIN(rx, X_MIN_POS - 0.001f, X_MAX_POS + 0.001f)
-          && WITHIN(ry, Y_MIN_POS - 0.001f, Y_MAX_POS + 0.001f);
+      return WITHIN(rx, X_MIN_POS - slop, X_MAX_POS + slop);
     #endif
   }
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
-          && WITHIN(rx, MIN_PROBE_X - 0.001f, MAX_PROBE_X + 0.001f)
-          && WITHIN(ry, MIN_PROBE_Y - 0.001f, MAX_PROBE_Y + 0.001f);
+          && WITHIN(rx, MIN_PROBE_X - slop, MAX_PROBE_X + slop)
+          && WITHIN(ry, MIN_PROBE_Y - slop, MAX_PROBE_Y + slop);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**

commit cd9868f442d07ff2de8491c064422f044c6e8f80
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Aug 21 19:12:26 2018 -0500

    Make position_is_reachable() smarter about IDEX machines`
    
    On many IDEX machines the allowed travel of the X1 carraige and X2 carraige does not perfectly overlap.
    
    This helps the issue.   But more work needs to be done at the higher level.  (For example the X1_MAX_POS should probably be factored into G26's mesh validation pattern.)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 78646a9f45..a94d90f91b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -260,23 +260,35 @@ void homeaxis(const AxisEnum axis);
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
    // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
-    // Add 0.001 margin to deal with float imprecision
-    return WITHIN(rx, X_MIN_POS - 0.001f, X_MAX_POS + 0.001f)
-        && WITHIN(ry, Y_MIN_POS - 0.001f, Y_MAX_POS + 0.001f);
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (active_extruder == 0) {
+        // Add 0.001 margin to deal with float imprecision
+        return WITHIN(rx, X1_MIN_POS - 0.001f, X1_MAX_POS + 0.001f)
+            && WITHIN(ry,  Y_MIN_POS - 0.001f,  Y_MAX_POS + 0.001f);
+      } else {
+       // Add 0.001 margin to deal with float imprecision
+       return WITHIN(rx, X2_MIN_POS - 0.001f, X2_MAX_POS + 0.001f)
+           && WITHIN(ry,  Y_MIN_POS - 0.001f,  Y_MAX_POS + 0.001f);
+      }
+    #else
+      // Add 0.001 margin to deal with float imprecision
+      return WITHIN(rx, X_MIN_POS - 0.001f, X_MAX_POS + 0.001f)
+          && WITHIN(ry, Y_MIN_POS - 0.001f, Y_MAX_POS + 0.001f);
+    #endif
   }
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 71288cb032..78646a9f45 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -64,21 +64,21 @@ extern float cartes[XYZ];
  */
 extern const float homing_feedrate_mm_s[4];
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 extern float feedrate_mm_s;
 
 /**
  * Feedrate scaling and conversion
  */
 extern int16_t feedrate_percentage;
-#define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01)
+#define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01f)
 
 extern uint8_t active_extruder;
 
 #if HOTENDS > 1
   extern float hotend_offset[XYZ][HOTENDS];
 #endif
 
 extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
@@ -134,32 +134,32 @@ void sync_plan_position_e();
  */
 void line_to_current_position();
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
 void buffer_line_to_destination(const float fr_mm_s);
 
 #if IS_KINEMATIC
-  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0);
+  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0);
 #endif
 
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0.0);
-void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0.0);
-void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0.0);
-void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0.0);
+void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0);
+void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0);
+void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0);
+void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0);
 
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 void bracket_probe_move(const bool before);
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 //
 // Homing
@@ -261,36 +261,36 @@ void homeaxis(const AxisEnum axis);
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
              && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
    // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     // Add 0.001 margin to deal with float imprecision
-    return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
-        && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
+    return WITHIN(rx, X_MIN_POS - 0.001f, X_MAX_POS + 0.001f)
+        && WITHIN(ry, Y_MIN_POS - 0.001f, Y_MAX_POS + 0.001f);
   }
 
   #if HAS_BED_PROBE
     /**
      * Return whether the given position is within the bed, and whether the nozzle
      * can reach the position required to put the probe at the given position.
      *
      * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
      *          nozzle must be be able to reach +10,-10.
      */
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
-          && WITHIN(rx, MIN_PROBE_X - 0.001, MAX_PROBE_X + 0.001)
-          && WITHIN(ry, MIN_PROBE_Y - 0.001, MAX_PROBE_Y + 0.001);
+          && WITHIN(rx, MIN_PROBE_X - 0.001f, MAX_PROBE_X + 0.001f)
+          && WITHIN(ry, MIN_PROBE_Y - 0.001f, MAX_PROBE_Y + 0.001f);
     }
   #endif
 
 #endif // CARTESIAN
 
 #if !HAS_BED_PROBE
   FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
 #endif
 
 /**

commit 90ba77ea0fcaabe604aff9190d42595dd3bb9f2a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 30 18:13:13 2018 -0500

    Lose the old HOMEAXIS macro

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index e06474654d..71288cb032 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -182,21 +182,20 @@ void clean_up_after_endstop_or_probe_move();
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
-#define HOMEAXIS(A) homeaxis(_AXIS(A))
 
 #if ENABLED(SENSORLESS_HOMING)
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
 #endif
 
 //
 // Macros
 //
 
 /**

commit 08e36e264e72f56bada1f25c1a784d6e3f9d2135
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:44:24 2018 -0500

    Apply _AXIS macro

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2535f07c98..e06474654d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -182,21 +182,21 @@ void clean_up_after_endstop_or_probe_move();
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
-#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+#define HOMEAXIS(A) homeaxis(_AXIS(A))
 
 #if ENABLED(SENSORLESS_HOMING)
   void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
 #endif
 
 //
 // Macros
 //
 
 /**

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 486677c4d9..2535f07c98 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -253,21 +253,21 @@ void homeaxis(const AxisEnum axis);
         #endif
       );
     #endif
   }
 
   #if HAS_BED_PROBE
     // Return true if the both nozzle and the probe can reach the given point.
     // Note: This won't work on SCARA since the probe offset rotates with the arm.
     inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
-             && position_is_reachable(rx, ry, FABS(MIN_PROBE_EDGE));
+             && position_is_reachable(rx, ry, ABS(MIN_PROBE_EDGE));
     }
   #endif
 
 #else // CARTESIAN
 
    // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     // Add 0.001 margin to deal with float imprecision
     return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
         && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);

commit e8e60263c8e454454d126f9154cf5c7ac3213725
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 5 15:47:56 2018 -0500

    Scale feedrate (mm/s to deg/s) for SCARA

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 25b5a431fc..486677c4d9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -333,11 +333,27 @@ void homeaxis(const AxisEnum axis);
 #endif
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  #if ENABLED(DELTA)
+    #define ADJUST_DELTA(V) \
+      if (planner.leveling_active) { \
+        const float zadj = bilinear_z_offset(V); \
+        delta[A_AXIS] += zadj; \
+        delta[B_AXIS] += zadj; \
+        delta[C_AXIS] += zadj; \
+      }
+  #else
+    #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
+  #endif
+#else
+  #define ADJUST_DELTA(V) NOOP
+#endif
+
 #endif // MOTION_H

commit 14c03cb6f4bf20b06ba5d6c849cd1a15341627df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 13 01:15:22 2018 -0500

    [2.0.x] Make MIN_PROBE_EDGE a general option (for electronic probes) (#10069)
    
    Some probes don't work near the edges of the bed. This change promotes MIN_PROBE_EDGE to a general setting that applies to all probing functions.

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 928e9f0f19..25b5a431fc 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -229,69 +229,78 @@ void homeaxis(const AxisEnum axis);
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
+  #if IS_SCARA
+    extern const float L1, L2;
+  #endif
+
   // Return true if the given point is within the printable area
-  inline bool position_is_reachable(const float &rx, const float &ry) {
+  inline bool position_is_reachable(const float &rx, const float &ry, const float inset=0) {
     #if ENABLED(DELTA)
-      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);
+      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS - inset);
     #elif IS_SCARA
-      #if MIDDLE_DEAD_ZONE_R > 0
-        const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
-        return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
-      #else
-        return HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y) <= sq(L1 + L2);
-      #endif
-    #else // CARTESIAN
-      // To be migrated from MakerArm branch in future
+      const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
+      return (
+        R2 <= sq(L1 + L2) - inset
+        #if MIDDLE_DEAD_ZONE_R > 0
+          && R2 >= sq(float(MIDDLE_DEAD_ZONE_R))
+        #endif
+      );
     #endif
   }
 
-  // Return true if the both nozzle and the probe can reach the given point.
-  // Note: This won't work on SCARA since the probe offset rotates with the arm.
-  inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-    return position_is_reachable(rx, ry)
-        && position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-  }
+  #if HAS_BED_PROBE
+    // Return true if the both nozzle and the probe can reach the given point.
+    // Note: This won't work on SCARA since the probe offset rotates with the arm.
+    inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
+      return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+             && position_is_reachable(rx, ry, FABS(MIN_PROBE_EDGE));
+    }
+  #endif
 
 #else // CARTESIAN
 
    // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     // Add 0.001 margin to deal with float imprecision
     return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
         && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
   }
 
-  /**
-   * Return whether the given position is within the bed, and whether the nozzle
-   * can reach the position required to put the probe at the given position.
-   *
-   * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
-   *          nozzle must be be able to reach +10,-10.
-   */
-  inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-    const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER),
-                ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
-    return position_is_reachable(nx, ny)
-        && WITHIN(rx, X_MIN_BED - 0.001, X_MAX_BED + 0.001)
-        && WITHIN(ry, Y_MIN_BED - 0.001, Y_MAX_BED + 0.001);
-  }
+  #if HAS_BED_PROBE
+    /**
+     * Return whether the given position is within the bed, and whether the nozzle
+     * can reach the position required to put the probe at the given position.
+     *
+     * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
+     *          nozzle must be be able to reach +10,-10.
+     */
+    inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
+      return position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+          && WITHIN(rx, MIN_PROBE_X - 0.001, MAX_PROBE_X + 0.001)
+          && WITHIN(ry, MIN_PROBE_Y - 0.001, MAX_PROBE_Y + 0.001);
+    }
+  #endif
 
 #endif // CARTESIAN
 
+#if !HAS_BED_PROBE
+  FORCE_INLINE bool position_is_reachable_by_probe(const float &rx, const float &ry) { return position_is_reachable(rx, ry); }
+#endif
+
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */

commit 468f34104b0e71a3561d2dd99756220f90671e54
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 12 08:16:08 2018 -0500

    Patch do_blocking_move_to so 'destination' can be used

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 78ef15524e..928e9f0f19 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -142,24 +142,24 @@ void buffer_line_to_destination(const float fr_mm_s);
 
 #if IS_KINEMATIC
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0);
 #endif
 
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */
-void do_blocking_move_to(const float &x, const float &y, const float &z, const float &fr_mm_s=0.0);
-void do_blocking_move_to_x(const float &x, const float &fr_mm_s=0.0);
-void do_blocking_move_to_z(const float &z, const float &fr_mm_s=0.0);
-void do_blocking_move_to_xy(const float &x, const float &y, const float &fr_mm_s=0.0);
+void do_blocking_move_to(const float rx, const float ry, const float rz, const float &fr_mm_s=0.0);
+void do_blocking_move_to_x(const float &rx, const float &fr_mm_s=0.0);
+void do_blocking_move_to_z(const float &rz, const float &fr_mm_s=0.0);
+void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s=0.0);
 
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 void bracket_probe_move(const bool before);
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 //
 // Homing

commit 2908e76151f894bae27f6f455cfbea51e2dc1e41
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 21:12:05 2018 -0600

    Fix position_is_reachable_by_probe typo, add comment
    
    Fix #10029

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a7a3711348..78ef15524e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -229,57 +229,65 @@ void homeaxis(const AxisEnum axis);
 #define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
 #define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
+  // Return true if the given point is within the printable area
   inline bool position_is_reachable(const float &rx, const float &ry) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);
     #elif IS_SCARA
       #if MIDDLE_DEAD_ZONE_R > 0
         const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
         return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
       #else
         return HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y) <= sq(L1 + L2);
       #endif
     #else // CARTESIAN
       // To be migrated from MakerArm branch in future
     #endif
   }
 
+  // Return true if the both nozzle and the probe can reach the given point.
+  // Note: This won't work on SCARA since the probe offset rotates with the arm.
   inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-
-    // Both the nozzle and the probe must be able to reach the point.
-    // This won't work on SCARA since the probe offset rotates with the arm.
-
     return position_is_reachable(rx, ry)
         && position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER));
   }
 
 #else // CARTESIAN
 
+   // Return true if the given position is within the machine bounds.
   inline bool position_is_reachable(const float &rx, const float &ry) {
     // Add 0.001 margin to deal with float imprecision
     return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
         && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
   }
 
+  /**
+   * Return whether the given position is within the bed, and whether the nozzle
+   * can reach the position required to put the probe at the given position.
+   *
+   * Example: For a probe offset of -10,+10, then for the probe to reach 0,0 the
+   *          nozzle must be be able to reach +10,-10.
+   */
   inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-    const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
-    return position_is_reachable(rx, ry)
-        && WITHIN(nx, X_MIN_BED - 0.001, X_MAX_BED + 0.001)
-        && WITHIN(ny, Y_MIN_BED - 0.001, Y_MAX_BED + 0.001);
+    const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER),
+                ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
+    return position_is_reachable(nx, ny)
+        && WITHIN(rx, X_MIN_BED - 0.001, X_MAX_BED + 0.001)
+        && WITHIN(ry, Y_MIN_BED - 0.001, Y_MAX_BED + 0.001);
   }
 
 #endif // CARTESIAN
 
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif

commit dfd5d2fe75d61360c03c42cd56764ceb9a3ffc8a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 9 03:37:30 2018 -0600

    Have position_is_reachable_by_probe use the whole bed (#10020)
    
    Previously `position_is_reachable_by_probe` was limited to the area specified for `G29` mesh leveling (even if leveling was disabled). This change will properly consider the entire bed area so that `G30` and other non-leveling probing may take place.

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index a2e0748893..a7a3711348 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -256,29 +256,30 @@ void homeaxis(const AxisEnum axis);
     // Both the nozzle and the probe must be able to reach the point.
     // This won't work on SCARA since the probe offset rotates with the arm.
 
     return position_is_reachable(rx, ry)
         && position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER));
   }
 
 #else // CARTESIAN
 
   inline bool position_is_reachable(const float &rx, const float &ry) {
-      // Add 0.001 margin to deal with float imprecision
-      return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
-          && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
+    // Add 0.001 margin to deal with float imprecision
+    return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
+        && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
   }
 
   inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
-      // Add 0.001 margin to deal with float imprecision
-      return WITHIN(rx, MIN_PROBE_X - 0.001, MAX_PROBE_X + 0.001)
-          && WITHIN(ry, MIN_PROBE_Y - 0.001, MAX_PROBE_Y + 0.001);
+    const float nx = rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ry - (Y_PROBE_OFFSET_FROM_EXTRUDER);
+    return position_is_reachable(rx, ry)
+        && WITHIN(nx, X_MIN_BED - 0.001, X_MAX_BED + 0.001)
+        && WITHIN(ny, Y_MIN_BED - 0.001, Y_MAX_BED + 0.001);
   }
 
 #endif // CARTESIAN
 
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index bb478d624b..a2e0748893 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -281,41 +281,41 @@ void homeaxis(const AxisEnum axis);
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
-  enum DualXMode {
+  enum DualXMode : char {
     DXC_FULL_CONTROL_MODE,  // DUAL_X_CARRIAGE only
     DXC_AUTO_PARK_MODE,     // DUAL_X_CARRIAGE only
     DXC_DUPLICATION_MODE
   };
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
                duplicate_extruder_x_offset;       // used in mode 2
   extern bool active_extruder_parked;             // used in mode 1 & 2
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
-  enum DualXMode {
+  enum DualXMode : char {
     DXC_DUPLICATION_MODE = 2
   };
 
 #endif
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND

commit a446433c87dc8b715ed5b9d98a34104f90b676b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 1 01:37:31 2018 -0600

    Fix SENSORLESS_HOMING for Core Kinematics (#9868)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 3222f12990..bb478d624b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -184,20 +184,24 @@ void clean_up_after_endstop_or_probe_move();
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()
 #endif
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
+#if ENABLED(SENSORLESS_HOMING)
+  void sensorless_homing_per_axis(const AxisEnum axis, const bool enable=true);
+#endif
+
 //
 // Macros
 //
 
 /**
  * Workspace offsets
  */
 #if HAS_WORKSPACE_OFFSET
   #if HAS_HOME_OFFSET
     extern float home_offset[XYZ];

commit 2c9775313a5a209822c9df4b0a907e406e672158
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 23 00:42:42 2018 -0600

    Fix Z position on HD44780
    
    Fix #9732

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index ea057695b9..3222f12990 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -188,58 +188,50 @@ void clean_up_after_endstop_or_probe_move();
 
 void set_axis_is_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
 //
 // Macros
 //
 
-// Workspace offsets
+/**
+ * Workspace offsets
+ */
 #if HAS_WORKSPACE_OFFSET
   #if HAS_HOME_OFFSET
     extern float home_offset[XYZ];
   #endif
   #if HAS_POSITION_SHIFT
     extern float position_shift[XYZ];
   #endif
-#endif
-
-#if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-  extern float workspace_offset[XYZ];
-  #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
-#elif HAS_HOME_OFFSET
-  #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
-#elif HAS_POSITION_SHIFT
-  #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
-#else
-  #define WORKSPACE_OFFSET(AXIS) 0
-#endif
-
-#define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
-#define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - WORKSPACE_OFFSET(AXIS))
-
-#if HAS_POSITION_SHIFT || DISABLED(DELTA)
-  #define LOGICAL_X_POSITION(POS)   NATIVE_TO_LOGICAL(POS, X_AXIS)
-  #define LOGICAL_Y_POSITION(POS)   NATIVE_TO_LOGICAL(POS, Y_AXIS)
-  #define RAW_X_POSITION(POS)       LOGICAL_TO_NATIVE(POS, X_AXIS)
-  #define RAW_Y_POSITION(POS)       LOGICAL_TO_NATIVE(POS, Y_AXIS)
+  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+    extern float workspace_offset[XYZ];
+    #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
+  #elif HAS_HOME_OFFSET
+    #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
+  #elif HAS_POSITION_SHIFT
+    #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
+  #endif
+  #define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
+  #define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - WORKSPACE_OFFSET(AXIS))
 #else
-  #define LOGICAL_X_POSITION(POS)   (POS)
-  #define LOGICAL_Y_POSITION(POS)   (POS)
-  #define RAW_X_POSITION(POS)       (POS)
-  #define RAW_Y_POSITION(POS)       (POS)
+  #define NATIVE_TO_LOGICAL(POS, AXIS) (POS)
+  #define LOGICAL_TO_NATIVE(POS, AXIS) (POS)
 #endif
-
-#define LOGICAL_Z_POSITION(POS)     NATIVE_TO_LOGICAL(POS, Z_AXIS)
-#define RAW_Z_POSITION(POS)         LOGICAL_TO_NATIVE(POS, Z_AXIS)
+#define LOGICAL_X_POSITION(POS) NATIVE_TO_LOGICAL(POS, X_AXIS)
+#define LOGICAL_Y_POSITION(POS) NATIVE_TO_LOGICAL(POS, Y_AXIS)
+#define LOGICAL_Z_POSITION(POS) NATIVE_TO_LOGICAL(POS, Z_AXIS)
+#define RAW_X_POSITION(POS)     LOGICAL_TO_NATIVE(POS, X_AXIS)
+#define RAW_Y_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Y_AXIS)
+#define RAW_Z_POSITION(POS)     LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
   inline bool position_is_reachable(const float &rx, const float &ry) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);

commit ea9ad4e46d9dea69e1e3fe851912f287f12d2ad1
Author: GMagician <3684609+GMagician@users.noreply.github.com>
Date:   Fri Feb 2 08:44:48 2018 +0100

    [2.0.x] Fix compile error on delta when NO_WORKSPACE_OFFSETS (#9388)

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 0c88af4c6c..ea057695b9 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -311,19 +311,19 @@ void homeaxis(const AxisEnum axis);
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
 
   enum DualXMode {
     DXC_DUPLICATION_MODE = 2
   };
 
 #endif
 
-#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(DELTA)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
 #endif // MOTION_H

commit 25af9decfed2c87c782595013e80233364581319
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 19 15:11:11 2017 -0600

    Remove enum.h include of MarlinConfig.h

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 7edbd29b3d..0c88af4c6c 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -285,33 +285,45 @@ void homeaxis(const AxisEnum axis);
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */
 #if ENABLED(DUAL_X_CARRIAGE)
 
+  enum DualXMode {
+    DXC_FULL_CONTROL_MODE,  // DUAL_X_CARRIAGE only
+    DXC_AUTO_PARK_MODE,     // DUAL_X_CARRIAGE only
+    DXC_DUPLICATION_MODE
+  };
+
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
                duplicate_extruder_x_offset;       // used in mode 2
   extern bool active_extruder_parked;             // used in mode 1 & 2
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
-#endif // DUAL_X_CARRIAGE
+#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+
+  enum DualXMode {
+    DXC_DUPLICATION_MODE = 2
+  };
+
+#endif
 
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
   void update_software_endstops(const AxisEnum axis);
 #endif
 
 #if HAS_M206_COMMAND
   void set_home_offset(const AxisEnum axis, const float v);
 #endif
 
 #endif // MOTION_H

commit 04abd8d45901199e03ded423478885b659eb65e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 13 01:34:19 2017 -0600

    Improve and clarify M428 code

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 826091c8ca..7edbd29b3d 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -166,20 +166,21 @@ void clean_up_after_endstop_or_probe_move();
 //
 
 #define HAS_AXIS_UNHOMED_ERR (                                                     \
          ENABLED(Z_PROBE_ALLEN_KEY)                                                \
       || ENABLED(Z_PROBE_SLED)                                                     \
       || HAS_PROBING_PROCEDURE                                                     \
       || HOTENDS > 1                                                               \
       || ENABLED(NOZZLE_CLEAN_FEATURE)                                             \
       || ENABLED(NOZZLE_PARK_FEATURE)                                              \
       || (ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(HOME_BEFORE_FILAMENT_CHANGE)) \
+      || HAS_M206_COMMAND                                                          \
     ) || ENABLED(NO_MOTION_BEFORE_HOMING)
 
 #if HAS_AXIS_UNHOMED_ERR
   bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
 #endif
 
 #if ENABLED(NO_MOTION_BEFORE_HOMING)
   #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
 #else
   #define MOTION_CONDITIONS IsRunning()

commit 75a58ee4b875630089574f497026a419d7e66d86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 9 23:22:11 2017 -0600

    Fix position_is_reachable bug in waiting

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 852633482e..826091c8ca 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -253,21 +253,21 @@ void homeaxis(const AxisEnum axis);
       // To be migrated from MakerArm branch in future
     #endif
   }
 
   inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
 
     // Both the nozzle and the probe must be able to reach the point.
     // This won't work on SCARA since the probe offset rotates with the arm.
 
     return position_is_reachable(rx, ry)
-        && position_is_reachable(rx - X_PROBE_OFFSET_FROM_EXTRUDER, ry - Y_PROBE_OFFSET_FROM_EXTRUDER);
+        && position_is_reachable(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), ry - (Y_PROBE_OFFSET_FROM_EXTRUDER));
   }
 
 #else // CARTESIAN
 
   inline bool position_is_reachable(const float &rx, const float &ry) {
       // Add 0.001 margin to deal with float imprecision
       return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
           && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
   }
 

commit 0cfb936dd124d22a6079a5e85802ddc14f0b4328
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 8 22:13:33 2017 -0600

    Clarify some motion code

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index d01a3f5eeb..852633482e 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -131,23 +131,21 @@ void sync_plan_position_e();
 /**
  * Move the planner to the current position from wherever it last moved
  * (or from wherever it has been told it is located).
  */
 void line_to_current_position();
 
 /**
  * Move the planner to the position stored in the destination array, which is
  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
  */
-void line_to_destination(const float fr_mm_s);
-
-inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
+void buffer_line_to_destination(const float fr_mm_s);
 
 #if IS_KINEMATIC
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0);
 #endif
 
 void prepare_move_to_destination();
 
 /**
  * Blocking movement and shorthand functions
  */

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 2a2449ef34..d01a3f5eeb 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -210,93 +210,84 @@ void homeaxis(const AxisEnum axis);
   extern float workspace_offset[XYZ];
   #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
 #elif HAS_HOME_OFFSET
   #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
 #elif HAS_POSITION_SHIFT
   #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
 #else
   #define WORKSPACE_OFFSET(AXIS) 0
 #endif
 
-#define LOGICAL_POSITION(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
-#define RAW_POSITION(POS, AXIS)     ((POS) - WORKSPACE_OFFSET(AXIS))
+#define NATIVE_TO_LOGICAL(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
+#define LOGICAL_TO_NATIVE(POS, AXIS) ((POS) - WORKSPACE_OFFSET(AXIS))
 
 #if HAS_POSITION_SHIFT || DISABLED(DELTA)
-  #define LOGICAL_X_POSITION(POS)   LOGICAL_POSITION(POS, X_AXIS)
-  #define LOGICAL_Y_POSITION(POS)   LOGICAL_POSITION(POS, Y_AXIS)
-  #define RAW_X_POSITION(POS)       RAW_POSITION(POS, X_AXIS)
-  #define RAW_Y_POSITION(POS)       RAW_POSITION(POS, Y_AXIS)
+  #define LOGICAL_X_POSITION(POS)   NATIVE_TO_LOGICAL(POS, X_AXIS)
+  #define LOGICAL_Y_POSITION(POS)   NATIVE_TO_LOGICAL(POS, Y_AXIS)
+  #define RAW_X_POSITION(POS)       LOGICAL_TO_NATIVE(POS, X_AXIS)
+  #define RAW_Y_POSITION(POS)       LOGICAL_TO_NATIVE(POS, Y_AXIS)
 #else
   #define LOGICAL_X_POSITION(POS)   (POS)
   #define LOGICAL_Y_POSITION(POS)   (POS)
   #define RAW_X_POSITION(POS)       (POS)
   #define RAW_Y_POSITION(POS)       (POS)
 #endif
 
-#define LOGICAL_Z_POSITION(POS)     LOGICAL_POSITION(POS, Z_AXIS)
-#define RAW_Z_POSITION(POS)         RAW_POSITION(POS, Z_AXIS)
-#define RAW_CURRENT_POSITION(A)     RAW_##A##_POSITION(current_position[A##_AXIS])
+#define LOGICAL_Z_POSITION(POS)     NATIVE_TO_LOGICAL(POS, Z_AXIS)
+#define RAW_Z_POSITION(POS)         LOGICAL_TO_NATIVE(POS, Z_AXIS)
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
-  inline bool position_is_reachable_raw_xy(const float &rx, const float &ry) {
+  inline bool position_is_reachable(const float &rx, const float &ry) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);
     #elif IS_SCARA
       #if MIDDLE_DEAD_ZONE_R > 0
         const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
         return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
       #else
         return HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y) <= sq(L1 + L2);
       #endif
     #else // CARTESIAN
       // To be migrated from MakerArm branch in future
     #endif
   }
 
-  inline bool position_is_reachable_by_probe_raw_xy(const float &rx, const float &ry) {
+  inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
 
     // Both the nozzle and the probe must be able to reach the point.
     // This won't work on SCARA since the probe offset rotates with the arm.
 
-    return position_is_reachable_raw_xy(rx, ry)
-        && position_is_reachable_raw_xy(rx - X_PROBE_OFFSET_FROM_EXTRUDER, ry - Y_PROBE_OFFSET_FROM_EXTRUDER);
+    return position_is_reachable(rx, ry)
+        && position_is_reachable(rx - X_PROBE_OFFSET_FROM_EXTRUDER, ry - Y_PROBE_OFFSET_FROM_EXTRUDER);
   }
 
 #else // CARTESIAN
 
-  inline bool position_is_reachable_raw_xy(const float &rx, const float &ry) {
+  inline bool position_is_reachable(const float &rx, const float &ry) {
       // Add 0.001 margin to deal with float imprecision
       return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
           && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
   }
 
-  inline bool position_is_reachable_by_probe_raw_xy(const float &rx, const float &ry) {
+  inline bool position_is_reachable_by_probe(const float &rx, const float &ry) {
       // Add 0.001 margin to deal with float imprecision
       return WITHIN(rx, MIN_PROBE_X - 0.001, MAX_PROBE_X + 0.001)
           && WITHIN(ry, MIN_PROBE_Y - 0.001, MAX_PROBE_Y + 0.001);
   }
 
 #endif // CARTESIAN
 
-FORCE_INLINE bool position_is_reachable_by_probe_xy(const float &lx, const float &ly) {
-  return position_is_reachable_by_probe_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
-}
-
-FORCE_INLINE bool position_is_reachable_xy(const float &lx, const float &ly) {
-  return position_is_reachable_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
-}
-
 /**
  * Dual X Carriage / Dual Nozzle
  */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
 /**
  * Dual X Carriage
  */

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 5da373354b..2a2449ef34 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -99,22 +99,22 @@ XYZ_DEFS(signed char, home_dir, HOME_DIR);
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   void clamp_to_software_endstops(float target[XYZ]);
 #else
   #define soft_endstops_enabled false
   #define clamp_to_software_endstops(x) NOOP
 #endif
 
 void report_current_position();
 
-inline void set_current_to_destination() { COPY(current_position, destination); }
-inline void set_destination_to_current() { COPY(destination, current_position); }
+inline void set_current_from_destination() { COPY(current_position, destination); }
+inline void set_destination_from_current() { COPY(destination, current_position); }
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */

commit 90af1fe5eefd353c9fb9c40430f45031147fd675
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:34:58 2017 -0500

    Implement NO_MOTION_BEFORE_HOMING option

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index 084868e58f..5da373354b 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -160,26 +160,40 @@ void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 void bracket_probe_move(const bool before);
 void setup_for_endstop_or_probe_move();
 void clean_up_after_endstop_or_probe_move();
 
 //
 // Homing
 //
 
-#define NEED_UNHOMED_ERR (HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION))
-
-#if NEED_UNHOMED_ERR
+#define HAS_AXIS_UNHOMED_ERR (                                                     \
+         ENABLED(Z_PROBE_ALLEN_KEY)                                                \
+      || ENABLED(Z_PROBE_SLED)                                                     \
+      || HAS_PROBING_PROCEDURE                                                     \
+      || HOTENDS > 1                                                               \
+      || ENABLED(NOZZLE_CLEAN_FEATURE)                                             \
+      || ENABLED(NOZZLE_PARK_FEATURE)                                              \
+      || (ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(HOME_BEFORE_FILAMENT_CHANGE)) \
+    ) || ENABLED(NO_MOTION_BEFORE_HOMING)
+
+#if HAS_AXIS_UNHOMED_ERR
   bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
 #endif
 
+#if ENABLED(NO_MOTION_BEFORE_HOMING)
+  #define MOTION_CONDITIONS (IsRunning() && !axis_unhomed_error())
+#else
+  #define MOTION_CONDITIONS IsRunning()
+#endif
+
 void set_axis_is_at_home(const AxisEnum axis);
 
 void homeaxis(const AxisEnum axis);
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
 //
 // Macros
 //
 
 // Workspace offsets

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
index f146c3c0a2..084868e58f 100644
--- a/Marlin/src/module/motion.h
+++ b/Marlin/src/module/motion.h
@@ -25,34 +25,67 @@
  *
  * High-level motion commands to feed the planner
  * Some of these methods may migrate to the planner class.
  */
 
 #ifndef MOTION_H
 #define MOTION_H
 
 #include "../inc/MarlinConfig.h"
 
-//#include "../HAL/HAL.h"
-
-// #if ENABLED(DELTA)
-//   #include "../module/delta.h"
-// #endif
+#if IS_SCARA
+  #include "../module/scara.h"
+#endif
 
 extern bool relative_mode;
 
-extern float current_position[XYZE], destination[XYZE];
+extern float current_position[XYZE],  // High-level current tool position
+             destination[XYZE];       // Destination for a move
+
+// Scratch space for a cartesian result
+extern float cartes[XYZ];
+
+// Until kinematics.cpp is created, declare this here
+#if IS_KINEMATIC
+  extern float delta[ABC];
+#endif
+
+#if OLDSCHOOL_ABL
+  extern float xy_probe_feedrate_mm_s;
+  #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
+#elif defined(XY_PROBE_SPEED)
+  #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
+#else
+  #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
+#endif
+
+/**
+ * Feed rates are often configured with mm/m
+ * but the planner and stepper like mm/s units.
+ */
+extern const float homing_feedrate_mm_s[4];
+FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 extern float feedrate_mm_s;
 
+/**
+ * Feedrate scaling and conversion
+ */
+extern int16_t feedrate_percentage;
+#define MMS_SCALED(MM_S) ((MM_S)*feedrate_percentage*0.01)
+
 extern uint8_t active_extruder;
 
+#if HOTENDS > 1
+  extern float hotend_offset[XYZ][HOTENDS];
+#endif
+
 extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
 
 FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
 FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
 
 #define XYZ_DEFS(type, array, CONFIG) \
   extern const type array##_P[XYZ]; \
   FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
   typedef void __void_##CONFIG##__
 
@@ -64,23 +97,28 @@ XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
 XYZ_DEFS(signed char, home_dir, HOME_DIR);
 
 #if HAS_SOFTWARE_ENDSTOPS
   extern bool soft_endstops_enabled;
   void clamp_to_software_endstops(float target[XYZ]);
 #else
   #define soft_endstops_enabled false
   #define clamp_to_software_endstops(x) NOOP
 #endif
 
+void report_current_position();
+
 inline void set_current_to_destination() { COPY(current_position, destination); }
 inline void set_destination_to_current() { COPY(destination, current_position); }
 
+void get_cartesian_from_steppers();
+void set_current_from_steppers_for_axis(const AxisEnum axis);
+
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position();
 void sync_plan_position_e();
 
 #if IS_KINEMATIC
@@ -103,21 +141,49 @@ void line_to_current_position();
 void line_to_destination(const float fr_mm_s);
 
 inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
 
 #if IS_KINEMATIC
   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0);
 #endif
 
 void prepare_move_to_destination();
 
-void clamp_to_software_endstops(float target[XYZ]);
+/**
+ * Blocking movement and shorthand functions
+ */
+void do_blocking_move_to(const float &x, const float &y, const float &z, const float &fr_mm_s=0.0);
+void do_blocking_move_to_x(const float &x, const float &fr_mm_s=0.0);
+void do_blocking_move_to_z(const float &z, const float &fr_mm_s=0.0);
+void do_blocking_move_to_xy(const float &x, const float &y, const float &fr_mm_s=0.0);
+
+void setup_for_endstop_or_probe_move();
+void clean_up_after_endstop_or_probe_move();
+
+void bracket_probe_move(const bool before);
+void setup_for_endstop_or_probe_move();
+void clean_up_after_endstop_or_probe_move();
+
+//
+// Homing
+//
+
+#define NEED_UNHOMED_ERR (HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION))
+
+#if NEED_UNHOMED_ERR
+  bool axis_unhomed_error(const bool x=true, const bool y=true, const bool z=true);
+#endif
+
+void set_axis_is_at_home(const AxisEnum axis);
+
+void homeaxis(const AxisEnum axis);
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
 //
 // Macros
 //
 
 // Workspace offsets
 #if HAS_WORKSPACE_OFFSET
   #if HAS_HOME_OFFSET
     extern float home_offset[XYZ];
   #endif
@@ -155,24 +221,20 @@ void clamp_to_software_endstops(float target[XYZ]);
 #define LOGICAL_Z_POSITION(POS)     LOGICAL_POSITION(POS, Z_AXIS)
 #define RAW_Z_POSITION(POS)         RAW_POSITION(POS, Z_AXIS)
 #define RAW_CURRENT_POSITION(A)     RAW_##A##_POSITION(current_position[A##_AXIS])
 
 /**
  * position_is_reachable family of functions
  */
 
 #if IS_KINEMATIC // (DELTA or SCARA)
 
-  #if IS_SCARA
-    extern const float L1, L2;
-  #endif
-
   inline bool position_is_reachable_raw_xy(const float &rx, const float &ry) {
     #if ENABLED(DELTA)
       return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);
     #elif IS_SCARA
       #if MIDDLE_DEAD_ZONE_R > 0
         const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
         return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
       #else
         return HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y) <= sq(L1 + L2);
       #endif
@@ -207,31 +269,45 @@ void clamp_to_software_endstops(float target[XYZ]);
 #endif // CARTESIAN
 
 FORCE_INLINE bool position_is_reachable_by_probe_xy(const float &lx, const float &ly) {
   return position_is_reachable_by_probe_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
 }
 
 FORCE_INLINE bool position_is_reachable_xy(const float &lx, const float &ly) {
   return position_is_reachable_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
 }
 
+/**
+ * Dual X Carriage / Dual Nozzle
+ */
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
 #endif
 
+/**
+ * Dual X Carriage
+ */
 #if ENABLED(DUAL_X_CARRIAGE)
 
   extern DualXMode dual_x_carriage_mode;
   extern float inactive_extruder_x_pos,           // used in mode 0 & 1
                raised_parked_position[XYZE],      // used in mode 1
                duplicate_extruder_x_offset;       // used in mode 2
   extern bool active_extruder_parked;             // used in mode 1 & 2
   extern millis_t delayed_move_time;              // used in mode 1
   extern int16_t duplicate_extruder_temp_offset;  // used in mode 2
 
   float x_home_pos(const int extruder);
 
   FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
 
 #endif // DUAL_X_CARRIAGE
 
+#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+  void update_software_endstops(const AxisEnum axis);
+#endif
+
+#if HAS_M206_COMMAND
+  void set_home_offset(const AxisEnum axis, const float v);
+#endif
+
 #endif // MOTION_H

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/module/motion.h b/Marlin/src/module/motion.h
new file mode 100644
index 0000000000..f146c3c0a2
--- /dev/null
+++ b/Marlin/src/module/motion.h
@@ -0,0 +1,237 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * motion.h
+ *
+ * High-level motion commands to feed the planner
+ * Some of these methods may migrate to the planner class.
+ */
+
+#ifndef MOTION_H
+#define MOTION_H
+
+#include "../inc/MarlinConfig.h"
+
+//#include "../HAL/HAL.h"
+
+// #if ENABLED(DELTA)
+//   #include "../module/delta.h"
+// #endif
+
+extern bool relative_mode;
+
+extern float current_position[XYZE], destination[XYZE];
+
+extern float feedrate_mm_s;
+
+extern uint8_t active_extruder;
+
+extern float soft_endstop_min[XYZ], soft_endstop_max[XYZ];
+
+FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
+FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
+
+#define XYZ_DEFS(type, array, CONFIG) \
+  extern const type array##_P[XYZ]; \
+  FORCE_INLINE type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
+  typedef void __void_##CONFIG##__
+
+XYZ_DEFS(float, base_min_pos,   MIN_POS);
+XYZ_DEFS(float, base_max_pos,   MAX_POS);
+XYZ_DEFS(float, base_home_pos,  HOME_POS);
+XYZ_DEFS(float, max_length,     MAX_LENGTH);
+XYZ_DEFS(float, home_bump_mm,   HOME_BUMP_MM);
+XYZ_DEFS(signed char, home_dir, HOME_DIR);
+
+#if HAS_SOFTWARE_ENDSTOPS
+  extern bool soft_endstops_enabled;
+  void clamp_to_software_endstops(float target[XYZ]);
+#else
+  #define soft_endstops_enabled false
+  #define clamp_to_software_endstops(x) NOOP
+#endif
+
+inline void set_current_to_destination() { COPY(current_position, destination); }
+inline void set_destination_to_current() { COPY(destination, current_position); }
+
+/**
+ * sync_plan_position
+ *
+ * Set the planner/stepper positions directly from current_position with
+ * no kinematic translation. Used for homing axes and cartesian/core syncing.
+ */
+void sync_plan_position();
+void sync_plan_position_e();
+
+#if IS_KINEMATIC
+  void sync_plan_position_kinematic();
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
+#else
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
+#endif
+
+/**
+ * Move the planner to the current position from wherever it last moved
+ * (or from wherever it has been told it is located).
+ */
+void line_to_current_position();
+
+/**
+ * Move the planner to the position stored in the destination array, which is
+ * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
+ */
+void line_to_destination(const float fr_mm_s);
+
+inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
+
+#if IS_KINEMATIC
+  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0);
+#endif
+
+void prepare_move_to_destination();
+
+void clamp_to_software_endstops(float target[XYZ]);
+
+//
+// Macros
+//
+
+// Workspace offsets
+#if HAS_WORKSPACE_OFFSET
+  #if HAS_HOME_OFFSET
+    extern float home_offset[XYZ];
+  #endif
+  #if HAS_POSITION_SHIFT
+    extern float position_shift[XYZ];
+  #endif
+#endif
+
+#if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+  extern float workspace_offset[XYZ];
+  #define WORKSPACE_OFFSET(AXIS) workspace_offset[AXIS]
+#elif HAS_HOME_OFFSET
+  #define WORKSPACE_OFFSET(AXIS) home_offset[AXIS]
+#elif HAS_POSITION_SHIFT
+  #define WORKSPACE_OFFSET(AXIS) position_shift[AXIS]
+#else
+  #define WORKSPACE_OFFSET(AXIS) 0
+#endif
+
+#define LOGICAL_POSITION(POS, AXIS) ((POS) + WORKSPACE_OFFSET(AXIS))
+#define RAW_POSITION(POS, AXIS)     ((POS) - WORKSPACE_OFFSET(AXIS))
+
+#if HAS_POSITION_SHIFT || DISABLED(DELTA)
+  #define LOGICAL_X_POSITION(POS)   LOGICAL_POSITION(POS, X_AXIS)
+  #define LOGICAL_Y_POSITION(POS)   LOGICAL_POSITION(POS, Y_AXIS)
+  #define RAW_X_POSITION(POS)       RAW_POSITION(POS, X_AXIS)
+  #define RAW_Y_POSITION(POS)       RAW_POSITION(POS, Y_AXIS)
+#else
+  #define LOGICAL_X_POSITION(POS)   (POS)
+  #define LOGICAL_Y_POSITION(POS)   (POS)
+  #define RAW_X_POSITION(POS)       (POS)
+  #define RAW_Y_POSITION(POS)       (POS)
+#endif
+
+#define LOGICAL_Z_POSITION(POS)     LOGICAL_POSITION(POS, Z_AXIS)
+#define RAW_Z_POSITION(POS)         RAW_POSITION(POS, Z_AXIS)
+#define RAW_CURRENT_POSITION(A)     RAW_##A##_POSITION(current_position[A##_AXIS])
+
+/**
+ * position_is_reachable family of functions
+ */
+
+#if IS_KINEMATIC // (DELTA or SCARA)
+
+  #if IS_SCARA
+    extern const float L1, L2;
+  #endif
+
+  inline bool position_is_reachable_raw_xy(const float &rx, const float &ry) {
+    #if ENABLED(DELTA)
+      return HYPOT2(rx, ry) <= sq(DELTA_PRINTABLE_RADIUS);
+    #elif IS_SCARA
+      #if MIDDLE_DEAD_ZONE_R > 0
+        const float R2 = HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y);
+        return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
+      #else
+        return HYPOT2(rx - SCARA_OFFSET_X, ry - SCARA_OFFSET_Y) <= sq(L1 + L2);
+      #endif
+    #else // CARTESIAN
+      // To be migrated from MakerArm branch in future
+    #endif
+  }
+
+  inline bool position_is_reachable_by_probe_raw_xy(const float &rx, const float &ry) {
+
+    // Both the nozzle and the probe must be able to reach the point.
+    // This won't work on SCARA since the probe offset rotates with the arm.
+
+    return position_is_reachable_raw_xy(rx, ry)
+        && position_is_reachable_raw_xy(rx - X_PROBE_OFFSET_FROM_EXTRUDER, ry - Y_PROBE_OFFSET_FROM_EXTRUDER);
+  }
+
+#else // CARTESIAN
+
+  inline bool position_is_reachable_raw_xy(const float &rx, const float &ry) {
+      // Add 0.001 margin to deal with float imprecision
+      return WITHIN(rx, X_MIN_POS - 0.001, X_MAX_POS + 0.001)
+          && WITHIN(ry, Y_MIN_POS - 0.001, Y_MAX_POS + 0.001);
+  }
+
+  inline bool position_is_reachable_by_probe_raw_xy(const float &rx, const float &ry) {
+      // Add 0.001 margin to deal with float imprecision
+      return WITHIN(rx, MIN_PROBE_X - 0.001, MAX_PROBE_X + 0.001)
+          && WITHIN(ry, MIN_PROBE_Y - 0.001, MAX_PROBE_Y + 0.001);
+  }
+
+#endif // CARTESIAN
+
+FORCE_INLINE bool position_is_reachable_by_probe_xy(const float &lx, const float &ly) {
+  return position_is_reachable_by_probe_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
+}
+
+FORCE_INLINE bool position_is_reachable_xy(const float &lx, const float &ly) {
+  return position_is_reachable_raw_xy(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
+}
+
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  extern bool extruder_duplication_enabled;       // Used in Dual X mode 2
+#endif
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  extern DualXMode dual_x_carriage_mode;
+  extern float inactive_extruder_x_pos,           // used in mode 0 & 1
+               raised_parked_position[XYZE],      // used in mode 1
+               duplicate_extruder_x_offset;       // used in mode 2
+  extern bool active_extruder_parked;             // used in mode 1 & 2
+  extern millis_t delayed_move_time;              // used in mode 1
+  extern int16_t duplicate_extruder_temp_offset;  // used in mode 2
+
+  float x_home_pos(const int extruder);
+
+  FORCE_INLINE int x_home_dir(const uint8_t extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
+
+#endif // DUAL_X_CARRIAGE
+
+#endif // MOTION_H
