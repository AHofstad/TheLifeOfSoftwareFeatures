commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 995bc3b195..c3503ede41 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_MARLINUI_MENU && HAS_TRINAMIC_CONFIG
 
 #include "menu_item.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
+#define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_F(uint16_4, F(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, STR_A);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, STR_B);
   #endif
@@ -83,21 +83,21 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E6, STR_E6);
   #endif
   #if AXIS_IS_TMC(E7)
     TMC_EDIT_STORED_I_RMS(E7, STR_E7);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, STR) EDIT_ITEM_P(uint8, PSTR(STR), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, STR) EDIT_ITEM_F(uint8, F(STR), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     TERN_(X_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(X,  STR_X));
     TERN_(Y_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Y,  STR_Y));
     TERN_(Z_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Z,  STR_Z));
     TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(X2, STR_X2));
     TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Y2, STR_Y2));
     TERN_(Z2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z2, STR_Z2));
@@ -111,21 +111,21 @@ void menu_tmc_current() {
     TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E5, STR_E5));
     TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E6, STR_E6));
     TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E7, STR_E7));
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_F(int4, F(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     TERN_( X_SENSORLESS, TMC_EDIT_STORED_SGT(X));
     TERN_(X2_SENSORLESS, TMC_EDIT_STORED_SGT(X2));
     TERN_( Y_SENSORLESS, TMC_EDIT_STORED_SGT(Y));
     TERN_(Y2_SENSORLESS, TMC_EDIT_STORED_SGT(Y2));
     TERN_( Z_SENSORLESS, TMC_EDIT_STORED_SGT(Z));
     TERN_(Z2_SENSORLESS, TMC_EDIT_STORED_SGT(Z2));
@@ -137,21 +137,21 @@ void menu_tmc_current() {
     TERN_( U_SENSORLESS, TMC_EDIT_STORED_SGT(U));
     TERN_( V_SENSORLESS, TMC_EDIT_STORED_SGT(V));
     TERN_( W_SENSORLESS, TMC_EDIT_STORED_SGT(W));
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_P(bool, PSTR(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
+  #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_F(bool, F(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     TERN_( X_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X,  STR_X));
     TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X2, STR_X2));
     TERN_( Y_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y,  STR_Y));
     TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y2, STR_Y2));
     TERN_( Z_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z,  STR_Z));

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 7e206e8d79..995bc3b195 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -127,20 +127,23 @@ void menu_tmc_current() {
     TERN_(X2_SENSORLESS, TMC_EDIT_STORED_SGT(X2));
     TERN_( Y_SENSORLESS, TMC_EDIT_STORED_SGT(Y));
     TERN_(Y2_SENSORLESS, TMC_EDIT_STORED_SGT(Y2));
     TERN_( Z_SENSORLESS, TMC_EDIT_STORED_SGT(Z));
     TERN_(Z2_SENSORLESS, TMC_EDIT_STORED_SGT(Z2));
     TERN_(Z3_SENSORLESS, TMC_EDIT_STORED_SGT(Z3));
     TERN_(Z4_SENSORLESS, TMC_EDIT_STORED_SGT(Z4));
     TERN_( I_SENSORLESS, TMC_EDIT_STORED_SGT(I));
     TERN_( J_SENSORLESS, TMC_EDIT_STORED_SGT(J));
     TERN_( K_SENSORLESS, TMC_EDIT_STORED_SGT(K));
+    TERN_( U_SENSORLESS, TMC_EDIT_STORED_SGT(U));
+    TERN_( V_SENSORLESS, TMC_EDIT_STORED_SGT(V));
+    TERN_( W_SENSORLESS, TMC_EDIT_STORED_SGT(W));
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
   #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_P(bool, PSTR(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index be6289d851..7e206e8d79 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_LCD_MENU && HAS_TRINAMIC_CONFIG
+#if HAS_MARLINUI_MENU && HAS_TRINAMIC_CONFIG
 
 #include "menu_item.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);

commit 9665a4434cee0386fa2a63a058b6f2598943ee98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 02:51:34 2022 -0600

    üßë‚Äçüíª Fewer string macros

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index ad7d632058..be6289d851 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -31,93 +31,93 @@
 #include "menu_item.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
-    TMC_EDIT_STORED_I_RMS(X, STR_X);
+    TMC_EDIT_STORED_I_RMS(X, STR_A);
   #endif
   #if AXIS_IS_TMC(Y)
-    TMC_EDIT_STORED_I_RMS(Y, STR_Y);
+    TMC_EDIT_STORED_I_RMS(Y, STR_B);
   #endif
   #if AXIS_IS_TMC(Z)
-    TMC_EDIT_STORED_I_RMS(Z, STR_Z);
+    TMC_EDIT_STORED_I_RMS(Z, STR_C);
   #endif
   #if AXIS_IS_TMC(X2)
     TMC_EDIT_STORED_I_RMS(X2, STR_X2);
   #endif
   #if AXIS_IS_TMC(Y2)
     TMC_EDIT_STORED_I_RMS(Y2, STR_Y2);
   #endif
   #if AXIS_IS_TMC(Z2)
     TMC_EDIT_STORED_I_RMS(Z2, STR_Z2);
   #endif
   #if AXIS_IS_TMC(Z3)
     TMC_EDIT_STORED_I_RMS(Z3, STR_Z3);
   #endif
   #if AXIS_IS_TMC(Z4)
     TMC_EDIT_STORED_I_RMS(Z4, STR_Z4);
   #endif
   #if AXIS_IS_TMC(E0)
-    TMC_EDIT_STORED_I_RMS(E0, LCD_STR_E0);
+    TMC_EDIT_STORED_I_RMS(E0, STR_E0);
   #endif
   #if AXIS_IS_TMC(E1)
-    TMC_EDIT_STORED_I_RMS(E1, LCD_STR_E1);
+    TMC_EDIT_STORED_I_RMS(E1, STR_E1);
   #endif
   #if AXIS_IS_TMC(E2)
-    TMC_EDIT_STORED_I_RMS(E2, LCD_STR_E2);
+    TMC_EDIT_STORED_I_RMS(E2, STR_E2);
   #endif
   #if AXIS_IS_TMC(E3)
-    TMC_EDIT_STORED_I_RMS(E3, LCD_STR_E3);
+    TMC_EDIT_STORED_I_RMS(E3, STR_E3);
   #endif
   #if AXIS_IS_TMC(E4)
-    TMC_EDIT_STORED_I_RMS(E4, LCD_STR_E4);
+    TMC_EDIT_STORED_I_RMS(E4, STR_E4);
   #endif
   #if AXIS_IS_TMC(E5)
-    TMC_EDIT_STORED_I_RMS(E5, LCD_STR_E5);
+    TMC_EDIT_STORED_I_RMS(E5, STR_E5);
   #endif
   #if AXIS_IS_TMC(E6)
-    TMC_EDIT_STORED_I_RMS(E6, LCD_STR_E6);
+    TMC_EDIT_STORED_I_RMS(E6, STR_E6);
   #endif
   #if AXIS_IS_TMC(E7)
-    TMC_EDIT_STORED_I_RMS(E7, LCD_STR_E7);
+    TMC_EDIT_STORED_I_RMS(E7, STR_E7);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
   #define TMC_EDIT_STORED_HYBRID_THRS(ST, STR) EDIT_ITEM_P(uint8, PSTR(STR), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     TERN_(X_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(X,  STR_X));
     TERN_(Y_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Y,  STR_Y));
     TERN_(Z_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Z,  STR_Z));
     TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(X2, STR_X2));
     TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Y2, STR_Y2));
     TERN_(Z2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z2, STR_Z2));
     TERN_(Z3_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z3, STR_Z3));
     TERN_(Z4_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z4, STR_Z4));
-    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0));
-    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1));
-    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2));
-    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E3, LCD_STR_E3));
-    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E4, LCD_STR_E4));
-    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5));
-    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E6, LCD_STR_E6));
-    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E7, LCD_STR_E7));
+    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E0, STR_E0));
+    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E1, STR_E1));
+    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E2, STR_E2));
+    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E3, STR_E3));
+    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E4, STR_E4));
+    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E5, STR_E5));
+    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E6, STR_E6));
+    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E7, STR_E7));
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
@@ -148,28 +148,28 @@ void menu_tmc_current() {
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     TERN_( X_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X,  STR_X));
     TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X2, STR_X2));
     TERN_( Y_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y,  STR_Y));
     TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y2, STR_Y2));
     TERN_( Z_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z,  STR_Z));
     TERN_(Z2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z2, STR_Z2));
     TERN_(Z3_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z3, STR_Z3));
     TERN_(Z4_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z4, STR_Z4));
-    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E0, LCD_STR_E0));
-    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E1, LCD_STR_E1));
-    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E2, LCD_STR_E2));
-    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E3, LCD_STR_E3));
-    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E4, LCD_STR_E4));
-    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E5, LCD_STR_E5));
-    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E6, LCD_STR_E6));
-    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E7, LCD_STR_E7));
+    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E0, STR_E0));
+    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E1, STR_E1));
+    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E2, STR_E2));
+    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E3, STR_E3));
+    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E4, STR_E4));
+    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E5, STR_E5));
+    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E6, STR_E6));
+    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E7, STR_E7));
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
   BACK_ITEM(MSG_ADVANCED_SETTINGS);
   SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);
   TERN_(HYBRID_THRESHOLD,   SUBMENU(MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs));

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 69193701eb..ad7d632058 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -88,177 +88,94 @@ void menu_tmc_current() {
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
   #define TMC_EDIT_STORED_HYBRID_THRS(ST, STR) EDIT_ITEM_P(uint8, PSTR(STR), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
-    #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STORED_HYBRID_THRS(X, STR_X);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STORED_HYBRID_THRS(Y, STR_Y);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STORED_HYBRID_THRS(Z, STR_Z);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STORED_HYBRID_THRS(X2, STR_X2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STORED_HYBRID_THRS(Y2, STR_Y2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STORED_HYBRID_THRS(Z2, STR_Z2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STORED_HYBRID_THRS(Z3, STR_Z3);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z4)
-      TMC_EDIT_STORED_HYBRID_THRS(Z4, STR_Z4);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STORED_HYBRID_THRS(E3, LCD_STR_E3);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STORED_HYBRID_THRS(E4, LCD_STR_E4);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E6)
-      TMC_EDIT_STORED_HYBRID_THRS(E6, LCD_STR_E6);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E7)
-      TMC_EDIT_STORED_HYBRID_THRS(E7, LCD_STR_E7);
-    #endif
+    TERN_(X_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(X,  STR_X));
+    TERN_(Y_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Y,  STR_Y));
+    TERN_(Z_HAS_STEALTHCHOP,  TMC_EDIT_STORED_HYBRID_THRS(Z,  STR_Z));
+    TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(X2, STR_X2));
+    TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Y2, STR_Y2));
+    TERN_(Z2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z2, STR_Z2));
+    TERN_(Z3_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z3, STR_Z3));
+    TERN_(Z4_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(Z4, STR_Z4));
+    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0));
+    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1));
+    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2));
+    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E3, LCD_STR_E3));
+    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E4, LCD_STR_E4));
+    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5));
+    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E6, LCD_STR_E6));
+    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STORED_HYBRID_THRS(E7, LCD_STR_E7));
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
-    #if X_SENSORLESS
-      TMC_EDIT_STORED_SGT(X);
-      #if X2_SENSORLESS
-        TMC_EDIT_STORED_SGT(X2);
-      #endif
-    #endif
-    #if Y_SENSORLESS
-      TMC_EDIT_STORED_SGT(Y);
-      #if Y2_SENSORLESS
-        TMC_EDIT_STORED_SGT(Y2);
-      #endif
-    #endif
-    #if Z_SENSORLESS
-      TMC_EDIT_STORED_SGT(Z);
-      #if Z2_SENSORLESS
-        TMC_EDIT_STORED_SGT(Z2);
-      #endif
-      #if Z3_SENSORLESS
-        TMC_EDIT_STORED_SGT(Z3);
-      #endif
-      #if Z4_SENSORLESS
-        TMC_EDIT_STORED_SGT(Z4);
-      #endif
-    #endif
+    TERN_( X_SENSORLESS, TMC_EDIT_STORED_SGT(X));
+    TERN_(X2_SENSORLESS, TMC_EDIT_STORED_SGT(X2));
+    TERN_( Y_SENSORLESS, TMC_EDIT_STORED_SGT(Y));
+    TERN_(Y2_SENSORLESS, TMC_EDIT_STORED_SGT(Y2));
+    TERN_( Z_SENSORLESS, TMC_EDIT_STORED_SGT(Z));
+    TERN_(Z2_SENSORLESS, TMC_EDIT_STORED_SGT(Z2));
+    TERN_(Z3_SENSORLESS, TMC_EDIT_STORED_SGT(Z3));
+    TERN_(Z4_SENSORLESS, TMC_EDIT_STORED_SGT(Z4));
+    TERN_( I_SENSORLESS, TMC_EDIT_STORED_SGT(I));
+    TERN_( J_SENSORLESS, TMC_EDIT_STORED_SGT(J));
+    TERN_( K_SENSORLESS, TMC_EDIT_STORED_SGT(K));
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
   #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_P(bool, PSTR(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
-    #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STEP_MODE(X, STR_X);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STEP_MODE(Y, STR_Y);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STEP_MODE(Z, STR_Z);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STEP_MODE(X2, STR_X2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STEP_MODE(Y2, STR_Y2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STEP_MODE(Z2, STR_Z2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STEP_MODE(Z3, STR_Z3);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(Z4)
-      TMC_EDIT_STEP_MODE(Z4, STR_Z4);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STEP_MODE(E0, LCD_STR_E0);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STEP_MODE(E1, LCD_STR_E1);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STEP_MODE(E2, LCD_STR_E2);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STEP_MODE(E3, LCD_STR_E3);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STEP_MODE(E4, LCD_STR_E4);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STEP_MODE(E5, LCD_STR_E5);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E6)
-      TMC_EDIT_STEP_MODE(E6, LCD_STR_E6);
-    #endif
-    #if AXIS_HAS_STEALTHCHOP(E7)
-      TMC_EDIT_STEP_MODE(E7, LCD_STR_E7);
-    #endif
+    TERN_( X_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X,  STR_X));
+    TERN_(X2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(X2, STR_X2));
+    TERN_( Y_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y,  STR_Y));
+    TERN_(Y2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Y2, STR_Y2));
+    TERN_( Z_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z,  STR_Z));
+    TERN_(Z2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z2, STR_Z2));
+    TERN_(Z3_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z3, STR_Z3));
+    TERN_(Z4_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(Z4, STR_Z4));
+    TERN_(E0_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E0, LCD_STR_E0));
+    TERN_(E1_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E1, LCD_STR_E1));
+    TERN_(E2_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E2, LCD_STR_E2));
+    TERN_(E3_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E3, LCD_STR_E3));
+    TERN_(E4_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E4, LCD_STR_E4));
+    TERN_(E5_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E5, LCD_STR_E5));
+    TERN_(E6_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E6, LCD_STR_E6));
+    TERN_(E7_HAS_STEALTHCHOP, TMC_EDIT_STEP_MODE(E7, LCD_STR_E7));
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
   BACK_ITEM(MSG_ADVANCED_SETTINGS);
   SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);
-  #if ENABLED(HYBRID_THRESHOLD)
-    SUBMENU(MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
-  #endif
-  #if ENABLED(SENSORLESS_HOMING)
-    SUBMENU(MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
-  #endif
-  #if HAS_STEALTHCHOP
-    SUBMENU(MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
-  #endif
+  TERN_(HYBRID_THRESHOLD,   SUBMENU(MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs));
+  TERN_(SENSORLESS_HOMING,  SUBMENU(MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs));
+  TERN_(HAS_STEALTHCHOP,    SUBMENU(MSG_TMC_STEPPING_MODE, menu_tmc_step_mode));
   END_MENU();
 }
 
 #endif // HAS_TRINAMIC_CONFIG

commit 819ec462b8440172c32f009adf44ad54c266c1e5
Author: BsCmOD <64871957+BsCmOD@users.noreply.github.com>
Date:   Fri Nov 27 04:25:18 2020 +0100

    FIX TMC menu message (#20294)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 402ee41a1b..69193701eb 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -240,21 +240,21 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E7)
       TMC_EDIT_STEP_MODE(E7, LCD_STR_E7);
     #endif
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
-  BACK_ITEM(MSG_CONTROL);
+  BACK_ITEM(MSG_ADVANCED_SETTINGS);
   SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);
   #if ENABLED(HYBRID_THRESHOLD)
     SUBMENU(MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
   #endif
   #if ENABLED(SENSORLESS_HOMING)
     SUBMENU(MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
   #endif
   #if HAS_STEALTHCHOP
     SUBMENU(MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
   #endif

commit 4f67642122059a9270f9e3690978248355f88e72
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 05:21:34 2020 -0500

    Header for individual menus

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index f2f26886fc..402ee41a1b 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -21,21 +21,21 @@
  */
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_LCD_MENU && HAS_TRINAMIC_CONFIG
 
-#include "menu.h"
+#include "menu_item.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, STR_X);

commit a9912681b40ebaea6b452a41fb0d25ec9c93c8fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Aug 6 00:49:15 2020 -0500

    General cleanup

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index e74619d295..f2f26886fc 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_TRINAMIC_CONFIG && HAS_LCD_MENU
+#if HAS_LCD_MENU && HAS_TRINAMIC_CONFIG
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index f8c6eb3a8a..e74619d295 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC_CONFIG && HAS_LCD_MENU

commit a226b281aff5d569bc18afb9879149e0e89d29df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 30 22:52:33 2020 -0500

    UI and stall reset for extra TMC axes (#17818)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 296a132e14..f8c6eb3a8a 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -150,29 +150,41 @@ void menu_tmc_current() {
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
-    #endif
-    #if X2_SENSORLESS
-      TMC_EDIT_STORED_SGT(X2);
+      #if X2_SENSORLESS
+        TMC_EDIT_STORED_SGT(X2);
+      #endif
     #endif
     #if Y_SENSORLESS
       TMC_EDIT_STORED_SGT(Y);
+      #if Y2_SENSORLESS
+        TMC_EDIT_STORED_SGT(Y2);
+      #endif
     #endif
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
+      #if Z2_SENSORLESS
+        TMC_EDIT_STORED_SGT(Z2);
+      #endif
+      #if Z3_SENSORLESS
+        TMC_EDIT_STORED_SGT(Z3);
+      #endif
+      #if Z4_SENSORLESS
+        TMC_EDIT_STORED_SGT(Z4);
+      #endif
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
   #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_P(bool, PSTR(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 0350d788eb..296a132e14 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_TRINAMIC && HAS_LCD_MENU
+#if HAS_TRINAMIC_CONFIG && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
@@ -242,11 +242,11 @@ void menu_tmc() {
   #endif
   #if ENABLED(SENSORLESS_HOMING)
     SUBMENU(MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
   #endif
   #if HAS_STEALTHCHOP
     SUBMENU(MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
   #endif
   END_MENU();
 }
 
-#endif // HAS_TRINAMIC
+#endif // HAS_TRINAMIC_CONFIG

commit ec1b86d9cb3a08f77beb2aaa8363c7bff0a9e175
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 05:38:25 2020 -0600

    Serial strings in macros

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 4d971e4e3a..0350d788eb 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM_P(uint16_4, PSTR(MSG), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
+#define TMC_EDIT_STORED_I_RMS(ST,STR) EDIT_ITEM_P(uint16_4, PSTR(STR), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, STR_X);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, STR_Y);
   #endif
@@ -83,21 +83,21 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E6, LCD_STR_E6);
   #endif
   #if AXIS_IS_TMC(E7)
     TMC_EDIT_STORED_I_RMS(E7, LCD_STR_E7);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, STR) EDIT_ITEM_P(uint8, PSTR(STR), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, STR_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, STR_Y);
     #endif
@@ -143,21 +143,21 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E7)
       TMC_EDIT_STORED_HYBRID_THRS(E7, LCD_STR_E7);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(MSG_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(STR_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
     #if X2_SENSORLESS
       TMC_EDIT_STORED_SGT(X2);
     #endif
@@ -167,21 +167,21 @@ void menu_tmc_current() {
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM_P(bool, PSTR(MSG), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
+  #define TMC_EDIT_STEP_MODE(ST, STR) EDIT_ITEM_P(bool, PSTR(STR), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STEP_MODE(X, STR_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STEP_MODE(Y, STR_Y);

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index ed70a3e7f1..4d971e4e3a 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -31,42 +31,42 @@
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM_P(uint16_4, PSTR(MSG), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
-    TMC_EDIT_STORED_I_RMS(X, MSG_X);
+    TMC_EDIT_STORED_I_RMS(X, STR_X);
   #endif
   #if AXIS_IS_TMC(Y)
-    TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
+    TMC_EDIT_STORED_I_RMS(Y, STR_Y);
   #endif
   #if AXIS_IS_TMC(Z)
-    TMC_EDIT_STORED_I_RMS(Z, MSG_Z);
+    TMC_EDIT_STORED_I_RMS(Z, STR_Z);
   #endif
   #if AXIS_IS_TMC(X2)
-    TMC_EDIT_STORED_I_RMS(X2, MSG_X2);
+    TMC_EDIT_STORED_I_RMS(X2, STR_X2);
   #endif
   #if AXIS_IS_TMC(Y2)
-    TMC_EDIT_STORED_I_RMS(Y2, MSG_Y2);
+    TMC_EDIT_STORED_I_RMS(Y2, STR_Y2);
   #endif
   #if AXIS_IS_TMC(Z2)
-    TMC_EDIT_STORED_I_RMS(Z2, MSG_Z2);
+    TMC_EDIT_STORED_I_RMS(Z2, STR_Z2);
   #endif
   #if AXIS_IS_TMC(Z3)
-    TMC_EDIT_STORED_I_RMS(Z3, MSG_Z3);
+    TMC_EDIT_STORED_I_RMS(Z3, STR_Z3);
   #endif
   #if AXIS_IS_TMC(Z4)
-    TMC_EDIT_STORED_I_RMS(Z4, MSG_Z4);
+    TMC_EDIT_STORED_I_RMS(Z4, STR_Z4);
   #endif
   #if AXIS_IS_TMC(E0)
     TMC_EDIT_STORED_I_RMS(E0, LCD_STR_E0);
   #endif
   #if AXIS_IS_TMC(E1)
     TMC_EDIT_STORED_I_RMS(E1, LCD_STR_E1);
   #endif
   #if AXIS_IS_TMC(E2)
     TMC_EDIT_STORED_I_RMS(E2, LCD_STR_E2);
   #endif
@@ -89,42 +89,42 @@ void menu_tmc_current() {
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
   #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
+      TMC_EDIT_STORED_HYBRID_THRS(X, STR_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
+      TMC_EDIT_STORED_HYBRID_THRS(Y, STR_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STORED_HYBRID_THRS(Z, MSG_Z);
+      TMC_EDIT_STORED_HYBRID_THRS(Z, STR_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STORED_HYBRID_THRS(X2, MSG_X2);
+      TMC_EDIT_STORED_HYBRID_THRS(X2, STR_X2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STORED_HYBRID_THRS(Y2, MSG_Y2);
+      TMC_EDIT_STORED_HYBRID_THRS(Y2, STR_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STORED_HYBRID_THRS(Z2, MSG_Z2);
+      TMC_EDIT_STORED_HYBRID_THRS(Z2, STR_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STORED_HYBRID_THRS(Z3, MSG_Z3);
+      TMC_EDIT_STORED_HYBRID_THRS(Z3, STR_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z4)
-      TMC_EDIT_STORED_HYBRID_THRS(Z4, MSG_Z4);
+      TMC_EDIT_STORED_HYBRID_THRS(Z4, STR_Z4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
       TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
       TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
       TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2);
     #endif
@@ -174,42 +174,42 @@ void menu_tmc_current() {
 
 #if HAS_STEALTHCHOP
 
   #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM_P(bool, PSTR(MSG), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STEP_MODE(X, MSG_X);
+      TMC_EDIT_STEP_MODE(X, STR_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STEP_MODE(Y, MSG_Y);
+      TMC_EDIT_STEP_MODE(Y, STR_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STEP_MODE(Z, MSG_Z);
+      TMC_EDIT_STEP_MODE(Z, STR_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STEP_MODE(X2, MSG_X2);
+      TMC_EDIT_STEP_MODE(X2, STR_X2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STEP_MODE(Y2, MSG_Y2);
+      TMC_EDIT_STEP_MODE(Y2, STR_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STEP_MODE(Z2, MSG_Z2);
+      TMC_EDIT_STEP_MODE(Z2, STR_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STEP_MODE(Z3, MSG_Z3);
+      TMC_EDIT_STEP_MODE(Z3, STR_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z4)
-      TMC_EDIT_STEP_MODE(Z4, MSG_Z4);
+      TMC_EDIT_STEP_MODE(Z4, STR_Z4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
       TMC_EDIT_STEP_MODE(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
       TMC_EDIT_STEP_MODE(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
       TMC_EDIT_STEP_MODE(E2, LCD_STR_E2);
     #endif

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index ff6a50ccfc..ed70a3e7f1 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 054b4e61f3..ff6a50ccfc 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -72,20 +72,26 @@ void menu_tmc_current() {
   #endif
   #if AXIS_IS_TMC(E3)
     TMC_EDIT_STORED_I_RMS(E3, LCD_STR_E3);
   #endif
   #if AXIS_IS_TMC(E4)
     TMC_EDIT_STORED_I_RMS(E4, LCD_STR_E4);
   #endif
   #if AXIS_IS_TMC(E5)
     TMC_EDIT_STORED_I_RMS(E5, LCD_STR_E5);
   #endif
+  #if AXIS_IS_TMC(E6)
+    TMC_EDIT_STORED_I_RMS(E6, LCD_STR_E6);
+  #endif
+  #if AXIS_IS_TMC(E7)
+    TMC_EDIT_STORED_I_RMS(E7, LCD_STR_E7);
+  #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
   #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
@@ -124,20 +130,26 @@ void menu_tmc_current() {
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
       TMC_EDIT_STORED_HYBRID_THRS(E3, LCD_STR_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
       TMC_EDIT_STORED_HYBRID_THRS(E4, LCD_STR_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5);
     #endif
+    #if AXIS_HAS_STEALTHCHOP(E6)
+      TMC_EDIT_STORED_HYBRID_THRS(E6, LCD_STR_E6);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E7)
+      TMC_EDIT_STORED_HYBRID_THRS(E7, LCD_STR_E7);
+    #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(MSG_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
@@ -203,20 +215,26 @@ void menu_tmc_current() {
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
       TMC_EDIT_STEP_MODE(E3, LCD_STR_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
       TMC_EDIT_STEP_MODE(E4, LCD_STR_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STEP_MODE(E5, LCD_STR_E5);
     #endif
+    #if AXIS_HAS_STEALTHCHOP(E6)
+      TMC_EDIT_STEP_MODE(E6, LCD_STR_E6);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E7)
+      TMC_EDIT_STEP_MODE(E7, LCD_STR_E7);
+    #endif
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
   BACK_ITEM(MSG_CONTROL);
   SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);
   #if ENABLED(HYBRID_THRESHOLD)

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index ef0e207a60..054b4e61f3 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -51,20 +51,23 @@ void menu_tmc_current() {
   #endif
   #if AXIS_IS_TMC(Y2)
     TMC_EDIT_STORED_I_RMS(Y2, MSG_Y2);
   #endif
   #if AXIS_IS_TMC(Z2)
     TMC_EDIT_STORED_I_RMS(Z2, MSG_Z2);
   #endif
   #if AXIS_IS_TMC(Z3)
     TMC_EDIT_STORED_I_RMS(Z3, MSG_Z3);
   #endif
+  #if AXIS_IS_TMC(Z4)
+    TMC_EDIT_STORED_I_RMS(Z4, MSG_Z4);
+  #endif
   #if AXIS_IS_TMC(E0)
     TMC_EDIT_STORED_I_RMS(E0, LCD_STR_E0);
   #endif
   #if AXIS_IS_TMC(E1)
     TMC_EDIT_STORED_I_RMS(E1, LCD_STR_E1);
   #endif
   #if AXIS_IS_TMC(E2)
     TMC_EDIT_STORED_I_RMS(E2, LCD_STR_E2);
   #endif
   #if AXIS_IS_TMC(E3)
@@ -100,20 +103,23 @@ void menu_tmc_current() {
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
       TMC_EDIT_STORED_HYBRID_THRS(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
       TMC_EDIT_STORED_HYBRID_THRS(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
       TMC_EDIT_STORED_HYBRID_THRS(Z3, MSG_Z3);
     #endif
+    #if AXIS_HAS_STEALTHCHOP(Z4)
+      TMC_EDIT_STORED_HYBRID_THRS(Z4, MSG_Z4);
+    #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
       TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
       TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
       TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
@@ -176,20 +182,23 @@ void menu_tmc_current() {
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
       TMC_EDIT_STEP_MODE(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
       TMC_EDIT_STEP_MODE(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
       TMC_EDIT_STEP_MODE(Z3, MSG_Z3);
     #endif
+    #if AXIS_HAS_STEALTHCHOP(Z4)
+      TMC_EDIT_STEP_MODE(Z4, MSG_Z4);
+    #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
       TMC_EDIT_STEP_MODE(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
       TMC_EDIT_STEP_MODE(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
       TMC_EDIT_STEP_MODE(E2, LCD_STR_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)

commit 23d21dd81c0c634046108e40f50fa09e3503a5dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 2 00:05:05 2019 -0500

    Tweak lambdas

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index ee74b95171..ef0e207a60 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM_P(uint16_4, PSTR(MSG), &stepper##ST.val_mA, 100, 3000, [](){ stepper##ST.refresh_stepper_current(); })
+#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM_P(uint16_4, PSTR(MSG), &stepper##ST.val_mA, 100, 3000, []{ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, MSG_X);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
   #endif
@@ -74,21 +74,21 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E4, LCD_STR_E4);
   #endif
   #if AXIS_IS_TMC(E5)
     TMC_EDIT_STORED_I_RMS(E5, LCD_STR_E5);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, [](){ stepper##ST.refresh_hybrid_thrs(); });
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, []{ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
     #endif
@@ -125,21 +125,21 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(MSG_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, [](){ stepper##ST.refresh_homing_thrs(); });
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(MSG_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, []{ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
     #if X2_SENSORLESS
       TMC_EDIT_STORED_SGT(X2);
     #endif
@@ -149,21 +149,21 @@ void menu_tmc_current() {
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM_P(bool, PSTR(MSG), &stepper##ST.stored.stealthChop_enabled, [](){ stepper##ST.refresh_stepping_mode(); })
+  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM_P(bool, PSTR(MSG), &stepper##ST.stored.stealthChop_enabled, []{ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STEP_MODE(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STEP_MODE(Y, MSG_Y);

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 4d6f539e2d..ee74b95171 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, [](){ stepper##ST.refresh_stepper_current(); })
+#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM_P(uint16_4, PSTR(MSG), &stepper##ST.val_mA, 100, 3000, [](){ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, MSG_X);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
   #endif
@@ -74,21 +74,21 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E4, LCD_STR_E4);
   #endif
   #if AXIS_IS_TMC(E5)
     TMC_EDIT_STORED_I_RMS(E5, LCD_STR_E5);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, [](){ stepper##ST.refresh_hybrid_thrs(); });
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM_P(uint8, PSTR(MSG), &stepper##ST.stored.hybrid_thrs, 0, 255, [](){ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
     #endif
@@ -125,21 +125,21 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, [](){ stepper##ST.refresh_homing_thrs(); });
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM_P(int4, PSTR(MSG_##ST), &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, [](){ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
     #if X2_SENSORLESS
       TMC_EDIT_STORED_SGT(X2);
     #endif
@@ -149,21 +149,21 @@ void menu_tmc_current() {
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM(bool, MSG, &stepper##ST.stored.stealthChop_enabled, [](){ stepper##ST.refresh_stepping_mode(); })
+  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM_P(bool, PSTR(MSG), &stepper##ST.stored.stealthChop_enabled, [](){ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STEP_MODE(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STEP_MODE(Y, MSG_Y);

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 7f0b42643f..4d6f539e2d 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,61 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
-
-#if AXIS_IS_TMC(X)
-  void refresh_stepper_current_X()  { stepperX.refresh_stepper_current();  }
-#endif
-#if AXIS_IS_TMC(Y)
-  void refresh_stepper_current_Y()  { stepperY.refresh_stepper_current();  }
-#endif
-#if AXIS_IS_TMC(Z)
-  void refresh_stepper_current_Z()  { stepperZ.refresh_stepper_current();  }
-#endif
-#if AXIS_IS_TMC(X2)
-  void refresh_stepper_current_X2() { stepperX2.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(Y2)
-  void refresh_stepper_current_Y2() { stepperY2.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(Z2)
-  void refresh_stepper_current_Z2() { stepperZ2.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(Z3)
-  void refresh_stepper_current_Z3() { stepperZ3.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E0)
-  void refresh_stepper_current_E0() { stepperE0.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E1)
-  void refresh_stepper_current_E1() { stepperE1.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E2)
-  void refresh_stepper_current_E2() { stepperE2.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E3)
-  void refresh_stepper_current_E3() { stepperE3.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E4)
-  void refresh_stepper_current_E4() { stepperE4.refresh_stepper_current(); }
-#endif
-#if AXIS_IS_TMC(E5)
-  void refresh_stepper_current_E5() { stepperE5.refresh_stepper_current(); }
-#endif
+#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, [](){ stepper##ST.refresh_stepper_current(); })
 
 void menu_tmc_current() {
   START_MENU();
   BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, MSG_X);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
   #endif
@@ -92,83 +52,43 @@ void menu_tmc_current() {
   #if AXIS_IS_TMC(Y2)
     TMC_EDIT_STORED_I_RMS(Y2, MSG_Y2);
   #endif
   #if AXIS_IS_TMC(Z2)
     TMC_EDIT_STORED_I_RMS(Z2, MSG_Z2);
   #endif
   #if AXIS_IS_TMC(Z3)
     TMC_EDIT_STORED_I_RMS(Z3, MSG_Z3);
   #endif
   #if AXIS_IS_TMC(E0)
-    TMC_EDIT_STORED_I_RMS(E0, MSG_E1);
+    TMC_EDIT_STORED_I_RMS(E0, LCD_STR_E0);
   #endif
   #if AXIS_IS_TMC(E1)
-    TMC_EDIT_STORED_I_RMS(E1, MSG_E2);
+    TMC_EDIT_STORED_I_RMS(E1, LCD_STR_E1);
   #endif
   #if AXIS_IS_TMC(E2)
-    TMC_EDIT_STORED_I_RMS(E2, MSG_E3);
+    TMC_EDIT_STORED_I_RMS(E2, LCD_STR_E2);
   #endif
   #if AXIS_IS_TMC(E3)
-    TMC_EDIT_STORED_I_RMS(E3, MSG_E4);
+    TMC_EDIT_STORED_I_RMS(E3, LCD_STR_E3);
   #endif
   #if AXIS_IS_TMC(E4)
-    TMC_EDIT_STORED_I_RMS(E4, MSG_E5);
+    TMC_EDIT_STORED_I_RMS(E4, LCD_STR_E4);
   #endif
   #if AXIS_IS_TMC(E5)
-    TMC_EDIT_STORED_I_RMS(E5, MSG_E6);
+    TMC_EDIT_STORED_I_RMS(E5, LCD_STR_E5);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
-
-  #if AXIS_HAS_STEALTHCHOP(X)
-    void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Y)
-    void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z)
-    void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(X2)
-    void refresh_hybrid_thrs_X2() { stepperX2.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Y2)
-    void refresh_hybrid_thrs_Y2() { stepperY2.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z2)
-    void refresh_hybrid_thrs_Z2() { stepperZ2.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z3)
-    void refresh_hybrid_thrs_Z3() { stepperZ3.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E0)
-    void refresh_hybrid_thrs_E0() { stepperE0.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E1)
-    void refresh_hybrid_thrs_E1() { stepperE1.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E2)
-    void refresh_hybrid_thrs_E2() { stepperE2.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E3)
-    void refresh_hybrid_thrs_E3() { stepperE3.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E4)
-    void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E5)
-    void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(); }
-  #endif
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, [](){ stepper##ST.refresh_hybrid_thrs(); });
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
     #endif
@@ -181,58 +101,45 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(Y2)
       TMC_EDIT_STORED_HYBRID_THRS(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
       TMC_EDIT_STORED_HYBRID_THRS(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
       TMC_EDIT_STORED_HYBRID_THRS(Z3, MSG_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STORED_HYBRID_THRS(E0, MSG_E1);
+      TMC_EDIT_STORED_HYBRID_THRS(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STORED_HYBRID_THRS(E1, MSG_E2);
+      TMC_EDIT_STORED_HYBRID_THRS(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STORED_HYBRID_THRS(E2, MSG_E3);
+      TMC_EDIT_STORED_HYBRID_THRS(E2, LCD_STR_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STORED_HYBRID_THRS(E3, MSG_E4);
+      TMC_EDIT_STORED_HYBRID_THRS(E3, LCD_STR_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STORED_HYBRID_THRS(E4, MSG_E5);
+      TMC_EDIT_STORED_HYBRID_THRS(E4, LCD_STR_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STORED_HYBRID_THRS(E5, MSG_E6);
+      TMC_EDIT_STORED_HYBRID_THRS(E5, LCD_STR_E5);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, refresh_homing_thrs_##ST);
-
-  #if X_SENSORLESS
-    void refresh_homing_thrs_X()  { stepperX.refresh_homing_thrs();  }
-  #endif
-  #if X2_SENSORLESS
-    void refresh_homing_thrs_X2() { stepperX2.refresh_homing_thrs();  }
-  #endif
-  #if Y_SENSORLESS
-    void refresh_homing_thrs_Y()  { stepperY.refresh_homing_thrs();  }
-  #endif
-  #if Z_SENSORLESS
-    void refresh_homing_thrs_Z()  { stepperZ.refresh_homing_thrs();  }
-  #endif
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, [](){ stepper##ST.refresh_homing_thrs(); });
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
     #if X2_SENSORLESS
       TMC_EDIT_STORED_SGT(X2);
     #endif
@@ -242,61 +149,21 @@ void menu_tmc_current() {
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM(bool, MSG, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
-
-  #if AXIS_HAS_STEALTHCHOP(X)
-    void refresh_stepping_mode_X()  { stepperX.refresh_stepping_mode();  }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Y)
-    void refresh_stepping_mode_Y()  { stepperY.refresh_stepping_mode();  }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z)
-    void refresh_stepping_mode_Z()  { stepperZ.refresh_stepping_mode();  }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(X2)
-    void refresh_stepping_mode_X2() { stepperX2.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Y2)
-    void refresh_stepping_mode_Y2() { stepperY2.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z2)
-    void refresh_stepping_mode_Z2() { stepperZ2.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(Z3)
-    void refresh_stepping_mode_Z3() { stepperZ3.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E0)
-    void refresh_stepping_mode_E0() { stepperE0.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E1)
-    void refresh_stepping_mode_E1() { stepperE1.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E2)
-    void refresh_stepping_mode_E2() { stepperE2.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E3)
-    void refresh_stepping_mode_E3() { stepperE3.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E4)
-    void refresh_stepping_mode_E4() { stepperE4.refresh_stepping_mode(); }
-  #endif
-  #if AXIS_HAS_STEALTHCHOP(E5)
-    void refresh_stepping_mode_E5() { stepperE5.refresh_stepping_mode(); }
-  #endif
+  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM(bool, MSG, &stepper##ST.stored.stealthChop_enabled, [](){ stepper##ST.refresh_stepping_mode(); })
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STEP_MODE(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STEP_MODE(Y, MSG_Y);
@@ -310,36 +177,36 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(Y2)
       TMC_EDIT_STEP_MODE(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
       TMC_EDIT_STEP_MODE(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
       TMC_EDIT_STEP_MODE(Z3, MSG_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STEP_MODE(E0, MSG_E1);
+      TMC_EDIT_STEP_MODE(E0, LCD_STR_E0);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STEP_MODE(E1, MSG_E2);
+      TMC_EDIT_STEP_MODE(E1, LCD_STR_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STEP_MODE(E2, MSG_E3);
+      TMC_EDIT_STEP_MODE(E2, LCD_STR_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STEP_MODE(E3, MSG_E4);
+      TMC_EDIT_STEP_MODE(E3, LCD_STR_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STEP_MODE(E4, MSG_E5);
+      TMC_EDIT_STEP_MODE(E4, LCD_STR_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STEP_MODE(E5, MSG_E6);
+      TMC_EDIT_STEP_MODE(E5, LCD_STR_E5);
     #endif
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
   BACK_ITEM(MSG_CONTROL);
   SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);

commit 273cbe931e868554bf6782881443ccbf5fdd4208
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 3 05:38:30 2019 -0500

    Aliases for common menu item types

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 917b39ebfa..7f0b42643f 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST,MSG) MENU_ITEM_EDIT_CALLBACK(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
+#define TMC_EDIT_STORED_I_RMS(ST,MSG) EDIT_ITEM(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
 
 #if AXIS_IS_TMC(X)
   void refresh_stepper_current_X()  { stepperX.refresh_stepper_current();  }
 #endif
 #if AXIS_IS_TMC(Y)
   void refresh_stepper_current_Y()  { stepperY.refresh_stepper_current();  }
 #endif
 #if AXIS_IS_TMC(Z)
   void refresh_stepper_current_Z()  { stepperZ.refresh_stepper_current();  }
 #endif
@@ -69,21 +69,21 @@
 #endif
 #if AXIS_IS_TMC(E4)
   void refresh_stepper_current_E4() { stepperE4.refresh_stepper_current(); }
 #endif
 #if AXIS_IS_TMC(E5)
   void refresh_stepper_current_E5() { stepperE5.refresh_stepper_current(); }
 #endif
 
 void menu_tmc_current() {
   START_MENU();
-  MENU_BACK(MSG_TMC_DRIVERS);
+  BACK_ITEM(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
     TMC_EDIT_STORED_I_RMS(X, MSG_X);
   #endif
   #if AXIS_IS_TMC(Y)
     TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
   #endif
   #if AXIS_IS_TMC(Z)
     TMC_EDIT_STORED_I_RMS(Z, MSG_Z);
   #endif
   #if AXIS_IS_TMC(X2)
@@ -114,21 +114,21 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E4, MSG_E5);
   #endif
   #if AXIS_IS_TMC(E5)
     TMC_EDIT_STORED_I_RMS(E5, MSG_E6);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) MENU_ITEM_EDIT_CALLBACK(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) EDIT_ITEM(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
 
   #if AXIS_HAS_STEALTHCHOP(X)
     void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
     void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
     void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(); }
   #endif
@@ -158,21 +158,21 @@ void menu_tmc_current() {
   #endif
   #if AXIS_HAS_STEALTHCHOP(E4)
     void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E5)
     void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(); }
   #endif
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
-    MENU_BACK(MSG_TMC_DRIVERS);
+    BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
       TMC_EDIT_STORED_HYBRID_THRS(Z, MSG_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
@@ -205,58 +205,58 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STORED_HYBRID_THRS(E5, MSG_E6);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, refresh_homing_thrs_##ST);
+  #define TMC_EDIT_STORED_SGT(ST) EDIT_ITEM(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, refresh_homing_thrs_##ST);
 
   #if X_SENSORLESS
     void refresh_homing_thrs_X()  { stepperX.refresh_homing_thrs();  }
   #endif
   #if X2_SENSORLESS
     void refresh_homing_thrs_X2() { stepperX2.refresh_homing_thrs();  }
   #endif
   #if Y_SENSORLESS
     void refresh_homing_thrs_Y()  { stepperY.refresh_homing_thrs();  }
   #endif
   #if Z_SENSORLESS
     void refresh_homing_thrs_Z()  { stepperZ.refresh_homing_thrs();  }
   #endif
 
   void menu_tmc_homing_thrs() {
     START_MENU();
-    MENU_BACK(MSG_TMC_DRIVERS);
+    BACK_ITEM(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
     #if X2_SENSORLESS
       TMC_EDIT_STORED_SGT(X2);
     #endif
     #if Y_SENSORLESS
       TMC_EDIT_STORED_SGT(Y);
     #endif
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST, MSG) MENU_ITEM_EDIT_CALLBACK(bool, MSG, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
+  #define TMC_EDIT_STEP_MODE(ST, MSG) EDIT_ITEM(bool, MSG, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
 
   #if AXIS_HAS_STEALTHCHOP(X)
     void refresh_stepping_mode_X()  { stepperX.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
     void refresh_stepping_mode_Y()  { stepperY.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
     void refresh_stepping_mode_Z()  { stepperZ.refresh_stepping_mode();  }
   #endif
@@ -287,21 +287,21 @@ void menu_tmc_current() {
   #if AXIS_HAS_STEALTHCHOP(E4)
     void refresh_stepping_mode_E4() { stepperE4.refresh_stepping_mode(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E5)
     void refresh_stepping_mode_E5() { stepperE5.refresh_stepping_mode(); }
   #endif
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
-    MENU_BACK(MSG_TMC_DRIVERS);
+    BACK_ITEM(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STEP_MODE(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STEP_MODE(Y, MSG_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
       TMC_EDIT_STEP_MODE(Z, MSG_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
@@ -334,25 +334,25 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STEP_MODE(E5, MSG_E6);
     #endif
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
-  MENU_BACK(MSG_CONTROL);
-  MENU_ITEM(submenu, MSG_TMC_CURRENT, menu_tmc_current);
+  BACK_ITEM(MSG_CONTROL);
+  SUBMENU(MSG_TMC_CURRENT, menu_tmc_current);
   #if ENABLED(HYBRID_THRESHOLD)
-    MENU_ITEM(submenu, MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
+    SUBMENU(MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
   #endif
   #if ENABLED(SENSORLESS_HOMING)
-    MENU_ITEM(submenu, MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
+    SUBMENU(MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
   #endif
   #if HAS_STEALTHCHOP
-    MENU_ITEM(submenu, MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
+    SUBMENU(MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
   #endif
   END_MENU();
 }
 
 #endif // HAS_TRINAMIC

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 8218463daf..917b39ebfa 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -22,21 +22,21 @@
 
 //
 // TMC Menu
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
-#include "../../module/stepper_indirection.h"
+#include "../../module/stepper/indirection.h"
 #include "../../feature/tmc_util.h"
 
 #define TMC_EDIT_STORED_I_RMS(ST,MSG) MENU_ITEM_EDIT_CALLBACK(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
 
 #if AXIS_IS_TMC(X)
   void refresh_stepper_current_X()  { stepperX.refresh_stepper_current();  }
 #endif
 #if AXIS_IS_TMC(Y)
   void refresh_stepper_current_Y()  { stepperY.refresh_stepper_current();  }
 #endif

commit 0ebaea94be98b7ae27f9e2daf34e59f65436bd26
Author: AlexandrZloy <49792082+AlexandrZloy@users.noreply.github.com>
Date:   Thu Aug 29 12:15:31 2019 +0700

    Add stallGuard threshold for X2 (#15042)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 8b905cd095..8218463daf 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -210,33 +210,39 @@ void menu_tmc_current() {
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, refresh_homing_thrs_##ST);
 
   #if X_SENSORLESS
     void refresh_homing_thrs_X()  { stepperX.refresh_homing_thrs();  }
   #endif
+  #if X2_SENSORLESS
+    void refresh_homing_thrs_X2() { stepperX2.refresh_homing_thrs();  }
+  #endif
   #if Y_SENSORLESS
     void refresh_homing_thrs_Y()  { stepperY.refresh_homing_thrs();  }
   #endif
   #if Z_SENSORLESS
     void refresh_homing_thrs_Z()  { stepperZ.refresh_homing_thrs();  }
   #endif
 
   void menu_tmc_homing_thrs() {
     START_MENU();
     MENU_BACK(MSG_TMC_DRIVERS);
     #if X_SENSORLESS
       TMC_EDIT_STORED_SGT(X);
     #endif
+    #if X2_SENSORLESS
+      TMC_EDIT_STORED_SGT(X2);
+    #endif
     #if Y_SENSORLESS
       TMC_EDIT_STORED_SGT(Y);
     #endif
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 1a6bf8f844..8b905cd095 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 585af5b5b6..1a6bf8f844 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -205,21 +205,21 @@ void menu_tmc_current() {
     #if AXIS_HAS_STEALTHCHOP(E5)
       TMC_EDIT_STORED_HYBRID_THRS(E5, MSG_E6);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int8, MSG_##ST, &stepper##ST.stored.homing_thrs, -64, 63, refresh_homing_thrs_##ST);
+  #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int4, MSG_##ST, &stepper##ST.stored.homing_thrs, stepper##ST.sgt_min, stepper##ST.sgt_max, refresh_homing_thrs_##ST);
 
   #if X_SENSORLESS
     void refresh_homing_thrs_X()  { stepperX.refresh_homing_thrs();  }
   #endif
   #if Y_SENSORLESS
     void refresh_homing_thrs_Y()  { stepperY.refresh_homing_thrs();  }
   #endif
   #if Z_SENSORLESS
     void refresh_homing_thrs_Z()  { stepperZ.refresh_homing_thrs();  }
   #endif

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 13634c5894..585af5b5b6 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -117,57 +117,57 @@ void menu_tmc_current() {
     TMC_EDIT_STORED_I_RMS(E5, MSG_E6);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
   #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) MENU_ITEM_EDIT_CALLBACK(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
 
   #if AXIS_HAS_STEALTHCHOP(X)
-    void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[X_AXIS]); }
+    void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
-    void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Y_AXIS]); }
+    void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
-    void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+    void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(X2)
-    void refresh_hybrid_thrs_X2() { stepperX2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[X_AXIS]); }
+    void refresh_hybrid_thrs_X2() { stepperX2.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y2)
-    void refresh_hybrid_thrs_Y2() { stepperY2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Y_AXIS]); }
+    void refresh_hybrid_thrs_Y2() { stepperY2.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z2)
-    void refresh_hybrid_thrs_Z2() { stepperZ2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+    void refresh_hybrid_thrs_Z2() { stepperZ2.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z3)
-    void refresh_hybrid_thrs_Z3() { stepperZ3.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+    void refresh_hybrid_thrs_Z3() { stepperZ3.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E0)
-    void refresh_hybrid_thrs_E0() { stepperE0.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS]); }
+    void refresh_hybrid_thrs_E0() { stepperE0.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E1)
-    void refresh_hybrid_thrs_E1() { stepperE1.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(1)]); }
+    void refresh_hybrid_thrs_E1() { stepperE1.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E2)
-    void refresh_hybrid_thrs_E2() { stepperE2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(2)]); }
+    void refresh_hybrid_thrs_E2() { stepperE2.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E3)
-    void refresh_hybrid_thrs_E3() { stepperE3.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(3)]); }
+    void refresh_hybrid_thrs_E3() { stepperE3.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E4)
-    void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(4)]); }
+    void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E5)
-    void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(5)]); }
+    void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(); }
   #endif
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     MENU_BACK(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
       TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
       TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);

commit ca7f6ff2876e7f9aa5c536bb4e733df40494cea2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Apr 23 12:31:51 2019 -0600

    Fix MSG_En messages for consistency (#13788)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 3d44649599..13634c5894 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -25,21 +25,21 @@
 //
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_TRINAMIC && HAS_LCD_MENU
 
 #include "menu.h"
 #include "../../module/stepper_indirection.h"
 #include "../../feature/tmc_util.h"
 
-#define TMC_EDIT_STORED_I_RMS(ST) MENU_ITEM_EDIT_CALLBACK(uint16_4, MSG_##ST, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
+#define TMC_EDIT_STORED_I_RMS(ST,MSG) MENU_ITEM_EDIT_CALLBACK(uint16_4, MSG, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
 
 #if AXIS_IS_TMC(X)
   void refresh_stepper_current_X()  { stepperX.refresh_stepper_current();  }
 #endif
 #if AXIS_IS_TMC(Y)
   void refresh_stepper_current_Y()  { stepperY.refresh_stepper_current();  }
 #endif
 #if AXIS_IS_TMC(Z)
   void refresh_stepper_current_Z()  { stepperZ.refresh_stepper_current();  }
 #endif
@@ -71,64 +71,64 @@
   void refresh_stepper_current_E4() { stepperE4.refresh_stepper_current(); }
 #endif
 #if AXIS_IS_TMC(E5)
   void refresh_stepper_current_E5() { stepperE5.refresh_stepper_current(); }
 #endif
 
 void menu_tmc_current() {
   START_MENU();
   MENU_BACK(MSG_TMC_DRIVERS);
   #if AXIS_IS_TMC(X)
-    TMC_EDIT_STORED_I_RMS(X);
+    TMC_EDIT_STORED_I_RMS(X, MSG_X);
   #endif
   #if AXIS_IS_TMC(Y)
-    TMC_EDIT_STORED_I_RMS(Y);
+    TMC_EDIT_STORED_I_RMS(Y, MSG_Y);
   #endif
   #if AXIS_IS_TMC(Z)
-    TMC_EDIT_STORED_I_RMS(Z);
+    TMC_EDIT_STORED_I_RMS(Z, MSG_Z);
   #endif
   #if AXIS_IS_TMC(X2)
-    TMC_EDIT_STORED_I_RMS(X2);
+    TMC_EDIT_STORED_I_RMS(X2, MSG_X2);
   #endif
   #if AXIS_IS_TMC(Y2)
-    TMC_EDIT_STORED_I_RMS(Y2);
+    TMC_EDIT_STORED_I_RMS(Y2, MSG_Y2);
   #endif
   #if AXIS_IS_TMC(Z2)
-    TMC_EDIT_STORED_I_RMS(Z2);
+    TMC_EDIT_STORED_I_RMS(Z2, MSG_Z2);
   #endif
   #if AXIS_IS_TMC(Z3)
-    TMC_EDIT_STORED_I_RMS(Z3);
+    TMC_EDIT_STORED_I_RMS(Z3, MSG_Z3);
   #endif
   #if AXIS_IS_TMC(E0)
-    TMC_EDIT_STORED_I_RMS(E0);
+    TMC_EDIT_STORED_I_RMS(E0, MSG_E1);
   #endif
   #if AXIS_IS_TMC(E1)
-    TMC_EDIT_STORED_I_RMS(E1);
+    TMC_EDIT_STORED_I_RMS(E1, MSG_E2);
   #endif
   #if AXIS_IS_TMC(E2)
-    TMC_EDIT_STORED_I_RMS(E2);
+    TMC_EDIT_STORED_I_RMS(E2, MSG_E3);
   #endif
   #if AXIS_IS_TMC(E3)
-    TMC_EDIT_STORED_I_RMS(E3);
+    TMC_EDIT_STORED_I_RMS(E3, MSG_E4);
   #endif
   #if AXIS_IS_TMC(E4)
-    TMC_EDIT_STORED_I_RMS(E4);
+    TMC_EDIT_STORED_I_RMS(E4, MSG_E5);
   #endif
   #if AXIS_IS_TMC(E5)
-    TMC_EDIT_STORED_I_RMS(E5);
+    TMC_EDIT_STORED_I_RMS(E5, MSG_E6);
   #endif
   END_MENU();
 }
 
 #if ENABLED(HYBRID_THRESHOLD)
 
-  #define TMC_EDIT_STORED_HYBRID_THRS(ST) MENU_ITEM_EDIT_CALLBACK(uint8, MSG_##ST, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST, MSG) MENU_ITEM_EDIT_CALLBACK(uint8, MSG, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
 
   #if AXIS_HAS_STEALTHCHOP(X)
     void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[X_AXIS]); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
     void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Y_AXIS]); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
     void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
   #endif
@@ -160,57 +160,57 @@ void menu_tmc_current() {
     void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(4)]); }
   #endif
   #if AXIS_HAS_STEALTHCHOP(E5)
     void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(5)]); }
   #endif
 
   void menu_tmc_hybrid_thrs() {
     START_MENU();
     MENU_BACK(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STORED_HYBRID_THRS(X);
+      TMC_EDIT_STORED_HYBRID_THRS(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STORED_HYBRID_THRS(Y);
+      TMC_EDIT_STORED_HYBRID_THRS(Y, MSG_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STORED_HYBRID_THRS(Z);
+      TMC_EDIT_STORED_HYBRID_THRS(Z, MSG_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STORED_HYBRID_THRS(X2);
+      TMC_EDIT_STORED_HYBRID_THRS(X2, MSG_X2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STORED_HYBRID_THRS(Y2);
+      TMC_EDIT_STORED_HYBRID_THRS(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STORED_HYBRID_THRS(Z2);
+      TMC_EDIT_STORED_HYBRID_THRS(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STORED_HYBRID_THRS(Z3);
+      TMC_EDIT_STORED_HYBRID_THRS(Z3, MSG_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STORED_HYBRID_THRS(E0);
+      TMC_EDIT_STORED_HYBRID_THRS(E0, MSG_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STORED_HYBRID_THRS(E1);
+      TMC_EDIT_STORED_HYBRID_THRS(E1, MSG_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STORED_HYBRID_THRS(E2);
+      TMC_EDIT_STORED_HYBRID_THRS(E2, MSG_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STORED_HYBRID_THRS(E3);
+      TMC_EDIT_STORED_HYBRID_THRS(E3, MSG_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STORED_HYBRID_THRS(E4);
+      TMC_EDIT_STORED_HYBRID_THRS(E4, MSG_E5);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STORED_HYBRID_THRS(E5);
+      TMC_EDIT_STORED_HYBRID_THRS(E5, MSG_E6);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
 
   #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int8, MSG_##ST, &stepper##ST.stored.homing_thrs, -64, 63, refresh_homing_thrs_##ST);
 
@@ -236,21 +236,21 @@ void menu_tmc_current() {
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
 #if HAS_STEALTHCHOP
 
-  #define TMC_EDIT_STEP_MODE(ST) MENU_ITEM_EDIT_CALLBACK(bool, MSG_##ST, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
+  #define TMC_EDIT_STEP_MODE(ST, MSG) MENU_ITEM_EDIT_CALLBACK(bool, MSG, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
 
   #if AXIS_HAS_STEALTHCHOP(X)
     void refresh_stepping_mode_X()  { stepperX.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
     void refresh_stepping_mode_Y()  { stepperY.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
     void refresh_stepping_mode_Z()  { stepperZ.refresh_stepping_mode();  }
   #endif
@@ -283,57 +283,57 @@ void menu_tmc_current() {
   #endif
   #if AXIS_HAS_STEALTHCHOP(E5)
     void refresh_stepping_mode_E5() { stepperE5.refresh_stepping_mode(); }
   #endif
 
   void menu_tmc_step_mode() {
     START_MENU();
     STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
     MENU_BACK(MSG_TMC_DRIVERS);
     #if AXIS_HAS_STEALTHCHOP(X)
-      TMC_EDIT_STEP_MODE(X);
+      TMC_EDIT_STEP_MODE(X, MSG_X);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y)
-      TMC_EDIT_STEP_MODE(Y);
+      TMC_EDIT_STEP_MODE(Y, MSG_Y);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z)
-      TMC_EDIT_STEP_MODE(Z);
+      TMC_EDIT_STEP_MODE(Z, MSG_Z);
     #endif
     #if AXIS_HAS_STEALTHCHOP(X2)
-      TMC_EDIT_STEP_MODE(X2);
+      TMC_EDIT_STEP_MODE(X2, MSG_X2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Y2)
-      TMC_EDIT_STEP_MODE(Y2);
+      TMC_EDIT_STEP_MODE(Y2, MSG_Y2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z2)
-      TMC_EDIT_STEP_MODE(Z2);
+      TMC_EDIT_STEP_MODE(Z2, MSG_Z2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(Z3)
-      TMC_EDIT_STEP_MODE(Z3);
+      TMC_EDIT_STEP_MODE(Z3, MSG_Z3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E0)
-      TMC_EDIT_STEP_MODE(E0);
+      TMC_EDIT_STEP_MODE(E0, MSG_E1);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E1)
-      TMC_EDIT_STEP_MODE(E1);
+      TMC_EDIT_STEP_MODE(E1, MSG_E2);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E2)
-      TMC_EDIT_STEP_MODE(E2);
+      TMC_EDIT_STEP_MODE(E2, MSG_E3);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E3)
-      TMC_EDIT_STEP_MODE(E3);
+      TMC_EDIT_STEP_MODE(E3, MSG_E4);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E4)
-      TMC_EDIT_STEP_MODE(E4);
+      TMC_EDIT_STEP_MODE(E4, MSG_E5);
     #endif
     #if AXIS_HAS_STEALTHCHOP(E5)
-      TMC_EDIT_STEP_MODE(E5);
+      TMC_EDIT_STEP_MODE(E5, MSG_E6);
     #endif
     END_MENU();
   }
 
 #endif
 
 void menu_tmc() {
   START_MENU();
   MENU_BACK(MSG_CONTROL);
   MENU_ITEM(submenu, MSG_TMC_CURRENT, menu_tmc_current);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index fa2e2c4c86..3d44649599 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit e5801b75f89254d088b423499719b5ccbc48cb0d
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Jan 21 07:54:57 2019 +0200

    Fix TMC-related compile issues. (#12971)
    
    - `STEALTHOP_[XYZE]` configuration options now set the default state.

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
index 269e65ba57..fa2e2c4c86 100644
--- a/Marlin/src/lcd/menu/menu_tmc.cpp
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -234,21 +234,21 @@ void menu_tmc_current() {
       TMC_EDIT_STORED_SGT(Y);
     #endif
     #if Z_SENSORLESS
       TMC_EDIT_STORED_SGT(Z);
     #endif
     END_MENU();
   }
 
 #endif
 
-#if STEALTHCHOP_ENABLED
+#if HAS_STEALTHCHOP
 
   #define TMC_EDIT_STEP_MODE(ST) MENU_ITEM_EDIT_CALLBACK(bool, MSG_##ST, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
 
   #if AXIS_HAS_STEALTHCHOP(X)
     void refresh_stepping_mode_X()  { stepperX.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Y)
     void refresh_stepping_mode_Y()  { stepperY.refresh_stepping_mode();  }
   #endif
   #if AXIS_HAS_STEALTHCHOP(Z)
@@ -336,17 +336,17 @@ void menu_tmc_current() {
 void menu_tmc() {
   START_MENU();
   MENU_BACK(MSG_CONTROL);
   MENU_ITEM(submenu, MSG_TMC_CURRENT, menu_tmc_current);
   #if ENABLED(HYBRID_THRESHOLD)
     MENU_ITEM(submenu, MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
   #endif
   #if ENABLED(SENSORLESS_HOMING)
     MENU_ITEM(submenu, MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
   #endif
-  #if STEALTHCHOP_ENABLED
+  #if HAS_STEALTHCHOP
     MENU_ITEM(submenu, MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
   #endif
   END_MENU();
 }
 
 #endif // HAS_TRINAMIC

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/lcd/menu/menu_tmc.cpp b/Marlin/src/lcd/menu/menu_tmc.cpp
new file mode 100644
index 0000000000..269e65ba57
--- /dev/null
+++ b/Marlin/src/lcd/menu/menu_tmc.cpp
@@ -0,0 +1,352 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+//
+// TMC Menu
+//
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_TRINAMIC && HAS_LCD_MENU
+
+#include "menu.h"
+#include "../../module/stepper_indirection.h"
+#include "../../feature/tmc_util.h"
+
+#define TMC_EDIT_STORED_I_RMS(ST) MENU_ITEM_EDIT_CALLBACK(uint16_4, MSG_##ST, &stepper##ST.val_mA, 100, 3000, refresh_stepper_current_##ST)
+
+#if AXIS_IS_TMC(X)
+  void refresh_stepper_current_X()  { stepperX.refresh_stepper_current();  }
+#endif
+#if AXIS_IS_TMC(Y)
+  void refresh_stepper_current_Y()  { stepperY.refresh_stepper_current();  }
+#endif
+#if AXIS_IS_TMC(Z)
+  void refresh_stepper_current_Z()  { stepperZ.refresh_stepper_current();  }
+#endif
+#if AXIS_IS_TMC(X2)
+  void refresh_stepper_current_X2() { stepperX2.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(Y2)
+  void refresh_stepper_current_Y2() { stepperY2.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(Z2)
+  void refresh_stepper_current_Z2() { stepperZ2.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(Z3)
+  void refresh_stepper_current_Z3() { stepperZ3.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E0)
+  void refresh_stepper_current_E0() { stepperE0.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E1)
+  void refresh_stepper_current_E1() { stepperE1.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E2)
+  void refresh_stepper_current_E2() { stepperE2.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E3)
+  void refresh_stepper_current_E3() { stepperE3.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E4)
+  void refresh_stepper_current_E4() { stepperE4.refresh_stepper_current(); }
+#endif
+#if AXIS_IS_TMC(E5)
+  void refresh_stepper_current_E5() { stepperE5.refresh_stepper_current(); }
+#endif
+
+void menu_tmc_current() {
+  START_MENU();
+  MENU_BACK(MSG_TMC_DRIVERS);
+  #if AXIS_IS_TMC(X)
+    TMC_EDIT_STORED_I_RMS(X);
+  #endif
+  #if AXIS_IS_TMC(Y)
+    TMC_EDIT_STORED_I_RMS(Y);
+  #endif
+  #if AXIS_IS_TMC(Z)
+    TMC_EDIT_STORED_I_RMS(Z);
+  #endif
+  #if AXIS_IS_TMC(X2)
+    TMC_EDIT_STORED_I_RMS(X2);
+  #endif
+  #if AXIS_IS_TMC(Y2)
+    TMC_EDIT_STORED_I_RMS(Y2);
+  #endif
+  #if AXIS_IS_TMC(Z2)
+    TMC_EDIT_STORED_I_RMS(Z2);
+  #endif
+  #if AXIS_IS_TMC(Z3)
+    TMC_EDIT_STORED_I_RMS(Z3);
+  #endif
+  #if AXIS_IS_TMC(E0)
+    TMC_EDIT_STORED_I_RMS(E0);
+  #endif
+  #if AXIS_IS_TMC(E1)
+    TMC_EDIT_STORED_I_RMS(E1);
+  #endif
+  #if AXIS_IS_TMC(E2)
+    TMC_EDIT_STORED_I_RMS(E2);
+  #endif
+  #if AXIS_IS_TMC(E3)
+    TMC_EDIT_STORED_I_RMS(E3);
+  #endif
+  #if AXIS_IS_TMC(E4)
+    TMC_EDIT_STORED_I_RMS(E4);
+  #endif
+  #if AXIS_IS_TMC(E5)
+    TMC_EDIT_STORED_I_RMS(E5);
+  #endif
+  END_MENU();
+}
+
+#if ENABLED(HYBRID_THRESHOLD)
+
+  #define TMC_EDIT_STORED_HYBRID_THRS(ST) MENU_ITEM_EDIT_CALLBACK(uint8, MSG_##ST, &stepper##ST.stored.hybrid_thrs, 0, 255, refresh_hybrid_thrs_##ST);
+
+  #if AXIS_HAS_STEALTHCHOP(X)
+    void refresh_hybrid_thrs_X()  {  stepperX.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[X_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Y)
+    void refresh_hybrid_thrs_Y()  {  stepperY.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Y_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z)
+    void refresh_hybrid_thrs_Z()  {  stepperZ.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(X2)
+    void refresh_hybrid_thrs_X2() { stepperX2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[X_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Y2)
+    void refresh_hybrid_thrs_Y2() { stepperY2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Y_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z2)
+    void refresh_hybrid_thrs_Z2() { stepperZ2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z3)
+    void refresh_hybrid_thrs_Z3() { stepperZ3.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[Z_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E0)
+    void refresh_hybrid_thrs_E0() { stepperE0.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E1)
+    void refresh_hybrid_thrs_E1() { stepperE1.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(1)]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E2)
+    void refresh_hybrid_thrs_E2() { stepperE2.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(2)]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E3)
+    void refresh_hybrid_thrs_E3() { stepperE3.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(3)]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E4)
+    void refresh_hybrid_thrs_E4() { stepperE4.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(4)]); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E5)
+    void refresh_hybrid_thrs_E5() { stepperE5.refresh_hybrid_thrs(planner.settings.axis_steps_per_mm[E_AXIS_N(5)]); }
+  #endif
+
+  void menu_tmc_hybrid_thrs() {
+    START_MENU();
+    MENU_BACK(MSG_TMC_DRIVERS);
+    #if AXIS_HAS_STEALTHCHOP(X)
+      TMC_EDIT_STORED_HYBRID_THRS(X);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Y)
+      TMC_EDIT_STORED_HYBRID_THRS(Y);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z)
+      TMC_EDIT_STORED_HYBRID_THRS(Z);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(X2)
+      TMC_EDIT_STORED_HYBRID_THRS(X2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Y2)
+      TMC_EDIT_STORED_HYBRID_THRS(Y2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z2)
+      TMC_EDIT_STORED_HYBRID_THRS(Z2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z3)
+      TMC_EDIT_STORED_HYBRID_THRS(Z3);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E0)
+      TMC_EDIT_STORED_HYBRID_THRS(E0);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E1)
+      TMC_EDIT_STORED_HYBRID_THRS(E1);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E2)
+      TMC_EDIT_STORED_HYBRID_THRS(E2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E3)
+      TMC_EDIT_STORED_HYBRID_THRS(E3);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E4)
+      TMC_EDIT_STORED_HYBRID_THRS(E4);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E5)
+      TMC_EDIT_STORED_HYBRID_THRS(E5);
+    #endif
+    END_MENU();
+  }
+
+#endif
+
+#if ENABLED(SENSORLESS_HOMING)
+
+  #define TMC_EDIT_STORED_SGT(ST) MENU_ITEM_EDIT_CALLBACK(int8, MSG_##ST, &stepper##ST.stored.homing_thrs, -64, 63, refresh_homing_thrs_##ST);
+
+  #if X_SENSORLESS
+    void refresh_homing_thrs_X()  { stepperX.refresh_homing_thrs();  }
+  #endif
+  #if Y_SENSORLESS
+    void refresh_homing_thrs_Y()  { stepperY.refresh_homing_thrs();  }
+  #endif
+  #if Z_SENSORLESS
+    void refresh_homing_thrs_Z()  { stepperZ.refresh_homing_thrs();  }
+  #endif
+
+  void menu_tmc_homing_thrs() {
+    START_MENU();
+    MENU_BACK(MSG_TMC_DRIVERS);
+    #if X_SENSORLESS
+      TMC_EDIT_STORED_SGT(X);
+    #endif
+    #if Y_SENSORLESS
+      TMC_EDIT_STORED_SGT(Y);
+    #endif
+    #if Z_SENSORLESS
+      TMC_EDIT_STORED_SGT(Z);
+    #endif
+    END_MENU();
+  }
+
+#endif
+
+#if STEALTHCHOP_ENABLED
+
+  #define TMC_EDIT_STEP_MODE(ST) MENU_ITEM_EDIT_CALLBACK(bool, MSG_##ST, &stepper##ST.stored.stealthChop_enabled, refresh_stepping_mode_##ST)
+
+  #if AXIS_HAS_STEALTHCHOP(X)
+    void refresh_stepping_mode_X()  { stepperX.refresh_stepping_mode();  }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Y)
+    void refresh_stepping_mode_Y()  { stepperY.refresh_stepping_mode();  }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z)
+    void refresh_stepping_mode_Z()  { stepperZ.refresh_stepping_mode();  }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(X2)
+    void refresh_stepping_mode_X2() { stepperX2.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Y2)
+    void refresh_stepping_mode_Y2() { stepperY2.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z2)
+    void refresh_stepping_mode_Z2() { stepperZ2.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(Z3)
+    void refresh_stepping_mode_Z3() { stepperZ3.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E0)
+    void refresh_stepping_mode_E0() { stepperE0.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E1)
+    void refresh_stepping_mode_E1() { stepperE1.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E2)
+    void refresh_stepping_mode_E2() { stepperE2.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E3)
+    void refresh_stepping_mode_E3() { stepperE3.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E4)
+    void refresh_stepping_mode_E4() { stepperE4.refresh_stepping_mode(); }
+  #endif
+  #if AXIS_HAS_STEALTHCHOP(E5)
+    void refresh_stepping_mode_E5() { stepperE5.refresh_stepping_mode(); }
+  #endif
+
+  void menu_tmc_step_mode() {
+    START_MENU();
+    STATIC_ITEM(MSG_TMC_STEALTH_ENABLED);
+    MENU_BACK(MSG_TMC_DRIVERS);
+    #if AXIS_HAS_STEALTHCHOP(X)
+      TMC_EDIT_STEP_MODE(X);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Y)
+      TMC_EDIT_STEP_MODE(Y);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z)
+      TMC_EDIT_STEP_MODE(Z);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(X2)
+      TMC_EDIT_STEP_MODE(X2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Y2)
+      TMC_EDIT_STEP_MODE(Y2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z2)
+      TMC_EDIT_STEP_MODE(Z2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(Z3)
+      TMC_EDIT_STEP_MODE(Z3);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E0)
+      TMC_EDIT_STEP_MODE(E0);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E1)
+      TMC_EDIT_STEP_MODE(E1);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E2)
+      TMC_EDIT_STEP_MODE(E2);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E3)
+      TMC_EDIT_STEP_MODE(E3);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E4)
+      TMC_EDIT_STEP_MODE(E4);
+    #endif
+    #if AXIS_HAS_STEALTHCHOP(E5)
+      TMC_EDIT_STEP_MODE(E5);
+    #endif
+    END_MENU();
+  }
+
+#endif
+
+void menu_tmc() {
+  START_MENU();
+  MENU_BACK(MSG_CONTROL);
+  MENU_ITEM(submenu, MSG_TMC_CURRENT, menu_tmc_current);
+  #if ENABLED(HYBRID_THRESHOLD)
+    MENU_ITEM(submenu, MSG_TMC_HYBRID_THRS, menu_tmc_hybrid_thrs);
+  #endif
+  #if ENABLED(SENSORLESS_HOMING)
+    MENU_ITEM(submenu, MSG_TMC_HOMING_THRS, menu_tmc_homing_thrs);
+  #endif
+  #if STEALTHCHOP_ENABLED
+    MENU_ITEM(submenu, MSG_TMC_STEPPING_MODE, menu_tmc_step_mode);
+  #endif
+  END_MENU();
+}
+
+#endif // HAS_TRINAMIC
