commit d69ce775032bc254bf3da67088ebdfcaad0612b5
Author: Yuri D'Elia <wavexx@users.noreply.github.com>
Date:   Mon Aug 21 21:39:49 2023 +0200

    üêõ Fixes for G2/G3 arcs (#26170)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b3a281bcc8..c87d64d19b 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -75,28 +75,31 @@ void plan_arc(
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[axis_p] - rvec.a,
               center_Q = current_position[axis_q] - rvec.b,
               rt_X = cart[axis_p] - center_P,
               rt_Y = cart[axis_q] - center_Q;
 
-  ARC_LIJKUVW_CODE(
-    const float start_L = current_position[axis_l],
-    const float start_I = current_position.i,
-    const float start_J = current_position.j,
-    const float start_K = current_position.k,
-    const float start_U = current_position.u,
-    const float start_V = current_position.v,
-    const float start_W = current_position.w
+  // Starting position of the move for all non-arc axes
+  // i.e., only one of X, Y, or Z, plus the rest.
+  ARC_LIJKUVWE_CODE(
+    float start_L = current_position[axis_l],
+    float start_I = current_position.i,
+    float start_J = current_position.j,
+    float start_K = current_position.k,
+    float start_U = current_position.u,
+    float start_V = current_position.v,
+    float start_W = current_position.w,
+    float start_E = current_position.e
   );
 
   // Angle of rotation between position and target from the circle center.
   float angular_travel, abs_angular_travel;
 
   // Minimum number of segments in an arc move
   uint16_t min_segments = 1;
 
   // Do a full circle if starting and ending positions are "identical"
   if (NEAR(current_position[axis_p], cart[axis_p]) && NEAR(current_position[axis_q], cart[axis_q])) {
@@ -118,29 +121,30 @@ void plan_arc(
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
     abs_angular_travel = ABS(angular_travel);
 
     // Apply minimum segments to the arc
     const float portion_of_circle = abs_angular_travel / RADIANS(360);  // Portion of a complete circle (0 < N < 1)
     min_segments = CEIL((MIN_CIRCLE_SEGMENTS) * portion_of_circle);     // Minimum segments for the arc
   }
 
+  // Total travel on all the non-arc axes
   ARC_LIJKUVWE_CODE(
     float travel_L = cart[axis_l] - start_L,
     float travel_I = cart.i       - start_I,
     float travel_J = cart.j       - start_J,
     float travel_K = cart.k       - start_K,
     float travel_U = cart.u       - start_U,
     float travel_V = cart.v       - start_V,
     float travel_W = cart.w       - start_W,
-    float travel_E = cart.e       - current_position.e
+    float travel_E = cart.e       - start_E
   );
 
   // If "P" specified circles, call plan_arc recursively then continue with the rest of the arc
   if (TERN0(ARC_P_CIRCLES, circles)) {
     const float total_angular = abs_angular_travel + circles * RADIANS(360),    // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular;                   // Each circle's part of the total
 
     ARC_LIJKUVWE_CODE(
       const float per_circle_L = travel_L * part_per_circle,    // X, Y, or Z movement per circle
       const float per_circle_I = travel_I * part_per_circle,    // The rest are also non-arc
@@ -159,29 +163,43 @@ void plan_arc(
         temp_position.i       += per_circle_I,                  // The rest are also non-circular
         temp_position.j       += per_circle_J,
         temp_position.k       += per_circle_K,
         temp_position.u       += per_circle_U,
         temp_position.v       += per_circle_V,
         temp_position.w       += per_circle_W,
         temp_position.e       += per_circle_E                   // Destination E axis
       );
       plan_arc(temp_position, offset, clockwise, 0);            // Plan a single whole circle
     }
+
+    // Get starting coordinates for the remainder from the current position
+    ARC_LIJKUVWE_CODE(
+      start_L = current_position[axis_l],
+      start_I = current_position.i,
+      start_J = current_position.j,
+      start_K = current_position.k,
+      start_U = current_position.u,
+      start_V = current_position.v,
+      start_W = current_position.w,
+      start_E = current_position.e
+    );
+
+    // Update travel distance for the remainder
     ARC_LIJKUVWE_CODE(
-      travel_L = cart[axis_l] - current_position[axis_l],       // Linear X, Y, or Z
-      travel_I = cart.i       - current_position.i,             // The rest are also non-arc
-      travel_J = cart.j       - current_position.j,
-      travel_K = cart.k       - current_position.k,
-      travel_U = cart.u       - current_position.u,
-      travel_V = cart.v       - current_position.v,
-      travel_W = cart.w       - current_position.w,
-      travel_E = cart.e       - current_position.e
+      travel_L = cart[axis_l] - start_L,                        // Linear X, Y, or Z
+      travel_I = cart.i       - start_I,                        // The rest are also non-arc
+      travel_J = cart.j       - start_J,
+      travel_K = cart.k       - start_K,
+      travel_U = cart.u       - start_U,
+      travel_V = cart.v       - start_V,
+      travel_W = cart.w       - start_W,
+      travel_E = cart.e       - start_E
     );
   }
 
   // Millimeters in the arc, assuming it's flat
   const float flat_mm = radius * abs_angular_travel;
 
   // Return if the move is near zero
   if (flat_mm < 0.0001f
     GANG_N(SUB2(NUM_AXES),                                      // Two axes for the arc
       && NEAR_ZERO(travel_L),                                   // Linear X, Y, or Z
@@ -249,70 +267,66 @@ void plan_arc(
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
 
   xyze_pos_t raw;
 
-  // do not calculate rotation parameters for trivial single-segment arcs
+  // Don't calculate rotation parameters for trivial single-segment arcs
   if (segments > 1) {
     // Vector rotation matrix values
     const float theta_per_segment = angular_travel / segments,
                 sq_theta_per_segment = sq(theta_per_segment),
                 sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
                 cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
-    #if DISABLED(AUTO_BED_LEVELING_UBL)
-      ARC_LIJKUVW_CODE(
-        const float per_segment_L = travel_L / segments,
-        const float per_segment_I = travel_I / segments,
-        const float per_segment_J = travel_J / segments,
-        const float per_segment_K = travel_K / segments,
-        const float per_segment_U = travel_U / segments,
-        const float per_segment_V = travel_V / segments,
-        const float per_segment_W = travel_W / segments
-      );
-    #endif
-
-    CODE_ITEM_E(const float extruder_per_segment = travel_E / segments);
+    ARC_LIJKUVWE_CODE(
+      const float per_segment_L = travel_L / segments,
+      const float per_segment_I = travel_I / segments,
+      const float per_segment_J = travel_J / segments,
+      const float per_segment_K = travel_K / segments,
+      const float per_segment_U = travel_U / segments,
+      const float per_segment_V = travel_V / segments,
+      const float per_segment_W = travel_W / segments,
+      const float per_segment_E = travel_E / segments
+    );
 
     // Initialize all linear axes and E
     ARC_LIJKUVWE_CODE(
-      raw[axis_l] = current_position[axis_l],
-      raw.i       = current_position.i,
-      raw.j       = current_position.j,
-      raw.k       = current_position.k,
-      raw.u       = current_position.u,
-      raw.v       = current_position.v,
-      raw.w       = current_position.w,
-      raw.e       = current_position.e
+      raw[axis_l] = start_L,
+      raw.i       = start_I,
+      raw.j       = start_J,
+      raw.k       = start_K,
+      raw.u       = start_U,
+      raw.v       = start_V,
+      raw.w       = start_W,
+      raw.e       = start_E
     );
 
     millis_t next_idle_ms = millis() + 200UL;
 
     #if N_ARC_CORRECTION > 1
       int8_t arc_recalc_count = N_ARC_CORRECTION;
     #endif
 
     // An arc can always complete within limits from a speed which...
     // a) is <= any configured maximum speed,
     // b) does not require centripetal force greater than any configured maximum acceleration,
     // c) is <= nominal speed,
     // d) allows the print head to stop in the remining length of the curve within all configured maximum accelerations.
     // The last has to be calculated every time through the loop.
     const float limiting_accel = _MIN(planner.settings.max_acceleration_mm_per_s2[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
                 limiting_speed = _MIN(planner.settings.max_feedrate_mm_s[axis_p], planner.settings.max_feedrate_mm_s[axis_q]),
                 limiting_speed_sqr = _MIN(sq(limiting_speed), limiting_accel * radius, sq(scaled_fr_mm_s));
-    float arc_mm_remaining = flat_mm;
 
     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
       thermalManager.task();
       const millis_t ms = millis();
       if (ELAPSED(ms, next_idle_ms)) {
         next_idle_ms = ms + 200UL;
         idle();
       }
 
@@ -336,77 +350,61 @@ void plan_arc(
         // For now, compute both at the same time.
         const float Ti = i * theta_per_segment, cos_Ti = cos(Ti), sin_Ti = sin(Ti);
         rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
         rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
       }
 
       // Update raw location
       raw[axis_p] = center_P + rvec.a;
       raw[axis_q] = center_Q + rvec.b;
       ARC_LIJKUVWE_CODE(
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          raw[axis_l] = start_L,
-          raw.i = start_I, raw.j = start_J, raw.k = start_K,
-          raw.u = start_U, raw.v = start_V, raw.w = start_V
-        #else
-          raw[axis_l] += per_segment_L,
-          raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K,
-          raw.u += per_segment_U, raw.v += per_segment_V, raw.w += per_segment_W
-        #endif
-        , raw.e += extruder_per_segment
+        raw[axis_l] = start_L + per_segment_L * i,
+        raw.i       = start_I + per_segment_I * i,
+        raw.j       = start_J + per_segment_J * i,
+        raw.k       = start_K + per_segment_K * i,
+        raw.u       = start_U + per_segment_U * i,
+        raw.v       = start_V + per_segment_V * i,
+        raw.w       = start_W + per_segment_W * i,
+        raw.e       = start_E + per_segment_E * i
       );
 
       apply_motion_limits(raw);
 
       #if HAS_LEVELING && !PLANNER_LEVELING
         planner.apply_leveling(raw);
       #endif
 
       // calculate safe speed for stopping by the end of the arc
-      arc_mm_remaining -= segment_mm;
+      const float arc_mm_remaining = flat_mm - segment_mm * i;
       hints.safe_exit_speed_sqr = _MIN(limiting_speed_sqr, 2 * limiting_accel * arc_mm_remaining);
 
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints))
         break;
 
       hints.curve_radius = radius;
     }
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJKUVW_CODE(
-      raw[axis_l] = start_L,
-      raw.i = start_I, raw.j = start_J, raw.k = start_K,
-      raw.u = start_U, raw.v = start_V, raw.w = start_W
-    );
-  #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   hints.curve_radius = 0;
   hints.safe_exit_speed_sqr = 0.0f;
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints);
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJKUVW_CODE(
-      raw[axis_l] = start_L,
-      raw.i = start_I, raw.j = start_J, raw.k = start_K,
-      raw.u = start_U, raw.v = start_V, raw.w = start_W
-    );
-  #endif
-  current_position = raw;
+  current_position = cart;
 
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form (JK, KI) and R-form.
  *
  *  - Depending on the current Workspace Plane orientation,

commit a3df3d40eec8e3d4b82feed5b92d50ba15b47acf
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jun 17 22:55:02 2023 +0200

    üêõ Fix G2/G3 limiting_speed (#25988)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 1cae82f71c..b3a281bcc8 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -296,21 +296,21 @@ void plan_arc(
       int8_t arc_recalc_count = N_ARC_CORRECTION;
     #endif
 
     // An arc can always complete within limits from a speed which...
     // a) is <= any configured maximum speed,
     // b) does not require centripetal force greater than any configured maximum acceleration,
     // c) is <= nominal speed,
     // d) allows the print head to stop in the remining length of the curve within all configured maximum accelerations.
     // The last has to be calculated every time through the loop.
     const float limiting_accel = _MIN(planner.settings.max_acceleration_mm_per_s2[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
-                limiting_speed = _MIN(planner.settings.max_feedrate_mm_s[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
+                limiting_speed = _MIN(planner.settings.max_feedrate_mm_s[axis_p], planner.settings.max_feedrate_mm_s[axis_q]),
                 limiting_speed_sqr = _MIN(sq(limiting_speed), limiting_accel * radius, sq(scaled_fr_mm_s));
     float arc_mm_remaining = flat_mm;
 
     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
       thermalManager.task();
       const millis_t ms = millis();
       if (ELAPSED(ms, next_idle_ms)) {
         next_idle_ms = ms + 200UL;
         idle();

commit 842489a5dc2d4e0c7f80c4bde031355383848360
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 19:36:22 2023 -0600

    üêõ Don't skip G2/G3 E-only moves

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 2634117cd9..1cae82f71c 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -135,71 +135,76 @@ void plan_arc(
     float travel_W = cart.w       - start_W,
     float travel_E = cart.e       - current_position.e
   );
 
   // If "P" specified circles, call plan_arc recursively then continue with the rest of the arc
   if (TERN0(ARC_P_CIRCLES, circles)) {
     const float total_angular = abs_angular_travel + circles * RADIANS(360),    // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular;                   // Each circle's part of the total
 
     ARC_LIJKUVWE_CODE(
-      const float per_circle_L = travel_L * part_per_circle,    // L movement per circle
-      const float per_circle_I = travel_I * part_per_circle,
+      const float per_circle_L = travel_L * part_per_circle,    // X, Y, or Z movement per circle
+      const float per_circle_I = travel_I * part_per_circle,    // The rest are also non-arc
       const float per_circle_J = travel_J * part_per_circle,
       const float per_circle_K = travel_K * part_per_circle,
       const float per_circle_U = travel_U * part_per_circle,
       const float per_circle_V = travel_V * part_per_circle,
       const float per_circle_W = travel_W * part_per_circle,
       const float per_circle_E = travel_E * part_per_circle     // E movement per circle
     );
 
     xyze_pos_t temp_position = current_position;
     for (uint16_t n = circles; n--;) {
-      ARC_LIJKUVWE_CODE(                                           // Destination Linear Axes
-        temp_position[axis_l] += per_circle_L,
-        temp_position.i       += per_circle_I,
+      ARC_LIJKUVWE_CODE(                                        // Destination Linear Axes
+        temp_position[axis_l] += per_circle_L,                  // Linear X, Y, or Z
+        temp_position.i       += per_circle_I,                  // The rest are also non-circular
         temp_position.j       += per_circle_J,
         temp_position.k       += per_circle_K,
         temp_position.u       += per_circle_U,
         temp_position.v       += per_circle_V,
         temp_position.w       += per_circle_W,
         temp_position.e       += per_circle_E                   // Destination E axis
       );
       plan_arc(temp_position, offset, clockwise, 0);            // Plan a single whole circle
     }
     ARC_LIJKUVWE_CODE(
-      travel_L = cart[axis_l] - current_position[axis_l],
-      travel_I = cart.i       - current_position.i,
+      travel_L = cart[axis_l] - current_position[axis_l],       // Linear X, Y, or Z
+      travel_I = cart.i       - current_position.i,             // The rest are also non-arc
       travel_J = cart.j       - current_position.j,
       travel_K = cart.k       - current_position.k,
       travel_U = cart.u       - current_position.u,
       travel_V = cart.v       - current_position.v,
       travel_W = cart.w       - current_position.w,
       travel_E = cart.e       - current_position.e
     );
   }
 
   // Millimeters in the arc, assuming it's flat
   const float flat_mm = radius * abs_angular_travel;
 
   // Return if the move is near zero
   if (flat_mm < 0.0001f
-    GANG_N(SUB2(NUM_AXES),
-      && travel_L < 0.0001f,
-      && travel_I < 0.0001f,
-      && travel_J < 0.0001f,
-      && travel_K < 0.0001f,
-      && travel_U < 0.0001f,
-      && travel_V < 0.0001f,
-      && travel_W < 0.0001f
+    GANG_N(SUB2(NUM_AXES),                                      // Two axes for the arc
+      && NEAR_ZERO(travel_L),                                   // Linear X, Y, or Z
+      && NEAR_ZERO(travel_I),
+      && NEAR_ZERO(travel_J),
+      && NEAR_ZERO(travel_K),
+      && NEAR_ZERO(travel_U),
+      && NEAR_ZERO(travel_V),
+      && NEAR_ZERO(travel_W)
     )
-  ) return;
+  ) {
+    #if HAS_EXTRUDERS
+      if (!NEAR_ZERO(travel_E)) gcode.G0_G1();                  // Handle retract/recover as G1
+      return;
+    #endif
+  }
 
   // Feedrate for the move, scaled by the feedrate multiplier
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Get the ideal segment length for the move based on settings
   const float ideal_segment_mm = (
     #if ARC_SEGMENTS_PER_SEC  // Length based on segments per second and feedrate
       constrain(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM)
     #else
       MAX_ARC_SEGMENT_MM      // Length using the maximum segment size
@@ -419,78 +424,77 @@ void plan_arc(
  *
  *  - P specifies the number of full circles to do
  *      before the specified arc move.
  *
  *  Examples:
  *
  *    G2 I10           ; CW circle centered at X+10
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
-  if (MOTION_CONDITIONS) {
+  if (!MOTION_CONDITIONS) return;
 
-    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));
 
-    #if ENABLED(SF_ARC_FIX)
-      const bool relative_mode_backup = relative_mode;
-      relative_mode = true;
-    #endif
+  #if ENABLED(SF_ARC_FIX)
+    const bool relative_mode_backup = relative_mode;
+    relative_mode = true;
+  #endif
 
-    get_destination_from_command();   // Get X Y [Z[I[J[K...]]]] [E] F (and set cutter power)
-
-    TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
-
-    ab_float_t arc_offset = { 0, 0 };
-    if (parser.seenval('R')) {
-      const float r = parser.value_linear_units();
-      if (r) {
-        const xy_pos_t p1 = current_position, p2 = destination;
-        if (p1 != p2) {
-          const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current
-          const float e = clockwise ^ (r < 0) ? -1 : 1,  // clockwise -1/1, counterclockwise 1/-1
-                      len = d2.magnitude(),              // Distance to mid-point of move from current
-                      h2 = (r - len) * (r + len),        // factored to reduce rounding error
-                      h = (h2 >= 0) ? SQRT(h2) : 0.0f;   // Distance to the arc pivot-point from midpoint
-          const xy_pos_t s = { -d2.y, d2.x };            // Perpendicular bisector. (Divide by len for unit vector.)
-          arc_offset = d2 + s / len * e * h;             // The calculated offset (mid-point if |r| <= len)
-        }
+  get_destination_from_command();   // Get X Y [Z[I[J[K...]]]] [E] F (and set cutter power)
+
+  TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
+
+  ab_float_t arc_offset = { 0, 0 };
+  if (parser.seenval('R')) {
+    const float r = parser.value_linear_units();
+    if (r) {
+      const xy_pos_t p1 = current_position, p2 = destination;
+      if (p1 != p2) {
+        const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current
+        const float e = clockwise ^ (r < 0) ? -1 : 1,  // clockwise -1/1, counterclockwise 1/-1
+                    len = d2.magnitude(),              // Distance to mid-point of move from current
+                    h2 = (r - len) * (r + len),        // factored to reduce rounding error
+                    h = (h2 >= 0) ? SQRT(h2) : 0.0f;   // Distance to the arc pivot-point from midpoint
+        const xy_pos_t s = { -d2.y, d2.x };            // Perpendicular bisector. (Divide by len for unit vector.)
+        arc_offset = d2 + s / len * e * h;             // The calculated offset (mid-point if |r| <= len)
       }
     }
-    else {
-      #if ENABLED(CNC_WORKSPACE_PLANES)
-        char achar, bchar;
-        switch (workspace_plane) {
-          default:
-          case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
-          case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;
-          case GcodeSuite::PLANE_ZX: achar = 'K'; bchar = 'I'; break;
-        }
-      #else
-        constexpr char achar = 'I', bchar = 'J';
-      #endif
-      if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
-      if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();
-    }
-
-    if (arc_offset) {
+  }
+  else {
+    #if ENABLED(CNC_WORKSPACE_PLANES)
+      char achar, bchar;
+      switch (workspace_plane) {
+        default:
+        case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
+        case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;
+        case GcodeSuite::PLANE_ZX: achar = 'K'; bchar = 'I'; break;
+      }
+    #else
+      constexpr char achar = 'I', bchar = 'J';
+    #endif
+    if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
+    if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();
+  }
 
-      #if ENABLED(ARC_P_CIRCLES)
-        // P indicates number of circles to do
-        const int8_t circles_to_do = parser.byteval('P');
-        if (!WITHIN(circles_to_do, 0, 100))
-          SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
-      #else
-        constexpr uint8_t circles_to_do = 0;
-      #endif
+  if (arc_offset) {
 
-      // Send the arc to the planner
-      plan_arc(destination, arc_offset, clockwise, circles_to_do);
-      reset_stepper_timeout();
-    }
-    else
-      SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
+    #if ENABLED(ARC_P_CIRCLES)
+      // P indicates number of circles to do
+      const int8_t circles_to_do = parser.byteval('P');
+      if (!WITHIN(circles_to_do, 0, 100))
+        SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
+    #else
+      constexpr uint8_t circles_to_do = 0;
+    #endif
 
-    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
+    // Send the arc to the planner
+    plan_arc(destination, arc_offset, clockwise, circles_to_do);
+    reset_stepper_timeout();
   }
+  else
+    SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
+
+  TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
 }
 
 #endif // ARC_SUPPORT

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 1a0a9c8ccc..2634117cd9 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -211,21 +211,21 @@ void plan_arc(
               nominal_segment_mm = flat_mm / nominal_segments;
 
   // The number of whole segments in the arc, with best attempt to honor MIN_ARC_SEGMENT_MM and MAX_ARC_SEGMENT_MM
   const uint16_t segments = nominal_segment_mm > (MAX_ARC_SEGMENT_MM) ? CEIL(flat_mm / (MAX_ARC_SEGMENT_MM)) :
                             nominal_segment_mm < (MIN_ARC_SEGMENT_MM) ? _MAX(1, FLOOR(flat_mm / (MIN_ARC_SEGMENT_MM))) :
                             nominal_segments;
   const float segment_mm = flat_mm / segments;
 
   // Add hints to help optimize the move
   PlannerHints hints;
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
+  #if ENABLED(FEEDRATE_SCALING)
     hints.inv_duration = (scaled_fr_mm_s / flat_mm) * segments;
   #endif
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is

commit 3b4a5a1ae86da5e790f1551ea801dfcd61acff50
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Jul 18 06:51:44 2022 +0100

    ü©π Arc/Planner optimization followup (#24509)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index c45204c6f6..1a0a9c8ccc 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -287,25 +287,26 @@ void plan_arc(
 
     millis_t next_idle_ms = millis() + 200UL;
 
     #if N_ARC_CORRECTION > 1
       int8_t arc_recalc_count = N_ARC_CORRECTION;
     #endif
 
     // An arc can always complete within limits from a speed which...
     // a) is <= any configured maximum speed,
     // b) does not require centripetal force greater than any configured maximum acceleration,
-    // c) allows the print head to stop in the remining length of the curve within all configured maximum accelerations.
+    // c) is <= nominal speed,
+    // d) allows the print head to stop in the remining length of the curve within all configured maximum accelerations.
     // The last has to be calculated every time through the loop.
     const float limiting_accel = _MIN(planner.settings.max_acceleration_mm_per_s2[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
                 limiting_speed = _MIN(planner.settings.max_feedrate_mm_s[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
-                limiting_speed_sqr = _MIN(sq(limiting_speed), limiting_accel * radius);
+                limiting_speed_sqr = _MIN(sq(limiting_speed), limiting_accel * radius, sq(scaled_fr_mm_s));
     float arc_mm_remaining = flat_mm;
 
     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
       thermalManager.task();
       const millis_t ms = millis();
       if (ELAPSED(ms, next_idle_ms)) {
         next_idle_ms = ms + 200UL;
         idle();
       }
@@ -350,46 +351,47 @@ void plan_arc(
       );
 
       apply_motion_limits(raw);
 
       #if HAS_LEVELING && !PLANNER_LEVELING
         planner.apply_leveling(raw);
       #endif
 
       // calculate safe speed for stopping by the end of the arc
       arc_mm_remaining -= segment_mm;
-
-      hints.curve_radius = i > 1 ? radius : 0;
       hints.safe_exit_speed_sqr = _MIN(limiting_speed_sqr, 2 * limiting_accel * arc_mm_remaining);
 
       if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints))
         break;
+
+      hints.curve_radius = radius;
     }
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     ARC_LIJKUVW_CODE(
       raw[axis_l] = start_L,
       raw.i = start_I, raw.j = start_J, raw.k = start_K,
       raw.u = start_U, raw.v = start_V, raw.w = start_W
     );
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   hints.curve_radius = 0;
+  hints.safe_exit_speed_sqr = 0.0f;
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints);
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     ARC_LIJKUVW_CODE(
       raw[axis_l] = start_L,
       raw.i = start_I, raw.j = start_J, raw.k = start_K,
       raw.u = start_U, raw.v = start_V, raw.w = start_W
     );
   #endif
   current_position = raw;

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 14ef9ac2a6..c45204c6f6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -207,23 +207,26 @@ void plan_arc(
   );
 
   // Number of whole segments based on the ideal segment length
   const float nominal_segments = _MAX(FLOOR(flat_mm / ideal_segment_mm), min_segments),
               nominal_segment_mm = flat_mm / nominal_segments;
 
   // The number of whole segments in the arc, with best attempt to honor MIN_ARC_SEGMENT_MM and MAX_ARC_SEGMENT_MM
   const uint16_t segments = nominal_segment_mm > (MAX_ARC_SEGMENT_MM) ? CEIL(flat_mm / (MAX_ARC_SEGMENT_MM)) :
                             nominal_segment_mm < (MIN_ARC_SEGMENT_MM) ? _MAX(1, FLOOR(flat_mm / (MIN_ARC_SEGMENT_MM))) :
                             nominal_segments;
+  const float segment_mm = flat_mm / segments;
 
+  // Add hints to help optimize the move
+  PlannerHints hints;
   #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float inv_duration = (scaled_fr_mm_s / flat_mm) * segments;
+    hints.inv_duration = (scaled_fr_mm_s / flat_mm) * segments;
   #endif
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
@@ -281,20 +284,30 @@ void plan_arc(
       raw.w       = current_position.w,
       raw.e       = current_position.e
     );
 
     millis_t next_idle_ms = millis() + 200UL;
 
     #if N_ARC_CORRECTION > 1
       int8_t arc_recalc_count = N_ARC_CORRECTION;
     #endif
 
+    // An arc can always complete within limits from a speed which...
+    // a) is <= any configured maximum speed,
+    // b) does not require centripetal force greater than any configured maximum acceleration,
+    // c) allows the print head to stop in the remining length of the curve within all configured maximum accelerations.
+    // The last has to be calculated every time through the loop.
+    const float limiting_accel = _MIN(planner.settings.max_acceleration_mm_per_s2[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
+                limiting_speed = _MIN(planner.settings.max_feedrate_mm_s[axis_p], planner.settings.max_acceleration_mm_per_s2[axis_q]),
+                limiting_speed_sqr = _MIN(sq(limiting_speed), limiting_accel * radius);
+    float arc_mm_remaining = flat_mm;
+
     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
       thermalManager.task();
       const millis_t ms = millis();
       if (ELAPSED(ms, next_idle_ms)) {
         next_idle_ms = ms + 200UL;
         idle();
       }
 
       #if N_ARC_CORRECTION > 1
@@ -335,42 +348,49 @@ void plan_arc(
         #endif
         , raw.e += extruder_per_segment
       );
 
       apply_motion_limits(raw);
 
       #if HAS_LEVELING && !PLANNER_LEVELING
         planner.apply_leveling(raw);
       #endif
 
-      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)))
+      // calculate safe speed for stopping by the end of the arc
+      arc_mm_remaining -= segment_mm;
+
+      hints.curve_radius = i > 1 ? radius : 0;
+      hints.safe_exit_speed_sqr = _MIN(limiting_speed_sqr, 2 * limiting_accel * arc_mm_remaining);
+
+      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints))
         break;
     }
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     ARC_LIJKUVW_CODE(
       raw[axis_l] = start_L,
       raw.i = start_I, raw.j = start_J, raw.k = start_K,
       raw.u = start_U, raw.v = start_V, raw.w = start_W
     );
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
-  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
+  hints.curve_radius = 0;
+  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints);
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     ARC_LIJKUVW_CODE(
       raw[axis_l] = start_L,
       raw.i = start_I, raw.j = start_J, raw.k = start_K,
       raw.u = start_U, raw.v = start_V, raw.w = start_W
     );
   #endif
   current_position = raw;
 

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index d9458f61eb..14ef9ac2a6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -283,21 +283,21 @@ void plan_arc(
     );
 
     millis_t next_idle_ms = millis() + 200UL;
 
     #if N_ARC_CORRECTION > 1
       int8_t arc_recalc_count = N_ARC_CORRECTION;
     #endif
 
     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
-      thermalManager.manage_heater();
+      thermalManager.task();
       const millis_t ms = millis();
       if (ELAPSED(ms, next_idle_ms)) {
         next_idle_ms = ms + 200UL;
         idle();
       }
 
       #if N_ARC_CORRECTION > 1
         if (--arc_recalc_count) {
           // Apply vector rotation matrix to previous rvec.a / 1
           const float r_new_Y = rvec.a * sin_T + rvec.b * cos_T;

commit 307dfb15ca88f424dcb4cf579e4542e77dfb0eaf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:24:59 2022 -0500

    ‚ôªÔ∏è Planner flags refactor

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index cd8225de69..d9458f61eb 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -308,21 +308,21 @@ void plan_arc(
       #endif
       {
         #if N_ARC_CORRECTION > 1
           arc_recalc_count = N_ARC_CORRECTION;
         #endif
 
         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
         // To reduce stuttering, the sin and cos could be computed at different times.
         // For now, compute both at the same time.
-        const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
+        const float Ti = i * theta_per_segment, cos_Ti = cos(Ti), sin_Ti = sin(Ti);
         rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
         rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
       }
 
       // Update raw location
       raw[axis_p] = center_P + rvec.a;
       raw[axis_q] = center_Q + rvec.b;
       ARC_LIJKUVWE_CODE(
         #if ENABLED(AUTO_BED_LEVELING_UBL)
           raw[axis_l] = start_L,

commit 1a6a6043102dd27a6107a62993638b4d2b02a4e5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Jun 18 05:17:12 2022 +0100

    üêõ Fix G2/G3 Arcs stutter / JD speed (#24362)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index dd1c1d1470..cd8225de69 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -190,42 +190,41 @@ void plan_arc(
       && travel_K < 0.0001f,
       && travel_U < 0.0001f,
       && travel_V < 0.0001f,
       && travel_W < 0.0001f
     )
   ) return;
 
   // Feedrate for the move, scaled by the feedrate multiplier
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-  // Get the nominal segment length based on settings
-  const float nominal_segment_mm = (
+  // Get the ideal segment length for the move based on settings
+  const float ideal_segment_mm = (
     #if ARC_SEGMENTS_PER_SEC  // Length based on segments per second and feedrate
       constrain(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM)
     #else
       MAX_ARC_SEGMENT_MM      // Length using the maximum segment size
     #endif
   );
 
-  // Number of whole segments based on the nominal segment length
-  const float nominal_segments = _MAX(FLOOR(flat_mm / nominal_segment_mm), min_segments);
+  // Number of whole segments based on the ideal segment length
+  const float nominal_segments = _MAX(FLOOR(flat_mm / ideal_segment_mm), min_segments),
+              nominal_segment_mm = flat_mm / nominal_segments;
 
-  // A new segment length based on the required minimum
-  const float segment_mm = constrain(flat_mm / nominal_segments, MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM);
+  // The number of whole segments in the arc, with best attempt to honor MIN_ARC_SEGMENT_MM and MAX_ARC_SEGMENT_MM
+  const uint16_t segments = nominal_segment_mm > (MAX_ARC_SEGMENT_MM) ? CEIL(flat_mm / (MAX_ARC_SEGMENT_MM)) :
+                            nominal_segment_mm < (MIN_ARC_SEGMENT_MM) ? _MAX(1, FLOOR(flat_mm / (MIN_ARC_SEGMENT_MM))) :
+                            nominal_segments;
 
-  // The number of whole segments in the arc, ignoring the remainder
-  uint16_t segments = FLOOR(flat_mm / segment_mm);
-
-  // Are the segments now too few to reach the destination?
-  const float segmented_length = segment_mm * segments;
-  const bool tooshort = segmented_length < flat_mm - 0.0001f;
-  const float proportion = tooshort ? segmented_length / flat_mm : 1.0f;
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    const float inv_duration = (scaled_fr_mm_s / flat_mm) * segments;
+  #endif
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation
@@ -239,122 +238,120 @@ void plan_arc(
    * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
    * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
    * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
-  // Vector rotation matrix values
-  xyze_pos_t raw;
-  const float theta_per_segment = proportion * angular_travel / segments,
-              sq_theta_per_segment = sq(theta_per_segment),
-              sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
-              cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
-
-  #if DISABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJKUVW_CODE(
-      const float per_segment_L = proportion * travel_L / segments,
-      const float per_segment_I = proportion * travel_I / segments,
-      const float per_segment_J = proportion * travel_J / segments,
-      const float per_segment_K = proportion * travel_K / segments,
-      const float per_segment_U = proportion * travel_U / segments,
-      const float per_segment_V = proportion * travel_V / segments,
-      const float per_segment_W = proportion * travel_W / segments
-    );
-  #endif
 
-  CODE_ITEM_E(const float extruder_per_segment = proportion * travel_E / segments);
-
-  // For shortened segments, run all but the remainder in the loop
-  if (tooshort) segments++;
+  xyze_pos_t raw;
 
-  // Initialize all linear axes and E
-  ARC_LIJKUVWE_CODE(
-    raw[axis_l] = current_position[axis_l],
-    raw.i       = current_position.i,
-    raw.j       = current_position.j,
-    raw.k       = current_position.k,
-    raw.u       = current_position.u,
-    raw.v       = current_position.v,
-    raw.w       = current_position.w,
-    raw.e       = current_position.e
-  );
+  // do not calculate rotation parameters for trivial single-segment arcs
+  if (segments > 1) {
+    // Vector rotation matrix values
+    const float theta_per_segment = angular_travel / segments,
+                sq_theta_per_segment = sq(theta_per_segment),
+                sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
+                cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
+
+    #if DISABLED(AUTO_BED_LEVELING_UBL)
+      ARC_LIJKUVW_CODE(
+        const float per_segment_L = travel_L / segments,
+        const float per_segment_I = travel_I / segments,
+        const float per_segment_J = travel_J / segments,
+        const float per_segment_K = travel_K / segments,
+        const float per_segment_U = travel_U / segments,
+        const float per_segment_V = travel_V / segments,
+        const float per_segment_W = travel_W / segments
+      );
+    #endif
 
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float inv_duration = scaled_fr_mm_s / segment_mm;
-  #endif
+    CODE_ITEM_E(const float extruder_per_segment = travel_E / segments);
 
-  millis_t next_idle_ms = millis() + 200UL;
+    // Initialize all linear axes and E
+    ARC_LIJKUVWE_CODE(
+      raw[axis_l] = current_position[axis_l],
+      raw.i       = current_position.i,
+      raw.j       = current_position.j,
+      raw.k       = current_position.k,
+      raw.u       = current_position.u,
+      raw.v       = current_position.v,
+      raw.w       = current_position.w,
+      raw.e       = current_position.e
+    );
 
-  #if N_ARC_CORRECTION > 1
-    int8_t arc_recalc_count = N_ARC_CORRECTION;
-  #endif
+    millis_t next_idle_ms = millis() + 200UL;
 
-  for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
+    #if N_ARC_CORRECTION > 1
+      int8_t arc_recalc_count = N_ARC_CORRECTION;
+    #endif
 
-    thermalManager.manage_heater();
-    const millis_t ms = millis();
-    if (ELAPSED(ms, next_idle_ms)) {
-      next_idle_ms = ms + 200UL;
-      idle();
-    }
+    for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
-    #if N_ARC_CORRECTION > 1
-      if (--arc_recalc_count) {
-        // Apply vector rotation matrix to previous rvec.a / 1
-        const float r_new_Y = rvec.a * sin_T + rvec.b * cos_T;
-        rvec.a = rvec.a * cos_T - rvec.b * sin_T;
-        rvec.b = r_new_Y;
+      thermalManager.manage_heater();
+      const millis_t ms = millis();
+      if (ELAPSED(ms, next_idle_ms)) {
+        next_idle_ms = ms + 200UL;
+        idle();
       }
-      else
-    #endif
-    {
+
       #if N_ARC_CORRECTION > 1
-        arc_recalc_count = N_ARC_CORRECTION;
+        if (--arc_recalc_count) {
+          // Apply vector rotation matrix to previous rvec.a / 1
+          const float r_new_Y = rvec.a * sin_T + rvec.b * cos_T;
+          rvec.a = rvec.a * cos_T - rvec.b * sin_T;
+          rvec.b = r_new_Y;
+        }
+        else
       #endif
+      {
+        #if N_ARC_CORRECTION > 1
+          arc_recalc_count = N_ARC_CORRECTION;
+        #endif
+
+        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
+        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
+        // To reduce stuttering, the sin and cos could be computed at different times.
+        // For now, compute both at the same time.
+        const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
+        rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
+        rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
+      }
 
-      // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
-      // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
-      // To reduce stuttering, the sin and cos could be computed at different times.
-      // For now, compute both at the same time.
-      const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
-      rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
-      rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
-    }
-
-    // Update raw location
-    raw[axis_p] = center_P + rvec.a;
-    raw[axis_q] = center_Q + rvec.b;
-    ARC_LIJKUVWE_CODE(
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        raw[axis_l] = start_L,
-        raw.i = start_I, raw.j = start_J, raw.k = start_K,
-        raw.u = start_U, raw.v = start_V, raw.w = start_V
-      #else
-        raw[axis_l] += per_segment_L,
-        raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K,
-        raw.u += per_segment_U, raw.v += per_segment_V, raw.w += per_segment_W
-      #endif
-      , raw.e += extruder_per_segment
-    );
+      // Update raw location
+      raw[axis_p] = center_P + rvec.a;
+      raw[axis_q] = center_Q + rvec.b;
+      ARC_LIJKUVWE_CODE(
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          raw[axis_l] = start_L,
+          raw.i = start_I, raw.j = start_J, raw.k = start_K,
+          raw.u = start_U, raw.v = start_V, raw.w = start_V
+        #else
+          raw[axis_l] += per_segment_L,
+          raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K,
+          raw.u += per_segment_U, raw.v += per_segment_V, raw.w += per_segment_W
+        #endif
+        , raw.e += extruder_per_segment
+      );
 
-    apply_motion_limits(raw);
+      apply_motion_limits(raw);
 
-    #if HAS_LEVELING && !PLANNER_LEVELING
-      planner.apply_leveling(raw);
-    #endif
+      #if HAS_LEVELING && !PLANNER_LEVELING
+        planner.apply_leveling(raw);
+      #endif
 
-    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)))
-      break;
+      if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)))
+        break;
+    }
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     ARC_LIJKUVW_CODE(
       raw[axis_l] = start_L,
       raw.i = start_I, raw.j = start_J, raw.k = start_K,
       raw.u = start_U, raw.v = start_V, raw.w = start_W
     );

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 0c7bdc7a3a..dd1c1d1470 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -41,22 +41,22 @@
 #endif
 #ifndef MIN_CIRCLE_SEGMENTS
   #define MIN_CIRCLE_SEGMENTS 72  // 5¬∞ per segment
 #endif
 #if !defined(MAX_ARC_SEGMENT_MM) && defined(MIN_ARC_SEGMENT_MM)
   #define MAX_ARC_SEGMENT_MM MIN_ARC_SEGMENT_MM
 #elif !defined(MIN_ARC_SEGMENT_MM) && defined(MAX_ARC_SEGMENT_MM)
   #define MIN_ARC_SEGMENT_MM MAX_ARC_SEGMENT_MM
 #endif
 
-#define ARC_LIJK_CODE(L,I,J,K)    CODE_N(SUB2(LINEAR_AXES),L,I,J,K)
-#define ARC_LIJKE_CODE(L,I,J,K,E) ARC_LIJK_CODE(L,I,J,K); CODE_ITEM_E(E)
+#define ARC_LIJKUVW_CODE(L,I,J,K,U,V,W)    CODE_N(SUB2(NUM_AXES),L,I,J,K,U,V,W)
+#define ARC_LIJKUVWE_CODE(L,I,J,K,U,V,W,E) ARC_LIJKUVW_CODE(L,I,J,K,U,V,W); CODE_ITEM_E(E)
 
 /**
  * Plan an arc in 2 dimensions, with linear motion in the other axes.
  * The arc is traced with many small linear segments according to the configuration.
  */
 void plan_arc(
   const xyze_pos_t &cart,   // Destination position
   const ab_float_t &offset, // Center of rotation relative to current_position
   const bool clockwise,     // Clockwise?
   const uint8_t circles     // Take the scenic route
@@ -75,25 +75,28 @@ void plan_arc(
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[axis_p] - rvec.a,
               center_Q = current_position[axis_q] - rvec.b,
               rt_X = cart[axis_p] - center_P,
               rt_Y = cart[axis_q] - center_Q;
 
-  ARC_LIJK_CODE(
+  ARC_LIJKUVW_CODE(
     const float start_L = current_position[axis_l],
     const float start_I = current_position.i,
     const float start_J = current_position.j,
-    const float start_K = current_position.k
+    const float start_K = current_position.k,
+    const float start_U = current_position.u,
+    const float start_V = current_position.v,
+    const float start_W = current_position.w
   );
 
   // Angle of rotation between position and target from the circle center.
   float angular_travel, abs_angular_travel;
 
   // Minimum number of segments in an arc move
   uint16_t min_segments = 1;
 
   // Do a full circle if starting and ending positions are "identical"
   if (NEAR(current_position[axis_p], cart[axis_p]) && NEAR(current_position[axis_q], cart[axis_q])) {
@@ -115,71 +118,86 @@ void plan_arc(
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
     abs_angular_travel = ABS(angular_travel);
 
     // Apply minimum segments to the arc
     const float portion_of_circle = abs_angular_travel / RADIANS(360);  // Portion of a complete circle (0 < N < 1)
     min_segments = CEIL((MIN_CIRCLE_SEGMENTS) * portion_of_circle);     // Minimum segments for the arc
   }
 
-  ARC_LIJKE_CODE(
+  ARC_LIJKUVWE_CODE(
     float travel_L = cart[axis_l] - start_L,
     float travel_I = cart.i       - start_I,
     float travel_J = cart.j       - start_J,
     float travel_K = cart.k       - start_K,
+    float travel_U = cart.u       - start_U,
+    float travel_V = cart.v       - start_V,
+    float travel_W = cart.w       - start_W,
     float travel_E = cart.e       - current_position.e
   );
 
   // If "P" specified circles, call plan_arc recursively then continue with the rest of the arc
   if (TERN0(ARC_P_CIRCLES, circles)) {
     const float total_angular = abs_angular_travel + circles * RADIANS(360),    // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular;                   // Each circle's part of the total
 
-    ARC_LIJKE_CODE(
+    ARC_LIJKUVWE_CODE(
       const float per_circle_L = travel_L * part_per_circle,    // L movement per circle
       const float per_circle_I = travel_I * part_per_circle,
       const float per_circle_J = travel_J * part_per_circle,
       const float per_circle_K = travel_K * part_per_circle,
+      const float per_circle_U = travel_U * part_per_circle,
+      const float per_circle_V = travel_V * part_per_circle,
+      const float per_circle_W = travel_W * part_per_circle,
       const float per_circle_E = travel_E * part_per_circle     // E movement per circle
     );
 
     xyze_pos_t temp_position = current_position;
     for (uint16_t n = circles; n--;) {
-      ARC_LIJKE_CODE(                                           // Destination Linear Axes
+      ARC_LIJKUVWE_CODE(                                           // Destination Linear Axes
         temp_position[axis_l] += per_circle_L,
         temp_position.i       += per_circle_I,
         temp_position.j       += per_circle_J,
         temp_position.k       += per_circle_K,
+        temp_position.u       += per_circle_U,
+        temp_position.v       += per_circle_V,
+        temp_position.w       += per_circle_W,
         temp_position.e       += per_circle_E                   // Destination E axis
       );
       plan_arc(temp_position, offset, clockwise, 0);            // Plan a single whole circle
     }
-    ARC_LIJKE_CODE(
+    ARC_LIJKUVWE_CODE(
       travel_L = cart[axis_l] - current_position[axis_l],
       travel_I = cart.i       - current_position.i,
       travel_J = cart.j       - current_position.j,
       travel_K = cart.k       - current_position.k,
+      travel_U = cart.u       - current_position.u,
+      travel_V = cart.v       - current_position.v,
+      travel_W = cart.w       - current_position.w,
       travel_E = cart.e       - current_position.e
     );
   }
 
   // Millimeters in the arc, assuming it's flat
   const float flat_mm = radius * abs_angular_travel;
 
   // Return if the move is near zero
   if (flat_mm < 0.0001f
-    GANG_N(SUB2(LINEAR_AXES),
+    GANG_N(SUB2(NUM_AXES),
       && travel_L < 0.0001f,
       && travel_I < 0.0001f,
       && travel_J < 0.0001f,
-      && travel_K < 0.0001f
+      && travel_K < 0.0001f,
+      && travel_U < 0.0001f,
+      && travel_V < 0.0001f,
+      && travel_W < 0.0001f
     )
   ) return;
 
   // Feedrate for the move, scaled by the feedrate multiplier
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Get the nominal segment length based on settings
   const float nominal_segment_mm = (
     #if ARC_SEGMENTS_PER_SEC  // Length based on segments per second and feedrate
       constrain(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM)
@@ -229,39 +247,45 @@ void plan_arc(
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
   const float theta_per_segment = proportion * angular_travel / segments,
               sq_theta_per_segment = sq(theta_per_segment),
               sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
               cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
   #if DISABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJK_CODE(
+    ARC_LIJKUVW_CODE(
       const float per_segment_L = proportion * travel_L / segments,
       const float per_segment_I = proportion * travel_I / segments,
       const float per_segment_J = proportion * travel_J / segments,
-      const float per_segment_K = proportion * travel_K / segments
+      const float per_segment_K = proportion * travel_K / segments,
+      const float per_segment_U = proportion * travel_U / segments,
+      const float per_segment_V = proportion * travel_V / segments,
+      const float per_segment_W = proportion * travel_W / segments
     );
   #endif
 
   CODE_ITEM_E(const float extruder_per_segment = proportion * travel_E / segments);
 
   // For shortened segments, run all but the remainder in the loop
   if (tooshort) segments++;
 
   // Initialize all linear axes and E
-  ARC_LIJKE_CODE(
+  ARC_LIJKUVWE_CODE(
     raw[axis_l] = current_position[axis_l],
     raw.i       = current_position.i,
     raw.j       = current_position.j,
     raw.k       = current_position.k,
+    raw.u       = current_position.u,
+    raw.v       = current_position.v,
+    raw.w       = current_position.w,
     raw.e       = current_position.e
   );
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / segment_mm;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
@@ -296,55 +320,67 @@ void plan_arc(
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
     raw[axis_p] = center_P + rvec.a;
     raw[axis_q] = center_Q + rvec.b;
-    ARC_LIJKE_CODE(
+    ARC_LIJKUVWE_CODE(
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K
+        raw[axis_l] = start_L,
+        raw.i = start_I, raw.j = start_J, raw.k = start_K,
+        raw.u = start_U, raw.v = start_V, raw.w = start_V
       #else
-        raw[axis_l] += per_segment_L, raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K
+        raw[axis_l] += per_segment_L,
+        raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K,
+        raw.u += per_segment_U, raw.v += per_segment_V, raw.w += per_segment_W
       #endif
       , raw.e += extruder_per_segment
     );
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)))
       break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJK_CODE(raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K);
+    ARC_LIJKUVW_CODE(
+      raw[axis_l] = start_L,
+      raw.i = start_I, raw.j = start_J, raw.k = start_K,
+      raw.u = start_U, raw.v = start_V, raw.w = start_W
+    );
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
-    ARC_LIJK_CODE(raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K);
+    ARC_LIJKUVW_CODE(
+      raw[axis_l] = start_L,
+      raw.i = start_I, raw.j = start_J, raw.k = start_K,
+      raw.u = start_U, raw.v = start_V, raw.w = start_W
+    );
   #endif
   current_position = raw;
 
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form (JK, KI) and R-form.
@@ -373,21 +409,21 @@ void plan_arc(
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));
 
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
-    get_destination_from_command();   // Get X Y [Z[I[J[K]]]] [E] F (and set cutter power)
+    get_destination_from_command();   // Get X Y [Z[I[J[K...]]]] [E] F (and set cutter power)
 
     TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
           const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    üé® Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 33167d9dff..0c7bdc7a3a 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -396,21 +396,21 @@ void GcodeSuite::G2_G3(const bool clockwise) {
                       h2 = (r - len) * (r + len),        // factored to reduce rounding error
                       h = (h2 >= 0) ? SQRT(h2) : 0.0f;   // Distance to the arc pivot-point from midpoint
           const xy_pos_t s = { -d2.y, d2.x };            // Perpendicular bisector. (Divide by len for unit vector.)
           arc_offset = d2 + s / len * e * h;             // The calculated offset (mid-point if |r| <= len)
         }
       }
     }
     else {
       #if ENABLED(CNC_WORKSPACE_PLANES)
         char achar, bchar;
-        switch (gcode.workspace_plane) {
+        switch (workspace_plane) {
           default:
           case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
           case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;
           case GcodeSuite::PLANE_ZX: achar = 'K'; bchar = 'I'; break;
         }
       #else
         constexpr char achar = 'I', bchar = 'J';
       #endif
       if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
       if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();

commit efb9ea92b85ec469e9436969129bcee33aadd3bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 30 17:02:12 2021 -0500

    üî® Fix HAL/STM32 F103Zx builds (#22610)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index f9f9c2b3da..33167d9dff 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -210,21 +210,21 @@ void plan_arc(
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation
    * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
    * all double numbers are single precision on the Arduino. (True double precision will not have
    * round off issues for CNC applications.) Single precision error can accumulate to be greater than
    * tool precision in some cases. Therefore, arc path correction is implemented.
    *
    * Small angle approximation may be used to reduce computation overhead further. This approximation
-   * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
+   * holds for everything, but very small circles and large MAX_ARC_SEGMENT_MM values. In other words,
    * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
    * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
    * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */

commit 4b4de71304a426e0d9b2696dae4e82eb55ba7079
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 29 13:57:47 2021 -0500

    ‚ö°Ô∏è Improve G2/G3 arc handling (#22599)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 094afdb70e..f9f9c2b3da 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -32,142 +32,182 @@
 #if ENABLED(DELTA)
   #include "../../module/delta.h"
 #elif ENABLED(SCARA)
   #include "../../module/scara.h"
 #endif
 
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
+#ifndef MIN_CIRCLE_SEGMENTS
+  #define MIN_CIRCLE_SEGMENTS 72  // 5¬∞ per segment
+#endif
+#if !defined(MAX_ARC_SEGMENT_MM) && defined(MIN_ARC_SEGMENT_MM)
+  #define MAX_ARC_SEGMENT_MM MIN_ARC_SEGMENT_MM
+#elif !defined(MIN_ARC_SEGMENT_MM) && defined(MAX_ARC_SEGMENT_MM)
+  #define MIN_ARC_SEGMENT_MM MAX_ARC_SEGMENT_MM
+#endif
+
+#define ARC_LIJK_CODE(L,I,J,K)    CODE_N(SUB2(LINEAR_AXES),L,I,J,K)
+#define ARC_LIJKE_CODE(L,I,J,K,E) ARC_LIJK_CODE(L,I,J,K); CODE_ITEM_E(E)
 
 /**
- * Plan an arc in 2 dimensions, with optional linear motion in a 3rd dimension
- *
- * The arc is traced by generating many small linear segments, as configured by
- * MM_PER_ARC_SEGMENT (Default 1mm). In the future we hope more slicers will include
- * an option to generate G2/G3 arcs for curved surfaces, as this will allow faster
- * boards to produce much smoother curved surfaces.
+ * Plan an arc in 2 dimensions, with linear motion in the other axes.
+ * The arc is traced with many small linear segments according to the configuration.
  */
 void plan_arc(
   const xyze_pos_t &cart,   // Destination position
   const ab_float_t &offset, // Center of rotation relative to current_position
   const bool clockwise,     // Clockwise?
   const uint8_t circles     // Take the scenic route
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
-    AxisEnum p_axis, q_axis, l_axis;
+    AxisEnum axis_p, axis_q, axis_l;
     switch (gcode.workspace_plane) {
       default:
-      case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
-      case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
-      case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
+      case GcodeSuite::PLANE_XY: axis_p = X_AXIS; axis_q = Y_AXIS; axis_l = Z_AXIS; break;
+      case GcodeSuite::PLANE_YZ: axis_p = Y_AXIS; axis_q = Z_AXIS; axis_l = X_AXIS; break;
+      case GcodeSuite::PLANE_ZX: axis_p = Z_AXIS; axis_q = X_AXIS; axis_l = Y_AXIS; break;
     }
   #else
-    constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS OPTARG(HAS_Z_AXIS, l_axis = Z_AXIS);
+    constexpr AxisEnum axis_p = X_AXIS, axis_q = Y_AXIS OPTARG(HAS_Z_AXIS, axis_l = Z_AXIS);
   #endif
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
-              center_P = current_position[p_axis] - rvec.a,
-              center_Q = current_position[q_axis] - rvec.b,
-              rt_X = cart[p_axis] - center_P,
-              rt_Y = cart[q_axis] - center_Q
-              OPTARG(HAS_Z_AXIS, start_L = current_position[l_axis]);
-
-  #ifdef MIN_ARC_SEGMENTS
-    uint16_t min_segments = MIN_ARC_SEGMENTS;
-  #else
-    constexpr uint16_t min_segments = 1;
-  #endif
+              center_P = current_position[axis_p] - rvec.a,
+              center_Q = current_position[axis_q] - rvec.b,
+              rt_X = cart[axis_p] - center_P,
+              rt_Y = cart[axis_q] - center_Q;
+
+  ARC_LIJK_CODE(
+    const float start_L = current_position[axis_l],
+    const float start_I = current_position.i,
+    const float start_J = current_position.j,
+    const float start_K = current_position.k
+  );
 
   // Angle of rotation between position and target from the circle center.
   float angular_travel, abs_angular_travel;
 
+  // Minimum number of segments in an arc move
+  uint16_t min_segments = 1;
+
   // Do a full circle if starting and ending positions are "identical"
-  if (NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
+  if (NEAR(current_position[axis_p], cart[axis_p]) && NEAR(current_position[axis_q], cart[axis_q])) {
     // Preserve direction for circles
     angular_travel = clockwise ? -RADIANS(360) : RADIANS(360);
     abs_angular_travel = RADIANS(360);
+    min_segments = MIN_CIRCLE_SEGMENTS;
   }
   else {
     // Calculate the angle
     angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
 
     // Angular travel too small to detect? Just return.
     if (!angular_travel) return;
 
     // Make sure angular travel over 180 degrees goes the other way around.
     switch (((angular_travel < 0) << 1) | clockwise) {
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
     abs_angular_travel = ABS(angular_travel);
 
-    #ifdef MIN_ARC_SEGMENTS
-      min_segments = CEIL(min_segments * abs_angular_travel / RADIANS(360));
-      NOLESS(min_segments, 1U);
-    #endif
+    // Apply minimum segments to the arc
+    const float portion_of_circle = abs_angular_travel / RADIANS(360);  // Portion of a complete circle (0 < N < 1)
+    min_segments = CEIL((MIN_CIRCLE_SEGMENTS) * portion_of_circle);     // Minimum segments for the arc
   }
 
-  #if HAS_Z_AXIS
-    float linear_travel = cart[l_axis] - start_L;
-  #endif
-  #if HAS_EXTRUDERS
-    float extruder_travel = cart.e - current_position.e;
-  #endif
+  ARC_LIJKE_CODE(
+    float travel_L = cart[axis_l] - start_L,
+    float travel_I = cart.i       - start_I,
+    float travel_J = cart.j       - start_J,
+    float travel_K = cart.k       - start_K,
+    float travel_E = cart.e       - current_position.e
+  );
 
-  // If circling around...
+  // If "P" specified circles, call plan_arc recursively then continue with the rest of the arc
   if (TERN0(ARC_P_CIRCLES, circles)) {
-    const float total_angular = abs_angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
-              part_per_circle = RADIANS(360) / total_angular;             // Each circle's part of the total
-
-    #if HAS_Z_AXIS
-      const float l_per_circle = linear_travel * part_per_circle;         // L movement per circle
-    #endif
-    #if HAS_EXTRUDERS
-      const float e_per_circle = extruder_travel * part_per_circle;       // E movement per circle
-    #endif
-
-    xyze_pos_t temp_position = current_position;                          // for plan_arc to compare to current_position
+    const float total_angular = abs_angular_travel + circles * RADIANS(360),    // Total rotation with all circles and remainder
+              part_per_circle = RADIANS(360) / total_angular;                   // Each circle's part of the total
+
+    ARC_LIJKE_CODE(
+      const float per_circle_L = travel_L * part_per_circle,    // L movement per circle
+      const float per_circle_I = travel_I * part_per_circle,
+      const float per_circle_J = travel_J * part_per_circle,
+      const float per_circle_K = travel_K * part_per_circle,
+      const float per_circle_E = travel_E * part_per_circle     // E movement per circle
+    );
+
+    xyze_pos_t temp_position = current_position;
     for (uint16_t n = circles; n--;) {
-      TERN_(HAS_EXTRUDERS, temp_position.e += e_per_circle);              // Destination E axis
-      TERN_(HAS_Z_AXIS, temp_position[l_axis] += l_per_circle);           // Destination L axis
-      plan_arc(temp_position, offset, clockwise, 0);                      // Plan a single whole circle
+      ARC_LIJKE_CODE(                                           // Destination Linear Axes
+        temp_position[axis_l] += per_circle_L,
+        temp_position.i       += per_circle_I,
+        temp_position.j       += per_circle_J,
+        temp_position.k       += per_circle_K,
+        temp_position.e       += per_circle_E                   // Destination E axis
+      );
+      plan_arc(temp_position, offset, clockwise, 0);            // Plan a single whole circle
     }
-    TERN_(HAS_Z_AXIS, linear_travel = cart[l_axis] - current_position[l_axis]);
-    TERN_(HAS_EXTRUDERS, extruder_travel = cart.e - current_position.e);
+    ARC_LIJKE_CODE(
+      travel_L = cart[axis_l] - current_position[axis_l],
+      travel_I = cart.i       - current_position.i,
+      travel_J = cart.j       - current_position.j,
+      travel_K = cart.k       - current_position.k,
+      travel_E = cart.e       - current_position.e
+    );
   }
 
-  const float flat_mm = radius * abs_angular_travel,
-              mm_of_travel = TERN_(HAS_Z_AXIS, linear_travel ? HYPOT(flat_mm, linear_travel) :) flat_mm;
-  if (mm_of_travel < 0.001f) return;
+  // Millimeters in the arc, assuming it's flat
+  const float flat_mm = radius * abs_angular_travel;
 
+  // Return if the move is near zero
+  if (flat_mm < 0.0001f
+    GANG_N(SUB2(LINEAR_AXES),
+      && travel_L < 0.0001f,
+      && travel_I < 0.0001f,
+      && travel_J < 0.0001f,
+      && travel_K < 0.0001f
+    )
+  ) return;
+
+  // Feedrate for the move, scaled by the feedrate multiplier
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-  // Start with a nominal segment length
-  float seg_length = (
-    #ifdef ARC_SEGMENTS_PER_R
-      constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
-    #elif ARC_SEGMENTS_PER_SEC
-      _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)
+  // Get the nominal segment length based on settings
+  const float nominal_segment_mm = (
+    #if ARC_SEGMENTS_PER_SEC  // Length based on segments per second and feedrate
+      constrain(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM)
     #else
-      MM_PER_ARC_SEGMENT
+      MAX_ARC_SEGMENT_MM      // Length using the maximum segment size
     #endif
   );
-  // Divide total travel by nominal segment length
-  uint16_t segments = FLOOR(mm_of_travel / seg_length);
-  NOLESS(segments, min_segments);         // At least some segments
-  seg_length = mm_of_travel / segments;
+
+  // Number of whole segments based on the nominal segment length
+  const float nominal_segments = _MAX(FLOOR(flat_mm / nominal_segment_mm), min_segments);
+
+  // A new segment length based on the required minimum
+  const float segment_mm = constrain(flat_mm / nominal_segments, MIN_ARC_SEGMENT_MM, MAX_ARC_SEGMENT_MM);
+
+  // The number of whole segments in the arc, ignoring the remainder
+  uint16_t segments = FLOOR(flat_mm / segment_mm);
+
+  // Are the segments now too few to reach the destination?
+  const float segmented_length = segment_mm * segments;
+  const bool tooshort = segmented_length < flat_mm - 0.0001f;
+  const float proportion = tooshort ? segmented_length / flat_mm : 1.0f;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation
@@ -183,53 +223,64 @@ void plan_arc(
    * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
-  const float theta_per_segment = angular_travel / segments,
+  const float theta_per_segment = proportion * angular_travel / segments,
               sq_theta_per_segment = sq(theta_per_segment),
               sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
               cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
-  #if HAS_Z_AXIS && DISABLED(AUTO_BED_LEVELING_UBL)
-    const float linear_per_segment = linear_travel / segments;
-  #endif
-  #if HAS_EXTRUDERS
-    const float extruder_per_segment = extruder_travel / segments;
+  #if DISABLED(AUTO_BED_LEVELING_UBL)
+    ARC_LIJK_CODE(
+      const float per_segment_L = proportion * travel_L / segments,
+      const float per_segment_I = proportion * travel_I / segments,
+      const float per_segment_J = proportion * travel_J / segments,
+      const float per_segment_K = proportion * travel_K / segments
+    );
   #endif
 
-  // Initialize the linear axis
-  TERN_(HAS_Z_AXIS, raw[l_axis] = current_position[l_axis]);
+  CODE_ITEM_E(const float extruder_per_segment = proportion * travel_E / segments);
 
-  // Initialize the extruder axis
-  TERN_(HAS_EXTRUDERS, raw.e = current_position.e);
+  // For shortened segments, run all but the remainder in the loop
+  if (tooshort) segments++;
+
+  // Initialize all linear axes and E
+  ARC_LIJKE_CODE(
+    raw[axis_l] = current_position[axis_l],
+    raw.i       = current_position.i,
+    raw.j       = current_position.j,
+    raw.k       = current_position.k,
+    raw.e       = current_position.e
+  );
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float inv_duration = scaled_fr_mm_s / seg_length;
+    const float inv_duration = scaled_fr_mm_s / segment_mm;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
-    if (ELAPSED(millis(), next_idle_ms)) {
-      next_idle_ms = millis() + 200UL;
+    const millis_t ms = millis();
+    if (ELAPSED(ms, next_idle_ms)) {
+      next_idle_ms = ms + 200UL;
       idle();
     }
 
     #if N_ARC_CORRECTION > 1
       if (--arc_recalc_count) {
         // Apply vector rotation matrix to previous rvec.a / 1
         const float r_new_Y = rvec.a * sin_T + rvec.b * cos_T;
         rvec.a = rvec.a * cos_T - rvec.b * sin_T;
         rvec.b = r_new_Y;
       }
@@ -243,54 +294,58 @@ void plan_arc(
       // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
       // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
-    raw[p_axis] = center_P + rvec.a;
-    raw[q_axis] = center_Q + rvec.b;
-    #if HAS_Z_AXIS
-      raw[l_axis] = TERN(AUTO_BED_LEVELING_UBL, start_L, raw[l_axis] + linear_per_segment);
-    #endif
-
-    TERN_(HAS_EXTRUDERS, raw.e += extruder_per_segment);
+    raw[axis_p] = center_P + rvec.a;
+    raw[axis_q] = center_Q + rvec.b;
+    ARC_LIJKE_CODE(
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K
+      #else
+        raw[axis_l] += per_segment_L, raw.i += per_segment_I, raw.j += per_segment_J, raw.k += per_segment_K
+      #endif
+      , raw.e += extruder_per_segment
+    );
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
-    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
-      OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-    )) break;
+    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)))
+      break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
-  TERN_(AUTO_BED_LEVELING_UBL, TERN_(HAS_Z_AXIS, raw[l_axis] = start_L));
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    ARC_LIJK_CODE(raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K);
+  #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
-  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
-    OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-  );
+  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0 OPTARG(SCARA_FEEDRATE_SCALING, inv_duration));
 
-  TERN_(AUTO_BED_LEVELING_UBL, TERN_(HAS_Z_AXIS, raw[l_axis] = start_L));
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    ARC_LIJK_CODE(raw[axis_l] = start_L, raw.i = start_I, raw.j = start_J, raw.k = start_K);
+  #endif
   current_position = raw;
 
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form (JK, KI) and R-form.
  *
@@ -318,21 +373,21 @@ void plan_arc(
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));
 
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
-    get_destination_from_command();   // Get X Y Z E F (and set cutter power)
+    get_destination_from_command();   // Get X Y [Z[I[J[K]]]] [E] F (and set cutter power)
 
     TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
           const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current

commit 497541e1995db4e9890abc0951e0a77104bc62ef
Author: Yash <76577754+yash-fn@users.noreply.github.com>
Date:   Tue Jul 20 14:51:41 2021 -0500

    üêõ Fix G2/G3 angular motion calculation (#22407)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 170789d827..094afdb70e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -76,77 +76,80 @@ void plan_arc(
               rt_Y = cart[q_axis] - center_Q
               OPTARG(HAS_Z_AXIS, start_L = current_position[l_axis]);
 
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = MIN_ARC_SEGMENTS;
   #else
     constexpr uint16_t min_segments = 1;
   #endif
 
   // Angle of rotation between position and target from the circle center.
-  float angular_travel;
+  float angular_travel, abs_angular_travel;
 
   // Do a full circle if starting and ending positions are "identical"
   if (NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
     // Preserve direction for circles
     angular_travel = clockwise ? -RADIANS(360) : RADIANS(360);
+    abs_angular_travel = RADIANS(360);
   }
   else {
     // Calculate the angle
     angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
 
     // Angular travel too small to detect? Just return.
     if (!angular_travel) return;
 
     // Make sure angular travel over 180 degrees goes the other way around.
     switch (((angular_travel < 0) << 1) | clockwise) {
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
+    abs_angular_travel = ABS(angular_travel);
+
     #ifdef MIN_ARC_SEGMENTS
-      min_segments = CEIL(min_segments * ABS(angular_travel) / RADIANS(360));
+      min_segments = CEIL(min_segments * abs_angular_travel / RADIANS(360));
       NOLESS(min_segments, 1U);
     #endif
   }
 
   #if HAS_Z_AXIS
     float linear_travel = cart[l_axis] - start_L;
   #endif
   #if HAS_EXTRUDERS
     float extruder_travel = cart.e - current_position.e;
   #endif
 
   // If circling around...
-  if (ENABLED(ARC_P_CIRCLES) && circles) {
-    const float total_angular = angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
+  if (TERN0(ARC_P_CIRCLES, circles)) {
+    const float total_angular = abs_angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular;             // Each circle's part of the total
 
     #if HAS_Z_AXIS
       const float l_per_circle = linear_travel * part_per_circle;         // L movement per circle
     #endif
     #if HAS_EXTRUDERS
       const float e_per_circle = extruder_travel * part_per_circle;       // E movement per circle
     #endif
 
     xyze_pos_t temp_position = current_position;                          // for plan_arc to compare to current_position
     for (uint16_t n = circles; n--;) {
       TERN_(HAS_EXTRUDERS, temp_position.e += e_per_circle);              // Destination E axis
       TERN_(HAS_Z_AXIS, temp_position[l_axis] += l_per_circle);           // Destination L axis
       plan_arc(temp_position, offset, clockwise, 0);                      // Plan a single whole circle
     }
     TERN_(HAS_Z_AXIS, linear_travel = cart[l_axis] - current_position[l_axis]);
     TERN_(HAS_EXTRUDERS, extruder_travel = cart.e - current_position.e);
   }
 
-  const float flat_mm = radius * angular_travel,
-              mm_of_travel = TERN_(HAS_Z_AXIS, linear_travel ? HYPOT(flat_mm, linear_travel) :) ABS(flat_mm);
+  const float flat_mm = radius * abs_angular_travel,
+              mm_of_travel = TERN_(HAS_Z_AXIS, linear_travel ? HYPOT(flat_mm, linear_travel) :) flat_mm;
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Start with a nominal segment length
   float seg_length = (
     #ifdef ARC_SEGMENTS_PER_R
       constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
     #elif ARC_SEGMENTS_PER_SEC
       _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 4d9f5559fe..170789d827 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -56,32 +56,32 @@ void plan_arc(
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
     }
   #else
-    constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
+    constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS OPTARG(HAS_Z_AXIS, l_axis = Z_AXIS);
   #endif
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
-              rt_Y = cart[q_axis] - center_Q,
-              start_L = current_position[l_axis];
+              rt_Y = cart[q_axis] - center_Q
+              OPTARG(HAS_Z_AXIS, start_L = current_position[l_axis]);
 
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = MIN_ARC_SEGMENTS;
   #else
     constexpr uint16_t min_segments = 1;
   #endif
 
   // Angle of rotation between position and target from the circle center.
   float angular_travel;
 
@@ -102,50 +102,51 @@ void plan_arc(
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
     #ifdef MIN_ARC_SEGMENTS
       min_segments = CEIL(min_segments * ABS(angular_travel) / RADIANS(360));
       NOLESS(min_segments, 1U);
     #endif
   }
 
-  float linear_travel = cart[l_axis] - start_L;
-
+  #if HAS_Z_AXIS
+    float linear_travel = cart[l_axis] - start_L;
+  #endif
   #if HAS_EXTRUDERS
     float extruder_travel = cart.e - current_position.e;
   #endif
 
   // If circling around...
   if (ENABLED(ARC_P_CIRCLES) && circles) {
     const float total_angular = angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
-              part_per_circle = RADIANS(360) / total_angular,             // Each circle's part of the total
-                 l_per_circle = linear_travel * part_per_circle;          // L movement per circle
+              part_per_circle = RADIANS(360) / total_angular;             // Each circle's part of the total
 
+    #if HAS_Z_AXIS
+      const float l_per_circle = linear_travel * part_per_circle;         // L movement per circle
+    #endif
     #if HAS_EXTRUDERS
       const float e_per_circle = extruder_travel * part_per_circle;       // E movement per circle
     #endif
 
     xyze_pos_t temp_position = current_position;                          // for plan_arc to compare to current_position
     for (uint16_t n = circles; n--;) {
       TERN_(HAS_EXTRUDERS, temp_position.e += e_per_circle);              // Destination E axis
-      temp_position[l_axis] += l_per_circle;                              // Destination L axis
+      TERN_(HAS_Z_AXIS, temp_position[l_axis] += l_per_circle);           // Destination L axis
       plan_arc(temp_position, offset, clockwise, 0);                      // Plan a single whole circle
     }
-    linear_travel = cart[l_axis] - current_position[l_axis];
-    #if HAS_EXTRUDERS
-      extruder_travel = cart.e - current_position.e;
-    #endif
+    TERN_(HAS_Z_AXIS, linear_travel = cart[l_axis] - current_position[l_axis]);
+    TERN_(HAS_EXTRUDERS, extruder_travel = cart.e - current_position.e);
   }
 
   const float flat_mm = radius * angular_travel,
-              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
+              mm_of_travel = TERN_(HAS_Z_AXIS, linear_travel ? HYPOT(flat_mm, linear_travel) :) ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Start with a nominal segment length
   float seg_length = (
     #ifdef ARC_SEGMENTS_PER_R
       constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
     #elif ARC_SEGMENTS_PER_SEC
       _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)
@@ -180,31 +181,33 @@ void plan_arc(
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
   const float theta_per_segment = angular_travel / segments,
-              linear_per_segment = linear_travel / segments,
               sq_theta_per_segment = sq(theta_per_segment),
               sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
               cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
+  #if HAS_Z_AXIS && DISABLED(AUTO_BED_LEVELING_UBL)
+    const float linear_per_segment = linear_travel / segments;
+  #endif
   #if HAS_EXTRUDERS
     const float extruder_per_segment = extruder_travel / segments;
   #endif
 
   // Initialize the linear axis
-  raw[l_axis] = current_position[l_axis];
+  TERN_(HAS_Z_AXIS, raw[l_axis] = current_position[l_axis]);
 
   // Initialize the extruder axis
   TERN_(HAS_EXTRUDERS, raw.e = current_position.e);
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / seg_length;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
@@ -239,55 +242,52 @@ void plan_arc(
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
     raw[p_axis] = center_P + rvec.a;
     raw[q_axis] = center_Q + rvec.b;
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      raw[l_axis] = start_L;
-      UNUSED(linear_per_segment);
-    #else
-      raw[l_axis] += linear_per_segment;
+    #if HAS_Z_AXIS
+      raw[l_axis] = TERN(AUTO_BED_LEVELING_UBL, start_L, raw[l_axis] + linear_per_segment);
     #endif
 
     TERN_(HAS_EXTRUDERS, raw.e += extruder_per_segment);
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
       OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
     )) break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
-  TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
+  TERN_(AUTO_BED_LEVELING_UBL, TERN_(HAS_Z_AXIS, raw[l_axis] = start_L));
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
     OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
   );
 
-  TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
+  TERN_(AUTO_BED_LEVELING_UBL, TERN_(HAS_Z_AXIS, raw[l_axis] = start_L));
   current_position = raw;
 
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form (JK, KI) and R-form.
  *

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index bafc79bcac..4d9f5559fe 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -102,37 +102,46 @@ void plan_arc(
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
 
     #ifdef MIN_ARC_SEGMENTS
       min_segments = CEIL(min_segments * ABS(angular_travel) / RADIANS(360));
       NOLESS(min_segments, 1U);
     #endif
   }
 
-  float linear_travel = cart[l_axis] - start_L,
-        extruder_travel = cart.e - current_position.e;
+  float linear_travel = cart[l_axis] - start_L;
+
+  #if HAS_EXTRUDERS
+    float extruder_travel = cart.e - current_position.e;
+  #endif
 
   // If circling around...
   if (ENABLED(ARC_P_CIRCLES) && circles) {
     const float total_angular = angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular,             // Each circle's part of the total
-                 l_per_circle = linear_travel * part_per_circle,          // L movement per circle
-                 e_per_circle = extruder_travel * part_per_circle;        // E movement per circle
+                 l_per_circle = linear_travel * part_per_circle;          // L movement per circle
+
+    #if HAS_EXTRUDERS
+      const float e_per_circle = extruder_travel * part_per_circle;       // E movement per circle
+    #endif
+
     xyze_pos_t temp_position = current_position;                          // for plan_arc to compare to current_position
     for (uint16_t n = circles; n--;) {
-      temp_position.e += e_per_circle;                                    // Destination E axis
+      TERN_(HAS_EXTRUDERS, temp_position.e += e_per_circle);              // Destination E axis
       temp_position[l_axis] += l_per_circle;                              // Destination L axis
       plan_arc(temp_position, offset, clockwise, 0);                      // Plan a single whole circle
     }
     linear_travel = cart[l_axis] - current_position[l_axis];
-    extruder_travel = cart.e - current_position.e;
+    #if HAS_EXTRUDERS
+      extruder_travel = cart.e - current_position.e;
+    #endif
   }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Start with a nominal segment length
   float seg_length = (
@@ -172,30 +181,33 @@ void plan_arc(
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
-              extruder_per_segment = extruder_travel / segments,
               sq_theta_per_segment = sq(theta_per_segment),
               sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
               cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
+  #if HAS_EXTRUDERS
+    const float extruder_per_segment = extruder_travel / segments;
+  #endif
+
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
-  raw.e = current_position.e;
+  TERN_(HAS_EXTRUDERS, raw.e = current_position.e);
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / seg_length;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
@@ -233,21 +245,22 @@ void plan_arc(
 
     // Update raw location
     raw[p_axis] = center_P + rvec.a;
     raw[q_axis] = center_Q + rvec.b;
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       raw[l_axis] = start_L;
       UNUSED(linear_per_segment);
     #else
       raw[l_axis] += linear_per_segment;
     #endif
-    raw.e += extruder_per_segment;
+
+    TERN_(HAS_EXTRUDERS, raw.e += extruder_per_segment);
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
       OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
     )) break;

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 41ff7e9765..bafc79bcac 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -242,40 +242,36 @@ void plan_arc(
     #endif
     raw.e += extruder_per_segment;
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , inv_duration
-      #endif
+      OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
     )) break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      , inv_duration
-    #endif
+    OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
   );
 
   TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
   current_position = raw;
 
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 5a8324362a..41ff7e9765 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -284,26 +284,26 @@ void plan_arc(
  *
  *  - Depending on the current Workspace Plane orientation,
  *    use parameters IJ/JK/KI to specify the XY/YZ/ZX offsets.
  *    At least one of the IJ/JK/KI parameters is required.
  *    XY/YZ/ZX can be omitted to do a complete circle.
  *    The given XY/YZ/ZX is not error-checked. The arc ends
  *    based on the angle of the destination.
  *    Mixing IJ/JK/KI with R will throw an error.
  *
  *  - R specifies the radius. X or Y (Y or Z / Z or X) is required.
- *    Omitting both XY/YZ/ZX will throw an error.
- *    XY/YZ/ZX must differ from the current XY/YZ/ZX.
- *    Mixing R with IJ/JK/KI will throw an error.
+ *      Omitting both XY/YZ/ZX will throw an error.
+ *      XY/YZ/ZX must differ from the current XY/YZ/ZX.
+ *      Mixing R with IJ/JK/KI will throw an error.
  *
  *  - P specifies the number of full circles to do
- *    before the specified arc move.
+ *      before the specified arc move.
  *
  *  Examples:
  *
  *    G2 I10           ; CW circle centered at X+10
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
     TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 61e50247f3..5a8324362a 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -299,20 +299,22 @@ void plan_arc(
  *    before the specified arc move.
  *
  *  Examples:
  *
  *    G2 I10           ; CW circle centered at X+10
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
+    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_RUNNING));
+
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
     get_destination_from_command();   // Get X Y Z E F (and set cutter power)
 
     TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
 
     ab_float_t arc_offset = { 0, 0 };
@@ -357,14 +359,16 @@ void GcodeSuite::G2_G3(const bool clockwise) {
       #else
         constexpr uint8_t circles_to_do = 0;
       #endif
 
       // Send the arc to the planner
       plan_arc(destination, arc_offset, clockwise, circles_to_do);
       reset_stepper_timeout();
     }
     else
       SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
+
+    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_IDLE));
   }
 }
 
 #endif // ARC_SUPPORT

commit 6ec4e744c07f4035312ab4f8d377c9c2d2154d5e
Author: yysh12 <yysh12@users.noreply.github.com>
Date:   Wed Dec 23 00:12:20 2020 -0600

    Improve plan_arc circle detection (#20440)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 9c6710a08d..61e50247f3 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -34,27 +34,26 @@
 #elif ENABLED(SCARA)
   #include "../../module/scara.h"
 #endif
 
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
 
 /**
- * Plan an arc in 2 dimensions
+ * Plan an arc in 2 dimensions, with optional linear motion in a 3rd dimension
  *
- * The arc is approximated by generating many small linear segments.
- * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
- * Arcs should only be made relatively large (over 5mm), as larger arcs with
- * larger segments will tend to be more efficient. Your slicer should have
- * options for G2/G3 arc generation. In future these options may be GCode tunable.
+ * The arc is traced by generating many small linear segments, as configured by
+ * MM_PER_ARC_SEGMENT (Default 1mm). In the future we hope more slicers will include
+ * an option to generate G2/G3 arcs for curved surfaces, as this will allow faster
+ * boards to produce much smoother curved surfaces.
  */
 void plan_arc(
   const xyze_pos_t &cart,   // Destination position
   const ab_float_t &offset, // Center of rotation relative to current_position
   const bool clockwise,     // Clockwise?
   const uint8_t circles     // Take the scenic route
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
@@ -70,40 +69,47 @@ void plan_arc(
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               start_L = current_position[l_axis];
 
-  // Angle of rotation between position and target from the circle center.
-  float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
-
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = MIN_ARC_SEGMENTS;
   #else
     constexpr uint16_t min_segments = 1;
   #endif
 
-  // Do a full circle if angular rotation is near 0 and the target is current position
-  if (!angular_travel || (NEAR_ZERO(angular_travel) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis]))) {
+  // Angle of rotation between position and target from the circle center.
+  float angular_travel;
+
+  // Do a full circle if starting and ending positions are "identical"
+  if (NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
     // Preserve direction for circles
     angular_travel = clockwise ? -RADIANS(360) : RADIANS(360);
   }
   else {
+    // Calculate the angle
+    angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
+
+    // Angular travel too small to detect? Just return.
+    if (!angular_travel) return;
+
     // Make sure angular travel over 180 degrees goes the other way around.
     switch (((angular_travel < 0) << 1) | clockwise) {
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
+
     #ifdef MIN_ARC_SEGMENTS
       min_segments = CEIL(min_segments * ABS(angular_travel) / RADIANS(360));
       NOLESS(min_segments, 1U);
     #endif
   }
 
   float linear_travel = cart[l_axis] - start_L,
         extruder_travel = cart.e - current_position.e;
 
   // If circling around...

commit 287887606440df467f7e4dcd0feb541990f254dc
Author: yysh12 <yysh12@users.noreply.github.com>
Date:   Thu Dec 3 04:40:39 2020 -0600

    Fix circle arc condition (#20322)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 469d726df9..9c6710a08d 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -80,21 +80,21 @@ void plan_arc(
   // Angle of rotation between position and target from the circle center.
   float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
 
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = MIN_ARC_SEGMENTS;
   #else
     constexpr uint16_t min_segments = 1;
   #endif
 
   // Do a full circle if angular rotation is near 0 and the target is current position
-  if ((!angular_travel || NEAR_ZERO(angular_travel)) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
+  if (!angular_travel || (NEAR_ZERO(angular_travel) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis]))) {
     // Preserve direction for circles
     angular_travel = clockwise ? -RADIANS(360) : RADIANS(360);
   }
   else {
     // Make sure angular travel over 180 degrees goes the other way around.
     switch (((angular_travel < 0) << 1) | clockwise) {
       case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
       case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
     }
     #ifdef MIN_ARC_SEGMENTS

commit dcb101224f3c0e2ceb12f81a91c13ce16468445d
Author: yysh12 <yysh12@users.noreply.github.com>
Date:   Sun Nov 29 14:50:54 2020 -0600

    Arc Direction followup for circles (#20314)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b920e23073..469d726df9 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -73,38 +73,40 @@ void plan_arc(
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               start_L = current_position[l_axis];
 
   // Angle of rotation between position and target from the circle center.
   float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
 
-  // Make sure angular travel over 180 degrees goes the other way around.
-  switch (((angular_travel < 0) << 1) + clockwise) {
-    case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
-    case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
-  }
-
   #ifdef MIN_ARC_SEGMENTS
-    uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * ABS(angular_travel) / RADIANS(360));
-    NOLESS(min_segments, 1U);
+    uint16_t min_segments = MIN_ARC_SEGMENTS;
   #else
     constexpr uint16_t min_segments = 1;
   #endif
 
-  // Make a circle if the angular rotation is 0 and the target is current position
-  if (NEAR_ZERO(angular_travel) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
-    angular_travel = RADIANS(360);
+  // Do a full circle if angular rotation is near 0 and the target is current position
+  if ((!angular_travel || NEAR_ZERO(angular_travel)) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
+    // Preserve direction for circles
+    angular_travel = clockwise ? -RADIANS(360) : RADIANS(360);
+  }
+  else {
+    // Make sure angular travel over 180 degrees goes the other way around.
+    switch (((angular_travel < 0) << 1) | clockwise) {
+      case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
+      case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
+    }
     #ifdef MIN_ARC_SEGMENTS
-      min_segments = MIN_ARC_SEGMENTS;
+      min_segments = CEIL(min_segments * ABS(angular_travel) / RADIANS(360));
+      NOLESS(min_segments, 1U);
     #endif
   }
 
   float linear_travel = cart[l_axis] - start_L,
         extruder_travel = cart.e - current_position.e;
 
   // If circling around...
   if (ENABLED(ARC_P_CIRCLES) && circles) {
     const float total_angular = angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
               part_per_circle = RADIANS(360) / total_angular,             // Each circle's part of the total

commit bab660ca7d4f2f22586375e44d97678d9f7846c1
Author: yysh12 <yysh12@users.noreply.github.com>
Date:   Thu Nov 26 23:29:07 2020 -0600

    Fix G2/G3 arcs > 180¬∞ (#20292)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index c713877a0e..b920e23073 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -70,30 +70,35 @@ void plan_arc(
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               start_L = current_position[l_axis];
 
-  // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
+  // Angle of rotation between position and target from the circle center.
   float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
-  if (angular_travel < 0) angular_travel += RADIANS(360);
+
+  // Make sure angular travel over 180 degrees goes the other way around.
+  switch (((angular_travel < 0) << 1) + clockwise) {
+    case 1: angular_travel -= RADIANS(360); break; // Positive but CW? Reverse direction.
+    case 2: angular_travel += RADIANS(360); break; // Negative but CCW? Reverse direction.
+  }
+
   #ifdef MIN_ARC_SEGMENTS
-    uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
+    uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * ABS(angular_travel) / RADIANS(360));
     NOLESS(min_segments, 1U);
   #else
     constexpr uint16_t min_segments = 1;
   #endif
-  if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (NEAR_ZERO(angular_travel) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
     angular_travel = RADIANS(360);
     #ifdef MIN_ARC_SEGMENTS
       min_segments = MIN_ARC_SEGMENTS;
     #endif
   }
 
   float linear_travel = cart[l_axis] - start_L,

commit a596969049a8522c630ec064e727e5277b6f1cff
Author: uwedamm <46942357+uwedamm@users.noreply.github.com>
Date:   Wed Oct 21 03:26:07 2020 +0200

    Fix G2/G3 P<circles> E and Z motion (#19797)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 61d9f1d3a6..c713877a0e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -45,21 +45,22 @@
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  * Arcs should only be made relatively large (over 5mm), as larger arcs with
  * larger segments will tend to be more efficient. Your slicer should have
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
   const xyze_pos_t &cart,   // Destination position
   const ab_float_t &offset, // Center of rotation relative to current_position
-  const uint8_t clockwise   // Clockwise?
+  const bool clockwise,     // Clockwise?
+  const uint8_t circles     // Take the scenic route
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
     }
   #else
@@ -67,43 +68,60 @@ void plan_arc(
   #endif
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
-              start_L = current_position[l_axis],
-              linear_travel = cart[l_axis] - start_L,
-              extruder_travel = cart.e - current_position.e;
+              start_L = current_position[l_axis];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
     NOLESS(min_segments, 1U);
   #else
     constexpr uint16_t min_segments = 1;
   #endif
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
-  if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis]) {
+  if (NEAR_ZERO(angular_travel) && NEAR(current_position[p_axis], cart[p_axis]) && NEAR(current_position[q_axis], cart[q_axis])) {
     angular_travel = RADIANS(360);
     #ifdef MIN_ARC_SEGMENTS
       min_segments = MIN_ARC_SEGMENTS;
     #endif
   }
 
+  float linear_travel = cart[l_axis] - start_L,
+        extruder_travel = cart.e - current_position.e;
+
+  // If circling around...
+  if (ENABLED(ARC_P_CIRCLES) && circles) {
+    const float total_angular = angular_travel + circles * RADIANS(360),  // Total rotation with all circles and remainder
+              part_per_circle = RADIANS(360) / total_angular,             // Each circle's part of the total
+                 l_per_circle = linear_travel * part_per_circle,          // L movement per circle
+                 e_per_circle = extruder_travel * part_per_circle;        // E movement per circle
+    xyze_pos_t temp_position = current_position;                          // for plan_arc to compare to current_position
+    for (uint16_t n = circles; n--;) {
+      temp_position.e += e_per_circle;                                    // Destination E axis
+      temp_position[l_axis] += l_per_circle;                              // Destination L axis
+      plan_arc(temp_position, offset, clockwise, 0);                      // Plan a single whole circle
+    }
+    linear_travel = cart[l_axis] - current_position[l_axis];
+    extruder_travel = cart.e - current_position.e;
+  }
+
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   // Start with a nominal segment length
   float seg_length = (
     #ifdef ARC_SEGMENTS_PER_R
       constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
@@ -143,21 +161,21 @@ void plan_arc(
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
               extruder_per_segment = extruder_travel / segments,
               sq_theta_per_segment = sq(theta_per_segment),
-              sin_T = theta_per_segment - sq_theta_per_segment*theta_per_segment/6,
+              sin_T = theta_per_segment - sq_theta_per_segment * theta_per_segment / 6,
               cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw.e = current_position.e;
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / seg_length;
@@ -313,28 +331,27 @@ void GcodeSuite::G2_G3(const bool clockwise) {
         constexpr char achar = 'I', bchar = 'J';
       #endif
       if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
       if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();
     }
 
     if (arc_offset) {
 
       #if ENABLED(ARC_P_CIRCLES)
         // P indicates number of circles to do
-        int8_t circles_to_do = parser.byteval('P');
+        const int8_t circles_to_do = parser.byteval('P');
         if (!WITHIN(circles_to_do, 0, 100))
           SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
-
-        while (circles_to_do--)
-          plan_arc(current_position, arc_offset, clockwise);
+      #else
+        constexpr uint8_t circles_to_do = 0;
       #endif
 
       // Send the arc to the planner
-      plan_arc(destination, arc_offset, clockwise);
+      plan_arc(destination, arc_offset, clockwise, circles_to_do);
       reset_stepper_timeout();
     }
     else
       SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
   }
 }
 
 #endif // ARC_SUPPORT

commit 9b78138600da8a069fd0bda5919b37be96b07d48
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 9 17:56:01 2020 -0500

    General cleanup

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 59a5346356..61d9f1d3a6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -108,23 +108,21 @@ void plan_arc(
     #ifdef ARC_SEGMENTS_PER_R
       constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
     #elif ARC_SEGMENTS_PER_SEC
       _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)
     #else
       MM_PER_ARC_SEGMENT
     #endif
   );
   // Divide total travel by nominal segment length
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
-  if (segments < min_segments) {            // Too few segments?
-    segments = min_segments;                // More segments
-  }
+  NOLESS(segments, min_segments);         // At least some segments
   seg_length = mm_of_travel / segments;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 5255db23b1..59a5346356 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(ARC_SUPPORT)
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"

commit 815c8d2b5562115932783c9b3b93372df157f30b
Author: Eyal <109809+eyal0@users.noreply.github.com>
Date:   Sat May 30 23:26:15 2020 -0600

    Improve G2 / G3 motion accuracy (#18144)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 91923121c5..5255db23b1 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -110,22 +110,22 @@ void plan_arc(
     #elif ARC_SEGMENTS_PER_SEC
       _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)
     #else
       MM_PER_ARC_SEGMENT
     #endif
   );
   // Divide total travel by nominal segment length
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
   if (segments < min_segments) {            // Too few segments?
     segments = min_segments;                // More segments
-    seg_length = mm_of_travel / segments;   // but also shorter
   }
+  seg_length = mm_of_travel / segments;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation
@@ -144,22 +144,23 @@ void plan_arc(
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   xyze_pos_t raw;
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
               extruder_per_segment = extruder_travel / segments,
-              sin_T = theta_per_segment,
-              cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
+              sq_theta_per_segment = sq(theta_per_segment),
+              sin_T = theta_per_segment - sq_theta_per_segment*theta_per_segment/6,
+              cos_T = 1 - 0.5f * sq_theta_per_segment; // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw.e = current_position.e;
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / seg_length;
   #endif
@@ -211,21 +212,21 @@ void plan_arc(
       raw[l_axis] += linear_per_segment;
     #endif
     raw.e += extruder_per_segment;
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
-    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, seg_length
+    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     )) break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
 

commit 32dc874928bf78b9192bc1a790b9151a9f6cf3c5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 10 03:42:48 2020 -0500

    Tempted by the const of a seg_length

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 0352947cca..91923121c5 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -96,35 +96,35 @@ void plan_arc(
       min_segments = MIN_ARC_SEGMENTS;
     #endif
   }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-  #ifdef ARC_SEGMENTS_PER_R
-    float seg_length = MM_PER_ARC_SEGMENT * radius;
-    LIMIT(seg_length, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R);
-  #elif ARC_SEGMENTS_PER_SEC
-    float seg_length = scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC);
-    NOLESS(seg_length, MM_PER_ARC_SEGMENT);
-  #else
-    constexpr float seg_length = MM_PER_ARC_SEGMENT;
-  #endif
-
-  // Length divided by segment size gives segment count
+  // Start with a nominal segment length
+  float seg_length = (
+    #ifdef ARC_SEGMENTS_PER_R
+      constrain(MM_PER_ARC_SEGMENT * radius, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R)
+    #elif ARC_SEGMENTS_PER_SEC
+      _MAX(scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC), MM_PER_ARC_SEGMENT)
+    #else
+      MM_PER_ARC_SEGMENT
+    #endif
+  );
+  // Divide total travel by nominal segment length
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
-  if (segments < min_segments) {
-    segments = min_segments;                      // No fewer than the minimum
-    seg_length = mm_of_travel / segments;         // A new segment length
+  if (segments < min_segments) {            // Too few segments?
+    segments = min_segments;                // More segments
+    seg_length = mm_of_travel / segments;   // but also shorter
   }
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive

commit de6a725b04f9005fa53fab240edb3d2c576a6c97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 10 02:46:37 2020 -0500

    Fix G2/G3 segment size
    
    Fixes #17348

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 1e8365d6d2..0352947cca 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -105,22 +105,27 @@ void plan_arc(
 
   #ifdef ARC_SEGMENTS_PER_R
     float seg_length = MM_PER_ARC_SEGMENT * radius;
     LIMIT(seg_length, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R);
   #elif ARC_SEGMENTS_PER_SEC
     float seg_length = scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC);
     NOLESS(seg_length, MM_PER_ARC_SEGMENT);
   #else
     constexpr float seg_length = MM_PER_ARC_SEGMENT;
   #endif
+
+  // Length divided by segment size gives segment count
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
-  NOLESS(segments, min_segments);
+  if (segments < min_segments) {
+    segments = min_segments;                      // No fewer than the minimum
+    seg_length = mm_of_travel / segments;         // A new segment length
+  }
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index d6b18bdd95..1e8365d6d2 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -63,28 +63,26 @@ void plan_arc(
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
-              #if ENABLED(AUTO_BED_LEVELING_UBL)
-                start_L  = current_position[l_axis],
-              #endif
               center_P = current_position[p_axis] - rvec.a,
               center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
-              linear_travel = cart[l_axis] - current_position[l_axis],
+              start_L = current_position[l_axis],
+              linear_travel = cart[l_axis] - start_L,
               extruder_travel = cart.e - current_position.e;
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
     NOLESS(min_segments, 1U);
   #else
     constexpr uint16_t min_segments = 1;
@@ -150,21 +148,20 @@ void plan_arc(
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
               cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw.e = current_position.e;
 
-
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / seg_length;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
@@ -213,46 +210,42 @@ void plan_arc(
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, seg_length
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
-    ))
-      break;
+    )) break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    raw[l_axis] = start_L;
-  #endif
+  TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    raw[l_axis] = start_L;
-  #endif
+  TERN_(AUTO_BED_LEVELING_UBL, raw[l_axis] = start_L);
   current_position = raw;
+
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form (JK, KI) and R-form.
  *
  *  - Depending on the current Workspace Plane orientation,
  *    use parameters IJ/JK/KI to specify the XY/YZ/ZX offsets.
@@ -278,23 +271,21 @@ void plan_arc(
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
     get_destination_from_command();   // Get X Y Z E F (and set cutter power)
 
-    #if ENABLED(SF_ARC_FIX)
-      relative_mode = relative_mode_backup;
-    #endif
+    TERN_(SF_ARC_FIX, relative_mode = relative_mode_backup);
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
           const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current
           const float e = clockwise ^ (r < 0) ? -1 : 1,  // clockwise -1/1, counterclockwise 1/-1
                       len = d2.magnitude(),              // Distance to mid-point of move from current

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b0fb299ab2..d6b18bdd95 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -276,21 +276,21 @@ void plan_arc(
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
   if (MOTION_CONDITIONS) {
 
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
-    get_destination_from_command();
+    get_destination_from_command();   // Get X Y Z E F (and set cutter power)
 
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;
     #endif
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;

commit e0e87ca19a57dc42e9eb5e22d044b8f3c1116544
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 31 12:49:36 2020 -0500

    Fix last arc segment
    
    Co-Authored-By: ellensp <ellensp@hotmail.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b11b1136b6..b0fb299ab2 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -229,21 +229,21 @@ void plan_arc(
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
-  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, seg_length
+  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, 0
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
   current_position = raw;
 } // plan_arc

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 70043f5386..b11b1136b6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -320,26 +320,26 @@ void GcodeSuite::G2_G3(const bool clockwise) {
       if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
       if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();
     }
 
     if (arc_offset) {
 
       #if ENABLED(ARC_P_CIRCLES)
         // P indicates number of circles to do
         int8_t circles_to_do = parser.byteval('P');
         if (!WITHIN(circles_to_do, 0, 100))
-          SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
+          SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
 
         while (circles_to_do--)
           plan_arc(current_position, arc_offset, clockwise);
       #endif
 
       // Send the arc to the planner
       plan_arc(destination, arc_offset, clockwise);
       reset_stepper_timeout();
     }
     else
-      SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
+      SERIAL_ERROR_MSG(STR_ERR_ARC_ARGS);
   }
 }
 
 #endif // ARC_SUPPORT

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index c915cc334e..70043f5386 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit b7f86bffd5debd04cfdf2450aa3e82343c4d0d5d
Author: Ryan <allted@gmail.com>
Date:   Tue Jan 21 00:53:26 2020 -0800

    Arc segment radius scaling (#16551)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 1487505e03..c915cc334e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -98,21 +98,24 @@ void plan_arc(
       min_segments = MIN_ARC_SEGMENTS;
     #endif
   }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-  #ifdef ARC_SEGMENTS_PER_SEC
+  #ifdef ARC_SEGMENTS_PER_R
+    float seg_length = MM_PER_ARC_SEGMENT * radius;
+    LIMIT(seg_length, MM_PER_ARC_SEGMENT, ARC_SEGMENTS_PER_R);
+  #elif ARC_SEGMENTS_PER_SEC
     float seg_length = scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC);
     NOLESS(seg_length, MM_PER_ARC_SEGMENT);
   #else
     constexpr float seg_length = MM_PER_ARC_SEGMENT;
   #endif
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
   NOLESS(segments, min_segments);
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,

commit 56e51efeea9c8a9cee4e24a5940d9d9d3fa517b6
Author: Ryan V1 <55478432+V1EngineeringInc@users.noreply.github.com>
Date:   Sat Jan 11 15:16:16 2020 -0800

    Use RECIPROCAL macro (not _RECIP) (#16530)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index e274b6a5cf..1487505e03 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -99,21 +99,21 @@ void plan_arc(
     #endif
   }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   #ifdef ARC_SEGMENTS_PER_SEC
-    float seg_length = scaled_fr_mm_s * _RECIP(ARC_SEGMENTS_PER_SEC);
+    float seg_length = scaled_fr_mm_s * RECIPROCAL(ARC_SEGMENTS_PER_SEC);
     NOLESS(seg_length, MM_PER_ARC_SEGMENT);
   #else
     constexpr float seg_length = MM_PER_ARC_SEGMENT;
   #endif
   uint16_t segments = FLOOR(mm_of_travel / seg_length);
   NOLESS(segments, min_segments);
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.

commit 36d08f8ad354005dcb45e2907fec5ece45f309a7
Author: Jamie <vector76@users.noreply.github.com>
Date:   Thu Jan 9 04:48:00 2020 -0600

    Add ARC_SEGMENTS_PER_SEC for finer G2/G3 arcs (#16510)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 6fecbdc0cc..e274b6a5cf 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -96,21 +96,29 @@ void plan_arc(
     angular_travel = RADIANS(360);
     #ifdef MIN_ARC_SEGMENTS
       min_segments = MIN_ARC_SEGMENTS;
     #endif
   }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
-  uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
+  const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
+
+  #ifdef ARC_SEGMENTS_PER_SEC
+    float seg_length = scaled_fr_mm_s * _RECIP(ARC_SEGMENTS_PER_SEC);
+    NOLESS(seg_length, MM_PER_ARC_SEGMENT);
+  #else
+    constexpr float seg_length = MM_PER_ARC_SEGMENT;
+  #endif
+  uint16_t segments = FLOOR(mm_of_travel / seg_length);
   NOLESS(segments, min_segments);
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
@@ -139,24 +147,23 @@ void plan_arc(
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
               cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw.e = current_position.e;
 
-  const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float inv_duration = scaled_fr_mm_s / MM_PER_ARC_SEGMENT;
+    const float inv_duration = scaled_fr_mm_s / seg_length;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
@@ -199,41 +206,41 @@ void plan_arc(
       raw[l_axis] += linear_per_segment;
     #endif
     raw.e += extruder_per_segment;
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
-    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, seg_length
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     ))
       break;
   }
 
   // Ensure last segment arrives at target location.
   raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
-  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, seg_length
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
   current_position = raw;
 } // plan_arc

commit e79666a82b7fd907ed0210c034342f851daad1b8
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Fri Oct 11 09:16:37 2019 +0700

    Followup to "Fix G2/G3 rounding" (#15510)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index edace2b63e..6fecbdc0cc 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -283,22 +283,22 @@ void GcodeSuite::G2_G3(const bool clockwise) {
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
           const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current
           const float e = clockwise ^ (r < 0) ? -1 : 1,  // clockwise -1/1, counterclockwise 1/-1
                       len = d2.magnitude(),              // Distance to mid-point of move from current
                       h2 = (r - len) * (r + len),        // factored to reduce rounding error
                       h = (h2 >= 0) ? SQRT(h2) : 0.0f;   // Distance to the arc pivot-point from midpoint
-          const xy_pos_t s = { -d2.y, d2.x } / len;      // Unit vector along perpendicular bisector
-          arc_offset = d2 + s * e * h;                   // The calculated offset (mid-point if |r| <= len)
+          const xy_pos_t s = { -d2.y, d2.x };            // Perpendicular bisector. (Divide by len for unit vector.)
+          arc_offset = d2 + s / len * e * h;             // The calculated offset (mid-point if |r| <= len)
         }
       }
     }
     else {
       #if ENABLED(CNC_WORKSPACE_PLANES)
         char achar, bchar;
         switch (gcode.workspace_plane) {
           default:
           case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
           case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;

commit d8aeeb8ff6a14d68acafe50e2f74a8f460c753c8
Author: Ed Williams <ed@edwilliams.org>
Date:   Thu Oct 10 14:50:08 2019 -1000

    Fix G2/G3 rounding error (#15507)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index e2240cbf23..edace2b63e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -278,26 +278,27 @@ void GcodeSuite::G2_G3(const bool clockwise) {
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;
     #endif
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
-          const xy_pos_t d = p2 - p1, m = (p1 + p2) * 0.5f;   // XY distance and midpoint
-          const float e = clockwise ^ (r < 0) ? -1 : 1,       // clockwise -1/1, counterclockwise 1/-1
-                      len = d.magnitude(),                    // Total move length
-                      h = SQRT((r - d * 0.5f) * (r + d * 0.5f)); // Distance to the arc pivot-point
-          const xy_pos_t s = { d.x, -d.y };                   // Inverse Slope of the perpendicular bisector
-          arc_offset = m + s * RECIPROCAL(len) * e * h - p1;  // The calculated offset
+          const xy_pos_t d2 = (p2 - p1) * 0.5f;          // XY vector to midpoint of move from current
+          const float e = clockwise ^ (r < 0) ? -1 : 1,  // clockwise -1/1, counterclockwise 1/-1
+                      len = d2.magnitude(),              // Distance to mid-point of move from current
+                      h2 = (r - len) * (r + len),        // factored to reduce rounding error
+                      h = (h2 >= 0) ? SQRT(h2) : 0.0f;   // Distance to the arc pivot-point from midpoint
+          const xy_pos_t s = { -d2.y, d2.x } / len;      // Unit vector along perpendicular bisector
+          arc_offset = d2 + s * e * h;                   // The calculated offset (mid-point if |r| <= len)
         }
       }
     }
     else {
       #if ENABLED(CNC_WORKSPACE_PLANES)
         char achar, bchar;
         switch (gcode.workspace_plane) {
           default:
           case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
           case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;

commit e84389c976136176e054baac75b15c46ab10f6a3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 17:09:20 2019 -0500

    Fix G2/G3 workspace plane parameters (#15475)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 5650e239bf..e2240cbf23 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -52,22 +52,22 @@
 void plan_arc(
   const xyze_pos_t &cart,   // Destination position
   const ab_float_t &offset, // Center of rotation relative to current_position
   const uint8_t clockwise   // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
-      case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
+      case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   ab_float_t rvec = -offset;
 
   const float radius = HYPOT(rvec.a, rvec.b),
               #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -235,33 +235,34 @@ void plan_arc(
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
   current_position = raw;
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
- * This command has two forms: IJ-form and R-form.
+ * This command has two forms: IJ-form (JK, KI) and R-form.
  *
- *  - I specifies an X offset. J specifies a Y offset.
- *    At least one of the IJ parameters is required.
- *    X and Y can be omitted to do a complete circle.
- *    The given XY is not error-checked. The arc ends
- *     based on the angle of the destination.
- *    Mixing I or J with R will throw an error.
+ *  - Depending on the current Workspace Plane orientation,
+ *    use parameters IJ/JK/KI to specify the XY/YZ/ZX offsets.
+ *    At least one of the IJ/JK/KI parameters is required.
+ *    XY/YZ/ZX can be omitted to do a complete circle.
+ *    The given XY/YZ/ZX is not error-checked. The arc ends
+ *    based on the angle of the destination.
+ *    Mixing IJ/JK/KI with R will throw an error.
  *
- *  - R specifies the radius. X or Y is required.
- *    Omitting both X and Y will throw an error.
- *    X or Y must differ from the current XY.
- *    Mixing R with I or J will throw an error.
+ *  - R specifies the radius. X or Y (Y or Z / Z or X) is required.
+ *    Omitting both XY/YZ/ZX will throw an error.
+ *    XY/YZ/ZX must differ from the current XY/YZ/ZX.
+ *    Mixing R with IJ/JK/KI will throw an error.
  *
  *  - P specifies the number of full circles to do
  *    before the specified arc move.
  *
  *  Examples:
  *
  *    G2 I10           ; CW circle centered at X+10
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
@@ -287,22 +288,33 @@ void GcodeSuite::G2_G3(const bool clockwise) {
           const xy_pos_t d = p2 - p1, m = (p1 + p2) * 0.5f;   // XY distance and midpoint
           const float e = clockwise ^ (r < 0) ? -1 : 1,       // clockwise -1/1, counterclockwise 1/-1
                       len = d.magnitude(),                    // Total move length
                       h = SQRT((r - d * 0.5f) * (r + d * 0.5f)); // Distance to the arc pivot-point
           const xy_pos_t s = { d.x, -d.y };                   // Inverse Slope of the perpendicular bisector
           arc_offset = m + s * RECIPROCAL(len) * e * h - p1;  // The calculated offset
         }
       }
     }
     else {
-      if (parser.seenval('I')) arc_offset.a = parser.value_linear_units();
-      if (parser.seenval('J')) arc_offset.b = parser.value_linear_units();
+      #if ENABLED(CNC_WORKSPACE_PLANES)
+        char achar, bchar;
+        switch (gcode.workspace_plane) {
+          default:
+          case GcodeSuite::PLANE_XY: achar = 'I'; bchar = 'J'; break;
+          case GcodeSuite::PLANE_YZ: achar = 'J'; bchar = 'K'; break;
+          case GcodeSuite::PLANE_ZX: achar = 'K'; bchar = 'I'; break;
+        }
+      #else
+        constexpr char achar = 'I', bchar = 'J';
+      #endif
+      if (parser.seenval(achar)) arc_offset.a = parser.value_linear_units();
+      if (parser.seenval(bchar)) arc_offset.b = parser.value_linear_units();
     }
 
     if (arc_offset) {
 
       #if ENABLED(ARC_P_CIRCLES)
         // P indicates number of circles to do
         int8_t circles_to_do = parser.byteval('P');
         if (!WITHIN(circles_to_do, 0, 100))
           SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
 

commit 56595a4c9cfad38a5fdd46d48e370edf70e0a079
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 7 00:03:17 2019 -0500

    Improve G2/G3 precision
    
    See https://github.com/MarlinFirmware/Marlin/issues/14745#issuecomment-538781253

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index e856afff11..5650e239bf 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -280,21 +280,21 @@ void GcodeSuite::G2_G3(const bool clockwise) {
 
     ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
         const xy_pos_t p1 = current_position, p2 = destination;
         if (p1 != p2) {
           const xy_pos_t d = p2 - p1, m = (p1 + p2) * 0.5f;   // XY distance and midpoint
           const float e = clockwise ^ (r < 0) ? -1 : 1,       // clockwise -1/1, counterclockwise 1/-1
                       len = d.magnitude(),                    // Total move length
-                      h = SQRT(sq(r) - sq(len * 0.5f));       // Distance to the arc pivot-point
+                      h = SQRT((r - d * 0.5f) * (r + d * 0.5f)); // Distance to the arc pivot-point
           const xy_pos_t s = { d.x, -d.y };                   // Inverse Slope of the perpendicular bisector
           arc_offset = m + s * RECIPROCAL(len) * e * h - p1;  // The calculated offset
         }
       }
     }
     else {
       if (parser.seenval('I')) arc_offset.a = parser.value_linear_units();
       if (parser.seenval('J')) arc_offset.b = parser.value_linear_units();
     }
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 2a713a9f41..e856afff11 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -43,52 +43,52 @@
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  * Arcs should only be made relatively large (over 5mm), as larger arcs with
  * larger segments will tend to be more efficient. Your slicer should have
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
-  const float (&cart)[XYZE],  // Destination position
-  const float (&offset)[2],   // Center of rotation relative to current_position
-  const uint8_t clockwise     // Clockwise?
+  const xyze_pos_t &cart,   // Destination position
+  const ab_float_t &offset, // Center of rotation relative to current_position
+  const uint8_t clockwise   // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
-  float r_P = -offset[0], r_Q = -offset[1];
+  ab_float_t rvec = -offset;
 
-  const float radius = HYPOT(r_P, r_Q),
+  const float radius = HYPOT(rvec.a, rvec.b),
               #if ENABLED(AUTO_BED_LEVELING_UBL)
                 start_L  = current_position[l_axis],
               #endif
-              center_P = current_position[p_axis] - r_P,
-              center_Q = current_position[q_axis] - r_Q,
+              center_P = current_position[p_axis] - rvec.a,
+              center_Q = current_position[q_axis] - rvec.b,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               linear_travel = cart[l_axis] - current_position[l_axis],
-              extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
+              extruder_travel = cart.e - current_position.e;
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
-  float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
+  float angular_travel = ATAN2(rvec.a * rt_Y - rvec.b * rt_X, rvec.a * rt_X + rvec.b * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
     NOLESS(min_segments, 1U);
   #else
     constexpr uint16_t min_segments = 1;
   #endif
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
@@ -126,32 +126,32 @@ void plan_arc(
    * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
    * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
-  float raw[XYZE];
+  xyze_pos_t raw;
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
               cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
-  raw[E_AXIS] = current_position[E_AXIS];
+  raw.e = current_position.e;
 
   const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float inv_duration = scaled_fr_mm_s / MM_PER_ARC_SEGMENT;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
@@ -161,88 +161,88 @@ void plan_arc(
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
       next_idle_ms = millis() + 200UL;
       idle();
     }
 
     #if N_ARC_CORRECTION > 1
       if (--arc_recalc_count) {
-        // Apply vector rotation matrix to previous r_P / 1
-        const float r_new_Y = r_P * sin_T + r_Q * cos_T;
-        r_P = r_P * cos_T - r_Q * sin_T;
-        r_Q = r_new_Y;
+        // Apply vector rotation matrix to previous rvec.a / 1
+        const float r_new_Y = rvec.a * sin_T + rvec.b * cos_T;
+        rvec.a = rvec.a * cos_T - rvec.b * sin_T;
+        rvec.b = r_new_Y;
       }
       else
     #endif
     {
       #if N_ARC_CORRECTION > 1
         arc_recalc_count = N_ARC_CORRECTION;
       #endif
 
       // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
       // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
-      r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
-      r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
+      rvec.a = -offset[0] * cos_Ti + offset[1] * sin_Ti;
+      rvec.b = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
-    raw[p_axis] = center_P + r_P;
-    raw[q_axis] = center_Q + r_Q;
+    raw[p_axis] = center_P + rvec.a;
+    raw[q_axis] = center_Q + rvec.b;
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       raw[l_axis] = start_L;
       UNUSED(linear_per_segment);
     #else
       raw[l_axis] += linear_per_segment;
     #endif
-    raw[E_AXIS] += extruder_per_segment;
+    raw.e += extruder_per_segment;
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     ))
       break;
   }
 
   // Ensure last segment arrives at target location.
-  COPY(raw, cart);
+  raw = cart;
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
-  COPY(current_position, raw);
+  current_position = raw;
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.
  *    At least one of the IJ parameters is required.
@@ -271,46 +271,41 @@ void GcodeSuite::G2_G3(const bool clockwise) {
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
     get_destination_from_command();
 
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;
     #endif
 
-    float arc_offset[2] = { 0, 0 };
+    ab_float_t arc_offset = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units();
       if (r) {
-        const float p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
-                    p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
-        if (p2 != p1 || q2 != q1) {
-          const float e = clockwise ^ (r < 0) ? -1 : 1,            // clockwise -1/1, counterclockwise 1/-1
-                      dx = p2 - p1, dy = q2 - q1,                  // X and Y differences
-                      d = HYPOT(dx, dy),                           // Linear distance between the points
-                      dinv = 1/d,                                  // Inverse of d
-                      h = SQRT(sq(r) - sq(d * 0.5f)),              // Distance to the arc pivot-point
-                      mx = (p1 + p2) * 0.5f, my = (q1 + q2) * 0.5f,// Point between the two points
-                      sx = -dy * dinv, sy = dx * dinv,             // Slope of the perpendicular bisector
-                      cx = mx + e * h * sx, cy = my + e * h * sy;  // Pivot-point of the arc
-          arc_offset[0] = cx - p1;
-          arc_offset[1] = cy - q1;
+        const xy_pos_t p1 = current_position, p2 = destination;
+        if (p1 != p2) {
+          const xy_pos_t d = p2 - p1, m = (p1 + p2) * 0.5f;   // XY distance and midpoint
+          const float e = clockwise ^ (r < 0) ? -1 : 1,       // clockwise -1/1, counterclockwise 1/-1
+                      len = d.magnitude(),                    // Total move length
+                      h = SQRT(sq(r) - sq(len * 0.5f));       // Distance to the arc pivot-point
+          const xy_pos_t s = { d.x, -d.y };                   // Inverse Slope of the perpendicular bisector
+          arc_offset = m + s * RECIPROCAL(len) * e * h - p1;  // The calculated offset
         }
       }
     }
     else {
-      if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
-      if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
+      if (parser.seenval('I')) arc_offset.a = parser.value_linear_units();
+      if (parser.seenval('J')) arc_offset.b = parser.value_linear_units();
     }
 
-    if (arc_offset[0] || arc_offset[1]) {
+    if (arc_offset) {
 
       #if ENABLED(ARC_P_CIRCLES)
         // P indicates number of circles to do
         int8_t circles_to_do = parser.byteval('P');
         if (!WITHIN(circles_to_do, 0, 100))
           SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
 
         while (circles_to_do--)
           plan_arc(current_position, arc_offset, clockwise);
       #endif

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 09762a995c..2a713a9f41 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -139,24 +139,24 @@ void plan_arc(
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
               cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw[E_AXIS] = current_position[E_AXIS];
 
-  const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
+  const feedRate_t scaled_fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float inv_duration = fr_mm_s / MM_PER_ARC_SEGMENT;
+    const float inv_duration = scaled_fr_mm_s / MM_PER_ARC_SEGMENT;
   #endif
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
@@ -199,41 +199,41 @@ void plan_arc(
       raw[l_axis] += linear_per_segment;
     #endif
     raw[E_AXIS] += extruder_per_segment;
 
     apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
-    if (!planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+    if (!planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     ))
       break;
   }
 
   // Ensure last segment arrives at target location.
   COPY(raw, cart);
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
   apply_motion_limits(raw);
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
-  planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+  planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
   COPY(current_position, raw);
 } // plan_arc

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 9f85d65d5e..09762a995c 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -273,34 +273,36 @@ void GcodeSuite::G2_G3(const bool clockwise) {
     #endif
 
     get_destination_from_command();
 
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;
     #endif
 
     float arc_offset[2] = { 0, 0 };
     if (parser.seenval('R')) {
-      const float r = parser.value_linear_units(),
-                  p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
-                  p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
-      if (r && (p2 != p1 || q2 != q1)) {
-        const float e = clockwise ^ (r < 0) ? -1 : 1,            // clockwise -1/1, counterclockwise 1/-1
-                    dx = p2 - p1, dy = q2 - q1,                  // X and Y differences
-                    d = HYPOT(dx, dy),                           // Linear distance between the points
-                    dinv = 1/d,                                  // Inverse of d
-                    h = SQRT(sq(r) - sq(d * 0.5f)),              // Distance to the arc pivot-point
-                    mx = (p1 + p2) * 0.5f, my = (q1 + q2) * 0.5f,// Point between the two points
-                    sx = -dy * dinv, sy = dx * dinv,             // Slope of the perpendicular bisector
-                    cx = mx + e * h * sx, cy = my + e * h * sy;  // Pivot-point of the arc
-        arc_offset[0] = cx - p1;
-        arc_offset[1] = cy - q1;
+      const float r = parser.value_linear_units();
+      if (r) {
+        const float p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
+                    p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
+        if (p2 != p1 || q2 != q1) {
+          const float e = clockwise ^ (r < 0) ? -1 : 1,            // clockwise -1/1, counterclockwise 1/-1
+                      dx = p2 - p1, dy = q2 - q1,                  // X and Y differences
+                      d = HYPOT(dx, dy),                           // Linear distance between the points
+                      dinv = 1/d,                                  // Inverse of d
+                      h = SQRT(sq(r) - sq(d * 0.5f)),              // Distance to the arc pivot-point
+                      mx = (p1 + p2) * 0.5f, my = (q1 + q2) * 0.5f,// Point between the two points
+                      sx = -dy * dinv, sy = dx * dinv,             // Slope of the perpendicular bisector
+                      cx = mx + e * h * sx, cy = my + e * h * sy;  // Pivot-point of the arc
+          arc_offset[0] = cx - p1;
+          arc_offset[1] = cy - q1;
+        }
       }
     }
     else {
       if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
       if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
     }
 
     if (arc_offset[0] || arc_offset[1]) {
 
       #if ENABLED(ARC_P_CIRCLES)

commit 7496e1cd6745fe72fc6c12e0792575bb7ffefad4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 4 21:40:40 2019 -0500

    whitespace

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 700ab82119..9f85d65d5e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -214,21 +214,21 @@ void plan_arc(
       break;
   }
 
   // Ensure last segment arrives at target location.
   COPY(raw, cart);
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
   apply_motion_limits(raw);
-  
+
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 

commit 293b890940a884480715be9a83d6ba30941d2bf7
Author: Jamie <vector76@users.noreply.github.com>
Date:   Wed Sep 4 13:02:30 2019 -0500

    Apply soft limits to G2/G3 final target (#15156)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 030675c230..700ab82119 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -213,20 +213,22 @@ void plan_arc(
     ))
       break;
   }
 
   // Ensure last segment arrives at target location.
   COPY(raw, cart);
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     raw[l_axis] = start_L;
   #endif
 
+  apply_motion_limits(raw);
+  
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index da07525dcf..030675c230 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit c6466c23fe256669659bd744bb5fd40829936f93
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 29 12:33:45 2019 -0600

    Silence signed/unsigned comparison warning. (#13508)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 4904b7e729..da07525dcf 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -78,21 +78,21 @@ void plan_arc(
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               linear_travel = cart[l_axis] - current_position[l_axis],
               extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   #ifdef MIN_ARC_SEGMENTS
     uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
-    NOLESS(min_segments, 1);
+    NOLESS(min_segments, 1U);
   #else
     constexpr uint16_t min_segments = 1;
   #endif
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis]) {
     angular_travel = RADIANS(360);
     #ifdef MIN_ARC_SEGMENTS
       min_segments = MIN_ARC_SEGMENTS;

commit d96f7d6068082a9eebc02ba6aee185219ae71fa4
Author: 7eggert <7eggert@gmx.de>
Date:   Mon Mar 25 01:53:47 2019 +0100

    Minimum segments for G2/G3. Better for small arcs. (#13466)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 5348d121c1..4904b7e729 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -76,32 +76,42 @@ void plan_arc(
               center_P = current_position[p_axis] - r_P,
               center_Q = current_position[q_axis] - r_Q,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               linear_travel = cart[l_axis] - current_position[l_axis],
               extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
+  #ifdef MIN_ARC_SEGMENTS
+    uint16_t min_segments = CEIL((MIN_ARC_SEGMENTS) * (angular_travel / RADIANS(360)));
+    NOLESS(min_segments, 1);
+  #else
+    constexpr uint16_t min_segments = 1;
+  #endif
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
-  if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
+  if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis]) {
     angular_travel = RADIANS(360);
+    #ifdef MIN_ARC_SEGMENTS
+      min_segments = MIN_ARC_SEGMENTS;
+    #endif
+  }
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001f) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
-  if (segments == 0) segments = 1;
+  NOLESS(segments, min_segments);
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
    * For arc generation, the center of the circle is the axis of rotation and the radius vector is
    * defined from the circle center to the initial position. Each line segment is formed by successive
    * vector rotations. This requires only two cos() and sin() computations to form the rotation

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 9193d25599..5348d121c1 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -183,21 +183,21 @@ void plan_arc(
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       raw[l_axis] = start_L;
       UNUSED(linear_per_segment);
     #else
       raw[l_axis] += linear_per_segment;
     #endif
     raw[E_AXIS] += extruder_per_segment;
 
-    clamp_to_software_endstops(raw);
+    apply_motion_limits(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     ))

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index f905a148b0..9193d25599 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit acf266fe781d6d4bdad7beeb387b70c24cf2e213
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jan 20 01:47:29 2019 +0100

    Fix a compile warning, etc. (#12955)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b0473ed41f..f905a148b0 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -177,20 +177,21 @@ void plan_arc(
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       raw[l_axis] = start_L;
+      UNUSED(linear_per_segment);
     #else
       raw[l_axis] += linear_per_segment;
     #endif
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index b592b31baa..b0473ed41f 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -286,31 +286,27 @@ void GcodeSuite::G2_G3(const bool clockwise) {
     else {
       if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
       if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
     }
 
     if (arc_offset[0] || arc_offset[1]) {
 
       #if ENABLED(ARC_P_CIRCLES)
         // P indicates number of circles to do
         int8_t circles_to_do = parser.byteval('P');
-        if (!WITHIN(circles_to_do, 0, 100)) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
-        }
+        if (!WITHIN(circles_to_do, 0, 100))
+          SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
+
         while (circles_to_do--)
           plan_arc(current_position, arc_offset, clockwise);
       #endif
 
       // Send the arc to the planner
       plan_arc(destination, arc_offset, clockwise);
       reset_stepper_timeout();
     }
-    else {
-      // Bad arguments
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
-    }
+    else
+      SERIAL_ERROR_MSG(MSG_ERR_ARC_ARGS);
   }
 }
 
 #endif // ARC_SUPPORT

commit cda5ef08fad18c728523a6ee7b2f05355e47799c
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Nov 13 11:20:21 2018 -0600

    Debug of G2-G3 for UBL (#12386)
    
    Changes only affect UBL.  Everything else is left alone.

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 0ae3f8574f..b592b31baa 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -63,20 +63,23 @@ void plan_arc(
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   float r_P = -offset[0], r_Q = -offset[1];
 
   const float radius = HYPOT(r_P, r_Q),
+              #if ENABLED(AUTO_BED_LEVELING_UBL)
+                start_L  = current_position[l_axis],
+              #endif
               center_P = current_position[p_axis] - r_P,
               center_Q = current_position[q_axis] - r_Q,
               rt_X = cart[p_axis] - center_P,
               rt_Y = cart[q_axis] - center_Q,
               linear_travel = cart[l_axis] - current_position[l_axis],
               extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
@@ -172,50 +175,60 @@ void plan_arc(
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
-    raw[l_axis] += linear_per_segment;
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      raw[l_axis] = start_L;
+    #else
+      raw[l_axis] += linear_per_segment;
+    #endif
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
     #if HAS_LEVELING && !PLANNER_LEVELING
       planner.apply_leveling(raw);
     #endif
 
     if (!planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , inv_duration
       #endif
     ))
       break;
   }
 
   // Ensure last segment arrives at target location.
   COPY(raw, cart);
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    raw[l_axis] = start_L;
+  #endif
 
   #if HAS_LEVELING && !PLANNER_LEVELING
     planner.apply_leveling(raw);
   #endif
 
   planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       , inv_duration
     #endif
   );
 
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    raw[l_axis] = start_L;
+  #endif
   COPY(current_position, raw);
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 5e52d54c9b..0ae3f8574f 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -28,24 +28,20 @@
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/temperature.h"
 
 #if ENABLED(DELTA)
   #include "../../module/delta.h"
 #elif ENABLED(SCARA)
   #include "../../module/scara.h"
 #endif
 
-#if HAS_FEEDRATE_SCALING && ENABLED(AUTO_BED_LEVELING_BILINEAR)
-  #include "../../feature/bedlevel/abl/abl.h"
-#endif
-
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
 
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
@@ -132,34 +128,26 @@ void plan_arc(
               cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
-  millis_t next_idle_ms = millis() + 200UL;
-
-  #if HAS_FEEDRATE_SCALING
-    // SCARA needs to scale the feed rate from mm/s to degrees/s
-    const float inv_segment_length = 1.0f / float(MM_PER_ARC_SEGMENT),
-                inverse_secs = inv_segment_length * fr_mm_s;
-    float oldA = planner.position_float[A_AXIS],
-          oldB = planner.position_float[B_AXIS]
-          #if ENABLED(DELTA_FEEDRATE_SCALING)
-            , oldC = planner.position_float[C_AXIS]
-          #endif
-          ;
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    const float inv_duration = fr_mm_s / MM_PER_ARC_SEGMENT;
   #endif
 
+  millis_t next_idle_ms = millis() + 200UL;
+
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
       next_idle_ms = millis() + 200UL;
       idle();
@@ -189,71 +177,46 @@ void plan_arc(
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     raw[l_axis] += linear_per_segment;
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
-    #if HAS_FEEDRATE_SCALING
-      inverse_kinematics(raw);
-      ADJUST_DELTA(raw);
+    #if HAS_LEVELING && !PLANNER_LEVELING
+      planner.apply_leveling(raw);
     #endif
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      // For SCARA scale the feed rate from mm/s to degrees/s
-      // i.e., Complete the angular vector in the given time.
-      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT))
-        break;
-      oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
-    #elif ENABLED(DELTA_FEEDRATE_SCALING)
-      // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
-      // i.e., Complete the linear vector in the given time.
-      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT))
-        break;
-      oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
-    #elif HAS_UBL_AND_CURVES
-      float pos[XYZ] = { raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS] };
-      planner.apply_leveling(pos);
-      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT))
-        break;
-    #else
-      if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder))
-        break;
-    #endif
+    if (!planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        , inv_duration
+      #endif
+    ))
+      break;
   }
 
   // Ensure last segment arrives at target location.
-  #if HAS_FEEDRATE_SCALING
-    inverse_kinematics(cart);
-    ADJUST_DELTA(cart);
-  #endif
+  COPY(raw, cart);
 
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
-    const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
-    if (diff2)
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT);
-  #elif ENABLED(DELTA_FEEDRATE_SCALING)
-    const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
-    if (diff2)
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT);
-  #elif HAS_UBL_AND_CURVES
-    float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
-    planner.apply_leveling(pos);
-    planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT);
-  #else
-    planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
+  #if HAS_LEVELING && !PLANNER_LEVELING
+    planner.apply_leveling(raw);
   #endif
 
-  COPY(current_position, cart);
+  planner.buffer_line(raw, fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      , inv_duration
+    #endif
+  );
+
+  COPY(current_position, raw);
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.
  *    At least one of the IJ parameters is required.

commit d10f29ae2e765803070ad024685972aa834243e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 6 01:43:12 2018 -0500

    Pass segment length in G2-G3

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 09e920846c..5e52d54c9b 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -197,58 +197,58 @@ void plan_arc(
     clamp_to_software_endstops(raw);
 
     #if HAS_FEEDRATE_SCALING
       inverse_kinematics(raw);
       ADJUST_DELTA(raw);
     #endif
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
-      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
+      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT))
         break;
       oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
     #elif ENABLED(DELTA_FEEDRATE_SCALING)
       // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
       // i.e., Complete the linear vector in the given time.
-      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder))
+      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT))
         break;
       oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
     #elif HAS_UBL_AND_CURVES
       float pos[XYZ] = { raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS] };
       planner.apply_leveling(pos);
-      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder))
+      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT))
         break;
     #else
       if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder))
         break;
     #endif
   }
 
   // Ensure last segment arrives at target location.
   #if HAS_FEEDRATE_SCALING
     inverse_kinematics(cart);
     ADJUST_DELTA(cart);
   #endif
 
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
     if (diff2)
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT);
   #elif ENABLED(DELTA_FEEDRATE_SCALING)
     const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
     if (diff2)
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder, MM_PER_ARC_SEGMENT);
   #elif HAS_UBL_AND_CURVES
     float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     planner.apply_leveling(pos);
-    planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder);
+    planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder, MM_PER_ARC_SEGMENT);
   #else
     planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   #endif
 
   COPY(current_position, cart);
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 46cd9daa37..09e920846c 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -85,21 +85,21 @@ void plan_arc(
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
     angular_travel = RADIANS(360);
 
   const float flat_mm = radius * angular_travel,
               mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
-  if (mm_of_travel < 0.001) return;
+  if (mm_of_travel < 0.001f) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;
    *
@@ -122,35 +122,35 @@ void plan_arc(
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
   float raw[XYZE];
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
-              cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
+              cos_T = 1 - 0.5f * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if HAS_FEEDRATE_SCALING
     // SCARA needs to scale the feed rate from mm/s to degrees/s
-    const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
+    const float inv_segment_length = 1.0f / float(MM_PER_ARC_SEGMENT),
                 inverse_secs = inv_segment_length * fr_mm_s;
     float oldA = planner.position_float[A_AXIS],
           oldB = planner.position_float[B_AXIS]
           #if ENABLED(DELTA_FEEDRATE_SCALING)
             , oldC = planner.position_float[C_AXIS]
           #endif
           ;
   #endif
 
   #if N_ARC_CORRECTION > 1
@@ -282,33 +282,34 @@ void GcodeSuite::G2_G3(const bool clockwise) {
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
     get_destination_from_command();
 
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;
     #endif
 
-    float arc_offset[2] = { 0.0, 0.0 };
+    float arc_offset[2] = { 0, 0 };
     if (parser.seenval('R')) {
       const float r = parser.value_linear_units(),
                   p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
                   p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
       if (r && (p2 != p1 || q2 != q1)) {
-        const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
-                    dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
-                    d = HYPOT(dx, dy),                          // Linear distance between the points
-                    h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
-                    mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
-                    sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
-                    cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
+        const float e = clockwise ^ (r < 0) ? -1 : 1,            // clockwise -1/1, counterclockwise 1/-1
+                    dx = p2 - p1, dy = q2 - q1,                  // X and Y differences
+                    d = HYPOT(dx, dy),                           // Linear distance between the points
+                    dinv = 1/d,                                  // Inverse of d
+                    h = SQRT(sq(r) - sq(d * 0.5f)),              // Distance to the arc pivot-point
+                    mx = (p1 + p2) * 0.5f, my = (q1 + q2) * 0.5f,// Point between the two points
+                    sx = -dy * dinv, sy = dx * dinv,             // Slope of the perpendicular bisector
+                    cx = mx + e * h * sx, cy = my + e * h * sy;  // Pivot-point of the arc
         arc_offset[0] = cx - p1;
         arc_offset[1] = cy - q1;
       }
     }
     else {
       if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
       if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
     }
 
     if (arc_offset[0] || arc_offset[1]) {

commit 8eaac0dab37b4376ac06f1fefd469cdd6bc80673
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 13:44:27 2018 -0500

    Add delta feedrate scaling (#11153)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 4c2c5ac913..46cd9daa37 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -28,21 +28,21 @@
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/temperature.h"
 
 #if ENABLED(DELTA)
   #include "../../module/delta.h"
 #elif ENABLED(SCARA)
   #include "../../module/scara.h"
 #endif
 
-#if ENABLED(SCARA_FEEDRATE_SCALING) && ENABLED(AUTO_BED_LEVELING_BILINEAR)
+#if HAS_FEEDRATE_SCALING && ENABLED(AUTO_BED_LEVELING_BILINEAR)
   #include "../../feature/bedlevel/abl/abl.h"
 #endif
 
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
 
 /**
  * Plan an arc in 2 dimensions
@@ -134,26 +134,30 @@ void plan_arc(
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   millis_t next_idle_ms = millis() + 200UL;
 
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
+  #if HAS_FEEDRATE_SCALING
     // SCARA needs to scale the feed rate from mm/s to degrees/s
     const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
                 inverse_secs = inv_segment_length * fr_mm_s;
     float oldA = planner.position_float[A_AXIS],
-          oldB = planner.position_float[B_AXIS];
+          oldB = planner.position_float[B_AXIS]
+          #if ENABLED(DELTA_FEEDRATE_SCALING)
+            , oldC = planner.position_float[C_AXIS]
+          #endif
+          ;
   #endif
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
@@ -185,46 +189,62 @@ void plan_arc(
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     raw[l_axis] += linear_per_segment;
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
+    #if HAS_FEEDRATE_SCALING
+      inverse_kinematics(raw);
+      ADJUST_DELTA(raw);
+    #endif
+
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
-      inverse_kinematics(raw);
-      ADJUST_DELTA(raw);
       if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
         break;
       oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+    #elif ENABLED(DELTA_FEEDRATE_SCALING)
+      // For DELTA scale the feed rate from Effector mm/s to Carriage mm/s
+      // i.e., Complete the linear vector in the given time.
+      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], SQRT(sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC)) * inverse_secs, active_extruder))
+        break;
+      oldA = delta[A_AXIS]; oldB = delta[B_AXIS]; oldC = delta[C_AXIS];
     #elif HAS_UBL_AND_CURVES
       float pos[XYZ] = { raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS] };
       planner.apply_leveling(pos);
       if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder))
         break;
     #else
       if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder))
         break;
     #endif
   }
 
   // Ensure last segment arrives at target location.
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
+  #if HAS_FEEDRATE_SCALING
     inverse_kinematics(cart);
     ADJUST_DELTA(cart);
+  #endif
+
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
     const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
     if (diff2)
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+  #elif ENABLED(DELTA_FEEDRATE_SCALING)
+    const float diff2 = sq(delta[A_AXIS] - oldA) + sq(delta[B_AXIS] - oldB) + sq(delta[C_AXIS] - oldC);
+    if (diff2)
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
   #elif HAS_UBL_AND_CURVES
     float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     planner.apply_leveling(pos);
     planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder);
   #else
     planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   #endif
 
   COPY(current_position, cart);
 } // plan_arc

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index f5c98c934d..4c2c5ac913 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -190,28 +190,31 @@ void plan_arc(
     raw[l_axis] += linear_per_segment;
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       inverse_kinematics(raw);
       ADJUST_DELTA(raw);
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+      if (!planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder))
+        break;
       oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
     #elif HAS_UBL_AND_CURVES
       float pos[XYZ] = { raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS] };
       planner.apply_leveling(pos);
-      planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder);
+      if (!planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder))
+        break;
     #else
-      planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+      if (!planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder))
+        break;
     #endif
   }
 
   // Ensure last segment arrives at target location.
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     inverse_kinematics(cart);
     ADJUST_DELTA(cart);
     const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
     if (diff2)
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 8ce54978ca..f5c98c934d 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -84,21 +84,21 @@ void plan_arc(
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
     angular_travel = RADIANS(360);
 
   const float flat_mm = radius * angular_travel,
-              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : FABS(flat_mm);
+              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : ABS(flat_mm);
   if (mm_of_travel < 0.001) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;

commit c43235dd398e0e0bf0f2d8a7a5dfcefd8175c35c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 11 00:36:04 2018 -0500

    Remove non-special comments

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 2596e6ca8d..8ce54978ca 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -216,23 +216,20 @@ void plan_arc(
     if (diff2)
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
   #elif HAS_UBL_AND_CURVES
     float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     planner.apply_leveling(pos);
     planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder);
   #else
     planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   #endif
 
-  // As far as the parser is concerned, the position is now == target. In reality the
-  // motion control system might still be processing the action and the real tool position
-  // in any intermediate location.
   COPY(current_position, cart);
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.

commit 613a3be16716cb31f184164b4ef658d5e19db568
Author: ManuelMcLure <manuel@mclure.org>
Date:   Thu May 10 22:30:51 2018 -0700

    Remove hidden dependencies on destination. Fixes #10686. (#10691)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 47868bb0c6..2596e6ca8d 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -219,21 +219,21 @@ void plan_arc(
     float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     planner.apply_leveling(pos);
     planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder);
   #else
     planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   #endif
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
-  set_current_from_destination();
+  COPY(current_position, cart);
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.
  *    At least one of the IJ parameters is required.

commit 19f189b4e5e10bdbdb3b28d94fa180f74cdbd654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 8 11:10:45 2018 -0500

    Add UBL support for G2/G3 and G5 (#10648)

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 046f8db862..47868bb0c6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -192,32 +192,40 @@ void plan_arc(
 
     clamp_to_software_endstops(raw);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       inverse_kinematics(raw);
       ADJUST_DELTA(raw);
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
       oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+    #elif HAS_UBL_AND_CURVES
+      float pos[XYZ] = { raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS] };
+      planner.apply_leveling(pos);
+      planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], raw[E_AXIS], fr_mm_s, active_extruder);
     #else
       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
     #endif
   }
 
   // Ensure last segment arrives at target location.
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     inverse_kinematics(cart);
     ADJUST_DELTA(cart);
     const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
     if (diff2)
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+  #elif HAS_UBL_AND_CURVES
+    float pos[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
+    planner.apply_leveling(pos);
+    planner.buffer_segment(pos[X_AXIS], pos[Y_AXIS], pos[Z_AXIS], cart[E_AXIS], fr_mm_s, active_extruder);
   #else
     planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   #endif
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 

commit e8e60263c8e454454d126f9154cf5c7ac3213725
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 5 15:47:56 2018 -0500

    Scale feedrate (mm/s to deg/s) for SCARA

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 95ebba41eb..046f8db862 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -28,20 +28,24 @@
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/temperature.h"
 
 #if ENABLED(DELTA)
   #include "../../module/delta.h"
 #elif ENABLED(SCARA)
   #include "../../module/scara.h"
 #endif
 
+#if ENABLED(SCARA_FEEDRATE_SCALING) && ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  #include "../../feature/bedlevel/abl/abl.h"
+#endif
+
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
 
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
@@ -130,20 +134,28 @@ void plan_arc(
   // Initialize the linear axis
   raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
   raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   millis_t next_idle_ms = millis() + 200UL;
 
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    // SCARA needs to scale the feed rate from mm/s to degrees/s
+    const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
+                inverse_secs = inv_segment_length * fr_mm_s;
+    float oldA = planner.position_float[A_AXIS],
+          oldB = planner.position_float[B_AXIS];
+  #endif
+
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
       next_idle_ms = millis() + 200UL;
       idle();
@@ -173,25 +185,42 @@ void plan_arc(
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     raw[l_axis] += linear_per_segment;
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
-    planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      // For SCARA scale the feed rate from mm/s to degrees/s
+      // i.e., Complete the angular vector in the given time.
+      inverse_kinematics(raw);
+      ADJUST_DELTA(raw);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+      oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+    #else
+      planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+    #endif
   }
 
   // Ensure last segment arrives at target location.
-  planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    inverse_kinematics(cart);
+    ADJUST_DELTA(cart);
+    const float diff2 = HYPOT2(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB);
+    if (diff2)
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], SQRT(diff2) * inverse_secs, active_extruder);
+  #else
+    planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
+  #endif
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 6ba2aa41a6..95ebba41eb 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -262,21 +262,21 @@ void GcodeSuite::G2_G3(const bool clockwise) {
         if (!WITHIN(circles_to_do, 0, 100)) {
           SERIAL_ERROR_START();
           SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
         }
         while (circles_to_do--)
           plan_arc(current_position, arc_offset, clockwise);
       #endif
 
       // Send the arc to the planner
       plan_arc(destination, arc_offset, clockwise);
-      refresh_cmd_timeout();
+      reset_stepper_timeout();
     }
     else {
       // Bad arguments
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
     }
   }
 }
 
 #endif // ARC_SUPPORT

commit 91db7930dc7c8e429f579549544183ac94c59200
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 1 04:30:41 2018 -0600

    Drop SCARA_FEEDRATE_SCALING
    
    The updated planner takes the length of the move, so this pre-calculation is no longer needed.

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 46dbd8b4f0..6ba2aa41a6 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -134,28 +134,20 @@ void plan_arc(
   raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
-    // SCARA needs to scale the feed rate from mm/s to degrees/s
-    const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
-                inverse_secs = inv_segment_length * fr_mm_s;
-    float oldA = stepper.get_axis_position_degrees(A_AXIS),
-          oldB = stepper.get_axis_position_degrees(B_AXIS);
-  #endif
-
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
       next_idle_ms = millis() + 200UL;
       idle();
     }
 
     #if N_ARC_CORRECTION > 1
       if (--arc_recalc_count) {
@@ -181,40 +173,25 @@ void plan_arc(
     }
 
     // Update raw location
     raw[p_axis] = center_P + r_P;
     raw[q_axis] = center_Q + r_Q;
     raw[l_axis] += linear_per_segment;
     raw[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(raw);
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
-      // For SCARA scale the feed rate from mm/s to degrees/s.
-      // i.e., Complete the angular vector in the given time.
-      inverse_kinematics(raw);
-      ADJUST_DELTA(raw);
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
-      oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
-    #else
-      planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
-    #endif
+    planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
   }
 
   // Ensure last segment arrives at target location.
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
-    inverse_kinematics(cart);
-    ADJUST_DELTA(cart);
-    planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
-  #else
-    planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
-  #endif
+  planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 377108619bf7cab77741c004f8c0975626c87db7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 11 03:34:25 2018 -0600

    Fix plan_arc clockwise (G2)
    
    Fix #9482

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 490a063ff2..46dbd8b4f0 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -80,21 +80,21 @@ void plan_arc(
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
     angular_travel = RADIANS(360);
 
   const float flat_mm = radius * angular_travel,
-              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : flat_mm;
+              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : FABS(flat_mm);
   if (mm_of_travel < 0.001) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;

commit 9644fe1839429bba2ac5fd61a001d6ad79d5c1d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 19:04:05 2018 -0600

    Lightly optimize arc length calculation

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 921a334500..490a063ff2 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -79,21 +79,22 @@ void plan_arc(
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
   if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
     angular_travel = RADIANS(360);
 
-  const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
+  const float flat_mm = radius * angular_travel,
+              mm_of_travel = linear_travel ? HYPOT(flat_mm, linear_travel) : flat_mm;
   if (mm_of_travel < 0.001) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
    * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
    *     r_T = [cos(phi) -sin(phi);
    *            sin(phi)  cos(phi)] * r ;

commit c6946084505149b2d20e0129eb13130f7a6af53d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 21:43:39 2017 -0600

    Apply SCARA_FEEDRATE_SCALING to G2/G3

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index c369be034a..921a334500 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -22,20 +22,26 @@
 
 #include "../../inc/MarlinConfig.h"
 
 #if ENABLED(ARC_SUPPORT)
 
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/planner.h"
 #include "../../module/temperature.h"
 
+#if ENABLED(DELTA)
+  #include "../../module/delta.h"
+#elif ENABLED(SCARA)
+  #include "../../module/scara.h"
+#endif
+
 #if N_ARC_CORRECTION < 1
   #undef N_ARC_CORRECTION
   #define N_ARC_CORRECTION 1
 #endif
 
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
@@ -106,41 +112,49 @@ void plan_arc(
    * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
    * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
    * issue for CNC machines with the single precision Arduino calculations.
    *
    * This approximation also allows plan_arc to immediately insert a line segment into the planner
    * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
    * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
    * This is important when there are successive arc motions.
    */
   // Vector rotation matrix values
-  float arc_target[XYZE];
+  float raw[XYZE];
   const float theta_per_segment = angular_travel / segments,
               linear_per_segment = linear_travel / segments,
               extruder_per_segment = extruder_travel / segments,
               sin_T = theta_per_segment,
               cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
 
   // Initialize the linear axis
-  arc_target[l_axis] = current_position[l_axis];
+  raw[l_axis] = current_position[l_axis];
 
   // Initialize the extruder axis
-  arc_target[E_AXIS] = current_position[E_AXIS];
+  raw[E_AXIS] = current_position[E_AXIS];
 
   const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
 
   millis_t next_idle_ms = millis() + 200UL;
 
   #if N_ARC_CORRECTION > 1
     int8_t arc_recalc_count = N_ARC_CORRECTION;
   #endif
 
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    // SCARA needs to scale the feed rate from mm/s to degrees/s
+    const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
+                inverse_secs = inv_segment_length * fr_mm_s;
+    float oldA = stepper.get_axis_position_degrees(A_AXIS),
+          oldB = stepper.get_axis_position_degrees(B_AXIS);
+  #endif
+
   for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
 
     thermalManager.manage_heater();
     if (ELAPSED(millis(), next_idle_ms)) {
       next_idle_ms = millis() + 200UL;
       idle();
     }
 
     #if N_ARC_CORRECTION > 1
       if (--arc_recalc_count) {
@@ -158,33 +172,48 @@ void plan_arc(
 
       // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
       // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
       // To reduce stuttering, the sin and cos could be computed at different times.
       // For now, compute both at the same time.
       const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
       r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
       r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
     }
 
-    // Update arc_target location
-    arc_target[p_axis] = center_P + r_P;
-    arc_target[q_axis] = center_Q + r_Q;
-    arc_target[l_axis] += linear_per_segment;
-    arc_target[E_AXIS] += extruder_per_segment;
-
-    clamp_to_software_endstops(arc_target);
-
-    planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
+    // Update raw location
+    raw[p_axis] = center_P + r_P;
+    raw[q_axis] = center_Q + r_Q;
+    raw[l_axis] += linear_per_segment;
+    raw[E_AXIS] += extruder_per_segment;
+
+    clamp_to_software_endstops(raw);
+
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      // For SCARA scale the feed rate from mm/s to degrees/s.
+      // i.e., Complete the angular vector in the given time.
+      inverse_kinematics(raw);
+      ADJUST_DELTA(raw);
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+      oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
+    #else
+      planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
+    #endif
   }
 
   // Ensure last segment arrives at target location.
-  planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    inverse_kinematics(cart);
+    ADJUST_DELTA(cart);
+    planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
+  #else
+    planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
+  #endif
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index a805c710f5..c369be034a 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -37,54 +37,54 @@
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  * Arcs should only be made relatively large (over 5mm), as larger arcs with
  * larger segments will tend to be more efficient. Your slicer should have
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
-  float rtarget[XYZE], // Destination position
-  float *offset,       // Center of rotation relative to current_position
-  uint8_t clockwise    // Clockwise?
+  const float (&cart)[XYZE],  // Destination position
+  const float (&offset)[2],   // Center of rotation relative to current_position
+  const uint8_t clockwise     // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   float r_P = -offset[0], r_Q = -offset[1];
 
   const float radius = HYPOT(r_P, r_Q),
               center_P = current_position[p_axis] - r_P,
               center_Q = current_position[q_axis] - r_Q,
-              rt_X = rtarget[p_axis] - center_P,
-              rt_Y = rtarget[q_axis] - center_Q,
-              linear_travel = rtarget[l_axis] - current_position[l_axis],
-              extruder_travel = rtarget[E_AXIS] - current_position[E_AXIS];
+              rt_X = cart[p_axis] - center_P,
+              rt_Y = cart[q_axis] - center_Q,
+              linear_travel = cart[l_axis] - current_position[l_axis],
+              extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
-  if (angular_travel == 0 && current_position[p_axis] == rtarget[p_axis] && current_position[q_axis] == rtarget[q_axis])
+  if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
     angular_travel = RADIANS(360);
 
   const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
   if (mm_of_travel < 0.001) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
@@ -170,21 +170,21 @@ void plan_arc(
     arc_target[q_axis] = center_Q + r_Q;
     arc_target[l_axis] += linear_per_segment;
     arc_target[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(arc_target);
 
     planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
   }
 
   // Ensure last segment arrives at target location.
-  planner.buffer_line_kinematic(rtarget, fr_mm_s, active_extruder);
+  planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 85a62bbf46c13b4e01ecafc9f3ce50ed92f67f3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 6 22:57:05 2017 -0600

    Misc. fixes to compiler warnings, etc.

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 88cd8a83e3..a805c710f5 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -44,20 +44,21 @@
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
   float rtarget[XYZE], // Destination position
   float *offset,       // Center of rotation relative to current_position
   uint8_t clockwise    // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
+      default:
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   float r_P = -offset[0], r_Q = -offset[1];

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 96655b62c9..88cd8a83e3 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -37,53 +37,53 @@
 /**
  * Plan an arc in 2 dimensions
  *
  * The arc is approximated by generating many small linear segments.
  * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  * Arcs should only be made relatively large (over 5mm), as larger arcs with
  * larger segments will tend to be more efficient. Your slicer should have
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
-  float logical[XYZE], // Destination position
+  float rtarget[XYZE], // Destination position
   float *offset,       // Center of rotation relative to current_position
   uint8_t clockwise    // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
     switch (gcode.workspace_plane) {
       case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
       case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
       case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   float r_P = -offset[0], r_Q = -offset[1];
 
   const float radius = HYPOT(r_P, r_Q),
               center_P = current_position[p_axis] - r_P,
               center_Q = current_position[q_axis] - r_Q,
-              rt_X = logical[p_axis] - center_P,
-              rt_Y = logical[q_axis] - center_Q,
-              linear_travel = logical[l_axis] - current_position[l_axis],
-              extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
+              rt_X = rtarget[p_axis] - center_P,
+              rt_Y = rtarget[q_axis] - center_Q,
+              linear_travel = rtarget[l_axis] - current_position[l_axis],
+              extruder_travel = rtarget[E_AXIS] - current_position[E_AXIS];
 
   // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   if (angular_travel < 0) angular_travel += RADIANS(360);
   if (clockwise) angular_travel -= RADIANS(360);
 
   // Make a circle if the angular rotation is 0 and the target is current position
-  if (angular_travel == 0 && current_position[p_axis] == logical[p_axis] && current_position[q_axis] == logical[q_axis])
+  if (angular_travel == 0 && current_position[p_axis] == rtarget[p_axis] && current_position[q_axis] == rtarget[q_axis])
     angular_travel = RADIANS(360);
 
   const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
   if (mm_of_travel < 0.001) return;
 
   uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
   if (segments == 0) segments = 1;
 
   /**
    * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
@@ -169,21 +169,21 @@ void plan_arc(
     arc_target[q_axis] = center_Q + r_Q;
     arc_target[l_axis] += linear_per_segment;
     arc_target[E_AXIS] += extruder_per_segment;
 
     clamp_to_software_endstops(arc_target);
 
     planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
   }
 
   // Ensure last segment arrives at target location.
-  planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
+  planner.buffer_line_kinematic(rtarget, fr_mm_s, active_extruder);
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
   set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 15fd7f7b9e..96655b62c9 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -174,21 +174,21 @@ void plan_arc(
 
     planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
   }
 
   // Ensure last segment arrives at target location.
   planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
 
   // As far as the parser is concerned, the position is now == target. In reality the
   // motion control system might still be processing the action and the real tool position
   // in any intermediate location.
-  set_current_to_destination();
+  set_current_from_destination();
 } // plan_arc
 
 /**
  * G2: Clockwise Arc
  * G3: Counterclockwise Arc
  *
  * This command has two forms: IJ-form and R-form.
  *
  *  - I specifies an X offset. J specifies a Y offset.
  *    At least one of the IJ parameters is required.

commit 90af1fe5eefd353c9fb9c40430f45031147fd675
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:34:58 2017 -0500

    Implement NO_MOTION_BEFORE_HOMING option

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 44f0f53ba7..15fd7f7b9e 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -204,21 +204,21 @@ void plan_arc(
  *
  *  - P specifies the number of full circles to do
  *    before the specified arc move.
  *
  *  Examples:
  *
  *    G2 I10           ; CW circle centered at X+10
  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
  */
 void GcodeSuite::G2_G3(const bool clockwise) {
-  if (IsRunning()) {
+  if (MOTION_CONDITIONS) {
 
     #if ENABLED(SF_ARC_FIX)
       const bool relative_mode_backup = relative_mode;
       relative_mode = true;
     #endif
 
     get_destination_from_command();
 
     #if ENABLED(SF_ARC_FIX)
       relative_mode = relative_mode_backup;

commit 9b4aa5ea8bb0baf78a3a2959e4f603fe6e9f14e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:08:48 2017 -0500

    Move G17-G19 to cpp

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
index 2986a86a65..44f0f53ba7 100644
--- a/Marlin/src/gcode/motion/G2_G3.cpp
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -43,24 +43,24 @@
  * larger segments will tend to be more efficient. Your slicer should have
  * options for G2/G3 arc generation. In future these options may be GCode tunable.
  */
 void plan_arc(
   float logical[XYZE], // Destination position
   float *offset,       // Center of rotation relative to current_position
   uint8_t clockwise    // Clockwise?
 ) {
   #if ENABLED(CNC_WORKSPACE_PLANES)
     AxisEnum p_axis, q_axis, l_axis;
-    switch (workspace_plane) {
-      case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
-      case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
-      case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
+    switch (gcode.workspace_plane) {
+      case GcodeSuite::PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
+      case GcodeSuite::PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
+      case GcodeSuite::PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
     }
   #else
     constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
   #endif
 
   // Radius vector from center to current location
   float r_P = -offset[0], r_Q = -offset[1];
 
   const float radius = HYPOT(r_P, r_Q),
               center_P = current_position[p_axis] - r_P,

commit 4007cbfe9e1316b23e594281f520ac49e36f2561
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 20:57:52 2017 -0500

    Move G2_G3 to cpp

diff --git a/Marlin/src/gcode/motion/G2_G3.cpp b/Marlin/src/gcode/motion/G2_G3.cpp
new file mode 100644
index 0000000000..2986a86a65
--- /dev/null
+++ b/Marlin/src/gcode/motion/G2_G3.cpp
@@ -0,0 +1,274 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(ARC_SUPPORT)
+
+#include "../gcode.h"
+#include "../../module/motion.h"
+#include "../../module/planner.h"
+#include "../../module/temperature.h"
+
+#if N_ARC_CORRECTION < 1
+  #undef N_ARC_CORRECTION
+  #define N_ARC_CORRECTION 1
+#endif
+
+/**
+ * Plan an arc in 2 dimensions
+ *
+ * The arc is approximated by generating many small linear segments.
+ * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
+ * Arcs should only be made relatively large (over 5mm), as larger arcs with
+ * larger segments will tend to be more efficient. Your slicer should have
+ * options for G2/G3 arc generation. In future these options may be GCode tunable.
+ */
+void plan_arc(
+  float logical[XYZE], // Destination position
+  float *offset,       // Center of rotation relative to current_position
+  uint8_t clockwise    // Clockwise?
+) {
+  #if ENABLED(CNC_WORKSPACE_PLANES)
+    AxisEnum p_axis, q_axis, l_axis;
+    switch (workspace_plane) {
+      case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
+      case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
+      case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
+    }
+  #else
+    constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
+  #endif
+
+  // Radius vector from center to current location
+  float r_P = -offset[0], r_Q = -offset[1];
+
+  const float radius = HYPOT(r_P, r_Q),
+              center_P = current_position[p_axis] - r_P,
+              center_Q = current_position[q_axis] - r_Q,
+              rt_X = logical[p_axis] - center_P,
+              rt_Y = logical[q_axis] - center_Q,
+              linear_travel = logical[l_axis] - current_position[l_axis],
+              extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
+
+  // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
+  float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
+  if (angular_travel < 0) angular_travel += RADIANS(360);
+  if (clockwise) angular_travel -= RADIANS(360);
+
+  // Make a circle if the angular rotation is 0 and the target is current position
+  if (angular_travel == 0 && current_position[p_axis] == logical[p_axis] && current_position[q_axis] == logical[q_axis])
+    angular_travel = RADIANS(360);
+
+  const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
+  if (mm_of_travel < 0.001) return;
+
+  uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
+  if (segments == 0) segments = 1;
+
+  /**
+   * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
+   * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
+   *     r_T = [cos(phi) -sin(phi);
+   *            sin(phi)  cos(phi)] * r ;
+   *
+   * For arc generation, the center of the circle is the axis of rotation and the radius vector is
+   * defined from the circle center to the initial position. Each line segment is formed by successive
+   * vector rotations. This requires only two cos() and sin() computations to form the rotation
+   * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
+   * all double numbers are single precision on the Arduino. (True double precision will not have
+   * round off issues for CNC applications.) Single precision error can accumulate to be greater than
+   * tool precision in some cases. Therefore, arc path correction is implemented.
+   *
+   * Small angle approximation may be used to reduce computation overhead further. This approximation
+   * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
+   * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
+   * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
+   * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
+   * issue for CNC machines with the single precision Arduino calculations.
+   *
+   * This approximation also allows plan_arc to immediately insert a line segment into the planner
+   * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
+   * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
+   * This is important when there are successive arc motions.
+   */
+  // Vector rotation matrix values
+  float arc_target[XYZE];
+  const float theta_per_segment = angular_travel / segments,
+              linear_per_segment = linear_travel / segments,
+              extruder_per_segment = extruder_travel / segments,
+              sin_T = theta_per_segment,
+              cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
+
+  // Initialize the linear axis
+  arc_target[l_axis] = current_position[l_axis];
+
+  // Initialize the extruder axis
+  arc_target[E_AXIS] = current_position[E_AXIS];
+
+  const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
+
+  millis_t next_idle_ms = millis() + 200UL;
+
+  #if N_ARC_CORRECTION > 1
+    int8_t arc_recalc_count = N_ARC_CORRECTION;
+  #endif
+
+  for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
+
+    thermalManager.manage_heater();
+    if (ELAPSED(millis(), next_idle_ms)) {
+      next_idle_ms = millis() + 200UL;
+      idle();
+    }
+
+    #if N_ARC_CORRECTION > 1
+      if (--arc_recalc_count) {
+        // Apply vector rotation matrix to previous r_P / 1
+        const float r_new_Y = r_P * sin_T + r_Q * cos_T;
+        r_P = r_P * cos_T - r_Q * sin_T;
+        r_Q = r_new_Y;
+      }
+      else
+    #endif
+    {
+      #if N_ARC_CORRECTION > 1
+        arc_recalc_count = N_ARC_CORRECTION;
+      #endif
+
+      // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
+      // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
+      // To reduce stuttering, the sin and cos could be computed at different times.
+      // For now, compute both at the same time.
+      const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
+      r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
+      r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
+    }
+
+    // Update arc_target location
+    arc_target[p_axis] = center_P + r_P;
+    arc_target[q_axis] = center_Q + r_Q;
+    arc_target[l_axis] += linear_per_segment;
+    arc_target[E_AXIS] += extruder_per_segment;
+
+    clamp_to_software_endstops(arc_target);
+
+    planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
+  }
+
+  // Ensure last segment arrives at target location.
+  planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
+
+  // As far as the parser is concerned, the position is now == target. In reality the
+  // motion control system might still be processing the action and the real tool position
+  // in any intermediate location.
+  set_current_to_destination();
+} // plan_arc
+
+/**
+ * G2: Clockwise Arc
+ * G3: Counterclockwise Arc
+ *
+ * This command has two forms: IJ-form and R-form.
+ *
+ *  - I specifies an X offset. J specifies a Y offset.
+ *    At least one of the IJ parameters is required.
+ *    X and Y can be omitted to do a complete circle.
+ *    The given XY is not error-checked. The arc ends
+ *     based on the angle of the destination.
+ *    Mixing I or J with R will throw an error.
+ *
+ *  - R specifies the radius. X or Y is required.
+ *    Omitting both X and Y will throw an error.
+ *    X or Y must differ from the current XY.
+ *    Mixing R with I or J will throw an error.
+ *
+ *  - P specifies the number of full circles to do
+ *    before the specified arc move.
+ *
+ *  Examples:
+ *
+ *    G2 I10           ; CW circle centered at X+10
+ *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
+ */
+void GcodeSuite::G2_G3(const bool clockwise) {
+  if (IsRunning()) {
+
+    #if ENABLED(SF_ARC_FIX)
+      const bool relative_mode_backup = relative_mode;
+      relative_mode = true;
+    #endif
+
+    get_destination_from_command();
+
+    #if ENABLED(SF_ARC_FIX)
+      relative_mode = relative_mode_backup;
+    #endif
+
+    float arc_offset[2] = { 0.0, 0.0 };
+    if (parser.seenval('R')) {
+      const float r = parser.value_linear_units(),
+                  p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
+                  p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
+      if (r && (p2 != p1 || q2 != q1)) {
+        const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
+                    dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
+                    d = HYPOT(dx, dy),                          // Linear distance between the points
+                    h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
+                    mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
+                    sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
+                    cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
+        arc_offset[0] = cx - p1;
+        arc_offset[1] = cy - q1;
+      }
+    }
+    else {
+      if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
+      if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
+    }
+
+    if (arc_offset[0] || arc_offset[1]) {
+
+      #if ENABLED(ARC_P_CIRCLES)
+        // P indicates number of circles to do
+        int8_t circles_to_do = parser.byteval('P');
+        if (!WITHIN(circles_to_do, 0, 100)) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
+        }
+        while (circles_to_do--)
+          plan_arc(current_position, arc_offset, clockwise);
+      #endif
+
+      // Send the arc to the planner
+      plan_arc(destination, arc_offset, clockwise);
+      refresh_cmd_timeout();
+    }
+    else {
+      // Bad arguments
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
+    }
+  }
+}
+
+#endif // ARC_SUPPORT
